
Stm32F769bit6.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001f8  00200000  00200000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00028010  00200200  00200200  00010200  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00001858  00228210  00228210  00038210  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  00229a68  00229a68  00039a68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  00229a70  00229a70  00039a70  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  00229a74  00229a74  00039a74  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         0000007c  20000000  00229a78  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00015294  20000080  00229af4  00040080  2**5
                  ALLOC
  8 ._user_heap_stack 00008000  20015314  00229af4  00045314  2**0
                  ALLOC
  9 .sdram        006ff000  c0000000  c0000000  00050000  2**5
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  0004007c  2**0
                  CONTENTS, READONLY
 11 .debug_info   0003bf54  00000000  00000000  000400aa  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_abbrev 0000753d  00000000  00000000  0007bffe  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00002ca0  00000000  00000000  00083540  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000029e8  00000000  00000000  000861e0  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00018e63  00000000  00000000  00088bc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000d093  00000000  00000000  000a1a2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  000aeabe  2**0
                  CONTENTS, READONLY
 18 .debug_frame  0000c0d8  00000000  00000000  000aeb3c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00200200 <__do_global_dtors_aux>:
  200200:	b510      	push	{r4, lr}
  200202:	4c05      	ldr	r4, [pc, #20]	; (200218 <__do_global_dtors_aux+0x18>)
  200204:	7823      	ldrb	r3, [r4, #0]
  200206:	b933      	cbnz	r3, 200216 <__do_global_dtors_aux+0x16>
  200208:	4b04      	ldr	r3, [pc, #16]	; (20021c <__do_global_dtors_aux+0x1c>)
  20020a:	b113      	cbz	r3, 200212 <__do_global_dtors_aux+0x12>
  20020c:	4804      	ldr	r0, [pc, #16]	; (200220 <__do_global_dtors_aux+0x20>)
  20020e:	f3af 8000 	nop.w
  200212:	2301      	movs	r3, #1
  200214:	7023      	strb	r3, [r4, #0]
  200216:	bd10      	pop	{r4, pc}
  200218:	20000080 	.word	0x20000080
  20021c:	00000000 	.word	0x00000000
  200220:	002281f8 	.word	0x002281f8

00200224 <frame_dummy>:
  200224:	b508      	push	{r3, lr}
  200226:	4b03      	ldr	r3, [pc, #12]	; (200234 <frame_dummy+0x10>)
  200228:	b11b      	cbz	r3, 200232 <frame_dummy+0xe>
  20022a:	4903      	ldr	r1, [pc, #12]	; (200238 <frame_dummy+0x14>)
  20022c:	4803      	ldr	r0, [pc, #12]	; (20023c <frame_dummy+0x18>)
  20022e:	f3af 8000 	nop.w
  200232:	bd08      	pop	{r3, pc}
  200234:	00000000 	.word	0x00000000
  200238:	20000084 	.word	0x20000084
  20023c:	002281f8 	.word	0x002281f8

00200240 <strlen>:
  200240:	4603      	mov	r3, r0
  200242:	f813 2b01 	ldrb.w	r2, [r3], #1
  200246:	2a00      	cmp	r2, #0
  200248:	d1fb      	bne.n	200242 <strlen+0x2>
  20024a:	1a18      	subs	r0, r3, r0
  20024c:	3801      	subs	r0, #1
  20024e:	4770      	bx	lr

00200250 <__aeabi_frsub>:
  200250:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  200254:	e002      	b.n	20025c <__addsf3>
  200256:	bf00      	nop

00200258 <__aeabi_fsub>:
  200258:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0020025c <__addsf3>:
  20025c:	0042      	lsls	r2, r0, #1
  20025e:	bf1f      	itttt	ne
  200260:	ea5f 0341 	movsne.w	r3, r1, lsl #1
  200264:	ea92 0f03 	teqne	r2, r3
  200268:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
  20026c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  200270:	d06a      	beq.n	200348 <__addsf3+0xec>
  200272:	ea4f 6212 	mov.w	r2, r2, lsr #24
  200276:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
  20027a:	bfc1      	itttt	gt
  20027c:	18d2      	addgt	r2, r2, r3
  20027e:	4041      	eorgt	r1, r0
  200280:	4048      	eorgt	r0, r1
  200282:	4041      	eorgt	r1, r0
  200284:	bfb8      	it	lt
  200286:	425b      	neglt	r3, r3
  200288:	2b19      	cmp	r3, #25
  20028a:	bf88      	it	hi
  20028c:	4770      	bxhi	lr
  20028e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
  200292:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  200296:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
  20029a:	bf18      	it	ne
  20029c:	4240      	negne	r0, r0
  20029e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
  2002a2:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
  2002a6:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
  2002aa:	bf18      	it	ne
  2002ac:	4249      	negne	r1, r1
  2002ae:	ea92 0f03 	teq	r2, r3
  2002b2:	d03f      	beq.n	200334 <__addsf3+0xd8>
  2002b4:	f1a2 0201 	sub.w	r2, r2, #1
  2002b8:	fa41 fc03 	asr.w	ip, r1, r3
  2002bc:	eb10 000c 	adds.w	r0, r0, ip
  2002c0:	f1c3 0320 	rsb	r3, r3, #32
  2002c4:	fa01 f103 	lsl.w	r1, r1, r3
  2002c8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  2002cc:	d502      	bpl.n	2002d4 <__addsf3+0x78>
  2002ce:	4249      	negs	r1, r1
  2002d0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
  2002d4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
  2002d8:	d313      	bcc.n	200302 <__addsf3+0xa6>
  2002da:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
  2002de:	d306      	bcc.n	2002ee <__addsf3+0x92>
  2002e0:	0840      	lsrs	r0, r0, #1
  2002e2:	ea4f 0131 	mov.w	r1, r1, rrx
  2002e6:	f102 0201 	add.w	r2, r2, #1
  2002ea:	2afe      	cmp	r2, #254	; 0xfe
  2002ec:	d251      	bcs.n	200392 <__addsf3+0x136>
  2002ee:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
  2002f2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
  2002f6:	bf08      	it	eq
  2002f8:	f020 0001 	biceq.w	r0, r0, #1
  2002fc:	ea40 0003 	orr.w	r0, r0, r3
  200300:	4770      	bx	lr
  200302:	0049      	lsls	r1, r1, #1
  200304:	eb40 0000 	adc.w	r0, r0, r0
  200308:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
  20030c:	f1a2 0201 	sub.w	r2, r2, #1
  200310:	d1ed      	bne.n	2002ee <__addsf3+0x92>
  200312:	fab0 fc80 	clz	ip, r0
  200316:	f1ac 0c08 	sub.w	ip, ip, #8
  20031a:	ebb2 020c 	subs.w	r2, r2, ip
  20031e:	fa00 f00c 	lsl.w	r0, r0, ip
  200322:	bfaa      	itet	ge
  200324:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
  200328:	4252      	neglt	r2, r2
  20032a:	4318      	orrge	r0, r3
  20032c:	bfbc      	itt	lt
  20032e:	40d0      	lsrlt	r0, r2
  200330:	4318      	orrlt	r0, r3
  200332:	4770      	bx	lr
  200334:	f092 0f00 	teq	r2, #0
  200338:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
  20033c:	bf06      	itte	eq
  20033e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
  200342:	3201      	addeq	r2, #1
  200344:	3b01      	subne	r3, #1
  200346:	e7b5      	b.n	2002b4 <__addsf3+0x58>
  200348:	ea4f 0341 	mov.w	r3, r1, lsl #1
  20034c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
  200350:	bf18      	it	ne
  200352:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
  200356:	d021      	beq.n	20039c <__addsf3+0x140>
  200358:	ea92 0f03 	teq	r2, r3
  20035c:	d004      	beq.n	200368 <__addsf3+0x10c>
  20035e:	f092 0f00 	teq	r2, #0
  200362:	bf08      	it	eq
  200364:	4608      	moveq	r0, r1
  200366:	4770      	bx	lr
  200368:	ea90 0f01 	teq	r0, r1
  20036c:	bf1c      	itt	ne
  20036e:	2000      	movne	r0, #0
  200370:	4770      	bxne	lr
  200372:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
  200376:	d104      	bne.n	200382 <__addsf3+0x126>
  200378:	0040      	lsls	r0, r0, #1
  20037a:	bf28      	it	cs
  20037c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
  200380:	4770      	bx	lr
  200382:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
  200386:	bf3c      	itt	cc
  200388:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
  20038c:	4770      	bxcc	lr
  20038e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
  200392:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
  200396:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
  20039a:	4770      	bx	lr
  20039c:	ea7f 6222 	mvns.w	r2, r2, asr #24
  2003a0:	bf16      	itet	ne
  2003a2:	4608      	movne	r0, r1
  2003a4:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
  2003a8:	4601      	movne	r1, r0
  2003aa:	0242      	lsls	r2, r0, #9
  2003ac:	bf06      	itte	eq
  2003ae:	ea5f 2341 	movseq.w	r3, r1, lsl #9
  2003b2:	ea90 0f01 	teqeq	r0, r1
  2003b6:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
  2003ba:	4770      	bx	lr

002003bc <__aeabi_ui2f>:
  2003bc:	f04f 0300 	mov.w	r3, #0
  2003c0:	e004      	b.n	2003cc <__aeabi_i2f+0x8>
  2003c2:	bf00      	nop

002003c4 <__aeabi_i2f>:
  2003c4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
  2003c8:	bf48      	it	mi
  2003ca:	4240      	negmi	r0, r0
  2003cc:	ea5f 0c00 	movs.w	ip, r0
  2003d0:	bf08      	it	eq
  2003d2:	4770      	bxeq	lr
  2003d4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
  2003d8:	4601      	mov	r1, r0
  2003da:	f04f 0000 	mov.w	r0, #0
  2003de:	e01c      	b.n	20041a <__aeabi_l2f+0x2a>

002003e0 <__aeabi_ul2f>:
  2003e0:	ea50 0201 	orrs.w	r2, r0, r1
  2003e4:	bf08      	it	eq
  2003e6:	4770      	bxeq	lr
  2003e8:	f04f 0300 	mov.w	r3, #0
  2003ec:	e00a      	b.n	200404 <__aeabi_l2f+0x14>
  2003ee:	bf00      	nop

002003f0 <__aeabi_l2f>:
  2003f0:	ea50 0201 	orrs.w	r2, r0, r1
  2003f4:	bf08      	it	eq
  2003f6:	4770      	bxeq	lr
  2003f8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
  2003fc:	d502      	bpl.n	200404 <__aeabi_l2f+0x14>
  2003fe:	4240      	negs	r0, r0
  200400:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  200404:	ea5f 0c01 	movs.w	ip, r1
  200408:	bf02      	ittt	eq
  20040a:	4684      	moveq	ip, r0
  20040c:	4601      	moveq	r1, r0
  20040e:	2000      	moveq	r0, #0
  200410:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
  200414:	bf08      	it	eq
  200416:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
  20041a:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
  20041e:	fabc f28c 	clz	r2, ip
  200422:	3a08      	subs	r2, #8
  200424:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
  200428:	db10      	blt.n	20044c <__aeabi_l2f+0x5c>
  20042a:	fa01 fc02 	lsl.w	ip, r1, r2
  20042e:	4463      	add	r3, ip
  200430:	fa00 fc02 	lsl.w	ip, r0, r2
  200434:	f1c2 0220 	rsb	r2, r2, #32
  200438:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
  20043c:	fa20 f202 	lsr.w	r2, r0, r2
  200440:	eb43 0002 	adc.w	r0, r3, r2
  200444:	bf08      	it	eq
  200446:	f020 0001 	biceq.w	r0, r0, #1
  20044a:	4770      	bx	lr
  20044c:	f102 0220 	add.w	r2, r2, #32
  200450:	fa01 fc02 	lsl.w	ip, r1, r2
  200454:	f1c2 0220 	rsb	r2, r2, #32
  200458:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
  20045c:	fa21 f202 	lsr.w	r2, r1, r2
  200460:	eb43 0002 	adc.w	r0, r3, r2
  200464:	bf08      	it	eq
  200466:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
  20046a:	4770      	bx	lr

0020046c <__aeabi_ldivmod>:
  20046c:	b97b      	cbnz	r3, 20048e <__aeabi_ldivmod+0x22>
  20046e:	b972      	cbnz	r2, 20048e <__aeabi_ldivmod+0x22>
  200470:	2900      	cmp	r1, #0
  200472:	bfbe      	ittt	lt
  200474:	2000      	movlt	r0, #0
  200476:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
  20047a:	e006      	blt.n	20048a <__aeabi_ldivmod+0x1e>
  20047c:	bf08      	it	eq
  20047e:	2800      	cmpeq	r0, #0
  200480:	bf1c      	itt	ne
  200482:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
  200486:	f04f 30ff 	movne.w	r0, #4294967295
  20048a:	f000 b9fb 	b.w	200884 <__aeabi_idiv0>
  20048e:	f1ad 0c08 	sub.w	ip, sp, #8
  200492:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  200496:	2900      	cmp	r1, #0
  200498:	db09      	blt.n	2004ae <__aeabi_ldivmod+0x42>
  20049a:	2b00      	cmp	r3, #0
  20049c:	db1a      	blt.n	2004d4 <__aeabi_ldivmod+0x68>
  20049e:	f000 f883 	bl	2005a8 <__udivmoddi4>
  2004a2:	f8dd e004 	ldr.w	lr, [sp, #4]
  2004a6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  2004aa:	b004      	add	sp, #16
  2004ac:	4770      	bx	lr
  2004ae:	4240      	negs	r0, r0
  2004b0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  2004b4:	2b00      	cmp	r3, #0
  2004b6:	db1b      	blt.n	2004f0 <__aeabi_ldivmod+0x84>
  2004b8:	f000 f876 	bl	2005a8 <__udivmoddi4>
  2004bc:	f8dd e004 	ldr.w	lr, [sp, #4]
  2004c0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  2004c4:	b004      	add	sp, #16
  2004c6:	4240      	negs	r0, r0
  2004c8:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  2004cc:	4252      	negs	r2, r2
  2004ce:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  2004d2:	4770      	bx	lr
  2004d4:	4252      	negs	r2, r2
  2004d6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  2004da:	f000 f865 	bl	2005a8 <__udivmoddi4>
  2004de:	f8dd e004 	ldr.w	lr, [sp, #4]
  2004e2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  2004e6:	b004      	add	sp, #16
  2004e8:	4240      	negs	r0, r0
  2004ea:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  2004ee:	4770      	bx	lr
  2004f0:	4252      	negs	r2, r2
  2004f2:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  2004f6:	f000 f857 	bl	2005a8 <__udivmoddi4>
  2004fa:	f8dd e004 	ldr.w	lr, [sp, #4]
  2004fe:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  200502:	b004      	add	sp, #16
  200504:	4252      	negs	r2, r2
  200506:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  20050a:	4770      	bx	lr

0020050c <__aeabi_uldivmod>:
  20050c:	b953      	cbnz	r3, 200524 <__aeabi_uldivmod+0x18>
  20050e:	b94a      	cbnz	r2, 200524 <__aeabi_uldivmod+0x18>
  200510:	2900      	cmp	r1, #0
  200512:	bf08      	it	eq
  200514:	2800      	cmpeq	r0, #0
  200516:	bf1c      	itt	ne
  200518:	f04f 31ff 	movne.w	r1, #4294967295
  20051c:	f04f 30ff 	movne.w	r0, #4294967295
  200520:	f000 b9b0 	b.w	200884 <__aeabi_idiv0>
  200524:	f1ad 0c08 	sub.w	ip, sp, #8
  200528:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  20052c:	f000 f83c 	bl	2005a8 <__udivmoddi4>
  200530:	f8dd e004 	ldr.w	lr, [sp, #4]
  200534:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  200538:	b004      	add	sp, #16
  20053a:	4770      	bx	lr

0020053c <__aeabi_f2lz>:
  20053c:	ee07 0a90 	vmov	s15, r0
  200540:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  200544:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  200548:	d401      	bmi.n	20054e <__aeabi_f2lz+0x12>
  20054a:	f000 b809 	b.w	200560 <__aeabi_f2ulz>
  20054e:	b508      	push	{r3, lr}
  200550:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
  200554:	f000 f804 	bl	200560 <__aeabi_f2ulz>
  200558:	4240      	negs	r0, r0
  20055a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  20055e:	bd08      	pop	{r3, pc}

00200560 <__aeabi_f2ulz>:
  200560:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 200598 <__aeabi_f2ulz+0x38>
  200564:	ee07 0a90 	vmov	s15, r0
  200568:	ed9f 5b0d 	vldr	d5, [pc, #52]	; 2005a0 <__aeabi_f2ulz+0x40>
  20056c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  200570:	ee27 6b06 	vmul.f64	d6, d7, d6
  200574:	eebc 6bc6 	vcvt.u32.f64	s12, d6
  200578:	2000      	movs	r0, #0
  20057a:	eeb8 4b46 	vcvt.f64.u32	d4, s12
  20057e:	eea4 7b45 	vfms.f64	d7, d4, d5
  200582:	eebc 7bc7 	vcvt.u32.f64	s14, d7
  200586:	ee16 1a10 	vmov	r1, s12
  20058a:	ee17 3a10 	vmov	r3, s14
  20058e:	4318      	orrs	r0, r3
  200590:	4770      	bx	lr
  200592:	bf00      	nop
  200594:	f3af 8000 	nop.w
  200598:	00000000 	.word	0x00000000
  20059c:	3df00000 	.word	0x3df00000
  2005a0:	00000000 	.word	0x00000000
  2005a4:	41f00000 	.word	0x41f00000

002005a8 <__udivmoddi4>:
  2005a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  2005ac:	468c      	mov	ip, r1
  2005ae:	460d      	mov	r5, r1
  2005b0:	4604      	mov	r4, r0
  2005b2:	9e08      	ldr	r6, [sp, #32]
  2005b4:	2b00      	cmp	r3, #0
  2005b6:	d151      	bne.n	20065c <__udivmoddi4+0xb4>
  2005b8:	428a      	cmp	r2, r1
  2005ba:	4617      	mov	r7, r2
  2005bc:	d96d      	bls.n	20069a <__udivmoddi4+0xf2>
  2005be:	fab2 fe82 	clz	lr, r2
  2005c2:	f1be 0f00 	cmp.w	lr, #0
  2005c6:	d00b      	beq.n	2005e0 <__udivmoddi4+0x38>
  2005c8:	f1ce 0c20 	rsb	ip, lr, #32
  2005cc:	fa01 f50e 	lsl.w	r5, r1, lr
  2005d0:	fa20 fc0c 	lsr.w	ip, r0, ip
  2005d4:	fa02 f70e 	lsl.w	r7, r2, lr
  2005d8:	ea4c 0c05 	orr.w	ip, ip, r5
  2005dc:	fa00 f40e 	lsl.w	r4, r0, lr
  2005e0:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  2005e4:	0c25      	lsrs	r5, r4, #16
  2005e6:	fbbc f8fa 	udiv	r8, ip, sl
  2005ea:	fa1f f987 	uxth.w	r9, r7
  2005ee:	fb0a cc18 	mls	ip, sl, r8, ip
  2005f2:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  2005f6:	fb08 f309 	mul.w	r3, r8, r9
  2005fa:	42ab      	cmp	r3, r5
  2005fc:	d90a      	bls.n	200614 <__udivmoddi4+0x6c>
  2005fe:	19ed      	adds	r5, r5, r7
  200600:	f108 32ff 	add.w	r2, r8, #4294967295
  200604:	f080 8123 	bcs.w	20084e <__udivmoddi4+0x2a6>
  200608:	42ab      	cmp	r3, r5
  20060a:	f240 8120 	bls.w	20084e <__udivmoddi4+0x2a6>
  20060e:	f1a8 0802 	sub.w	r8, r8, #2
  200612:	443d      	add	r5, r7
  200614:	1aed      	subs	r5, r5, r3
  200616:	b2a4      	uxth	r4, r4
  200618:	fbb5 f0fa 	udiv	r0, r5, sl
  20061c:	fb0a 5510 	mls	r5, sl, r0, r5
  200620:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  200624:	fb00 f909 	mul.w	r9, r0, r9
  200628:	45a1      	cmp	r9, r4
  20062a:	d909      	bls.n	200640 <__udivmoddi4+0x98>
  20062c:	19e4      	adds	r4, r4, r7
  20062e:	f100 33ff 	add.w	r3, r0, #4294967295
  200632:	f080 810a 	bcs.w	20084a <__udivmoddi4+0x2a2>
  200636:	45a1      	cmp	r9, r4
  200638:	f240 8107 	bls.w	20084a <__udivmoddi4+0x2a2>
  20063c:	3802      	subs	r0, #2
  20063e:	443c      	add	r4, r7
  200640:	eba4 0409 	sub.w	r4, r4, r9
  200644:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  200648:	2100      	movs	r1, #0
  20064a:	2e00      	cmp	r6, #0
  20064c:	d061      	beq.n	200712 <__udivmoddi4+0x16a>
  20064e:	fa24 f40e 	lsr.w	r4, r4, lr
  200652:	2300      	movs	r3, #0
  200654:	6034      	str	r4, [r6, #0]
  200656:	6073      	str	r3, [r6, #4]
  200658:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20065c:	428b      	cmp	r3, r1
  20065e:	d907      	bls.n	200670 <__udivmoddi4+0xc8>
  200660:	2e00      	cmp	r6, #0
  200662:	d054      	beq.n	20070e <__udivmoddi4+0x166>
  200664:	2100      	movs	r1, #0
  200666:	e886 0021 	stmia.w	r6, {r0, r5}
  20066a:	4608      	mov	r0, r1
  20066c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  200670:	fab3 f183 	clz	r1, r3
  200674:	2900      	cmp	r1, #0
  200676:	f040 808e 	bne.w	200796 <__udivmoddi4+0x1ee>
  20067a:	42ab      	cmp	r3, r5
  20067c:	d302      	bcc.n	200684 <__udivmoddi4+0xdc>
  20067e:	4282      	cmp	r2, r0
  200680:	f200 80fa 	bhi.w	200878 <__udivmoddi4+0x2d0>
  200684:	1a84      	subs	r4, r0, r2
  200686:	eb65 0503 	sbc.w	r5, r5, r3
  20068a:	2001      	movs	r0, #1
  20068c:	46ac      	mov	ip, r5
  20068e:	2e00      	cmp	r6, #0
  200690:	d03f      	beq.n	200712 <__udivmoddi4+0x16a>
  200692:	e886 1010 	stmia.w	r6, {r4, ip}
  200696:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20069a:	b912      	cbnz	r2, 2006a2 <__udivmoddi4+0xfa>
  20069c:	2701      	movs	r7, #1
  20069e:	fbb7 f7f2 	udiv	r7, r7, r2
  2006a2:	fab7 fe87 	clz	lr, r7
  2006a6:	f1be 0f00 	cmp.w	lr, #0
  2006aa:	d134      	bne.n	200716 <__udivmoddi4+0x16e>
  2006ac:	1beb      	subs	r3, r5, r7
  2006ae:	0c3a      	lsrs	r2, r7, #16
  2006b0:	fa1f fc87 	uxth.w	ip, r7
  2006b4:	2101      	movs	r1, #1
  2006b6:	fbb3 f8f2 	udiv	r8, r3, r2
  2006ba:	0c25      	lsrs	r5, r4, #16
  2006bc:	fb02 3318 	mls	r3, r2, r8, r3
  2006c0:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  2006c4:	fb0c f308 	mul.w	r3, ip, r8
  2006c8:	42ab      	cmp	r3, r5
  2006ca:	d907      	bls.n	2006dc <__udivmoddi4+0x134>
  2006cc:	19ed      	adds	r5, r5, r7
  2006ce:	f108 30ff 	add.w	r0, r8, #4294967295
  2006d2:	d202      	bcs.n	2006da <__udivmoddi4+0x132>
  2006d4:	42ab      	cmp	r3, r5
  2006d6:	f200 80d1 	bhi.w	20087c <__udivmoddi4+0x2d4>
  2006da:	4680      	mov	r8, r0
  2006dc:	1aed      	subs	r5, r5, r3
  2006de:	b2a3      	uxth	r3, r4
  2006e0:	fbb5 f0f2 	udiv	r0, r5, r2
  2006e4:	fb02 5510 	mls	r5, r2, r0, r5
  2006e8:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  2006ec:	fb0c fc00 	mul.w	ip, ip, r0
  2006f0:	45a4      	cmp	ip, r4
  2006f2:	d907      	bls.n	200704 <__udivmoddi4+0x15c>
  2006f4:	19e4      	adds	r4, r4, r7
  2006f6:	f100 33ff 	add.w	r3, r0, #4294967295
  2006fa:	d202      	bcs.n	200702 <__udivmoddi4+0x15a>
  2006fc:	45a4      	cmp	ip, r4
  2006fe:	f200 80b8 	bhi.w	200872 <__udivmoddi4+0x2ca>
  200702:	4618      	mov	r0, r3
  200704:	eba4 040c 	sub.w	r4, r4, ip
  200708:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  20070c:	e79d      	b.n	20064a <__udivmoddi4+0xa2>
  20070e:	4631      	mov	r1, r6
  200710:	4630      	mov	r0, r6
  200712:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  200716:	f1ce 0420 	rsb	r4, lr, #32
  20071a:	fa05 f30e 	lsl.w	r3, r5, lr
  20071e:	fa07 f70e 	lsl.w	r7, r7, lr
  200722:	fa20 f804 	lsr.w	r8, r0, r4
  200726:	0c3a      	lsrs	r2, r7, #16
  200728:	fa25 f404 	lsr.w	r4, r5, r4
  20072c:	ea48 0803 	orr.w	r8, r8, r3
  200730:	fbb4 f1f2 	udiv	r1, r4, r2
  200734:	ea4f 4518 	mov.w	r5, r8, lsr #16
  200738:	fb02 4411 	mls	r4, r2, r1, r4
  20073c:	fa1f fc87 	uxth.w	ip, r7
  200740:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  200744:	fb01 f30c 	mul.w	r3, r1, ip
  200748:	42ab      	cmp	r3, r5
  20074a:	fa00 f40e 	lsl.w	r4, r0, lr
  20074e:	d909      	bls.n	200764 <__udivmoddi4+0x1bc>
  200750:	19ed      	adds	r5, r5, r7
  200752:	f101 30ff 	add.w	r0, r1, #4294967295
  200756:	f080 808a 	bcs.w	20086e <__udivmoddi4+0x2c6>
  20075a:	42ab      	cmp	r3, r5
  20075c:	f240 8087 	bls.w	20086e <__udivmoddi4+0x2c6>
  200760:	3902      	subs	r1, #2
  200762:	443d      	add	r5, r7
  200764:	1aeb      	subs	r3, r5, r3
  200766:	fa1f f588 	uxth.w	r5, r8
  20076a:	fbb3 f0f2 	udiv	r0, r3, r2
  20076e:	fb02 3310 	mls	r3, r2, r0, r3
  200772:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  200776:	fb00 f30c 	mul.w	r3, r0, ip
  20077a:	42ab      	cmp	r3, r5
  20077c:	d907      	bls.n	20078e <__udivmoddi4+0x1e6>
  20077e:	19ed      	adds	r5, r5, r7
  200780:	f100 38ff 	add.w	r8, r0, #4294967295
  200784:	d26f      	bcs.n	200866 <__udivmoddi4+0x2be>
  200786:	42ab      	cmp	r3, r5
  200788:	d96d      	bls.n	200866 <__udivmoddi4+0x2be>
  20078a:	3802      	subs	r0, #2
  20078c:	443d      	add	r5, r7
  20078e:	1aeb      	subs	r3, r5, r3
  200790:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  200794:	e78f      	b.n	2006b6 <__udivmoddi4+0x10e>
  200796:	f1c1 0720 	rsb	r7, r1, #32
  20079a:	fa22 f807 	lsr.w	r8, r2, r7
  20079e:	408b      	lsls	r3, r1
  2007a0:	fa05 f401 	lsl.w	r4, r5, r1
  2007a4:	ea48 0303 	orr.w	r3, r8, r3
  2007a8:	fa20 fe07 	lsr.w	lr, r0, r7
  2007ac:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  2007b0:	40fd      	lsrs	r5, r7
  2007b2:	ea4e 0e04 	orr.w	lr, lr, r4
  2007b6:	fbb5 f9fc 	udiv	r9, r5, ip
  2007ba:	ea4f 441e 	mov.w	r4, lr, lsr #16
  2007be:	fb0c 5519 	mls	r5, ip, r9, r5
  2007c2:	fa1f f883 	uxth.w	r8, r3
  2007c6:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  2007ca:	fb09 f408 	mul.w	r4, r9, r8
  2007ce:	42ac      	cmp	r4, r5
  2007d0:	fa02 f201 	lsl.w	r2, r2, r1
  2007d4:	fa00 fa01 	lsl.w	sl, r0, r1
  2007d8:	d908      	bls.n	2007ec <__udivmoddi4+0x244>
  2007da:	18ed      	adds	r5, r5, r3
  2007dc:	f109 30ff 	add.w	r0, r9, #4294967295
  2007e0:	d243      	bcs.n	20086a <__udivmoddi4+0x2c2>
  2007e2:	42ac      	cmp	r4, r5
  2007e4:	d941      	bls.n	20086a <__udivmoddi4+0x2c2>
  2007e6:	f1a9 0902 	sub.w	r9, r9, #2
  2007ea:	441d      	add	r5, r3
  2007ec:	1b2d      	subs	r5, r5, r4
  2007ee:	fa1f fe8e 	uxth.w	lr, lr
  2007f2:	fbb5 f0fc 	udiv	r0, r5, ip
  2007f6:	fb0c 5510 	mls	r5, ip, r0, r5
  2007fa:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  2007fe:	fb00 f808 	mul.w	r8, r0, r8
  200802:	45a0      	cmp	r8, r4
  200804:	d907      	bls.n	200816 <__udivmoddi4+0x26e>
  200806:	18e4      	adds	r4, r4, r3
  200808:	f100 35ff 	add.w	r5, r0, #4294967295
  20080c:	d229      	bcs.n	200862 <__udivmoddi4+0x2ba>
  20080e:	45a0      	cmp	r8, r4
  200810:	d927      	bls.n	200862 <__udivmoddi4+0x2ba>
  200812:	3802      	subs	r0, #2
  200814:	441c      	add	r4, r3
  200816:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  20081a:	eba4 0408 	sub.w	r4, r4, r8
  20081e:	fba0 8902 	umull	r8, r9, r0, r2
  200822:	454c      	cmp	r4, r9
  200824:	46c6      	mov	lr, r8
  200826:	464d      	mov	r5, r9
  200828:	d315      	bcc.n	200856 <__udivmoddi4+0x2ae>
  20082a:	d012      	beq.n	200852 <__udivmoddi4+0x2aa>
  20082c:	b156      	cbz	r6, 200844 <__udivmoddi4+0x29c>
  20082e:	ebba 030e 	subs.w	r3, sl, lr
  200832:	eb64 0405 	sbc.w	r4, r4, r5
  200836:	fa04 f707 	lsl.w	r7, r4, r7
  20083a:	40cb      	lsrs	r3, r1
  20083c:	431f      	orrs	r7, r3
  20083e:	40cc      	lsrs	r4, r1
  200840:	6037      	str	r7, [r6, #0]
  200842:	6074      	str	r4, [r6, #4]
  200844:	2100      	movs	r1, #0
  200846:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20084a:	4618      	mov	r0, r3
  20084c:	e6f8      	b.n	200640 <__udivmoddi4+0x98>
  20084e:	4690      	mov	r8, r2
  200850:	e6e0      	b.n	200614 <__udivmoddi4+0x6c>
  200852:	45c2      	cmp	sl, r8
  200854:	d2ea      	bcs.n	20082c <__udivmoddi4+0x284>
  200856:	ebb8 0e02 	subs.w	lr, r8, r2
  20085a:	eb69 0503 	sbc.w	r5, r9, r3
  20085e:	3801      	subs	r0, #1
  200860:	e7e4      	b.n	20082c <__udivmoddi4+0x284>
  200862:	4628      	mov	r0, r5
  200864:	e7d7      	b.n	200816 <__udivmoddi4+0x26e>
  200866:	4640      	mov	r0, r8
  200868:	e791      	b.n	20078e <__udivmoddi4+0x1e6>
  20086a:	4681      	mov	r9, r0
  20086c:	e7be      	b.n	2007ec <__udivmoddi4+0x244>
  20086e:	4601      	mov	r1, r0
  200870:	e778      	b.n	200764 <__udivmoddi4+0x1bc>
  200872:	3802      	subs	r0, #2
  200874:	443c      	add	r4, r7
  200876:	e745      	b.n	200704 <__udivmoddi4+0x15c>
  200878:	4608      	mov	r0, r1
  20087a:	e708      	b.n	20068e <__udivmoddi4+0xe6>
  20087c:	f1a8 0802 	sub.w	r8, r8, #2
  200880:	443d      	add	r5, r7
  200882:	e72b      	b.n	2006dc <__udivmoddi4+0x134>

00200884 <__aeabi_idiv0>:
  200884:	4770      	bx	lr
  200886:	bf00      	nop

00200888 <DEBUG_Init>:
#define DEBUG_DEBUG		1

static char ALIGN_32BYTES(dbgRecvBuffer[RECV_BUFF_SIZE]);

void DEBUG_Init(void)
{
  200888:	b580      	push	{r7, lr}
  20088a:	af00      	add	r7, sp, #0
	MX_UART7_Init();
  20088c:	f018 f94e 	bl	218b2c <MX_UART7_Init>
	memset(dbgRecvBuffer,0,RECV_BUFF_SIZE);
  200890:	2264      	movs	r2, #100	; 0x64
  200892:	2100      	movs	r1, #0
  200894:	4804      	ldr	r0, [pc, #16]	; (2008a8 <DEBUG_Init+0x20>)
  200896:	f025 fe4c 	bl	226532 <memset>
	DEBUG_ReceiveStart((uint8_t*)dbgRecvBuffer, RECV_BUFF_SIZE);
  20089a:	2164      	movs	r1, #100	; 0x64
  20089c:	4802      	ldr	r0, [pc, #8]	; (2008a8 <DEBUG_Init+0x20>)
  20089e:	f018 fa63 	bl	218d68 <DEBUG_ReceiveStart>
}
  2008a2:	bf00      	nop
  2008a4:	bd80      	pop	{r7, pc}
  2008a6:	bf00      	nop
  2008a8:	200000a0 	.word	0x200000a0

002008ac <Dbg>:

void Dbg(int on, char *txt)
{
  2008ac:	b580      	push	{r7, lr}
  2008ae:	b082      	sub	sp, #8
  2008b0:	af00      	add	r7, sp, #0
  2008b2:	6078      	str	r0, [r7, #4]
  2008b4:	6039      	str	r1, [r7, #0]
	if(on)
  2008b6:	687b      	ldr	r3, [r7, #4]
  2008b8:	2b00      	cmp	r3, #0
  2008ba:	d002      	beq.n	2008c2 <Dbg+0x16>
		DEBUG_Send(txt);
  2008bc:	6838      	ldr	r0, [r7, #0]
  2008be:	f018 fa3d 	bl	218d3c <DEBUG_Send>
}
  2008c2:	bf00      	nop
  2008c4:	3708      	adds	r7, #8
  2008c6:	46bd      	mov	sp, r7
  2008c8:	bd80      	pop	{r7, pc}

002008ca <DbgVar>:
		DEBUG_Send(endTxt);
	}
}

void DbgVar(int on, unsigned int buffLen, const char *fmt, ...)
{
  2008ca:	b40c      	push	{r2, r3}
  2008cc:	b580      	push	{r7, lr}
  2008ce:	b084      	sub	sp, #16
  2008d0:	af00      	add	r7, sp, #0
  2008d2:	6078      	str	r0, [r7, #4]
  2008d4:	6039      	str	r1, [r7, #0]
	if(on)
  2008d6:	687b      	ldr	r3, [r7, #4]
  2008d8:	2b00      	cmp	r3, #0
  2008da:	d012      	beq.n	200902 <DbgVar+0x38>
	{
		char *temp = (char*)pvPortMalloc(buffLen);
  2008dc:	6838      	ldr	r0, [r7, #0]
  2008de:	f023 fc1d 	bl	22411c <pvPortMalloc>
  2008e2:	60f8      	str	r0, [r7, #12]
		va_list va;
		va_start(va, fmt);
  2008e4:	f107 031c 	add.w	r3, r7, #28
  2008e8:	60bb      	str	r3, [r7, #8]
		mini_vsnprintf(temp, buffLen, fmt, va);
  2008ea:	68bb      	ldr	r3, [r7, #8]
  2008ec:	69ba      	ldr	r2, [r7, #24]
  2008ee:	6839      	ldr	r1, [r7, #0]
  2008f0:	68f8      	ldr	r0, [r7, #12]
  2008f2:	f000 fccc 	bl	20128e <mini_vsnprintf>
		va_end(va);
		DEBUG_Send(temp);
  2008f6:	68f8      	ldr	r0, [r7, #12]
  2008f8:	f018 fa20 	bl	218d3c <DEBUG_Send>
		vPortFree(temp);
  2008fc:	68f8      	ldr	r0, [r7, #12]
  2008fe:	f023 fcd5 	bl	2242ac <vPortFree>
	}
}
  200902:	bf00      	nop
  200904:	3710      	adds	r7, #16
  200906:	46bd      	mov	sp, r7
  200908:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
  20090c:	b002      	add	sp, #8
  20090e:	4770      	bx	lr

00200910 <DEBUG_IsAnythingReceive>:

static int DEBUG_IsAnythingReceive(void)
{
  200910:	b480      	push	{r7}
  200912:	af00      	add	r7, sp, #0
	if(dbgRecvBuffer[0]>0)
  200914:	4b05      	ldr	r3, [pc, #20]	; (20092c <DEBUG_IsAnythingReceive+0x1c>)
  200916:	781b      	ldrb	r3, [r3, #0]
  200918:	2b00      	cmp	r3, #0
  20091a:	d001      	beq.n	200920 <DEBUG_IsAnythingReceive+0x10>
		return 1;
  20091c:	2301      	movs	r3, #1
  20091e:	e000      	b.n	200922 <DEBUG_IsAnythingReceive+0x12>
	else
		return 0;
  200920:	2300      	movs	r3, #0
}
  200922:	4618      	mov	r0, r3
  200924:	46bd      	mov	sp, r7
  200926:	f85d 7b04 	ldr.w	r7, [sp], #4
  20092a:	4770      	bx	lr
  20092c:	200000a0 	.word	0x200000a0

00200930 <DEBUG_IsTxtReceive>:

static int DEBUG_IsTxtReceive(char *txt)
{
  200930:	b580      	push	{r7, lr}
  200932:	b082      	sub	sp, #8
  200934:	af00      	add	r7, sp, #0
  200936:	6078      	str	r0, [r7, #4]
	if(strstr(dbgRecvBuffer,txt))
  200938:	6879      	ldr	r1, [r7, #4]
  20093a:	480c      	ldr	r0, [pc, #48]	; (20096c <DEBUG_IsTxtReceive+0x3c>)
  20093c:	f025 fe23 	bl	226586 <strstr>
  200940:	4603      	mov	r3, r0
  200942:	2b00      	cmp	r3, #0
  200944:	d00c      	beq.n	200960 <DEBUG_IsTxtReceive+0x30>
	{
		DEBUG_ReceiveStop();
  200946:	f018 fa39 	bl	218dbc <DEBUG_ReceiveStop>
		memset(dbgRecvBuffer,0,RECV_BUFF_SIZE);
  20094a:	2264      	movs	r2, #100	; 0x64
  20094c:	2100      	movs	r1, #0
  20094e:	4807      	ldr	r0, [pc, #28]	; (20096c <DEBUG_IsTxtReceive+0x3c>)
  200950:	f025 fdef 	bl	226532 <memset>
		DEBUG_ReceiveStart((uint8_t*)dbgRecvBuffer, RECV_BUFF_SIZE);
  200954:	2164      	movs	r1, #100	; 0x64
  200956:	4805      	ldr	r0, [pc, #20]	; (20096c <DEBUG_IsTxtReceive+0x3c>)
  200958:	f018 fa06 	bl	218d68 <DEBUG_ReceiveStart>
		return 1;
  20095c:	2301      	movs	r3, #1
  20095e:	e000      	b.n	200962 <DEBUG_IsTxtReceive+0x32>
	}
	return 0;
  200960:	2300      	movs	r3, #0
}
  200962:	4618      	mov	r0, r3
  200964:	3708      	adds	r7, #8
  200966:	46bd      	mov	sp, r7
  200968:	bd80      	pop	{r7, pc}
  20096a:	bf00      	nop
  20096c:	200000a0 	.word	0x200000a0

00200970 <DEBUG_RxFullBuffService>:

void DEBUG_RxFullBuffService(void)
{
  200970:	b580      	push	{r7, lr}
  200972:	af00      	add	r7, sp, #0
	DEBUG_Send(dbgRecvBuffer);
  200974:	4808      	ldr	r0, [pc, #32]	; (200998 <DEBUG_RxFullBuffService+0x28>)
  200976:	f018 f9e1 	bl	218d3c <DEBUG_Send>
	memset(dbgRecvBuffer,0,RECV_BUFF_SIZE);
  20097a:	2264      	movs	r2, #100	; 0x64
  20097c:	2100      	movs	r1, #0
  20097e:	4806      	ldr	r0, [pc, #24]	; (200998 <DEBUG_RxFullBuffService+0x28>)
  200980:	f025 fdd7 	bl	226532 <memset>
	DEBUG_ReceiveStart((uint8_t*)dbgRecvBuffer, RECV_BUFF_SIZE);
  200984:	2164      	movs	r1, #100	; 0x64
  200986:	4804      	ldr	r0, [pc, #16]	; (200998 <DEBUG_RxFullBuffService+0x28>)
  200988:	f018 f9ee 	bl	218d68 <DEBUG_ReceiveStart>
	Dbg(DEBUG_DEBUG,"\r\n -----  DEBUG_RxFullBuffService -------  ");
  20098c:	4903      	ldr	r1, [pc, #12]	; (20099c <DEBUG_RxFullBuffService+0x2c>)
  20098e:	2001      	movs	r0, #1
  200990:	f7ff ff8c 	bl	2008ac <Dbg>
}
  200994:	bf00      	nop
  200996:	bd80      	pop	{r7, pc}
  200998:	200000a0 	.word	0x200000a0
  20099c:	00228210 	.word	0x00228210

002009a0 <DEBUG_RcvStr>:

int DEBUG_RcvStr(char *txt)
{
  2009a0:	b580      	push	{r7, lr}
  2009a2:	b082      	sub	sp, #8
  2009a4:	af00      	add	r7, sp, #0
  2009a6:	6078      	str	r0, [r7, #4]
	if(DEBUG_IsAnythingReceive())
  2009a8:	f7ff ffb2 	bl	200910 <DEBUG_IsAnythingReceive>
  2009ac:	4603      	mov	r3, r0
  2009ae:	2b00      	cmp	r3, #0
  2009b0:	d009      	beq.n	2009c6 <DEBUG_RcvStr+0x26>
	{
	  if(DEBUG_IsTxtReceive(txt))
  2009b2:	6878      	ldr	r0, [r7, #4]
  2009b4:	f7ff ffbc 	bl	200930 <DEBUG_IsTxtReceive>
  2009b8:	4603      	mov	r3, r0
  2009ba:	2b00      	cmp	r3, #0
  2009bc:	d001      	beq.n	2009c2 <DEBUG_RcvStr+0x22>
		  return 1;
  2009be:	2301      	movs	r3, #1
  2009c0:	e002      	b.n	2009c8 <DEBUG_RcvStr+0x28>
	  else
		  return 0;
  2009c2:	2300      	movs	r3, #0
  2009c4:	e000      	b.n	2009c8 <DEBUG_RcvStr+0x28>
	}
	else
		return 0;
  2009c6:	2300      	movs	r3, #0
}
  2009c8:	4618      	mov	r0, r3
  2009ca:	3708      	adds	r7, #8
  2009cc:	46bd      	mov	sp, r7
  2009ce:	bd80      	pop	{r7, pc}

002009d0 <float2stri>:
	}
	*output = 0;
}

void float2stri(char *buffer, float value, unsigned int dec_digits)
{
  2009d0:	b5f0      	push	{r4, r5, r6, r7, lr}
  2009d2:	ed2d 8b02 	vpush	{d8}
  2009d6:	b099      	sub	sp, #100	; 0x64
  2009d8:	af00      	add	r7, sp, #0
  2009da:	60f8      	str	r0, [r7, #12]
  2009dc:	ed87 0a02 	vstr	s0, [r7, #8]
  2009e0:	6079      	str	r1, [r7, #4]
	int idx;
	int64_t dbl_int, dbl_frac;
	int64_t mult = 1;
  2009e2:	f04f 0301 	mov.w	r3, #1
  2009e6:	f04f 0400 	mov.w	r4, #0
  2009ea:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
	char *output = buffer;
  2009ee:	68fb      	ldr	r3, [r7, #12]
  2009f0:	63fb      	str	r3, [r7, #60]	; 0x3c
	char tbfr[40];

	if (isfinite(value))
  2009f2:	edd7 7a02 	vldr	s15, [r7, #8]
  2009f6:	eef0 7ae7 	vabs.f32	s15, s15
  2009fa:	ed9f 7ab9 	vldr	s14, [pc, #740]	; 200ce0 <float2stri+0x310>
  2009fe:	eef4 7a47 	vcmp.f32	s15, s14
  200a02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  200a06:	bf8c      	ite	hi
  200a08:	2301      	movhi	r3, #1
  200a0a:	2300      	movls	r3, #0
  200a0c:	b2db      	uxtb	r3, r3
  200a0e:	f083 0301 	eor.w	r3, r3, #1
  200a12:	b2db      	uxtb	r3, r3
  200a14:	2b00      	cmp	r3, #0
  200a16:	f000 813d 	beq.w	200c94 <float2stri+0x2c4>
	{
		if ((value <= -99999999999999) || (value >= 99999999999999))
  200a1a:	edd7 7a02 	vldr	s15, [r7, #8]
  200a1e:	ed9f 7ab1 	vldr	s14, [pc, #708]	; 200ce4 <float2stri+0x314>
  200a22:	eef4 7ac7 	vcmpe.f32	s15, s14
  200a26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  200a2a:	d908      	bls.n	200a3e <float2stri+0x6e>
  200a2c:	edd7 7a02 	vldr	s15, [r7, #8]
  200a30:	ed9f 7aad 	vldr	s14, [pc, #692]	; 200ce8 <float2stri+0x318>
  200a34:	eef4 7ac7 	vcmpe.f32	s15, s14
  200a38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  200a3c:	db19      	blt.n	200a72 <float2stri+0xa2>
		{
			*output++ = '-';
  200a3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200a40:	1c5a      	adds	r2, r3, #1
  200a42:	63fa      	str	r2, [r7, #60]	; 0x3c
  200a44:	222d      	movs	r2, #45	; 0x2d
  200a46:	701a      	strb	r2, [r3, #0]
			*output++ = '-';
  200a48:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200a4a:	1c5a      	adds	r2, r3, #1
  200a4c:	63fa      	str	r2, [r7, #60]	; 0x3c
  200a4e:	222d      	movs	r2, #45	; 0x2d
  200a50:	701a      	strb	r2, [r3, #0]
			*output++ = '-';
  200a52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200a54:	1c5a      	adds	r2, r3, #1
  200a56:	63fa      	str	r2, [r7, #60]	; 0x3c
  200a58:	222d      	movs	r2, #45	; 0x2d
  200a5a:	701a      	strb	r2, [r3, #0]
			*output++ = '-';
  200a5c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200a5e:	1c5a      	adds	r2, r3, #1
  200a60:	63fa      	str	r2, [r7, #60]	; 0x3c
  200a62:	222d      	movs	r2, #45	; 0x2d
  200a64:	701a      	strb	r2, [r3, #0]
			*output++ = '-';
  200a66:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200a68:	1c5a      	adds	r2, r3, #1
  200a6a:	63fa      	str	r2, [r7, #60]	; 0x3c
  200a6c:	222d      	movs	r2, #45	; 0x2d
  200a6e:	701a      	strb	r2, [r3, #0]
  200a70:	e129      	b.n	200cc6 <float2stri+0x2f6>
		}
		else
		{
			if (value < 0.0)
  200a72:	edd7 7a02 	vldr	s15, [r7, #8]
  200a76:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  200a7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  200a7e:	d50e      	bpl.n	200a9e <float2stri+0xce>
			{
				*output++ = '-';
  200a80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200a82:	1c5a      	adds	r2, r3, #1
  200a84:	63fa      	str	r2, [r7, #60]	; 0x3c
  200a86:	222d      	movs	r2, #45	; 0x2d
  200a88:	701a      	strb	r2, [r3, #0]
				value *= -1.0;
  200a8a:	edd7 7a02 	vldr	s15, [r7, #8]
  200a8e:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  200a92:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  200a96:	eef1 7a67 	vneg.f32	s15, s15
  200a9a:	edc7 7a02 	vstr	s15, [r7, #8]
			}

			if (dec_digits <8)
  200a9e:	687b      	ldr	r3, [r7, #4]
  200aa0:	2b07      	cmp	r3, #7
  200aa2:	d82c      	bhi.n	200afe <float2stri+0x12e>
			{
				value += round_nums[dec_digits];
  200aa4:	edd7 7a02 	vldr	s15, [r7, #8]
  200aa8:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  200aac:	4a8f      	ldr	r2, [pc, #572]	; (200cec <float2stri+0x31c>)
  200aae:	687b      	ldr	r3, [r7, #4]
  200ab0:	00db      	lsls	r3, r3, #3
  200ab2:	4413      	add	r3, r2
  200ab4:	ed93 7b00 	vldr	d7, [r3]
  200ab8:	ee36 7b07 	vadd.f64	d7, d6, d7
  200abc:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  200ac0:	edc7 7a02 	vstr	s15, [r7, #8]
				for (idx = 0; idx < dec_digits; idx++)
  200ac4:	2300      	movs	r3, #0
  200ac6:	65fb      	str	r3, [r7, #92]	; 0x5c
  200ac8:	e014      	b.n	200af4 <float2stri+0x124>
					mult *= 10;
  200aca:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	; 0x40
  200ace:	460b      	mov	r3, r1
  200ad0:	4614      	mov	r4, r2
  200ad2:	00a6      	lsls	r6, r4, #2
  200ad4:	ea46 7693 	orr.w	r6, r6, r3, lsr #30
  200ad8:	009d      	lsls	r5, r3, #2
  200ada:	462b      	mov	r3, r5
  200adc:	4634      	mov	r4, r6
  200ade:	185b      	adds	r3, r3, r1
  200ae0:	eb44 0402 	adc.w	r4, r4, r2
  200ae4:	18db      	adds	r3, r3, r3
  200ae6:	eb44 0404 	adc.w	r4, r4, r4
  200aea:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
				for (idx = 0; idx < dec_digits; idx++)
  200aee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200af0:	3301      	adds	r3, #1
  200af2:	65fb      	str	r3, [r7, #92]	; 0x5c
  200af4:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  200af6:	687b      	ldr	r3, [r7, #4]
  200af8:	429a      	cmp	r2, r3
  200afa:	d3e6      	bcc.n	200aca <float2stri+0xfa>
  200afc:	e012      	b.n	200b24 <float2stri+0x154>
			}
			else
			{
				dec_digits = 7;
  200afe:	2307      	movs	r3, #7
  200b00:	607b      	str	r3, [r7, #4]
				value += round_nums[7];
  200b02:	edd7 7a02 	vldr	s15, [r7, #8]
  200b06:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  200b0a:	ed9f 6b73 	vldr	d6, [pc, #460]	; 200cd8 <float2stri+0x308>
  200b0e:	ee37 7b06 	vadd.f64	d7, d7, d6
  200b12:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  200b16:	edc7 7a02 	vstr	s15, [r7, #8]
				mult = 10000000;
  200b1a:	4b75      	ldr	r3, [pc, #468]	; (200cf0 <float2stri+0x320>)
  200b1c:	f04f 0400 	mov.w	r4, #0
  200b20:	e9c7 3410 	strd	r3, r4, [r7, #64]	; 0x40
			}

			dbl_int = (int64_t) value;
  200b24:	68b8      	ldr	r0, [r7, #8]
  200b26:	f7ff fd09 	bl	20053c <__aeabi_f2lz>
  200b2a:	4603      	mov	r3, r0
  200b2c:	460c      	mov	r4, r1
  200b2e:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
			dbl_frac = (int64_t) ((value - (float) dbl_int) * (float) mult);
  200b32:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
  200b36:	f7ff fc5b 	bl	2003f0 <__aeabi_l2f>
  200b3a:	ee07 0a10 	vmov	s14, r0
  200b3e:	edd7 7a02 	vldr	s15, [r7, #8]
  200b42:	ee37 8ac7 	vsub.f32	s16, s15, s14
  200b46:	e9d7 0110 	ldrd	r0, r1, [r7, #64]	; 0x40
  200b4a:	f7ff fc51 	bl	2003f0 <__aeabi_l2f>
  200b4e:	ee07 0a90 	vmov	s15, r0
  200b52:	ee68 7a27 	vmul.f32	s15, s16, s15
  200b56:	ee17 0a90 	vmov	r0, s15
  200b5a:	f7ff fcef 	bl	20053c <__aeabi_f2lz>
  200b5e:	4603      	mov	r3, r0
  200b60:	460c      	mov	r4, r1
  200b62:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48

			idx = 0;
  200b66:	2300      	movs	r3, #0
  200b68:	65fb      	str	r3, [r7, #92]	; 0x5c
			while (dbl_int != 0)
  200b6a:	e01e      	b.n	200baa <float2stri+0x1da>
			{
				tbfr[idx++] = '0' + (dbl_int % 10);
  200b6c:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
  200b6e:	1c63      	adds	r3, r4, #1
  200b70:	65fb      	str	r3, [r7, #92]	; 0x5c
  200b72:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
  200b76:	f04f 020a 	mov.w	r2, #10
  200b7a:	f04f 0300 	mov.w	r3, #0
  200b7e:	f7ff fc75 	bl	20046c <__aeabi_ldivmod>
  200b82:	b2d3      	uxtb	r3, r2
  200b84:	3330      	adds	r3, #48	; 0x30
  200b86:	b2da      	uxtb	r2, r3
  200b88:	f107 0360 	add.w	r3, r7, #96	; 0x60
  200b8c:	4423      	add	r3, r4
  200b8e:	f803 2c4c 	strb.w	r2, [r3, #-76]
				dbl_int /= 10;
  200b92:	e9d7 0114 	ldrd	r0, r1, [r7, #80]	; 0x50
  200b96:	f04f 020a 	mov.w	r2, #10
  200b9a:	f04f 0300 	mov.w	r3, #0
  200b9e:	f7ff fc65 	bl	20046c <__aeabi_ldivmod>
  200ba2:	4603      	mov	r3, r0
  200ba4:	460c      	mov	r4, r1
  200ba6:	e9c7 3414 	strd	r3, r4, [r7, #80]	; 0x50
			while (dbl_int != 0)
  200baa:	e9d7 3414 	ldrd	r3, r4, [r7, #80]	; 0x50
  200bae:	4323      	orrs	r3, r4
  200bb0:	d1dc      	bne.n	200b6c <float2stri+0x19c>
			}

			if (idx == 0)
  200bb2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200bb4:	2b00      	cmp	r3, #0
  200bb6:	d113      	bne.n	200be0 <float2stri+0x210>
				*output++ = '0';
  200bb8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200bba:	1c5a      	adds	r2, r3, #1
  200bbc:	63fa      	str	r2, [r7, #60]	; 0x3c
  200bbe:	2230      	movs	r2, #48	; 0x30
  200bc0:	701a      	strb	r2, [r3, #0]
  200bc2:	e010      	b.n	200be6 <float2stri+0x216>
			else
			{
				while (idx > 0)
				{
					*output++ = tbfr[idx - 1];
  200bc4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200bc6:	1c5a      	adds	r2, r3, #1
  200bc8:	63fa      	str	r2, [r7, #60]	; 0x3c
  200bca:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  200bcc:	3a01      	subs	r2, #1
  200bce:	f107 0160 	add.w	r1, r7, #96	; 0x60
  200bd2:	440a      	add	r2, r1
  200bd4:	f812 2c4c 	ldrb.w	r2, [r2, #-76]
  200bd8:	701a      	strb	r2, [r3, #0]
					idx--;
  200bda:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200bdc:	3b01      	subs	r3, #1
  200bde:	65fb      	str	r3, [r7, #92]	; 0x5c
				while (idx > 0)
  200be0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200be2:	2b00      	cmp	r3, #0
  200be4:	dcee      	bgt.n	200bc4 <float2stri+0x1f4>
				}
			}

			if (dec_digits > 0)
  200be6:	687b      	ldr	r3, [r7, #4]
  200be8:	2b00      	cmp	r3, #0
  200bea:	d06c      	beq.n	200cc6 <float2stri+0x2f6>
			{
				*output++ = '.';
  200bec:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200bee:	1c5a      	adds	r2, r3, #1
  200bf0:	63fa      	str	r2, [r7, #60]	; 0x3c
  200bf2:	222e      	movs	r2, #46	; 0x2e
  200bf4:	701a      	strb	r2, [r3, #0]

				idx = 0;
  200bf6:	2300      	movs	r3, #0
  200bf8:	65fb      	str	r3, [r7, #92]	; 0x5c
				while (dbl_frac != 0)
  200bfa:	e01e      	b.n	200c3a <float2stri+0x26a>
				{
					tbfr[idx++] = '0' + (dbl_frac % 10);
  200bfc:	6dfc      	ldr	r4, [r7, #92]	; 0x5c
  200bfe:	1c63      	adds	r3, r4, #1
  200c00:	65fb      	str	r3, [r7, #92]	; 0x5c
  200c02:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
  200c06:	f04f 020a 	mov.w	r2, #10
  200c0a:	f04f 0300 	mov.w	r3, #0
  200c0e:	f7ff fc2d 	bl	20046c <__aeabi_ldivmod>
  200c12:	b2d3      	uxtb	r3, r2
  200c14:	3330      	adds	r3, #48	; 0x30
  200c16:	b2da      	uxtb	r2, r3
  200c18:	f107 0360 	add.w	r3, r7, #96	; 0x60
  200c1c:	4423      	add	r3, r4
  200c1e:	f803 2c4c 	strb.w	r2, [r3, #-76]
					dbl_frac /= 10;
  200c22:	e9d7 0112 	ldrd	r0, r1, [r7, #72]	; 0x48
  200c26:	f04f 020a 	mov.w	r2, #10
  200c2a:	f04f 0300 	mov.w	r3, #0
  200c2e:	f7ff fc1d 	bl	20046c <__aeabi_ldivmod>
  200c32:	4603      	mov	r3, r0
  200c34:	460c      	mov	r4, r1
  200c36:	e9c7 3412 	strd	r3, r4, [r7, #72]	; 0x48
				while (dbl_frac != 0)
  200c3a:	e9d7 3412 	ldrd	r3, r4, [r7, #72]	; 0x48
  200c3e:	4323      	orrs	r3, r4
  200c40:	d1dc      	bne.n	200bfc <float2stri+0x22c>
				}
				while (idx < dec_digits)
  200c42:	e008      	b.n	200c56 <float2stri+0x286>
					tbfr[idx++] = '0';
  200c44:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200c46:	1c5a      	adds	r2, r3, #1
  200c48:	65fa      	str	r2, [r7, #92]	; 0x5c
  200c4a:	f107 0260 	add.w	r2, r7, #96	; 0x60
  200c4e:	4413      	add	r3, r2
  200c50:	2230      	movs	r2, #48	; 0x30
  200c52:	f803 2c4c 	strb.w	r2, [r3, #-76]
				while (idx < dec_digits)
  200c56:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  200c58:	687b      	ldr	r3, [r7, #4]
  200c5a:	429a      	cmp	r2, r3
  200c5c:	d3f2      	bcc.n	200c44 <float2stri+0x274>

				if (idx == 0)
  200c5e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200c60:	2b00      	cmp	r3, #0
  200c62:	d113      	bne.n	200c8c <float2stri+0x2bc>
					*output++ = '0';
  200c64:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200c66:	1c5a      	adds	r2, r3, #1
  200c68:	63fa      	str	r2, [r7, #60]	; 0x3c
  200c6a:	2230      	movs	r2, #48	; 0x30
  200c6c:	701a      	strb	r2, [r3, #0]
  200c6e:	e02a      	b.n	200cc6 <float2stri+0x2f6>
				else
				{
					while (idx > 0)
					{
						*output++ = tbfr[idx - 1];
  200c70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200c72:	1c5a      	adds	r2, r3, #1
  200c74:	63fa      	str	r2, [r7, #60]	; 0x3c
  200c76:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  200c78:	3a01      	subs	r2, #1
  200c7a:	f107 0160 	add.w	r1, r7, #96	; 0x60
  200c7e:	440a      	add	r2, r1
  200c80:	f812 2c4c 	ldrb.w	r2, [r2, #-76]
  200c84:	701a      	strb	r2, [r3, #0]
						idx--;
  200c86:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200c88:	3b01      	subs	r3, #1
  200c8a:	65fb      	str	r3, [r7, #92]	; 0x5c
					while (idx > 0)
  200c8c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  200c8e:	2b00      	cmp	r3, #0
  200c90:	dcee      	bgt.n	200c70 <float2stri+0x2a0>
  200c92:	e018      	b.n	200cc6 <float2stri+0x2f6>
			}
		}
	}
	else
	{
		*output++ = '-';
  200c94:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200c96:	1c5a      	adds	r2, r3, #1
  200c98:	63fa      	str	r2, [r7, #60]	; 0x3c
  200c9a:	222d      	movs	r2, #45	; 0x2d
  200c9c:	701a      	strb	r2, [r3, #0]
		*output++ = '-';
  200c9e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200ca0:	1c5a      	adds	r2, r3, #1
  200ca2:	63fa      	str	r2, [r7, #60]	; 0x3c
  200ca4:	222d      	movs	r2, #45	; 0x2d
  200ca6:	701a      	strb	r2, [r3, #0]
		*output++ = '-';
  200ca8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200caa:	1c5a      	adds	r2, r3, #1
  200cac:	63fa      	str	r2, [r7, #60]	; 0x3c
  200cae:	222d      	movs	r2, #45	; 0x2d
  200cb0:	701a      	strb	r2, [r3, #0]
		*output++ = '-';
  200cb2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200cb4:	1c5a      	adds	r2, r3, #1
  200cb6:	63fa      	str	r2, [r7, #60]	; 0x3c
  200cb8:	222d      	movs	r2, #45	; 0x2d
  200cba:	701a      	strb	r2, [r3, #0]
		*output++ = '-';
  200cbc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200cbe:	1c5a      	adds	r2, r3, #1
  200cc0:	63fa      	str	r2, [r7, #60]	; 0x3c
  200cc2:	222d      	movs	r2, #45	; 0x2d
  200cc4:	701a      	strb	r2, [r3, #0]
	}
	*output = 0;
  200cc6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  200cc8:	2200      	movs	r2, #0
  200cca:	701a      	strb	r2, [r3, #0]
}
  200ccc:	bf00      	nop
  200cce:	3764      	adds	r7, #100	; 0x64
  200cd0:	46bd      	mov	sp, r7
  200cd2:	ecbd 8b02 	vpop	{d8}
  200cd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  200cd8:	9abcaf48 	.word	0x9abcaf48
  200cdc:	3e6ad7f2 	.word	0x3e6ad7f2
  200ce0:	7f7fffff 	.word	0x7f7fffff
  200ce4:	d6b5e621 	.word	0xd6b5e621
  200ce8:	56b5e621 	.word	0x56b5e621
  200cec:	00229260 	.word	0x00229260
  200cf0:	00989680 	.word	0x00989680

00200cf4 <CODESTR_SdCard>:
#define DEBUG_ERRORS_SERVICES		1

static char codeBuff[50];

static char* CODESTR_SdCard(int code)
{
  200cf4:	b4b0      	push	{r4, r5, r7}
  200cf6:	b085      	sub	sp, #20
  200cf8:	af00      	add	r7, sp, #0
  200cfa:	6078      	str	r0, [r7, #4]
	char* CodeStr=codeBuff;
  200cfc:	4b91      	ldr	r3, [pc, #580]	; (200f44 <CODESTR_SdCard+0x250>)
  200cfe:	60fb      	str	r3, [r7, #12]

	switch(code)
  200d00:	687b      	ldr	r3, [r7, #4]
  200d02:	2b13      	cmp	r3, #19
  200d04:	f200 8117 	bhi.w	200f36 <CODESTR_SdCard+0x242>
  200d08:	a201      	add	r2, pc, #4	; (adr r2, 200d10 <CODESTR_SdCard+0x1c>)
  200d0a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  200d0e:	bf00      	nop
  200d10:	00200d61 	.word	0x00200d61
  200d14:	00200d6f 	.word	0x00200d6f
  200d18:	00200d81 	.word	0x00200d81
  200d1c:	00200d99 	.word	0x00200d99
  200d20:	00200daf 	.word	0x00200daf
  200d24:	00200dc7 	.word	0x00200dc7
  200d28:	00200ddf 	.word	0x00200ddf
  200d2c:	00200df3 	.word	0x00200df3
  200d30:	00200e07 	.word	0x00200e07
  200d34:	00200e1b 	.word	0x00200e1b
  200d38:	00200e33 	.word	0x00200e33
  200d3c:	00200e51 	.word	0x00200e51
  200d40:	00200e69 	.word	0x00200e69
  200d44:	00200e83 	.word	0x00200e83
  200d48:	00200e9b 	.word	0x00200e9b
  200d4c:	00200eaf 	.word	0x00200eaf
  200d50:	00200ec7 	.word	0x00200ec7
  200d54:	00200edb 	.word	0x00200edb
  200d58:	00200ef9 	.word	0x00200ef9
  200d5c:	00200f1b 	.word	0x00200f1b
	{
	case FR_OK:
		strcpy(CodeStr,"FR_OK");
  200d60:	68fb      	ldr	r3, [r7, #12]
  200d62:	4a79      	ldr	r2, [pc, #484]	; (200f48 <CODESTR_SdCard+0x254>)
  200d64:	6810      	ldr	r0, [r2, #0]
  200d66:	6018      	str	r0, [r3, #0]
  200d68:	8892      	ldrh	r2, [r2, #4]
  200d6a:	809a      	strh	r2, [r3, #4]
		break;
  200d6c:	e0e3      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_DISK_ERR:
		strcpy(CodeStr,"FR_DISK_ERR");
  200d6e:	68fb      	ldr	r3, [r7, #12]
  200d70:	4a76      	ldr	r2, [pc, #472]	; (200f4c <CODESTR_SdCard+0x258>)
  200d72:	461c      	mov	r4, r3
  200d74:	4613      	mov	r3, r2
  200d76:	cb07      	ldmia	r3!, {r0, r1, r2}
  200d78:	6020      	str	r0, [r4, #0]
  200d7a:	6061      	str	r1, [r4, #4]
  200d7c:	60a2      	str	r2, [r4, #8]
		break;
  200d7e:	e0da      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_INT_ERR:
		strcpy(CodeStr,"FR_INT_ERR");
  200d80:	68fb      	ldr	r3, [r7, #12]
  200d82:	4973      	ldr	r1, [pc, #460]	; (200f50 <CODESTR_SdCard+0x25c>)
  200d84:	461a      	mov	r2, r3
  200d86:	460b      	mov	r3, r1
  200d88:	cb03      	ldmia	r3!, {r0, r1}
  200d8a:	6010      	str	r0, [r2, #0]
  200d8c:	6051      	str	r1, [r2, #4]
  200d8e:	8819      	ldrh	r1, [r3, #0]
  200d90:	789b      	ldrb	r3, [r3, #2]
  200d92:	8111      	strh	r1, [r2, #8]
  200d94:	7293      	strb	r3, [r2, #10]
		break;
  200d96:	e0ce      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_NOT_READY:
		strcpy(CodeStr,"FR_NOT_READY");
  200d98:	68fb      	ldr	r3, [r7, #12]
  200d9a:	4a6e      	ldr	r2, [pc, #440]	; (200f54 <CODESTR_SdCard+0x260>)
  200d9c:	461c      	mov	r4, r3
  200d9e:	4613      	mov	r3, r2
  200da0:	cb07      	ldmia	r3!, {r0, r1, r2}
  200da2:	6020      	str	r0, [r4, #0]
  200da4:	6061      	str	r1, [r4, #4]
  200da6:	60a2      	str	r2, [r4, #8]
  200da8:	781b      	ldrb	r3, [r3, #0]
  200daa:	7323      	strb	r3, [r4, #12]
		break;
  200dac:	e0c3      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_NO_FILE:
		strcpy(CodeStr,"FR_NO_FILE");
  200dae:	68fb      	ldr	r3, [r7, #12]
  200db0:	4969      	ldr	r1, [pc, #420]	; (200f58 <CODESTR_SdCard+0x264>)
  200db2:	461a      	mov	r2, r3
  200db4:	460b      	mov	r3, r1
  200db6:	cb03      	ldmia	r3!, {r0, r1}
  200db8:	6010      	str	r0, [r2, #0]
  200dba:	6051      	str	r1, [r2, #4]
  200dbc:	8819      	ldrh	r1, [r3, #0]
  200dbe:	789b      	ldrb	r3, [r3, #2]
  200dc0:	8111      	strh	r1, [r2, #8]
  200dc2:	7293      	strb	r3, [r2, #10]
		break;
  200dc4:	e0b7      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_NO_PATH:
		strcpy(CodeStr,"FR_NO_PATH");
  200dc6:	68fb      	ldr	r3, [r7, #12]
  200dc8:	4964      	ldr	r1, [pc, #400]	; (200f5c <CODESTR_SdCard+0x268>)
  200dca:	461a      	mov	r2, r3
  200dcc:	460b      	mov	r3, r1
  200dce:	cb03      	ldmia	r3!, {r0, r1}
  200dd0:	6010      	str	r0, [r2, #0]
  200dd2:	6051      	str	r1, [r2, #4]
  200dd4:	8819      	ldrh	r1, [r3, #0]
  200dd6:	789b      	ldrb	r3, [r3, #2]
  200dd8:	8111      	strh	r1, [r2, #8]
  200dda:	7293      	strb	r3, [r2, #10]
		break;
  200ddc:	e0ab      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_INVALID_NAME:
		strcpy(CodeStr,"FR_INVALID_NAME");
  200dde:	68fb      	ldr	r3, [r7, #12]
  200de0:	4a5f      	ldr	r2, [pc, #380]	; (200f60 <CODESTR_SdCard+0x26c>)
  200de2:	461c      	mov	r4, r3
  200de4:	4615      	mov	r5, r2
  200de6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  200de8:	6020      	str	r0, [r4, #0]
  200dea:	6061      	str	r1, [r4, #4]
  200dec:	60a2      	str	r2, [r4, #8]
  200dee:	60e3      	str	r3, [r4, #12]
		break;
  200df0:	e0a1      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_DENIED:
		strcpy(CodeStr,"FR_DENIED");
  200df2:	68fb      	ldr	r3, [r7, #12]
  200df4:	495b      	ldr	r1, [pc, #364]	; (200f64 <CODESTR_SdCard+0x270>)
  200df6:	461a      	mov	r2, r3
  200df8:	460b      	mov	r3, r1
  200dfa:	cb03      	ldmia	r3!, {r0, r1}
  200dfc:	6010      	str	r0, [r2, #0]
  200dfe:	6051      	str	r1, [r2, #4]
  200e00:	881b      	ldrh	r3, [r3, #0]
  200e02:	8113      	strh	r3, [r2, #8]
		break;
  200e04:	e097      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_EXIST:
		strcpy(CodeStr,"FR_EXIST");
  200e06:	68fb      	ldr	r3, [r7, #12]
  200e08:	4957      	ldr	r1, [pc, #348]	; (200f68 <CODESTR_SdCard+0x274>)
  200e0a:	461a      	mov	r2, r3
  200e0c:	460b      	mov	r3, r1
  200e0e:	cb03      	ldmia	r3!, {r0, r1}
  200e10:	6010      	str	r0, [r2, #0]
  200e12:	6051      	str	r1, [r2, #4]
  200e14:	781b      	ldrb	r3, [r3, #0]
  200e16:	7213      	strb	r3, [r2, #8]
		break;
  200e18:	e08d      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_INVALID_OBJECT:
		strcpy(CodeStr,"FR_INVALID_OBJECT");
  200e1a:	68fb      	ldr	r3, [r7, #12]
  200e1c:	4a53      	ldr	r2, [pc, #332]	; (200f6c <CODESTR_SdCard+0x278>)
  200e1e:	461d      	mov	r5, r3
  200e20:	4614      	mov	r4, r2
  200e22:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  200e24:	6028      	str	r0, [r5, #0]
  200e26:	6069      	str	r1, [r5, #4]
  200e28:	60aa      	str	r2, [r5, #8]
  200e2a:	60eb      	str	r3, [r5, #12]
  200e2c:	8823      	ldrh	r3, [r4, #0]
  200e2e:	822b      	strh	r3, [r5, #16]
		break;
  200e30:	e081      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_WRITE_PROTECTED:
		strcpy(CodeStr,"FR_WRITE_PROTECTED");
  200e32:	68fb      	ldr	r3, [r7, #12]
  200e34:	4a4e      	ldr	r2, [pc, #312]	; (200f70 <CODESTR_SdCard+0x27c>)
  200e36:	461d      	mov	r5, r3
  200e38:	4614      	mov	r4, r2
  200e3a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  200e3c:	6028      	str	r0, [r5, #0]
  200e3e:	6069      	str	r1, [r5, #4]
  200e40:	60aa      	str	r2, [r5, #8]
  200e42:	60eb      	str	r3, [r5, #12]
  200e44:	8823      	ldrh	r3, [r4, #0]
  200e46:	78a2      	ldrb	r2, [r4, #2]
  200e48:	822b      	strh	r3, [r5, #16]
  200e4a:	4613      	mov	r3, r2
  200e4c:	74ab      	strb	r3, [r5, #18]
		break;
  200e4e:	e072      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_INVALID_DRIVE:
		strcpy(CodeStr,"FR_INVALID_DRIVE");
  200e50:	68fb      	ldr	r3, [r7, #12]
  200e52:	4a48      	ldr	r2, [pc, #288]	; (200f74 <CODESTR_SdCard+0x280>)
  200e54:	461d      	mov	r5, r3
  200e56:	4614      	mov	r4, r2
  200e58:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  200e5a:	6028      	str	r0, [r5, #0]
  200e5c:	6069      	str	r1, [r5, #4]
  200e5e:	60aa      	str	r2, [r5, #8]
  200e60:	60eb      	str	r3, [r5, #12]
  200e62:	7823      	ldrb	r3, [r4, #0]
  200e64:	742b      	strb	r3, [r5, #16]
		break;
  200e66:	e066      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_NOT_ENABLED:
		strcpy(CodeStr,"FR_NOT_ENABLED");
  200e68:	68fb      	ldr	r3, [r7, #12]
  200e6a:	4a43      	ldr	r2, [pc, #268]	; (200f78 <CODESTR_SdCard+0x284>)
  200e6c:	461c      	mov	r4, r3
  200e6e:	4613      	mov	r3, r2
  200e70:	cb07      	ldmia	r3!, {r0, r1, r2}
  200e72:	6020      	str	r0, [r4, #0]
  200e74:	6061      	str	r1, [r4, #4]
  200e76:	60a2      	str	r2, [r4, #8]
  200e78:	881a      	ldrh	r2, [r3, #0]
  200e7a:	789b      	ldrb	r3, [r3, #2]
  200e7c:	81a2      	strh	r2, [r4, #12]
  200e7e:	73a3      	strb	r3, [r4, #14]
		break;
  200e80:	e059      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_NO_FILESYSTEM:
		strcpy(CodeStr,"FR_NO_FILESYSTEM");
  200e82:	68fb      	ldr	r3, [r7, #12]
  200e84:	4a3d      	ldr	r2, [pc, #244]	; (200f7c <CODESTR_SdCard+0x288>)
  200e86:	461d      	mov	r5, r3
  200e88:	4614      	mov	r4, r2
  200e8a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  200e8c:	6028      	str	r0, [r5, #0]
  200e8e:	6069      	str	r1, [r5, #4]
  200e90:	60aa      	str	r2, [r5, #8]
  200e92:	60eb      	str	r3, [r5, #12]
  200e94:	7823      	ldrb	r3, [r4, #0]
  200e96:	742b      	strb	r3, [r5, #16]
		break;
  200e98:	e04d      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_MKFS_ABORTED:
		strcpy(CodeStr,"FR_MKFS_ABORTED");
  200e9a:	68fb      	ldr	r3, [r7, #12]
  200e9c:	4a38      	ldr	r2, [pc, #224]	; (200f80 <CODESTR_SdCard+0x28c>)
  200e9e:	461c      	mov	r4, r3
  200ea0:	4615      	mov	r5, r2
  200ea2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  200ea4:	6020      	str	r0, [r4, #0]
  200ea6:	6061      	str	r1, [r4, #4]
  200ea8:	60a2      	str	r2, [r4, #8]
  200eaa:	60e3      	str	r3, [r4, #12]
		break;
  200eac:	e043      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_TIMEOUT:
		strcpy(CodeStr,"FR_TIMEOUT");
  200eae:	68fb      	ldr	r3, [r7, #12]
  200eb0:	4934      	ldr	r1, [pc, #208]	; (200f84 <CODESTR_SdCard+0x290>)
  200eb2:	461a      	mov	r2, r3
  200eb4:	460b      	mov	r3, r1
  200eb6:	cb03      	ldmia	r3!, {r0, r1}
  200eb8:	6010      	str	r0, [r2, #0]
  200eba:	6051      	str	r1, [r2, #4]
  200ebc:	8819      	ldrh	r1, [r3, #0]
  200ebe:	789b      	ldrb	r3, [r3, #2]
  200ec0:	8111      	strh	r1, [r2, #8]
  200ec2:	7293      	strb	r3, [r2, #10]
		break;
  200ec4:	e037      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_LOCKED:
		strcpy(CodeStr,"FR_LOCKED");
  200ec6:	68fb      	ldr	r3, [r7, #12]
  200ec8:	492f      	ldr	r1, [pc, #188]	; (200f88 <CODESTR_SdCard+0x294>)
  200eca:	461a      	mov	r2, r3
  200ecc:	460b      	mov	r3, r1
  200ece:	cb03      	ldmia	r3!, {r0, r1}
  200ed0:	6010      	str	r0, [r2, #0]
  200ed2:	6051      	str	r1, [r2, #4]
  200ed4:	881b      	ldrh	r3, [r3, #0]
  200ed6:	8113      	strh	r3, [r2, #8]
		break;
  200ed8:	e02d      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_NOT_ENOUGH_CORE:
		strcpy(CodeStr,"FR_NOT_ENOUGH_CORE");
  200eda:	68fb      	ldr	r3, [r7, #12]
  200edc:	4a2b      	ldr	r2, [pc, #172]	; (200f8c <CODESTR_SdCard+0x298>)
  200ede:	461d      	mov	r5, r3
  200ee0:	4614      	mov	r4, r2
  200ee2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  200ee4:	6028      	str	r0, [r5, #0]
  200ee6:	6069      	str	r1, [r5, #4]
  200ee8:	60aa      	str	r2, [r5, #8]
  200eea:	60eb      	str	r3, [r5, #12]
  200eec:	8823      	ldrh	r3, [r4, #0]
  200eee:	78a2      	ldrb	r2, [r4, #2]
  200ef0:	822b      	strh	r3, [r5, #16]
  200ef2:	4613      	mov	r3, r2
  200ef4:	74ab      	strb	r3, [r5, #18]
		break;
  200ef6:	e01e      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_TOO_MANY_OPEN_FILES:
		strcpy(CodeStr,"FR_TOO_MANY_OPEN_FILES");
  200ef8:	68fb      	ldr	r3, [r7, #12]
  200efa:	4a25      	ldr	r2, [pc, #148]	; (200f90 <CODESTR_SdCard+0x29c>)
  200efc:	461c      	mov	r4, r3
  200efe:	4615      	mov	r5, r2
  200f00:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  200f02:	6020      	str	r0, [r4, #0]
  200f04:	6061      	str	r1, [r4, #4]
  200f06:	60a2      	str	r2, [r4, #8]
  200f08:	60e3      	str	r3, [r4, #12]
  200f0a:	6828      	ldr	r0, [r5, #0]
  200f0c:	6120      	str	r0, [r4, #16]
  200f0e:	88ab      	ldrh	r3, [r5, #4]
  200f10:	79aa      	ldrb	r2, [r5, #6]
  200f12:	82a3      	strh	r3, [r4, #20]
  200f14:	4613      	mov	r3, r2
  200f16:	75a3      	strb	r3, [r4, #22]
		break;
  200f18:	e00d      	b.n	200f36 <CODESTR_SdCard+0x242>
	case FR_INVALID_PARAMETER:
		strcpy(CodeStr,"FR_INVALID_PARAMETER");
  200f1a:	68fb      	ldr	r3, [r7, #12]
  200f1c:	4a1d      	ldr	r2, [pc, #116]	; (200f94 <CODESTR_SdCard+0x2a0>)
  200f1e:	461d      	mov	r5, r3
  200f20:	4614      	mov	r4, r2
  200f22:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  200f24:	6028      	str	r0, [r5, #0]
  200f26:	6069      	str	r1, [r5, #4]
  200f28:	60aa      	str	r2, [r5, #8]
  200f2a:	60eb      	str	r3, [r5, #12]
  200f2c:	6820      	ldr	r0, [r4, #0]
  200f2e:	6128      	str	r0, [r5, #16]
  200f30:	7923      	ldrb	r3, [r4, #4]
  200f32:	752b      	strb	r3, [r5, #20]
		break;
  200f34:	bf00      	nop
	}
	return CodeStr;
  200f36:	68fb      	ldr	r3, [r7, #12]
}
  200f38:	4618      	mov	r0, r3
  200f3a:	3714      	adds	r7, #20
  200f3c:	46bd      	mov	sp, r7
  200f3e:	bcb0      	pop	{r4, r5, r7}
  200f40:	4770      	bx	lr
  200f42:	bf00      	nop
  200f44:	20000104 	.word	0x20000104
  200f48:	0022823c 	.word	0x0022823c
  200f4c:	00228244 	.word	0x00228244
  200f50:	00228250 	.word	0x00228250
  200f54:	0022825c 	.word	0x0022825c
  200f58:	0022826c 	.word	0x0022826c
  200f5c:	00228278 	.word	0x00228278
  200f60:	00228284 	.word	0x00228284
  200f64:	00228294 	.word	0x00228294
  200f68:	002282a0 	.word	0x002282a0
  200f6c:	002282ac 	.word	0x002282ac
  200f70:	002282c0 	.word	0x002282c0
  200f74:	002282d4 	.word	0x002282d4
  200f78:	002282e8 	.word	0x002282e8
  200f7c:	002282f8 	.word	0x002282f8
  200f80:	0022830c 	.word	0x0022830c
  200f84:	0022831c 	.word	0x0022831c
  200f88:	00228328 	.word	0x00228328
  200f8c:	00228334 	.word	0x00228334
  200f90:	00228348 	.word	0x00228348
  200f94:	00228360 	.word	0x00228360

00200f98 <ERROR_SDcardMount>:

void ERROR_SDcardMount(int code){
  200f98:	b580      	push	{r7, lr}
  200f9a:	b082      	sub	sp, #8
  200f9c:	af00      	add	r7, sp, #0
  200f9e:	6078      	str	r0, [r7, #4]
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardMount code: %s",CODESTR_SdCard(code));
  200fa0:	6878      	ldr	r0, [r7, #4]
  200fa2:	f7ff fea7 	bl	200cf4 <CODESTR_SdCard>
  200fa6:	4603      	mov	r3, r0
  200fa8:	4a04      	ldr	r2, [pc, #16]	; (200fbc <ERROR_SDcardMount+0x24>)
  200faa:	2132      	movs	r1, #50	; 0x32
  200fac:	2001      	movs	r0, #1
  200fae:	f7ff fc8c 	bl	2008ca <DbgVar>
}
  200fb2:	bf00      	nop
  200fb4:	3708      	adds	r7, #8
  200fb6:	46bd      	mov	sp, r7
  200fb8:	bd80      	pop	{r7, pc}
  200fba:	bf00      	nop
  200fbc:	00228378 	.word	0x00228378

00200fc0 <ERROR_SDcardOpen>:
void ERROR_SDcardOpen(int code){
  200fc0:	b580      	push	{r7, lr}
  200fc2:	b082      	sub	sp, #8
  200fc4:	af00      	add	r7, sp, #0
  200fc6:	6078      	str	r0, [r7, #4]
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardOpen code: %s",CODESTR_SdCard(code));
  200fc8:	6878      	ldr	r0, [r7, #4]
  200fca:	f7ff fe93 	bl	200cf4 <CODESTR_SdCard>
  200fce:	4603      	mov	r3, r0
  200fd0:	4a04      	ldr	r2, [pc, #16]	; (200fe4 <ERROR_SDcardOpen+0x24>)
  200fd2:	2132      	movs	r1, #50	; 0x32
  200fd4:	2001      	movs	r0, #1
  200fd6:	f7ff fc78 	bl	2008ca <DbgVar>
}
  200fda:	bf00      	nop
  200fdc:	3708      	adds	r7, #8
  200fde:	46bd      	mov	sp, r7
  200fe0:	bd80      	pop	{r7, pc}
  200fe2:	bf00      	nop
  200fe4:	00228398 	.word	0x00228398

00200fe8 <ERROR_SDcardWrite>:
void ERROR_SDcardRead(int code){
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardRead code: %s",CODESTR_SdCard(code));
}
void ERROR_SDcardWrite(int code){
  200fe8:	b580      	push	{r7, lr}
  200fea:	b082      	sub	sp, #8
  200fec:	af00      	add	r7, sp, #0
  200fee:	6078      	str	r0, [r7, #4]
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardWrite code: %s",CODESTR_SdCard(code));
  200ff0:	6878      	ldr	r0, [r7, #4]
  200ff2:	f7ff fe7f 	bl	200cf4 <CODESTR_SdCard>
  200ff6:	4603      	mov	r3, r0
  200ff8:	4a04      	ldr	r2, [pc, #16]	; (20100c <ERROR_SDcardWrite+0x24>)
  200ffa:	2132      	movs	r1, #50	; 0x32
  200ffc:	2001      	movs	r0, #1
  200ffe:	f7ff fc64 	bl	2008ca <DbgVar>
}
  201002:	bf00      	nop
  201004:	3708      	adds	r7, #8
  201006:	46bd      	mov	sp, r7
  201008:	bd80      	pop	{r7, pc}
  20100a:	bf00      	nop
  20100c:	002283d0 	.word	0x002283d0

00201010 <ERROR_SDcardClose>:
void ERROR_SDcardClose(int code){
  201010:	b580      	push	{r7, lr}
  201012:	b082      	sub	sp, #8
  201014:	af00      	add	r7, sp, #0
  201016:	6078      	str	r0, [r7, #4]
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardClose code: %s",CODESTR_SdCard(code));
  201018:	6878      	ldr	r0, [r7, #4]
  20101a:	f7ff fe6b 	bl	200cf4 <CODESTR_SdCard>
  20101e:	4603      	mov	r3, r0
  201020:	4a04      	ldr	r2, [pc, #16]	; (201034 <ERROR_SDcardClose+0x24>)
  201022:	2132      	movs	r1, #50	; 0x32
  201024:	2001      	movs	r0, #1
  201026:	f7ff fc50 	bl	2008ca <DbgVar>
}
  20102a:	bf00      	nop
  20102c:	3708      	adds	r7, #8
  20102e:	46bd      	mov	sp, r7
  201030:	bd80      	pop	{r7, pc}
  201032:	bf00      	nop
  201034:	002283f0 	.word	0x002283f0

00201038 <ERROR_SDcardInfo>:
void ERROR_SDcardLseek(int code){
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardLseek code: %s",CODESTR_SdCard(code));
}
void ERROR_SDcardInfo(int code){
  201038:	b580      	push	{r7, lr}
  20103a:	b082      	sub	sp, #8
  20103c:	af00      	add	r7, sp, #0
  20103e:	6078      	str	r0, [r7, #4]
	DbgVar(DEBUG_ERRORS_SERVICES,50,"\r\nERROR_SDcardInfo code: %s",CODESTR_SdCard(code));
  201040:	6878      	ldr	r0, [r7, #4]
  201042:	f7ff fe57 	bl	200cf4 <CODESTR_SdCard>
  201046:	4603      	mov	r3, r0
  201048:	4a04      	ldr	r2, [pc, #16]	; (20105c <ERROR_SDcardInfo+0x24>)
  20104a:	2132      	movs	r1, #50	; 0x32
  20104c:	2001      	movs	r0, #1
  20104e:	f7ff fc3c 	bl	2008ca <DbgVar>
}
  201052:	bf00      	nop
  201054:	3708      	adds	r7, #8
  201056:	46bd      	mov	sp, r7
  201058:	bd80      	pop	{r7, pc}
  20105a:	bf00      	nop
  20105c:	00228430 	.word	0x00228430

00201060 <ERROR_NMIHandler>:

void ERROR_NMIHandler(void){
  201060:	b580      	push	{r7, lr}
  201062:	af00      	add	r7, sp, #0
	Dbg(DEBUG_ERRORS_SERVICES,"\r\nERROR_NMIHandler ");
  201064:	4902      	ldr	r1, [pc, #8]	; (201070 <ERROR_NMIHandler+0x10>)
  201066:	2001      	movs	r0, #1
  201068:	f7ff fc20 	bl	2008ac <Dbg>
	//HAL_NVIC_SystemReset();
}
  20106c:	bf00      	nop
  20106e:	bd80      	pop	{r7, pc}
  201070:	0022844c 	.word	0x0022844c

00201074 <ERROR_HardFaulHandler>:
void ERROR_HardFaulHandler(void){
  201074:	b580      	push	{r7, lr}
  201076:	af00      	add	r7, sp, #0
	Dbg(DEBUG_ERRORS_SERVICES,"\r\nERROR_HardFaulHandler ");
  201078:	4902      	ldr	r1, [pc, #8]	; (201084 <ERROR_HardFaulHandler+0x10>)
  20107a:	2001      	movs	r0, #1
  20107c:	f7ff fc16 	bl	2008ac <Dbg>
	//HAL_NVIC_SystemReset();
}
  201080:	bf00      	nop
  201082:	bd80      	pop	{r7, pc}
  201084:	00228460 	.word	0x00228460

00201088 <ERROR_MemManageHandler>:
void ERROR_MemManageHandler(void){
  201088:	b580      	push	{r7, lr}
  20108a:	af00      	add	r7, sp, #0
	Dbg(DEBUG_ERRORS_SERVICES,"\r\nERROR_MemManageHandler ");
  20108c:	4902      	ldr	r1, [pc, #8]	; (201098 <ERROR_MemManageHandler+0x10>)
  20108e:	2001      	movs	r0, #1
  201090:	f7ff fc0c 	bl	2008ac <Dbg>
	//HAL_NVIC_SystemReset();
}
  201094:	bf00      	nop
  201096:	bd80      	pop	{r7, pc}
  201098:	0022847c 	.word	0x0022847c

0020109c <ERROR_BusFaultHandler>:
void ERROR_BusFaultHandler(void){
  20109c:	b580      	push	{r7, lr}
  20109e:	af00      	add	r7, sp, #0
	Dbg(DEBUG_ERRORS_SERVICES,"\r\nERROR_BusFaultHandler ");
  2010a0:	4902      	ldr	r1, [pc, #8]	; (2010ac <ERROR_BusFaultHandler+0x10>)
  2010a2:	2001      	movs	r0, #1
  2010a4:	f7ff fc02 	bl	2008ac <Dbg>
	//HAL_NVIC_SystemReset();
}
  2010a8:	bf00      	nop
  2010aa:	bd80      	pop	{r7, pc}
  2010ac:	00228498 	.word	0x00228498

002010b0 <ERROR_UsageFaultHandler>:
void ERROR_UsageFaultHandler(void){
  2010b0:	b580      	push	{r7, lr}
  2010b2:	af00      	add	r7, sp, #0
	Dbg(DEBUG_ERRORS_SERVICES,"\r\nERROR_UsageFaultHandler ");
  2010b4:	4902      	ldr	r1, [pc, #8]	; (2010c0 <ERROR_UsageFaultHandler+0x10>)
  2010b6:	2001      	movs	r0, #1
  2010b8:	f7ff fbf8 	bl	2008ac <Dbg>
	//HAL_NVIC_SystemReset();
}
  2010bc:	bf00      	nop
  2010be:	bd80      	pop	{r7, pc}
  2010c0:	002284b4 	.word	0x002284b4

002010c4 <ERROR_DebugMonHandler>:
void ERROR_DebugMonHandler(void){
  2010c4:	b580      	push	{r7, lr}
  2010c6:	af00      	add	r7, sp, #0
	Dbg(DEBUG_ERRORS_SERVICES,"\r\nERROR_DebugMonHandler ");
  2010c8:	4902      	ldr	r1, [pc, #8]	; (2010d4 <ERROR_DebugMonHandler+0x10>)
  2010ca:	2001      	movs	r0, #1
  2010cc:	f7ff fbee 	bl	2008ac <Dbg>
	//HAL_NVIC_SystemReset();
}
  2010d0:	bf00      	nop
  2010d2:	bd80      	pop	{r7, pc}
  2010d4:	002284d0 	.word	0x002284d0

002010d8 <ERROR_Sdram>:

void ERROR_Sdram(void){
  2010d8:	b580      	push	{r7, lr}
  2010da:	af00      	add	r7, sp, #0
	Dbg(1,"\r\nERROR_Sdram ");
  2010dc:	4902      	ldr	r1, [pc, #8]	; (2010e8 <ERROR_Sdram+0x10>)
  2010de:	2001      	movs	r0, #1
  2010e0:	f7ff fbe4 	bl	2008ac <Dbg>
}
  2010e4:	bf00      	nop
  2010e6:	bd80      	pop	{r7, pc}
  2010e8:	002284ec 	.word	0x002284ec

002010ec <ERROR_StrChangeColor>:
void ERROR_StrChangeColor(void){
  2010ec:	b580      	push	{r7, lr}
  2010ee:	af00      	add	r7, sp, #0
	Dbg(1,"\r\nBuffChangeColor size overrun !!! ");
  2010f0:	4902      	ldr	r1, [pc, #8]	; (2010fc <ERROR_StrChangeColor+0x10>)
  2010f2:	2001      	movs	r0, #1
  2010f4:	f7ff fbda 	bl	2008ac <Dbg>
}
  2010f8:	bf00      	nop
  2010fa:	bd80      	pop	{r7, pc}
  2010fc:	002284fc 	.word	0x002284fc

00201100 <mini_strlen>:

//#include <stdarg.h>
#include "mini_printf.h"

unsigned int mini_strlen(const char *s)
{
  201100:	b480      	push	{r7}
  201102:	b085      	sub	sp, #20
  201104:	af00      	add	r7, sp, #0
  201106:	6078      	str	r0, [r7, #4]
	unsigned int len = 0;
  201108:	2300      	movs	r3, #0
  20110a:	60fb      	str	r3, [r7, #12]
	while (s[len] != '\0')
  20110c:	e002      	b.n	201114 <mini_strlen+0x14>
		len++;
  20110e:	68fb      	ldr	r3, [r7, #12]
  201110:	3301      	adds	r3, #1
  201112:	60fb      	str	r3, [r7, #12]
	while (s[len] != '\0')
  201114:	687a      	ldr	r2, [r7, #4]
  201116:	68fb      	ldr	r3, [r7, #12]
  201118:	4413      	add	r3, r2
  20111a:	781b      	ldrb	r3, [r3, #0]
  20111c:	2b00      	cmp	r3, #0
  20111e:	d1f6      	bne.n	20110e <mini_strlen+0xe>
	return len;
  201120:	68fb      	ldr	r3, [r7, #12]
}
  201122:	4618      	mov	r0, r3
  201124:	3714      	adds	r7, #20
  201126:	46bd      	mov	sp, r7
  201128:	f85d 7b04 	ldr.w	r7, [sp], #4
  20112c:	4770      	bx	lr

0020112e <mini_itoa>:

static unsigned int mini_itoa(int value, unsigned int radix, unsigned int uppercase, unsigned int unsig, char *buffer, unsigned int zero_pad)
{
  20112e:	b480      	push	{r7}
  201130:	b08b      	sub	sp, #44	; 0x2c
  201132:	af00      	add	r7, sp, #0
  201134:	60f8      	str	r0, [r7, #12]
  201136:	60b9      	str	r1, [r7, #8]
  201138:	607a      	str	r2, [r7, #4]
  20113a:	603b      	str	r3, [r7, #0]
	char *pbuffer = buffer;
  20113c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20113e:	627b      	str	r3, [r7, #36]	; 0x24
	int negative = 0;
  201140:	2300      	movs	r3, #0
  201142:	623b      	str	r3, [r7, #32]
	unsigned int i, len;

	/* No support for unusual radixes. */
	if (radix > 16)
  201144:	68bb      	ldr	r3, [r7, #8]
  201146:	2b10      	cmp	r3, #16
  201148:	d901      	bls.n	20114e <mini_itoa+0x20>
		return 0;
  20114a:	2300      	movs	r3, #0
  20114c:	e077      	b.n	20123e <mini_itoa+0x110>

	if (value < 0 && !unsig)
  20114e:	68fb      	ldr	r3, [r7, #12]
  201150:	2b00      	cmp	r3, #0
  201152:	da07      	bge.n	201164 <mini_itoa+0x36>
  201154:	683b      	ldr	r3, [r7, #0]
  201156:	2b00      	cmp	r3, #0
  201158:	d104      	bne.n	201164 <mini_itoa+0x36>
	{
		negative = 1;
  20115a:	2301      	movs	r3, #1
  20115c:	623b      	str	r3, [r7, #32]
		value = -value;
  20115e:	68fb      	ldr	r3, [r7, #12]
  201160:	425b      	negs	r3, r3
  201162:	60fb      	str	r3, [r7, #12]
	}

	/* This builds the string back to front ... */
	do
	{
		int digit = value % radix;
  201164:	68fb      	ldr	r3, [r7, #12]
  201166:	68ba      	ldr	r2, [r7, #8]
  201168:	fbb3 f2f2 	udiv	r2, r3, r2
  20116c:	68b9      	ldr	r1, [r7, #8]
  20116e:	fb01 f202 	mul.w	r2, r1, r2
  201172:	1a9b      	subs	r3, r3, r2
  201174:	61bb      	str	r3, [r7, #24]
		*(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
  201176:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  201178:	1c5a      	adds	r2, r3, #1
  20117a:	627a      	str	r2, [r7, #36]	; 0x24
  20117c:	69ba      	ldr	r2, [r7, #24]
  20117e:	2a09      	cmp	r2, #9
  201180:	dc04      	bgt.n	20118c <mini_itoa+0x5e>
  201182:	69ba      	ldr	r2, [r7, #24]
  201184:	b2d2      	uxtb	r2, r2
  201186:	3230      	adds	r2, #48	; 0x30
  201188:	b2d2      	uxtb	r2, r2
  20118a:	e00b      	b.n	2011a4 <mini_itoa+0x76>
  20118c:	687a      	ldr	r2, [r7, #4]
  20118e:	2a00      	cmp	r2, #0
  201190:	d001      	beq.n	201196 <mini_itoa+0x68>
  201192:	2141      	movs	r1, #65	; 0x41
  201194:	e000      	b.n	201198 <mini_itoa+0x6a>
  201196:	2161      	movs	r1, #97	; 0x61
  201198:	69ba      	ldr	r2, [r7, #24]
  20119a:	b2d2      	uxtb	r2, r2
  20119c:	440a      	add	r2, r1
  20119e:	b2d2      	uxtb	r2, r2
  2011a0:	3a0a      	subs	r2, #10
  2011a2:	b2d2      	uxtb	r2, r2
  2011a4:	701a      	strb	r2, [r3, #0]
		value /= radix;
  2011a6:	68fa      	ldr	r2, [r7, #12]
  2011a8:	68bb      	ldr	r3, [r7, #8]
  2011aa:	fbb2 f3f3 	udiv	r3, r2, r3
  2011ae:	60fb      	str	r3, [r7, #12]
	} while (value > 0);
  2011b0:	68fb      	ldr	r3, [r7, #12]
  2011b2:	2b00      	cmp	r3, #0
  2011b4:	dcd6      	bgt.n	201164 <mini_itoa+0x36>

	for (i = (pbuffer - buffer); i < zero_pad; i++)
  2011b6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2011b8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2011ba:	1ad3      	subs	r3, r2, r3
  2011bc:	61fb      	str	r3, [r7, #28]
  2011be:	e007      	b.n	2011d0 <mini_itoa+0xa2>
		*(pbuffer++) = '0';
  2011c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2011c2:	1c5a      	adds	r2, r3, #1
  2011c4:	627a      	str	r2, [r7, #36]	; 0x24
  2011c6:	2230      	movs	r2, #48	; 0x30
  2011c8:	701a      	strb	r2, [r3, #0]
	for (i = (pbuffer - buffer); i < zero_pad; i++)
  2011ca:	69fb      	ldr	r3, [r7, #28]
  2011cc:	3301      	adds	r3, #1
  2011ce:	61fb      	str	r3, [r7, #28]
  2011d0:	69fa      	ldr	r2, [r7, #28]
  2011d2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2011d4:	429a      	cmp	r2, r3
  2011d6:	d3f3      	bcc.n	2011c0 <mini_itoa+0x92>

	if (negative)
  2011d8:	6a3b      	ldr	r3, [r7, #32]
  2011da:	2b00      	cmp	r3, #0
  2011dc:	d004      	beq.n	2011e8 <mini_itoa+0xba>
		*(pbuffer++) = '-';
  2011de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2011e0:	1c5a      	adds	r2, r3, #1
  2011e2:	627a      	str	r2, [r7, #36]	; 0x24
  2011e4:	222d      	movs	r2, #45	; 0x2d
  2011e6:	701a      	strb	r2, [r3, #0]

	*(pbuffer) = '\0';
  2011e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2011ea:	2200      	movs	r2, #0
  2011ec:	701a      	strb	r2, [r3, #0]

	/* ... now we reverse it (could do it recursively but will
	 * conserve the stack space) */
	len = (pbuffer - buffer);
  2011ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2011f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2011f2:	1ad3      	subs	r3, r2, r3
  2011f4:	617b      	str	r3, [r7, #20]
	for (i = 0; i < len / 2; i++)
  2011f6:	2300      	movs	r3, #0
  2011f8:	61fb      	str	r3, [r7, #28]
  2011fa:	e01a      	b.n	201232 <mini_itoa+0x104>
	{
		char j = buffer[i];
  2011fc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  2011fe:	69fb      	ldr	r3, [r7, #28]
  201200:	4413      	add	r3, r2
  201202:	781b      	ldrb	r3, [r3, #0]
  201204:	74fb      	strb	r3, [r7, #19]
		buffer[i] = buffer[len - i - 1];
  201206:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  201208:	69fb      	ldr	r3, [r7, #28]
  20120a:	4413      	add	r3, r2
  20120c:	6979      	ldr	r1, [r7, #20]
  20120e:	69fa      	ldr	r2, [r7, #28]
  201210:	1a8a      	subs	r2, r1, r2
  201212:	3a01      	subs	r2, #1
  201214:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201216:	440a      	add	r2, r1
  201218:	7812      	ldrb	r2, [r2, #0]
  20121a:	701a      	strb	r2, [r3, #0]
		buffer[len - i - 1] = j;
  20121c:	697a      	ldr	r2, [r7, #20]
  20121e:	69fb      	ldr	r3, [r7, #28]
  201220:	1ad3      	subs	r3, r2, r3
  201222:	3b01      	subs	r3, #1
  201224:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  201226:	4413      	add	r3, r2
  201228:	7cfa      	ldrb	r2, [r7, #19]
  20122a:	701a      	strb	r2, [r3, #0]
	for (i = 0; i < len / 2; i++)
  20122c:	69fb      	ldr	r3, [r7, #28]
  20122e:	3301      	adds	r3, #1
  201230:	61fb      	str	r3, [r7, #28]
  201232:	697b      	ldr	r3, [r7, #20]
  201234:	085a      	lsrs	r2, r3, #1
  201236:	69fb      	ldr	r3, [r7, #28]
  201238:	429a      	cmp	r2, r3
  20123a:	d8df      	bhi.n	2011fc <mini_itoa+0xce>
	}

	return len;
  20123c:	697b      	ldr	r3, [r7, #20]
}
  20123e:	4618      	mov	r0, r3
  201240:	372c      	adds	r7, #44	; 0x2c
  201242:	46bd      	mov	sp, r7
  201244:	f85d 7b04 	ldr.w	r7, [sp], #4
  201248:	4770      	bx	lr

0020124a <_putc.5287>:
	char *pbuffer = buffer;
	char bf[24];
	char ch;

	int _putc(char ch)
	{
  20124a:	b480      	push	{r7}
  20124c:	b083      	sub	sp, #12
  20124e:	af00      	add	r7, sp, #0
  201250:	4603      	mov	r3, r0
  201252:	71fb      	strb	r3, [r7, #7]
  201254:	4663      	mov	r3, ip
  201256:	f8c7 c000 	str.w	ip, [r7]
		if ((unsigned int) ((pbuffer - buffer) + 1) >= buffer_len)
  20125a:	689a      	ldr	r2, [r3, #8]
  20125c:	4611      	mov	r1, r2
  20125e:	685a      	ldr	r2, [r3, #4]
  201260:	1a8a      	subs	r2, r1, r2
  201262:	3201      	adds	r2, #1
  201264:	4611      	mov	r1, r2
  201266:	681a      	ldr	r2, [r3, #0]
  201268:	4291      	cmp	r1, r2
  20126a:	d301      	bcc.n	201270 <_putc.5287+0x26>
			return 0;
  20126c:	2300      	movs	r3, #0
  20126e:	e008      	b.n	201282 <_putc.5287+0x38>
		*(pbuffer++) = ch;
  201270:	689a      	ldr	r2, [r3, #8]
  201272:	1c51      	adds	r1, r2, #1
  201274:	6099      	str	r1, [r3, #8]
  201276:	79f9      	ldrb	r1, [r7, #7]
  201278:	7011      	strb	r1, [r2, #0]
		*(pbuffer) = '\0';
  20127a:	689b      	ldr	r3, [r3, #8]
  20127c:	2200      	movs	r2, #0
  20127e:	701a      	strb	r2, [r3, #0]
		return 1;
  201280:	2301      	movs	r3, #1
	}
  201282:	4618      	mov	r0, r3
  201284:	370c      	adds	r7, #12
  201286:	46bd      	mov	sp, r7
  201288:	f85d 7b04 	ldr.w	r7, [sp], #4
  20128c:	4770      	bx	lr

0020128e <mini_vsnprintf>:
{
  20128e:	b580      	push	{r7, lr}
  201290:	b092      	sub	sp, #72	; 0x48
  201292:	af02      	add	r7, sp, #8
  201294:	607a      	str	r2, [r7, #4]
  201296:	603b      	str	r3, [r7, #0]
int mini_vsnprintf(char *buffer, unsigned int buffer_len, const char *fmt, va_list va)
  201298:	f107 0348 	add.w	r3, r7, #72	; 0x48
  20129c:	61bb      	str	r3, [r7, #24]
  20129e:	6138      	str	r0, [r7, #16]
  2012a0:	60f9      	str	r1, [r7, #12]
	char *pbuffer = buffer;
  2012a2:	693b      	ldr	r3, [r7, #16]
  2012a4:	617b      	str	r3, [r7, #20]
		*(pbuffer) = '\0';

		return len;
	}

	while ((ch = *(fmt++)))
  2012a6:	e0c1      	b.n	20142c <mini_vsnprintf+0x19e>
	{
		if ((unsigned int) ((pbuffer - buffer) + 1) >= buffer_len)
  2012a8:	697b      	ldr	r3, [r7, #20]
  2012aa:	461a      	mov	r2, r3
  2012ac:	693b      	ldr	r3, [r7, #16]
  2012ae:	1ad3      	subs	r3, r2, r3
  2012b0:	3301      	adds	r3, #1
  2012b2:	461a      	mov	r2, r3
  2012b4:	68fb      	ldr	r3, [r7, #12]
  2012b6:	429a      	cmp	r2, r3
  2012b8:	f080 80c4 	bcs.w	201444 <mini_vsnprintf+0x1b6>
			break;
		if (ch != '%')
  2012bc:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  2012c0:	2b25      	cmp	r3, #37	; 0x25
  2012c2:	d008      	beq.n	2012d6 <mini_vsnprintf+0x48>
			_putc(ch);
  2012c4:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
  2012c8:	f107 030c 	add.w	r3, r7, #12
  2012cc:	469c      	mov	ip, r3
  2012ce:	4610      	mov	r0, r2
  2012d0:	f7ff ffbb 	bl	20124a <_putc.5287>
  2012d4:	e0aa      	b.n	20142c <mini_vsnprintf+0x19e>
		else
		{
			char zero_pad = 0;
  2012d6:	2300      	movs	r3, #0
  2012d8:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
			char *ptr;
			unsigned int len;

			ch = *(fmt++);
  2012dc:	687b      	ldr	r3, [r7, #4]
  2012de:	1c5a      	adds	r2, r3, #1
  2012e0:	607a      	str	r2, [r7, #4]
  2012e2:	781b      	ldrb	r3, [r3, #0]
  2012e4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

			/* Zero padding requested */
			if (ch == '0')
  2012e8:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  2012ec:	2b30      	cmp	r3, #48	; 0x30
  2012ee:	d11d      	bne.n	20132c <mini_vsnprintf+0x9e>
			{
				ch = *(fmt++);
  2012f0:	687b      	ldr	r3, [r7, #4]
  2012f2:	1c5a      	adds	r2, r3, #1
  2012f4:	607a      	str	r2, [r7, #4]
  2012f6:	781b      	ldrb	r3, [r3, #0]
  2012f8:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
				if (ch == '\0')
  2012fc:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  201300:	2b00      	cmp	r3, #0
  201302:	f000 80a1 	beq.w	201448 <mini_vsnprintf+0x1ba>
					goto end;
				if (ch >= '0' && ch <= '9')
  201306:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  20130a:	2b2f      	cmp	r3, #47	; 0x2f
  20130c:	d908      	bls.n	201320 <mini_vsnprintf+0x92>
  20130e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  201312:	2b39      	cmp	r3, #57	; 0x39
  201314:	d804      	bhi.n	201320 <mini_vsnprintf+0x92>
					zero_pad = ch - '0';
  201316:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  20131a:	3b30      	subs	r3, #48	; 0x30
  20131c:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
				ch = *(fmt++);
  201320:	687b      	ldr	r3, [r7, #4]
  201322:	1c5a      	adds	r2, r3, #1
  201324:	607a      	str	r2, [r7, #4]
  201326:	781b      	ldrb	r3, [r3, #0]
  201328:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
			}

			switch (ch)
  20132c:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  201330:	2b64      	cmp	r3, #100	; 0x64
  201332:	d010      	beq.n	201356 <mini_vsnprintf+0xc8>
  201334:	2b64      	cmp	r3, #100	; 0x64
  201336:	dc07      	bgt.n	201348 <mini_vsnprintf+0xba>
  201338:	2b58      	cmp	r3, #88	; 0x58
  20133a:	d02f      	beq.n	20139c <mini_vsnprintf+0x10e>
  20133c:	2b63      	cmp	r3, #99	; 0x63
  20133e:	d04f      	beq.n	2013e0 <mini_vsnprintf+0x152>
  201340:	2b00      	cmp	r3, #0
  201342:	f000 8083 	beq.w	20144c <mini_vsnprintf+0x1be>
  201346:	e068      	b.n	20141a <mini_vsnprintf+0x18c>
  201348:	2b75      	cmp	r3, #117	; 0x75
  20134a:	d004      	beq.n	201356 <mini_vsnprintf+0xc8>
  20134c:	2b78      	cmp	r3, #120	; 0x78
  20134e:	d025      	beq.n	20139c <mini_vsnprintf+0x10e>
  201350:	2b73      	cmp	r3, #115	; 0x73
  201352:	d051      	beq.n	2013f8 <mini_vsnprintf+0x16a>
  201354:	e061      	b.n	20141a <mini_vsnprintf+0x18c>
			case 0:
				goto end;

			case 'u':
			case 'd':
				len = mini_itoa(va_arg(va, unsigned int), 10, 0, (ch == 'u'), bf, zero_pad);
  201356:	683b      	ldr	r3, [r7, #0]
  201358:	1d1a      	adds	r2, r3, #4
  20135a:	603a      	str	r2, [r7, #0]
  20135c:	681b      	ldr	r3, [r3, #0]
  20135e:	4618      	mov	r0, r3
  201360:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  201364:	2b75      	cmp	r3, #117	; 0x75
  201366:	bf0c      	ite	eq
  201368:	2301      	moveq	r3, #1
  20136a:	2300      	movne	r3, #0
  20136c:	b2db      	uxtb	r3, r3
  20136e:	461a      	mov	r2, r3
  201370:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
  201374:	9301      	str	r3, [sp, #4]
  201376:	f107 031c 	add.w	r3, r7, #28
  20137a:	9300      	str	r3, [sp, #0]
  20137c:	4613      	mov	r3, r2
  20137e:	2200      	movs	r2, #0
  201380:	210a      	movs	r1, #10
  201382:	f7ff fed4 	bl	20112e <mini_itoa>
  201386:	63b8      	str	r0, [r7, #56]	; 0x38
				_puts(bf, len);
  201388:	f107 021c 	add.w	r2, r7, #28
  20138c:	f107 030c 	add.w	r3, r7, #12
  201390:	469c      	mov	ip, r3
  201392:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  201394:	4610      	mov	r0, r2
  201396:	f000 f862 	bl	20145e <_puts.5291>
				break;
  20139a:	e047      	b.n	20142c <mini_vsnprintf+0x19e>

			case 'x':
			case 'X':
				len = mini_itoa(va_arg(va, unsigned int), 16, (ch == 'X'), 1, bf, zero_pad);
  20139c:	683b      	ldr	r3, [r7, #0]
  20139e:	1d1a      	adds	r2, r3, #4
  2013a0:	603a      	str	r2, [r7, #0]
  2013a2:	681b      	ldr	r3, [r3, #0]
  2013a4:	4618      	mov	r0, r3
  2013a6:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  2013aa:	2b58      	cmp	r3, #88	; 0x58
  2013ac:	bf0c      	ite	eq
  2013ae:	2301      	moveq	r3, #1
  2013b0:	2300      	movne	r3, #0
  2013b2:	b2db      	uxtb	r3, r3
  2013b4:	461a      	mov	r2, r3
  2013b6:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
  2013ba:	9301      	str	r3, [sp, #4]
  2013bc:	f107 031c 	add.w	r3, r7, #28
  2013c0:	9300      	str	r3, [sp, #0]
  2013c2:	2301      	movs	r3, #1
  2013c4:	2110      	movs	r1, #16
  2013c6:	f7ff feb2 	bl	20112e <mini_itoa>
  2013ca:	63b8      	str	r0, [r7, #56]	; 0x38
				_puts(bf, len);
  2013cc:	f107 021c 	add.w	r2, r7, #28
  2013d0:	f107 030c 	add.w	r3, r7, #12
  2013d4:	469c      	mov	ip, r3
  2013d6:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  2013d8:	4610      	mov	r0, r2
  2013da:	f000 f840 	bl	20145e <_puts.5291>
				break;
  2013de:	e025      	b.n	20142c <mini_vsnprintf+0x19e>

			case 'c':
				_putc((char) (va_arg(va, int)));
  2013e0:	683b      	ldr	r3, [r7, #0]
  2013e2:	1d1a      	adds	r2, r3, #4
  2013e4:	603a      	str	r2, [r7, #0]
  2013e6:	681b      	ldr	r3, [r3, #0]
  2013e8:	b2da      	uxtb	r2, r3
  2013ea:	f107 030c 	add.w	r3, r7, #12
  2013ee:	469c      	mov	ip, r3
  2013f0:	4610      	mov	r0, r2
  2013f2:	f7ff ff2a 	bl	20124a <_putc.5287>
				break;
  2013f6:	e019      	b.n	20142c <mini_vsnprintf+0x19e>

			case 's':
				ptr = va_arg(va, char*);
  2013f8:	683b      	ldr	r3, [r7, #0]
  2013fa:	1d1a      	adds	r2, r3, #4
  2013fc:	603a      	str	r2, [r7, #0]
  2013fe:	681b      	ldr	r3, [r3, #0]
  201400:	637b      	str	r3, [r7, #52]	; 0x34
				_puts(ptr, mini_strlen(ptr));
  201402:	6b78      	ldr	r0, [r7, #52]	; 0x34
  201404:	f7ff fe7c 	bl	201100 <mini_strlen>
  201408:	4602      	mov	r2, r0
  20140a:	f107 030c 	add.w	r3, r7, #12
  20140e:	469c      	mov	ip, r3
  201410:	4611      	mov	r1, r2
  201412:	6b78      	ldr	r0, [r7, #52]	; 0x34
  201414:	f000 f823 	bl	20145e <_puts.5291>
				break;
  201418:	e008      	b.n	20142c <mini_vsnprintf+0x19e>

			default:
				_putc(ch);
  20141a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
  20141e:	f107 030c 	add.w	r3, r7, #12
  201422:	469c      	mov	ip, r3
  201424:	4610      	mov	r0, r2
  201426:	f7ff ff10 	bl	20124a <_putc.5287>
				break;
  20142a:	bf00      	nop
	while ((ch = *(fmt++)))
  20142c:	687b      	ldr	r3, [r7, #4]
  20142e:	1c5a      	adds	r2, r3, #1
  201430:	607a      	str	r2, [r7, #4]
  201432:	781b      	ldrb	r3, [r3, #0]
  201434:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
  201438:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  20143c:	2b00      	cmp	r3, #0
  20143e:	f47f af33 	bne.w	2012a8 <mini_vsnprintf+0x1a>
  201442:	e004      	b.n	20144e <mini_vsnprintf+0x1c0>
			break;
  201444:	bf00      	nop
  201446:	e002      	b.n	20144e <mini_vsnprintf+0x1c0>
					goto end;
  201448:	bf00      	nop
  20144a:	e000      	b.n	20144e <mini_vsnprintf+0x1c0>
				goto end;
  20144c:	bf00      	nop
			}
		}
	}
	end: return pbuffer - buffer;
  20144e:	697b      	ldr	r3, [r7, #20]
  201450:	461a      	mov	r2, r3
  201452:	693b      	ldr	r3, [r7, #16]
  201454:	1ad3      	subs	r3, r2, r3
}
  201456:	4618      	mov	r0, r3
  201458:	3740      	adds	r7, #64	; 0x40
  20145a:	46bd      	mov	sp, r7
  20145c:	bd80      	pop	{r7, pc}

0020145e <_puts.5291>:
	{
  20145e:	b480      	push	{r7}
  201460:	b087      	sub	sp, #28
  201462:	af00      	add	r7, sp, #0
  201464:	60f8      	str	r0, [r7, #12]
  201466:	60b9      	str	r1, [r7, #8]
  201468:	4663      	mov	r3, ip
  20146a:	f8c7 c004 	str.w	ip, [r7, #4]
		if (buffer_len - (pbuffer - buffer) - 1 < len)
  20146e:	689a      	ldr	r2, [r3, #8]
  201470:	4611      	mov	r1, r2
  201472:	685a      	ldr	r2, [r3, #4]
  201474:	1a8a      	subs	r2, r1, r2
  201476:	4611      	mov	r1, r2
  201478:	681a      	ldr	r2, [r3, #0]
  20147a:	1a52      	subs	r2, r2, r1
  20147c:	1e51      	subs	r1, r2, #1
  20147e:	68ba      	ldr	r2, [r7, #8]
  201480:	4291      	cmp	r1, r2
  201482:	d208      	bcs.n	201496 <_puts.5291+0x38>
			len = buffer_len - (pbuffer - buffer) - 1;
  201484:	689a      	ldr	r2, [r3, #8]
  201486:	4611      	mov	r1, r2
  201488:	685a      	ldr	r2, [r3, #4]
  20148a:	1a8a      	subs	r2, r1, r2
  20148c:	4611      	mov	r1, r2
  20148e:	681a      	ldr	r2, [r3, #0]
  201490:	1a52      	subs	r2, r2, r1
  201492:	3a01      	subs	r2, #1
  201494:	60ba      	str	r2, [r7, #8]
		for (i = 0; i < len; i++)
  201496:	2200      	movs	r2, #0
  201498:	617a      	str	r2, [r7, #20]
  20149a:	e00a      	b.n	2014b2 <_puts.5291+0x54>
			*(pbuffer++) = s[i];
  20149c:	689a      	ldr	r2, [r3, #8]
  20149e:	1c51      	adds	r1, r2, #1
  2014a0:	6099      	str	r1, [r3, #8]
  2014a2:	68f8      	ldr	r0, [r7, #12]
  2014a4:	6979      	ldr	r1, [r7, #20]
  2014a6:	4401      	add	r1, r0
  2014a8:	7809      	ldrb	r1, [r1, #0]
  2014aa:	7011      	strb	r1, [r2, #0]
		for (i = 0; i < len; i++)
  2014ac:	697a      	ldr	r2, [r7, #20]
  2014ae:	3201      	adds	r2, #1
  2014b0:	617a      	str	r2, [r7, #20]
  2014b2:	6979      	ldr	r1, [r7, #20]
  2014b4:	68ba      	ldr	r2, [r7, #8]
  2014b6:	4291      	cmp	r1, r2
  2014b8:	d3f0      	bcc.n	20149c <_puts.5291+0x3e>
		*(pbuffer) = '\0';
  2014ba:	689b      	ldr	r3, [r3, #8]
  2014bc:	2200      	movs	r2, #0
  2014be:	701a      	strb	r2, [r3, #0]
		return len;
  2014c0:	68bb      	ldr	r3, [r7, #8]
	}
  2014c2:	4618      	mov	r0, r3
  2014c4:	371c      	adds	r7, #28
  2014c6:	46bd      	mov	sp, r7
  2014c8:	f85d 7b04 	ldr.w	r7, [sp], #4
  2014cc:	4770      	bx	lr
	...

002014d0 <SDCard_Init>:
#define MAX_OPEN_FILE   10

static FIL myFile[MAX_OPEN_FILE];

void SDCard_Init(void)
{
  2014d0:	b580      	push	{r7, lr}
  2014d2:	b082      	sub	sp, #8
  2014d4:	af00      	add	r7, sp, #0
	FRESULT result=f_mount(&SDFatFS, (TCHAR const*) SDPath, 1);
  2014d6:	2201      	movs	r2, #1
  2014d8:	4908      	ldr	r1, [pc, #32]	; (2014fc <SDCard_Init+0x2c>)
  2014da:	4809      	ldr	r0, [pc, #36]	; (201500 <SDCard_Init+0x30>)
  2014dc:	f021 f91c 	bl	222718 <f_mount>
  2014e0:	4603      	mov	r3, r0
  2014e2:	71fb      	strb	r3, [r7, #7]
	if(FR_OK!=result)
  2014e4:	79fb      	ldrb	r3, [r7, #7]
  2014e6:	2b00      	cmp	r3, #0
  2014e8:	d003      	beq.n	2014f2 <SDCard_Init+0x22>
		ERROR_SDcardMount((int)result);
  2014ea:	79fb      	ldrb	r3, [r7, #7]
  2014ec:	4618      	mov	r0, r3
  2014ee:	f7ff fd53 	bl	200f98 <ERROR_SDcardMount>
}
  2014f2:	bf00      	nop
  2014f4:	3708      	adds	r7, #8
  2014f6:	46bd      	mov	sp, r7
  2014f8:	bd80      	pop	{r7, pc}
  2014fa:	bf00      	nop
  2014fc:	20014e64 	.word	0x20014e64
  201500:	20015098 	.word	0x20015098

00201504 <SDCardFileOpen>:

int SDCardFileOpen(uint8_t id, char *fileName, uint8_t accessMode)
{
  201504:	b580      	push	{r7, lr}
  201506:	b084      	sub	sp, #16
  201508:	af00      	add	r7, sp, #0
  20150a:	4603      	mov	r3, r0
  20150c:	6039      	str	r1, [r7, #0]
  20150e:	71fb      	strb	r3, [r7, #7]
  201510:	4613      	mov	r3, r2
  201512:	71bb      	strb	r3, [r7, #6]
	FRESULT result=f_open(&myFile[id], fileName, accessMode);
  201514:	79fb      	ldrb	r3, [r7, #7]
  201516:	f44f 720c 	mov.w	r2, #560	; 0x230
  20151a:	fb02 f303 	mul.w	r3, r2, r3
  20151e:	4a0a      	ldr	r2, [pc, #40]	; (201548 <SDCardFileOpen+0x44>)
  201520:	4413      	add	r3, r2
  201522:	79ba      	ldrb	r2, [r7, #6]
  201524:	6839      	ldr	r1, [r7, #0]
  201526:	4618      	mov	r0, r3
  201528:	f021 f95a 	bl	2227e0 <f_open>
  20152c:	4603      	mov	r3, r0
  20152e:	73fb      	strb	r3, [r7, #15]
	if(FR_OK!=result)
  201530:	7bfb      	ldrb	r3, [r7, #15]
  201532:	2b00      	cmp	r3, #0
  201534:	d003      	beq.n	20153e <SDCardFileOpen+0x3a>
		ERROR_SDcardOpen((int)result);
  201536:	7bfb      	ldrb	r3, [r7, #15]
  201538:	4618      	mov	r0, r3
  20153a:	f7ff fd41 	bl	200fc0 <ERROR_SDcardOpen>
	return result;
  20153e:	7bfb      	ldrb	r3, [r7, #15]
}
  201540:	4618      	mov	r0, r3
  201542:	3710      	adds	r7, #16
  201544:	46bd      	mov	sp, r7
  201546:	bd80      	pop	{r7, pc}
  201548:	20000138 	.word	0x20000138

0020154c <SDCardFileRead>:

int SDCardFileRead(uint8_t id, char *buff, uint32_t size)
{
  20154c:	b580      	push	{r7, lr}
  20154e:	b088      	sub	sp, #32
  201550:	af00      	add	r7, sp, #0
  201552:	4603      	mov	r3, r0
  201554:	60b9      	str	r1, [r7, #8]
  201556:	607a      	str	r2, [r7, #4]
  201558:	73fb      	strb	r3, [r7, #15]
	int _result;
	uint32_t bytesRead;

	FRESULT result=f_read(&myFile[id], buff, size, (void *)&bytesRead);
  20155a:	7bfb      	ldrb	r3, [r7, #15]
  20155c:	f44f 720c 	mov.w	r2, #560	; 0x230
  201560:	fb02 f303 	mul.w	r3, r2, r3
  201564:	4a0d      	ldr	r2, [pc, #52]	; (20159c <SDCardFileRead+0x50>)
  201566:	1898      	adds	r0, r3, r2
  201568:	f107 0314 	add.w	r3, r7, #20
  20156c:	687a      	ldr	r2, [r7, #4]
  20156e:	68b9      	ldr	r1, [r7, #8]
  201570:	f021 fb10 	bl	222b94 <f_read>
  201574:	4603      	mov	r3, r0
  201576:	76fb      	strb	r3, [r7, #27]
	if(FR_OK!=result)
  201578:	7efb      	ldrb	r3, [r7, #27]
  20157a:	2b00      	cmp	r3, #0
  20157c:	d007      	beq.n	20158e <SDCardFileRead+0x42>
	{
		ERROR_SDcardOpen((int)result);
  20157e:	7efb      	ldrb	r3, [r7, #27]
  201580:	4618      	mov	r0, r3
  201582:	f7ff fd1d 	bl	200fc0 <ERROR_SDcardOpen>
		_result=result*(-1);
  201586:	7efb      	ldrb	r3, [r7, #27]
  201588:	425b      	negs	r3, r3
  20158a:	61fb      	str	r3, [r7, #28]
  20158c:	e001      	b.n	201592 <SDCardFileRead+0x46>
	}
	else
		_result=bytesRead;
  20158e:	697b      	ldr	r3, [r7, #20]
  201590:	61fb      	str	r3, [r7, #28]
	return _result;
  201592:	69fb      	ldr	r3, [r7, #28]
}
  201594:	4618      	mov	r0, r3
  201596:	3720      	adds	r7, #32
  201598:	46bd      	mov	sp, r7
  20159a:	bd80      	pop	{r7, pc}
  20159c:	20000138 	.word	0x20000138

002015a0 <SDCardFileWrite>:

int SDCardFileWrite(uint8_t id, char *buff, uint32_t size)
{
  2015a0:	b580      	push	{r7, lr}
  2015a2:	b088      	sub	sp, #32
  2015a4:	af00      	add	r7, sp, #0
  2015a6:	4603      	mov	r3, r0
  2015a8:	60b9      	str	r1, [r7, #8]
  2015aa:	607a      	str	r2, [r7, #4]
  2015ac:	73fb      	strb	r3, [r7, #15]
	int _result;
	uint32_t bytesWritten;

	FRESULT result=f_write(&myFile[id], buff, size, (void *)&bytesWritten);
  2015ae:	7bfb      	ldrb	r3, [r7, #15]
  2015b0:	f44f 720c 	mov.w	r2, #560	; 0x230
  2015b4:	fb02 f303 	mul.w	r3, r2, r3
  2015b8:	4a0d      	ldr	r2, [pc, #52]	; (2015f0 <SDCardFileWrite+0x50>)
  2015ba:	1898      	adds	r0, r3, r2
  2015bc:	f107 0314 	add.w	r3, r7, #20
  2015c0:	687a      	ldr	r2, [r7, #4]
  2015c2:	68b9      	ldr	r1, [r7, #8]
  2015c4:	f021 fc54 	bl	222e70 <f_write>
  2015c8:	4603      	mov	r3, r0
  2015ca:	76fb      	strb	r3, [r7, #27]
	if(FR_OK!=result)
  2015cc:	7efb      	ldrb	r3, [r7, #27]
  2015ce:	2b00      	cmp	r3, #0
  2015d0:	d007      	beq.n	2015e2 <SDCardFileWrite+0x42>
	{
		ERROR_SDcardWrite((int)result);
  2015d2:	7efb      	ldrb	r3, [r7, #27]
  2015d4:	4618      	mov	r0, r3
  2015d6:	f7ff fd07 	bl	200fe8 <ERROR_SDcardWrite>
		_result=result*(-1);
  2015da:	7efb      	ldrb	r3, [r7, #27]
  2015dc:	425b      	negs	r3, r3
  2015de:	61fb      	str	r3, [r7, #28]
  2015e0:	e001      	b.n	2015e6 <SDCardFileWrite+0x46>
	}
	else
		_result=bytesWritten;
  2015e2:	697b      	ldr	r3, [r7, #20]
  2015e4:	61fb      	str	r3, [r7, #28]
	return _result;
  2015e6:	69fb      	ldr	r3, [r7, #28]
}
  2015e8:	4618      	mov	r0, r3
  2015ea:	3720      	adds	r7, #32
  2015ec:	46bd      	mov	sp, r7
  2015ee:	bd80      	pop	{r7, pc}
  2015f0:	20000138 	.word	0x20000138

002015f4 <SDCardFileClose>:

int SDCardFileClose(uint8_t id)
{
  2015f4:	b580      	push	{r7, lr}
  2015f6:	b084      	sub	sp, #16
  2015f8:	af00      	add	r7, sp, #0
  2015fa:	4603      	mov	r3, r0
  2015fc:	71fb      	strb	r3, [r7, #7]
	FRESULT result=f_close(&myFile[id]);
  2015fe:	79fb      	ldrb	r3, [r7, #7]
  201600:	f44f 720c 	mov.w	r2, #560	; 0x230
  201604:	fb02 f303 	mul.w	r3, r2, r3
  201608:	4a09      	ldr	r2, [pc, #36]	; (201630 <SDCardFileClose+0x3c>)
  20160a:	4413      	add	r3, r2
  20160c:	4618      	mov	r0, r3
  20160e:	f021 fe5c 	bl	2232ca <f_close>
  201612:	4603      	mov	r3, r0
  201614:	73fb      	strb	r3, [r7, #15]
	if(FR_OK!=result)
  201616:	7bfb      	ldrb	r3, [r7, #15]
  201618:	2b00      	cmp	r3, #0
  20161a:	d003      	beq.n	201624 <SDCardFileClose+0x30>
		ERROR_SDcardClose((int)result);
  20161c:	7bfb      	ldrb	r3, [r7, #15]
  20161e:	4618      	mov	r0, r3
  201620:	f7ff fcf6 	bl	201010 <ERROR_SDcardClose>
	return result;
  201624:	7bfb      	ldrb	r3, [r7, #15]
}
  201626:	4618      	mov	r0, r3
  201628:	3710      	adds	r7, #16
  20162a:	46bd      	mov	sp, r7
  20162c:	bd80      	pop	{r7, pc}
  20162e:	bf00      	nop
  201630:	20000138 	.word	0x20000138

00201634 <SDCardFileInfo>:
{
	return f_size(&myFile[id]);
}

int SDCardFileInfo(char *name, uint32_t *fileSize)
{
  201634:	b580      	push	{r7, lr}
  201636:	b0ca      	sub	sp, #296	; 0x128
  201638:	af00      	add	r7, sp, #0
  20163a:	1d3b      	adds	r3, r7, #4
  20163c:	6018      	str	r0, [r3, #0]
  20163e:	463b      	mov	r3, r7
  201640:	6019      	str	r1, [r3, #0]
	FILINFO plikInfo;
	FRESULT result=f_stat(name, &plikInfo);   //f_size(&MyFile[id]); tylko gdy plik jest otwarty funkcj f_open()
  201642:	f107 020c 	add.w	r2, r7, #12
  201646:	1d3b      	adds	r3, r7, #4
  201648:	4611      	mov	r1, r2
  20164a:	6818      	ldr	r0, [r3, #0]
  20164c:	f021 fe6c 	bl	223328 <f_stat>
  201650:	4603      	mov	r3, r0
  201652:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
	if(FR_OK!=result)
  201656:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
  20165a:	2b00      	cmp	r3, #0
  20165c:	d005      	beq.n	20166a <SDCardFileInfo+0x36>
		ERROR_SDcardInfo((int)result);
  20165e:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
  201662:	4618      	mov	r0, r3
  201664:	f7ff fce8 	bl	201038 <ERROR_SDcardInfo>
  201668:	e005      	b.n	201676 <SDCardFileInfo+0x42>
	else
		*fileSize=plikInfo.fsize;
  20166a:	f107 030c 	add.w	r3, r7, #12
  20166e:	681a      	ldr	r2, [r3, #0]
  201670:	463b      	mov	r3, r7
  201672:	681b      	ldr	r3, [r3, #0]
  201674:	601a      	str	r2, [r3, #0]
	return result;
  201676:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
}
  20167a:	4618      	mov	r0, r3
  20167c:	f507 7794 	add.w	r7, r7, #296	; 0x128
  201680:	46bd      	mov	sp, r7
  201682:	bd80      	pop	{r7, pc}

00201684 <_IsSign.10745>:
	char sign;

	idx_copy=idx;

	int _IsSign(void)
	{
  201684:	b480      	push	{r7}
  201686:	b083      	sub	sp, #12
  201688:	af00      	add	r7, sp, #0
  20168a:	4663      	mov	r3, ip
  20168c:	f8c7 c004 	str.w	ip, [r7, #4]
		if(value<0)
  201690:	685a      	ldr	r2, [r3, #4]
  201692:	2a00      	cmp	r2, #0
  201694:	da05      	bge.n	2016a2 <_IsSign.10745+0x1e>
		{
			switch(plusMinus)
  201696:	681b      	ldr	r3, [r3, #0]
  201698:	3300      	adds	r3, #0
  20169a:	2b01      	cmp	r3, #1
  20169c:	d80b      	bhi.n	2016b6 <_IsSign.10745+0x32>
			{
			case Sign_plusMinus:
			case Sign_minus:
				return 1;
  20169e:	2301      	movs	r3, #1
  2016a0:	e00a      	b.n	2016b8 <_IsSign.10745+0x34>
			}
		}
		else if(value>0)
  2016a2:	685a      	ldr	r2, [r3, #4]
  2016a4:	2a00      	cmp	r2, #0
  2016a6:	dd06      	ble.n	2016b6 <_IsSign.10745+0x32>
		{
			switch(plusMinus)
  2016a8:	681b      	ldr	r3, [r3, #0]
  2016aa:	2b00      	cmp	r3, #0
  2016ac:	d001      	beq.n	2016b2 <_IsSign.10745+0x2e>
  2016ae:	2b02      	cmp	r3, #2
  2016b0:	d101      	bne.n	2016b6 <_IsSign.10745+0x32>
			{
			case Sign_plusMinus:
			case Sign_plus:
				return 1;
  2016b2:	2301      	movs	r3, #1
  2016b4:	e000      	b.n	2016b8 <_IsSign.10745+0x34>
			}
		}
		return 0;
  2016b6:	2300      	movs	r3, #0
	}
  2016b8:	4618      	mov	r0, r3
  2016ba:	370c      	adds	r7, #12
  2016bc:	46bd      	mov	sp, r7
  2016be:	f85d 7b04 	ldr.w	r7, [sp], #4
  2016c2:	4770      	bx	lr

002016c4 <Int2Str>:
{
  2016c4:	b580      	push	{r7, lr}
  2016c6:	b08c      	sub	sp, #48	; 0x30
  2016c8:	af00      	add	r7, sp, #0
  2016ca:	603a      	str	r2, [r7, #0]
  2016cc:	460a      	mov	r2, r1
  2016ce:	71fa      	strb	r2, [r7, #7]
char* Int2Str(int value, char freeSign, int maxDigits, int plusMinus)
  2016d0:	f107 0238 	add.w	r2, r7, #56	; 0x38
  2016d4:	617a      	str	r2, [r7, #20]
  2016d6:	6138      	str	r0, [r7, #16]
  2016d8:	60fb      	str	r3, [r7, #12]
	int i=10,k=1,j,idx_copy;
  2016da:	230a      	movs	r3, #10
  2016dc:	62fb      	str	r3, [r7, #44]	; 0x2c
  2016de:	2301      	movs	r3, #1
  2016e0:	62bb      	str	r3, [r7, #40]	; 0x28
	idx_copy=idx;
  2016e2:	4b60      	ldr	r3, [pc, #384]	; (201864 <Int2Str+0x1a0>)
  2016e4:	681b      	ldr	r3, [r3, #0]
  2016e6:	627b      	str	r3, [r7, #36]	; 0x24

	if(value<0){
  2016e8:	693b      	ldr	r3, [r7, #16]
  2016ea:	2b00      	cmp	r3, #0
  2016ec:	da05      	bge.n	2016fa <Int2Str+0x36>
		absolutValue=-value;
  2016ee:	693b      	ldr	r3, [r7, #16]
  2016f0:	425b      	negs	r3, r3
  2016f2:	623b      	str	r3, [r7, #32]
		sign='-';
  2016f4:	232d      	movs	r3, #45	; 0x2d
  2016f6:	77fb      	strb	r3, [r7, #31]
  2016f8:	e003      	b.n	201702 <Int2Str+0x3e>
	}
	else{
		absolutValue=value;
  2016fa:	693b      	ldr	r3, [r7, #16]
  2016fc:	623b      	str	r3, [r7, #32]
		sign='+';
  2016fe:	232b      	movs	r3, #43	; 0x2b
  201700:	77fb      	strb	r3, [r7, #31]
	}

	while(1)
	{
		if(absolutValue<i)
  201702:	6a3a      	ldr	r2, [r7, #32]
  201704:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  201706:	429a      	cmp	r2, r3
  201708:	f280 8093 	bge.w	201832 <Int2Str+0x16e>
		{
		   if(k<maxDigits)
  20170c:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20170e:	683b      	ldr	r3, [r7, #0]
  201710:	429a      	cmp	r2, r3
  201712:	da57      	bge.n	2017c4 <Int2Str+0x100>
			{
		   	if(idx+maxDigits >= SIZE_STRBUFF){
  201714:	4b53      	ldr	r3, [pc, #332]	; (201864 <Int2Str+0x1a0>)
  201716:	681a      	ldr	r2, [r3, #0]
  201718:	683b      	ldr	r3, [r7, #0]
  20171a:	4413      	add	r3, r2
  20171c:	2bc7      	cmp	r3, #199	; 0xc7
  20171e:	dd04      	ble.n	20172a <Int2Str+0x66>
		   		idx=0;
  201720:	4b50      	ldr	r3, [pc, #320]	; (201864 <Int2Str+0x1a0>)
  201722:	2200      	movs	r2, #0
  201724:	601a      	str	r2, [r3, #0]
		   		idx_copy=0;
  201726:	2300      	movs	r3, #0
  201728:	627b      	str	r3, [r7, #36]	; 0x24
		   	}

		   	if(Sign_none!=plusMinus)
  20172a:	68fb      	ldr	r3, [r7, #12]
  20172c:	2b03      	cmp	r3, #3
  20172e:	d024      	beq.n	20177a <Int2Str+0xb6>
		   	{
			   	if((freeSign==' '))
  201730:	79fb      	ldrb	r3, [r7, #7]
  201732:	2b20      	cmp	r3, #32
  201734:	d108      	bne.n	201748 <Int2Str+0x84>
			   		strBuff[idx++]=freeSign;
  201736:	4b4b      	ldr	r3, [pc, #300]	; (201864 <Int2Str+0x1a0>)
  201738:	681b      	ldr	r3, [r3, #0]
  20173a:	1c5a      	adds	r2, r3, #1
  20173c:	4949      	ldr	r1, [pc, #292]	; (201864 <Int2Str+0x1a0>)
  20173e:	600a      	str	r2, [r1, #0]
  201740:	4949      	ldr	r1, [pc, #292]	; (201868 <Int2Str+0x1a4>)
  201742:	79fa      	ldrb	r2, [r7, #7]
  201744:	54ca      	strb	r2, [r1, r3]
  201746:	e018      	b.n	20177a <Int2Str+0xb6>
			   	else
			   	{
			   		if(1==_IsSign())
  201748:	f107 030c 	add.w	r3, r7, #12
  20174c:	469c      	mov	ip, r3
  20174e:	f7ff ff99 	bl	201684 <_IsSign.10745>
  201752:	4603      	mov	r3, r0
  201754:	2b01      	cmp	r3, #1
  201756:	d108      	bne.n	20176a <Int2Str+0xa6>
			   			strBuff[idx++]=sign;
  201758:	4b42      	ldr	r3, [pc, #264]	; (201864 <Int2Str+0x1a0>)
  20175a:	681b      	ldr	r3, [r3, #0]
  20175c:	1c5a      	adds	r2, r3, #1
  20175e:	4941      	ldr	r1, [pc, #260]	; (201864 <Int2Str+0x1a0>)
  201760:	600a      	str	r2, [r1, #0]
  201762:	4941      	ldr	r1, [pc, #260]	; (201868 <Int2Str+0x1a4>)
  201764:	7ffa      	ldrb	r2, [r7, #31]
  201766:	54ca      	strb	r2, [r1, r3]
  201768:	e007      	b.n	20177a <Int2Str+0xb6>
			   		else
			   			strBuff[idx++]=' ';
  20176a:	4b3e      	ldr	r3, [pc, #248]	; (201864 <Int2Str+0x1a0>)
  20176c:	681b      	ldr	r3, [r3, #0]
  20176e:	1c5a      	adds	r2, r3, #1
  201770:	493c      	ldr	r1, [pc, #240]	; (201864 <Int2Str+0x1a0>)
  201772:	600a      	str	r2, [r1, #0]
  201774:	4a3c      	ldr	r2, [pc, #240]	; (201868 <Int2Str+0x1a4>)
  201776:	2120      	movs	r1, #32
  201778:	54d1      	strb	r1, [r2, r3]
			   	}
		   	}

		   	j=maxDigits-k;
  20177a:	683a      	ldr	r2, [r7, #0]
  20177c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20177e:	1ad3      	subs	r3, r2, r3
  201780:	61bb      	str	r3, [r7, #24]
		   	memset(&strBuff[idx],freeSign,j);
  201782:	4b38      	ldr	r3, [pc, #224]	; (201864 <Int2Str+0x1a0>)
  201784:	681b      	ldr	r3, [r3, #0]
  201786:	4a38      	ldr	r2, [pc, #224]	; (201868 <Int2Str+0x1a4>)
  201788:	4413      	add	r3, r2
  20178a:	79f9      	ldrb	r1, [r7, #7]
  20178c:	69ba      	ldr	r2, [r7, #24]
  20178e:	4618      	mov	r0, r3
  201790:	f024 fecf 	bl	226532 <memset>
		   	idx+=j;
  201794:	4b33      	ldr	r3, [pc, #204]	; (201864 <Int2Str+0x1a0>)
  201796:	681a      	ldr	r2, [r3, #0]
  201798:	69bb      	ldr	r3, [r7, #24]
  20179a:	4413      	add	r3, r2
  20179c:	4a31      	ldr	r2, [pc, #196]	; (201864 <Int2Str+0x1a0>)
  20179e:	6013      	str	r3, [r2, #0]

		   	if(freeSign==' ')
  2017a0:	79fb      	ldrb	r3, [r7, #7]
  2017a2:	2b20      	cmp	r3, #32
  2017a4:	d135      	bne.n	201812 <Int2Str+0x14e>
		   	{
		   		if(1==_IsSign())
  2017a6:	f107 030c 	add.w	r3, r7, #12
  2017aa:	469c      	mov	ip, r3
  2017ac:	f7ff ff6a 	bl	201684 <_IsSign.10745>
  2017b0:	4603      	mov	r3, r0
  2017b2:	2b01      	cmp	r3, #1
  2017b4:	d12d      	bne.n	201812 <Int2Str+0x14e>
		   			strBuff[idx-1]=sign;
  2017b6:	4b2b      	ldr	r3, [pc, #172]	; (201864 <Int2Str+0x1a0>)
  2017b8:	681b      	ldr	r3, [r3, #0]
  2017ba:	3b01      	subs	r3, #1
  2017bc:	492a      	ldr	r1, [pc, #168]	; (201868 <Int2Str+0x1a4>)
  2017be:	7ffa      	ldrb	r2, [r7, #31]
  2017c0:	54ca      	strb	r2, [r1, r3]
  2017c2:	e026      	b.n	201812 <Int2Str+0x14e>
		   	}
			}
		   else
		   {
		   	if(idx+k >= SIZE_STRBUFF){
  2017c4:	4b27      	ldr	r3, [pc, #156]	; (201864 <Int2Str+0x1a0>)
  2017c6:	681a      	ldr	r2, [r3, #0]
  2017c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2017ca:	4413      	add	r3, r2
  2017cc:	2bc7      	cmp	r3, #199	; 0xc7
  2017ce:	dd04      	ble.n	2017da <Int2Str+0x116>
		   		idx=0;
  2017d0:	4b24      	ldr	r3, [pc, #144]	; (201864 <Int2Str+0x1a0>)
  2017d2:	2200      	movs	r2, #0
  2017d4:	601a      	str	r2, [r3, #0]
		   		idx_copy=0;
  2017d6:	2300      	movs	r3, #0
  2017d8:	627b      	str	r3, [r7, #36]	; 0x24
		   	}

		   	if(Sign_none!=plusMinus)
  2017da:	68fb      	ldr	r3, [r7, #12]
  2017dc:	2b03      	cmp	r3, #3
  2017de:	d018      	beq.n	201812 <Int2Str+0x14e>
		   	{
		   		if(1==_IsSign())
  2017e0:	f107 030c 	add.w	r3, r7, #12
  2017e4:	469c      	mov	ip, r3
  2017e6:	f7ff ff4d 	bl	201684 <_IsSign.10745>
  2017ea:	4603      	mov	r3, r0
  2017ec:	2b01      	cmp	r3, #1
  2017ee:	d108      	bne.n	201802 <Int2Str+0x13e>
		   			strBuff[idx++]=sign;
  2017f0:	4b1c      	ldr	r3, [pc, #112]	; (201864 <Int2Str+0x1a0>)
  2017f2:	681b      	ldr	r3, [r3, #0]
  2017f4:	1c5a      	adds	r2, r3, #1
  2017f6:	491b      	ldr	r1, [pc, #108]	; (201864 <Int2Str+0x1a0>)
  2017f8:	600a      	str	r2, [r1, #0]
  2017fa:	491b      	ldr	r1, [pc, #108]	; (201868 <Int2Str+0x1a4>)
  2017fc:	7ffa      	ldrb	r2, [r7, #31]
  2017fe:	54ca      	strb	r2, [r1, r3]
  201800:	e007      	b.n	201812 <Int2Str+0x14e>
		   		else
		   			strBuff[idx++]=' ';
  201802:	4b18      	ldr	r3, [pc, #96]	; (201864 <Int2Str+0x1a0>)
  201804:	681b      	ldr	r3, [r3, #0]
  201806:	1c5a      	adds	r2, r3, #1
  201808:	4916      	ldr	r1, [pc, #88]	; (201864 <Int2Str+0x1a0>)
  20180a:	600a      	str	r2, [r1, #0]
  20180c:	4a16      	ldr	r2, [pc, #88]	; (201868 <Int2Str+0x1a4>)
  20180e:	2120      	movs	r1, #32
  201810:	54d1      	strb	r1, [r2, r3]
		   	}
		   }
			itoa(absolutValue,&strBuff[idx],10);
  201812:	4b14      	ldr	r3, [pc, #80]	; (201864 <Int2Str+0x1a0>)
  201814:	681b      	ldr	r3, [r3, #0]
  201816:	4a14      	ldr	r2, [pc, #80]	; (201868 <Int2Str+0x1a4>)
  201818:	4413      	add	r3, r2
  20181a:	220a      	movs	r2, #10
  20181c:	4619      	mov	r1, r3
  20181e:	6a38      	ldr	r0, [r7, #32]
  201820:	f024 fe7a 	bl	226518 <itoa>
			idx+=k;
  201824:	4b0f      	ldr	r3, [pc, #60]	; (201864 <Int2Str+0x1a0>)
  201826:	681a      	ldr	r2, [r3, #0]
  201828:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20182a:	4413      	add	r3, r2
  20182c:	4a0d      	ldr	r2, [pc, #52]	; (201864 <Int2Str+0x1a0>)
  20182e:	6013      	str	r3, [r2, #0]
			break;
  201830:	e009      	b.n	201846 <Int2Str+0x182>
		}
		else
		{
			i*=10;
  201832:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  201834:	4613      	mov	r3, r2
  201836:	009b      	lsls	r3, r3, #2
  201838:	4413      	add	r3, r2
  20183a:	005b      	lsls	r3, r3, #1
  20183c:	62fb      	str	r3, [r7, #44]	; 0x2c
			k++;
  20183e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  201840:	3301      	adds	r3, #1
  201842:	62bb      	str	r3, [r7, #40]	; 0x28
		if(absolutValue<i)
  201844:	e75d      	b.n	201702 <Int2Str+0x3e>
		}
	}
	strBuff[idx++]=0;
  201846:	4b07      	ldr	r3, [pc, #28]	; (201864 <Int2Str+0x1a0>)
  201848:	681b      	ldr	r3, [r3, #0]
  20184a:	1c5a      	adds	r2, r3, #1
  20184c:	4905      	ldr	r1, [pc, #20]	; (201864 <Int2Str+0x1a0>)
  20184e:	600a      	str	r2, [r1, #0]
  201850:	4a05      	ldr	r2, [pc, #20]	; (201868 <Int2Str+0x1a4>)
  201852:	2100      	movs	r1, #0
  201854:	54d1      	strb	r1, [r2, r3]
	return strBuff+idx_copy;
  201856:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  201858:	4a03      	ldr	r2, [pc, #12]	; (201868 <Int2Str+0x1a4>)
  20185a:	4413      	add	r3, r2
}
  20185c:	4618      	mov	r0, r3
  20185e:	3730      	adds	r7, #48	; 0x30
  201860:	46bd      	mov	sp, r7
  201862:	bd80      	pop	{r7, pc}
  201864:	20001844 	.word	0x20001844
  201868:	20001718 	.word	0x20001718

0020186c <_IsSign.10767>:
	char sign;

	idx_copy=idx;

	int _IsSign(void)
	{
  20186c:	b480      	push	{r7}
  20186e:	b083      	sub	sp, #12
  201870:	af00      	add	r7, sp, #0
  201872:	4663      	mov	r3, ip
  201874:	f8c7 c004 	str.w	ip, [r7, #4]
		if(value<0)
  201878:	edd3 7a01 	vldr	s15, [r3, #4]
  20187c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  201880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  201884:	d505      	bpl.n	201892 <_IsSign.10767+0x26>
		{
			switch(plusMinus)
  201886:	681b      	ldr	r3, [r3, #0]
  201888:	3300      	adds	r3, #0
  20188a:	2b01      	cmp	r3, #1
  20188c:	d80f      	bhi.n	2018ae <_IsSign.10767+0x42>
			{
			case Sign_plusMinus:
			case Sign_minus:
				return 1;
  20188e:	2301      	movs	r3, #1
  201890:	e00e      	b.n	2018b0 <_IsSign.10767+0x44>
			}
		}
		else if(value>0)
  201892:	edd3 7a01 	vldr	s15, [r3, #4]
  201896:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  20189a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20189e:	dd06      	ble.n	2018ae <_IsSign.10767+0x42>
		{
			switch(plusMinus)
  2018a0:	681b      	ldr	r3, [r3, #0]
  2018a2:	2b00      	cmp	r3, #0
  2018a4:	d001      	beq.n	2018aa <_IsSign.10767+0x3e>
  2018a6:	2b02      	cmp	r3, #2
  2018a8:	d101      	bne.n	2018ae <_IsSign.10767+0x42>
			{
			case Sign_plusMinus:
			case Sign_plus:
				return 1;
  2018aa:	2301      	movs	r3, #1
  2018ac:	e000      	b.n	2018b0 <_IsSign.10767+0x44>
			}
		}
		return 0;
  2018ae:	2300      	movs	r3, #0
	}
  2018b0:	4618      	mov	r0, r3
  2018b2:	370c      	adds	r7, #12
  2018b4:	46bd      	mov	sp, r7
  2018b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  2018ba:	4770      	bx	lr

002018bc <Float2Str>:
{
  2018bc:	b580      	push	{r7, lr}
  2018be:	b08e      	sub	sp, #56	; 0x38
  2018c0:	af00      	add	r7, sp, #0
  2018c2:	eef0 7a40 	vmov.f32	s15, s0
  2018c6:	60b9      	str	r1, [r7, #8]
  2018c8:	607b      	str	r3, [r7, #4]
  2018ca:	4603      	mov	r3, r0
  2018cc:	73fb      	strb	r3, [r7, #15]
char* Float2Str(float value, char freeSign, int maxDigits, int plusMinus, int dec_digits)
  2018ce:	f107 0340 	add.w	r3, r7, #64	; 0x40
  2018d2:	61fb      	str	r3, [r7, #28]
  2018d4:	edc7 7a06 	vstr	s15, [r7, #24]
  2018d8:	617a      	str	r2, [r7, #20]
	int i=10,k=1,j,idx_copy;
  2018da:	230a      	movs	r3, #10
  2018dc:	637b      	str	r3, [r7, #52]	; 0x34
  2018de:	2301      	movs	r3, #1
  2018e0:	633b      	str	r3, [r7, #48]	; 0x30
	idx_copy=idx;
  2018e2:	4b70      	ldr	r3, [pc, #448]	; (201aa4 <Float2Str+0x1e8>)
  2018e4:	681b      	ldr	r3, [r3, #0]
  2018e6:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(value<0){
  2018e8:	edd7 7a06 	vldr	s15, [r7, #24]
  2018ec:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  2018f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2018f4:	d509      	bpl.n	20190a <Float2Str+0x4e>
		absolutValue=-value;
  2018f6:	edd7 7a06 	vldr	s15, [r7, #24]
  2018fa:	eef1 7a67 	vneg.f32	s15, s15
  2018fe:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
		sign='-';
  201902:	232d      	movs	r3, #45	; 0x2d
  201904:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  201908:	e004      	b.n	201914 <Float2Str+0x58>
	}
	else{
		absolutValue=value;
  20190a:	69bb      	ldr	r3, [r7, #24]
  20190c:	62bb      	str	r3, [r7, #40]	; 0x28
		sign='+';
  20190e:	232b      	movs	r3, #43	; 0x2b
  201910:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	}

	while(1)
	{
		if(absolutValue<i)
  201914:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  201916:	ee07 3a90 	vmov	s15, r3
  20191a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  20191e:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  201922:	eeb4 7ae7 	vcmpe.f32	s14, s15
  201926:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20192a:	f340 80a1 	ble.w	201a70 <Float2Str+0x1b4>
		{
		   if(k<maxDigits)
  20192e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  201930:	68bb      	ldr	r3, [r7, #8]
  201932:	429a      	cmp	r2, r3
  201934:	da5c      	bge.n	2019f0 <Float2Str+0x134>
			{
		   	if(idx+maxDigits+dec_digits+1 >= SIZE_STRBUFF){
  201936:	4b5b      	ldr	r3, [pc, #364]	; (201aa4 <Float2Str+0x1e8>)
  201938:	681a      	ldr	r2, [r3, #0]
  20193a:	68bb      	ldr	r3, [r7, #8]
  20193c:	441a      	add	r2, r3
  20193e:	687b      	ldr	r3, [r7, #4]
  201940:	4413      	add	r3, r2
  201942:	3301      	adds	r3, #1
  201944:	2bc7      	cmp	r3, #199	; 0xc7
  201946:	dd04      	ble.n	201952 <Float2Str+0x96>
		   		idx=0;
  201948:	4b56      	ldr	r3, [pc, #344]	; (201aa4 <Float2Str+0x1e8>)
  20194a:	2200      	movs	r2, #0
  20194c:	601a      	str	r2, [r3, #0]
		   		idx_copy=0;
  20194e:	2300      	movs	r3, #0
  201950:	62fb      	str	r3, [r7, #44]	; 0x2c
		   	}

		   	if(Sign_none!=plusMinus)
  201952:	697b      	ldr	r3, [r7, #20]
  201954:	2b03      	cmp	r3, #3
  201956:	d025      	beq.n	2019a4 <Float2Str+0xe8>
		   	{
			   	if((freeSign==' '))
  201958:	7bfb      	ldrb	r3, [r7, #15]
  20195a:	2b20      	cmp	r3, #32
  20195c:	d108      	bne.n	201970 <Float2Str+0xb4>
			   		strBuff[idx++]=freeSign;
  20195e:	4b51      	ldr	r3, [pc, #324]	; (201aa4 <Float2Str+0x1e8>)
  201960:	681b      	ldr	r3, [r3, #0]
  201962:	1c5a      	adds	r2, r3, #1
  201964:	494f      	ldr	r1, [pc, #316]	; (201aa4 <Float2Str+0x1e8>)
  201966:	600a      	str	r2, [r1, #0]
  201968:	494f      	ldr	r1, [pc, #316]	; (201aa8 <Float2Str+0x1ec>)
  20196a:	7bfa      	ldrb	r2, [r7, #15]
  20196c:	54ca      	strb	r2, [r1, r3]
  20196e:	e019      	b.n	2019a4 <Float2Str+0xe8>
			   	else
			   	{
			   		if(1==_IsSign())
  201970:	f107 0314 	add.w	r3, r7, #20
  201974:	469c      	mov	ip, r3
  201976:	f7ff ff79 	bl	20186c <_IsSign.10767>
  20197a:	4603      	mov	r3, r0
  20197c:	2b01      	cmp	r3, #1
  20197e:	d109      	bne.n	201994 <Float2Str+0xd8>
			   			strBuff[idx++]=sign;
  201980:	4b48      	ldr	r3, [pc, #288]	; (201aa4 <Float2Str+0x1e8>)
  201982:	681b      	ldr	r3, [r3, #0]
  201984:	1c5a      	adds	r2, r3, #1
  201986:	4947      	ldr	r1, [pc, #284]	; (201aa4 <Float2Str+0x1e8>)
  201988:	600a      	str	r2, [r1, #0]
  20198a:	4947      	ldr	r1, [pc, #284]	; (201aa8 <Float2Str+0x1ec>)
  20198c:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  201990:	54ca      	strb	r2, [r1, r3]
  201992:	e007      	b.n	2019a4 <Float2Str+0xe8>
			   		else
			   			strBuff[idx++]=' ';
  201994:	4b43      	ldr	r3, [pc, #268]	; (201aa4 <Float2Str+0x1e8>)
  201996:	681b      	ldr	r3, [r3, #0]
  201998:	1c5a      	adds	r2, r3, #1
  20199a:	4942      	ldr	r1, [pc, #264]	; (201aa4 <Float2Str+0x1e8>)
  20199c:	600a      	str	r2, [r1, #0]
  20199e:	4a42      	ldr	r2, [pc, #264]	; (201aa8 <Float2Str+0x1ec>)
  2019a0:	2120      	movs	r1, #32
  2019a2:	54d1      	strb	r1, [r2, r3]
			   	}
		   	}

		   	j=maxDigits-k;
  2019a4:	68ba      	ldr	r2, [r7, #8]
  2019a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2019a8:	1ad3      	subs	r3, r2, r3
  2019aa:	623b      	str	r3, [r7, #32]
		   	memset(&strBuff[idx],freeSign,j);
  2019ac:	4b3d      	ldr	r3, [pc, #244]	; (201aa4 <Float2Str+0x1e8>)
  2019ae:	681b      	ldr	r3, [r3, #0]
  2019b0:	4a3d      	ldr	r2, [pc, #244]	; (201aa8 <Float2Str+0x1ec>)
  2019b2:	4413      	add	r3, r2
  2019b4:	7bf9      	ldrb	r1, [r7, #15]
  2019b6:	6a3a      	ldr	r2, [r7, #32]
  2019b8:	4618      	mov	r0, r3
  2019ba:	f024 fdba 	bl	226532 <memset>
		   	idx+=j;
  2019be:	4b39      	ldr	r3, [pc, #228]	; (201aa4 <Float2Str+0x1e8>)
  2019c0:	681a      	ldr	r2, [r3, #0]
  2019c2:	6a3b      	ldr	r3, [r7, #32]
  2019c4:	4413      	add	r3, r2
  2019c6:	4a37      	ldr	r2, [pc, #220]	; (201aa4 <Float2Str+0x1e8>)
  2019c8:	6013      	str	r3, [r2, #0]

		   	if(freeSign==' ')
  2019ca:	7bfb      	ldrb	r3, [r7, #15]
  2019cc:	2b20      	cmp	r3, #32
  2019ce:	d13a      	bne.n	201a46 <Float2Str+0x18a>
		   	{
		   		if(1==_IsSign())
  2019d0:	f107 0314 	add.w	r3, r7, #20
  2019d4:	469c      	mov	ip, r3
  2019d6:	f7ff ff49 	bl	20186c <_IsSign.10767>
  2019da:	4603      	mov	r3, r0
  2019dc:	2b01      	cmp	r3, #1
  2019de:	d132      	bne.n	201a46 <Float2Str+0x18a>
		   			strBuff[idx-1]=sign;
  2019e0:	4b30      	ldr	r3, [pc, #192]	; (201aa4 <Float2Str+0x1e8>)
  2019e2:	681b      	ldr	r3, [r3, #0]
  2019e4:	3b01      	subs	r3, #1
  2019e6:	4930      	ldr	r1, [pc, #192]	; (201aa8 <Float2Str+0x1ec>)
  2019e8:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  2019ec:	54ca      	strb	r2, [r1, r3]
  2019ee:	e02a      	b.n	201a46 <Float2Str+0x18a>
		   	}
			}
		   else
		   {
		   	if(idx+k+dec_digits+1 >= SIZE_STRBUFF){
  2019f0:	4b2c      	ldr	r3, [pc, #176]	; (201aa4 <Float2Str+0x1e8>)
  2019f2:	681a      	ldr	r2, [r3, #0]
  2019f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2019f6:	441a      	add	r2, r3
  2019f8:	687b      	ldr	r3, [r7, #4]
  2019fa:	4413      	add	r3, r2
  2019fc:	3301      	adds	r3, #1
  2019fe:	2bc7      	cmp	r3, #199	; 0xc7
  201a00:	dd04      	ble.n	201a0c <Float2Str+0x150>
		   		idx=0;
  201a02:	4b28      	ldr	r3, [pc, #160]	; (201aa4 <Float2Str+0x1e8>)
  201a04:	2200      	movs	r2, #0
  201a06:	601a      	str	r2, [r3, #0]
		   		idx_copy=0;
  201a08:	2300      	movs	r3, #0
  201a0a:	62fb      	str	r3, [r7, #44]	; 0x2c
		   	}

		   	if(Sign_none!=plusMinus)
  201a0c:	697b      	ldr	r3, [r7, #20]
  201a0e:	2b03      	cmp	r3, #3
  201a10:	d019      	beq.n	201a46 <Float2Str+0x18a>
		   	{
		   		if(1==_IsSign())
  201a12:	f107 0314 	add.w	r3, r7, #20
  201a16:	469c      	mov	ip, r3
  201a18:	f7ff ff28 	bl	20186c <_IsSign.10767>
  201a1c:	4603      	mov	r3, r0
  201a1e:	2b01      	cmp	r3, #1
  201a20:	d109      	bne.n	201a36 <Float2Str+0x17a>
		   			strBuff[idx++]=sign;
  201a22:	4b20      	ldr	r3, [pc, #128]	; (201aa4 <Float2Str+0x1e8>)
  201a24:	681b      	ldr	r3, [r3, #0]
  201a26:	1c5a      	adds	r2, r3, #1
  201a28:	491e      	ldr	r1, [pc, #120]	; (201aa4 <Float2Str+0x1e8>)
  201a2a:	600a      	str	r2, [r1, #0]
  201a2c:	491e      	ldr	r1, [pc, #120]	; (201aa8 <Float2Str+0x1ec>)
  201a2e:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  201a32:	54ca      	strb	r2, [r1, r3]
  201a34:	e007      	b.n	201a46 <Float2Str+0x18a>
		   		else
		   			strBuff[idx++]=' ';
  201a36:	4b1b      	ldr	r3, [pc, #108]	; (201aa4 <Float2Str+0x1e8>)
  201a38:	681b      	ldr	r3, [r3, #0]
  201a3a:	1c5a      	adds	r2, r3, #1
  201a3c:	4919      	ldr	r1, [pc, #100]	; (201aa4 <Float2Str+0x1e8>)
  201a3e:	600a      	str	r2, [r1, #0]
  201a40:	4a19      	ldr	r2, [pc, #100]	; (201aa8 <Float2Str+0x1ec>)
  201a42:	2120      	movs	r1, #32
  201a44:	54d1      	strb	r1, [r2, r3]
		   	}
		   }
			float2stri(&strBuff[idx], absolutValue,dec_digits);
  201a46:	4b17      	ldr	r3, [pc, #92]	; (201aa4 <Float2Str+0x1e8>)
  201a48:	681b      	ldr	r3, [r3, #0]
  201a4a:	4a17      	ldr	r2, [pc, #92]	; (201aa8 <Float2Str+0x1ec>)
  201a4c:	4413      	add	r3, r2
  201a4e:	687a      	ldr	r2, [r7, #4]
  201a50:	4611      	mov	r1, r2
  201a52:	ed97 0a0a 	vldr	s0, [r7, #40]	; 0x28
  201a56:	4618      	mov	r0, r3
  201a58:	f7fe ffba 	bl	2009d0 <float2stri>
			idx+=k+dec_digits+1;
  201a5c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  201a5e:	687b      	ldr	r3, [r7, #4]
  201a60:	4413      	add	r3, r2
  201a62:	1c5a      	adds	r2, r3, #1
  201a64:	4b0f      	ldr	r3, [pc, #60]	; (201aa4 <Float2Str+0x1e8>)
  201a66:	681b      	ldr	r3, [r3, #0]
  201a68:	4413      	add	r3, r2
  201a6a:	4a0e      	ldr	r2, [pc, #56]	; (201aa4 <Float2Str+0x1e8>)
  201a6c:	6013      	str	r3, [r2, #0]
			break;
  201a6e:	e009      	b.n	201a84 <Float2Str+0x1c8>
		}
		else
		{
			i*=10;
  201a70:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  201a72:	4613      	mov	r3, r2
  201a74:	009b      	lsls	r3, r3, #2
  201a76:	4413      	add	r3, r2
  201a78:	005b      	lsls	r3, r3, #1
  201a7a:	637b      	str	r3, [r7, #52]	; 0x34
			k++;
  201a7c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  201a7e:	3301      	adds	r3, #1
  201a80:	633b      	str	r3, [r7, #48]	; 0x30
		if(absolutValue<i)
  201a82:	e747      	b.n	201914 <Float2Str+0x58>
		}
	}
	strBuff[idx++]=0;
  201a84:	4b07      	ldr	r3, [pc, #28]	; (201aa4 <Float2Str+0x1e8>)
  201a86:	681b      	ldr	r3, [r3, #0]
  201a88:	1c5a      	adds	r2, r3, #1
  201a8a:	4906      	ldr	r1, [pc, #24]	; (201aa4 <Float2Str+0x1e8>)
  201a8c:	600a      	str	r2, [r1, #0]
  201a8e:	4a06      	ldr	r2, [pc, #24]	; (201aa8 <Float2Str+0x1ec>)
  201a90:	2100      	movs	r1, #0
  201a92:	54d1      	strb	r1, [r2, r3]
	return strBuff+idx_copy;
  201a94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  201a96:	4a04      	ldr	r2, [pc, #16]	; (201aa8 <Float2Str+0x1ec>)
  201a98:	4413      	add	r3, r2
}
  201a9a:	4618      	mov	r0, r3
  201a9c:	3738      	adds	r7, #56	; 0x38
  201a9e:	46bd      	mov	sp, r7
  201aa0:	bd80      	pop	{r7, pc}
  201aa2:	bf00      	nop
  201aa4:	20001844 	.word	0x20001844
  201aa8:	20001718 	.word	0x20001718

00201aac <StrAll>:

char* StrAll(int nrStr, ...)
{
  201aac:	b40f      	push	{r0, r1, r2, r3}
  201aae:	b580      	push	{r7, lr}
  201ab0:	b086      	sub	sp, #24
  201ab2:	af00      	add	r7, sp, #0
	int i,len,lenOut;
	char *ptr;
	va_list va;

	va_start(va,0);
  201ab4:	f107 0324 	add.w	r3, r7, #36	; 0x24
  201ab8:	607b      	str	r3, [r7, #4]
	strBuffOut[0]=0;
  201aba:	4b1c      	ldr	r3, [pc, #112]	; (201b2c <StrAll+0x80>)
  201abc:	2200      	movs	r2, #0
  201abe:	701a      	strb	r2, [r3, #0]

	for(i=0;i<nrStr;++i)
  201ac0:	2300      	movs	r3, #0
  201ac2:	617b      	str	r3, [r7, #20]
  201ac4:	e025      	b.n	201b12 <StrAll+0x66>
	{
		ptr=va_arg(va,char*);
  201ac6:	687b      	ldr	r3, [r7, #4]
  201ac8:	1d1a      	adds	r2, r3, #4
  201aca:	607a      	str	r2, [r7, #4]
  201acc:	681b      	ldr	r3, [r3, #0]
  201ace:	613b      	str	r3, [r7, #16]
		len=strlen(ptr);
  201ad0:	6938      	ldr	r0, [r7, #16]
  201ad2:	f7fe fbb5 	bl	200240 <strlen>
  201ad6:	4603      	mov	r3, r0
  201ad8:	60fb      	str	r3, [r7, #12]
		lenOut=strlen(strBuffOut);
  201ada:	4814      	ldr	r0, [pc, #80]	; (201b2c <StrAll+0x80>)
  201adc:	f7fe fbb0 	bl	200240 <strlen>
  201ae0:	4603      	mov	r3, r0
  201ae2:	60bb      	str	r3, [r7, #8]

		if(lenOut+len>=SIZE_STRBUFF_OUT){
  201ae4:	68ba      	ldr	r2, [r7, #8]
  201ae6:	68fb      	ldr	r3, [r7, #12]
  201ae8:	4413      	add	r3, r2
  201aea:	2b63      	cmp	r3, #99	; 0x63
  201aec:	dd08      	ble.n	201b00 <StrAll+0x54>
			strncat(strBuffOut,ptr,SIZE_STRBUFF_OUT-lenOut-1);
  201aee:	68bb      	ldr	r3, [r7, #8]
  201af0:	f1c3 0363 	rsb	r3, r3, #99	; 0x63
  201af4:	461a      	mov	r2, r3
  201af6:	6939      	ldr	r1, [r7, #16]
  201af8:	480c      	ldr	r0, [pc, #48]	; (201b2c <StrAll+0x80>)
  201afa:	f024 fd30 	bl	22655e <strncat>
			break;
  201afe:	e00c      	b.n	201b1a <StrAll+0x6e>
		}
		else
			strncat(strBuffOut,ptr,len);
  201b00:	68fb      	ldr	r3, [r7, #12]
  201b02:	461a      	mov	r2, r3
  201b04:	6939      	ldr	r1, [r7, #16]
  201b06:	4809      	ldr	r0, [pc, #36]	; (201b2c <StrAll+0x80>)
  201b08:	f024 fd29 	bl	22655e <strncat>
	for(i=0;i<nrStr;++i)
  201b0c:	697b      	ldr	r3, [r7, #20]
  201b0e:	3301      	adds	r3, #1
  201b10:	617b      	str	r3, [r7, #20]
  201b12:	697a      	ldr	r2, [r7, #20]
  201b14:	6a3b      	ldr	r3, [r7, #32]
  201b16:	429a      	cmp	r2, r3
  201b18:	dbd5      	blt.n	201ac6 <StrAll+0x1a>
	}

	va_end(va);
	return strBuffOut;
  201b1a:	4b04      	ldr	r3, [pc, #16]	; (201b2c <StrAll+0x80>)
}
  201b1c:	4618      	mov	r0, r3
  201b1e:	3718      	adds	r7, #24
  201b20:	46bd      	mov	sp, r7
  201b22:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
  201b26:	b004      	add	sp, #16
  201b28:	4770      	bx	lr
  201b2a:	bf00      	nop
  201b2c:	200017e0 	.word	0x200017e0

00201b30 <SwapUint16>:

void SwapUint16(uint16_t *a, uint16_t *b)
{
  201b30:	b480      	push	{r7}
  201b32:	b085      	sub	sp, #20
  201b34:	af00      	add	r7, sp, #0
  201b36:	6078      	str	r0, [r7, #4]
  201b38:	6039      	str	r1, [r7, #0]
	uint16_t a_temp=*a;
  201b3a:	687b      	ldr	r3, [r7, #4]
  201b3c:	881b      	ldrh	r3, [r3, #0]
  201b3e:	81fb      	strh	r3, [r7, #14]
	uint16_t b_temp=*b;
  201b40:	683b      	ldr	r3, [r7, #0]
  201b42:	881b      	ldrh	r3, [r3, #0]
  201b44:	81bb      	strh	r3, [r7, #12]
	*a=b_temp;
  201b46:	687b      	ldr	r3, [r7, #4]
  201b48:	89ba      	ldrh	r2, [r7, #12]
  201b4a:	801a      	strh	r2, [r3, #0]
	*b=a_temp;
  201b4c:	683b      	ldr	r3, [r7, #0]
  201b4e:	89fa      	ldrh	r2, [r7, #14]
  201b50:	801a      	strh	r2, [r3, #0]
}
  201b52:	bf00      	nop
  201b54:	3714      	adds	r7, #20
  201b56:	46bd      	mov	sp, r7
  201b58:	f85d 7b04 	ldr.w	r7, [sp], #4
  201b5c:	4770      	bx	lr
	...

00201b60 <StartMeasureTime>:
	}
	return 0;
}

void StartMeasureTime(int nr)
{
  201b60:	b580      	push	{r7, lr}
  201b62:	b082      	sub	sp, #8
  201b64:	af00      	add	r7, sp, #0
  201b66:	6078      	str	r0, [r7, #4]
	if(nr<MAX_MEASURE_TIME)
  201b68:	687b      	ldr	r3, [r7, #4]
  201b6a:	2b09      	cmp	r3, #9
  201b6c:	dc06      	bgt.n	201b7c <StartMeasureTime+0x1c>
		measurTime[nr] = xTaskGetTickCount();
  201b6e:	f023 fef5 	bl	22595c <xTaskGetTickCount>
  201b72:	4601      	mov	r1, r0
  201b74:	4a03      	ldr	r2, [pc, #12]	; (201b84 <StartMeasureTime+0x24>)
  201b76:	687b      	ldr	r3, [r7, #4]
  201b78:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
  201b7c:	bf00      	nop
  201b7e:	3708      	adds	r7, #8
  201b80:	46bd      	mov	sp, r7
  201b82:	bd80      	pop	{r7, pc}
  201b84:	20001848 	.word	0x20001848

00201b88 <StopMeasureTime>:
uint32_t StopMeasureTime(int nr, char *nameTime)
{
  201b88:	b580      	push	{r7, lr}
  201b8a:	b086      	sub	sp, #24
  201b8c:	af02      	add	r7, sp, #8
  201b8e:	6078      	str	r0, [r7, #4]
  201b90:	6039      	str	r1, [r7, #0]
	if(nr<MAX_MEASURE_TIME)
  201b92:	687b      	ldr	r3, [r7, #4]
  201b94:	2b09      	cmp	r3, #9
  201b96:	dc1b      	bgt.n	201bd0 <StopMeasureTime+0x48>
	{
		int measurTimeStop = xTaskGetTickCount();
  201b98:	f023 fee0 	bl	22595c <xTaskGetTickCount>
  201b9c:	4603      	mov	r3, r0
  201b9e:	60fb      	str	r3, [r7, #12]
		if(nameTime[0]>0)
  201ba0:	683b      	ldr	r3, [r7, #0]
  201ba2:	781b      	ldrb	r3, [r3, #0]
  201ba4:	2b00      	cmp	r3, #0
  201ba6:	d00c      	beq.n	201bc2 <StopMeasureTime+0x3a>
			DbgVar(1,20,"%s%d ",nameTime,measurTimeStop-measurTime[nr]);
  201ba8:	68fa      	ldr	r2, [r7, #12]
  201baa:	490c      	ldr	r1, [pc, #48]	; (201bdc <StopMeasureTime+0x54>)
  201bac:	687b      	ldr	r3, [r7, #4]
  201bae:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  201bb2:	1ad3      	subs	r3, r2, r3
  201bb4:	9300      	str	r3, [sp, #0]
  201bb6:	683b      	ldr	r3, [r7, #0]
  201bb8:	4a09      	ldr	r2, [pc, #36]	; (201be0 <StopMeasureTime+0x58>)
  201bba:	2114      	movs	r1, #20
  201bbc:	2001      	movs	r0, #1
  201bbe:	f7fe fe84 	bl	2008ca <DbgVar>
		return measurTimeStop-measurTime[nr];
  201bc2:	68fa      	ldr	r2, [r7, #12]
  201bc4:	4905      	ldr	r1, [pc, #20]	; (201bdc <StopMeasureTime+0x54>)
  201bc6:	687b      	ldr	r3, [r7, #4]
  201bc8:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
  201bcc:	1ad3      	subs	r3, r2, r3
  201bce:	e000      	b.n	201bd2 <StopMeasureTime+0x4a>
	}
	return 0;
  201bd0:	2300      	movs	r3, #0
}
  201bd2:	4618      	mov	r0, r3
  201bd4:	3710      	adds	r7, #16
  201bd6:	46bd      	mov	sp, r7
  201bd8:	bd80      	pop	{r7, pc}
  201bda:	bf00      	nop
  201bdc:	20001848 	.word	0x20001848
  201be0:	00228520 	.word	0x00228520

00201be4 <_Middle_RoundRectangleFrame>:
	float coeff[MAX_DEGREE_CIRCLE];
	uint8_t rot[MAX_DEGREE_CIRCLE];
}Circle_Param;
static Circle_Param Circle;

static void _Middle_RoundRectangleFrame(int rectangleFrame, int fillHeight, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpSizeX, uint32_t width, uint32_t height){
  201be4:	b580      	push	{r7, lr}
  201be6:	b088      	sub	sp, #32
  201be8:	af00      	add	r7, sp, #0
  201bea:	60f8      	str	r0, [r7, #12]
  201bec:	60b9      	str	r1, [r7, #8]
  201bee:	607a      	str	r2, [r7, #4]
  201bf0:	603b      	str	r3, [r7, #0]
	int _height = height-fillHeight;
  201bf2:	68bb      	ldr	r3, [r7, #8]
  201bf4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  201bf6:	1ad3      	subs	r3, r2, r3
  201bf8:	617b      	str	r3, [r7, #20]
	int _width = width-2;
  201bfa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  201bfc:	3b02      	subs	r3, #2
  201bfe:	613b      	str	r3, [r7, #16]
	if(rectangleFrame)
  201c00:	68fb      	ldr	r3, [r7, #12]
  201c02:	2b00      	cmp	r3, #0
  201c04:	d01a      	beq.n	201c3c <_Middle_RoundRectangleFrame+0x58>
	{
		for (int j=0; j<_height; j++)
  201c06:	2300      	movs	r3, #0
  201c08:	61fb      	str	r3, [r7, #28]
  201c0a:	e012      	b.n	201c32 <_Middle_RoundRectangleFrame+0x4e>
		{
			_FillBuff(1, FrameColor);
  201c0c:	6879      	ldr	r1, [r7, #4]
  201c0e:	2001      	movs	r0, #1
  201c10:	f003 f81a 	bl	204c48 <_FillBuff>
			_FillBuff(_width, FillColor);
  201c14:	6839      	ldr	r1, [r7, #0]
  201c16:	6938      	ldr	r0, [r7, #16]
  201c18:	f003 f816 	bl	204c48 <_FillBuff>
			_FillBuff(1, FrameColor);
  201c1c:	6879      	ldr	r1, [r7, #4]
  201c1e:	2001      	movs	r0, #1
  201c20:	f003 f812 	bl	204c48 <_FillBuff>
			_NextDrawLine(BkpSizeX,width);
  201c24:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  201c26:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  201c28:	f003 f922 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<_height; j++)
  201c2c:	69fb      	ldr	r3, [r7, #28]
  201c2e:	3301      	adds	r3, #1
  201c30:	61fb      	str	r3, [r7, #28]
  201c32:	69fa      	ldr	r2, [r7, #28]
  201c34:	697b      	ldr	r3, [r7, #20]
  201c36:	429a      	cmp	r2, r3
  201c38:	dbe8      	blt.n	201c0c <_Middle_RoundRectangleFrame+0x28>
			k+=_width;
			_FillBuff(1, FrameColor);
			_NextDrawLine(BkpSizeX,width);
		}
	}
}
  201c3a:	e01b      	b.n	201c74 <_Middle_RoundRectangleFrame+0x90>
		for (int j=0; j<_height; j++)
  201c3c:	2300      	movs	r3, #0
  201c3e:	61bb      	str	r3, [r7, #24]
  201c40:	e014      	b.n	201c6c <_Middle_RoundRectangleFrame+0x88>
			_FillBuff(1, FrameColor);
  201c42:	6879      	ldr	r1, [r7, #4]
  201c44:	2001      	movs	r0, #1
  201c46:	f002 ffff 	bl	204c48 <_FillBuff>
			k+=_width;
  201c4a:	4b0c      	ldr	r3, [pc, #48]	; (201c7c <_Middle_RoundRectangleFrame+0x98>)
  201c4c:	681a      	ldr	r2, [r3, #0]
  201c4e:	693b      	ldr	r3, [r7, #16]
  201c50:	4413      	add	r3, r2
  201c52:	4a0a      	ldr	r2, [pc, #40]	; (201c7c <_Middle_RoundRectangleFrame+0x98>)
  201c54:	6013      	str	r3, [r2, #0]
			_FillBuff(1, FrameColor);
  201c56:	6879      	ldr	r1, [r7, #4]
  201c58:	2001      	movs	r0, #1
  201c5a:	f002 fff5 	bl	204c48 <_FillBuff>
			_NextDrawLine(BkpSizeX,width);
  201c5e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  201c60:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  201c62:	f003 f905 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<_height; j++)
  201c66:	69bb      	ldr	r3, [r7, #24]
  201c68:	3301      	adds	r3, #1
  201c6a:	61bb      	str	r3, [r7, #24]
  201c6c:	69ba      	ldr	r2, [r7, #24]
  201c6e:	697b      	ldr	r3, [r7, #20]
  201c70:	429a      	cmp	r2, r3
  201c72:	dbe6      	blt.n	201c42 <_Middle_RoundRectangleFrame+0x5e>
}
  201c74:	bf00      	nop
  201c76:	3720      	adds	r7, #32
  201c78:	46bd      	mov	sp, r7
  201c7a:	bd80      	pop	{r7, pc}
  201c7c:	20001870 	.word	0x20001870

00201c80 <_Fill.11212>:
		o1 = GetTransitionColor(FrameColor,BkpColor,AA.c1);
		o2 = GetTransitionColor(FrameColor,BkpColor,AA.c2);
	}

	void _Fill(int x)
	{
  201c80:	b580      	push	{r7, lr}
  201c82:	b082      	sub	sp, #8
  201c84:	af00      	add	r7, sp, #0
  201c86:	6078      	str	r0, [r7, #4]
  201c88:	4663      	mov	r3, ip
  201c8a:	f8c7 c000 	str.w	ip, [r7]
		if(rectangleFrame)
  201c8e:	691a      	ldr	r2, [r3, #16]
  201c90:	2a00      	cmp	r2, #0
  201c92:	d005      	beq.n	201ca0 <_Fill.11212+0x20>
			A(x,FillColor);
  201c94:	68db      	ldr	r3, [r3, #12]
  201c96:	4619      	mov	r1, r3
  201c98:	6878      	ldr	r0, [r7, #4]
  201c9a:	f002 ffd5 	bl	204c48 <_FillBuff>
		else
			k+=x;
	}
  201c9e:	e005      	b.n	201cac <_Fill.11212+0x2c>
			k+=x;
  201ca0:	4b04      	ldr	r3, [pc, #16]	; (201cb4 <_Fill.11212+0x34>)
  201ca2:	681a      	ldr	r2, [r3, #0]
  201ca4:	687b      	ldr	r3, [r7, #4]
  201ca6:	4413      	add	r3, r2
  201ca8:	4a02      	ldr	r2, [pc, #8]	; (201cb4 <_Fill.11212+0x34>)
  201caa:	6013      	str	r3, [r2, #0]
	}
  201cac:	bf00      	nop
  201cae:	3708      	adds	r7, #8
  201cb0:	46bd      	mov	sp, r7
  201cb2:	bd80      	pop	{r7, pc}
  201cb4:	20001870 	.word	0x20001870

00201cb8 <LCD_DrawRoundRectangleFrame>:
{
  201cb8:	b580      	push	{r7, lr}
  201cba:	b092      	sub	sp, #72	; 0x48
  201cbc:	af04      	add	r7, sp, #16
  201cbe:	60f9      	str	r1, [r7, #12]
  201cc0:	60ba      	str	r2, [r7, #8]
  201cc2:	607b      	str	r3, [r7, #4]
  201cc4:	6d79      	ldr	r1, [r7, #84]	; 0x54
  201cc6:	6dba      	ldr	r2, [r7, #88]	; 0x58
static void LCD_DrawRoundRectangleFrame(int rectangleFrame, uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor)
  201cc8:	f107 0340 	add.w	r3, r7, #64	; 0x40
  201ccc:	62fb      	str	r3, [r7, #44]	; 0x2c
  201cce:	6278      	str	r0, [r7, #36]	; 0x24
  201cd0:	6239      	str	r1, [r7, #32]
  201cd2:	61fa      	str	r2, [r7, #28]
	uint8_t thickness = BkpColor>>24;
  201cd4:	69fb      	ldr	r3, [r7, #28]
  201cd6:	0e1b      	lsrs	r3, r3, #24
  201cd8:	b2db      	uxtb	r3, r3
  201cda:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
	uint32_t i1 = GetTransitionColor(FrameColor,FillColor,AA.c1);
  201cde:	4b1b      	ldr	r3, [pc, #108]	; (201d4c <LCD_DrawRoundRectangleFrame+0x94>)
  201ce0:	edd3 7a00 	vldr	s15, [r3]
  201ce4:	6a3b      	ldr	r3, [r7, #32]
  201ce6:	eeb0 0a67 	vmov.f32	s0, s15
  201cea:	4619      	mov	r1, r3
  201cec:	6d38      	ldr	r0, [r7, #80]	; 0x50
  201cee:	f005 fc87 	bl	207600 <GetTransitionColor>
  201cf2:	6378      	str	r0, [r7, #52]	; 0x34
	uint32_t i2 = GetTransitionColor(FrameColor,FillColor,AA.c2);
  201cf4:	4b15      	ldr	r3, [pc, #84]	; (201d4c <LCD_DrawRoundRectangleFrame+0x94>)
  201cf6:	edd3 7a01 	vldr	s15, [r3, #4]
  201cfa:	6a3b      	ldr	r3, [r7, #32]
  201cfc:	eeb0 0a67 	vmov.f32	s0, s15
  201d00:	4619      	mov	r1, r3
  201d02:	6d38      	ldr	r0, [r7, #80]	; 0x50
  201d04:	f005 fc7c 	bl	207600 <GetTransitionColor>
  201d08:	6338      	str	r0, [r7, #48]	; 0x30
	if((thickness==0)||(thickness==255)){
  201d0a:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  201d0e:	2b00      	cmp	r3, #0
  201d10:	d003      	beq.n	201d1a <LCD_DrawRoundRectangleFrame+0x62>
  201d12:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
  201d16:	2bff      	cmp	r3, #255	; 0xff
  201d18:	d11a      	bne.n	201d50 <LCD_DrawRoundRectangleFrame+0x98>
		o1 = GetTransitionColor(FrameColor,BkpColor,AA.c1);
  201d1a:	4b0c      	ldr	r3, [pc, #48]	; (201d4c <LCD_DrawRoundRectangleFrame+0x94>)
  201d1c:	edd3 7a00 	vldr	s15, [r3]
  201d20:	69fb      	ldr	r3, [r7, #28]
  201d22:	eeb0 0a67 	vmov.f32	s0, s15
  201d26:	4619      	mov	r1, r3
  201d28:	6d38      	ldr	r0, [r7, #80]	; 0x50
  201d2a:	f005 fc69 	bl	207600 <GetTransitionColor>
  201d2e:	4603      	mov	r3, r0
  201d30:	617b      	str	r3, [r7, #20]
		o2 = GetTransitionColor(FrameColor,BkpColor,AA.c2);
  201d32:	4b06      	ldr	r3, [pc, #24]	; (201d4c <LCD_DrawRoundRectangleFrame+0x94>)
  201d34:	edd3 7a01 	vldr	s15, [r3, #4]
  201d38:	69fb      	ldr	r3, [r7, #28]
  201d3a:	eeb0 0a67 	vmov.f32	s0, s15
  201d3e:	4619      	mov	r1, r3
  201d40:	6d38      	ldr	r0, [r7, #80]	; 0x50
  201d42:	f005 fc5d 	bl	207600 <GetTransitionColor>
  201d46:	4603      	mov	r3, r0
  201d48:	61bb      	str	r3, [r7, #24]
  201d4a:	e001      	b.n	201d50 <LCD_DrawRoundRectangleFrame+0x98>
  201d4c:	20002050 	.word	0x20002050
			case 4:	k+=1; break;
			}
		}
	}

	_StartDrawLine(posBuff,BkpSizeX,x,y);
  201d50:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  201d52:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  201d54:	68b9      	ldr	r1, [r7, #8]
  201d56:	68f8      	ldr	r0, [r7, #12]
  201d58:	f003 f822 	bl	204da0 <_StartDrawLine>
	_Out_AA_left(0); A(width-10,FrameColor); _Out_AA_right(0);
  201d5c:	f107 0314 	add.w	r3, r7, #20
  201d60:	469c      	mov	ip, r3
  201d62:	2000      	movs	r0, #0
  201d64:	f000 f9f0 	bl	202148 <_Out_AA_left.11215>
  201d68:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201d6a:	3b0a      	subs	r3, #10
  201d6c:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201d6e:	4618      	mov	r0, r3
  201d70:	f002 ff6a 	bl	204c48 <_FillBuff>
  201d74:	f107 0314 	add.w	r3, r7, #20
  201d78:	469c      	mov	ip, r3
  201d7a:	2000      	movs	r0, #0
  201d7c:	f000 fa6c 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  201d80:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201d82:	68b8      	ldr	r0, [r7, #8]
  201d84:	f003 f874 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(1); A(2,FrameColor); A(1,i1);A(1,i2); _Fill(width-14); A(1,i2);A(1,i1);A(2,FrameColor); _Out_AA_right(1);
  201d88:	f107 0314 	add.w	r3, r7, #20
  201d8c:	469c      	mov	ip, r3
  201d8e:	2001      	movs	r0, #1
  201d90:	f000 f9da 	bl	202148 <_Out_AA_left.11215>
  201d94:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201d96:	2002      	movs	r0, #2
  201d98:	f002 ff56 	bl	204c48 <_FillBuff>
  201d9c:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201d9e:	2001      	movs	r0, #1
  201da0:	f002 ff52 	bl	204c48 <_FillBuff>
  201da4:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201da6:	2001      	movs	r0, #1
  201da8:	f002 ff4e 	bl	204c48 <_FillBuff>
  201dac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201dae:	3b0e      	subs	r3, #14
  201db0:	461a      	mov	r2, r3
  201db2:	f107 0314 	add.w	r3, r7, #20
  201db6:	469c      	mov	ip, r3
  201db8:	4610      	mov	r0, r2
  201dba:	f7ff ff61 	bl	201c80 <_Fill.11212>
  201dbe:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201dc0:	2001      	movs	r0, #1
  201dc2:	f002 ff41 	bl	204c48 <_FillBuff>
  201dc6:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201dc8:	2001      	movs	r0, #1
  201dca:	f002 ff3d 	bl	204c48 <_FillBuff>
  201dce:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201dd0:	2002      	movs	r0, #2
  201dd2:	f002 ff39 	bl	204c48 <_FillBuff>
  201dd6:	f107 0314 	add.w	r3, r7, #20
  201dda:	469c      	mov	ip, r3
  201ddc:	2001      	movs	r0, #1
  201dde:	f000 fa3b 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  201de2:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201de4:	68b8      	ldr	r0, [r7, #8]
  201de6:	f003 f843 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(2); A(1,FrameColor); A(1,i1); _Fill(width-8); A(1,i1); A(1,FrameColor); _Out_AA_right(2);
  201dea:	f107 0314 	add.w	r3, r7, #20
  201dee:	469c      	mov	ip, r3
  201df0:	2002      	movs	r0, #2
  201df2:	f000 f9a9 	bl	202148 <_Out_AA_left.11215>
  201df6:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201df8:	2001      	movs	r0, #1
  201dfa:	f002 ff25 	bl	204c48 <_FillBuff>
  201dfe:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201e00:	2001      	movs	r0, #1
  201e02:	f002 ff21 	bl	204c48 <_FillBuff>
  201e06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201e08:	3b08      	subs	r3, #8
  201e0a:	461a      	mov	r2, r3
  201e0c:	f107 0314 	add.w	r3, r7, #20
  201e10:	469c      	mov	ip, r3
  201e12:	4610      	mov	r0, r2
  201e14:	f7ff ff34 	bl	201c80 <_Fill.11212>
  201e18:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201e1a:	2001      	movs	r0, #1
  201e1c:	f002 ff14 	bl	204c48 <_FillBuff>
  201e20:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201e22:	2001      	movs	r0, #1
  201e24:	f002 ff10 	bl	204c48 <_FillBuff>
  201e28:	f107 0314 	add.w	r3, r7, #20
  201e2c:	469c      	mov	ip, r3
  201e2e:	2002      	movs	r0, #2
  201e30:	f000 fa12 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  201e34:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201e36:	68b8      	ldr	r0, [r7, #8]
  201e38:	f003 f81a 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(3); A(1,FrameColor); A(1,i1); _Fill(width-6); A(1,i1); A(1,FrameColor); _Out_AA_right(3);
  201e3c:	f107 0314 	add.w	r3, r7, #20
  201e40:	469c      	mov	ip, r3
  201e42:	2003      	movs	r0, #3
  201e44:	f000 f980 	bl	202148 <_Out_AA_left.11215>
  201e48:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201e4a:	2001      	movs	r0, #1
  201e4c:	f002 fefc 	bl	204c48 <_FillBuff>
  201e50:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201e52:	2001      	movs	r0, #1
  201e54:	f002 fef8 	bl	204c48 <_FillBuff>
  201e58:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201e5a:	3b06      	subs	r3, #6
  201e5c:	461a      	mov	r2, r3
  201e5e:	f107 0314 	add.w	r3, r7, #20
  201e62:	469c      	mov	ip, r3
  201e64:	4610      	mov	r0, r2
  201e66:	f7ff ff0b 	bl	201c80 <_Fill.11212>
  201e6a:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201e6c:	2001      	movs	r0, #1
  201e6e:	f002 feeb 	bl	204c48 <_FillBuff>
  201e72:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201e74:	2001      	movs	r0, #1
  201e76:	f002 fee7 	bl	204c48 <_FillBuff>
  201e7a:	f107 0314 	add.w	r3, r7, #20
  201e7e:	469c      	mov	ip, r3
  201e80:	2003      	movs	r0, #3
  201e82:	f000 f9e9 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  201e86:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201e88:	68b8      	ldr	r0, [r7, #8]
  201e8a:	f002 fff1 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(4); A(1,FrameColor); _Fill(width-4); A(1,FrameColor); _Out_AA_right(4);
  201e8e:	f107 0314 	add.w	r3, r7, #20
  201e92:	469c      	mov	ip, r3
  201e94:	2004      	movs	r0, #4
  201e96:	f000 f957 	bl	202148 <_Out_AA_left.11215>
  201e9a:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201e9c:	2001      	movs	r0, #1
  201e9e:	f002 fed3 	bl	204c48 <_FillBuff>
  201ea2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201ea4:	3b04      	subs	r3, #4
  201ea6:	461a      	mov	r2, r3
  201ea8:	f107 0314 	add.w	r3, r7, #20
  201eac:	469c      	mov	ip, r3
  201eae:	4610      	mov	r0, r2
  201eb0:	f7ff fee6 	bl	201c80 <_Fill.11212>
  201eb4:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201eb6:	2001      	movs	r0, #1
  201eb8:	f002 fec6 	bl	204c48 <_FillBuff>
  201ebc:	f107 0314 	add.w	r3, r7, #20
  201ec0:	469c      	mov	ip, r3
  201ec2:	2004      	movs	r0, #4
  201ec4:	f000 f9c8 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  201ec8:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201eca:	68b8      	ldr	r0, [r7, #8]
  201ecc:	f002 ffd0 	bl	204e70 <_NextDrawLine>

	A(1,FrameColor);  A(1,i1); _Fill(width-4); A(1,i1); A(1,FrameColor);
  201ed0:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201ed2:	2001      	movs	r0, #1
  201ed4:	f002 feb8 	bl	204c48 <_FillBuff>
  201ed8:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201eda:	2001      	movs	r0, #1
  201edc:	f002 feb4 	bl	204c48 <_FillBuff>
  201ee0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201ee2:	3b04      	subs	r3, #4
  201ee4:	461a      	mov	r2, r3
  201ee6:	f107 0314 	add.w	r3, r7, #20
  201eea:	469c      	mov	ip, r3
  201eec:	4610      	mov	r0, r2
  201eee:	f7ff fec7 	bl	201c80 <_Fill.11212>
  201ef2:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201ef4:	2001      	movs	r0, #1
  201ef6:	f002 fea7 	bl	204c48 <_FillBuff>
  201efa:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201efc:	2001      	movs	r0, #1
  201efe:	f002 fea3 	bl	204c48 <_FillBuff>
	_NextDrawLine(BkpSizeX,width);
  201f02:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201f04:	68b8      	ldr	r0, [r7, #8]
  201f06:	f002 ffb3 	bl	204e70 <_NextDrawLine>
	A(1,FrameColor);  A(1,i2); _Fill(width-4); A(1,i2); A(1,FrameColor);
  201f0a:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201f0c:	2001      	movs	r0, #1
  201f0e:	f002 fe9b 	bl	204c48 <_FillBuff>
  201f12:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201f14:	2001      	movs	r0, #1
  201f16:	f002 fe97 	bl	204c48 <_FillBuff>
  201f1a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201f1c:	3b04      	subs	r3, #4
  201f1e:	461a      	mov	r2, r3
  201f20:	f107 0314 	add.w	r3, r7, #20
  201f24:	469c      	mov	ip, r3
  201f26:	4610      	mov	r0, r2
  201f28:	f7ff feaa 	bl	201c80 <_Fill.11212>
  201f2c:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201f2e:	2001      	movs	r0, #1
  201f30:	f002 fe8a 	bl	204c48 <_FillBuff>
  201f34:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201f36:	2001      	movs	r0, #1
  201f38:	f002 fe86 	bl	204c48 <_FillBuff>
	_NextDrawLine(BkpSizeX,width);
  201f3c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201f3e:	68b8      	ldr	r0, [r7, #8]
  201f40:	f002 ff96 	bl	204e70 <_NextDrawLine>

	_Middle_RoundRectangleFrame(rectangleFrame,14,FrameColor,FillColor,BkpSizeX,width,height);
  201f44:	6a78      	ldr	r0, [r7, #36]	; 0x24
  201f46:	6a3a      	ldr	r2, [r7, #32]
  201f48:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  201f4a:	9302      	str	r3, [sp, #8]
  201f4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201f4e:	9301      	str	r3, [sp, #4]
  201f50:	68bb      	ldr	r3, [r7, #8]
  201f52:	9300      	str	r3, [sp, #0]
  201f54:	4613      	mov	r3, r2
  201f56:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  201f58:	210e      	movs	r1, #14
  201f5a:	f7ff fe43 	bl	201be4 <_Middle_RoundRectangleFrame>

	A(1,FrameColor);  A(1,i2); _Fill(width-4); A(1,i2); A(1,FrameColor);
  201f5e:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201f60:	2001      	movs	r0, #1
  201f62:	f002 fe71 	bl	204c48 <_FillBuff>
  201f66:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201f68:	2001      	movs	r0, #1
  201f6a:	f002 fe6d 	bl	204c48 <_FillBuff>
  201f6e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201f70:	3b04      	subs	r3, #4
  201f72:	461a      	mov	r2, r3
  201f74:	f107 0314 	add.w	r3, r7, #20
  201f78:	469c      	mov	ip, r3
  201f7a:	4610      	mov	r0, r2
  201f7c:	f7ff fe80 	bl	201c80 <_Fill.11212>
  201f80:	6b39      	ldr	r1, [r7, #48]	; 0x30
  201f82:	2001      	movs	r0, #1
  201f84:	f002 fe60 	bl	204c48 <_FillBuff>
  201f88:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201f8a:	2001      	movs	r0, #1
  201f8c:	f002 fe5c 	bl	204c48 <_FillBuff>
	_NextDrawLine(BkpSizeX,width);
  201f90:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201f92:	68b8      	ldr	r0, [r7, #8]
  201f94:	f002 ff6c 	bl	204e70 <_NextDrawLine>
	A(1,FrameColor);  A(1,i1); _Fill(width-4); A(1,i1); A(1,FrameColor);
  201f98:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201f9a:	2001      	movs	r0, #1
  201f9c:	f002 fe54 	bl	204c48 <_FillBuff>
  201fa0:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201fa2:	2001      	movs	r0, #1
  201fa4:	f002 fe50 	bl	204c48 <_FillBuff>
  201fa8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201faa:	3b04      	subs	r3, #4
  201fac:	461a      	mov	r2, r3
  201fae:	f107 0314 	add.w	r3, r7, #20
  201fb2:	469c      	mov	ip, r3
  201fb4:	4610      	mov	r0, r2
  201fb6:	f7ff fe63 	bl	201c80 <_Fill.11212>
  201fba:	6b79      	ldr	r1, [r7, #52]	; 0x34
  201fbc:	2001      	movs	r0, #1
  201fbe:	f002 fe43 	bl	204c48 <_FillBuff>
  201fc2:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201fc4:	2001      	movs	r0, #1
  201fc6:	f002 fe3f 	bl	204c48 <_FillBuff>
	_NextDrawLine(BkpSizeX,width);
  201fca:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  201fcc:	68b8      	ldr	r0, [r7, #8]
  201fce:	f002 ff4f 	bl	204e70 <_NextDrawLine>

	_Out_AA_left(4); A(1,FrameColor); _Fill(width-4); A(1,FrameColor); _Out_AA_right(4);
  201fd2:	f107 0314 	add.w	r3, r7, #20
  201fd6:	469c      	mov	ip, r3
  201fd8:	2004      	movs	r0, #4
  201fda:	f000 f8b5 	bl	202148 <_Out_AA_left.11215>
  201fde:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201fe0:	2001      	movs	r0, #1
  201fe2:	f002 fe31 	bl	204c48 <_FillBuff>
  201fe6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  201fe8:	3b04      	subs	r3, #4
  201fea:	461a      	mov	r2, r3
  201fec:	f107 0314 	add.w	r3, r7, #20
  201ff0:	469c      	mov	ip, r3
  201ff2:	4610      	mov	r0, r2
  201ff4:	f7ff fe44 	bl	201c80 <_Fill.11212>
  201ff8:	6d39      	ldr	r1, [r7, #80]	; 0x50
  201ffa:	2001      	movs	r0, #1
  201ffc:	f002 fe24 	bl	204c48 <_FillBuff>
  202000:	f107 0314 	add.w	r3, r7, #20
  202004:	469c      	mov	ip, r3
  202006:	2004      	movs	r0, #4
  202008:	f000 f926 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  20200c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20200e:	68b8      	ldr	r0, [r7, #8]
  202010:	f002 ff2e 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(3); A(1,FrameColor); A(1,i1); _Fill(width-6); A(1,i1); A(1,FrameColor); _Out_AA_right(3);
  202014:	f107 0314 	add.w	r3, r7, #20
  202018:	469c      	mov	ip, r3
  20201a:	2003      	movs	r0, #3
  20201c:	f000 f894 	bl	202148 <_Out_AA_left.11215>
  202020:	6d39      	ldr	r1, [r7, #80]	; 0x50
  202022:	2001      	movs	r0, #1
  202024:	f002 fe10 	bl	204c48 <_FillBuff>
  202028:	6b79      	ldr	r1, [r7, #52]	; 0x34
  20202a:	2001      	movs	r0, #1
  20202c:	f002 fe0c 	bl	204c48 <_FillBuff>
  202030:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  202032:	3b06      	subs	r3, #6
  202034:	461a      	mov	r2, r3
  202036:	f107 0314 	add.w	r3, r7, #20
  20203a:	469c      	mov	ip, r3
  20203c:	4610      	mov	r0, r2
  20203e:	f7ff fe1f 	bl	201c80 <_Fill.11212>
  202042:	6b79      	ldr	r1, [r7, #52]	; 0x34
  202044:	2001      	movs	r0, #1
  202046:	f002 fdff 	bl	204c48 <_FillBuff>
  20204a:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20204c:	2001      	movs	r0, #1
  20204e:	f002 fdfb 	bl	204c48 <_FillBuff>
  202052:	f107 0314 	add.w	r3, r7, #20
  202056:	469c      	mov	ip, r3
  202058:	2003      	movs	r0, #3
  20205a:	f000 f8fd 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  20205e:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  202060:	68b8      	ldr	r0, [r7, #8]
  202062:	f002 ff05 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(2); A(1,FrameColor); A(1,i1); _Fill(width-8); A(1,i1); A(1,FrameColor); _Out_AA_right(2);
  202066:	f107 0314 	add.w	r3, r7, #20
  20206a:	469c      	mov	ip, r3
  20206c:	2002      	movs	r0, #2
  20206e:	f000 f86b 	bl	202148 <_Out_AA_left.11215>
  202072:	6d39      	ldr	r1, [r7, #80]	; 0x50
  202074:	2001      	movs	r0, #1
  202076:	f002 fde7 	bl	204c48 <_FillBuff>
  20207a:	6b79      	ldr	r1, [r7, #52]	; 0x34
  20207c:	2001      	movs	r0, #1
  20207e:	f002 fde3 	bl	204c48 <_FillBuff>
  202082:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  202084:	3b08      	subs	r3, #8
  202086:	461a      	mov	r2, r3
  202088:	f107 0314 	add.w	r3, r7, #20
  20208c:	469c      	mov	ip, r3
  20208e:	4610      	mov	r0, r2
  202090:	f7ff fdf6 	bl	201c80 <_Fill.11212>
  202094:	6b79      	ldr	r1, [r7, #52]	; 0x34
  202096:	2001      	movs	r0, #1
  202098:	f002 fdd6 	bl	204c48 <_FillBuff>
  20209c:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20209e:	2001      	movs	r0, #1
  2020a0:	f002 fdd2 	bl	204c48 <_FillBuff>
  2020a4:	f107 0314 	add.w	r3, r7, #20
  2020a8:	469c      	mov	ip, r3
  2020aa:	2002      	movs	r0, #2
  2020ac:	f000 f8d4 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  2020b0:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2020b2:	68b8      	ldr	r0, [r7, #8]
  2020b4:	f002 fedc 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(1); A(2,FrameColor); A(1,i1);A(1,i2); _Fill(width-14); A(1,i2);A(1,i1);A(2,FrameColor); _Out_AA_right(1);
  2020b8:	f107 0314 	add.w	r3, r7, #20
  2020bc:	469c      	mov	ip, r3
  2020be:	2001      	movs	r0, #1
  2020c0:	f000 f842 	bl	202148 <_Out_AA_left.11215>
  2020c4:	6d39      	ldr	r1, [r7, #80]	; 0x50
  2020c6:	2002      	movs	r0, #2
  2020c8:	f002 fdbe 	bl	204c48 <_FillBuff>
  2020cc:	6b79      	ldr	r1, [r7, #52]	; 0x34
  2020ce:	2001      	movs	r0, #1
  2020d0:	f002 fdba 	bl	204c48 <_FillBuff>
  2020d4:	6b39      	ldr	r1, [r7, #48]	; 0x30
  2020d6:	2001      	movs	r0, #1
  2020d8:	f002 fdb6 	bl	204c48 <_FillBuff>
  2020dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  2020de:	3b0e      	subs	r3, #14
  2020e0:	461a      	mov	r2, r3
  2020e2:	f107 0314 	add.w	r3, r7, #20
  2020e6:	469c      	mov	ip, r3
  2020e8:	4610      	mov	r0, r2
  2020ea:	f7ff fdc9 	bl	201c80 <_Fill.11212>
  2020ee:	6b39      	ldr	r1, [r7, #48]	; 0x30
  2020f0:	2001      	movs	r0, #1
  2020f2:	f002 fda9 	bl	204c48 <_FillBuff>
  2020f6:	6b79      	ldr	r1, [r7, #52]	; 0x34
  2020f8:	2001      	movs	r0, #1
  2020fa:	f002 fda5 	bl	204c48 <_FillBuff>
  2020fe:	6d39      	ldr	r1, [r7, #80]	; 0x50
  202100:	2002      	movs	r0, #2
  202102:	f002 fda1 	bl	204c48 <_FillBuff>
  202106:	f107 0314 	add.w	r3, r7, #20
  20210a:	469c      	mov	ip, r3
  20210c:	2001      	movs	r0, #1
  20210e:	f000 f8a3 	bl	202258 <_Out_AA_right.11230>
	_NextDrawLine(BkpSizeX,width);
  202112:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  202114:	68b8      	ldr	r0, [r7, #8]
  202116:	f002 feab 	bl	204e70 <_NextDrawLine>
	_Out_AA_left(0); A(width-10,FrameColor); _Out_AA_right(0);
  20211a:	f107 0314 	add.w	r3, r7, #20
  20211e:	469c      	mov	ip, r3
  202120:	2000      	movs	r0, #0
  202122:	f000 f811 	bl	202148 <_Out_AA_left.11215>
  202126:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  202128:	3b0a      	subs	r3, #10
  20212a:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20212c:	4618      	mov	r0, r3
  20212e:	f002 fd8b 	bl	204c48 <_FillBuff>
  202132:	f107 0314 	add.w	r3, r7, #20
  202136:	469c      	mov	ip, r3
  202138:	2000      	movs	r0, #0
  20213a:	f000 f88d 	bl	202258 <_Out_AA_right.11230>

	#undef  A
}
  20213e:	bf00      	nop
  202140:	3738      	adds	r7, #56	; 0x38
  202142:	46bd      	mov	sp, r7
  202144:	bd80      	pop	{r7, pc}
  202146:	bf00      	nop

00202148 <_Out_AA_left.11215>:
	{
  202148:	b590      	push	{r4, r7, lr}
  20214a:	b083      	sub	sp, #12
  20214c:	af00      	add	r7, sp, #0
  20214e:	6078      	str	r0, [r7, #4]
  202150:	4664      	mov	r4, ip
  202152:	f8c7 c000 	str.w	ip, [r7]
		if((thickness==0)||(thickness==255))
  202156:	7d23      	ldrb	r3, [r4, #20]
  202158:	2b00      	cmp	r3, #0
  20215a:	d002      	beq.n	202162 <_Out_AA_left.11215+0x1a>
  20215c:	7d23      	ldrb	r3, [r4, #20]
  20215e:	2bff      	cmp	r3, #255	; 0xff
  202160:	d143      	bne.n	2021ea <_Out_AA_left.11215+0xa2>
		{	switch(stage)
  202162:	687b      	ldr	r3, [r7, #4]
  202164:	2b04      	cmp	r3, #4
  202166:	d86f      	bhi.n	202248 <_Out_AA_left.11215+0x100>
  202168:	a201      	add	r2, pc, #4	; (adr r2, 202170 <_Out_AA_left.11215+0x28>)
  20216a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  20216e:	bf00      	nop
  202170:	00202185 	.word	0x00202185
  202174:	002021a5 	.word	0x002021a5
  202178:	002021bb 	.word	0x002021bb
  20217c:	002021d1 	.word	0x002021d1
  202180:	002021dd 	.word	0x002021dd
			case 0:	A(3,BkpColor); A(1,o2); A(1,o1);  break;
  202184:	68a3      	ldr	r3, [r4, #8]
  202186:	4619      	mov	r1, r3
  202188:	2003      	movs	r0, #3
  20218a:	f002 fd5d 	bl	204c48 <_FillBuff>
  20218e:	6863      	ldr	r3, [r4, #4]
  202190:	4619      	mov	r1, r3
  202192:	2001      	movs	r0, #1
  202194:	f002 fd58 	bl	204c48 <_FillBuff>
  202198:	6823      	ldr	r3, [r4, #0]
  20219a:	4619      	mov	r1, r3
  20219c:	2001      	movs	r0, #1
  20219e:	f002 fd53 	bl	204c48 <_FillBuff>
  2021a2:	e021      	b.n	2021e8 <_Out_AA_left.11215+0xa0>
			case 1:	A(2,BkpColor); A(1,o1);  break;
  2021a4:	68a3      	ldr	r3, [r4, #8]
  2021a6:	4619      	mov	r1, r3
  2021a8:	2002      	movs	r0, #2
  2021aa:	f002 fd4d 	bl	204c48 <_FillBuff>
  2021ae:	6823      	ldr	r3, [r4, #0]
  2021b0:	4619      	mov	r1, r3
  2021b2:	2001      	movs	r0, #1
  2021b4:	f002 fd48 	bl	204c48 <_FillBuff>
  2021b8:	e016      	b.n	2021e8 <_Out_AA_left.11215+0xa0>
			case 2:	A(1,BkpColor); A(1,o1);  break;
  2021ba:	68a3      	ldr	r3, [r4, #8]
  2021bc:	4619      	mov	r1, r3
  2021be:	2001      	movs	r0, #1
  2021c0:	f002 fd42 	bl	204c48 <_FillBuff>
  2021c4:	6823      	ldr	r3, [r4, #0]
  2021c6:	4619      	mov	r1, r3
  2021c8:	2001      	movs	r0, #1
  2021ca:	f002 fd3d 	bl	204c48 <_FillBuff>
  2021ce:	e00b      	b.n	2021e8 <_Out_AA_left.11215+0xa0>
			case 3:	A(1,o2); break;
  2021d0:	6863      	ldr	r3, [r4, #4]
  2021d2:	4619      	mov	r1, r3
  2021d4:	2001      	movs	r0, #1
  2021d6:	f002 fd37 	bl	204c48 <_FillBuff>
  2021da:	e005      	b.n	2021e8 <_Out_AA_left.11215+0xa0>
			case 4:	A(1,o1); break;
  2021dc:	6823      	ldr	r3, [r4, #0]
  2021de:	4619      	mov	r1, r3
  2021e0:	2001      	movs	r0, #1
  2021e2:	f002 fd31 	bl	204c48 <_FillBuff>
  2021e6:	bf00      	nop
		}
  2021e8:	e02e      	b.n	202248 <_Out_AA_left.11215+0x100>
		{  switch(stage)
  2021ea:	687b      	ldr	r3, [r7, #4]
  2021ec:	2b04      	cmp	r3, #4
  2021ee:	d82c      	bhi.n	20224a <_Out_AA_left.11215+0x102>
  2021f0:	a201      	add	r2, pc, #4	; (adr r2, 2021f8 <_Out_AA_left.11215+0xb0>)
  2021f2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  2021f6:	bf00      	nop
  2021f8:	0020220d 	.word	0x0020220d
  2021fc:	00202219 	.word	0x00202219
  202200:	00202225 	.word	0x00202225
  202204:	00202231 	.word	0x00202231
  202208:	0020223d 	.word	0x0020223d
			case 0:	k+=5; break;
  20220c:	4b11      	ldr	r3, [pc, #68]	; (202254 <_Out_AA_left.11215+0x10c>)
  20220e:	681b      	ldr	r3, [r3, #0]
  202210:	3305      	adds	r3, #5
  202212:	4a10      	ldr	r2, [pc, #64]	; (202254 <_Out_AA_left.11215+0x10c>)
  202214:	6013      	str	r3, [r2, #0]
  202216:	e018      	b.n	20224a <_Out_AA_left.11215+0x102>
			case 1:	k+=3; break;
  202218:	4b0e      	ldr	r3, [pc, #56]	; (202254 <_Out_AA_left.11215+0x10c>)
  20221a:	681b      	ldr	r3, [r3, #0]
  20221c:	3303      	adds	r3, #3
  20221e:	4a0d      	ldr	r2, [pc, #52]	; (202254 <_Out_AA_left.11215+0x10c>)
  202220:	6013      	str	r3, [r2, #0]
  202222:	e012      	b.n	20224a <_Out_AA_left.11215+0x102>
			case 2:	k+=2; break;
  202224:	4b0b      	ldr	r3, [pc, #44]	; (202254 <_Out_AA_left.11215+0x10c>)
  202226:	681b      	ldr	r3, [r3, #0]
  202228:	3302      	adds	r3, #2
  20222a:	4a0a      	ldr	r2, [pc, #40]	; (202254 <_Out_AA_left.11215+0x10c>)
  20222c:	6013      	str	r3, [r2, #0]
  20222e:	e00c      	b.n	20224a <_Out_AA_left.11215+0x102>
			case 3:	k+=1; break;
  202230:	4b08      	ldr	r3, [pc, #32]	; (202254 <_Out_AA_left.11215+0x10c>)
  202232:	681b      	ldr	r3, [r3, #0]
  202234:	3301      	adds	r3, #1
  202236:	4a07      	ldr	r2, [pc, #28]	; (202254 <_Out_AA_left.11215+0x10c>)
  202238:	6013      	str	r3, [r2, #0]
  20223a:	e006      	b.n	20224a <_Out_AA_left.11215+0x102>
			case 4:	k+=1; break;
  20223c:	4b05      	ldr	r3, [pc, #20]	; (202254 <_Out_AA_left.11215+0x10c>)
  20223e:	681b      	ldr	r3, [r3, #0]
  202240:	3301      	adds	r3, #1
  202242:	4a04      	ldr	r2, [pc, #16]	; (202254 <_Out_AA_left.11215+0x10c>)
  202244:	6013      	str	r3, [r2, #0]
  202246:	e000      	b.n	20224a <_Out_AA_left.11215+0x102>
		}
  202248:	bf00      	nop
	}
  20224a:	bf00      	nop
  20224c:	370c      	adds	r7, #12
  20224e:	46bd      	mov	sp, r7
  202250:	bd90      	pop	{r4, r7, pc}
  202252:	bf00      	nop
  202254:	20001870 	.word	0x20001870

00202258 <_Out_AA_right.11230>:
	{
  202258:	b590      	push	{r4, r7, lr}
  20225a:	b083      	sub	sp, #12
  20225c:	af00      	add	r7, sp, #0
  20225e:	6078      	str	r0, [r7, #4]
  202260:	4664      	mov	r4, ip
  202262:	f8c7 c000 	str.w	ip, [r7]
		if((thickness==0)||(thickness==255))
  202266:	7d23      	ldrb	r3, [r4, #20]
  202268:	2b00      	cmp	r3, #0
  20226a:	d002      	beq.n	202272 <_Out_AA_right.11230+0x1a>
  20226c:	7d23      	ldrb	r3, [r4, #20]
  20226e:	2bff      	cmp	r3, #255	; 0xff
  202270:	d143      	bne.n	2022fa <_Out_AA_right.11230+0xa2>
		{	switch(stage)
  202272:	687b      	ldr	r3, [r7, #4]
  202274:	2b04      	cmp	r3, #4
  202276:	d86f      	bhi.n	202358 <_Out_AA_right.11230+0x100>
  202278:	a201      	add	r2, pc, #4	; (adr r2, 202280 <_Out_AA_right.11230+0x28>)
  20227a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  20227e:	bf00      	nop
  202280:	00202295 	.word	0x00202295
  202284:	002022b5 	.word	0x002022b5
  202288:	002022cb 	.word	0x002022cb
  20228c:	002022e1 	.word	0x002022e1
  202290:	002022ed 	.word	0x002022ed
			case 0:	A(1,o1); A(1,o2); A(3,BkpColor);  break;
  202294:	6823      	ldr	r3, [r4, #0]
  202296:	4619      	mov	r1, r3
  202298:	2001      	movs	r0, #1
  20229a:	f002 fcd5 	bl	204c48 <_FillBuff>
  20229e:	6863      	ldr	r3, [r4, #4]
  2022a0:	4619      	mov	r1, r3
  2022a2:	2001      	movs	r0, #1
  2022a4:	f002 fcd0 	bl	204c48 <_FillBuff>
  2022a8:	68a3      	ldr	r3, [r4, #8]
  2022aa:	4619      	mov	r1, r3
  2022ac:	2003      	movs	r0, #3
  2022ae:	f002 fccb 	bl	204c48 <_FillBuff>
  2022b2:	e021      	b.n	2022f8 <_Out_AA_right.11230+0xa0>
			case 1:	A(1,o1); A(2,BkpColor);  break;
  2022b4:	6823      	ldr	r3, [r4, #0]
  2022b6:	4619      	mov	r1, r3
  2022b8:	2001      	movs	r0, #1
  2022ba:	f002 fcc5 	bl	204c48 <_FillBuff>
  2022be:	68a3      	ldr	r3, [r4, #8]
  2022c0:	4619      	mov	r1, r3
  2022c2:	2002      	movs	r0, #2
  2022c4:	f002 fcc0 	bl	204c48 <_FillBuff>
  2022c8:	e016      	b.n	2022f8 <_Out_AA_right.11230+0xa0>
			case 2:	A(1,o1); A(1,BkpColor);  break;
  2022ca:	6823      	ldr	r3, [r4, #0]
  2022cc:	4619      	mov	r1, r3
  2022ce:	2001      	movs	r0, #1
  2022d0:	f002 fcba 	bl	204c48 <_FillBuff>
  2022d4:	68a3      	ldr	r3, [r4, #8]
  2022d6:	4619      	mov	r1, r3
  2022d8:	2001      	movs	r0, #1
  2022da:	f002 fcb5 	bl	204c48 <_FillBuff>
  2022de:	e00b      	b.n	2022f8 <_Out_AA_right.11230+0xa0>
			case 3:	A(1,o2); break;
  2022e0:	6863      	ldr	r3, [r4, #4]
  2022e2:	4619      	mov	r1, r3
  2022e4:	2001      	movs	r0, #1
  2022e6:	f002 fcaf 	bl	204c48 <_FillBuff>
  2022ea:	e005      	b.n	2022f8 <_Out_AA_right.11230+0xa0>
			case 4:	A(1,o1); break;
  2022ec:	6823      	ldr	r3, [r4, #0]
  2022ee:	4619      	mov	r1, r3
  2022f0:	2001      	movs	r0, #1
  2022f2:	f002 fca9 	bl	204c48 <_FillBuff>
  2022f6:	bf00      	nop
		}
  2022f8:	e02e      	b.n	202358 <_Out_AA_right.11230+0x100>
		{	switch(stage)
  2022fa:	687b      	ldr	r3, [r7, #4]
  2022fc:	2b04      	cmp	r3, #4
  2022fe:	d82c      	bhi.n	20235a <_Out_AA_right.11230+0x102>
  202300:	a201      	add	r2, pc, #4	; (adr r2, 202308 <_Out_AA_right.11230+0xb0>)
  202302:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  202306:	bf00      	nop
  202308:	0020231d 	.word	0x0020231d
  20230c:	00202329 	.word	0x00202329
  202310:	00202335 	.word	0x00202335
  202314:	00202341 	.word	0x00202341
  202318:	0020234d 	.word	0x0020234d
			case 0:	k+=5; break;
  20231c:	4b11      	ldr	r3, [pc, #68]	; (202364 <_Out_AA_right.11230+0x10c>)
  20231e:	681b      	ldr	r3, [r3, #0]
  202320:	3305      	adds	r3, #5
  202322:	4a10      	ldr	r2, [pc, #64]	; (202364 <_Out_AA_right.11230+0x10c>)
  202324:	6013      	str	r3, [r2, #0]
  202326:	e018      	b.n	20235a <_Out_AA_right.11230+0x102>
			case 1:	k+=3; break;
  202328:	4b0e      	ldr	r3, [pc, #56]	; (202364 <_Out_AA_right.11230+0x10c>)
  20232a:	681b      	ldr	r3, [r3, #0]
  20232c:	3303      	adds	r3, #3
  20232e:	4a0d      	ldr	r2, [pc, #52]	; (202364 <_Out_AA_right.11230+0x10c>)
  202330:	6013      	str	r3, [r2, #0]
  202332:	e012      	b.n	20235a <_Out_AA_right.11230+0x102>
			case 2:	k+=2; break;
  202334:	4b0b      	ldr	r3, [pc, #44]	; (202364 <_Out_AA_right.11230+0x10c>)
  202336:	681b      	ldr	r3, [r3, #0]
  202338:	3302      	adds	r3, #2
  20233a:	4a0a      	ldr	r2, [pc, #40]	; (202364 <_Out_AA_right.11230+0x10c>)
  20233c:	6013      	str	r3, [r2, #0]
  20233e:	e00c      	b.n	20235a <_Out_AA_right.11230+0x102>
			case 3:	k+=1; break;
  202340:	4b08      	ldr	r3, [pc, #32]	; (202364 <_Out_AA_right.11230+0x10c>)
  202342:	681b      	ldr	r3, [r3, #0]
  202344:	3301      	adds	r3, #1
  202346:	4a07      	ldr	r2, [pc, #28]	; (202364 <_Out_AA_right.11230+0x10c>)
  202348:	6013      	str	r3, [r2, #0]
  20234a:	e006      	b.n	20235a <_Out_AA_right.11230+0x102>
			case 4:	k+=1; break;
  20234c:	4b05      	ldr	r3, [pc, #20]	; (202364 <_Out_AA_right.11230+0x10c>)
  20234e:	681b      	ldr	r3, [r3, #0]
  202350:	3301      	adds	r3, #1
  202352:	4a04      	ldr	r2, [pc, #16]	; (202364 <_Out_AA_right.11230+0x10c>)
  202354:	6013      	str	r3, [r2, #0]
  202356:	e000      	b.n	20235a <_Out_AA_right.11230+0x102>
		}
  202358:	bf00      	nop
	}
  20235a:	bf00      	nop
  20235c:	370c      	adds	r7, #12
  20235e:	46bd      	mov	sp, r7
  202360:	bd90      	pop	{r4, r7, pc}
  202362:	bf00      	nop
  202364:	20001870 	.word	0x20001870

00202368 <PixelCorrect>:

static void PixelCorrect(uint32_t drawColor, uint32_t bkColor, float ratioStart, uint16_t pxlLen, int multiplier){
  202368:	b580      	push	{r7, lr}
  20236a:	b088      	sub	sp, #32
  20236c:	af00      	add	r7, sp, #0
  20236e:	6178      	str	r0, [r7, #20]
  202370:	6139      	str	r1, [r7, #16]
  202372:	ed87 0a03 	vstr	s0, [r7, #12]
  202376:	607b      	str	r3, [r7, #4]
  202378:	4613      	mov	r3, r2
  20237a:	817b      	strh	r3, [r7, #10]
	Set_AACoeff_Draw(pxlLen,drawColor,bkColor,ratioStart);
  20237c:	897b      	ldrh	r3, [r7, #10]
  20237e:	ed97 0a03 	vldr	s0, [r7, #12]
  202382:	693a      	ldr	r2, [r7, #16]
  202384:	6979      	ldr	r1, [r7, #20]
  202386:	4618      	mov	r0, r3
  202388:	f002 fdb0 	bl	204eec <Set_AACoeff_Draw>
	for(int a=0;a<pxlLen;++a)
  20238c:	2300      	movs	r3, #0
  20238e:	61fb      	str	r3, [r7, #28]
  202390:	e012      	b.n	2023b8 <PixelCorrect+0x50>
		pLcd[k+multiplier*a]=buff_AA[1+a];
  202392:	687b      	ldr	r3, [r7, #4]
  202394:	69fa      	ldr	r2, [r7, #28]
  202396:	fb02 f303 	mul.w	r3, r2, r3
  20239a:	461a      	mov	r2, r3
  20239c:	4b0a      	ldr	r3, [pc, #40]	; (2023c8 <PixelCorrect+0x60>)
  20239e:	681b      	ldr	r3, [r3, #0]
  2023a0:	4413      	add	r3, r2
  2023a2:	69fa      	ldr	r2, [r7, #28]
  2023a4:	3201      	adds	r2, #1
  2023a6:	4909      	ldr	r1, [pc, #36]	; (2023cc <PixelCorrect+0x64>)
  2023a8:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2023ac:	4908      	ldr	r1, [pc, #32]	; (2023d0 <PixelCorrect+0x68>)
  2023ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	for(int a=0;a<pxlLen;++a)
  2023b2:	69fb      	ldr	r3, [r7, #28]
  2023b4:	3301      	adds	r3, #1
  2023b6:	61fb      	str	r3, [r7, #28]
  2023b8:	897a      	ldrh	r2, [r7, #10]
  2023ba:	69fb      	ldr	r3, [r7, #28]
  2023bc:	429a      	cmp	r2, r3
  2023be:	dce8      	bgt.n	202392 <PixelCorrect+0x2a>
}
  2023c0:	bf00      	nop
  2023c2:	3720      	adds	r7, #32
  2023c4:	46bd      	mov	sp, r7
  2023c6:	bd80      	pop	{r7, pc}
  2023c8:	20001870 	.word	0x20001870
  2023cc:	20001878 	.word	0x20001878
  2023d0:	c0000000 	.word	0xc0000000

002023d4 <InverseAndCopyBuff>:

static void InverseAndCopyBuff(uint8_t *buf_inv, uint8_t *buf){
  2023d4:	b480      	push	{r7}
  2023d6:	b085      	sub	sp, #20
  2023d8:	af00      	add	r7, sp, #0
  2023da:	6078      	str	r0, [r7, #4]
  2023dc:	6039      	str	r1, [r7, #0]
	buf_inv[0]=buf[0];
  2023de:	683b      	ldr	r3, [r7, #0]
  2023e0:	781a      	ldrb	r2, [r3, #0]
  2023e2:	687b      	ldr	r3, [r7, #4]
  2023e4:	701a      	strb	r2, [r3, #0]
	for(int i=0;i<buf[0];i++)
  2023e6:	2300      	movs	r3, #0
  2023e8:	60fb      	str	r3, [r7, #12]
  2023ea:	e011      	b.n	202410 <InverseAndCopyBuff+0x3c>
		buf_inv[1+i]=buf[buf[0]-i];
  2023ec:	68fb      	ldr	r3, [r7, #12]
  2023ee:	3301      	adds	r3, #1
  2023f0:	461a      	mov	r2, r3
  2023f2:	687b      	ldr	r3, [r7, #4]
  2023f4:	4413      	add	r3, r2
  2023f6:	683a      	ldr	r2, [r7, #0]
  2023f8:	7812      	ldrb	r2, [r2, #0]
  2023fa:	4611      	mov	r1, r2
  2023fc:	68fa      	ldr	r2, [r7, #12]
  2023fe:	1a8a      	subs	r2, r1, r2
  202400:	4611      	mov	r1, r2
  202402:	683a      	ldr	r2, [r7, #0]
  202404:	440a      	add	r2, r1
  202406:	7812      	ldrb	r2, [r2, #0]
  202408:	701a      	strb	r2, [r3, #0]
	for(int i=0;i<buf[0];i++)
  20240a:	68fb      	ldr	r3, [r7, #12]
  20240c:	3301      	adds	r3, #1
  20240e:	60fb      	str	r3, [r7, #12]
  202410:	683b      	ldr	r3, [r7, #0]
  202412:	781b      	ldrb	r3, [r3, #0]
  202414:	461a      	mov	r2, r3
  202416:	68fb      	ldr	r3, [r7, #12]
  202418:	429a      	cmp	r2, r3
  20241a:	dce7      	bgt.n	2023ec <InverseAndCopyBuff+0x18>
}
  20241c:	bf00      	nop
  20241e:	3714      	adds	r7, #20
  202420:	46bd      	mov	sp, r7
  202422:	f85d 7b04 	ldr.w	r7, [sp], #4
  202426:	4770      	bx	lr

00202428 <LCD_CircleCorrect>:
		}
	}
}

static void LCD_CircleCorrect(void)
{
  202428:	b480      	push	{r7}
  20242a:	af00      	add	r7, sp, #0
	//LCD_OffsCircleLine(1,1);  LCD_OffsCircleLine(2,-1);
	//LCD_OffsCircleLine(1,2);  LCD_OffsCircleLine(2,-1); LCD_OffsCircleLine(3,-1);
	//LCD_OffsCircleLine(1,4);  LCD_OffsCircleLine(2,3); LCD_OffsCircleLine(3,2);  LCD_OffsCircleLine(3,1);
}
  20242c:	bf00      	nop
  20242e:	46bd      	mov	sp, r7
  202430:	f85d 7b04 	ldr.w	r7, [sp], #4
  202434:	4770      	bx	lr
	...

00202438 <GetDegFromPosK>:

static uint16_t GetDegFromPosK( uint32_t posBuff, uint16_t x0, uint16_t y0, uint32_t BkpSizeX)
{
  202438:	b590      	push	{r4, r7, lr}
  20243a:	b08b      	sub	sp, #44	; 0x2c
  20243c:	af00      	add	r7, sp, #0
  20243e:	61f8      	str	r0, [r7, #28]
  202440:	617b      	str	r3, [r7, #20]
  202442:	460b      	mov	r3, r1
  202444:	837b      	strh	r3, [r7, #26]
  202446:	4613      	mov	r3, r2
  202448:	833b      	strh	r3, [r7, #24]
	pos = _GetPosXY(posBuff,BkpSizeX);
  20244a:	4c29      	ldr	r4, [pc, #164]	; (2024f0 <GetDegFromPosK+0xb8>)
  20244c:	f107 0308 	add.w	r3, r7, #8
  202450:	697a      	ldr	r2, [r7, #20]
  202452:	69f9      	ldr	r1, [r7, #28]
  202454:	4618      	mov	r0, r3
  202456:	f002 fcbd 	bl	204dd4 <_GetPosXY>
  20245a:	4622      	mov	r2, r4
  20245c:	f107 0308 	add.w	r3, r7, #8
  202460:	e893 0003 	ldmia.w	r3, {r0, r1}
  202464:	e882 0003 	stmia.w	r2, {r0, r1}
	float deg = DEG(atan2(pos.y-y0, pos.x-x0));
  202468:	4b21      	ldr	r3, [pc, #132]	; (2024f0 <GetDegFromPosK+0xb8>)
  20246a:	685a      	ldr	r2, [r3, #4]
  20246c:	8b3b      	ldrh	r3, [r7, #24]
  20246e:	1ad3      	subs	r3, r2, r3
  202470:	ee07 3a90 	vmov	s15, r3
  202474:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  202478:	4b1d      	ldr	r3, [pc, #116]	; (2024f0 <GetDegFromPosK+0xb8>)
  20247a:	681a      	ldr	r2, [r3, #0]
  20247c:	8b7b      	ldrh	r3, [r7, #26]
  20247e:	1ad3      	subs	r3, r2, r3
  202480:	ee06 3a90 	vmov	s13, r3
  202484:	eeb8 6be6 	vcvt.f64.s32	d6, s13
  202488:	eeb0 1b46 	vmov.f64	d1, d6
  20248c:	eeb0 0b47 	vmov.f64	d0, d7
  202490:	f024 f906 	bl	2266a0 <atan2>
  202494:	eeb0 5b40 	vmov.f64	d5, d0
  202498:	ed9f 6b13 	vldr	d6, [pc, #76]	; 2024e8 <GetDegFromPosK+0xb0>
  20249c:	ee85 7b06 	vdiv.f64	d7, d5, d6
  2024a0:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2024a4:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
	return deg<0 ? 360+deg : deg;
  2024a8:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  2024ac:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  2024b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2024b4:	d50c      	bpl.n	2024d0 <GetDegFromPosK+0x98>
  2024b6:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  2024ba:	ed9f 7a0e 	vldr	s14, [pc, #56]	; 2024f4 <GetDegFromPosK+0xbc>
  2024be:	ee77 7a87 	vadd.f32	s15, s15, s14
  2024c2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  2024c6:	edc7 7a01 	vstr	s15, [r7, #4]
  2024ca:	88bb      	ldrh	r3, [r7, #4]
  2024cc:	b29b      	uxth	r3, r3
  2024ce:	e007      	b.n	2024e0 <GetDegFromPosK+0xa8>
  2024d0:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  2024d4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  2024d8:	edc7 7a01 	vstr	s15, [r7, #4]
  2024dc:	88bb      	ldrh	r3, [r7, #4]
  2024de:	b29b      	uxth	r3, r3
}
  2024e0:	4618      	mov	r0, r3
  2024e2:	372c      	adds	r7, #44	; 0x2c
  2024e4:	46bd      	mov	sp, r7
  2024e6:	bd90      	pop	{r4, r7, pc}
  2024e8:	6cd799af 	.word	0x6cd799af
  2024ec:	3f91df40 	.word	0x3f91df40
  2024f0:	20002048 	.word	0x20002048
  2024f4:	43b40000 	.word	0x43b40000

002024f8 <LCD_SearchLinePoints>:
	}
	k+=offs;
}

static uint8_t LCD_SearchLinePoints(int startMeasure, int posBuff, int x0,int y0, int deg, uint32_t BkpSizeX)
{
  2024f8:	b590      	push	{r4, r7, lr}
  2024fa:	b08b      	sub	sp, #44	; 0x2c
  2024fc:	af00      	add	r7, sp, #0
  2024fe:	6178      	str	r0, [r7, #20]
  202500:	6139      	str	r1, [r7, #16]
  202502:	60fa      	str	r2, [r7, #12]
  202504:	60bb      	str	r3, [r7, #8]
	static float tang, coeff;

	if(startMeasure)
  202506:	697b      	ldr	r3, [r7, #20]
  202508:	2b00      	cmp	r3, #0
  20250a:	d076      	beq.n	2025fa <LCD_SearchLinePoints+0x102>
	{
		tang= tan(TANG_ARG(deg));
  20250c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20250e:	ee07 3a90 	vmov	s15, r3
  202512:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  202516:	ed9f 6bb8 	vldr	d6, [pc, #736]	; 2027f8 <LCD_SearchLinePoints+0x300>
  20251a:	ee27 7b06 	vmul.f64	d7, d7, d6
  20251e:	eeb0 0b47 	vmov.f64	d0, d7
  202522:	f024 f88d 	bl	226640 <tan>
  202526:	eeb0 7b40 	vmov.f64	d7, d0
  20252a:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  20252e:	4bb4      	ldr	r3, [pc, #720]	; (202800 <LCD_SearchLinePoints+0x308>)
  202530:	edc3 7a00 	vstr	s15, [r3]
		coeff = 1/ABS(tang);
  202534:	4bb2      	ldr	r3, [pc, #712]	; (202800 <LCD_SearchLinePoints+0x308>)
  202536:	edd3 7a00 	vldr	s15, [r3]
  20253a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  20253e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202542:	dd07      	ble.n	202554 <LCD_SearchLinePoints+0x5c>
  202544:	4bae      	ldr	r3, [pc, #696]	; (202800 <LCD_SearchLinePoints+0x308>)
  202546:	ed93 7a00 	vldr	s14, [r3]
  20254a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  20254e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  202552:	e008      	b.n	202566 <LCD_SearchLinePoints+0x6e>
  202554:	4baa      	ldr	r3, [pc, #680]	; (202800 <LCD_SearchLinePoints+0x308>)
  202556:	edd3 7a00 	vldr	s15, [r3]
  20255a:	eeb1 7a67 	vneg.f32	s14, s15
  20255e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  202562:	eec6 7a87 	vdiv.f32	s15, s13, s14
  202566:	4ba7      	ldr	r3, [pc, #668]	; (202804 <LCD_SearchLinePoints+0x30c>)
  202568:	edc3 7a00 	vstr	s15, [r3]

		if(deg>0 && deg<=45)
  20256c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20256e:	2b00      	cmp	r3, #0
  202570:	dd04      	ble.n	20257c <LCD_SearchLinePoints+0x84>
  202572:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202574:	2b2d      	cmp	r3, #45	; 0x2d
  202576:	dc01      	bgt.n	20257c <LCD_SearchLinePoints+0x84>
			return 1;
  202578:	2301      	movs	r3, #1
  20257a:	e200      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>45 && deg<=90)
  20257c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20257e:	2b2d      	cmp	r3, #45	; 0x2d
  202580:	dd04      	ble.n	20258c <LCD_SearchLinePoints+0x94>
  202582:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202584:	2b5a      	cmp	r3, #90	; 0x5a
  202586:	dc01      	bgt.n	20258c <LCD_SearchLinePoints+0x94>
			return 2;
  202588:	2302      	movs	r3, #2
  20258a:	e1f8      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>90 && deg<=135)
  20258c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20258e:	2b5a      	cmp	r3, #90	; 0x5a
  202590:	dd04      	ble.n	20259c <LCD_SearchLinePoints+0xa4>
  202592:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202594:	2b87      	cmp	r3, #135	; 0x87
  202596:	dc01      	bgt.n	20259c <LCD_SearchLinePoints+0xa4>
			return 3;
  202598:	2303      	movs	r3, #3
  20259a:	e1f0      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>135 && deg<=180)
  20259c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20259e:	2b87      	cmp	r3, #135	; 0x87
  2025a0:	dd04      	ble.n	2025ac <LCD_SearchLinePoints+0xb4>
  2025a2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025a4:	2bb4      	cmp	r3, #180	; 0xb4
  2025a6:	dc01      	bgt.n	2025ac <LCD_SearchLinePoints+0xb4>
			return 4;
  2025a8:	2304      	movs	r3, #4
  2025aa:	e1e8      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>180 && deg<=225)
  2025ac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025ae:	2bb4      	cmp	r3, #180	; 0xb4
  2025b0:	dd04      	ble.n	2025bc <LCD_SearchLinePoints+0xc4>
  2025b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025b4:	2be1      	cmp	r3, #225	; 0xe1
  2025b6:	dc01      	bgt.n	2025bc <LCD_SearchLinePoints+0xc4>
			return 5;
  2025b8:	2305      	movs	r3, #5
  2025ba:	e1e0      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>225 && deg<=270)
  2025bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025be:	2be1      	cmp	r3, #225	; 0xe1
  2025c0:	dd05      	ble.n	2025ce <LCD_SearchLinePoints+0xd6>
  2025c2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025c4:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  2025c8:	dc01      	bgt.n	2025ce <LCD_SearchLinePoints+0xd6>
			return 6;
  2025ca:	2306      	movs	r3, #6
  2025cc:	e1d7      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>270 && deg<=315)
  2025ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025d0:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  2025d4:	dd05      	ble.n	2025e2 <LCD_SearchLinePoints+0xea>
  2025d6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025d8:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  2025dc:	da01      	bge.n	2025e2 <LCD_SearchLinePoints+0xea>
			return 7;
  2025de:	2307      	movs	r3, #7
  2025e0:	e1cd      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if(deg>315 && deg<=360)
  2025e2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025e4:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  2025e8:	f2c0 81c8 	blt.w	20297c <LCD_SearchLinePoints+0x484>
  2025ec:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2025ee:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  2025f2:	f300 81c3 	bgt.w	20297c <LCD_SearchLinePoints+0x484>
			return 8;
  2025f6:	2308      	movs	r3, #8
  2025f8:	e1c1      	b.n	20297e <LCD_SearchLinePoints+0x486>
	}
	else
	{
   	pos = _GetPosXY(posBuff,BkpSizeX);
  2025fa:	6939      	ldr	r1, [r7, #16]
  2025fc:	4c82      	ldr	r4, [pc, #520]	; (202808 <LCD_SearchLinePoints+0x310>)
  2025fe:	463b      	mov	r3, r7
  202600:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  202602:	4618      	mov	r0, r3
  202604:	f002 fbe6 	bl	204dd4 <_GetPosXY>
  202608:	4622      	mov	r2, r4
  20260a:	463b      	mov	r3, r7
  20260c:	e893 0003 	ldmia.w	r3, {r0, r1}
  202610:	e882 0003 	stmia.w	r2, {r0, r1}
   	float xxx = pos.x - x0;
  202614:	4b7c      	ldr	r3, [pc, #496]	; (202808 <LCD_SearchLinePoints+0x310>)
  202616:	681a      	ldr	r2, [r3, #0]
  202618:	68fb      	ldr	r3, [r7, #12]
  20261a:	1ad3      	subs	r3, r2, r3
  20261c:	ee07 3a90 	vmov	s15, r3
  202620:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  202624:	edc7 7a09 	vstr	s15, [r7, #36]	; 0x24
		float yyy = pos.y - y0;
  202628:	4b77      	ldr	r3, [pc, #476]	; (202808 <LCD_SearchLinePoints+0x310>)
  20262a:	685a      	ldr	r2, [r3, #4]
  20262c:	68bb      	ldr	r3, [r7, #8]
  20262e:	1ad3      	subs	r3, r2, r3
  202630:	ee07 3a90 	vmov	s15, r3
  202634:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  202638:	edc7 7a08 	vstr	s15, [r7, #32]
		float _yyy = tang*xxx;
  20263c:	4b70      	ldr	r3, [pc, #448]	; (202800 <LCD_SearchLinePoints+0x308>)
  20263e:	ed93 7a00 	vldr	s14, [r3]
  202642:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  202646:	ee67 7a27 	vmul.f32	s15, s14, s15
  20264a:	edc7 7a07 	vstr	s15, [r7, #28]

		if(deg>0 && deg<=45)
  20264e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202650:	2b00      	cmp	r3, #0
  202652:	dd2d      	ble.n	2026b0 <LCD_SearchLinePoints+0x1b8>
  202654:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202656:	2b2d      	cmp	r3, #45	; 0x2d
  202658:	dc2a      	bgt.n	2026b0 <LCD_SearchLinePoints+0x1b8>
		{
				  if(yyy<_yyy)	                                return 0;
  20265a:	ed97 7a08 	vldr	s14, [r7, #32]
  20265e:	edd7 7a07 	vldr	s15, [r7, #28]
  202662:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202666:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20266a:	d501      	bpl.n	202670 <LCD_SearchLinePoints+0x178>
  20266c:	2300      	movs	r3, #0
  20266e:	e186      	b.n	20297e <LCD_SearchLinePoints+0x486>
			else if( (yyy>=_yyy) && (yyy<tang*(xxx+coeff)) )  return 1;
  202670:	ed97 7a08 	vldr	s14, [r7, #32]
  202674:	edd7 7a07 	vldr	s15, [r7, #28]
  202678:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20267c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202680:	db14      	blt.n	2026ac <LCD_SearchLinePoints+0x1b4>
  202682:	4b60      	ldr	r3, [pc, #384]	; (202804 <LCD_SearchLinePoints+0x30c>)
  202684:	ed93 7a00 	vldr	s14, [r3]
  202688:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  20268c:	ee37 7a27 	vadd.f32	s14, s14, s15
  202690:	4b5b      	ldr	r3, [pc, #364]	; (202800 <LCD_SearchLinePoints+0x308>)
  202692:	edd3 7a00 	vldr	s15, [r3]
  202696:	ee27 7a27 	vmul.f32	s14, s14, s15
  20269a:	edd7 7a08 	vldr	s15, [r7, #32]
  20269e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2026a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2026a6:	dd01      	ble.n	2026ac <LCD_SearchLinePoints+0x1b4>
  2026a8:	2301      	movs	r3, #1
  2026aa:	e168      	b.n	20297e <LCD_SearchLinePoints+0x486>
			else															  return 2;
  2026ac:	2302      	movs	r3, #2
  2026ae:	e166      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}
		else if(deg>45 && deg<=90)
  2026b0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2026b2:	2b2d      	cmp	r3, #45	; 0x2d
  2026b4:	dd2c      	ble.n	202710 <LCD_SearchLinePoints+0x218>
  2026b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2026b8:	2b5a      	cmp	r3, #90	; 0x5a
  2026ba:	dc29      	bgt.n	202710 <LCD_SearchLinePoints+0x218>
		{
			  if(yyy<_yyy)	                                return 0;
  2026bc:	ed97 7a08 	vldr	s14, [r7, #32]
  2026c0:	edd7 7a07 	vldr	s15, [r7, #28]
  2026c4:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2026c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2026cc:	d501      	bpl.n	2026d2 <LCD_SearchLinePoints+0x1da>
  2026ce:	2300      	movs	r3, #0
  2026d0:	e155      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if( (yyy>=_yyy) && (yyy<tang*(xxx+1)) )      return 1;
  2026d2:	ed97 7a08 	vldr	s14, [r7, #32]
  2026d6:	edd7 7a07 	vldr	s15, [r7, #28]
  2026da:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2026de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2026e2:	db13      	blt.n	20270c <LCD_SearchLinePoints+0x214>
  2026e4:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  2026e8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  2026ec:	ee37 7a87 	vadd.f32	s14, s15, s14
  2026f0:	4b43      	ldr	r3, [pc, #268]	; (202800 <LCD_SearchLinePoints+0x308>)
  2026f2:	edd3 7a00 	vldr	s15, [r3]
  2026f6:	ee27 7a27 	vmul.f32	s14, s14, s15
  2026fa:	edd7 7a08 	vldr	s15, [r7, #32]
  2026fe:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202702:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202706:	dd01      	ble.n	20270c <LCD_SearchLinePoints+0x214>
  202708:	2301      	movs	r3, #1
  20270a:	e138      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else															  return 2;
  20270c:	2302      	movs	r3, #2
  20270e:	e136      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}

		else if(deg>90 && deg<=135)
  202710:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202712:	2b5a      	cmp	r3, #90	; 0x5a
  202714:	dd2c      	ble.n	202770 <LCD_SearchLinePoints+0x278>
  202716:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202718:	2b87      	cmp	r3, #135	; 0x87
  20271a:	dc29      	bgt.n	202770 <LCD_SearchLinePoints+0x278>
		{
			  if(yyy>_yyy)	                                return 0;
  20271c:	ed97 7a08 	vldr	s14, [r7, #32]
  202720:	edd7 7a07 	vldr	s15, [r7, #28]
  202724:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202728:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20272c:	dd01      	ble.n	202732 <LCD_SearchLinePoints+0x23a>
  20272e:	2300      	movs	r3, #0
  202730:	e125      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+1)) )      return 1;
  202732:	ed97 7a08 	vldr	s14, [r7, #32]
  202736:	edd7 7a07 	vldr	s15, [r7, #28]
  20273a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20273e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202742:	d813      	bhi.n	20276c <LCD_SearchLinePoints+0x274>
  202744:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  202748:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  20274c:	ee37 7a87 	vadd.f32	s14, s15, s14
  202750:	4b2b      	ldr	r3, [pc, #172]	; (202800 <LCD_SearchLinePoints+0x308>)
  202752:	edd3 7a00 	vldr	s15, [r3]
  202756:	ee27 7a27 	vmul.f32	s14, s14, s15
  20275a:	edd7 7a08 	vldr	s15, [r7, #32]
  20275e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202762:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202766:	d501      	bpl.n	20276c <LCD_SearchLinePoints+0x274>
  202768:	2301      	movs	r3, #1
  20276a:	e108      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else															  return 2;
  20276c:	2302      	movs	r3, #2
  20276e:	e106      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}
		else if(deg>135 && deg<=180)
  202770:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202772:	2b87      	cmp	r3, #135	; 0x87
  202774:	dd2d      	ble.n	2027d2 <LCD_SearchLinePoints+0x2da>
  202776:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202778:	2bb4      	cmp	r3, #180	; 0xb4
  20277a:	dc2a      	bgt.n	2027d2 <LCD_SearchLinePoints+0x2da>
		{
			  if(yyy>_yyy)	                                return 0;
  20277c:	ed97 7a08 	vldr	s14, [r7, #32]
  202780:	edd7 7a07 	vldr	s15, [r7, #28]
  202784:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202788:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20278c:	dd01      	ble.n	202792 <LCD_SearchLinePoints+0x29a>
  20278e:	2300      	movs	r3, #0
  202790:	e0f5      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+coeff)) )  return 1;
  202792:	ed97 7a08 	vldr	s14, [r7, #32]
  202796:	edd7 7a07 	vldr	s15, [r7, #28]
  20279a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20279e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2027a2:	d814      	bhi.n	2027ce <LCD_SearchLinePoints+0x2d6>
  2027a4:	4b17      	ldr	r3, [pc, #92]	; (202804 <LCD_SearchLinePoints+0x30c>)
  2027a6:	ed93 7a00 	vldr	s14, [r3]
  2027aa:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  2027ae:	ee37 7a27 	vadd.f32	s14, s14, s15
  2027b2:	4b13      	ldr	r3, [pc, #76]	; (202800 <LCD_SearchLinePoints+0x308>)
  2027b4:	edd3 7a00 	vldr	s15, [r3]
  2027b8:	ee27 7a27 	vmul.f32	s14, s14, s15
  2027bc:	edd7 7a08 	vldr	s15, [r7, #32]
  2027c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2027c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2027c8:	d501      	bpl.n	2027ce <LCD_SearchLinePoints+0x2d6>
  2027ca:	2301      	movs	r3, #1
  2027cc:	e0d7      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else															  return 2;
  2027ce:	2302      	movs	r3, #2
  2027d0:	e0d5      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}

		else if(deg>180 && deg<=225)
  2027d2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2027d4:	2bb4      	cmp	r3, #180	; 0xb4
  2027d6:	dd39      	ble.n	20284c <LCD_SearchLinePoints+0x354>
  2027d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2027da:	2be1      	cmp	r3, #225	; 0xe1
  2027dc:	dc36      	bgt.n	20284c <LCD_SearchLinePoints+0x354>
		{
				  if(yyy<_yyy)	                                return 2;
  2027de:	ed97 7a08 	vldr	s14, [r7, #32]
  2027e2:	edd7 7a07 	vldr	s15, [r7, #28]
  2027e6:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2027ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2027ee:	d50d      	bpl.n	20280c <LCD_SearchLinePoints+0x314>
  2027f0:	2302      	movs	r3, #2
  2027f2:	e0c4      	b.n	20297e <LCD_SearchLinePoints+0x486>
  2027f4:	f3af 8000 	nop.w
  2027f8:	6cd799af 	.word	0x6cd799af
  2027fc:	3f91df40 	.word	0x3f91df40
  202800:	20002304 	.word	0x20002304
  202804:	20002308 	.word	0x20002308
  202808:	20002048 	.word	0x20002048
			else if( (yyy>=_yyy) && (yyy<tang*(xxx+coeff)) )  return 1;
  20280c:	ed97 7a08 	vldr	s14, [r7, #32]
  202810:	edd7 7a07 	vldr	s15, [r7, #28]
  202814:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202818:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20281c:	db14      	blt.n	202848 <LCD_SearchLinePoints+0x350>
  20281e:	4b5a      	ldr	r3, [pc, #360]	; (202988 <LCD_SearchLinePoints+0x490>)
  202820:	ed93 7a00 	vldr	s14, [r3]
  202824:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  202828:	ee37 7a27 	vadd.f32	s14, s14, s15
  20282c:	4b57      	ldr	r3, [pc, #348]	; (20298c <LCD_SearchLinePoints+0x494>)
  20282e:	edd3 7a00 	vldr	s15, [r3]
  202832:	ee27 7a27 	vmul.f32	s14, s14, s15
  202836:	edd7 7a08 	vldr	s15, [r7, #32]
  20283a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20283e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202842:	dd01      	ble.n	202848 <LCD_SearchLinePoints+0x350>
  202844:	2301      	movs	r3, #1
  202846:	e09a      	b.n	20297e <LCD_SearchLinePoints+0x486>
			else															  return 0;
  202848:	2300      	movs	r3, #0
  20284a:	e098      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}
		else if(deg>225 && deg<=270)
  20284c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20284e:	2be1      	cmp	r3, #225	; 0xe1
  202850:	dd2d      	ble.n	2028ae <LCD_SearchLinePoints+0x3b6>
  202852:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202854:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  202858:	dc29      	bgt.n	2028ae <LCD_SearchLinePoints+0x3b6>
		{
			  if(yyy<_yyy)	                                return 2;
  20285a:	ed97 7a08 	vldr	s14, [r7, #32]
  20285e:	edd7 7a07 	vldr	s15, [r7, #28]
  202862:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202866:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20286a:	d501      	bpl.n	202870 <LCD_SearchLinePoints+0x378>
  20286c:	2302      	movs	r3, #2
  20286e:	e086      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if( (yyy>=_yyy) && (yyy<tang*(xxx+1)) )      return 1;
  202870:	ed97 7a08 	vldr	s14, [r7, #32]
  202874:	edd7 7a07 	vldr	s15, [r7, #28]
  202878:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20287c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202880:	db13      	blt.n	2028aa <LCD_SearchLinePoints+0x3b2>
  202882:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  202886:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  20288a:	ee37 7a87 	vadd.f32	s14, s15, s14
  20288e:	4b3f      	ldr	r3, [pc, #252]	; (20298c <LCD_SearchLinePoints+0x494>)
  202890:	edd3 7a00 	vldr	s15, [r3]
  202894:	ee27 7a27 	vmul.f32	s14, s14, s15
  202898:	edd7 7a08 	vldr	s15, [r7, #32]
  20289c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2028a0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2028a4:	dd01      	ble.n	2028aa <LCD_SearchLinePoints+0x3b2>
  2028a6:	2301      	movs	r3, #1
  2028a8:	e069      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else															  return 0;
  2028aa:	2300      	movs	r3, #0
  2028ac:	e067      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}

		else if(deg>270 && deg<=315)
  2028ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2028b0:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  2028b4:	dd2d      	ble.n	202912 <LCD_SearchLinePoints+0x41a>
  2028b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2028b8:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  2028bc:	da29      	bge.n	202912 <LCD_SearchLinePoints+0x41a>
		{
			  if(yyy>_yyy)	                                return 2;
  2028be:	ed97 7a08 	vldr	s14, [r7, #32]
  2028c2:	edd7 7a07 	vldr	s15, [r7, #28]
  2028c6:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2028ca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2028ce:	dd01      	ble.n	2028d4 <LCD_SearchLinePoints+0x3dc>
  2028d0:	2302      	movs	r3, #2
  2028d2:	e054      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+1)) )      return 1;
  2028d4:	ed97 7a08 	vldr	s14, [r7, #32]
  2028d8:	edd7 7a07 	vldr	s15, [r7, #28]
  2028dc:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2028e0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2028e4:	d813      	bhi.n	20290e <LCD_SearchLinePoints+0x416>
  2028e6:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  2028ea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  2028ee:	ee37 7a87 	vadd.f32	s14, s15, s14
  2028f2:	4b26      	ldr	r3, [pc, #152]	; (20298c <LCD_SearchLinePoints+0x494>)
  2028f4:	edd3 7a00 	vldr	s15, [r3]
  2028f8:	ee27 7a27 	vmul.f32	s14, s14, s15
  2028fc:	edd7 7a08 	vldr	s15, [r7, #32]
  202900:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202904:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202908:	d501      	bpl.n	20290e <LCD_SearchLinePoints+0x416>
  20290a:	2301      	movs	r3, #1
  20290c:	e037      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else															  return 0;
  20290e:	2300      	movs	r3, #0
  202910:	e035      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}
		else if(deg>315 && deg<=360)
  202912:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  202914:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  202918:	db2e      	blt.n	202978 <LCD_SearchLinePoints+0x480>
  20291a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20291c:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  202920:	dc2a      	bgt.n	202978 <LCD_SearchLinePoints+0x480>
		{
			  if(yyy>_yyy)	                                return 2;
  202922:	ed97 7a08 	vldr	s14, [r7, #32]
  202926:	edd7 7a07 	vldr	s15, [r7, #28]
  20292a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20292e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202932:	dd01      	ble.n	202938 <LCD_SearchLinePoints+0x440>
  202934:	2302      	movs	r3, #2
  202936:	e022      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+coeff)) )  return 1;
  202938:	ed97 7a08 	vldr	s14, [r7, #32]
  20293c:	edd7 7a07 	vldr	s15, [r7, #28]
  202940:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202944:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202948:	d814      	bhi.n	202974 <LCD_SearchLinePoints+0x47c>
  20294a:	4b0f      	ldr	r3, [pc, #60]	; (202988 <LCD_SearchLinePoints+0x490>)
  20294c:	ed93 7a00 	vldr	s14, [r3]
  202950:	edd7 7a09 	vldr	s15, [r7, #36]	; 0x24
  202954:	ee37 7a27 	vadd.f32	s14, s14, s15
  202958:	4b0c      	ldr	r3, [pc, #48]	; (20298c <LCD_SearchLinePoints+0x494>)
  20295a:	edd3 7a00 	vldr	s15, [r3]
  20295e:	ee27 7a27 	vmul.f32	s14, s14, s15
  202962:	edd7 7a08 	vldr	s15, [r7, #32]
  202966:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20296a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20296e:	d501      	bpl.n	202974 <LCD_SearchLinePoints+0x47c>
  202970:	2301      	movs	r3, #1
  202972:	e004      	b.n	20297e <LCD_SearchLinePoints+0x486>
		else															  return 0;
  202974:	2300      	movs	r3, #0
  202976:	e002      	b.n	20297e <LCD_SearchLinePoints+0x486>
		}

		else
			return 3;
  202978:	2303      	movs	r3, #3
  20297a:	e000      	b.n	20297e <LCD_SearchLinePoints+0x486>
	}
	return 0;
  20297c:	2300      	movs	r3, #0
}
  20297e:	4618      	mov	r0, r3
  202980:	372c      	adds	r7, #44	; 0x2c
  202982:	46bd      	mov	sp, r7
  202984:	bd90      	pop	{r4, r7, pc}
  202986:	bf00      	nop
  202988:	20002308 	.word	0x20002308
  20298c:	20002304 	.word	0x20002304

00202990 <LCD_SearchRadiusPoints>:

static uint8_t LCD_SearchRadiusPoints(int posBuff, int nrDeg, uint32_t BkpSizeX)
{
  202990:	b590      	push	{r4, r7, lr}
  202992:	b08d      	sub	sp, #52	; 0x34
  202994:	af00      	add	r7, sp, #0
  202996:	6178      	str	r0, [r7, #20]
  202998:	6139      	str	r1, [r7, #16]
  20299a:	60fa      	str	r2, [r7, #12]
	float tang= Circle.tang[nrDeg];
  20299c:	4ac8      	ldr	r2, [pc, #800]	; (202cc0 <LCD_SearchRadiusPoints+0x330>)
  20299e:	693b      	ldr	r3, [r7, #16]
  2029a0:	3392      	adds	r3, #146	; 0x92
  2029a2:	009b      	lsls	r3, r3, #2
  2029a4:	4413      	add	r3, r2
  2029a6:	3304      	adds	r3, #4
  2029a8:	681b      	ldr	r3, [r3, #0]
  2029aa:	62fb      	str	r3, [r7, #44]	; 0x2c
	float coeff=Circle.coeff[nrDeg];
  2029ac:	4ac4      	ldr	r2, [pc, #784]	; (202cc0 <LCD_SearchRadiusPoints+0x330>)
  2029ae:	693b      	ldr	r3, [r7, #16]
  2029b0:	339c      	adds	r3, #156	; 0x9c
  2029b2:	009b      	lsls	r3, r3, #2
  2029b4:	4413      	add	r3, r2
  2029b6:	3304      	adds	r3, #4
  2029b8:	681b      	ldr	r3, [r3, #0]
  2029ba:	62bb      	str	r3, [r7, #40]	; 0x28
	uint16_t deg = Circle.degree[1+nrDeg];
  2029bc:	693b      	ldr	r3, [r7, #16]
  2029be:	3301      	adds	r3, #1
  2029c0:	4abf      	ldr	r2, [pc, #764]	; (202cc0 <LCD_SearchRadiusPoints+0x330>)
  2029c2:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2029c6:	005b      	lsls	r3, r3, #1
  2029c8:	4413      	add	r3, r2
  2029ca:	889b      	ldrh	r3, [r3, #4]
  2029cc:	84fb      	strh	r3, [r7, #38]	; 0x26

   	pos = _GetPosXY(posBuff,BkpSizeX);
  2029ce:	6979      	ldr	r1, [r7, #20]
  2029d0:	4cbc      	ldr	r4, [pc, #752]	; (202cc4 <LCD_SearchRadiusPoints+0x334>)
  2029d2:	463b      	mov	r3, r7
  2029d4:	68fa      	ldr	r2, [r7, #12]
  2029d6:	4618      	mov	r0, r3
  2029d8:	f002 f9fc 	bl	204dd4 <_GetPosXY>
  2029dc:	4622      	mov	r2, r4
  2029de:	463b      	mov	r3, r7
  2029e0:	e893 0003 	ldmia.w	r3, {r0, r1}
  2029e4:	e882 0003 	stmia.w	r2, {r0, r1}
   	float xxx = pos.x - Circle.x0;
  2029e8:	4bb6      	ldr	r3, [pc, #728]	; (202cc4 <LCD_SearchRadiusPoints+0x334>)
  2029ea:	681b      	ldr	r3, [r3, #0]
  2029ec:	4ab4      	ldr	r2, [pc, #720]	; (202cc0 <LCD_SearchRadiusPoints+0x330>)
  2029ee:	f8b2 2208 	ldrh.w	r2, [r2, #520]	; 0x208
  2029f2:	1a9b      	subs	r3, r3, r2
  2029f4:	ee07 3a90 	vmov	s15, r3
  2029f8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2029fc:	edc7 7a08 	vstr	s15, [r7, #32]
		float yyy = pos.y - Circle.y0;
  202a00:	4bb0      	ldr	r3, [pc, #704]	; (202cc4 <LCD_SearchRadiusPoints+0x334>)
  202a02:	685b      	ldr	r3, [r3, #4]
  202a04:	4aae      	ldr	r2, [pc, #696]	; (202cc0 <LCD_SearchRadiusPoints+0x330>)
  202a06:	f8b2 220a 	ldrh.w	r2, [r2, #522]	; 0x20a
  202a0a:	1a9b      	subs	r3, r3, r2
  202a0c:	ee07 3a90 	vmov	s15, r3
  202a10:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  202a14:	edc7 7a07 	vstr	s15, [r7, #28]
		float _yyy = tang*xxx;
  202a18:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
  202a1c:	edd7 7a08 	vldr	s15, [r7, #32]
  202a20:	ee67 7a27 	vmul.f32	s15, s14, s15
  202a24:	edc7 7a06 	vstr	s15, [r7, #24]

		if(deg>0 && deg<=45)
  202a28:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202a2a:	2b00      	cmp	r3, #0
  202a2c:	d02b      	beq.n	202a86 <LCD_SearchRadiusPoints+0xf6>
  202a2e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202a30:	2b2d      	cmp	r3, #45	; 0x2d
  202a32:	d828      	bhi.n	202a86 <LCD_SearchRadiusPoints+0xf6>
		{
				  if(yyy<_yyy)	                                return 0;
  202a34:	ed97 7a07 	vldr	s14, [r7, #28]
  202a38:	edd7 7a06 	vldr	s15, [r7, #24]
  202a3c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202a40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202a44:	d501      	bpl.n	202a4a <LCD_SearchRadiusPoints+0xba>
  202a46:	2300      	movs	r3, #0
  202a48:	e170      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
			else if( (yyy>=_yyy) && (yyy<tang*(xxx+coeff)) )  return 1;
  202a4a:	ed97 7a07 	vldr	s14, [r7, #28]
  202a4e:	edd7 7a06 	vldr	s15, [r7, #24]
  202a52:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202a56:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202a5a:	db12      	blt.n	202a82 <LCD_SearchRadiusPoints+0xf2>
  202a5c:	ed97 7a08 	vldr	s14, [r7, #32]
  202a60:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202a64:	ee37 7a27 	vadd.f32	s14, s14, s15
  202a68:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202a6c:	ee27 7a27 	vmul.f32	s14, s14, s15
  202a70:	edd7 7a07 	vldr	s15, [r7, #28]
  202a74:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202a78:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202a7c:	dd01      	ble.n	202a82 <LCD_SearchRadiusPoints+0xf2>
  202a7e:	2301      	movs	r3, #1
  202a80:	e154      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
			else															  return 2;
  202a82:	2302      	movs	r3, #2
  202a84:	e152      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}
		else if(deg>45 && deg<=90)
  202a86:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202a88:	2b2d      	cmp	r3, #45	; 0x2d
  202a8a:	d92b      	bls.n	202ae4 <LCD_SearchRadiusPoints+0x154>
  202a8c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202a8e:	2b5a      	cmp	r3, #90	; 0x5a
  202a90:	d828      	bhi.n	202ae4 <LCD_SearchRadiusPoints+0x154>
		{
			  if(yyy<_yyy)	                                return 0;
  202a92:	ed97 7a07 	vldr	s14, [r7, #28]
  202a96:	edd7 7a06 	vldr	s15, [r7, #24]
  202a9a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202a9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202aa2:	d501      	bpl.n	202aa8 <LCD_SearchRadiusPoints+0x118>
  202aa4:	2300      	movs	r3, #0
  202aa6:	e141      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else if( (yyy>=_yyy) && (yyy<tang*(xxx+1)) )      return 1;
  202aa8:	ed97 7a07 	vldr	s14, [r7, #28]
  202aac:	edd7 7a06 	vldr	s15, [r7, #24]
  202ab0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202ab4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ab8:	db12      	blt.n	202ae0 <LCD_SearchRadiusPoints+0x150>
  202aba:	edd7 7a08 	vldr	s15, [r7, #32]
  202abe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202ac2:	ee37 7a87 	vadd.f32	s14, s15, s14
  202ac6:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202aca:	ee27 7a27 	vmul.f32	s14, s14, s15
  202ace:	edd7 7a07 	vldr	s15, [r7, #28]
  202ad2:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202ad6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ada:	dd01      	ble.n	202ae0 <LCD_SearchRadiusPoints+0x150>
  202adc:	2301      	movs	r3, #1
  202ade:	e125      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else															  return 2;
  202ae0:	2302      	movs	r3, #2
  202ae2:	e123      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}

		else if(deg>90 && deg<=135)
  202ae4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202ae6:	2b5a      	cmp	r3, #90	; 0x5a
  202ae8:	d92b      	bls.n	202b42 <LCD_SearchRadiusPoints+0x1b2>
  202aea:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202aec:	2b87      	cmp	r3, #135	; 0x87
  202aee:	d828      	bhi.n	202b42 <LCD_SearchRadiusPoints+0x1b2>
		{
			  if(yyy>_yyy)	                                return 0;
  202af0:	ed97 7a07 	vldr	s14, [r7, #28]
  202af4:	edd7 7a06 	vldr	s15, [r7, #24]
  202af8:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202afc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202b00:	dd01      	ble.n	202b06 <LCD_SearchRadiusPoints+0x176>
  202b02:	2300      	movs	r3, #0
  202b04:	e112      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+1)) )      return 1;
  202b06:	ed97 7a07 	vldr	s14, [r7, #28]
  202b0a:	edd7 7a06 	vldr	s15, [r7, #24]
  202b0e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202b12:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202b16:	d812      	bhi.n	202b3e <LCD_SearchRadiusPoints+0x1ae>
  202b18:	edd7 7a08 	vldr	s15, [r7, #32]
  202b1c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202b20:	ee37 7a87 	vadd.f32	s14, s15, s14
  202b24:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202b28:	ee27 7a27 	vmul.f32	s14, s14, s15
  202b2c:	edd7 7a07 	vldr	s15, [r7, #28]
  202b30:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202b34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202b38:	d501      	bpl.n	202b3e <LCD_SearchRadiusPoints+0x1ae>
  202b3a:	2301      	movs	r3, #1
  202b3c:	e0f6      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else															  return 2;
  202b3e:	2302      	movs	r3, #2
  202b40:	e0f4      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}
		else if(deg>135 && deg<=180)
  202b42:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202b44:	2b87      	cmp	r3, #135	; 0x87
  202b46:	d92b      	bls.n	202ba0 <LCD_SearchRadiusPoints+0x210>
  202b48:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202b4a:	2bb4      	cmp	r3, #180	; 0xb4
  202b4c:	d828      	bhi.n	202ba0 <LCD_SearchRadiusPoints+0x210>
		{
			  if(yyy>_yyy)	                                return 0;
  202b4e:	ed97 7a07 	vldr	s14, [r7, #28]
  202b52:	edd7 7a06 	vldr	s15, [r7, #24]
  202b56:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202b5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202b5e:	dd01      	ble.n	202b64 <LCD_SearchRadiusPoints+0x1d4>
  202b60:	2300      	movs	r3, #0
  202b62:	e0e3      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+coeff)) )  return 1;
  202b64:	ed97 7a07 	vldr	s14, [r7, #28]
  202b68:	edd7 7a06 	vldr	s15, [r7, #24]
  202b6c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202b70:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202b74:	d812      	bhi.n	202b9c <LCD_SearchRadiusPoints+0x20c>
  202b76:	ed97 7a08 	vldr	s14, [r7, #32]
  202b7a:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202b7e:	ee37 7a27 	vadd.f32	s14, s14, s15
  202b82:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202b86:	ee27 7a27 	vmul.f32	s14, s14, s15
  202b8a:	edd7 7a07 	vldr	s15, [r7, #28]
  202b8e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202b92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202b96:	d501      	bpl.n	202b9c <LCD_SearchRadiusPoints+0x20c>
  202b98:	2301      	movs	r3, #1
  202b9a:	e0c7      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else															  return 2;
  202b9c:	2302      	movs	r3, #2
  202b9e:	e0c5      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}

		else if(deg>180 && deg<=225)
  202ba0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202ba2:	2bb4      	cmp	r3, #180	; 0xb4
  202ba4:	d92b      	bls.n	202bfe <LCD_SearchRadiusPoints+0x26e>
  202ba6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202ba8:	2be1      	cmp	r3, #225	; 0xe1
  202baa:	d828      	bhi.n	202bfe <LCD_SearchRadiusPoints+0x26e>
		{
				  if(yyy<_yyy)	                                return 2;
  202bac:	ed97 7a07 	vldr	s14, [r7, #28]
  202bb0:	edd7 7a06 	vldr	s15, [r7, #24]
  202bb4:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202bb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202bbc:	d501      	bpl.n	202bc2 <LCD_SearchRadiusPoints+0x232>
  202bbe:	2302      	movs	r3, #2
  202bc0:	e0b4      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
			else if( (yyy>=_yyy) && (yyy<tang*(xxx+coeff)) )  return 1;
  202bc2:	ed97 7a07 	vldr	s14, [r7, #28]
  202bc6:	edd7 7a06 	vldr	s15, [r7, #24]
  202bca:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202bce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202bd2:	db12      	blt.n	202bfa <LCD_SearchRadiusPoints+0x26a>
  202bd4:	ed97 7a08 	vldr	s14, [r7, #32]
  202bd8:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202bdc:	ee37 7a27 	vadd.f32	s14, s14, s15
  202be0:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202be4:	ee27 7a27 	vmul.f32	s14, s14, s15
  202be8:	edd7 7a07 	vldr	s15, [r7, #28]
  202bec:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202bf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202bf4:	dd01      	ble.n	202bfa <LCD_SearchRadiusPoints+0x26a>
  202bf6:	2301      	movs	r3, #1
  202bf8:	e098      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
			else															  return 0;
  202bfa:	2300      	movs	r3, #0
  202bfc:	e096      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}
		else if(deg>225 && deg<=270)
  202bfe:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202c00:	2be1      	cmp	r3, #225	; 0xe1
  202c02:	d92c      	bls.n	202c5e <LCD_SearchRadiusPoints+0x2ce>
  202c04:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202c06:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  202c0a:	d828      	bhi.n	202c5e <LCD_SearchRadiusPoints+0x2ce>
		{
			  if(yyy<_yyy)	                                return 2;
  202c0c:	ed97 7a07 	vldr	s14, [r7, #28]
  202c10:	edd7 7a06 	vldr	s15, [r7, #24]
  202c14:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202c18:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202c1c:	d501      	bpl.n	202c22 <LCD_SearchRadiusPoints+0x292>
  202c1e:	2302      	movs	r3, #2
  202c20:	e084      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else if( (yyy>=_yyy) && (yyy<tang*(xxx+1)) )      return 1;
  202c22:	ed97 7a07 	vldr	s14, [r7, #28]
  202c26:	edd7 7a06 	vldr	s15, [r7, #24]
  202c2a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202c2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202c32:	db12      	blt.n	202c5a <LCD_SearchRadiusPoints+0x2ca>
  202c34:	edd7 7a08 	vldr	s15, [r7, #32]
  202c38:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202c3c:	ee37 7a87 	vadd.f32	s14, s15, s14
  202c40:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202c44:	ee27 7a27 	vmul.f32	s14, s14, s15
  202c48:	edd7 7a07 	vldr	s15, [r7, #28]
  202c4c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202c50:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202c54:	dd01      	ble.n	202c5a <LCD_SearchRadiusPoints+0x2ca>
  202c56:	2301      	movs	r3, #1
  202c58:	e068      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else															  return 0;
  202c5a:	2300      	movs	r3, #0
  202c5c:	e066      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}

		else if(deg>270 && deg<=315)
  202c5e:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202c60:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  202c64:	d930      	bls.n	202cc8 <LCD_SearchRadiusPoints+0x338>
  202c66:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202c68:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  202c6c:	d22c      	bcs.n	202cc8 <LCD_SearchRadiusPoints+0x338>
		{
			  if(yyy>_yyy)	                                return 2;
  202c6e:	ed97 7a07 	vldr	s14, [r7, #28]
  202c72:	edd7 7a06 	vldr	s15, [r7, #24]
  202c76:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202c7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202c7e:	dd01      	ble.n	202c84 <LCD_SearchRadiusPoints+0x2f4>
  202c80:	2302      	movs	r3, #2
  202c82:	e053      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+1)) )      return 1;
  202c84:	ed97 7a07 	vldr	s14, [r7, #28]
  202c88:	edd7 7a06 	vldr	s15, [r7, #24]
  202c8c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202c90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202c94:	d812      	bhi.n	202cbc <LCD_SearchRadiusPoints+0x32c>
  202c96:	edd7 7a08 	vldr	s15, [r7, #32]
  202c9a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202c9e:	ee37 7a87 	vadd.f32	s14, s15, s14
  202ca2:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202ca6:	ee27 7a27 	vmul.f32	s14, s14, s15
  202caa:	edd7 7a07 	vldr	s15, [r7, #28]
  202cae:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202cb2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202cb6:	d501      	bpl.n	202cbc <LCD_SearchRadiusPoints+0x32c>
  202cb8:	2301      	movs	r3, #1
  202cba:	e037      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else															  return 0;
  202cbc:	2300      	movs	r3, #0
  202cbe:	e035      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
  202cc0:	2000205c 	.word	0x2000205c
  202cc4:	20002048 	.word	0x20002048
		}
		else if(deg>315 && deg<=360)
  202cc8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202cca:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  202cce:	d32c      	bcc.n	202d2a <LCD_SearchRadiusPoints+0x39a>
  202cd0:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202cd2:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  202cd6:	d828      	bhi.n	202d2a <LCD_SearchRadiusPoints+0x39a>
		{
			  if(yyy>_yyy)	                                return 2;
  202cd8:	ed97 7a07 	vldr	s14, [r7, #28]
  202cdc:	edd7 7a06 	vldr	s15, [r7, #24]
  202ce0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202ce4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ce8:	dd01      	ble.n	202cee <LCD_SearchRadiusPoints+0x35e>
  202cea:	2302      	movs	r3, #2
  202cec:	e01e      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+coeff)) )  return 1;
  202cee:	ed97 7a07 	vldr	s14, [r7, #28]
  202cf2:	edd7 7a06 	vldr	s15, [r7, #24]
  202cf6:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202cfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202cfe:	d812      	bhi.n	202d26 <LCD_SearchRadiusPoints+0x396>
  202d00:	ed97 7a08 	vldr	s14, [r7, #32]
  202d04:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202d08:	ee37 7a27 	vadd.f32	s14, s14, s15
  202d0c:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202d10:	ee27 7a27 	vmul.f32	s14, s14, s15
  202d14:	edd7 7a07 	vldr	s15, [r7, #28]
  202d18:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202d1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202d20:	d501      	bpl.n	202d26 <LCD_SearchRadiusPoints+0x396>
  202d22:	2301      	movs	r3, #1
  202d24:	e002      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		else															  return 0;
  202d26:	2300      	movs	r3, #0
  202d28:	e000      	b.n	202d2c <LCD_SearchRadiusPoints+0x39c>
		}

		else
			return 3;
  202d2a:	2303      	movs	r3, #3
}
  202d2c:	4618      	mov	r0, r3
  202d2e:	3734      	adds	r7, #52	; 0x34
  202d30:	46bd      	mov	sp, r7
  202d32:	bd90      	pop	{r4, r7, pc}

00202d34 <LCD_SearchRadiusPoints___>:
structPosition _GetPosXY___(uint32_t posBuff, int k, uint32_t BkpSizeX);
static uint8_t LCD_SearchRadiusPoints___(int posBuff, int k, int nrDeg, uint32_t BkpSizeX)
{
  202d34:	b590      	push	{r4, r7, lr}
  202d36:	b08d      	sub	sp, #52	; 0x34
  202d38:	af00      	add	r7, sp, #0
  202d3a:	6178      	str	r0, [r7, #20]
  202d3c:	6139      	str	r1, [r7, #16]
  202d3e:	60fa      	str	r2, [r7, #12]
  202d40:	60bb      	str	r3, [r7, #8]
	float tang= Circle.tang[nrDeg];
  202d42:	4ac9      	ldr	r2, [pc, #804]	; (203068 <LCD_SearchRadiusPoints___+0x334>)
  202d44:	68fb      	ldr	r3, [r7, #12]
  202d46:	3392      	adds	r3, #146	; 0x92
  202d48:	009b      	lsls	r3, r3, #2
  202d4a:	4413      	add	r3, r2
  202d4c:	3304      	adds	r3, #4
  202d4e:	681b      	ldr	r3, [r3, #0]
  202d50:	62fb      	str	r3, [r7, #44]	; 0x2c
	float coeff=Circle.coeff[nrDeg];
  202d52:	4ac5      	ldr	r2, [pc, #788]	; (203068 <LCD_SearchRadiusPoints___+0x334>)
  202d54:	68fb      	ldr	r3, [r7, #12]
  202d56:	339c      	adds	r3, #156	; 0x9c
  202d58:	009b      	lsls	r3, r3, #2
  202d5a:	4413      	add	r3, r2
  202d5c:	3304      	adds	r3, #4
  202d5e:	681b      	ldr	r3, [r3, #0]
  202d60:	62bb      	str	r3, [r7, #40]	; 0x28
	uint16_t deg = Circle.degree[1+nrDeg];
  202d62:	68fb      	ldr	r3, [r7, #12]
  202d64:	3301      	adds	r3, #1
  202d66:	4ac0      	ldr	r2, [pc, #768]	; (203068 <LCD_SearchRadiusPoints___+0x334>)
  202d68:	f503 7382 	add.w	r3, r3, #260	; 0x104
  202d6c:	005b      	lsls	r3, r3, #1
  202d6e:	4413      	add	r3, r2
  202d70:	889b      	ldrh	r3, [r3, #4]
  202d72:	84fb      	strh	r3, [r7, #38]	; 0x26

   	pos = _GetPosXY___(posBuff,k,BkpSizeX);
  202d74:	6979      	ldr	r1, [r7, #20]
  202d76:	4cbd      	ldr	r4, [pc, #756]	; (20306c <LCD_SearchRadiusPoints___+0x338>)
  202d78:	4638      	mov	r0, r7
  202d7a:	68bb      	ldr	r3, [r7, #8]
  202d7c:	693a      	ldr	r2, [r7, #16]
  202d7e:	f002 f851 	bl	204e24 <_GetPosXY___>
  202d82:	4622      	mov	r2, r4
  202d84:	463b      	mov	r3, r7
  202d86:	e893 0003 	ldmia.w	r3, {r0, r1}
  202d8a:	e882 0003 	stmia.w	r2, {r0, r1}
   	float xxx = pos.x - Circle.x0;
  202d8e:	4bb7      	ldr	r3, [pc, #732]	; (20306c <LCD_SearchRadiusPoints___+0x338>)
  202d90:	681b      	ldr	r3, [r3, #0]
  202d92:	4ab5      	ldr	r2, [pc, #724]	; (203068 <LCD_SearchRadiusPoints___+0x334>)
  202d94:	f8b2 2208 	ldrh.w	r2, [r2, #520]	; 0x208
  202d98:	1a9b      	subs	r3, r3, r2
  202d9a:	ee07 3a90 	vmov	s15, r3
  202d9e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  202da2:	edc7 7a08 	vstr	s15, [r7, #32]
		float yyy = pos.y - Circle.y0;
  202da6:	4bb1      	ldr	r3, [pc, #708]	; (20306c <LCD_SearchRadiusPoints___+0x338>)
  202da8:	685b      	ldr	r3, [r3, #4]
  202daa:	4aaf      	ldr	r2, [pc, #700]	; (203068 <LCD_SearchRadiusPoints___+0x334>)
  202dac:	f8b2 220a 	ldrh.w	r2, [r2, #522]	; 0x20a
  202db0:	1a9b      	subs	r3, r3, r2
  202db2:	ee07 3a90 	vmov	s15, r3
  202db6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  202dba:	edc7 7a07 	vstr	s15, [r7, #28]
		float _yyy = tang*xxx;
  202dbe:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
  202dc2:	edd7 7a08 	vldr	s15, [r7, #32]
  202dc6:	ee67 7a27 	vmul.f32	s15, s14, s15
  202dca:	edc7 7a06 	vstr	s15, [r7, #24]

		if(deg>0 && deg<=45)
  202dce:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202dd0:	2b00      	cmp	r3, #0
  202dd2:	d02b      	beq.n	202e2c <LCD_SearchRadiusPoints___+0xf8>
  202dd4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202dd6:	2b2d      	cmp	r3, #45	; 0x2d
  202dd8:	d828      	bhi.n	202e2c <LCD_SearchRadiusPoints___+0xf8>
		{
				  if(yyy<_yyy)	                                return 0;
  202dda:	ed97 7a07 	vldr	s14, [r7, #28]
  202dde:	edd7 7a06 	vldr	s15, [r7, #24]
  202de2:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202de6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202dea:	d501      	bpl.n	202df0 <LCD_SearchRadiusPoints___+0xbc>
  202dec:	2300      	movs	r3, #0
  202dee:	e171      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
			else if( (yyy>=_yyy) && (yyy<tang*(xxx+coeff)) )  return 1;
  202df0:	ed97 7a07 	vldr	s14, [r7, #28]
  202df4:	edd7 7a06 	vldr	s15, [r7, #24]
  202df8:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202dfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202e00:	db12      	blt.n	202e28 <LCD_SearchRadiusPoints___+0xf4>
  202e02:	ed97 7a08 	vldr	s14, [r7, #32]
  202e06:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202e0a:	ee37 7a27 	vadd.f32	s14, s14, s15
  202e0e:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202e12:	ee27 7a27 	vmul.f32	s14, s14, s15
  202e16:	edd7 7a07 	vldr	s15, [r7, #28]
  202e1a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202e1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202e22:	dd01      	ble.n	202e28 <LCD_SearchRadiusPoints___+0xf4>
  202e24:	2301      	movs	r3, #1
  202e26:	e155      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
			else															  return 2;
  202e28:	2302      	movs	r3, #2
  202e2a:	e153      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}
		else if(deg>45 && deg<=90)
  202e2c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202e2e:	2b2d      	cmp	r3, #45	; 0x2d
  202e30:	d92b      	bls.n	202e8a <LCD_SearchRadiusPoints___+0x156>
  202e32:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202e34:	2b5a      	cmp	r3, #90	; 0x5a
  202e36:	d828      	bhi.n	202e8a <LCD_SearchRadiusPoints___+0x156>
		{
			  if(yyy<_yyy)	                                return 0;
  202e38:	ed97 7a07 	vldr	s14, [r7, #28]
  202e3c:	edd7 7a06 	vldr	s15, [r7, #24]
  202e40:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202e44:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202e48:	d501      	bpl.n	202e4e <LCD_SearchRadiusPoints___+0x11a>
  202e4a:	2300      	movs	r3, #0
  202e4c:	e142      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else if( (yyy>=_yyy) && (yyy<tang*(xxx+1)) )      return 1;
  202e4e:	ed97 7a07 	vldr	s14, [r7, #28]
  202e52:	edd7 7a06 	vldr	s15, [r7, #24]
  202e56:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202e5a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202e5e:	db12      	blt.n	202e86 <LCD_SearchRadiusPoints___+0x152>
  202e60:	edd7 7a08 	vldr	s15, [r7, #32]
  202e64:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202e68:	ee37 7a87 	vadd.f32	s14, s15, s14
  202e6c:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202e70:	ee27 7a27 	vmul.f32	s14, s14, s15
  202e74:	edd7 7a07 	vldr	s15, [r7, #28]
  202e78:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202e7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202e80:	dd01      	ble.n	202e86 <LCD_SearchRadiusPoints___+0x152>
  202e82:	2301      	movs	r3, #1
  202e84:	e126      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else															  return 2;
  202e86:	2302      	movs	r3, #2
  202e88:	e124      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}

		else if(deg>90 && deg<=135)
  202e8a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202e8c:	2b5a      	cmp	r3, #90	; 0x5a
  202e8e:	d92b      	bls.n	202ee8 <LCD_SearchRadiusPoints___+0x1b4>
  202e90:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202e92:	2b87      	cmp	r3, #135	; 0x87
  202e94:	d828      	bhi.n	202ee8 <LCD_SearchRadiusPoints___+0x1b4>
		{
			  if(yyy>_yyy)	                                return 0;
  202e96:	ed97 7a07 	vldr	s14, [r7, #28]
  202e9a:	edd7 7a06 	vldr	s15, [r7, #24]
  202e9e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202ea2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ea6:	dd01      	ble.n	202eac <LCD_SearchRadiusPoints___+0x178>
  202ea8:	2300      	movs	r3, #0
  202eaa:	e113      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+1)) )      return 1;
  202eac:	ed97 7a07 	vldr	s14, [r7, #28]
  202eb0:	edd7 7a06 	vldr	s15, [r7, #24]
  202eb4:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202eb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ebc:	d812      	bhi.n	202ee4 <LCD_SearchRadiusPoints___+0x1b0>
  202ebe:	edd7 7a08 	vldr	s15, [r7, #32]
  202ec2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202ec6:	ee37 7a87 	vadd.f32	s14, s15, s14
  202eca:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202ece:	ee27 7a27 	vmul.f32	s14, s14, s15
  202ed2:	edd7 7a07 	vldr	s15, [r7, #28]
  202ed6:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202eda:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ede:	d501      	bpl.n	202ee4 <LCD_SearchRadiusPoints___+0x1b0>
  202ee0:	2301      	movs	r3, #1
  202ee2:	e0f7      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else															  return 2;
  202ee4:	2302      	movs	r3, #2
  202ee6:	e0f5      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}
		else if(deg>135 && deg<=180)
  202ee8:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202eea:	2b87      	cmp	r3, #135	; 0x87
  202eec:	d92b      	bls.n	202f46 <LCD_SearchRadiusPoints___+0x212>
  202eee:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202ef0:	2bb4      	cmp	r3, #180	; 0xb4
  202ef2:	d828      	bhi.n	202f46 <LCD_SearchRadiusPoints___+0x212>
		{
			  if(yyy>_yyy)	                                return 0;
  202ef4:	ed97 7a07 	vldr	s14, [r7, #28]
  202ef8:	edd7 7a06 	vldr	s15, [r7, #24]
  202efc:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202f00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202f04:	dd01      	ble.n	202f0a <LCD_SearchRadiusPoints___+0x1d6>
  202f06:	2300      	movs	r3, #0
  202f08:	e0e4      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+coeff)) )  return 1;
  202f0a:	ed97 7a07 	vldr	s14, [r7, #28]
  202f0e:	edd7 7a06 	vldr	s15, [r7, #24]
  202f12:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202f16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202f1a:	d812      	bhi.n	202f42 <LCD_SearchRadiusPoints___+0x20e>
  202f1c:	ed97 7a08 	vldr	s14, [r7, #32]
  202f20:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202f24:	ee37 7a27 	vadd.f32	s14, s14, s15
  202f28:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202f2c:	ee27 7a27 	vmul.f32	s14, s14, s15
  202f30:	edd7 7a07 	vldr	s15, [r7, #28]
  202f34:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202f38:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202f3c:	d501      	bpl.n	202f42 <LCD_SearchRadiusPoints___+0x20e>
  202f3e:	2301      	movs	r3, #1
  202f40:	e0c8      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else															  return 2;
  202f42:	2302      	movs	r3, #2
  202f44:	e0c6      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}

		else if(deg>180 && deg<=225)
  202f46:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202f48:	2bb4      	cmp	r3, #180	; 0xb4
  202f4a:	d92b      	bls.n	202fa4 <LCD_SearchRadiusPoints___+0x270>
  202f4c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202f4e:	2be1      	cmp	r3, #225	; 0xe1
  202f50:	d828      	bhi.n	202fa4 <LCD_SearchRadiusPoints___+0x270>
		{
				  if(yyy<_yyy)	                                return 2;
  202f52:	ed97 7a07 	vldr	s14, [r7, #28]
  202f56:	edd7 7a06 	vldr	s15, [r7, #24]
  202f5a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202f5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202f62:	d501      	bpl.n	202f68 <LCD_SearchRadiusPoints___+0x234>
  202f64:	2302      	movs	r3, #2
  202f66:	e0b5      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
			else if( (yyy>=_yyy) && (yyy<tang*(xxx+coeff)) )  return 1;
  202f68:	ed97 7a07 	vldr	s14, [r7, #28]
  202f6c:	edd7 7a06 	vldr	s15, [r7, #24]
  202f70:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202f74:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202f78:	db12      	blt.n	202fa0 <LCD_SearchRadiusPoints___+0x26c>
  202f7a:	ed97 7a08 	vldr	s14, [r7, #32]
  202f7e:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  202f82:	ee37 7a27 	vadd.f32	s14, s14, s15
  202f86:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202f8a:	ee27 7a27 	vmul.f32	s14, s14, s15
  202f8e:	edd7 7a07 	vldr	s15, [r7, #28]
  202f92:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202f96:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202f9a:	dd01      	ble.n	202fa0 <LCD_SearchRadiusPoints___+0x26c>
  202f9c:	2301      	movs	r3, #1
  202f9e:	e099      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
			else															  return 0;
  202fa0:	2300      	movs	r3, #0
  202fa2:	e097      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}
		else if(deg>225 && deg<=270)
  202fa4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202fa6:	2be1      	cmp	r3, #225	; 0xe1
  202fa8:	d92c      	bls.n	203004 <LCD_SearchRadiusPoints___+0x2d0>
  202faa:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  202fac:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  202fb0:	d828      	bhi.n	203004 <LCD_SearchRadiusPoints___+0x2d0>
		{
			  if(yyy<_yyy)	                                return 2;
  202fb2:	ed97 7a07 	vldr	s14, [r7, #28]
  202fb6:	edd7 7a06 	vldr	s15, [r7, #24]
  202fba:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202fbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202fc2:	d501      	bpl.n	202fc8 <LCD_SearchRadiusPoints___+0x294>
  202fc4:	2302      	movs	r3, #2
  202fc6:	e085      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else if( (yyy>=_yyy) && (yyy<tang*(xxx+1)) )      return 1;
  202fc8:	ed97 7a07 	vldr	s14, [r7, #28]
  202fcc:	edd7 7a06 	vldr	s15, [r7, #24]
  202fd0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202fd4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202fd8:	db12      	blt.n	203000 <LCD_SearchRadiusPoints___+0x2cc>
  202fda:	edd7 7a08 	vldr	s15, [r7, #32]
  202fde:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  202fe2:	ee37 7a87 	vadd.f32	s14, s15, s14
  202fe6:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  202fea:	ee27 7a27 	vmul.f32	s14, s14, s15
  202fee:	edd7 7a07 	vldr	s15, [r7, #28]
  202ff2:	eeb4 7ae7 	vcmpe.f32	s14, s15
  202ff6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  202ffa:	dd01      	ble.n	203000 <LCD_SearchRadiusPoints___+0x2cc>
  202ffc:	2301      	movs	r3, #1
  202ffe:	e069      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else															  return 0;
  203000:	2300      	movs	r3, #0
  203002:	e067      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}

		else if(deg>270 && deg<=315)
  203004:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  203006:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  20300a:	d931      	bls.n	203070 <LCD_SearchRadiusPoints___+0x33c>
  20300c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  20300e:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  203012:	d22d      	bcs.n	203070 <LCD_SearchRadiusPoints___+0x33c>
		{
			  if(yyy>_yyy)	                                return 2;
  203014:	ed97 7a07 	vldr	s14, [r7, #28]
  203018:	edd7 7a06 	vldr	s15, [r7, #24]
  20301c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  203020:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  203024:	dd01      	ble.n	20302a <LCD_SearchRadiusPoints___+0x2f6>
  203026:	2302      	movs	r3, #2
  203028:	e054      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+1)) )      return 1;
  20302a:	ed97 7a07 	vldr	s14, [r7, #28]
  20302e:	edd7 7a06 	vldr	s15, [r7, #24]
  203032:	eeb4 7ae7 	vcmpe.f32	s14, s15
  203036:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20303a:	d812      	bhi.n	203062 <LCD_SearchRadiusPoints___+0x32e>
  20303c:	edd7 7a08 	vldr	s15, [r7, #32]
  203040:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  203044:	ee37 7a87 	vadd.f32	s14, s15, s14
  203048:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  20304c:	ee27 7a27 	vmul.f32	s14, s14, s15
  203050:	edd7 7a07 	vldr	s15, [r7, #28]
  203054:	eeb4 7ae7 	vcmpe.f32	s14, s15
  203058:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20305c:	d501      	bpl.n	203062 <LCD_SearchRadiusPoints___+0x32e>
  20305e:	2301      	movs	r3, #1
  203060:	e038      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else															  return 0;
  203062:	2300      	movs	r3, #0
  203064:	e036      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
  203066:	bf00      	nop
  203068:	2000205c 	.word	0x2000205c
  20306c:	20002048 	.word	0x20002048
		}
		else if(deg>315 && deg<=360)
  203070:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  203072:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  203076:	d32c      	bcc.n	2030d2 <LCD_SearchRadiusPoints___+0x39e>
  203078:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  20307a:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  20307e:	d828      	bhi.n	2030d2 <LCD_SearchRadiusPoints___+0x39e>
		{
			  if(yyy>_yyy)	                                return 2;
  203080:	ed97 7a07 	vldr	s14, [r7, #28]
  203084:	edd7 7a06 	vldr	s15, [r7, #24]
  203088:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20308c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  203090:	dd01      	ble.n	203096 <LCD_SearchRadiusPoints___+0x362>
  203092:	2302      	movs	r3, #2
  203094:	e01e      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else if( (yyy<=_yyy) && (yyy>tang*(xxx+coeff)) )  return 1;
  203096:	ed97 7a07 	vldr	s14, [r7, #28]
  20309a:	edd7 7a06 	vldr	s15, [r7, #24]
  20309e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2030a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2030a6:	d812      	bhi.n	2030ce <LCD_SearchRadiusPoints___+0x39a>
  2030a8:	ed97 7a08 	vldr	s14, [r7, #32]
  2030ac:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  2030b0:	ee37 7a27 	vadd.f32	s14, s14, s15
  2030b4:	edd7 7a0b 	vldr	s15, [r7, #44]	; 0x2c
  2030b8:	ee27 7a27 	vmul.f32	s14, s14, s15
  2030bc:	edd7 7a07 	vldr	s15, [r7, #28]
  2030c0:	eeb4 7ae7 	vcmpe.f32	s14, s15
  2030c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2030c8:	d501      	bpl.n	2030ce <LCD_SearchRadiusPoints___+0x39a>
  2030ca:	2301      	movs	r3, #1
  2030cc:	e002      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		else															  return 0;
  2030ce:	2300      	movs	r3, #0
  2030d0:	e000      	b.n	2030d4 <LCD_SearchRadiusPoints___+0x3a0>
		}

		else
			return 3;
  2030d2:	2303      	movs	r3, #3
}
  2030d4:	4618      	mov	r0, r3
  2030d6:	3734      	adds	r7, #52	; 0x34
  2030d8:	46bd      	mov	sp, r7
  2030da:	bd90      	pop	{r4, r7, pc}

002030dc <_DrawArrayBuffRightDown_AA___>:

static uint8_t _DrawArrayBuffRightDown_AA___(uint32_t posBuff, uint8_t *pFill, uint32_t drawColor, uint32_t outColor, uint32_t inColor, float outRatioStart, float inRatioStart, uint32_t BkpSizeX, int direction, uint8_t *buf)
{
  2030dc:	b580      	push	{r7, lr}
  2030de:	b090      	sub	sp, #64	; 0x40
  2030e0:	af00      	add	r7, sp, #0
  2030e2:	6178      	str	r0, [r7, #20]
  2030e4:	6139      	str	r1, [r7, #16]
  2030e6:	60fa      	str	r2, [r7, #12]
  2030e8:	60bb      	str	r3, [r7, #8]
  2030ea:	ed87 0a01 	vstr	s0, [r7, #4]
  2030ee:	edc7 0a00 	vstr	s1, [r7]
	int j=buf[0], i=buf[1], p=2, i_prev;
  2030f2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  2030f4:	781b      	ldrb	r3, [r3, #0]
  2030f6:	63fb      	str	r3, [r7, #60]	; 0x3c
  2030f8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  2030fa:	3301      	adds	r3, #1
  2030fc:	781b      	ldrb	r3, [r3, #0]
  2030fe:	63bb      	str	r3, [r7, #56]	; 0x38
  203100:	2302      	movs	r3, #2
  203102:	637b      	str	r3, [r7, #52]	; 0x34
	uint8_t thershold;

	if(0==direction)
  203104:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  203106:	2b00      	cmp	r3, #0
  203108:	f040 8193 	bne.w	203432 <_DrawArrayBuffRightDown_AA___+0x356>
	{
		while(j--)
  20310c:	e0b7      	b.n	20327e <_DrawArrayBuffRightDown_AA___+0x1a2>
		{
			i_prev=i;
  20310e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  203110:	623b      	str	r3, [r7, #32]
			while(i--){
  203112:	e034      	b.n	20317e <_DrawArrayBuffRightDown_AA___+0xa2>
				thershold=LCD_SearchRadiusPoints(posBuff,*pFill,BkpSizeX);
  203114:	6978      	ldr	r0, [r7, #20]
  203116:	693b      	ldr	r3, [r7, #16]
  203118:	781b      	ldrb	r3, [r3, #0]
  20311a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20311c:	4619      	mov	r1, r3
  20311e:	f7ff fc37 	bl	202990 <LCD_SearchRadiusPoints>
  203122:	4603      	mov	r3, r0
  203124:	77fb      	strb	r3, [r7, #31]
				if((0==thershold)||(1==thershold)){
  203126:	7ffb      	ldrb	r3, [r7, #31]
  203128:	2b00      	cmp	r3, #0
  20312a:	d002      	beq.n	203132 <_DrawArrayBuffRightDown_AA___+0x56>
  20312c:	7ffb      	ldrb	r3, [r7, #31]
  20312e:	2b01      	cmp	r3, #1
  203130:	d112      	bne.n	203158 <_DrawArrayBuffRightDown_AA___+0x7c>
					if(*pFill==0) *pFill=1;
  203132:	693b      	ldr	r3, [r7, #16]
  203134:	781b      	ldrb	r3, [r3, #0]
  203136:	2b00      	cmp	r3, #0
  203138:	d10c      	bne.n	203154 <_DrawArrayBuffRightDown_AA___+0x78>
  20313a:	693b      	ldr	r3, [r7, #16]
  20313c:	2201      	movs	r2, #1
  20313e:	701a      	strb	r2, [r3, #0]
					else return 1;
					pLcd[k++]=drawColor;
  203140:	4b97      	ldr	r3, [pc, #604]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203142:	681b      	ldr	r3, [r3, #0]
  203144:	1c5a      	adds	r2, r3, #1
  203146:	4996      	ldr	r1, [pc, #600]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203148:	600a      	str	r2, [r1, #0]
  20314a:	4996      	ldr	r1, [pc, #600]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  20314c:	68fa      	ldr	r2, [r7, #12]
  20314e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  203152:	e014      	b.n	20317e <_DrawArrayBuffRightDown_AA___+0xa2>
					else return 1;
  203154:	2301      	movs	r3, #1
  203156:	e173      	b.n	203440 <_DrawArrayBuffRightDown_AA___+0x364>
				}
				else{
					if(*pFill==0)
  203158:	693b      	ldr	r3, [r7, #16]
  20315a:	781b      	ldrb	r3, [r3, #0]
  20315c:	2b00      	cmp	r3, #0
  20315e:	d105      	bne.n	20316c <_DrawArrayBuffRightDown_AA___+0x90>
						k++;
  203160:	4b8f      	ldr	r3, [pc, #572]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203162:	681b      	ldr	r3, [r3, #0]
  203164:	3301      	adds	r3, #1
  203166:	4a8e      	ldr	r2, [pc, #568]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203168:	6013      	str	r3, [r2, #0]
  20316a:	e008      	b.n	20317e <_DrawArrayBuffRightDown_AA___+0xa2>
					else
						pLcd[k++]=drawColor;
  20316c:	4b8c      	ldr	r3, [pc, #560]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  20316e:	681b      	ldr	r3, [r3, #0]
  203170:	1c5a      	adds	r2, r3, #1
  203172:	498b      	ldr	r1, [pc, #556]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203174:	600a      	str	r2, [r1, #0]
  203176:	498b      	ldr	r1, [pc, #556]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  203178:	68fa      	ldr	r2, [r7, #12]
  20317a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			while(i--){
  20317e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  203180:	1e5a      	subs	r2, r3, #1
  203182:	63ba      	str	r2, [r7, #56]	; 0x38
  203184:	2b00      	cmp	r3, #0
  203186:	d1c5      	bne.n	203114 <_DrawArrayBuffRightDown_AA___+0x38>
				}
			}

			if(j){
  203188:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20318a:	2b00      	cmp	r3, #0
  20318c:	d03c      	beq.n	203208 <_DrawArrayBuffRightDown_AA___+0x12c>
				i=buf[p++];
  20318e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  203190:	1c5a      	adds	r2, r3, #1
  203192:	637a      	str	r2, [r7, #52]	; 0x34
  203194:	461a      	mov	r2, r3
  203196:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  203198:	4413      	add	r3, r2
  20319a:	781b      	ldrb	r3, [r3, #0]
  20319c:	63bb      	str	r3, [r7, #56]	; 0x38
				if(*pFill==1){
  20319e:	693b      	ldr	r3, [r7, #16]
  2031a0:	781b      	ldrb	r3, [r3, #0]
  2031a2:	2b01      	cmp	r3, #1
  2031a4:	d130      	bne.n	203208 <_DrawArrayBuffRightDown_AA___+0x12c>
					Set_AACoeff_Draw(i,drawColor,outColor,outRatioStart);
  2031a6:	ed97 0a01 	vldr	s0, [r7, #4]
  2031aa:	68ba      	ldr	r2, [r7, #8]
  2031ac:	68f9      	ldr	r1, [r7, #12]
  2031ae:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  2031b0:	f001 fe9c 	bl	204eec <Set_AACoeff_Draw>
					for(int a=0;a<buff_AA[0];++a){
  2031b4:	2300      	movs	r3, #0
  2031b6:	633b      	str	r3, [r7, #48]	; 0x30
  2031b8:	e01f      	b.n	2031fa <_DrawArrayBuffRightDown_AA___+0x11e>
						thershold=LCD_SearchRadiusPoints___(posBuff,k+a,*pFill,BkpSizeX);
  2031ba:	6978      	ldr	r0, [r7, #20]
  2031bc:	4b78      	ldr	r3, [pc, #480]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2031be:	681a      	ldr	r2, [r3, #0]
  2031c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2031c2:	4413      	add	r3, r2
  2031c4:	4619      	mov	r1, r3
  2031c6:	693b      	ldr	r3, [r7, #16]
  2031c8:	781b      	ldrb	r3, [r3, #0]
  2031ca:	461a      	mov	r2, r3
  2031cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2031ce:	f7ff fdb1 	bl	202d34 <LCD_SearchRadiusPoints___>
  2031d2:	4603      	mov	r3, r0
  2031d4:	77fb      	strb	r3, [r7, #31]
						if(2==thershold)
  2031d6:	7ffb      	ldrb	r3, [r7, #31]
  2031d8:	2b02      	cmp	r3, #2
  2031da:	d114      	bne.n	203206 <_DrawArrayBuffRightDown_AA___+0x12a>
							pLcd[k+a]=buff_AA[1+a];
  2031dc:	4b70      	ldr	r3, [pc, #448]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2031de:	681a      	ldr	r2, [r3, #0]
  2031e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2031e2:	4413      	add	r3, r2
  2031e4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  2031e6:	3201      	adds	r2, #1
  2031e8:	496f      	ldr	r1, [pc, #444]	; (2033a8 <_DrawArrayBuffRightDown_AA___+0x2cc>)
  2031ea:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2031ee:	496d      	ldr	r1, [pc, #436]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  2031f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					for(int a=0;a<buff_AA[0];++a){
  2031f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2031f6:	3301      	adds	r3, #1
  2031f8:	633b      	str	r3, [r7, #48]	; 0x30
  2031fa:	4b6b      	ldr	r3, [pc, #428]	; (2033a8 <_DrawArrayBuffRightDown_AA___+0x2cc>)
  2031fc:	681a      	ldr	r2, [r3, #0]
  2031fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  203200:	429a      	cmp	r2, r3
  203202:	d8da      	bhi.n	2031ba <_DrawArrayBuffRightDown_AA___+0xde>
  203204:	e000      	b.n	203208 <_DrawArrayBuffRightDown_AA___+0x12c>
						else
							break;
  203206:	bf00      	nop
					}
			}}
			k+=BkpSizeX;
  203208:	4b65      	ldr	r3, [pc, #404]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  20320a:	681a      	ldr	r2, [r3, #0]
  20320c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20320e:	4413      	add	r3, r2
  203210:	4a63      	ldr	r2, [pc, #396]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203212:	6013      	str	r3, [r2, #0]

			if(*pFill==1){
  203214:	693b      	ldr	r3, [r7, #16]
  203216:	781b      	ldrb	r3, [r3, #0]
  203218:	2b01      	cmp	r3, #1
  20321a:	d130      	bne.n	20327e <_DrawArrayBuffRightDown_AA___+0x1a2>
				Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
  20321c:	ed97 0a00 	vldr	s0, [r7]
  203220:	6cba      	ldr	r2, [r7, #72]	; 0x48
  203222:	68f9      	ldr	r1, [r7, #12]
  203224:	6a38      	ldr	r0, [r7, #32]
  203226:	f001 fe61 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a){
  20322a:	2300      	movs	r3, #0
  20322c:	62fb      	str	r3, [r7, #44]	; 0x2c
  20322e:	e021      	b.n	203274 <_DrawArrayBuffRightDown_AA___+0x198>
					thershold=LCD_SearchRadiusPoints___(posBuff,k-1-a,*pFill,BkpSizeX);
  203230:	6978      	ldr	r0, [r7, #20]
  203232:	4b5b      	ldr	r3, [pc, #364]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203234:	681a      	ldr	r2, [r3, #0]
  203236:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203238:	1ad3      	subs	r3, r2, r3
  20323a:	3b01      	subs	r3, #1
  20323c:	4619      	mov	r1, r3
  20323e:	693b      	ldr	r3, [r7, #16]
  203240:	781b      	ldrb	r3, [r3, #0]
  203242:	461a      	mov	r2, r3
  203244:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203246:	f7ff fd75 	bl	202d34 <LCD_SearchRadiusPoints___>
  20324a:	4603      	mov	r3, r0
  20324c:	77fb      	strb	r3, [r7, #31]
					if(2==thershold)
  20324e:	7ffb      	ldrb	r3, [r7, #31]
  203250:	2b02      	cmp	r3, #2
  203252:	d114      	bne.n	20327e <_DrawArrayBuffRightDown_AA___+0x1a2>
						pLcd[k-1-a]=buff_AA[1+a];
  203254:	4b52      	ldr	r3, [pc, #328]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203256:	681a      	ldr	r2, [r3, #0]
  203258:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20325a:	1ad3      	subs	r3, r2, r3
  20325c:	3b01      	subs	r3, #1
  20325e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  203260:	3201      	adds	r2, #1
  203262:	4951      	ldr	r1, [pc, #324]	; (2033a8 <_DrawArrayBuffRightDown_AA___+0x2cc>)
  203264:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  203268:	494e      	ldr	r1, [pc, #312]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  20326a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a){
  20326e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203270:	3301      	adds	r3, #1
  203272:	62fb      	str	r3, [r7, #44]	; 0x2c
  203274:	4b4c      	ldr	r3, [pc, #304]	; (2033a8 <_DrawArrayBuffRightDown_AA___+0x2cc>)
  203276:	681a      	ldr	r2, [r3, #0]
  203278:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20327a:	429a      	cmp	r2, r3
  20327c:	d8d8      	bhi.n	203230 <_DrawArrayBuffRightDown_AA___+0x154>
		while(j--)
  20327e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  203280:	1e5a      	subs	r2, r3, #1
  203282:	63fa      	str	r2, [r7, #60]	; 0x3c
  203284:	2b00      	cmp	r3, #0
  203286:	f47f af42 	bne.w	20310e <_DrawArrayBuffRightDown_AA___+0x32>
  20328a:	e0d8      	b.n	20343e <_DrawArrayBuffRightDown_AA___+0x362>
	}
	else
	{
		while(j--)
		{
			i_prev=i;
  20328c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20328e:	623b      	str	r3, [r7, #32]
			while(i--){
  203290:	e03b      	b.n	20330a <_DrawArrayBuffRightDown_AA___+0x22e>
				thershold=LCD_SearchRadiusPoints(posBuff,*pFill,BkpSizeX);
  203292:	6978      	ldr	r0, [r7, #20]
  203294:	693b      	ldr	r3, [r7, #16]
  203296:	781b      	ldrb	r3, [r3, #0]
  203298:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20329a:	4619      	mov	r1, r3
  20329c:	f7ff fb78 	bl	202990 <LCD_SearchRadiusPoints>
  2032a0:	4603      	mov	r3, r0
  2032a2:	77fb      	strb	r3, [r7, #31]
				if((0==thershold)||(1==thershold)){
  2032a4:	7ffb      	ldrb	r3, [r7, #31]
  2032a6:	2b00      	cmp	r3, #0
  2032a8:	d002      	beq.n	2032b0 <_DrawArrayBuffRightDown_AA___+0x1d4>
  2032aa:	7ffb      	ldrb	r3, [r7, #31]
  2032ac:	2b01      	cmp	r3, #1
  2032ae:	d115      	bne.n	2032dc <_DrawArrayBuffRightDown_AA___+0x200>
					if(*pFill==0) *pFill=1;
  2032b0:	693b      	ldr	r3, [r7, #16]
  2032b2:	781b      	ldrb	r3, [r3, #0]
  2032b4:	2b00      	cmp	r3, #0
  2032b6:	d10f      	bne.n	2032d8 <_DrawArrayBuffRightDown_AA___+0x1fc>
  2032b8:	693b      	ldr	r3, [r7, #16]
  2032ba:	2201      	movs	r2, #1
  2032bc:	701a      	strb	r2, [r3, #0]
					else return 1;
					pLcd[k]=drawColor;
  2032be:	4b38      	ldr	r3, [pc, #224]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2032c0:	681b      	ldr	r3, [r3, #0]
  2032c2:	4938      	ldr	r1, [pc, #224]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  2032c4:	68fa      	ldr	r2, [r7, #12]
  2032c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					k+=BkpSizeX;
  2032ca:	4b35      	ldr	r3, [pc, #212]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2032cc:	681a      	ldr	r2, [r3, #0]
  2032ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2032d0:	4413      	add	r3, r2
  2032d2:	4a33      	ldr	r2, [pc, #204]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2032d4:	6013      	str	r3, [r2, #0]
  2032d6:	e018      	b.n	20330a <_DrawArrayBuffRightDown_AA___+0x22e>
					else return 1;
  2032d8:	2301      	movs	r3, #1
  2032da:	e0b1      	b.n	203440 <_DrawArrayBuffRightDown_AA___+0x364>
				}
				else{
					if(*pFill==0)
  2032dc:	693b      	ldr	r3, [r7, #16]
  2032de:	781b      	ldrb	r3, [r3, #0]
  2032e0:	2b00      	cmp	r3, #0
  2032e2:	d106      	bne.n	2032f2 <_DrawArrayBuffRightDown_AA___+0x216>
						k+=BkpSizeX;
  2032e4:	4b2e      	ldr	r3, [pc, #184]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2032e6:	681a      	ldr	r2, [r3, #0]
  2032e8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2032ea:	4413      	add	r3, r2
  2032ec:	4a2c      	ldr	r2, [pc, #176]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2032ee:	6013      	str	r3, [r2, #0]
  2032f0:	e00b      	b.n	20330a <_DrawArrayBuffRightDown_AA___+0x22e>
					else{
						pLcd[k]=drawColor;
  2032f2:	4b2b      	ldr	r3, [pc, #172]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  2032f4:	681b      	ldr	r3, [r3, #0]
  2032f6:	492b      	ldr	r1, [pc, #172]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  2032f8:	68fa      	ldr	r2, [r7, #12]
  2032fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
						k+=BkpSizeX;
  2032fe:	4b28      	ldr	r3, [pc, #160]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203300:	681a      	ldr	r2, [r3, #0]
  203302:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203304:	4413      	add	r3, r2
  203306:	4a26      	ldr	r2, [pc, #152]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203308:	6013      	str	r3, [r2, #0]
			while(i--){
  20330a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20330c:	1e5a      	subs	r2, r3, #1
  20330e:	63ba      	str	r2, [r7, #56]	; 0x38
  203310:	2b00      	cmp	r3, #0
  203312:	d1be      	bne.n	203292 <_DrawArrayBuffRightDown_AA___+0x1b6>
					}
				}
			}

			if(j){
  203314:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  203316:	2b00      	cmp	r3, #0
  203318:	d049      	beq.n	2033ae <_DrawArrayBuffRightDown_AA___+0x2d2>
				i=buf[p++];
  20331a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20331c:	1c5a      	adds	r2, r3, #1
  20331e:	637a      	str	r2, [r7, #52]	; 0x34
  203320:	461a      	mov	r2, r3
  203322:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  203324:	4413      	add	r3, r2
  203326:	781b      	ldrb	r3, [r3, #0]
  203328:	63bb      	str	r3, [r7, #56]	; 0x38
				if(*pFill==1){
  20332a:	693b      	ldr	r3, [r7, #16]
  20332c:	781b      	ldrb	r3, [r3, #0]
  20332e:	2b01      	cmp	r3, #1
  203330:	d13d      	bne.n	2033ae <_DrawArrayBuffRightDown_AA___+0x2d2>
					Set_AACoeff_Draw(i,drawColor,inColor,inRatioStart);
  203332:	ed97 0a00 	vldr	s0, [r7]
  203336:	6cba      	ldr	r2, [r7, #72]	; 0x48
  203338:	68f9      	ldr	r1, [r7, #12]
  20333a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  20333c:	f001 fdd6 	bl	204eec <Set_AACoeff_Draw>
					for(int a=0;a<buff_AA[0];++a){
  203340:	2300      	movs	r3, #0
  203342:	62bb      	str	r3, [r7, #40]	; 0x28
  203344:	e025      	b.n	203392 <_DrawArrayBuffRightDown_AA___+0x2b6>
						thershold=LCD_SearchRadiusPoints___(posBuff,k+a*BkpSizeX,*pFill,BkpSizeX);
  203346:	6978      	ldr	r0, [r7, #20]
  203348:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20334a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20334c:	fb02 f203 	mul.w	r2, r2, r3
  203350:	4b13      	ldr	r3, [pc, #76]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203352:	681b      	ldr	r3, [r3, #0]
  203354:	4413      	add	r3, r2
  203356:	4619      	mov	r1, r3
  203358:	693b      	ldr	r3, [r7, #16]
  20335a:	781b      	ldrb	r3, [r3, #0]
  20335c:	461a      	mov	r2, r3
  20335e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203360:	f7ff fce8 	bl	202d34 <LCD_SearchRadiusPoints___>
  203364:	4603      	mov	r3, r0
  203366:	77fb      	strb	r3, [r7, #31]
						if(2==thershold)
  203368:	7ffb      	ldrb	r3, [r7, #31]
  20336a:	2b02      	cmp	r3, #2
  20336c:	d11e      	bne.n	2033ac <_DrawArrayBuffRightDown_AA___+0x2d0>
							pLcd[k+a*BkpSizeX]=buff_AA[1+a];
  20336e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  203370:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  203372:	fb02 f203 	mul.w	r2, r2, r3
  203376:	4b0a      	ldr	r3, [pc, #40]	; (2033a0 <_DrawArrayBuffRightDown_AA___+0x2c4>)
  203378:	681b      	ldr	r3, [r3, #0]
  20337a:	4413      	add	r3, r2
  20337c:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20337e:	3201      	adds	r2, #1
  203380:	4909      	ldr	r1, [pc, #36]	; (2033a8 <_DrawArrayBuffRightDown_AA___+0x2cc>)
  203382:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  203386:	4907      	ldr	r1, [pc, #28]	; (2033a4 <_DrawArrayBuffRightDown_AA___+0x2c8>)
  203388:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					for(int a=0;a<buff_AA[0];++a){
  20338c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20338e:	3301      	adds	r3, #1
  203390:	62bb      	str	r3, [r7, #40]	; 0x28
  203392:	4b05      	ldr	r3, [pc, #20]	; (2033a8 <_DrawArrayBuffRightDown_AA___+0x2cc>)
  203394:	681a      	ldr	r2, [r3, #0]
  203396:	6abb      	ldr	r3, [r7, #40]	; 0x28
  203398:	429a      	cmp	r2, r3
  20339a:	d8d4      	bhi.n	203346 <_DrawArrayBuffRightDown_AA___+0x26a>
  20339c:	e007      	b.n	2033ae <_DrawArrayBuffRightDown_AA___+0x2d2>
  20339e:	bf00      	nop
  2033a0:	20001870 	.word	0x20001870
  2033a4:	c0000000 	.word	0xc0000000
  2033a8:	20001878 	.word	0x20001878
						else break;
  2033ac:	bf00      	nop
					}
			}}
			k++;
  2033ae:	4b26      	ldr	r3, [pc, #152]	; (203448 <_DrawArrayBuffRightDown_AA___+0x36c>)
  2033b0:	681b      	ldr	r3, [r3, #0]
  2033b2:	3301      	adds	r3, #1
  2033b4:	4a24      	ldr	r2, [pc, #144]	; (203448 <_DrawArrayBuffRightDown_AA___+0x36c>)
  2033b6:	6013      	str	r3, [r2, #0]

			if(*pFill==1){
  2033b8:	693b      	ldr	r3, [r7, #16]
  2033ba:	781b      	ldrb	r3, [r3, #0]
  2033bc:	2b01      	cmp	r3, #1
  2033be:	d138      	bne.n	203432 <_DrawArrayBuffRightDown_AA___+0x356>
				Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
  2033c0:	ed97 0a01 	vldr	s0, [r7, #4]
  2033c4:	68ba      	ldr	r2, [r7, #8]
  2033c6:	68f9      	ldr	r1, [r7, #12]
  2033c8:	6a38      	ldr	r0, [r7, #32]
  2033ca:	f001 fd8f 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a){
  2033ce:	2300      	movs	r3, #0
  2033d0:	627b      	str	r3, [r7, #36]	; 0x24
  2033d2:	e029      	b.n	203428 <_DrawArrayBuffRightDown_AA___+0x34c>
					thershold=LCD_SearchRadiusPoints___(posBuff,k-(a+1)*BkpSizeX,*pFill,BkpSizeX);
  2033d4:	6978      	ldr	r0, [r7, #20]
  2033d6:	4b1c      	ldr	r3, [pc, #112]	; (203448 <_DrawArrayBuffRightDown_AA___+0x36c>)
  2033d8:	681a      	ldr	r2, [r3, #0]
  2033da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2033dc:	3301      	adds	r3, #1
  2033de:	4619      	mov	r1, r3
  2033e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2033e2:	fb03 f301 	mul.w	r3, r3, r1
  2033e6:	1ad3      	subs	r3, r2, r3
  2033e8:	4619      	mov	r1, r3
  2033ea:	693b      	ldr	r3, [r7, #16]
  2033ec:	781b      	ldrb	r3, [r3, #0]
  2033ee:	461a      	mov	r2, r3
  2033f0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2033f2:	f7ff fc9f 	bl	202d34 <LCD_SearchRadiusPoints___>
  2033f6:	4603      	mov	r3, r0
  2033f8:	77fb      	strb	r3, [r7, #31]
					if(0==thershold)
  2033fa:	7ffb      	ldrb	r3, [r7, #31]
  2033fc:	2b00      	cmp	r3, #0
  2033fe:	d118      	bne.n	203432 <_DrawArrayBuffRightDown_AA___+0x356>
						pLcd[k-(a+1)*BkpSizeX]=buff_AA[1+a];
  203400:	4b11      	ldr	r3, [pc, #68]	; (203448 <_DrawArrayBuffRightDown_AA___+0x36c>)
  203402:	681a      	ldr	r2, [r3, #0]
  203404:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  203406:	3301      	adds	r3, #1
  203408:	4619      	mov	r1, r3
  20340a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20340c:	fb03 f301 	mul.w	r3, r3, r1
  203410:	1ad3      	subs	r3, r2, r3
  203412:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  203414:	3201      	adds	r2, #1
  203416:	490d      	ldr	r1, [pc, #52]	; (20344c <_DrawArrayBuffRightDown_AA___+0x370>)
  203418:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20341c:	490c      	ldr	r1, [pc, #48]	; (203450 <_DrawArrayBuffRightDown_AA___+0x374>)
  20341e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a){
  203422:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  203424:	3301      	adds	r3, #1
  203426:	627b      	str	r3, [r7, #36]	; 0x24
  203428:	4b08      	ldr	r3, [pc, #32]	; (20344c <_DrawArrayBuffRightDown_AA___+0x370>)
  20342a:	681a      	ldr	r2, [r3, #0]
  20342c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20342e:	429a      	cmp	r2, r3
  203430:	d8d0      	bhi.n	2033d4 <_DrawArrayBuffRightDown_AA___+0x2f8>
		while(j--)
  203432:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  203434:	1e5a      	subs	r2, r3, #1
  203436:	63fa      	str	r2, [r7, #60]	; 0x3c
  203438:	2b00      	cmp	r3, #0
  20343a:	f47f af27 	bne.w	20328c <_DrawArrayBuffRightDown_AA___+0x1b0>
					else break;
				}
			}
		}
	}
	return 0;
  20343e:	2300      	movs	r3, #0
}
  203440:	4618      	mov	r0, r3
  203442:	3740      	adds	r7, #64	; 0x40
  203444:	46bd      	mov	sp, r7
  203446:	bd80      	pop	{r7, pc}
  203448:	20001870 	.word	0x20001870
  20344c:	20001878 	.word	0x20001878
  203450:	c0000000 	.word	0xc0000000

00203454 <_DrawArrayBuffLeftDown_AA___>:

static uint8_t _DrawArrayBuffLeftDown_AA___(uint32_t posBuff, uint8_t *pFill, uint32_t drawColor, uint32_t outColor, uint32_t inColor, float outRatioStart, float inRatioStart, uint32_t BkpSizeX, int direction, uint8_t *buf)
{
  203454:	b580      	push	{r7, lr}
  203456:	b090      	sub	sp, #64	; 0x40
  203458:	af00      	add	r7, sp, #0
  20345a:	6178      	str	r0, [r7, #20]
  20345c:	6139      	str	r1, [r7, #16]
  20345e:	60fa      	str	r2, [r7, #12]
  203460:	60bb      	str	r3, [r7, #8]
  203462:	ed87 0a01 	vstr	s0, [r7, #4]
  203466:	edc7 0a00 	vstr	s1, [r7]
	int j=buf[0], i=buf[1], p=2, i_prev;
  20346a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20346c:	781b      	ldrb	r3, [r3, #0]
  20346e:	63fb      	str	r3, [r7, #60]	; 0x3c
  203470:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  203472:	3301      	adds	r3, #1
  203474:	781b      	ldrb	r3, [r3, #0]
  203476:	63bb      	str	r3, [r7, #56]	; 0x38
  203478:	2302      	movs	r3, #2
  20347a:	637b      	str	r3, [r7, #52]	; 0x34
	uint8_t thershold;

	if(0==direction)
  20347c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20347e:	2b00      	cmp	r3, #0
  203480:	f040 813b 	bne.w	2036fa <_DrawArrayBuffLeftDown_AA___+0x2a6>
	{
		while(j--)
  203484:	e092      	b.n	2035ac <_DrawArrayBuffLeftDown_AA___+0x158>
		{
			i_prev=i;
  203486:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  203488:	623b      	str	r3, [r7, #32]
			while(i--){
  20348a:	e034      	b.n	2034f6 <_DrawArrayBuffLeftDown_AA___+0xa2>
				thershold=LCD_SearchRadiusPoints(posBuff,*pFill,BkpSizeX);
  20348c:	6978      	ldr	r0, [r7, #20]
  20348e:	693b      	ldr	r3, [r7, #16]
  203490:	781b      	ldrb	r3, [r3, #0]
  203492:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  203494:	4619      	mov	r1, r3
  203496:	f7ff fa7b 	bl	202990 <LCD_SearchRadiusPoints>
  20349a:	4603      	mov	r3, r0
  20349c:	77fb      	strb	r3, [r7, #31]
				if((0==thershold)||(1==thershold)){
  20349e:	7ffb      	ldrb	r3, [r7, #31]
  2034a0:	2b00      	cmp	r3, #0
  2034a2:	d002      	beq.n	2034aa <_DrawArrayBuffLeftDown_AA___+0x56>
  2034a4:	7ffb      	ldrb	r3, [r7, #31]
  2034a6:	2b01      	cmp	r3, #1
  2034a8:	d112      	bne.n	2034d0 <_DrawArrayBuffLeftDown_AA___+0x7c>
					if(*pFill==0) *pFill=1;
  2034aa:	693b      	ldr	r3, [r7, #16]
  2034ac:	781b      	ldrb	r3, [r3, #0]
  2034ae:	2b00      	cmp	r3, #0
  2034b0:	d10c      	bne.n	2034cc <_DrawArrayBuffLeftDown_AA___+0x78>
  2034b2:	693b      	ldr	r3, [r7, #16]
  2034b4:	2201      	movs	r2, #1
  2034b6:	701a      	strb	r2, [r3, #0]
					else return 1;
					pLcd[k--]=drawColor;
  2034b8:	4b95      	ldr	r3, [pc, #596]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2034ba:	681b      	ldr	r3, [r3, #0]
  2034bc:	1e5a      	subs	r2, r3, #1
  2034be:	4994      	ldr	r1, [pc, #592]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2034c0:	600a      	str	r2, [r1, #0]
  2034c2:	4994      	ldr	r1, [pc, #592]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  2034c4:	68fa      	ldr	r2, [r7, #12]
  2034c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  2034ca:	e014      	b.n	2034f6 <_DrawArrayBuffLeftDown_AA___+0xa2>
					else return 1;
  2034cc:	2301      	movs	r3, #1
  2034ce:	e11b      	b.n	203708 <_DrawArrayBuffLeftDown_AA___+0x2b4>
				}
				else{
					if(*pFill==0)
  2034d0:	693b      	ldr	r3, [r7, #16]
  2034d2:	781b      	ldrb	r3, [r3, #0]
  2034d4:	2b00      	cmp	r3, #0
  2034d6:	d105      	bne.n	2034e4 <_DrawArrayBuffLeftDown_AA___+0x90>
						k--;
  2034d8:	4b8d      	ldr	r3, [pc, #564]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2034da:	681b      	ldr	r3, [r3, #0]
  2034dc:	3b01      	subs	r3, #1
  2034de:	4a8c      	ldr	r2, [pc, #560]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2034e0:	6013      	str	r3, [r2, #0]
  2034e2:	e008      	b.n	2034f6 <_DrawArrayBuffLeftDown_AA___+0xa2>
					else
						pLcd[k--]=drawColor;
  2034e4:	4b8a      	ldr	r3, [pc, #552]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2034e6:	681b      	ldr	r3, [r3, #0]
  2034e8:	1e5a      	subs	r2, r3, #1
  2034ea:	4989      	ldr	r1, [pc, #548]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2034ec:	600a      	str	r2, [r1, #0]
  2034ee:	4989      	ldr	r1, [pc, #548]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  2034f0:	68fa      	ldr	r2, [r7, #12]
  2034f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			while(i--){
  2034f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2034f8:	1e5a      	subs	r2, r3, #1
  2034fa:	63ba      	str	r2, [r7, #56]	; 0x38
  2034fc:	2b00      	cmp	r3, #0
  2034fe:	d1c5      	bne.n	20348c <_DrawArrayBuffLeftDown_AA___+0x38>
				}
			}

			if(j){
  203500:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  203502:	2b00      	cmp	r3, #0
  203504:	d029      	beq.n	20355a <_DrawArrayBuffLeftDown_AA___+0x106>
				i=buf[p++];
  203506:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  203508:	1c5a      	adds	r2, r3, #1
  20350a:	637a      	str	r2, [r7, #52]	; 0x34
  20350c:	461a      	mov	r2, r3
  20350e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  203510:	4413      	add	r3, r2
  203512:	781b      	ldrb	r3, [r3, #0]
  203514:	63bb      	str	r3, [r7, #56]	; 0x38
				if(*pFill==1){
  203516:	693b      	ldr	r3, [r7, #16]
  203518:	781b      	ldrb	r3, [r3, #0]
  20351a:	2b01      	cmp	r3, #1
  20351c:	d11d      	bne.n	20355a <_DrawArrayBuffLeftDown_AA___+0x106>
					Set_AACoeff_Draw(i,drawColor,inColor,inRatioStart);
  20351e:	ed97 0a00 	vldr	s0, [r7]
  203522:	6cba      	ldr	r2, [r7, #72]	; 0x48
  203524:	68f9      	ldr	r1, [r7, #12]
  203526:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  203528:	f001 fce0 	bl	204eec <Set_AACoeff_Draw>
					for(int a=0;a<buff_AA[0];++a)
  20352c:	2300      	movs	r3, #0
  20352e:	633b      	str	r3, [r7, #48]	; 0x30
  203530:	e00e      	b.n	203550 <_DrawArrayBuffLeftDown_AA___+0xfc>
						pLcd[k-a]=buff_AA[1+a];
  203532:	4b77      	ldr	r3, [pc, #476]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203534:	681a      	ldr	r2, [r3, #0]
  203536:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  203538:	1ad3      	subs	r3, r2, r3
  20353a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  20353c:	3201      	adds	r2, #1
  20353e:	4976      	ldr	r1, [pc, #472]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  203540:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  203544:	4973      	ldr	r1, [pc, #460]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  203546:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					for(int a=0;a<buff_AA[0];++a)
  20354a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20354c:	3301      	adds	r3, #1
  20354e:	633b      	str	r3, [r7, #48]	; 0x30
  203550:	4b71      	ldr	r3, [pc, #452]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  203552:	681a      	ldr	r2, [r3, #0]
  203554:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  203556:	429a      	cmp	r2, r3
  203558:	d8eb      	bhi.n	203532 <_DrawArrayBuffLeftDown_AA___+0xde>
			}}
			k+=BkpSizeX;
  20355a:	4b6d      	ldr	r3, [pc, #436]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  20355c:	681a      	ldr	r2, [r3, #0]
  20355e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203560:	4413      	add	r3, r2
  203562:	4a6b      	ldr	r2, [pc, #428]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203564:	6013      	str	r3, [r2, #0]

			if(*pFill==1){
  203566:	693b      	ldr	r3, [r7, #16]
  203568:	781b      	ldrb	r3, [r3, #0]
  20356a:	2b01      	cmp	r3, #1
  20356c:	d11e      	bne.n	2035ac <_DrawArrayBuffLeftDown_AA___+0x158>
				Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
  20356e:	ed97 0a01 	vldr	s0, [r7, #4]
  203572:	68ba      	ldr	r2, [r7, #8]
  203574:	68f9      	ldr	r1, [r7, #12]
  203576:	6a38      	ldr	r0, [r7, #32]
  203578:	f001 fcb8 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  20357c:	2300      	movs	r3, #0
  20357e:	62fb      	str	r3, [r7, #44]	; 0x2c
  203580:	e00f      	b.n	2035a2 <_DrawArrayBuffLeftDown_AA___+0x14e>
					pLcd[k+1+a]=buff_AA[1+a];
  203582:	4b63      	ldr	r3, [pc, #396]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203584:	681a      	ldr	r2, [r3, #0]
  203586:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203588:	4413      	add	r3, r2
  20358a:	3301      	adds	r3, #1
  20358c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  20358e:	3201      	adds	r2, #1
  203590:	4961      	ldr	r1, [pc, #388]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  203592:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  203596:	495f      	ldr	r1, [pc, #380]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  203598:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  20359c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20359e:	3301      	adds	r3, #1
  2035a0:	62fb      	str	r3, [r7, #44]	; 0x2c
  2035a2:	4b5d      	ldr	r3, [pc, #372]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  2035a4:	681a      	ldr	r2, [r3, #0]
  2035a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2035a8:	429a      	cmp	r2, r3
  2035aa:	d8ea      	bhi.n	203582 <_DrawArrayBuffLeftDown_AA___+0x12e>
		while(j--)
  2035ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2035ae:	1e5a      	subs	r2, r3, #1
  2035b0:	63fa      	str	r2, [r7, #60]	; 0x3c
  2035b2:	2b00      	cmp	r3, #0
  2035b4:	f47f af67 	bne.w	203486 <_DrawArrayBuffLeftDown_AA___+0x32>
  2035b8:	e0a5      	b.n	203706 <_DrawArrayBuffLeftDown_AA___+0x2b2>
	}
	else
	{
		while(j--)
		{
			i_prev=i;
  2035ba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2035bc:	623b      	str	r3, [r7, #32]
			while(i--){
  2035be:	e03b      	b.n	203638 <_DrawArrayBuffLeftDown_AA___+0x1e4>
				thershold=LCD_SearchRadiusPoints(posBuff,*pFill,BkpSizeX);
  2035c0:	6978      	ldr	r0, [r7, #20]
  2035c2:	693b      	ldr	r3, [r7, #16]
  2035c4:	781b      	ldrb	r3, [r3, #0]
  2035c6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  2035c8:	4619      	mov	r1, r3
  2035ca:	f7ff f9e1 	bl	202990 <LCD_SearchRadiusPoints>
  2035ce:	4603      	mov	r3, r0
  2035d0:	77fb      	strb	r3, [r7, #31]
				if((0==thershold)||(1==thershold)){
  2035d2:	7ffb      	ldrb	r3, [r7, #31]
  2035d4:	2b00      	cmp	r3, #0
  2035d6:	d002      	beq.n	2035de <_DrawArrayBuffLeftDown_AA___+0x18a>
  2035d8:	7ffb      	ldrb	r3, [r7, #31]
  2035da:	2b01      	cmp	r3, #1
  2035dc:	d115      	bne.n	20360a <_DrawArrayBuffLeftDown_AA___+0x1b6>
					if(*pFill==0) *pFill=1;
  2035de:	693b      	ldr	r3, [r7, #16]
  2035e0:	781b      	ldrb	r3, [r3, #0]
  2035e2:	2b00      	cmp	r3, #0
  2035e4:	d10f      	bne.n	203606 <_DrawArrayBuffLeftDown_AA___+0x1b2>
  2035e6:	693b      	ldr	r3, [r7, #16]
  2035e8:	2201      	movs	r2, #1
  2035ea:	701a      	strb	r2, [r3, #0]
					else return 1;
					pLcd[k]=drawColor;
  2035ec:	4b48      	ldr	r3, [pc, #288]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2035ee:	681b      	ldr	r3, [r3, #0]
  2035f0:	4948      	ldr	r1, [pc, #288]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  2035f2:	68fa      	ldr	r2, [r7, #12]
  2035f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					k+=BkpSizeX;
  2035f8:	4b45      	ldr	r3, [pc, #276]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2035fa:	681a      	ldr	r2, [r3, #0]
  2035fc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2035fe:	4413      	add	r3, r2
  203600:	4a43      	ldr	r2, [pc, #268]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203602:	6013      	str	r3, [r2, #0]
  203604:	e018      	b.n	203638 <_DrawArrayBuffLeftDown_AA___+0x1e4>
					else return 1;
  203606:	2301      	movs	r3, #1
  203608:	e07e      	b.n	203708 <_DrawArrayBuffLeftDown_AA___+0x2b4>
				}
				else{
					if(*pFill==0)
  20360a:	693b      	ldr	r3, [r7, #16]
  20360c:	781b      	ldrb	r3, [r3, #0]
  20360e:	2b00      	cmp	r3, #0
  203610:	d106      	bne.n	203620 <_DrawArrayBuffLeftDown_AA___+0x1cc>
						k+=BkpSizeX;
  203612:	4b3f      	ldr	r3, [pc, #252]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203614:	681a      	ldr	r2, [r3, #0]
  203616:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203618:	4413      	add	r3, r2
  20361a:	4a3d      	ldr	r2, [pc, #244]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  20361c:	6013      	str	r3, [r2, #0]
  20361e:	e00b      	b.n	203638 <_DrawArrayBuffLeftDown_AA___+0x1e4>
					else{
						pLcd[k]=drawColor;
  203620:	4b3b      	ldr	r3, [pc, #236]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203622:	681b      	ldr	r3, [r3, #0]
  203624:	493b      	ldr	r1, [pc, #236]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  203626:	68fa      	ldr	r2, [r7, #12]
  203628:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
						k+=BkpSizeX;
  20362c:	4b38      	ldr	r3, [pc, #224]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  20362e:	681a      	ldr	r2, [r3, #0]
  203630:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203632:	4413      	add	r3, r2
  203634:	4a36      	ldr	r2, [pc, #216]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  203636:	6013      	str	r3, [r2, #0]
			while(i--){
  203638:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20363a:	1e5a      	subs	r2, r3, #1
  20363c:	63ba      	str	r2, [r7, #56]	; 0x38
  20363e:	2b00      	cmp	r3, #0
  203640:	d1be      	bne.n	2035c0 <_DrawArrayBuffLeftDown_AA___+0x16c>
					}
				}
			}

			if(j){
  203642:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  203644:	2b00      	cmp	r3, #0
  203646:	d02c      	beq.n	2036a2 <_DrawArrayBuffLeftDown_AA___+0x24e>
				i=buf[p++];
  203648:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20364a:	1c5a      	adds	r2, r3, #1
  20364c:	637a      	str	r2, [r7, #52]	; 0x34
  20364e:	461a      	mov	r2, r3
  203650:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  203652:	4413      	add	r3, r2
  203654:	781b      	ldrb	r3, [r3, #0]
  203656:	63bb      	str	r3, [r7, #56]	; 0x38
				if(*pFill==1){
  203658:	693b      	ldr	r3, [r7, #16]
  20365a:	781b      	ldrb	r3, [r3, #0]
  20365c:	2b01      	cmp	r3, #1
  20365e:	d120      	bne.n	2036a2 <_DrawArrayBuffLeftDown_AA___+0x24e>
					Set_AACoeff_Draw(i,drawColor,outColor,outRatioStart);
  203660:	ed97 0a01 	vldr	s0, [r7, #4]
  203664:	68ba      	ldr	r2, [r7, #8]
  203666:	68f9      	ldr	r1, [r7, #12]
  203668:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  20366a:	f001 fc3f 	bl	204eec <Set_AACoeff_Draw>
					for(int a=0;a<buff_AA[0];++a)
  20366e:	2300      	movs	r3, #0
  203670:	62bb      	str	r3, [r7, #40]	; 0x28
  203672:	e011      	b.n	203698 <_DrawArrayBuffLeftDown_AA___+0x244>
						pLcd[k+a*BkpSizeX]=buff_AA[1+a];
  203674:	6abb      	ldr	r3, [r7, #40]	; 0x28
  203676:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  203678:	fb02 f203 	mul.w	r2, r2, r3
  20367c:	4b24      	ldr	r3, [pc, #144]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  20367e:	681b      	ldr	r3, [r3, #0]
  203680:	4413      	add	r3, r2
  203682:	6aba      	ldr	r2, [r7, #40]	; 0x28
  203684:	3201      	adds	r2, #1
  203686:	4924      	ldr	r1, [pc, #144]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  203688:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20368c:	4921      	ldr	r1, [pc, #132]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  20368e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					for(int a=0;a<buff_AA[0];++a)
  203692:	6abb      	ldr	r3, [r7, #40]	; 0x28
  203694:	3301      	adds	r3, #1
  203696:	62bb      	str	r3, [r7, #40]	; 0x28
  203698:	4b1f      	ldr	r3, [pc, #124]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  20369a:	681a      	ldr	r2, [r3, #0]
  20369c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20369e:	429a      	cmp	r2, r3
  2036a0:	d8e8      	bhi.n	203674 <_DrawArrayBuffLeftDown_AA___+0x220>
			}}
			k--;
  2036a2:	4b1b      	ldr	r3, [pc, #108]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2036a4:	681b      	ldr	r3, [r3, #0]
  2036a6:	3b01      	subs	r3, #1
  2036a8:	4a19      	ldr	r2, [pc, #100]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2036aa:	6013      	str	r3, [r2, #0]

			if(*pFill==1){
  2036ac:	693b      	ldr	r3, [r7, #16]
  2036ae:	781b      	ldrb	r3, [r3, #0]
  2036b0:	2b01      	cmp	r3, #1
  2036b2:	d122      	bne.n	2036fa <_DrawArrayBuffLeftDown_AA___+0x2a6>
				Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
  2036b4:	ed97 0a00 	vldr	s0, [r7]
  2036b8:	6cba      	ldr	r2, [r7, #72]	; 0x48
  2036ba:	68f9      	ldr	r1, [r7, #12]
  2036bc:	6a38      	ldr	r0, [r7, #32]
  2036be:	f001 fc15 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  2036c2:	2300      	movs	r3, #0
  2036c4:	627b      	str	r3, [r7, #36]	; 0x24
  2036c6:	e013      	b.n	2036f0 <_DrawArrayBuffLeftDown_AA___+0x29c>
					pLcd[k-(a+1)*BkpSizeX]=buff_AA[1+a];
  2036c8:	4b11      	ldr	r3, [pc, #68]	; (203710 <_DrawArrayBuffLeftDown_AA___+0x2bc>)
  2036ca:	681a      	ldr	r2, [r3, #0]
  2036cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2036ce:	3301      	adds	r3, #1
  2036d0:	4619      	mov	r1, r3
  2036d2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2036d4:	fb03 f301 	mul.w	r3, r3, r1
  2036d8:	1ad3      	subs	r3, r2, r3
  2036da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2036dc:	3201      	adds	r2, #1
  2036de:	490e      	ldr	r1, [pc, #56]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  2036e0:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2036e4:	490b      	ldr	r1, [pc, #44]	; (203714 <_DrawArrayBuffLeftDown_AA___+0x2c0>)
  2036e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  2036ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2036ec:	3301      	adds	r3, #1
  2036ee:	627b      	str	r3, [r7, #36]	; 0x24
  2036f0:	4b09      	ldr	r3, [pc, #36]	; (203718 <_DrawArrayBuffLeftDown_AA___+0x2c4>)
  2036f2:	681a      	ldr	r2, [r3, #0]
  2036f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2036f6:	429a      	cmp	r2, r3
  2036f8:	d8e6      	bhi.n	2036c8 <_DrawArrayBuffLeftDown_AA___+0x274>
		while(j--)
  2036fa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2036fc:	1e5a      	subs	r2, r3, #1
  2036fe:	63fa      	str	r2, [r7, #60]	; 0x3c
  203700:	2b00      	cmp	r3, #0
  203702:	f47f af5a 	bne.w	2035ba <_DrawArrayBuffLeftDown_AA___+0x166>
			}
		}
	}
	return 0;
  203706:	2300      	movs	r3, #0
}
  203708:	4618      	mov	r0, r3
  20370a:	3740      	adds	r7, #64	; 0x40
  20370c:	46bd      	mov	sp, r7
  20370e:	bd80      	pop	{r7, pc}
  203710:	20001870 	.word	0x20001870
  203714:	c0000000 	.word	0xc0000000
  203718:	20001878 	.word	0x20001878

0020371c <_Fill.11620>:
			else
				DrawLine(0,Circle.x0,Circle.y0,(Circle.width-4-circleLinesLenCorrect)/2-1,Circle.degree[1+i],FrameColor,BkpSizeX, Circle.outRatioStart,Circle.inRatioStart,Circle.degColor[i],Circle.degColor[i+1]);
		}

		void _Fill(int width)
		{
  20371c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  203720:	b08b      	sub	sp, #44	; 0x2c
  203722:	af00      	add	r7, sp, #0
  203724:	6078      	str	r0, [r7, #4]
  203726:	46e0      	mov	r8, ip
  203728:	f8c7 c000 	str.w	ip, [r7]
  20372c:	4668      	mov	r0, sp
  20372e:	4681      	mov	r9, r0
			int j=width;
  203730:	6878      	ldr	r0, [r7, #4]
  203732:	6278      	str	r0, [r7, #36]	; 0x24
			uint8_t threshold[Circle.degree[0]];
  203734:	4876      	ldr	r0, [pc, #472]	; (203910 <_Fill.11620+0x1f4>)
  203736:	f8b0 020c 	ldrh.w	r0, [r0, #524]	; 0x20c
  20373a:	4605      	mov	r5, r0
  20373c:	3d01      	subs	r5, #1
  20373e:	617d      	str	r5, [r7, #20]
  203740:	b285      	uxth	r5, r0
  203742:	f04f 0600 	mov.w	r6, #0
  203746:	00f2      	lsls	r2, r6, #3
  203748:	ea42 7255 	orr.w	r2, r2, r5, lsr #29
  20374c:	00e9      	lsls	r1, r5, #3
  20374e:	b281      	uxth	r1, r0
  203750:	f04f 0200 	mov.w	r2, #0
  203754:	00d4      	lsls	r4, r2, #3
  203756:	ea44 7451 	orr.w	r4, r4, r1, lsr #29
  20375a:	00cb      	lsls	r3, r1, #3
  20375c:	4603      	mov	r3, r0
  20375e:	3307      	adds	r3, #7
  203760:	08db      	lsrs	r3, r3, #3
  203762:	00db      	lsls	r3, r3, #3
  203764:	ebad 0d03 	sub.w	sp, sp, r3
  203768:	466b      	mov	r3, sp
  20376a:	3300      	adds	r3, #0
  20376c:	613b      	str	r3, [r7, #16]
			int subj=0, deltaDeg;
  20376e:	2300      	movs	r3, #0
  203770:	623b      	str	r3, [r7, #32]

			while(j--)
  203772:	e0c1      	b.n	2038f8 <_Fill.11620+0x1dc>
			{
				if(pLcd[k]==FillColor){
  203774:	4b67      	ldr	r3, [pc, #412]	; (203914 <_Fill.11620+0x1f8>)
  203776:	681b      	ldr	r3, [r3, #0]
  203778:	4a67      	ldr	r2, [pc, #412]	; (203918 <_Fill.11620+0x1fc>)
  20377a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  20377e:	f8d8 300c 	ldr.w	r3, [r8, #12]
  203782:	429a      	cmp	r2, r3
  203784:	d11c      	bne.n	2037c0 <_Fill.11620+0xa4>
					for(int i=0;i<Circle.degree[0];++i)
  203786:	2300      	movs	r3, #0
  203788:	61fb      	str	r3, [r7, #28]
  20378a:	e012      	b.n	2037b2 <_Fill.11620+0x96>
						threshold[i]=LCD_SearchRadiusPoints(posBuff,i,bkX);
  20378c:	f8d8 3008 	ldr.w	r3, [r8, #8]
  203790:	4618      	mov	r0, r3
  203792:	f8d8 3004 	ldr.w	r3, [r8, #4]
  203796:	461a      	mov	r2, r3
  203798:	69f9      	ldr	r1, [r7, #28]
  20379a:	f7ff f8f9 	bl	202990 <LCD_SearchRadiusPoints>
  20379e:	4603      	mov	r3, r0
  2037a0:	4619      	mov	r1, r3
  2037a2:	693a      	ldr	r2, [r7, #16]
  2037a4:	69fb      	ldr	r3, [r7, #28]
  2037a6:	4413      	add	r3, r2
  2037a8:	460a      	mov	r2, r1
  2037aa:	701a      	strb	r2, [r3, #0]
					for(int i=0;i<Circle.degree[0];++i)
  2037ac:	69fb      	ldr	r3, [r7, #28]
  2037ae:	3301      	adds	r3, #1
  2037b0:	61fb      	str	r3, [r7, #28]
  2037b2:	4b57      	ldr	r3, [pc, #348]	; (203910 <_Fill.11620+0x1f4>)
  2037b4:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  2037b8:	461a      	mov	r2, r3
  2037ba:	69fb      	ldr	r3, [r7, #28]
  2037bc:	429a      	cmp	r2, r3
  2037be:	dce5      	bgt.n	20378c <_Fill.11620+0x70>
				}

				GOTO_ToFillCircle:
				if(pLcd[k]==FillColor)
  2037c0:	4b54      	ldr	r3, [pc, #336]	; (203914 <_Fill.11620+0x1f8>)
  2037c2:	681b      	ldr	r3, [r3, #0]
  2037c4:	4a54      	ldr	r2, [pc, #336]	; (203918 <_Fill.11620+0x1fc>)
  2037c6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  2037ca:	f8d8 300c 	ldr.w	r3, [r8, #12]
  2037ce:	429a      	cmp	r2, r3
  2037d0:	d163      	bne.n	20389a <_Fill.11620+0x17e>
				{
					for(int i=0;i<Circle.degree[0]-1;++i)
  2037d2:	2300      	movs	r3, #0
  2037d4:	61bb      	str	r3, [r7, #24]
  2037d6:	e052      	b.n	20387e <_Fill.11620+0x162>
					{
						deltaDeg=Circle.degree[1+i+1]-Circle.degree[1+i];
  2037d8:	69bb      	ldr	r3, [r7, #24]
  2037da:	3302      	adds	r3, #2
  2037dc:	4a4c      	ldr	r2, [pc, #304]	; (203910 <_Fill.11620+0x1f4>)
  2037de:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2037e2:	005b      	lsls	r3, r3, #1
  2037e4:	4413      	add	r3, r2
  2037e6:	889b      	ldrh	r3, [r3, #4]
  2037e8:	4619      	mov	r1, r3
  2037ea:	69bb      	ldr	r3, [r7, #24]
  2037ec:	3301      	adds	r3, #1
  2037ee:	4a48      	ldr	r2, [pc, #288]	; (203910 <_Fill.11620+0x1f4>)
  2037f0:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2037f4:	005b      	lsls	r3, r3, #1
  2037f6:	4413      	add	r3, r2
  2037f8:	889b      	ldrh	r3, [r3, #4]
  2037fa:	1acb      	subs	r3, r1, r3
  2037fc:	60fb      	str	r3, [r7, #12]
						if( ((deltaDeg>0)&&(deltaDeg<=180)) || (deltaDeg<-180) ){
  2037fe:	68fb      	ldr	r3, [r7, #12]
  203800:	2b00      	cmp	r3, #0
  203802:	dd02      	ble.n	20380a <_Fill.11620+0xee>
  203804:	68fb      	ldr	r3, [r7, #12]
  203806:	2bb4      	cmp	r3, #180	; 0xb4
  203808:	dd03      	ble.n	203812 <_Fill.11620+0xf6>
  20380a:	68fb      	ldr	r3, [r7, #12]
  20380c:	f113 0fb4 	cmn.w	r3, #180	; 0xb4
  203810:	da18      	bge.n	203844 <_Fill.11620+0x128>
							if((threshold[i]==0)&&(threshold[i+1]==2)){
  203812:	693a      	ldr	r2, [r7, #16]
  203814:	69bb      	ldr	r3, [r7, #24]
  203816:	4413      	add	r3, r2
  203818:	781b      	ldrb	r3, [r3, #0]
  20381a:	2b00      	cmp	r3, #0
  20381c:	d12b      	bne.n	203876 <_Fill.11620+0x15a>
  20381e:	69bb      	ldr	r3, [r7, #24]
  203820:	3301      	adds	r3, #1
  203822:	693a      	ldr	r2, [r7, #16]
  203824:	5cd3      	ldrb	r3, [r2, r3]
  203826:	2b02      	cmp	r3, #2
  203828:	d125      	bne.n	203876 <_Fill.11620+0x15a>
								pLcd[k]=Circle.degColor[1+i];
  20382a:	4b3a      	ldr	r3, [pc, #232]	; (203914 <_Fill.11620+0x1f8>)
  20382c:	681a      	ldr	r2, [r3, #0]
  20382e:	69bb      	ldr	r3, [r7, #24]
  203830:	3301      	adds	r3, #1
  203832:	4937      	ldr	r1, [pc, #220]	; (203910 <_Fill.11620+0x1f4>)
  203834:	3388      	adds	r3, #136	; 0x88
  203836:	009b      	lsls	r3, r3, #2
  203838:	440b      	add	r3, r1
  20383a:	685b      	ldr	r3, [r3, #4]
  20383c:	4936      	ldr	r1, [pc, #216]	; (203918 <_Fill.11620+0x1fc>)
  20383e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
								break;
  203842:	e023      	b.n	20388c <_Fill.11620+0x170>
							}
						}
						else{
							if((threshold[i]==0)||(threshold[i+1]==2)){
  203844:	693a      	ldr	r2, [r7, #16]
  203846:	69bb      	ldr	r3, [r7, #24]
  203848:	4413      	add	r3, r2
  20384a:	781b      	ldrb	r3, [r3, #0]
  20384c:	2b00      	cmp	r3, #0
  20384e:	d005      	beq.n	20385c <_Fill.11620+0x140>
  203850:	69bb      	ldr	r3, [r7, #24]
  203852:	3301      	adds	r3, #1
  203854:	693a      	ldr	r2, [r7, #16]
  203856:	5cd3      	ldrb	r3, [r2, r3]
  203858:	2b02      	cmp	r3, #2
  20385a:	d10d      	bne.n	203878 <_Fill.11620+0x15c>
								pLcd[k]=Circle.degColor[1+i];
  20385c:	4b2d      	ldr	r3, [pc, #180]	; (203914 <_Fill.11620+0x1f8>)
  20385e:	681a      	ldr	r2, [r3, #0]
  203860:	69bb      	ldr	r3, [r7, #24]
  203862:	3301      	adds	r3, #1
  203864:	492a      	ldr	r1, [pc, #168]	; (203910 <_Fill.11620+0x1f4>)
  203866:	3388      	adds	r3, #136	; 0x88
  203868:	009b      	lsls	r3, r3, #2
  20386a:	440b      	add	r3, r1
  20386c:	685b      	ldr	r3, [r3, #4]
  20386e:	492a      	ldr	r1, [pc, #168]	; (203918 <_Fill.11620+0x1fc>)
  203870:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
								break;
  203874:	e00a      	b.n	20388c <_Fill.11620+0x170>
							if((threshold[i]==0)&&(threshold[i+1]==2)){
  203876:	bf00      	nop
					for(int i=0;i<Circle.degree[0]-1;++i)
  203878:	69bb      	ldr	r3, [r7, #24]
  20387a:	3301      	adds	r3, #1
  20387c:	61bb      	str	r3, [r7, #24]
  20387e:	4b24      	ldr	r3, [pc, #144]	; (203910 <_Fill.11620+0x1f4>)
  203880:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  203884:	1e5a      	subs	r2, r3, #1
  203886:	69bb      	ldr	r3, [r7, #24]
  203888:	429a      	cmp	r2, r3
  20388a:	dca5      	bgt.n	2037d8 <_Fill.11620+0xbc>
							}
						}
					}
					k++; subj=1;
  20388c:	4b21      	ldr	r3, [pc, #132]	; (203914 <_Fill.11620+0x1f8>)
  20388e:	681b      	ldr	r3, [r3, #0]
  203890:	3301      	adds	r3, #1
  203892:	4a20      	ldr	r2, [pc, #128]	; (203914 <_Fill.11620+0x1f8>)
  203894:	6013      	str	r3, [r2, #0]
  203896:	2301      	movs	r3, #1
  203898:	623b      	str	r3, [r7, #32]
				}
				if(pLcd[k]==FillColor){ if(j==0){ k--; break; } j--; subj=0; goto GOTO_ToFillCircle; }
  20389a:	4b1e      	ldr	r3, [pc, #120]	; (203914 <_Fill.11620+0x1f8>)
  20389c:	681b      	ldr	r3, [r3, #0]
  20389e:	4a1e      	ldr	r2, [pc, #120]	; (203918 <_Fill.11620+0x1fc>)
  2038a0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  2038a4:	f8d8 300c 	ldr.w	r3, [r8, #12]
  2038a8:	429a      	cmp	r2, r3
  2038aa:	d10e      	bne.n	2038ca <_Fill.11620+0x1ae>
  2038ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2038ae:	2b00      	cmp	r3, #0
  2038b0:	d105      	bne.n	2038be <_Fill.11620+0x1a2>
  2038b2:	4b18      	ldr	r3, [pc, #96]	; (203914 <_Fill.11620+0x1f8>)
  2038b4:	681b      	ldr	r3, [r3, #0]
  2038b6:	3b01      	subs	r3, #1
  2038b8:	4a16      	ldr	r2, [pc, #88]	; (203914 <_Fill.11620+0x1f8>)
  2038ba:	6013      	str	r3, [r2, #0]
  2038bc:	e022      	b.n	203904 <_Fill.11620+0x1e8>
  2038be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2038c0:	3b01      	subs	r3, #1
  2038c2:	627b      	str	r3, [r7, #36]	; 0x24
  2038c4:	2300      	movs	r3, #0
  2038c6:	623b      	str	r3, [r7, #32]
  2038c8:	e77a      	b.n	2037c0 <_Fill.11620+0xa4>
				k++;
  2038ca:	4b12      	ldr	r3, [pc, #72]	; (203914 <_Fill.11620+0x1f8>)
  2038cc:	681b      	ldr	r3, [r3, #0]
  2038ce:	3301      	adds	r3, #1
  2038d0:	4a10      	ldr	r2, [pc, #64]	; (203914 <_Fill.11620+0x1f8>)
  2038d2:	6013      	str	r3, [r2, #0]
				if(subj==1){ subj=0; if(j>0) j--; else{ k--; break; }}
  2038d4:	6a3b      	ldr	r3, [r7, #32]
  2038d6:	2b01      	cmp	r3, #1
  2038d8:	d10e      	bne.n	2038f8 <_Fill.11620+0x1dc>
  2038da:	2300      	movs	r3, #0
  2038dc:	623b      	str	r3, [r7, #32]
  2038de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2038e0:	2b00      	cmp	r3, #0
  2038e2:	dd03      	ble.n	2038ec <_Fill.11620+0x1d0>
  2038e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2038e6:	3b01      	subs	r3, #1
  2038e8:	627b      	str	r3, [r7, #36]	; 0x24
  2038ea:	e005      	b.n	2038f8 <_Fill.11620+0x1dc>
  2038ec:	4b09      	ldr	r3, [pc, #36]	; (203914 <_Fill.11620+0x1f8>)
  2038ee:	681b      	ldr	r3, [r3, #0]
  2038f0:	3b01      	subs	r3, #1
  2038f2:	4a08      	ldr	r2, [pc, #32]	; (203914 <_Fill.11620+0x1f8>)
  2038f4:	6013      	str	r3, [r2, #0]
  2038f6:	e005      	b.n	203904 <_Fill.11620+0x1e8>
			while(j--)
  2038f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2038fa:	1e5a      	subs	r2, r3, #1
  2038fc:	627a      	str	r2, [r7, #36]	; 0x24
  2038fe:	2b00      	cmp	r3, #0
  203900:	f47f af38 	bne.w	203774 <_Fill.11620+0x58>
  203904:	46cd      	mov	sp, r9
			}
		}
  203906:	bf00      	nop
  203908:	372c      	adds	r7, #44	; 0x2c
  20390a:	46bd      	mov	sp, r7
  20390c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  203910:	2000205c 	.word	0x2000205c
  203914:	20001870 	.word	0x20001870
  203918:	c0000000 	.word	0xc0000000

0020391c <LCD_DrawCircle>:
{
  20391c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  203920:	b0b8      	sub	sp, #224	; 0xe0
  203922:	af06      	add	r7, sp, #24
  203924:	60f9      	str	r1, [r7, #12]
  203926:	60ba      	str	r2, [r7, #8]
  203928:	607b      	str	r3, [r7, #4]
  20392a:	f8d7 10f4 	ldr.w	r1, [r7, #244]	; 0xf4
  20392e:	f8d7 20f8 	ldr.w	r2, [r7, #248]	; 0xf8
static void LCD_DrawCircle(uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t __x, uint32_t __y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor)
  203932:	f107 03e8 	add.w	r3, r7, #232	; 0xe8
  203936:	62bb      	str	r3, [r7, #40]	; 0x28
  203938:	6238      	str	r0, [r7, #32]
  20393a:	61b9      	str	r1, [r7, #24]
  20393c:	627a      	str	r2, [r7, #36]	; 0x24
	int matchWidth=0, circleFlag=0;
  20393e:	2300      	movs	r3, #0
  203940:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  203944:	2300      	movs	r3, #0
  203946:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
	uint16_t param =width>>16;
  20394a:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
  20394e:	0c1b      	lsrs	r3, r3, #16
  203950:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
	uint32_t _FillColor, _width=(width&0x0000FFFF)-matchWidth;
  203954:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
  203958:	b29a      	uxth	r2, r3
  20395a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
  20395e:	1ad3      	subs	r3, r2, r3
  203960:	653b      	str	r3, [r7, #80]	; 0x50
	if(FillColor!=TRANSPARENT) _FillColor=FillColor;
  203962:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  203964:	2b00      	cmp	r3, #0
  203966:	d003      	beq.n	203970 <LCD_DrawCircle+0x54>
  203968:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20396a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  20396e:	e003      	b.n	203978 <LCD_DrawCircle+0x5c>
	else								_FillColor=BkpColor;
  203970:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
  203974:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
	uint32_t bkX = BkpSizeX;
  203978:	68fb      	ldr	r3, [r7, #12]
  20397a:	61fb      	str	r3, [r7, #28]
	uint32_t x=__x, y=__y;
  20397c:	687b      	ldr	r3, [r7, #4]
  20397e:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  203982:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
  203986:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
	if((_width==height)&&(_width>0)&&(height>0))
  20398a:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20398c:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
  203990:	429a      	cmp	r2, r3
  203992:	f040 8175 	bne.w	203c80 <LCD_DrawCircle+0x364>
  203996:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  203998:	2b00      	cmp	r3, #0
  20399a:	f000 8171 	beq.w	203c80 <LCD_DrawCircle+0x364>
  20399e:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
  2039a2:	2b00      	cmp	r3, #0
  2039a4:	f000 816c 	beq.w	203c80 <LCD_DrawCircle+0x364>
	   _width=(width&0x0000FFFF)-matchWidth;
  2039a8:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
  2039ac:	b29a      	uxth	r2, r3
  2039ae:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
  2039b2:	1ad3      	subs	r3, r2, r3
  2039b4:	653b      	str	r3, [r7, #80]	; 0x50
		uint32_t R=_width/2, err=0.5;
  2039b6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2039b8:	085b      	lsrs	r3, r3, #1
  2039ba:	64fb      	str	r3, [r7, #76]	; 0x4c
  2039bc:	2300      	movs	r3, #0
  2039be:	64bb      	str	r3, [r7, #72]	; 0x48
		uint32_t pxl_width = R/3;
  2039c0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2039c2:	4aad      	ldr	r2, [pc, #692]	; (203c78 <LCD_DrawCircle+0x35c>)
  2039c4:	fba2 2303 	umull	r2, r3, r2, r3
  2039c8:	085b      	lsrs	r3, r3, #1
  2039ca:	647b      	str	r3, [r7, #68]	; 0x44
		x=__x+_width/2 + matchWidth/2;
  2039cc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2039ce:	085a      	lsrs	r2, r3, #1
  2039d0:	687b      	ldr	r3, [r7, #4]
  2039d2:	441a      	add	r2, r3
  2039d4:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
  2039d8:	2b00      	cmp	r3, #0
  2039da:	da00      	bge.n	2039de <LCD_DrawCircle+0xc2>
  2039dc:	3301      	adds	r3, #1
  2039de:	105b      	asrs	r3, r3, #1
  2039e0:	4413      	add	r3, r2
  2039e2:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
		if(_width%2) x++;
  2039e6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2039e8:	f003 0301 	and.w	r3, r3, #1
  2039ec:	2b00      	cmp	r3, #0
  2039ee:	d004      	beq.n	2039fa <LCD_DrawCircle+0xde>
  2039f0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
  2039f4:	3301      	adds	r3, #1
  2039f6:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
		y=__y;
  2039fa:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
  2039fe:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
		float _x=(float)x, _y=(float)y;
  203a02:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
  203a06:	ee07 3a90 	vmov	s15, r3
  203a0a:	eef8 7a67 	vcvt.f32.u32	s15, s15
  203a0e:	edc7 7a2c 	vstr	s15, [r7, #176]	; 0xb0
  203a12:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  203a16:	ee07 3a90 	vmov	s15, r3
  203a1a:	eef8 7a67 	vcvt.f32.u32	s15, s15
  203a1e:	edc7 7a2b 	vstr	s15, [r7, #172]	; 0xac
		float x0=(float)x, y0=(float)y+R;
  203a22:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
  203a26:	ee07 3a90 	vmov	s15, r3
  203a2a:	eef8 7a67 	vcvt.f32.u32	s15, s15
  203a2e:	edc7 7a10 	vstr	s15, [r7, #64]	; 0x40
  203a32:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  203a36:	ee07 3a90 	vmov	s15, r3
  203a3a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  203a3e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  203a40:	ee07 3a90 	vmov	s15, r3
  203a44:	eef8 7a67 	vcvt.f32.u32	s15, s15
  203a48:	ee77 7a27 	vadd.f32	s15, s14, s15
  203a4c:	edc7 7a0f 	vstr	s15, [r7, #60]	; 0x3c
		float param_y = pow(y0-_y,2);
  203a50:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
  203a54:	edd7 7a2b 	vldr	s15, [r7, #172]	; 0xac
  203a58:	ee77 7a67 	vsub.f32	s15, s14, s15
  203a5c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  203a60:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  203a64:	eeb0 0b47 	vmov.f64	d0, d7
  203a68:	f022 fe1e 	bl	2266a8 <pow>
  203a6c:	eeb0 7b40 	vmov.f64	d7, d0
  203a70:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  203a74:	edc7 7a2a 	vstr	s15, [r7, #168]	; 0xa8
		float param_x = pow(_x-x0,2);
  203a78:	ed97 7a2c 	vldr	s14, [r7, #176]	; 0xb0
  203a7c:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
  203a80:	ee77 7a67 	vsub.f32	s15, s14, s15
  203a84:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  203a88:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  203a8c:	eeb0 0b47 	vmov.f64	d0, d7
  203a90:	f022 fe0a 	bl	2266a8 <pow>
  203a94:	eeb0 7b40 	vmov.f64	d7, d0
  203a98:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  203a9c:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
		float decision = pow(R+err,2);
  203aa0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  203aa2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  203aa4:	4413      	add	r3, r2
  203aa6:	ee07 3a90 	vmov	s15, r3
  203aaa:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  203aae:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  203ab2:	eeb0 0b47 	vmov.f64	d0, d7
  203ab6:	f022 fdf7 	bl	2266a8 <pow>
  203aba:	eeb0 7b40 	vmov.f64	d7, d0
  203abe:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  203ac2:	edc7 7a0d 	vstr	s15, [r7, #52]	; 0x34
		int pxl_line=0,i=0;
  203ac6:	2300      	movs	r3, #0
  203ac8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  203acc:	2300      	movs	r3, #0
  203ace:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
		buf[0]=pxl_width;
  203ad2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  203ad4:	b2da      	uxtb	r2, r3
  203ad6:	4b69      	ldr	r3, [pc, #420]	; (203c7c <LCD_DrawCircle+0x360>)
  203ad8:	701a      	strb	r2, [r3, #0]
			_x++;  pxl_line++;
  203ada:	edd7 7a2c 	vldr	s15, [r7, #176]	; 0xb0
  203ade:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  203ae2:	ee77 7a87 	vadd.f32	s15, s15, s14
  203ae6:	edc7 7a2c 	vstr	s15, [r7, #176]	; 0xb0
  203aea:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
  203aee:	3301      	adds	r3, #1
  203af0:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
			param_x = pow(_x-x0,2);
  203af4:	ed97 7a2c 	vldr	s14, [r7, #176]	; 0xb0
  203af8:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
  203afc:	ee77 7a67 	vsub.f32	s15, s14, s15
  203b00:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  203b04:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  203b08:	eeb0 0b47 	vmov.f64	d0, d7
  203b0c:	f022 fdcc 	bl	2266a8 <pow>
  203b10:	eeb0 7b40 	vmov.f64	d7, d0
  203b14:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  203b18:	edc7 7a0e 	vstr	s15, [r7, #56]	; 0x38
			if((param_x+param_y) > decision){
  203b1c:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
  203b20:	edd7 7a2a 	vldr	s15, [r7, #168]	; 0xa8
  203b24:	ee37 7a27 	vadd.f32	s14, s14, s15
  203b28:	edd7 7a0d 	vldr	s15, [r7, #52]	; 0x34
  203b2c:	eeb4 7ae7 	vcmpe.f32	s14, s15
  203b30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  203b34:	dd2b      	ble.n	203b8e <LCD_DrawCircle+0x272>
				_y++;
  203b36:	edd7 7a2b 	vldr	s15, [r7, #172]	; 0xac
  203b3a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  203b3e:	ee77 7a87 	vadd.f32	s15, s15, s14
  203b42:	edc7 7a2b 	vstr	s15, [r7, #172]	; 0xac
				param_y = pow(y0-_y,2);
  203b46:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
  203b4a:	edd7 7a2b 	vldr	s15, [r7, #172]	; 0xac
  203b4e:	ee77 7a67 	vsub.f32	s15, s14, s15
  203b52:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  203b56:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  203b5a:	eeb0 0b47 	vmov.f64	d0, d7
  203b5e:	f022 fda3 	bl	2266a8 <pow>
  203b62:	eeb0 7b40 	vmov.f64	d7, d0
  203b66:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  203b6a:	edc7 7a2a 	vstr	s15, [r7, #168]	; 0xa8
				buf[1+i++]=pxl_line-1;
  203b6e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  203b72:	1c5a      	adds	r2, r3, #1
  203b74:	f8c7 20a0 	str.w	r2, [r7, #160]	; 0xa0
  203b78:	3301      	adds	r3, #1
  203b7a:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
  203b7e:	b2d2      	uxtb	r2, r2
  203b80:	3a01      	subs	r2, #1
  203b82:	b2d1      	uxtb	r1, r2
  203b84:	4a3d      	ldr	r2, [pc, #244]	; (203c7c <LCD_DrawCircle+0x360>)
  203b86:	54d1      	strb	r1, [r2, r3]
				pxl_line=1;
  203b88:	2301      	movs	r3, #1
  203b8a:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
		}while(i<pxl_width);
  203b8e:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
  203b92:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  203b94:	429a      	cmp	r2, r3
  203b96:	d3a0      	bcc.n	203ada <LCD_DrawCircle+0x1be>
		LCD_CircleCorrect();
  203b98:	f7fe fc46 	bl	202428 <LCD_CircleCorrect>
  	 uint16_t _height=buf[0];
  203b9c:	4b37      	ldr	r3, [pc, #220]	; (203c7c <LCD_DrawCircle+0x360>)
  203b9e:	781b      	ldrb	r3, [r3, #0]
  203ba0:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
  	 for(int i=0;i<buf[0];++i) _height+=buf[buf[0]-i];
  203ba4:	2300      	movs	r3, #0
  203ba6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  203baa:	e012      	b.n	203bd2 <LCD_DrawCircle+0x2b6>
  203bac:	4b33      	ldr	r3, [pc, #204]	; (203c7c <LCD_DrawCircle+0x360>)
  203bae:	781b      	ldrb	r3, [r3, #0]
  203bb0:	461a      	mov	r2, r3
  203bb2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  203bb6:	1ad3      	subs	r3, r2, r3
  203bb8:	4a30      	ldr	r2, [pc, #192]	; (203c7c <LCD_DrawCircle+0x360>)
  203bba:	5cd3      	ldrb	r3, [r2, r3]
  203bbc:	b29a      	uxth	r2, r3
  203bbe:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
  203bc2:	4413      	add	r3, r2
  203bc4:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
  203bc8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  203bcc:	3301      	adds	r3, #1
  203bce:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  203bd2:	4b2a      	ldr	r3, [pc, #168]	; (203c7c <LCD_DrawCircle+0x360>)
  203bd4:	781b      	ldrb	r3, [r3, #0]
  203bd6:	461a      	mov	r2, r3
  203bd8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  203bdc:	429a      	cmp	r2, r3
  203bde:	dce5      	bgt.n	203bac <LCD_DrawCircle+0x290>
  	 _height = 2*_height;
  203be0:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
  203be4:	005b      	lsls	r3, r3, #1
  203be6:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
		if(height>=_height)
  203bea:	f8b7 209e 	ldrh.w	r2, [r7, #158]	; 0x9e
  203bee:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
  203bf2:	429a      	cmp	r2, r3
  203bf4:	d839      	bhi.n	203c6a <LCD_DrawCircle+0x34e>
			y= y+(height-_height)/2;
  203bf6:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
  203bfa:	f8d7 20f0 	ldr.w	r2, [r7, #240]	; 0xf0
  203bfe:	1ad3      	subs	r3, r2, r3
  203c00:	085b      	lsrs	r3, r3, #1
  203c02:	f8d7 20b4 	ldr.w	r2, [r7, #180]	; 0xb4
  203c06:	4413      	add	r3, r2
  203c08:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
		x-=(x-__x-_height/2);
  203c0c:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
  203c10:	085b      	lsrs	r3, r3, #1
  203c12:	b29b      	uxth	r3, r3
  203c14:	4619      	mov	r1, r3
  203c16:	687a      	ldr	r2, [r7, #4]
  203c18:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
  203c1c:	1ad3      	subs	r3, r2, r3
  203c1e:	440b      	add	r3, r1
  203c20:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
  203c24:	4413      	add	r3, r2
  203c26:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
		y-=(y-__y);
  203c2a:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
  203c2e:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
		Circle.width=_height;
  203c32:	4a12      	ldr	r2, [pc, #72]	; (203c7c <LCD_DrawCircle+0x360>)
  203c34:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
  203c38:	f8a2 3204 	strh.w	r3, [r2, #516]	; 0x204
		Circle.x0=x;
  203c3c:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
  203c40:	b29a      	uxth	r2, r3
  203c42:	4b0e      	ldr	r3, [pc, #56]	; (203c7c <LCD_DrawCircle+0x360>)
  203c44:	f8a3 2208 	strh.w	r2, [r3, #520]	; 0x208
		Circle.y0=y+Circle.width/2;
  203c48:	4b0c      	ldr	r3, [pc, #48]	; (203c7c <LCD_DrawCircle+0x360>)
  203c4a:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  203c4e:	085b      	lsrs	r3, r3, #1
  203c50:	b29a      	uxth	r2, r3
  203c52:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  203c56:	b29b      	uxth	r3, r3
  203c58:	4413      	add	r3, r2
  203c5a:	b29a      	uxth	r2, r3
  203c5c:	4b07      	ldr	r3, [pc, #28]	; (203c7c <LCD_DrawCircle+0x360>)
  203c5e:	f8a3 220a 	strh.w	r2, [r3, #522]	; 0x20a
		circleFlag=1;
  203c62:	2301      	movs	r3, #1
  203c64:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
	{
  203c68:	e013      	b.n	203c92 <LCD_DrawCircle+0x376>
			matchWidth+=1;
  203c6a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
  203c6e:	3301      	adds	r3, #1
  203c70:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
			goto GOTO_ToCalculateRadius;
  203c74:	e698      	b.n	2039a8 <LCD_DrawCircle+0x8c>
  203c76:	bf00      	nop
  203c78:	aaaaaaab 	.word	0xaaaaaaab
  203c7c:	2000205c 	.word	0x2000205c
	else if((_width==0)&&(height==0));
  203c80:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  203c82:	2b00      	cmp	r3, #0
  203c84:	f040 86cd 	bne.w	204a22 <LCD_DrawCircle+0x1106>
  203c88:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
  203c8c:	2b00      	cmp	r3, #0
  203c8e:	f040 86c8 	bne.w	204a22 <LCD_DrawCircle+0x1106>
	uint8_t buf_Inv[buf[0]+1];
  203c92:	4b86      	ldr	r3, [pc, #536]	; (203eac <LCD_DrawCircle+0x590>)
  203c94:	781b      	ldrb	r3, [r3, #0]
  203c96:	1c59      	adds	r1, r3, #1
  203c98:	466b      	mov	r3, sp
  203c9a:	469a      	mov	sl, r3
  203c9c:	1e4b      	subs	r3, r1, #1
  203c9e:	633b      	str	r3, [r7, #48]	; 0x30
  203ca0:	460b      	mov	r3, r1
  203ca2:	461a      	mov	r2, r3
  203ca4:	f04f 0300 	mov.w	r3, #0
  203ca8:	ea4f 09c3 	mov.w	r9, r3, lsl #3
  203cac:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
  203cb0:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  203cb4:	460b      	mov	r3, r1
  203cb6:	461a      	mov	r2, r3
  203cb8:	f04f 0300 	mov.w	r3, #0
  203cbc:	00dd      	lsls	r5, r3, #3
  203cbe:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
  203cc2:	00d4      	lsls	r4, r2, #3
  203cc4:	460b      	mov	r3, r1
  203cc6:	3307      	adds	r3, #7
  203cc8:	08db      	lsrs	r3, r3, #3
  203cca:	00db      	lsls	r3, r3, #3
  203ccc:	ebad 0d03 	sub.w	sp, sp, r3
  203cd0:	ab06      	add	r3, sp, #24
  203cd2:	3300      	adds	r3, #0
  203cd4:	62fb      	str	r3, [r7, #44]	; 0x2c
	InverseAndCopyBuff(buf_Inv,buf);
  203cd6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203cd8:	4974      	ldr	r1, [pc, #464]	; (203eac <LCD_DrawCircle+0x590>)
  203cda:	4618      	mov	r0, r3
  203cdc:	f7fe fb7a 	bl	2023d4 <InverseAndCopyBuff>
	_StartDrawLine(posBuff,bkX,x,y);
  203ce0:	6a38      	ldr	r0, [r7, #32]
  203ce2:	69f9      	ldr	r1, [r7, #28]
  203ce4:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  203ce8:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
  203cec:	f001 f858 	bl	204da0 <_StartDrawLine>
	if(param==Degree_Circle && circleFlag)
  203cf0:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
  203cf4:	2b05      	cmp	r3, #5
  203cf6:	f040 80db 	bne.w	203eb0 <LCD_DrawCircle+0x594>
  203cfa:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
  203cfe:	2b00      	cmp	r3, #0
  203d00:	f000 80d6 	beq.w	203eb0 <LCD_DrawCircle+0x594>
		uint8_t pFill=0;
  203d04:	2300      	movs	r3, #0
  203d06:	75fb      	strb	r3, [r7, #23]
		if(_DrawArrayBuffRightDown_AA___(posBuff,&pFill,PARAM_AA,0,buf)){ return; 	}   _CopyDrawPos(); _IncDrawPos(-bkX); PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  203d08:	4b68      	ldr	r3, [pc, #416]	; (203eac <LCD_DrawCircle+0x590>)
  203d0a:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203d0e:	4b67      	ldr	r3, [pc, #412]	; (203eac <LCD_DrawCircle+0x590>)
  203d10:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203d14:	6a38      	ldr	r0, [r7, #32]
  203d16:	69ba      	ldr	r2, [r7, #24]
  203d18:	f107 0117 	add.w	r1, r7, #23
  203d1c:	4b63      	ldr	r3, [pc, #396]	; (203eac <LCD_DrawCircle+0x590>)
  203d1e:	9303      	str	r3, [sp, #12]
  203d20:	2300      	movs	r3, #0
  203d22:	9302      	str	r3, [sp, #8]
  203d24:	68fb      	ldr	r3, [r7, #12]
  203d26:	9301      	str	r3, [sp, #4]
  203d28:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
  203d2c:	9300      	str	r3, [sp, #0]
  203d2e:	eef0 0a47 	vmov.f32	s1, s14
  203d32:	eeb0 0a67 	vmov.f32	s0, s15
  203d36:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
  203d3a:	f7ff f9cf 	bl	2030dc <_DrawArrayBuffRightDown_AA___>
  203d3e:	4603      	mov	r3, r0
  203d40:	2b00      	cmp	r3, #0
  203d42:	f040 80a9 	bne.w	203e98 <LCD_DrawCircle+0x57c>
  203d46:	f000 fff9 	bl	204d3c <_CopyDrawPos>
  203d4a:	69fb      	ldr	r3, [r7, #28]
  203d4c:	425b      	negs	r3, r3
  203d4e:	4618      	mov	r0, r3
  203d50:	f001 f814 	bl	204d7c <_IncDrawPos>
  203d54:	4b55      	ldr	r3, [pc, #340]	; (203eac <LCD_DrawCircle+0x590>)
  203d56:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203d5a:	69b8      	ldr	r0, [r7, #24]
  203d5c:	2301      	movs	r3, #1
  203d5e:	2201      	movs	r2, #1
  203d60:	eeb0 0a67 	vmov.f32	s0, s15
  203d64:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203d68:	f7fe fafe 	bl	202368 <PixelCorrect>
  203d6c:	f000 fff6 	bl	204d5c <_SetCopyDrawPos>
		if(_DrawArrayBuffRightDown_AA___(posBuff,&pFill,PARAM_AA,1,buf_Inv)){ return; }                      				   PixelCorrect(PARAM, buf[1],bkX);   _IncDrawPos(-1);
  203d70:	4b4e      	ldr	r3, [pc, #312]	; (203eac <LCD_DrawCircle+0x590>)
  203d72:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203d76:	4b4d      	ldr	r3, [pc, #308]	; (203eac <LCD_DrawCircle+0x590>)
  203d78:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203d7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203d7e:	6a38      	ldr	r0, [r7, #32]
  203d80:	69ba      	ldr	r2, [r7, #24]
  203d82:	f107 0117 	add.w	r1, r7, #23
  203d86:	9303      	str	r3, [sp, #12]
  203d88:	2301      	movs	r3, #1
  203d8a:	9302      	str	r3, [sp, #8]
  203d8c:	68fb      	ldr	r3, [r7, #12]
  203d8e:	9301      	str	r3, [sp, #4]
  203d90:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
  203d94:	9300      	str	r3, [sp, #0]
  203d96:	eef0 0a47 	vmov.f32	s1, s14
  203d9a:	eeb0 0a67 	vmov.f32	s0, s15
  203d9e:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
  203da2:	f7ff f99b 	bl	2030dc <_DrawArrayBuffRightDown_AA___>
  203da6:	4603      	mov	r3, r0
  203da8:	2b00      	cmp	r3, #0
  203daa:	d177      	bne.n	203e9c <LCD_DrawCircle+0x580>
  203dac:	4b3f      	ldr	r3, [pc, #252]	; (203eac <LCD_DrawCircle+0x590>)
  203dae:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203db2:	4b3e      	ldr	r3, [pc, #248]	; (203eac <LCD_DrawCircle+0x590>)
  203db4:	785b      	ldrb	r3, [r3, #1]
  203db6:	b29a      	uxth	r2, r3
  203db8:	69fb      	ldr	r3, [r7, #28]
  203dba:	69b8      	ldr	r0, [r7, #24]
  203dbc:	eeb0 0a67 	vmov.f32	s0, s15
  203dc0:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203dc4:	f7fe fad0 	bl	202368 <PixelCorrect>
  203dc8:	f04f 30ff 	mov.w	r0, #4294967295
  203dcc:	f000 ffd6 	bl	204d7c <_IncDrawPos>
		if(_DrawArrayBuffLeftDown_AA___ (posBuff,&pFill,PARAM_AA,1,buf)){ return; 	} 		 _CopyDrawPos(); _IncDrawPos(1);    PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  203dd0:	4b36      	ldr	r3, [pc, #216]	; (203eac <LCD_DrawCircle+0x590>)
  203dd2:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203dd6:	4b35      	ldr	r3, [pc, #212]	; (203eac <LCD_DrawCircle+0x590>)
  203dd8:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203ddc:	6a38      	ldr	r0, [r7, #32]
  203dde:	69ba      	ldr	r2, [r7, #24]
  203de0:	f107 0117 	add.w	r1, r7, #23
  203de4:	4b31      	ldr	r3, [pc, #196]	; (203eac <LCD_DrawCircle+0x590>)
  203de6:	9303      	str	r3, [sp, #12]
  203de8:	2301      	movs	r3, #1
  203dea:	9302      	str	r3, [sp, #8]
  203dec:	68fb      	ldr	r3, [r7, #12]
  203dee:	9301      	str	r3, [sp, #4]
  203df0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
  203df4:	9300      	str	r3, [sp, #0]
  203df6:	eef0 0a47 	vmov.f32	s1, s14
  203dfa:	eeb0 0a67 	vmov.f32	s0, s15
  203dfe:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
  203e02:	f7ff fb27 	bl	203454 <_DrawArrayBuffLeftDown_AA___>
  203e06:	4603      	mov	r3, r0
  203e08:	2b00      	cmp	r3, #0
  203e0a:	d149      	bne.n	203ea0 <LCD_DrawCircle+0x584>
  203e0c:	f000 ff96 	bl	204d3c <_CopyDrawPos>
  203e10:	2001      	movs	r0, #1
  203e12:	f000 ffb3 	bl	204d7c <_IncDrawPos>
  203e16:	4b25      	ldr	r3, [pc, #148]	; (203eac <LCD_DrawCircle+0x590>)
  203e18:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203e1c:	69b8      	ldr	r0, [r7, #24]
  203e1e:	2301      	movs	r3, #1
  203e20:	2201      	movs	r2, #1
  203e22:	eeb0 0a67 	vmov.f32	s0, s15
  203e26:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203e2a:	f7fe fa9d 	bl	202368 <PixelCorrect>
  203e2e:	f000 ff95 	bl	204d5c <_SetCopyDrawPos>
		if(_DrawArrayBuffLeftDown_AA___ (posBuff,&pFill,PARAM_AA,0,buf_Inv)){ return; 	}                      					PixelCorrect(PARAM, buf[1],-1);    _IncDrawPos(-bkX);
  203e32:	4b1e      	ldr	r3, [pc, #120]	; (203eac <LCD_DrawCircle+0x590>)
  203e34:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203e38:	4b1c      	ldr	r3, [pc, #112]	; (203eac <LCD_DrawCircle+0x590>)
  203e3a:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203e3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203e40:	6a38      	ldr	r0, [r7, #32]
  203e42:	69ba      	ldr	r2, [r7, #24]
  203e44:	f107 0117 	add.w	r1, r7, #23
  203e48:	9303      	str	r3, [sp, #12]
  203e4a:	2300      	movs	r3, #0
  203e4c:	9302      	str	r3, [sp, #8]
  203e4e:	68fb      	ldr	r3, [r7, #12]
  203e50:	9301      	str	r3, [sp, #4]
  203e52:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
  203e56:	9300      	str	r3, [sp, #0]
  203e58:	eef0 0a47 	vmov.f32	s1, s14
  203e5c:	eeb0 0a67 	vmov.f32	s0, s15
  203e60:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
  203e64:	f7ff faf6 	bl	203454 <_DrawArrayBuffLeftDown_AA___>
  203e68:	4603      	mov	r3, r0
  203e6a:	2b00      	cmp	r3, #0
  203e6c:	d11a      	bne.n	203ea4 <LCD_DrawCircle+0x588>
  203e6e:	4b0f      	ldr	r3, [pc, #60]	; (203eac <LCD_DrawCircle+0x590>)
  203e70:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203e74:	4b0d      	ldr	r3, [pc, #52]	; (203eac <LCD_DrawCircle+0x590>)
  203e76:	785b      	ldrb	r3, [r3, #1]
  203e78:	b29a      	uxth	r2, r3
  203e7a:	69b8      	ldr	r0, [r7, #24]
  203e7c:	f04f 33ff 	mov.w	r3, #4294967295
  203e80:	eeb0 0a67 	vmov.f32	s0, s15
  203e84:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203e88:	f7fe fa6e 	bl	202368 <PixelCorrect>
  203e8c:	69fb      	ldr	r3, [r7, #28]
  203e8e:	425b      	negs	r3, r3
  203e90:	4618      	mov	r0, r3
  203e92:	f000 ff73 	bl	204d7c <_IncDrawPos>
		return;
  203e96:	e006      	b.n	203ea6 <LCD_DrawCircle+0x58a>
		if(_DrawArrayBuffRightDown_AA___(posBuff,&pFill,PARAM_AA,0,buf)){ return; 	}   _CopyDrawPos(); _IncDrawPos(-bkX); PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  203e98:	bf00      	nop
  203e9a:	e004      	b.n	203ea6 <LCD_DrawCircle+0x58a>
		if(_DrawArrayBuffRightDown_AA___(posBuff,&pFill,PARAM_AA,1,buf_Inv)){ return; }                      				   PixelCorrect(PARAM, buf[1],bkX);   _IncDrawPos(-1);
  203e9c:	bf00      	nop
  203e9e:	e002      	b.n	203ea6 <LCD_DrawCircle+0x58a>
		if(_DrawArrayBuffLeftDown_AA___ (posBuff,&pFill,PARAM_AA,1,buf)){ return; 	} 		 _CopyDrawPos(); _IncDrawPos(1);    PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  203ea0:	bf00      	nop
  203ea2:	e000      	b.n	203ea6 <LCD_DrawCircle+0x58a>
		if(_DrawArrayBuffLeftDown_AA___ (posBuff,&pFill,PARAM_AA,0,buf_Inv)){ return; 	}                      					PixelCorrect(PARAM, buf[1],-1);    _IncDrawPos(-bkX);
  203ea4:	bf00      	nop
  203ea6:	46d5      	mov	sp, sl
  203ea8:	f000 bdbc 	b.w	204a24 <LCD_DrawCircle+0x1108>
  203eac:	2000205c 	.word	0x2000205c
		_DrawArrayBuffRightDown_AA(PARAM_AA,0,buf); 	    _CopyDrawPos(); _IncDrawPos(-bkX); PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  203eb0:	4bae      	ldr	r3, [pc, #696]	; (20416c <LCD_DrawCircle+0x850>)
  203eb2:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203eb6:	4bad      	ldr	r3, [pc, #692]	; (20416c <LCD_DrawCircle+0x850>)
  203eb8:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203ebc:	69b8      	ldr	r0, [r7, #24]
  203ebe:	4bab      	ldr	r3, [pc, #684]	; (20416c <LCD_DrawCircle+0x850>)
  203ec0:	9301      	str	r3, [sp, #4]
  203ec2:	2300      	movs	r3, #0
  203ec4:	9300      	str	r3, [sp, #0]
  203ec6:	68fb      	ldr	r3, [r7, #12]
  203ec8:	eef0 0a47 	vmov.f32	s1, s14
  203ecc:	eeb0 0a67 	vmov.f32	s0, s15
  203ed0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  203ed4:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203ed8:	f001 f878 	bl	204fcc <_DrawArrayBuffRightDown_AA>
  203edc:	f000 ff2e 	bl	204d3c <_CopyDrawPos>
  203ee0:	69fb      	ldr	r3, [r7, #28]
  203ee2:	425b      	negs	r3, r3
  203ee4:	4618      	mov	r0, r3
  203ee6:	f000 ff49 	bl	204d7c <_IncDrawPos>
  203eea:	4ba0      	ldr	r3, [pc, #640]	; (20416c <LCD_DrawCircle+0x850>)
  203eec:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203ef0:	69b8      	ldr	r0, [r7, #24]
  203ef2:	2301      	movs	r3, #1
  203ef4:	2201      	movs	r2, #1
  203ef6:	eeb0 0a67 	vmov.f32	s0, s15
  203efa:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203efe:	f7fe fa33 	bl	202368 <PixelCorrect>
  203f02:	f000 ff2b 	bl	204d5c <_SetCopyDrawPos>
		_DrawArrayBuffRightDown_AA(PARAM_AA,1,buf_Inv);                      				   PixelCorrect(PARAM, buf[1],bkX);   _IncDrawPos(-1);
  203f06:	4b99      	ldr	r3, [pc, #612]	; (20416c <LCD_DrawCircle+0x850>)
  203f08:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203f0c:	4b97      	ldr	r3, [pc, #604]	; (20416c <LCD_DrawCircle+0x850>)
  203f0e:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203f12:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203f14:	69b8      	ldr	r0, [r7, #24]
  203f16:	9301      	str	r3, [sp, #4]
  203f18:	2301      	movs	r3, #1
  203f1a:	9300      	str	r3, [sp, #0]
  203f1c:	68fb      	ldr	r3, [r7, #12]
  203f1e:	eef0 0a47 	vmov.f32	s1, s14
  203f22:	eeb0 0a67 	vmov.f32	s0, s15
  203f26:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  203f2a:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203f2e:	f001 f84d 	bl	204fcc <_DrawArrayBuffRightDown_AA>
  203f32:	4b8e      	ldr	r3, [pc, #568]	; (20416c <LCD_DrawCircle+0x850>)
  203f34:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203f38:	4b8c      	ldr	r3, [pc, #560]	; (20416c <LCD_DrawCircle+0x850>)
  203f3a:	785b      	ldrb	r3, [r3, #1]
  203f3c:	b29a      	uxth	r2, r3
  203f3e:	69fb      	ldr	r3, [r7, #28]
  203f40:	69b8      	ldr	r0, [r7, #24]
  203f42:	eeb0 0a67 	vmov.f32	s0, s15
  203f46:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203f4a:	f7fe fa0d 	bl	202368 <PixelCorrect>
  203f4e:	f04f 30ff 	mov.w	r0, #4294967295
  203f52:	f000 ff13 	bl	204d7c <_IncDrawPos>
		_DrawArrayBuffLeftDown_AA (PARAM_AA,1,buf); 		 _CopyDrawPos(); _IncDrawPos(1);    PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  203f56:	4b85      	ldr	r3, [pc, #532]	; (20416c <LCD_DrawCircle+0x850>)
  203f58:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203f5c:	4b83      	ldr	r3, [pc, #524]	; (20416c <LCD_DrawCircle+0x850>)
  203f5e:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203f62:	69b8      	ldr	r0, [r7, #24]
  203f64:	4b81      	ldr	r3, [pc, #516]	; (20416c <LCD_DrawCircle+0x850>)
  203f66:	9301      	str	r3, [sp, #4]
  203f68:	2301      	movs	r3, #1
  203f6a:	9300      	str	r3, [sp, #0]
  203f6c:	68fb      	ldr	r3, [r7, #12]
  203f6e:	eef0 0a47 	vmov.f32	s1, s14
  203f72:	eeb0 0a67 	vmov.f32	s0, s15
  203f76:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  203f7a:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203f7e:	f001 fa23 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
  203f82:	f000 fedb 	bl	204d3c <_CopyDrawPos>
  203f86:	2001      	movs	r0, #1
  203f88:	f000 fef8 	bl	204d7c <_IncDrawPos>
  203f8c:	4b77      	ldr	r3, [pc, #476]	; (20416c <LCD_DrawCircle+0x850>)
  203f8e:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203f92:	69b8      	ldr	r0, [r7, #24]
  203f94:	2301      	movs	r3, #1
  203f96:	2201      	movs	r2, #1
  203f98:	eeb0 0a67 	vmov.f32	s0, s15
  203f9c:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203fa0:	f7fe f9e2 	bl	202368 <PixelCorrect>
  203fa4:	f000 feda 	bl	204d5c <_SetCopyDrawPos>
		_DrawArrayBuffLeftDown_AA (PARAM_AA,0,buf_Inv);                      					PixelCorrect(PARAM, buf[1],-1);    _IncDrawPos(-bkX);
  203fa8:	4b70      	ldr	r3, [pc, #448]	; (20416c <LCD_DrawCircle+0x850>)
  203faa:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203fae:	4b6f      	ldr	r3, [pc, #444]	; (20416c <LCD_DrawCircle+0x850>)
  203fb0:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  203fb4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  203fb6:	69b8      	ldr	r0, [r7, #24]
  203fb8:	9301      	str	r3, [sp, #4]
  203fba:	2300      	movs	r3, #0
  203fbc:	9300      	str	r3, [sp, #0]
  203fbe:	68fb      	ldr	r3, [r7, #12]
  203fc0:	eef0 0a47 	vmov.f32	s1, s14
  203fc4:	eeb0 0a67 	vmov.f32	s0, s15
  203fc8:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  203fcc:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203fd0:	f001 f9fa 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
  203fd4:	4b65      	ldr	r3, [pc, #404]	; (20416c <LCD_DrawCircle+0x850>)
  203fd6:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  203fda:	4b64      	ldr	r3, [pc, #400]	; (20416c <LCD_DrawCircle+0x850>)
  203fdc:	785b      	ldrb	r3, [r3, #1]
  203fde:	b29a      	uxth	r2, r3
  203fe0:	69b8      	ldr	r0, [r7, #24]
  203fe2:	f04f 33ff 	mov.w	r3, #4294967295
  203fe6:	eeb0 0a67 	vmov.f32	s0, s15
  203fea:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  203fee:	f7fe f9bb 	bl	202368 <PixelCorrect>
  203ff2:	69fb      	ldr	r3, [r7, #28]
  203ff4:	425b      	negs	r3, r3
  203ff6:	4618      	mov	r0, r3
  203ff8:	f000 fec0 	bl	204d7c <_IncDrawPos>
		_DrawArrayBuffLeftUp_AA  (PARAM_AA,0,buf);       _CopyDrawPos(); _IncDrawPos(bkX);  PixelCorrect(PARAM, 1,     -bkX);  _SetCopyDrawPos();
  203ffc:	4b5b      	ldr	r3, [pc, #364]	; (20416c <LCD_DrawCircle+0x850>)
  203ffe:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  204002:	4b5a      	ldr	r3, [pc, #360]	; (20416c <LCD_DrawCircle+0x850>)
  204004:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  204008:	69b8      	ldr	r0, [r7, #24]
  20400a:	4b58      	ldr	r3, [pc, #352]	; (20416c <LCD_DrawCircle+0x850>)
  20400c:	9301      	str	r3, [sp, #4]
  20400e:	2300      	movs	r3, #0
  204010:	9300      	str	r3, [sp, #0]
  204012:	68fb      	ldr	r3, [r7, #12]
  204014:	eef0 0a47 	vmov.f32	s1, s14
  204018:	eeb0 0a67 	vmov.f32	s0, s15
  20401c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  204020:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  204024:	f001 fac6 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
  204028:	f000 fe88 	bl	204d3c <_CopyDrawPos>
  20402c:	69fb      	ldr	r3, [r7, #28]
  20402e:	4618      	mov	r0, r3
  204030:	f000 fea4 	bl	204d7c <_IncDrawPos>
  204034:	4b4d      	ldr	r3, [pc, #308]	; (20416c <LCD_DrawCircle+0x850>)
  204036:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  20403a:	69fb      	ldr	r3, [r7, #28]
  20403c:	425b      	negs	r3, r3
  20403e:	69b8      	ldr	r0, [r7, #24]
  204040:	2201      	movs	r2, #1
  204042:	eeb0 0a67 	vmov.f32	s0, s15
  204046:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  20404a:	f7fe f98d 	bl	202368 <PixelCorrect>
  20404e:	f000 fe85 	bl	204d5c <_SetCopyDrawPos>
		_DrawArrayBuffLeftUp_AA  (PARAM_AA,1,buf_Inv);  						    					PixelCorrect(PARAM, buf[1],-bkX);  _IncDrawPos(1);
  204052:	4b46      	ldr	r3, [pc, #280]	; (20416c <LCD_DrawCircle+0x850>)
  204054:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  204058:	4b44      	ldr	r3, [pc, #272]	; (20416c <LCD_DrawCircle+0x850>)
  20405a:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  20405e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  204060:	69b8      	ldr	r0, [r7, #24]
  204062:	9301      	str	r3, [sp, #4]
  204064:	2301      	movs	r3, #1
  204066:	9300      	str	r3, [sp, #0]
  204068:	68fb      	ldr	r3, [r7, #12]
  20406a:	eef0 0a47 	vmov.f32	s1, s14
  20406e:	eeb0 0a67 	vmov.f32	s0, s15
  204072:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  204076:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  20407a:	f001 fa9b 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
  20407e:	4b3b      	ldr	r3, [pc, #236]	; (20416c <LCD_DrawCircle+0x850>)
  204080:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  204084:	4b39      	ldr	r3, [pc, #228]	; (20416c <LCD_DrawCircle+0x850>)
  204086:	785b      	ldrb	r3, [r3, #1]
  204088:	b29a      	uxth	r2, r3
  20408a:	69fb      	ldr	r3, [r7, #28]
  20408c:	425b      	negs	r3, r3
  20408e:	69b8      	ldr	r0, [r7, #24]
  204090:	eeb0 0a67 	vmov.f32	s0, s15
  204094:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  204098:	f7fe f966 	bl	202368 <PixelCorrect>
  20409c:	2001      	movs	r0, #1
  20409e:	f000 fe6d 	bl	204d7c <_IncDrawPos>
		_DrawArrayBuffRightUp_AA (PARAM_AA,1,buf);       _CopyDrawPos(); _IncDrawPos(-1);  	PixelCorrect(PARAM, 1,      1);    _SetCopyDrawPos();
  2040a2:	4b32      	ldr	r3, [pc, #200]	; (20416c <LCD_DrawCircle+0x850>)
  2040a4:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  2040a8:	4b30      	ldr	r3, [pc, #192]	; (20416c <LCD_DrawCircle+0x850>)
  2040aa:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  2040ae:	69b8      	ldr	r0, [r7, #24]
  2040b0:	4b2e      	ldr	r3, [pc, #184]	; (20416c <LCD_DrawCircle+0x850>)
  2040b2:	9301      	str	r3, [sp, #4]
  2040b4:	2301      	movs	r3, #1
  2040b6:	9300      	str	r3, [sp, #0]
  2040b8:	68fb      	ldr	r3, [r7, #12]
  2040ba:	eef0 0a47 	vmov.f32	s1, s14
  2040be:	eeb0 0a67 	vmov.f32	s0, s15
  2040c2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  2040c6:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  2040ca:	f001 f887 	bl	2051dc <_DrawArrayBuffRightUp_AA>
  2040ce:	f000 fe35 	bl	204d3c <_CopyDrawPos>
  2040d2:	f04f 30ff 	mov.w	r0, #4294967295
  2040d6:	f000 fe51 	bl	204d7c <_IncDrawPos>
  2040da:	4b24      	ldr	r3, [pc, #144]	; (20416c <LCD_DrawCircle+0x850>)
  2040dc:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  2040e0:	69b8      	ldr	r0, [r7, #24]
  2040e2:	2301      	movs	r3, #1
  2040e4:	2201      	movs	r2, #1
  2040e6:	eeb0 0a67 	vmov.f32	s0, s15
  2040ea:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  2040ee:	f7fe f93b 	bl	202368 <PixelCorrect>
  2040f2:	f000 fe33 	bl	204d5c <_SetCopyDrawPos>
		_DrawArrayBuffRightUp_AA (PARAM_AA,0,buf_Inv);                       					PixelCorrect(PARAM, buf[1], 1);
  2040f6:	4b1d      	ldr	r3, [pc, #116]	; (20416c <LCD_DrawCircle+0x850>)
  2040f8:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  2040fc:	4b1b      	ldr	r3, [pc, #108]	; (20416c <LCD_DrawCircle+0x850>)
  2040fe:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  204102:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  204104:	69b8      	ldr	r0, [r7, #24]
  204106:	9301      	str	r3, [sp, #4]
  204108:	2300      	movs	r3, #0
  20410a:	9300      	str	r3, [sp, #0]
  20410c:	68fb      	ldr	r3, [r7, #12]
  20410e:	eef0 0a47 	vmov.f32	s1, s14
  204112:	eeb0 0a67 	vmov.f32	s0, s15
  204116:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
  20411a:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  20411e:	f001 f85d 	bl	2051dc <_DrawArrayBuffRightUp_AA>
  204122:	4b12      	ldr	r3, [pc, #72]	; (20416c <LCD_DrawCircle+0x850>)
  204124:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  204128:	4b10      	ldr	r3, [pc, #64]	; (20416c <LCD_DrawCircle+0x850>)
  20412a:	785b      	ldrb	r3, [r3, #1]
  20412c:	b29a      	uxth	r2, r3
  20412e:	69b8      	ldr	r0, [r7, #24]
  204130:	2301      	movs	r3, #1
  204132:	eeb0 0a67 	vmov.f32	s0, s15
  204136:	f8d7 10fc 	ldr.w	r1, [r7, #252]	; 0xfc
  20413a:	f7fe f915 	bl	202368 <PixelCorrect>
	if(FillColor!=TRANSPARENT)
  20413e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  204140:	2b00      	cmp	r3, #0
  204142:	f000 8170 	beq.w	204426 <LCD_DrawCircle+0xb0a>
   	 uint16_t fillWidth, fillHeight=0;
  204146:	2300      	movs	r3, #0
  204148:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
		_StartDrawLine(posBuff,bkX,x,y);
  20414c:	6a38      	ldr	r0, [r7, #32]
  20414e:	69f9      	ldr	r1, [r7, #28]
  204150:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  204154:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
  204158:	f000 fe22 	bl	204da0 <_StartDrawLine>
		fillWidth=0;
  20415c:	2300      	movs	r3, #0
  20415e:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
		for(int i=0;i<buf[0];++i){
  204162:	2300      	movs	r3, #0
  204164:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  204168:	e03d      	b.n	2041e6 <LCD_DrawCircle+0x8ca>
  20416a:	bf00      	nop
  20416c:	2000205c 	.word	0x2000205c
			_IncDrawPos(bkX-buf[i+1]);	_CopyDrawPos(); k+=buf[i+1];	if(i>0) _DrawRight(2*fillWidth,FillColor);	_SetCopyDrawPos();	fillHeight++;
  204170:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  204174:	3301      	adds	r3, #1
  204176:	4ac5      	ldr	r2, [pc, #788]	; (20448c <LCD_DrawCircle+0xb70>)
  204178:	5cd3      	ldrb	r3, [r2, r3]
  20417a:	461a      	mov	r2, r3
  20417c:	69fb      	ldr	r3, [r7, #28]
  20417e:	1a9b      	subs	r3, r3, r2
  204180:	4618      	mov	r0, r3
  204182:	f000 fdfb 	bl	204d7c <_IncDrawPos>
  204186:	f000 fdd9 	bl	204d3c <_CopyDrawPos>
  20418a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20418e:	3301      	adds	r3, #1
  204190:	4abe      	ldr	r2, [pc, #760]	; (20448c <LCD_DrawCircle+0xb70>)
  204192:	5cd3      	ldrb	r3, [r2, r3]
  204194:	461a      	mov	r2, r3
  204196:	4bbe      	ldr	r3, [pc, #760]	; (204490 <LCD_DrawCircle+0xb74>)
  204198:	681b      	ldr	r3, [r3, #0]
  20419a:	4413      	add	r3, r2
  20419c:	4abc      	ldr	r2, [pc, #752]	; (204490 <LCD_DrawCircle+0xb74>)
  20419e:	6013      	str	r3, [r2, #0]
  2041a0:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2041a4:	2b00      	cmp	r3, #0
  2041a6:	dd07      	ble.n	2041b8 <LCD_DrawCircle+0x89c>
  2041a8:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  2041ac:	005b      	lsls	r3, r3, #1
  2041ae:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2041b0:	4611      	mov	r1, r2
  2041b2:	4618      	mov	r0, r3
  2041b4:	f000 fe72 	bl	204e9c <_DrawRight>
  2041b8:	f000 fdd0 	bl	204d5c <_SetCopyDrawPos>
  2041bc:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
  2041c0:	3301      	adds	r3, #1
  2041c2:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
			fillWidth += buf[i+1];
  2041c6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2041ca:	3301      	adds	r3, #1
  2041cc:	4aaf      	ldr	r2, [pc, #700]	; (20448c <LCD_DrawCircle+0xb70>)
  2041ce:	5cd3      	ldrb	r3, [r2, r3]
  2041d0:	b29a      	uxth	r2, r3
  2041d2:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  2041d6:	4413      	add	r3, r2
  2041d8:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
		for(int i=0;i<buf[0];++i){
  2041dc:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2041e0:	3301      	adds	r3, #1
  2041e2:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  2041e6:	4ba9      	ldr	r3, [pc, #676]	; (20448c <LCD_DrawCircle+0xb70>)
  2041e8:	781b      	ldrb	r3, [r3, #0]
  2041ea:	461a      	mov	r2, r3
  2041ec:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2041f0:	429a      	cmp	r2, r3
  2041f2:	dcbd      	bgt.n	204170 <LCD_DrawCircle+0x854>
		for(int i=0;i<buf[0];++i){
  2041f4:	2300      	movs	r3, #0
  2041f6:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  2041fa:	e05a      	b.n	2042b2 <LCD_DrawCircle+0x996>
			fillWidth++;
  2041fc:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  204200:	3301      	adds	r3, #1
  204202:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
			_IncDrawPos(-1);
  204206:	f04f 30ff 	mov.w	r0, #4294967295
  20420a:	f000 fdb7 	bl	204d7c <_IncDrawPos>
			for(int j=0; j<buf[buf[0]-i]; ++j){
  20420e:	2300      	movs	r3, #0
  204210:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  204214:	e03b      	b.n	20428e <LCD_DrawCircle+0x972>
				_IncDrawPos(bkX);	_CopyDrawPos(); if(j==buf[buf[0]-i]-1){k+=1;_DrawRight(2*(fillWidth-1),FillColor);}else{k+=2;_DrawRight(2*(fillWidth-2),FillColor);}	_SetCopyDrawPos();	fillHeight++;
  204216:	69fb      	ldr	r3, [r7, #28]
  204218:	4618      	mov	r0, r3
  20421a:	f000 fdaf 	bl	204d7c <_IncDrawPos>
  20421e:	f000 fd8d 	bl	204d3c <_CopyDrawPos>
  204222:	4b9a      	ldr	r3, [pc, #616]	; (20448c <LCD_DrawCircle+0xb70>)
  204224:	781b      	ldrb	r3, [r3, #0]
  204226:	461a      	mov	r2, r3
  204228:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  20422c:	1ad3      	subs	r3, r2, r3
  20422e:	4a97      	ldr	r2, [pc, #604]	; (20448c <LCD_DrawCircle+0xb70>)
  204230:	5cd3      	ldrb	r3, [r2, r3]
  204232:	1e5a      	subs	r2, r3, #1
  204234:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  204238:	429a      	cmp	r2, r3
  20423a:	d10e      	bne.n	20425a <LCD_DrawCircle+0x93e>
  20423c:	4b94      	ldr	r3, [pc, #592]	; (204490 <LCD_DrawCircle+0xb74>)
  20423e:	681b      	ldr	r3, [r3, #0]
  204240:	3301      	adds	r3, #1
  204242:	4a93      	ldr	r2, [pc, #588]	; (204490 <LCD_DrawCircle+0xb74>)
  204244:	6013      	str	r3, [r2, #0]
  204246:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  20424a:	3b01      	subs	r3, #1
  20424c:	005b      	lsls	r3, r3, #1
  20424e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  204250:	4611      	mov	r1, r2
  204252:	4618      	mov	r0, r3
  204254:	f000 fe22 	bl	204e9c <_DrawRight>
  204258:	e00d      	b.n	204276 <LCD_DrawCircle+0x95a>
  20425a:	4b8d      	ldr	r3, [pc, #564]	; (204490 <LCD_DrawCircle+0xb74>)
  20425c:	681b      	ldr	r3, [r3, #0]
  20425e:	3302      	adds	r3, #2
  204260:	4a8b      	ldr	r2, [pc, #556]	; (204490 <LCD_DrawCircle+0xb74>)
  204262:	6013      	str	r3, [r2, #0]
  204264:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  204268:	3b02      	subs	r3, #2
  20426a:	005b      	lsls	r3, r3, #1
  20426c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  20426e:	4611      	mov	r1, r2
  204270:	4618      	mov	r0, r3
  204272:	f000 fe13 	bl	204e9c <_DrawRight>
  204276:	f000 fd71 	bl	204d5c <_SetCopyDrawPos>
  20427a:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
  20427e:	3301      	adds	r3, #1
  204280:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
			for(int j=0; j<buf[buf[0]-i]; ++j){
  204284:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  204288:	3301      	adds	r3, #1
  20428a:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  20428e:	4b7f      	ldr	r3, [pc, #508]	; (20448c <LCD_DrawCircle+0xb70>)
  204290:	781b      	ldrb	r3, [r3, #0]
  204292:	461a      	mov	r2, r3
  204294:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  204298:	1ad3      	subs	r3, r2, r3
  20429a:	4a7c      	ldr	r2, [pc, #496]	; (20448c <LCD_DrawCircle+0xb70>)
  20429c:	5cd3      	ldrb	r3, [r2, r3]
  20429e:	461a      	mov	r2, r3
  2042a0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  2042a4:	429a      	cmp	r2, r3
  2042a6:	dcb6      	bgt.n	204216 <LCD_DrawCircle+0x8fa>
		for(int i=0;i<buf[0];++i){
  2042a8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2042ac:	3301      	adds	r3, #1
  2042ae:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  2042b2:	4b76      	ldr	r3, [pc, #472]	; (20448c <LCD_DrawCircle+0xb70>)
  2042b4:	781b      	ldrb	r3, [r3, #0]
  2042b6:	461a      	mov	r2, r3
  2042b8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2042bc:	429a      	cmp	r2, r3
  2042be:	dc9d      	bgt.n	2041fc <LCD_DrawCircle+0x8e0>
		fillHeight = 2*fillHeight-1;
  2042c0:	f8b7 3094 	ldrh.w	r3, [r7, #148]	; 0x94
  2042c4:	005b      	lsls	r3, r3, #1
  2042c6:	b29b      	uxth	r3, r3
  2042c8:	3b01      	subs	r3, #1
  2042ca:	f8a7 3094 	strh.w	r3, [r7, #148]	; 0x94
		_StartDrawLine(posBuff,bkX,x,y+fillHeight);
  2042ce:	f8b7 2094 	ldrh.w	r2, [r7, #148]	; 0x94
  2042d2:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  2042d6:	4413      	add	r3, r2
  2042d8:	6a38      	ldr	r0, [r7, #32]
  2042da:	69f9      	ldr	r1, [r7, #28]
  2042dc:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
  2042e0:	f000 fd5e 	bl	204da0 <_StartDrawLine>
		fillWidth=0;
  2042e4:	2300      	movs	r3, #0
  2042e6:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
		for(int i=0;i<buf[0];++i){
  2042ea:	2300      	movs	r3, #0
  2042ec:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  2042f0:	e035      	b.n	20435e <LCD_DrawCircle+0xa42>
			_IncDrawPos(-bkX-buf[i+1]);	_CopyDrawPos();	 k+=buf[i+1];	if(i>0) _DrawRight(2*fillWidth,FillColor);	_SetCopyDrawPos();
  2042f2:	69fb      	ldr	r3, [r7, #28]
  2042f4:	425b      	negs	r3, r3
  2042f6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  2042fa:	3201      	adds	r2, #1
  2042fc:	4963      	ldr	r1, [pc, #396]	; (20448c <LCD_DrawCircle+0xb70>)
  2042fe:	5c8a      	ldrb	r2, [r1, r2]
  204300:	1a9b      	subs	r3, r3, r2
  204302:	4618      	mov	r0, r3
  204304:	f000 fd3a 	bl	204d7c <_IncDrawPos>
  204308:	f000 fd18 	bl	204d3c <_CopyDrawPos>
  20430c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  204310:	3301      	adds	r3, #1
  204312:	4a5e      	ldr	r2, [pc, #376]	; (20448c <LCD_DrawCircle+0xb70>)
  204314:	5cd3      	ldrb	r3, [r2, r3]
  204316:	461a      	mov	r2, r3
  204318:	4b5d      	ldr	r3, [pc, #372]	; (204490 <LCD_DrawCircle+0xb74>)
  20431a:	681b      	ldr	r3, [r3, #0]
  20431c:	4413      	add	r3, r2
  20431e:	4a5c      	ldr	r2, [pc, #368]	; (204490 <LCD_DrawCircle+0xb74>)
  204320:	6013      	str	r3, [r2, #0]
  204322:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  204326:	2b00      	cmp	r3, #0
  204328:	dd07      	ble.n	20433a <LCD_DrawCircle+0xa1e>
  20432a:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  20432e:	005b      	lsls	r3, r3, #1
  204330:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  204332:	4611      	mov	r1, r2
  204334:	4618      	mov	r0, r3
  204336:	f000 fdb1 	bl	204e9c <_DrawRight>
  20433a:	f000 fd0f 	bl	204d5c <_SetCopyDrawPos>
			fillWidth += buf[i+1];
  20433e:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  204342:	3301      	adds	r3, #1
  204344:	4a51      	ldr	r2, [pc, #324]	; (20448c <LCD_DrawCircle+0xb70>)
  204346:	5cd3      	ldrb	r3, [r2, r3]
  204348:	b29a      	uxth	r2, r3
  20434a:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  20434e:	4413      	add	r3, r2
  204350:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
		for(int i=0;i<buf[0];++i){
  204354:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  204358:	3301      	adds	r3, #1
  20435a:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  20435e:	4b4b      	ldr	r3, [pc, #300]	; (20448c <LCD_DrawCircle+0xb70>)
  204360:	781b      	ldrb	r3, [r3, #0]
  204362:	461a      	mov	r2, r3
  204364:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  204368:	429a      	cmp	r2, r3
  20436a:	dcc2      	bgt.n	2042f2 <LCD_DrawCircle+0x9d6>
		for(int i=0;i<buf[0];++i){
  20436c:	2300      	movs	r3, #0
  20436e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  204372:	e051      	b.n	204418 <LCD_DrawCircle+0xafc>
			fillWidth++;
  204374:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  204378:	3301      	adds	r3, #1
  20437a:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96
			_IncDrawPos(-1);
  20437e:	f04f 30ff 	mov.w	r0, #4294967295
  204382:	f000 fcfb 	bl	204d7c <_IncDrawPos>
			for(int j=0; j<buf[buf[0]-i]; ++j){
  204386:	2300      	movs	r3, #0
  204388:	67fb      	str	r3, [r7, #124]	; 0x7c
  20438a:	e034      	b.n	2043f6 <LCD_DrawCircle+0xada>
				_IncDrawPos(-bkX);	_CopyDrawPos();  if(j==buf[buf[0]-i]-1){k+=1;_DrawRight(2*(fillWidth-1),FillColor);}else{k+=2;_DrawRight(2*(fillWidth-2),FillColor);}	 _SetCopyDrawPos();
  20438c:	69fb      	ldr	r3, [r7, #28]
  20438e:	425b      	negs	r3, r3
  204390:	4618      	mov	r0, r3
  204392:	f000 fcf3 	bl	204d7c <_IncDrawPos>
  204396:	f000 fcd1 	bl	204d3c <_CopyDrawPos>
  20439a:	4b3c      	ldr	r3, [pc, #240]	; (20448c <LCD_DrawCircle+0xb70>)
  20439c:	781b      	ldrb	r3, [r3, #0]
  20439e:	461a      	mov	r2, r3
  2043a0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  2043a4:	1ad3      	subs	r3, r2, r3
  2043a6:	4a39      	ldr	r2, [pc, #228]	; (20448c <LCD_DrawCircle+0xb70>)
  2043a8:	5cd3      	ldrb	r3, [r2, r3]
  2043aa:	1e5a      	subs	r2, r3, #1
  2043ac:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2043ae:	429a      	cmp	r2, r3
  2043b0:	d10e      	bne.n	2043d0 <LCD_DrawCircle+0xab4>
  2043b2:	4b37      	ldr	r3, [pc, #220]	; (204490 <LCD_DrawCircle+0xb74>)
  2043b4:	681b      	ldr	r3, [r3, #0]
  2043b6:	3301      	adds	r3, #1
  2043b8:	4a35      	ldr	r2, [pc, #212]	; (204490 <LCD_DrawCircle+0xb74>)
  2043ba:	6013      	str	r3, [r2, #0]
  2043bc:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  2043c0:	3b01      	subs	r3, #1
  2043c2:	005b      	lsls	r3, r3, #1
  2043c4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2043c6:	4611      	mov	r1, r2
  2043c8:	4618      	mov	r0, r3
  2043ca:	f000 fd67 	bl	204e9c <_DrawRight>
  2043ce:	e00d      	b.n	2043ec <LCD_DrawCircle+0xad0>
  2043d0:	4b2f      	ldr	r3, [pc, #188]	; (204490 <LCD_DrawCircle+0xb74>)
  2043d2:	681b      	ldr	r3, [r3, #0]
  2043d4:	3302      	adds	r3, #2
  2043d6:	4a2e      	ldr	r2, [pc, #184]	; (204490 <LCD_DrawCircle+0xb74>)
  2043d8:	6013      	str	r3, [r2, #0]
  2043da:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
  2043de:	3b02      	subs	r3, #2
  2043e0:	005b      	lsls	r3, r3, #1
  2043e2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2043e4:	4611      	mov	r1, r2
  2043e6:	4618      	mov	r0, r3
  2043e8:	f000 fd58 	bl	204e9c <_DrawRight>
  2043ec:	f000 fcb6 	bl	204d5c <_SetCopyDrawPos>
			for(int j=0; j<buf[buf[0]-i]; ++j){
  2043f0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2043f2:	3301      	adds	r3, #1
  2043f4:	67fb      	str	r3, [r7, #124]	; 0x7c
  2043f6:	4b25      	ldr	r3, [pc, #148]	; (20448c <LCD_DrawCircle+0xb70>)
  2043f8:	781b      	ldrb	r3, [r3, #0]
  2043fa:	461a      	mov	r2, r3
  2043fc:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  204400:	1ad3      	subs	r3, r2, r3
  204402:	4a22      	ldr	r2, [pc, #136]	; (20448c <LCD_DrawCircle+0xb70>)
  204404:	5cd3      	ldrb	r3, [r2, r3]
  204406:	461a      	mov	r2, r3
  204408:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20440a:	429a      	cmp	r2, r3
  20440c:	dcbe      	bgt.n	20438c <LCD_DrawCircle+0xa70>
		for(int i=0;i<buf[0];++i){
  20440e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  204412:	3301      	adds	r3, #1
  204414:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  204418:	4b1c      	ldr	r3, [pc, #112]	; (20448c <LCD_DrawCircle+0xb70>)
  20441a:	781b      	ldrb	r3, [r3, #0]
  20441c:	461a      	mov	r2, r3
  20441e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  204422:	429a      	cmp	r2, r3
  204424:	dca6      	bgt.n	204374 <LCD_DrawCircle+0xa58>
	if(param==Percent_Circle && circleFlag)
  204426:	f8b7 3056 	ldrh.w	r3, [r7, #86]	; 0x56
  20442a:	2b04      	cmp	r3, #4
  20442c:	f040 82f7 	bne.w	204a1e <LCD_DrawCircle+0x1102>
  204430:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
  204434:	2b00      	cmp	r3, #0
  204436:	f000 82f2 	beq.w	204a1e <LCD_DrawCircle+0x1102>
		int circleLinesLenCorrect=0;
  20443a:	2300      	movs	r3, #0
  20443c:	67bb      	str	r3, [r7, #120]	; 0x78
		uint16_t fillWidth=0, fillHeight=0;
  20443e:	2300      	movs	r3, #0
  204440:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
  204444:	2300      	movs	r3, #0
  204446:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
		for(int i=0;i<Circle.degree[0];++i)
  20444a:	2300      	movs	r3, #0
  20444c:	673b      	str	r3, [r7, #112]	; 0x70
  20444e:	e15c      	b.n	20470a <LCD_DrawCircle+0xdee>
			if(IS_RANGE(Circle.degree[1+i],46,89)){
  204450:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204452:	3301      	adds	r3, #1
  204454:	4a0d      	ldr	r2, [pc, #52]	; (20448c <LCD_DrawCircle+0xb70>)
  204456:	f503 7382 	add.w	r3, r3, #260	; 0x104
  20445a:	005b      	lsls	r3, r3, #1
  20445c:	4413      	add	r3, r2
  20445e:	889b      	ldrh	r3, [r3, #4]
  204460:	2b2d      	cmp	r3, #45	; 0x2d
  204462:	d917      	bls.n	204494 <LCD_DrawCircle+0xb78>
  204464:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204466:	3301      	adds	r3, #1
  204468:	4a08      	ldr	r2, [pc, #32]	; (20448c <LCD_DrawCircle+0xb70>)
  20446a:	f503 7382 	add.w	r3, r3, #260	; 0x104
  20446e:	005b      	lsls	r3, r3, #1
  204470:	4413      	add	r3, r2
  204472:	889b      	ldrh	r3, [r3, #4]
  204474:	2b59      	cmp	r3, #89	; 0x59
  204476:	d80d      	bhi.n	204494 <LCD_DrawCircle+0xb78>
				if(Circle.width<150) circleLinesLenCorrect=-1;
  204478:	4b04      	ldr	r3, [pc, #16]	; (20448c <LCD_DrawCircle+0xb70>)
  20447a:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  20447e:	2b95      	cmp	r3, #149	; 0x95
  204480:	f200 8080 	bhi.w	204584 <LCD_DrawCircle+0xc68>
  204484:	f04f 33ff 	mov.w	r3, #4294967295
  204488:	67bb      	str	r3, [r7, #120]	; 0x78
  20448a:	e07b      	b.n	204584 <LCD_DrawCircle+0xc68>
  20448c:	2000205c 	.word	0x2000205c
  204490:	20001870 	.word	0x20001870
			else if(IS_RANGE(Circle.degree[1+i],113,157)) circleLinesLenCorrect=2;  //to w fazie koncowej trzeba uregulowac ostatecznie
  204494:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204496:	3301      	adds	r3, #1
  204498:	4aa5      	ldr	r2, [pc, #660]	; (204730 <LCD_DrawCircle+0xe14>)
  20449a:	f503 7382 	add.w	r3, r3, #260	; 0x104
  20449e:	005b      	lsls	r3, r3, #1
  2044a0:	4413      	add	r3, r2
  2044a2:	889b      	ldrh	r3, [r3, #4]
  2044a4:	2b70      	cmp	r3, #112	; 0x70
  2044a6:	d90c      	bls.n	2044c2 <LCD_DrawCircle+0xba6>
  2044a8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2044aa:	3301      	adds	r3, #1
  2044ac:	4aa0      	ldr	r2, [pc, #640]	; (204730 <LCD_DrawCircle+0xe14>)
  2044ae:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2044b2:	005b      	lsls	r3, r3, #1
  2044b4:	4413      	add	r3, r2
  2044b6:	889b      	ldrh	r3, [r3, #4]
  2044b8:	2b9d      	cmp	r3, #157	; 0x9d
  2044ba:	d802      	bhi.n	2044c2 <LCD_DrawCircle+0xba6>
  2044bc:	2302      	movs	r3, #2
  2044be:	67bb      	str	r3, [r7, #120]	; 0x78
  2044c0:	e060      	b.n	204584 <LCD_DrawCircle+0xc68>
			else if(IS_RANGE(Circle.degree[1+i],201,247)) circleLinesLenCorrect=3;
  2044c2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2044c4:	3301      	adds	r3, #1
  2044c6:	4a9a      	ldr	r2, [pc, #616]	; (204730 <LCD_DrawCircle+0xe14>)
  2044c8:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2044cc:	005b      	lsls	r3, r3, #1
  2044ce:	4413      	add	r3, r2
  2044d0:	889b      	ldrh	r3, [r3, #4]
  2044d2:	2bc8      	cmp	r3, #200	; 0xc8
  2044d4:	d90c      	bls.n	2044f0 <LCD_DrawCircle+0xbd4>
  2044d6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2044d8:	3301      	adds	r3, #1
  2044da:	4a95      	ldr	r2, [pc, #596]	; (204730 <LCD_DrawCircle+0xe14>)
  2044dc:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2044e0:	005b      	lsls	r3, r3, #1
  2044e2:	4413      	add	r3, r2
  2044e4:	889b      	ldrh	r3, [r3, #4]
  2044e6:	2bf7      	cmp	r3, #247	; 0xf7
  2044e8:	d802      	bhi.n	2044f0 <LCD_DrawCircle+0xbd4>
  2044ea:	2303      	movs	r3, #3
  2044ec:	67bb      	str	r3, [r7, #120]	; 0x78
  2044ee:	e049      	b.n	204584 <LCD_DrawCircle+0xc68>
			else if(IS_RANGE(Circle.degree[1+i],270,292)) circleLinesLenCorrect=-1;
  2044f0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2044f2:	3301      	adds	r3, #1
  2044f4:	4a8e      	ldr	r2, [pc, #568]	; (204730 <LCD_DrawCircle+0xe14>)
  2044f6:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2044fa:	005b      	lsls	r3, r3, #1
  2044fc:	4413      	add	r3, r2
  2044fe:	889b      	ldrh	r3, [r3, #4]
  204500:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  204504:	d30e      	bcc.n	204524 <LCD_DrawCircle+0xc08>
  204506:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204508:	3301      	adds	r3, #1
  20450a:	4a89      	ldr	r2, [pc, #548]	; (204730 <LCD_DrawCircle+0xe14>)
  20450c:	f503 7382 	add.w	r3, r3, #260	; 0x104
  204510:	005b      	lsls	r3, r3, #1
  204512:	4413      	add	r3, r2
  204514:	889b      	ldrh	r3, [r3, #4]
  204516:	f5b3 7f92 	cmp.w	r3, #292	; 0x124
  20451a:	d803      	bhi.n	204524 <LCD_DrawCircle+0xc08>
  20451c:	f04f 33ff 	mov.w	r3, #4294967295
  204520:	67bb      	str	r3, [r7, #120]	; 0x78
  204522:	e02f      	b.n	204584 <LCD_DrawCircle+0xc68>
			else if(IS_RANGE(Circle.degree[1+i],293,338)){
  204524:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204526:	3301      	adds	r3, #1
  204528:	4a81      	ldr	r2, [pc, #516]	; (204730 <LCD_DrawCircle+0xe14>)
  20452a:	f503 7382 	add.w	r3, r3, #260	; 0x104
  20452e:	005b      	lsls	r3, r3, #1
  204530:	4413      	add	r3, r2
  204532:	889b      	ldrh	r3, [r3, #4]
  204534:	f5b3 7f92 	cmp.w	r3, #292	; 0x124
  204538:	d924      	bls.n	204584 <LCD_DrawCircle+0xc68>
  20453a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  20453c:	3301      	adds	r3, #1
  20453e:	4a7c      	ldr	r2, [pc, #496]	; (204730 <LCD_DrawCircle+0xe14>)
  204540:	f503 7382 	add.w	r3, r3, #260	; 0x104
  204544:	005b      	lsls	r3, r3, #1
  204546:	4413      	add	r3, r2
  204548:	889b      	ldrh	r3, [r3, #4]
  20454a:	f5b3 7fa9 	cmp.w	r3, #338	; 0x152
  20454e:	d819      	bhi.n	204584 <LCD_DrawCircle+0xc68>
				  	  if((Circle.width>100)&&(Circle.width<260)) circleLinesLenCorrect=1;
  204550:	4b77      	ldr	r3, [pc, #476]	; (204730 <LCD_DrawCircle+0xe14>)
  204552:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  204556:	2b64      	cmp	r3, #100	; 0x64
  204558:	d908      	bls.n	20456c <LCD_DrawCircle+0xc50>
  20455a:	4b75      	ldr	r3, [pc, #468]	; (204730 <LCD_DrawCircle+0xe14>)
  20455c:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  204560:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  204564:	d202      	bcs.n	20456c <LCD_DrawCircle+0xc50>
  204566:	2301      	movs	r3, #1
  204568:	67bb      	str	r3, [r7, #120]	; 0x78
  20456a:	e00b      	b.n	204584 <LCD_DrawCircle+0xc68>
				  	  else if(Circle.width>260) 						circleLinesLenCorrect=2;
  20456c:	4b70      	ldr	r3, [pc, #448]	; (204730 <LCD_DrawCircle+0xe14>)
  20456e:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  204572:	f5b3 7f82 	cmp.w	r3, #260	; 0x104
  204576:	d902      	bls.n	20457e <LCD_DrawCircle+0xc62>
  204578:	2302      	movs	r3, #2
  20457a:	67bb      	str	r3, [r7, #120]	; 0x78
  20457c:	e002      	b.n	204584 <LCD_DrawCircle+0xc68>
				  	  else													circleLinesLenCorrect=-1;
  20457e:	f04f 33ff 	mov.w	r3, #4294967295
  204582:	67bb      	str	r3, [r7, #120]	; 0x78
			if(i==0)
  204584:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204586:	2b00      	cmp	r3, #0
  204588:	d13b      	bne.n	204602 <LCD_DrawCircle+0xce6>
				DrawLine(0,Circle.x0,Circle.y0,(Circle.width-4-circleLinesLenCorrect)/2-1,Circle.degree[1+i],FrameColor,BkpSizeX, Circle.outRatioStart,Circle.inRatioStart,_FillColor,Circle.degColor[i+1]);
  20458a:	4b69      	ldr	r3, [pc, #420]	; (204730 <LCD_DrawCircle+0xe14>)
  20458c:	f8b3 0208 	ldrh.w	r0, [r3, #520]	; 0x208
  204590:	4b67      	ldr	r3, [pc, #412]	; (204730 <LCD_DrawCircle+0xe14>)
  204592:	f8b3 420a 	ldrh.w	r4, [r3, #522]	; 0x20a
  204596:	4b66      	ldr	r3, [pc, #408]	; (204730 <LCD_DrawCircle+0xe14>)
  204598:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  20459c:	1f1a      	subs	r2, r3, #4
  20459e:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  2045a0:	1ad3      	subs	r3, r2, r3
  2045a2:	2b00      	cmp	r3, #0
  2045a4:	da00      	bge.n	2045a8 <LCD_DrawCircle+0xc8c>
  2045a6:	3301      	adds	r3, #1
  2045a8:	105b      	asrs	r3, r3, #1
  2045aa:	b29b      	uxth	r3, r3
  2045ac:	3b01      	subs	r3, #1
  2045ae:	b29d      	uxth	r5, r3
  2045b0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2045b2:	3301      	adds	r3, #1
  2045b4:	4a5e      	ldr	r2, [pc, #376]	; (204730 <LCD_DrawCircle+0xe14>)
  2045b6:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2045ba:	005b      	lsls	r3, r3, #1
  2045bc:	4413      	add	r3, r2
  2045be:	889a      	ldrh	r2, [r3, #4]
  2045c0:	4b5b      	ldr	r3, [pc, #364]	; (204730 <LCD_DrawCircle+0xe14>)
  2045c2:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  2045c6:	4b5a      	ldr	r3, [pc, #360]	; (204730 <LCD_DrawCircle+0xe14>)
  2045c8:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  2045cc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2045ce:	3301      	adds	r3, #1
  2045d0:	4957      	ldr	r1, [pc, #348]	; (204730 <LCD_DrawCircle+0xe14>)
  2045d2:	3388      	adds	r3, #136	; 0x88
  2045d4:	009b      	lsls	r3, r3, #2
  2045d6:	440b      	add	r3, r1
  2045d8:	6859      	ldr	r1, [r3, #4]
  2045da:	69bb      	ldr	r3, [r7, #24]
  2045dc:	9104      	str	r1, [sp, #16]
  2045de:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
  2045e2:	9103      	str	r1, [sp, #12]
  2045e4:	68f9      	ldr	r1, [r7, #12]
  2045e6:	9102      	str	r1, [sp, #8]
  2045e8:	9301      	str	r3, [sp, #4]
  2045ea:	9200      	str	r2, [sp, #0]
  2045ec:	eef0 0a47 	vmov.f32	s1, s14
  2045f0:	eeb0 0a67 	vmov.f32	s0, s15
  2045f4:	462b      	mov	r3, r5
  2045f6:	4622      	mov	r2, r4
  2045f8:	4601      	mov	r1, r0
  2045fa:	2000      	movs	r0, #0
  2045fc:	f001 fce8 	bl	205fd0 <DrawLine>
  204600:	e080      	b.n	204704 <LCD_DrawCircle+0xde8>
			else if(i==Circle.degree[0]-1)
  204602:	4b4b      	ldr	r3, [pc, #300]	; (204730 <LCD_DrawCircle+0xe14>)
  204604:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  204608:	1e5a      	subs	r2, r3, #1
  20460a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  20460c:	429a      	cmp	r2, r3
  20460e:	d13a      	bne.n	204686 <LCD_DrawCircle+0xd6a>
				DrawLine(0,Circle.x0,Circle.y0,(Circle.width-4-circleLinesLenCorrect)/2-1,Circle.degree[1+i],FrameColor,BkpSizeX, Circle.outRatioStart,Circle.inRatioStart,Circle.degColor[i],_FillColor);
  204610:	4b47      	ldr	r3, [pc, #284]	; (204730 <LCD_DrawCircle+0xe14>)
  204612:	f8b3 4208 	ldrh.w	r4, [r3, #520]	; 0x208
  204616:	4b46      	ldr	r3, [pc, #280]	; (204730 <LCD_DrawCircle+0xe14>)
  204618:	f8b3 520a 	ldrh.w	r5, [r3, #522]	; 0x20a
  20461c:	4b44      	ldr	r3, [pc, #272]	; (204730 <LCD_DrawCircle+0xe14>)
  20461e:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  204622:	1f1a      	subs	r2, r3, #4
  204624:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  204626:	1ad3      	subs	r3, r2, r3
  204628:	2b00      	cmp	r3, #0
  20462a:	da00      	bge.n	20462e <LCD_DrawCircle+0xd12>
  20462c:	3301      	adds	r3, #1
  20462e:	105b      	asrs	r3, r3, #1
  204630:	b29b      	uxth	r3, r3
  204632:	3b01      	subs	r3, #1
  204634:	b29e      	uxth	r6, r3
  204636:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204638:	3301      	adds	r3, #1
  20463a:	4a3d      	ldr	r2, [pc, #244]	; (204730 <LCD_DrawCircle+0xe14>)
  20463c:	f503 7382 	add.w	r3, r3, #260	; 0x104
  204640:	005b      	lsls	r3, r3, #1
  204642:	4413      	add	r3, r2
  204644:	889a      	ldrh	r2, [r3, #4]
  204646:	4b3a      	ldr	r3, [pc, #232]	; (204730 <LCD_DrawCircle+0xe14>)
  204648:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  20464c:	4b38      	ldr	r3, [pc, #224]	; (204730 <LCD_DrawCircle+0xe14>)
  20464e:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  204652:	4937      	ldr	r1, [pc, #220]	; (204730 <LCD_DrawCircle+0xe14>)
  204654:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204656:	3388      	adds	r3, #136	; 0x88
  204658:	009b      	lsls	r3, r3, #2
  20465a:	440b      	add	r3, r1
  20465c:	6859      	ldr	r1, [r3, #4]
  20465e:	69bb      	ldr	r3, [r7, #24]
  204660:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
  204664:	9004      	str	r0, [sp, #16]
  204666:	9103      	str	r1, [sp, #12]
  204668:	68f9      	ldr	r1, [r7, #12]
  20466a:	9102      	str	r1, [sp, #8]
  20466c:	9301      	str	r3, [sp, #4]
  20466e:	9200      	str	r2, [sp, #0]
  204670:	eef0 0a47 	vmov.f32	s1, s14
  204674:	eeb0 0a67 	vmov.f32	s0, s15
  204678:	4633      	mov	r3, r6
  20467a:	462a      	mov	r2, r5
  20467c:	4621      	mov	r1, r4
  20467e:	2000      	movs	r0, #0
  204680:	f001 fca6 	bl	205fd0 <DrawLine>
  204684:	e03e      	b.n	204704 <LCD_DrawCircle+0xde8>
				DrawLine(0,Circle.x0,Circle.y0,(Circle.width-4-circleLinesLenCorrect)/2-1,Circle.degree[1+i],FrameColor,BkpSizeX, Circle.outRatioStart,Circle.inRatioStart,Circle.degColor[i],Circle.degColor[i+1]);
  204686:	4b2a      	ldr	r3, [pc, #168]	; (204730 <LCD_DrawCircle+0xe14>)
  204688:	f8b3 4208 	ldrh.w	r4, [r3, #520]	; 0x208
  20468c:	4b28      	ldr	r3, [pc, #160]	; (204730 <LCD_DrawCircle+0xe14>)
  20468e:	f8b3 520a 	ldrh.w	r5, [r3, #522]	; 0x20a
  204692:	4b27      	ldr	r3, [pc, #156]	; (204730 <LCD_DrawCircle+0xe14>)
  204694:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  204698:	1f1a      	subs	r2, r3, #4
  20469a:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  20469c:	1ad3      	subs	r3, r2, r3
  20469e:	2b00      	cmp	r3, #0
  2046a0:	da00      	bge.n	2046a4 <LCD_DrawCircle+0xd88>
  2046a2:	3301      	adds	r3, #1
  2046a4:	105b      	asrs	r3, r3, #1
  2046a6:	b29b      	uxth	r3, r3
  2046a8:	3b01      	subs	r3, #1
  2046aa:	b29e      	uxth	r6, r3
  2046ac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2046ae:	3301      	adds	r3, #1
  2046b0:	4a1f      	ldr	r2, [pc, #124]	; (204730 <LCD_DrawCircle+0xe14>)
  2046b2:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2046b6:	005b      	lsls	r3, r3, #1
  2046b8:	4413      	add	r3, r2
  2046ba:	889a      	ldrh	r2, [r3, #4]
  2046bc:	4b1c      	ldr	r3, [pc, #112]	; (204730 <LCD_DrawCircle+0xe14>)
  2046be:	edd3 7a7d 	vldr	s15, [r3, #500]	; 0x1f4
  2046c2:	4b1b      	ldr	r3, [pc, #108]	; (204730 <LCD_DrawCircle+0xe14>)
  2046c4:	ed93 7a7e 	vldr	s14, [r3, #504]	; 0x1f8
  2046c8:	4919      	ldr	r1, [pc, #100]	; (204730 <LCD_DrawCircle+0xe14>)
  2046ca:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2046cc:	3388      	adds	r3, #136	; 0x88
  2046ce:	009b      	lsls	r3, r3, #2
  2046d0:	440b      	add	r3, r1
  2046d2:	6859      	ldr	r1, [r3, #4]
  2046d4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2046d6:	3301      	adds	r3, #1
  2046d8:	4815      	ldr	r0, [pc, #84]	; (204730 <LCD_DrawCircle+0xe14>)
  2046da:	3388      	adds	r3, #136	; 0x88
  2046dc:	009b      	lsls	r3, r3, #2
  2046de:	4403      	add	r3, r0
  2046e0:	6858      	ldr	r0, [r3, #4]
  2046e2:	69bb      	ldr	r3, [r7, #24]
  2046e4:	9004      	str	r0, [sp, #16]
  2046e6:	9103      	str	r1, [sp, #12]
  2046e8:	68f9      	ldr	r1, [r7, #12]
  2046ea:	9102      	str	r1, [sp, #8]
  2046ec:	9301      	str	r3, [sp, #4]
  2046ee:	9200      	str	r2, [sp, #0]
  2046f0:	eef0 0a47 	vmov.f32	s1, s14
  2046f4:	eeb0 0a67 	vmov.f32	s0, s15
  2046f8:	4633      	mov	r3, r6
  2046fa:	462a      	mov	r2, r5
  2046fc:	4621      	mov	r1, r4
  2046fe:	2000      	movs	r0, #0
  204700:	f001 fc66 	bl	205fd0 <DrawLine>
		for(int i=0;i<Circle.degree[0];++i)
  204704:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204706:	3301      	adds	r3, #1
  204708:	673b      	str	r3, [r7, #112]	; 0x70
  20470a:	4b09      	ldr	r3, [pc, #36]	; (204730 <LCD_DrawCircle+0xe14>)
  20470c:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  204710:	461a      	mov	r2, r3
  204712:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  204714:	429a      	cmp	r2, r3
  204716:	f73f ae9b 	bgt.w	204450 <LCD_DrawCircle+0xb34>
				}
				k++;
			}
		}

		_StartDrawLine(posBuff,bkX,x,y);
  20471a:	6a38      	ldr	r0, [r7, #32]
  20471c:	69f9      	ldr	r1, [r7, #28]
  20471e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  204722:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
  204726:	f000 fb3b 	bl	204da0 <_StartDrawLine>
		for(int i=0;i<buf[0];++i){
  20472a:	2300      	movs	r3, #0
  20472c:	66fb      	str	r3, [r7, #108]	; 0x6c
  20472e:	e043      	b.n	2047b8 <LCD_DrawCircle+0xe9c>
  204730:	2000205c 	.word	0x2000205c
			_IncDrawPos(bkX-buf[i+1]);	  _CopyDrawPos();   _Change_AA(buf[i+1]); 	if(i>0) _Fill(2*fillWidth); _Change_AA(buf[i+1]); _SetCopyDrawPos();	fillHeight++;
  204734:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  204736:	3301      	adds	r3, #1
  204738:	4abc      	ldr	r2, [pc, #752]	; (204a2c <LCD_DrawCircle+0x1110>)
  20473a:	5cd3      	ldrb	r3, [r2, r3]
  20473c:	461a      	mov	r2, r3
  20473e:	69fb      	ldr	r3, [r7, #28]
  204740:	1a9b      	subs	r3, r3, r2
  204742:	4618      	mov	r0, r3
  204744:	f000 fb1a 	bl	204d7c <_IncDrawPos>
  204748:	f000 faf8 	bl	204d3c <_CopyDrawPos>
  20474c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20474e:	3301      	adds	r3, #1
  204750:	4ab6      	ldr	r2, [pc, #728]	; (204a2c <LCD_DrawCircle+0x1110>)
  204752:	5cd3      	ldrb	r3, [r2, r3]
  204754:	461a      	mov	r2, r3
  204756:	f107 0318 	add.w	r3, r7, #24
  20475a:	469c      	mov	ip, r3
  20475c:	4610      	mov	r0, r2
  20475e:	f000 f967 	bl	204a30 <_Change_AA.11639>
  204762:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  204764:	2b00      	cmp	r3, #0
  204766:	dd08      	ble.n	20477a <LCD_DrawCircle+0xe5e>
  204768:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  20476c:	005a      	lsls	r2, r3, #1
  20476e:	f107 0318 	add.w	r3, r7, #24
  204772:	469c      	mov	ip, r3
  204774:	4610      	mov	r0, r2
  204776:	f7fe ffd1 	bl	20371c <_Fill.11620>
  20477a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20477c:	3301      	adds	r3, #1
  20477e:	4aab      	ldr	r2, [pc, #684]	; (204a2c <LCD_DrawCircle+0x1110>)
  204780:	5cd3      	ldrb	r3, [r2, r3]
  204782:	461a      	mov	r2, r3
  204784:	f107 0318 	add.w	r3, r7, #24
  204788:	469c      	mov	ip, r3
  20478a:	4610      	mov	r0, r2
  20478c:	f000 f950 	bl	204a30 <_Change_AA.11639>
  204790:	f000 fae4 	bl	204d5c <_SetCopyDrawPos>
  204794:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
  204798:	3301      	adds	r3, #1
  20479a:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
			fillWidth += buf[i+1];
  20479e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2047a0:	3301      	adds	r3, #1
  2047a2:	4aa2      	ldr	r2, [pc, #648]	; (204a2c <LCD_DrawCircle+0x1110>)
  2047a4:	5cd3      	ldrb	r3, [r2, r3]
  2047a6:	b29a      	uxth	r2, r3
  2047a8:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  2047ac:	4413      	add	r3, r2
  2047ae:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
		for(int i=0;i<buf[0];++i){
  2047b2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2047b4:	3301      	adds	r3, #1
  2047b6:	66fb      	str	r3, [r7, #108]	; 0x6c
  2047b8:	4b9c      	ldr	r3, [pc, #624]	; (204a2c <LCD_DrawCircle+0x1110>)
  2047ba:	781b      	ldrb	r3, [r3, #0]
  2047bc:	461a      	mov	r2, r3
  2047be:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2047c0:	429a      	cmp	r2, r3
  2047c2:	dcb7      	bgt.n	204734 <LCD_DrawCircle+0xe18>
		}

		for(int i=0;i<buf[0];++i){
  2047c4:	2300      	movs	r3, #0
  2047c6:	66bb      	str	r3, [r7, #104]	; 0x68
  2047c8:	e061      	b.n	20488e <LCD_DrawCircle+0xf72>
			fillWidth++;
  2047ca:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  2047ce:	3301      	adds	r3, #1
  2047d0:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
			_IncDrawPos(-1);
  2047d4:	f04f 30ff 	mov.w	r0, #4294967295
  2047d8:	f000 fad0 	bl	204d7c <_IncDrawPos>
			for(int j=0; j<buf[buf[0]-i]; ++j){
  2047dc:	2300      	movs	r3, #0
  2047de:	667b      	str	r3, [r7, #100]	; 0x64
  2047e0:	e047      	b.n	204872 <LCD_DrawCircle+0xf56>
				_IncDrawPos(bkX);	_CopyDrawPos(); if(j==buf[buf[0]-i]-1){ _Change_AA(1); _Fill(2*(fillWidth-1)); _Change_AA(1); }else{ _Change_AA(2); _Fill(2*(fillWidth-2)); _Change_AA(2); }	_SetCopyDrawPos();	fillHeight++;
  2047e2:	69fb      	ldr	r3, [r7, #28]
  2047e4:	4618      	mov	r0, r3
  2047e6:	f000 fac9 	bl	204d7c <_IncDrawPos>
  2047ea:	f000 faa7 	bl	204d3c <_CopyDrawPos>
  2047ee:	4b8f      	ldr	r3, [pc, #572]	; (204a2c <LCD_DrawCircle+0x1110>)
  2047f0:	781b      	ldrb	r3, [r3, #0]
  2047f2:	461a      	mov	r2, r3
  2047f4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  2047f6:	1ad3      	subs	r3, r2, r3
  2047f8:	4a8c      	ldr	r2, [pc, #560]	; (204a2c <LCD_DrawCircle+0x1110>)
  2047fa:	5cd3      	ldrb	r3, [r2, r3]
  2047fc:	1e5a      	subs	r2, r3, #1
  2047fe:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  204800:	429a      	cmp	r2, r3
  204802:	d116      	bne.n	204832 <LCD_DrawCircle+0xf16>
  204804:	f107 0318 	add.w	r3, r7, #24
  204808:	469c      	mov	ip, r3
  20480a:	2001      	movs	r0, #1
  20480c:	f000 f910 	bl	204a30 <_Change_AA.11639>
  204810:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  204814:	3b01      	subs	r3, #1
  204816:	005a      	lsls	r2, r3, #1
  204818:	f107 0318 	add.w	r3, r7, #24
  20481c:	469c      	mov	ip, r3
  20481e:	4610      	mov	r0, r2
  204820:	f7fe ff7c 	bl	20371c <_Fill.11620>
  204824:	f107 0318 	add.w	r3, r7, #24
  204828:	469c      	mov	ip, r3
  20482a:	2001      	movs	r0, #1
  20482c:	f000 f900 	bl	204a30 <_Change_AA.11639>
  204830:	e015      	b.n	20485e <LCD_DrawCircle+0xf42>
  204832:	f107 0318 	add.w	r3, r7, #24
  204836:	469c      	mov	ip, r3
  204838:	2002      	movs	r0, #2
  20483a:	f000 f8f9 	bl	204a30 <_Change_AA.11639>
  20483e:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  204842:	3b02      	subs	r3, #2
  204844:	005a      	lsls	r2, r3, #1
  204846:	f107 0318 	add.w	r3, r7, #24
  20484a:	469c      	mov	ip, r3
  20484c:	4610      	mov	r0, r2
  20484e:	f7fe ff65 	bl	20371c <_Fill.11620>
  204852:	f107 0318 	add.w	r3, r7, #24
  204856:	469c      	mov	ip, r3
  204858:	2002      	movs	r0, #2
  20485a:	f000 f8e9 	bl	204a30 <_Change_AA.11639>
  20485e:	f000 fa7d 	bl	204d5c <_SetCopyDrawPos>
  204862:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
  204866:	3301      	adds	r3, #1
  204868:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
			for(int j=0; j<buf[buf[0]-i]; ++j){
  20486c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20486e:	3301      	adds	r3, #1
  204870:	667b      	str	r3, [r7, #100]	; 0x64
  204872:	4b6e      	ldr	r3, [pc, #440]	; (204a2c <LCD_DrawCircle+0x1110>)
  204874:	781b      	ldrb	r3, [r3, #0]
  204876:	461a      	mov	r2, r3
  204878:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20487a:	1ad3      	subs	r3, r2, r3
  20487c:	4a6b      	ldr	r2, [pc, #428]	; (204a2c <LCD_DrawCircle+0x1110>)
  20487e:	5cd3      	ldrb	r3, [r2, r3]
  204880:	461a      	mov	r2, r3
  204882:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  204884:	429a      	cmp	r2, r3
  204886:	dcac      	bgt.n	2047e2 <LCD_DrawCircle+0xec6>
		for(int i=0;i<buf[0];++i){
  204888:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20488a:	3301      	adds	r3, #1
  20488c:	66bb      	str	r3, [r7, #104]	; 0x68
  20488e:	4b67      	ldr	r3, [pc, #412]	; (204a2c <LCD_DrawCircle+0x1110>)
  204890:	781b      	ldrb	r3, [r3, #0]
  204892:	461a      	mov	r2, r3
  204894:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  204896:	429a      	cmp	r2, r3
  204898:	dc97      	bgt.n	2047ca <LCD_DrawCircle+0xeae>
			}
		}

		fillHeight = 2*fillHeight-1;
  20489a:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
  20489e:	005b      	lsls	r3, r3, #1
  2048a0:	b29b      	uxth	r3, r3
  2048a2:	3b01      	subs	r3, #1
  2048a4:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74

		_StartDrawLine(posBuff,bkX,x,y+fillHeight);
  2048a8:	f8b7 2074 	ldrh.w	r2, [r7, #116]	; 0x74
  2048ac:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
  2048b0:	4413      	add	r3, r2
  2048b2:	6a38      	ldr	r0, [r7, #32]
  2048b4:	69f9      	ldr	r1, [r7, #28]
  2048b6:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
  2048ba:	f000 fa71 	bl	204da0 <_StartDrawLine>
		fillWidth=0;
  2048be:	2300      	movs	r3, #0
  2048c0:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
		for(int i=0;i<buf[0];++i){
  2048c4:	2300      	movs	r3, #0
  2048c6:	663b      	str	r3, [r7, #96]	; 0x60
  2048c8:	e03c      	b.n	204944 <LCD_DrawCircle+0x1028>
			_IncDrawPos(-bkX-buf[i+1]);	_CopyDrawPos();	_Change_AA(buf[i+1]); if(i>0) _Fill(2*fillWidth); _Change_AA(buf[i+1]);	_SetCopyDrawPos();
  2048ca:	69fb      	ldr	r3, [r7, #28]
  2048cc:	425b      	negs	r3, r3
  2048ce:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  2048d0:	3201      	adds	r2, #1
  2048d2:	4956      	ldr	r1, [pc, #344]	; (204a2c <LCD_DrawCircle+0x1110>)
  2048d4:	5c8a      	ldrb	r2, [r1, r2]
  2048d6:	1a9b      	subs	r3, r3, r2
  2048d8:	4618      	mov	r0, r3
  2048da:	f000 fa4f 	bl	204d7c <_IncDrawPos>
  2048de:	f000 fa2d 	bl	204d3c <_CopyDrawPos>
  2048e2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  2048e4:	3301      	adds	r3, #1
  2048e6:	4a51      	ldr	r2, [pc, #324]	; (204a2c <LCD_DrawCircle+0x1110>)
  2048e8:	5cd3      	ldrb	r3, [r2, r3]
  2048ea:	461a      	mov	r2, r3
  2048ec:	f107 0318 	add.w	r3, r7, #24
  2048f0:	469c      	mov	ip, r3
  2048f2:	4610      	mov	r0, r2
  2048f4:	f000 f89c 	bl	204a30 <_Change_AA.11639>
  2048f8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  2048fa:	2b00      	cmp	r3, #0
  2048fc:	dd08      	ble.n	204910 <LCD_DrawCircle+0xff4>
  2048fe:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  204902:	005a      	lsls	r2, r3, #1
  204904:	f107 0318 	add.w	r3, r7, #24
  204908:	469c      	mov	ip, r3
  20490a:	4610      	mov	r0, r2
  20490c:	f7fe ff06 	bl	20371c <_Fill.11620>
  204910:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  204912:	3301      	adds	r3, #1
  204914:	4a45      	ldr	r2, [pc, #276]	; (204a2c <LCD_DrawCircle+0x1110>)
  204916:	5cd3      	ldrb	r3, [r2, r3]
  204918:	461a      	mov	r2, r3
  20491a:	f107 0318 	add.w	r3, r7, #24
  20491e:	469c      	mov	ip, r3
  204920:	4610      	mov	r0, r2
  204922:	f000 f885 	bl	204a30 <_Change_AA.11639>
  204926:	f000 fa19 	bl	204d5c <_SetCopyDrawPos>
			fillWidth += buf[i+1];
  20492a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20492c:	3301      	adds	r3, #1
  20492e:	4a3f      	ldr	r2, [pc, #252]	; (204a2c <LCD_DrawCircle+0x1110>)
  204930:	5cd3      	ldrb	r3, [r2, r3]
  204932:	b29a      	uxth	r2, r3
  204934:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  204938:	4413      	add	r3, r2
  20493a:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
		for(int i=0;i<buf[0];++i){
  20493e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  204940:	3301      	adds	r3, #1
  204942:	663b      	str	r3, [r7, #96]	; 0x60
  204944:	4b39      	ldr	r3, [pc, #228]	; (204a2c <LCD_DrawCircle+0x1110>)
  204946:	781b      	ldrb	r3, [r3, #0]
  204948:	461a      	mov	r2, r3
  20494a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20494c:	429a      	cmp	r2, r3
  20494e:	dcbc      	bgt.n	2048ca <LCD_DrawCircle+0xfae>
		}

		for(int i=0;i<buf[0];++i){
  204950:	2300      	movs	r3, #0
  204952:	65fb      	str	r3, [r7, #92]	; 0x5c
  204954:	e05d      	b.n	204a12 <LCD_DrawCircle+0x10f6>
			fillWidth++;
  204956:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  20495a:	3301      	adds	r3, #1
  20495c:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
			_IncDrawPos(-1);
  204960:	f04f 30ff 	mov.w	r0, #4294967295
  204964:	f000 fa0a 	bl	204d7c <_IncDrawPos>
			for(int j=0; j<buf[buf[0]-i]; ++j){
  204968:	2300      	movs	r3, #0
  20496a:	65bb      	str	r3, [r7, #88]	; 0x58
  20496c:	e043      	b.n	2049f6 <LCD_DrawCircle+0x10da>
				_IncDrawPos(-bkX);	_CopyDrawPos();  if(j==buf[buf[0]-i]-1){ _Change_AA(1); _Fill(2*(fillWidth-1)); _Change_AA(1);}else{ _Change_AA(2); _Fill(2*(fillWidth-2)); _Change_AA(2);}	 _SetCopyDrawPos();
  20496e:	69fb      	ldr	r3, [r7, #28]
  204970:	425b      	negs	r3, r3
  204972:	4618      	mov	r0, r3
  204974:	f000 fa02 	bl	204d7c <_IncDrawPos>
  204978:	f000 f9e0 	bl	204d3c <_CopyDrawPos>
  20497c:	4b2b      	ldr	r3, [pc, #172]	; (204a2c <LCD_DrawCircle+0x1110>)
  20497e:	781b      	ldrb	r3, [r3, #0]
  204980:	461a      	mov	r2, r3
  204982:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  204984:	1ad3      	subs	r3, r2, r3
  204986:	4a29      	ldr	r2, [pc, #164]	; (204a2c <LCD_DrawCircle+0x1110>)
  204988:	5cd3      	ldrb	r3, [r2, r3]
  20498a:	1e5a      	subs	r2, r3, #1
  20498c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20498e:	429a      	cmp	r2, r3
  204990:	d116      	bne.n	2049c0 <LCD_DrawCircle+0x10a4>
  204992:	f107 0318 	add.w	r3, r7, #24
  204996:	469c      	mov	ip, r3
  204998:	2001      	movs	r0, #1
  20499a:	f000 f849 	bl	204a30 <_Change_AA.11639>
  20499e:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  2049a2:	3b01      	subs	r3, #1
  2049a4:	005a      	lsls	r2, r3, #1
  2049a6:	f107 0318 	add.w	r3, r7, #24
  2049aa:	469c      	mov	ip, r3
  2049ac:	4610      	mov	r0, r2
  2049ae:	f7fe feb5 	bl	20371c <_Fill.11620>
  2049b2:	f107 0318 	add.w	r3, r7, #24
  2049b6:	469c      	mov	ip, r3
  2049b8:	2001      	movs	r0, #1
  2049ba:	f000 f839 	bl	204a30 <_Change_AA.11639>
  2049be:	e015      	b.n	2049ec <LCD_DrawCircle+0x10d0>
  2049c0:	f107 0318 	add.w	r3, r7, #24
  2049c4:	469c      	mov	ip, r3
  2049c6:	2002      	movs	r0, #2
  2049c8:	f000 f832 	bl	204a30 <_Change_AA.11639>
  2049cc:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
  2049d0:	3b02      	subs	r3, #2
  2049d2:	005a      	lsls	r2, r3, #1
  2049d4:	f107 0318 	add.w	r3, r7, #24
  2049d8:	469c      	mov	ip, r3
  2049da:	4610      	mov	r0, r2
  2049dc:	f7fe fe9e 	bl	20371c <_Fill.11620>
  2049e0:	f107 0318 	add.w	r3, r7, #24
  2049e4:	469c      	mov	ip, r3
  2049e6:	2002      	movs	r0, #2
  2049e8:	f000 f822 	bl	204a30 <_Change_AA.11639>
  2049ec:	f000 f9b6 	bl	204d5c <_SetCopyDrawPos>
			for(int j=0; j<buf[buf[0]-i]; ++j){
  2049f0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  2049f2:	3301      	adds	r3, #1
  2049f4:	65bb      	str	r3, [r7, #88]	; 0x58
  2049f6:	4b0d      	ldr	r3, [pc, #52]	; (204a2c <LCD_DrawCircle+0x1110>)
  2049f8:	781b      	ldrb	r3, [r3, #0]
  2049fa:	461a      	mov	r2, r3
  2049fc:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  2049fe:	1ad3      	subs	r3, r2, r3
  204a00:	4a0a      	ldr	r2, [pc, #40]	; (204a2c <LCD_DrawCircle+0x1110>)
  204a02:	5cd3      	ldrb	r3, [r2, r3]
  204a04:	461a      	mov	r2, r3
  204a06:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  204a08:	429a      	cmp	r2, r3
  204a0a:	dcb0      	bgt.n	20496e <LCD_DrawCircle+0x1052>
		for(int i=0;i<buf[0];++i){
  204a0c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  204a0e:	3301      	adds	r3, #1
  204a10:	65fb      	str	r3, [r7, #92]	; 0x5c
  204a12:	4b06      	ldr	r3, [pc, #24]	; (204a2c <LCD_DrawCircle+0x1110>)
  204a14:	781b      	ldrb	r3, [r3, #0]
  204a16:	461a      	mov	r2, r3
  204a18:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  204a1a:	429a      	cmp	r2, r3
  204a1c:	dc9b      	bgt.n	204956 <LCD_DrawCircle+0x103a>
  204a1e:	46d5      	mov	sp, sl
  204a20:	e000      	b.n	204a24 <LCD_DrawCircle+0x1108>
	else return;
  204a22:	bf00      	nop
	}

	#undef PARAM
	#undef PARAM_AA
	#undef buf
}
  204a24:	37c8      	adds	r7, #200	; 0xc8
  204a26:	46bd      	mov	sp, r7
  204a28:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  204a2c:	2000205c 	.word	0x2000205c

00204a30 <_Change_AA.11639>:
		{
  204a30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  204a34:	b088      	sub	sp, #32
  204a36:	af00      	add	r7, sp, #0
  204a38:	6078      	str	r0, [r7, #4]
  204a3a:	4664      	mov	r4, ip
  204a3c:	f8c7 c000 	str.w	ip, [r7]
  204a40:	4669      	mov	r1, sp
  204a42:	4688      	mov	r8, r1
			int j=width;
  204a44:	6879      	ldr	r1, [r7, #4]
  204a46:	61f9      	str	r1, [r7, #28]
			int threshold[Circle.degree[0]];
  204a48:	496b      	ldr	r1, [pc, #428]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204a4a:	f8b1 e20c 	ldrh.w	lr, [r1, #524]	; 0x20c
  204a4e:	4671      	mov	r1, lr
  204a50:	3901      	subs	r1, #1
  204a52:	6139      	str	r1, [r7, #16]
  204a54:	fa1f f08e 	uxth.w	r0, lr
  204a58:	f04f 0100 	mov.w	r1, #0
  204a5c:	014e      	lsls	r6, r1, #5
  204a5e:	ea46 66d0 	orr.w	r6, r6, r0, lsr #27
  204a62:	0145      	lsls	r5, r0, #5
  204a64:	fa1f f08e 	uxth.w	r0, lr
  204a68:	f04f 0100 	mov.w	r1, #0
  204a6c:	014b      	lsls	r3, r1, #5
  204a6e:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
  204a72:	0142      	lsls	r2, r0, #5
  204a74:	4673      	mov	r3, lr
  204a76:	009b      	lsls	r3, r3, #2
  204a78:	3303      	adds	r3, #3
  204a7a:	3307      	adds	r3, #7
  204a7c:	08db      	lsrs	r3, r3, #3
  204a7e:	00db      	lsls	r3, r3, #3
  204a80:	ebad 0d03 	sub.w	sp, sp, r3
  204a84:	466b      	mov	r3, sp
  204a86:	3303      	adds	r3, #3
  204a88:	089b      	lsrs	r3, r3, #2
  204a8a:	009b      	lsls	r3, r3, #2
  204a8c:	60fb      	str	r3, [r7, #12]
			while(j--)
  204a8e:	e0a6      	b.n	204bde <_Change_AA.11639+0x1ae>
				for(int i=0;i<Circle.degree[0];++i)
  204a90:	2300      	movs	r3, #0
  204a92:	61bb      	str	r3, [r7, #24]
  204a94:	e00f      	b.n	204ab6 <_Change_AA.11639+0x86>
					threshold[i]=LCD_SearchRadiusPoints(posBuff,i,bkX);
  204a96:	68a3      	ldr	r3, [r4, #8]
  204a98:	4618      	mov	r0, r3
  204a9a:	6863      	ldr	r3, [r4, #4]
  204a9c:	461a      	mov	r2, r3
  204a9e:	69b9      	ldr	r1, [r7, #24]
  204aa0:	f7fd ff76 	bl	202990 <LCD_SearchRadiusPoints>
  204aa4:	4603      	mov	r3, r0
  204aa6:	4619      	mov	r1, r3
  204aa8:	68fb      	ldr	r3, [r7, #12]
  204aaa:	69ba      	ldr	r2, [r7, #24]
  204aac:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
				for(int i=0;i<Circle.degree[0];++i)
  204ab0:	69bb      	ldr	r3, [r7, #24]
  204ab2:	3301      	adds	r3, #1
  204ab4:	61bb      	str	r3, [r7, #24]
  204ab6:	4b50      	ldr	r3, [pc, #320]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204ab8:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  204abc:	461a      	mov	r2, r3
  204abe:	69bb      	ldr	r3, [r7, #24]
  204ac0:	429a      	cmp	r2, r3
  204ac2:	dce8      	bgt.n	204a96 <_Change_AA.11639+0x66>
				for(int i=0;i<Circle.degree[0]-1;++i)
  204ac4:	2300      	movs	r3, #0
  204ac6:	617b      	str	r3, [r7, #20]
  204ac8:	e07c      	b.n	204bc4 <_Change_AA.11639+0x194>
					deltaDeg=Circle.degree[1+i+1]-Circle.degree[1+i];
  204aca:	697b      	ldr	r3, [r7, #20]
  204acc:	3302      	adds	r3, #2
  204ace:	4a4a      	ldr	r2, [pc, #296]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204ad0:	f503 7382 	add.w	r3, r3, #260	; 0x104
  204ad4:	005b      	lsls	r3, r3, #1
  204ad6:	4413      	add	r3, r2
  204ad8:	889b      	ldrh	r3, [r3, #4]
  204ada:	4619      	mov	r1, r3
  204adc:	697b      	ldr	r3, [r7, #20]
  204ade:	3301      	adds	r3, #1
  204ae0:	4a45      	ldr	r2, [pc, #276]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204ae2:	f503 7382 	add.w	r3, r3, #260	; 0x104
  204ae6:	005b      	lsls	r3, r3, #1
  204ae8:	4413      	add	r3, r2
  204aea:	889b      	ldrh	r3, [r3, #4]
  204aec:	1acb      	subs	r3, r1, r3
  204aee:	60bb      	str	r3, [r7, #8]
					if( ((deltaDeg>0)&&(deltaDeg<=180)) || (deltaDeg<-180) )
  204af0:	68bb      	ldr	r3, [r7, #8]
  204af2:	2b00      	cmp	r3, #0
  204af4:	dd02      	ble.n	204afc <_Change_AA.11639+0xcc>
  204af6:	68bb      	ldr	r3, [r7, #8]
  204af8:	2bb4      	cmp	r3, #180	; 0xb4
  204afa:	dd03      	ble.n	204b04 <_Change_AA.11639+0xd4>
  204afc:	68bb      	ldr	r3, [r7, #8]
  204afe:	f113 0fb4 	cmn.w	r3, #180	; 0xb4
  204b02:	da2d      	bge.n	204b60 <_Change_AA.11639+0x130>
						if((threshold[i]==0)&&(threshold[i+1]==2)){
  204b04:	68fb      	ldr	r3, [r7, #12]
  204b06:	697a      	ldr	r2, [r7, #20]
  204b08:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  204b0c:	2b00      	cmp	r3, #0
  204b0e:	d155      	bne.n	204bbc <_Change_AA.11639+0x18c>
  204b10:	697b      	ldr	r3, [r7, #20]
  204b12:	1c5a      	adds	r2, r3, #1
  204b14:	68fb      	ldr	r3, [r7, #12]
  204b16:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  204b1a:	2b02      	cmp	r3, #2
  204b1c:	d14e      	bne.n	204bbc <_Change_AA.11639+0x18c>
							pLcd[k]=GetTransitionColor(FrameColor, Circle.degColor[1+i], GetTransitionCoeff(FrameColor,FillColor,pLcd[k]));
  204b1e:	4b37      	ldr	r3, [pc, #220]	; (204bfc <_Change_AA.11639+0x1cc>)
  204b20:	681d      	ldr	r5, [r3, #0]
  204b22:	697b      	ldr	r3, [r7, #20]
  204b24:	3301      	adds	r3, #1
  204b26:	4a34      	ldr	r2, [pc, #208]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204b28:	3388      	adds	r3, #136	; 0x88
  204b2a:	009b      	lsls	r3, r3, #2
  204b2c:	4413      	add	r3, r2
  204b2e:	685e      	ldr	r6, [r3, #4]
  204b30:	4b32      	ldr	r3, [pc, #200]	; (204bfc <_Change_AA.11639+0x1cc>)
  204b32:	681b      	ldr	r3, [r3, #0]
  204b34:	4a32      	ldr	r2, [pc, #200]	; (204c00 <_Change_AA.11639+0x1d0>)
  204b36:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  204b3a:	6823      	ldr	r3, [r4, #0]
  204b3c:	68e1      	ldr	r1, [r4, #12]
  204b3e:	4618      	mov	r0, r3
  204b40:	f002 fe04 	bl	20774c <GetTransitionCoeff>
  204b44:	eef0 7a40 	vmov.f32	s15, s0
  204b48:	6823      	ldr	r3, [r4, #0]
  204b4a:	eeb0 0a67 	vmov.f32	s0, s15
  204b4e:	4631      	mov	r1, r6
  204b50:	4618      	mov	r0, r3
  204b52:	f002 fd55 	bl	207600 <GetTransitionColor>
  204b56:	4602      	mov	r2, r0
  204b58:	4b29      	ldr	r3, [pc, #164]	; (204c00 <_Change_AA.11639+0x1d0>)
  204b5a:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
							break;
  204b5e:	e039      	b.n	204bd4 <_Change_AA.11639+0x1a4>
						if((threshold[i]==0)||(threshold[i+1]==2)){
  204b60:	68fb      	ldr	r3, [r7, #12]
  204b62:	697a      	ldr	r2, [r7, #20]
  204b64:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  204b68:	2b00      	cmp	r3, #0
  204b6a:	d006      	beq.n	204b7a <_Change_AA.11639+0x14a>
  204b6c:	697b      	ldr	r3, [r7, #20]
  204b6e:	1c5a      	adds	r2, r3, #1
  204b70:	68fb      	ldr	r3, [r7, #12]
  204b72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  204b76:	2b02      	cmp	r3, #2
  204b78:	d121      	bne.n	204bbe <_Change_AA.11639+0x18e>
							pLcd[k]=GetTransitionColor(FrameColor, Circle.degColor[1+i], GetTransitionCoeff(FrameColor,FillColor,pLcd[k]));
  204b7a:	4b20      	ldr	r3, [pc, #128]	; (204bfc <_Change_AA.11639+0x1cc>)
  204b7c:	681d      	ldr	r5, [r3, #0]
  204b7e:	697b      	ldr	r3, [r7, #20]
  204b80:	3301      	adds	r3, #1
  204b82:	4a1d      	ldr	r2, [pc, #116]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204b84:	3388      	adds	r3, #136	; 0x88
  204b86:	009b      	lsls	r3, r3, #2
  204b88:	4413      	add	r3, r2
  204b8a:	685e      	ldr	r6, [r3, #4]
  204b8c:	4b1b      	ldr	r3, [pc, #108]	; (204bfc <_Change_AA.11639+0x1cc>)
  204b8e:	681b      	ldr	r3, [r3, #0]
  204b90:	4a1b      	ldr	r2, [pc, #108]	; (204c00 <_Change_AA.11639+0x1d0>)
  204b92:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  204b96:	6823      	ldr	r3, [r4, #0]
  204b98:	68e1      	ldr	r1, [r4, #12]
  204b9a:	4618      	mov	r0, r3
  204b9c:	f002 fdd6 	bl	20774c <GetTransitionCoeff>
  204ba0:	eef0 7a40 	vmov.f32	s15, s0
  204ba4:	6823      	ldr	r3, [r4, #0]
  204ba6:	eeb0 0a67 	vmov.f32	s0, s15
  204baa:	4631      	mov	r1, r6
  204bac:	4618      	mov	r0, r3
  204bae:	f002 fd27 	bl	207600 <GetTransitionColor>
  204bb2:	4602      	mov	r2, r0
  204bb4:	4b12      	ldr	r3, [pc, #72]	; (204c00 <_Change_AA.11639+0x1d0>)
  204bb6:	f843 2025 	str.w	r2, [r3, r5, lsl #2]
							break;
  204bba:	e00b      	b.n	204bd4 <_Change_AA.11639+0x1a4>
						if((threshold[i]==0)&&(threshold[i+1]==2)){
  204bbc:	bf00      	nop
				for(int i=0;i<Circle.degree[0]-1;++i)
  204bbe:	697b      	ldr	r3, [r7, #20]
  204bc0:	3301      	adds	r3, #1
  204bc2:	617b      	str	r3, [r7, #20]
  204bc4:	4b0c      	ldr	r3, [pc, #48]	; (204bf8 <_Change_AA.11639+0x1c8>)
  204bc6:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  204bca:	1e5a      	subs	r2, r3, #1
  204bcc:	697b      	ldr	r3, [r7, #20]
  204bce:	429a      	cmp	r2, r3
  204bd0:	f73f af7b 	bgt.w	204aca <_Change_AA.11639+0x9a>
				k++;
  204bd4:	4b09      	ldr	r3, [pc, #36]	; (204bfc <_Change_AA.11639+0x1cc>)
  204bd6:	681b      	ldr	r3, [r3, #0]
  204bd8:	3301      	adds	r3, #1
  204bda:	4a08      	ldr	r2, [pc, #32]	; (204bfc <_Change_AA.11639+0x1cc>)
  204bdc:	6013      	str	r3, [r2, #0]
			while(j--)
  204bde:	69fb      	ldr	r3, [r7, #28]
  204be0:	1e5a      	subs	r2, r3, #1
  204be2:	61fa      	str	r2, [r7, #28]
  204be4:	2b00      	cmp	r3, #0
  204be6:	f47f af53 	bne.w	204a90 <_Change_AA.11639+0x60>
  204bea:	46c5      	mov	sp, r8
		}
  204bec:	bf00      	nop
  204bee:	3720      	adds	r7, #32
  204bf0:	46bd      	mov	sp, r7
  204bf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  204bf6:	bf00      	nop
  204bf8:	2000205c 	.word	0x2000205c
  204bfc:	20001870 	.word	0x20001870
  204c00:	c0000000 	.word	0xc0000000

00204c04 <CorrectLineAA_off>:
//################################## -- Global Declarations -- #########################################################

void CorrectLineAA_on(void){
	correctLine_AA=1;
}
void CorrectLineAA_off(void){
  204c04:	b480      	push	{r7}
  204c06:	af00      	add	r7, sp, #0
	correctLine_AA=0;
  204c08:	4b03      	ldr	r3, [pc, #12]	; (204c18 <CorrectLineAA_off+0x14>)
  204c0a:	2200      	movs	r2, #0
  204c0c:	701a      	strb	r2, [r3, #0]
}
  204c0e:	bf00      	nop
  204c10:	46bd      	mov	sp, r7
  204c12:	f85d 7b04 	ldr.w	r7, [sp], #4
  204c16:	4770      	bx	lr
  204c18:	20002058 	.word	0x20002058

00204c1c <Set_AACoeff_RoundFrameRectangle>:

void Set_AACoeff_RoundFrameRectangle(float coeff_1, float coeff_2){
  204c1c:	b480      	push	{r7}
  204c1e:	b083      	sub	sp, #12
  204c20:	af00      	add	r7, sp, #0
  204c22:	ed87 0a01 	vstr	s0, [r7, #4]
  204c26:	edc7 0a00 	vstr	s1, [r7]
	AA.c1 = coeff_1;
  204c2a:	4a06      	ldr	r2, [pc, #24]	; (204c44 <Set_AACoeff_RoundFrameRectangle+0x28>)
  204c2c:	687b      	ldr	r3, [r7, #4]
  204c2e:	6013      	str	r3, [r2, #0]
	AA.c2 = coeff_2;
  204c30:	4a04      	ldr	r2, [pc, #16]	; (204c44 <Set_AACoeff_RoundFrameRectangle+0x28>)
  204c32:	683b      	ldr	r3, [r7, #0]
  204c34:	6053      	str	r3, [r2, #4]
}
  204c36:	bf00      	nop
  204c38:	370c      	adds	r7, #12
  204c3a:	46bd      	mov	sp, r7
  204c3c:	f85d 7b04 	ldr.w	r7, [sp], #4
  204c40:	4770      	bx	lr
  204c42:	bf00      	nop
  204c44:	20002050 	.word	0x20002050

00204c48 <_FillBuff>:

void _FillBuff(int itCount, uint32_t color)
{
  204c48:	b4b0      	push	{r4, r5, r7}
  204c4a:	b089      	sub	sp, #36	; 0x24
  204c4c:	af00      	add	r7, sp, #0
  204c4e:	6078      	str	r0, [r7, #4]
  204c50:	6039      	str	r1, [r7, #0]
	if(itCount>10)
  204c52:	687b      	ldr	r3, [r7, #4]
  204c54:	2b0a      	cmp	r3, #10
  204c56:	dd55      	ble.n	204d04 <_FillBuff+0xbc>
	{
		int j=itCount/2;
  204c58:	687b      	ldr	r3, [r7, #4]
  204c5a:	2b00      	cmp	r3, #0
  204c5c:	da00      	bge.n	204c60 <_FillBuff+0x18>
  204c5e:	3301      	adds	r3, #1
  204c60:	105b      	asrs	r3, r3, #1
  204c62:	61fb      	str	r3, [r7, #28]
		int a=j;
  204c64:	69fb      	ldr	r3, [r7, #28]
  204c66:	617b      	str	r3, [r7, #20]

		uint64_t *pLcd64=(uint64_t*) (pLcd+k);
  204c68:	4b32      	ldr	r3, [pc, #200]	; (204d34 <_FillBuff+0xec>)
  204c6a:	681b      	ldr	r3, [r3, #0]
  204c6c:	009b      	lsls	r3, r3, #2
  204c6e:	4a32      	ldr	r2, [pc, #200]	; (204d38 <_FillBuff+0xf0>)
  204c70:	4413      	add	r3, r2
  204c72:	613b      	str	r3, [r7, #16]
		uint64_t color64=(((uint64_t)color)<<32)|((uint64_t)color);
  204c74:	683b      	ldr	r3, [r7, #0]
  204c76:	461a      	mov	r2, r3
  204c78:	f04f 0300 	mov.w	r3, #0
  204c7c:	0015      	movs	r5, r2
  204c7e:	2400      	movs	r4, #0
  204c80:	683b      	ldr	r3, [r7, #0]
  204c82:	461a      	mov	r2, r3
  204c84:	f04f 0300 	mov.w	r3, #0
  204c88:	ea44 0002 	orr.w	r0, r4, r2
  204c8c:	ea45 0103 	orr.w	r1, r5, r3
  204c90:	4603      	mov	r3, r0
  204c92:	460c      	mov	r4, r1
  204c94:	e9c7 3402 	strd	r3, r4, [r7, #8]

		j--;
  204c98:	69fb      	ldr	r3, [r7, #28]
  204c9a:	3b01      	subs	r3, #1
  204c9c:	61fb      	str	r3, [r7, #28]
		while (j)
  204c9e:	e009      	b.n	204cb4 <_FillBuff+0x6c>
			pLcd64[j--]=color64;
  204ca0:	69fb      	ldr	r3, [r7, #28]
  204ca2:	1e5a      	subs	r2, r3, #1
  204ca4:	61fa      	str	r2, [r7, #28]
  204ca6:	00db      	lsls	r3, r3, #3
  204ca8:	693a      	ldr	r2, [r7, #16]
  204caa:	441a      	add	r2, r3
  204cac:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
  204cb0:	e882 0018 	stmia.w	r2, {r3, r4}
		while (j)
  204cb4:	69fb      	ldr	r3, [r7, #28]
  204cb6:	2b00      	cmp	r3, #0
  204cb8:	d1f2      	bne.n	204ca0 <_FillBuff+0x58>

		pLcd64[j]=color64;
  204cba:	69fb      	ldr	r3, [r7, #28]
  204cbc:	00db      	lsls	r3, r3, #3
  204cbe:	693a      	ldr	r2, [r7, #16]
  204cc0:	441a      	add	r2, r3
  204cc2:	e9d7 3402 	ldrd	r3, r4, [r7, #8]
  204cc6:	e882 0018 	stmia.w	r2, {r3, r4}
		k+=a+itCount/2;
  204cca:	687b      	ldr	r3, [r7, #4]
  204ccc:	2b00      	cmp	r3, #0
  204cce:	da00      	bge.n	204cd2 <_FillBuff+0x8a>
  204cd0:	3301      	adds	r3, #1
  204cd2:	105b      	asrs	r3, r3, #1
  204cd4:	461a      	mov	r2, r3
  204cd6:	697b      	ldr	r3, [r7, #20]
  204cd8:	4413      	add	r3, r2
  204cda:	461a      	mov	r2, r3
  204cdc:	4b15      	ldr	r3, [pc, #84]	; (204d34 <_FillBuff+0xec>)
  204cde:	681b      	ldr	r3, [r3, #0]
  204ce0:	4413      	add	r3, r2
  204ce2:	4a14      	ldr	r2, [pc, #80]	; (204d34 <_FillBuff+0xec>)
  204ce4:	6013      	str	r3, [r2, #0]

		if (itCount%2)
  204ce6:	687b      	ldr	r3, [r7, #4]
  204ce8:	f003 0301 	and.w	r3, r3, #1
  204cec:	2b00      	cmp	r3, #0
  204cee:	d01c      	beq.n	204d2a <_FillBuff+0xe2>
			pLcd[k++]=color;
  204cf0:	4b10      	ldr	r3, [pc, #64]	; (204d34 <_FillBuff+0xec>)
  204cf2:	681b      	ldr	r3, [r3, #0]
  204cf4:	1c5a      	adds	r2, r3, #1
  204cf6:	490f      	ldr	r1, [pc, #60]	; (204d34 <_FillBuff+0xec>)
  204cf8:	600a      	str	r2, [r1, #0]
  204cfa:	490f      	ldr	r1, [pc, #60]	; (204d38 <_FillBuff+0xf0>)
  204cfc:	683a      	ldr	r2, [r7, #0]
  204cfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	else
	{
		for(int i=0;i<itCount;++i)
			pLcd[k++]=color;
	}
}
  204d02:	e012      	b.n	204d2a <_FillBuff+0xe2>
		for(int i=0;i<itCount;++i)
  204d04:	2300      	movs	r3, #0
  204d06:	61bb      	str	r3, [r7, #24]
  204d08:	e00b      	b.n	204d22 <_FillBuff+0xda>
			pLcd[k++]=color;
  204d0a:	4b0a      	ldr	r3, [pc, #40]	; (204d34 <_FillBuff+0xec>)
  204d0c:	681b      	ldr	r3, [r3, #0]
  204d0e:	1c5a      	adds	r2, r3, #1
  204d10:	4908      	ldr	r1, [pc, #32]	; (204d34 <_FillBuff+0xec>)
  204d12:	600a      	str	r2, [r1, #0]
  204d14:	4908      	ldr	r1, [pc, #32]	; (204d38 <_FillBuff+0xf0>)
  204d16:	683a      	ldr	r2, [r7, #0]
  204d18:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		for(int i=0;i<itCount;++i)
  204d1c:	69bb      	ldr	r3, [r7, #24]
  204d1e:	3301      	adds	r3, #1
  204d20:	61bb      	str	r3, [r7, #24]
  204d22:	69ba      	ldr	r2, [r7, #24]
  204d24:	687b      	ldr	r3, [r7, #4]
  204d26:	429a      	cmp	r2, r3
  204d28:	dbef      	blt.n	204d0a <_FillBuff+0xc2>
}
  204d2a:	bf00      	nop
  204d2c:	3724      	adds	r7, #36	; 0x24
  204d2e:	46bd      	mov	sp, r7
  204d30:	bcb0      	pop	{r4, r5, r7}
  204d32:	4770      	bx	lr
  204d34:	20001870 	.word	0x20001870
  204d38:	c0000000 	.word	0xc0000000

00204d3c <_CopyDrawPos>:

void _CopyDrawPos(void){
  204d3c:	b480      	push	{r7}
  204d3e:	af00      	add	r7, sp, #0
	kCopy=k;
  204d40:	4b04      	ldr	r3, [pc, #16]	; (204d54 <_CopyDrawPos+0x18>)
  204d42:	681b      	ldr	r3, [r3, #0]
  204d44:	4a04      	ldr	r2, [pc, #16]	; (204d58 <_CopyDrawPos+0x1c>)
  204d46:	6013      	str	r3, [r2, #0]
}
  204d48:	bf00      	nop
  204d4a:	46bd      	mov	sp, r7
  204d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
  204d50:	4770      	bx	lr
  204d52:	bf00      	nop
  204d54:	20001870 	.word	0x20001870
  204d58:	20001874 	.word	0x20001874

00204d5c <_SetCopyDrawPos>:
void _SetCopyDrawPos(void){
  204d5c:	b480      	push	{r7}
  204d5e:	af00      	add	r7, sp, #0
	k=kCopy;
  204d60:	4b04      	ldr	r3, [pc, #16]	; (204d74 <_SetCopyDrawPos+0x18>)
  204d62:	681b      	ldr	r3, [r3, #0]
  204d64:	4a04      	ldr	r2, [pc, #16]	; (204d78 <_SetCopyDrawPos+0x1c>)
  204d66:	6013      	str	r3, [r2, #0]
}
  204d68:	bf00      	nop
  204d6a:	46bd      	mov	sp, r7
  204d6c:	f85d 7b04 	ldr.w	r7, [sp], #4
  204d70:	4770      	bx	lr
  204d72:	bf00      	nop
  204d74:	20001874 	.word	0x20001874
  204d78:	20001870 	.word	0x20001870

00204d7c <_IncDrawPos>:
void _IncDrawPos(int pos){
  204d7c:	b480      	push	{r7}
  204d7e:	b083      	sub	sp, #12
  204d80:	af00      	add	r7, sp, #0
  204d82:	6078      	str	r0, [r7, #4]
	k+=pos;
  204d84:	4b05      	ldr	r3, [pc, #20]	; (204d9c <_IncDrawPos+0x20>)
  204d86:	681a      	ldr	r2, [r3, #0]
  204d88:	687b      	ldr	r3, [r7, #4]
  204d8a:	4413      	add	r3, r2
  204d8c:	4a03      	ldr	r2, [pc, #12]	; (204d9c <_IncDrawPos+0x20>)
  204d8e:	6013      	str	r3, [r2, #0]
}
  204d90:	bf00      	nop
  204d92:	370c      	adds	r7, #12
  204d94:	46bd      	mov	sp, r7
  204d96:	f85d 7b04 	ldr.w	r7, [sp], #4
  204d9a:	4770      	bx	lr
  204d9c:	20001870 	.word	0x20001870

00204da0 <_StartDrawLine>:

void _StartDrawLine(uint32_t posBuff,uint32_t BkpSizeX,uint32_t x,uint32_t y){
  204da0:	b480      	push	{r7}
  204da2:	b085      	sub	sp, #20
  204da4:	af00      	add	r7, sp, #0
  204da6:	60f8      	str	r0, [r7, #12]
  204da8:	60b9      	str	r1, [r7, #8]
  204daa:	607a      	str	r2, [r7, #4]
  204dac:	603b      	str	r3, [r7, #0]
	k=posBuff+(y*BkpSizeX+x);
  204dae:	683b      	ldr	r3, [r7, #0]
  204db0:	68ba      	ldr	r2, [r7, #8]
  204db2:	fb02 f203 	mul.w	r2, r2, r3
  204db6:	687b      	ldr	r3, [r7, #4]
  204db8:	441a      	add	r2, r3
  204dba:	68fb      	ldr	r3, [r7, #12]
  204dbc:	4413      	add	r3, r2
  204dbe:	4a04      	ldr	r2, [pc, #16]	; (204dd0 <_StartDrawLine+0x30>)
  204dc0:	6013      	str	r3, [r2, #0]
}
  204dc2:	bf00      	nop
  204dc4:	3714      	adds	r7, #20
  204dc6:	46bd      	mov	sp, r7
  204dc8:	f85d 7b04 	ldr.w	r7, [sp], #4
  204dcc:	4770      	bx	lr
  204dce:	bf00      	nop
  204dd0:	20001870 	.word	0x20001870

00204dd4 <_GetPosXY>:
	return ((k-posBuff)/BkpSizeX);
}
uint32_t _GetPosX(uint32_t posBuff,uint32_t BkpSizeX){
	return ((k-posBuff)-_GetPosY(posBuff,BkpSizeX)*BkpSizeX);
}
structPosition _GetPosXY(uint32_t posBuff, uint32_t BkpSizeX){
  204dd4:	b480      	push	{r7}
  204dd6:	b089      	sub	sp, #36	; 0x24
  204dd8:	af00      	add	r7, sp, #0
  204dda:	60f8      	str	r0, [r7, #12]
  204ddc:	60b9      	str	r1, [r7, #8]
  204dde:	607a      	str	r2, [r7, #4]
	structPosition temp;
	int kOffs = k-posBuff;
  204de0:	4b0f      	ldr	r3, [pc, #60]	; (204e20 <_GetPosXY+0x4c>)
  204de2:	681a      	ldr	r2, [r3, #0]
  204de4:	68bb      	ldr	r3, [r7, #8]
  204de6:	1ad3      	subs	r3, r2, r3
  204de8:	61fb      	str	r3, [r7, #28]
	temp.y = (kOffs/BkpSizeX);
  204dea:	69fa      	ldr	r2, [r7, #28]
  204dec:	687b      	ldr	r3, [r7, #4]
  204dee:	fbb2 f3f3 	udiv	r3, r2, r3
  204df2:	61bb      	str	r3, [r7, #24]
	temp.x = (kOffs-temp.y*BkpSizeX);
  204df4:	69fa      	ldr	r2, [r7, #28]
  204df6:	69bb      	ldr	r3, [r7, #24]
  204df8:	4619      	mov	r1, r3
  204dfa:	687b      	ldr	r3, [r7, #4]
  204dfc:	fb03 f301 	mul.w	r3, r3, r1
  204e00:	1ad3      	subs	r3, r2, r3
  204e02:	617b      	str	r3, [r7, #20]
	return temp;
  204e04:	68fb      	ldr	r3, [r7, #12]
  204e06:	461a      	mov	r2, r3
  204e08:	f107 0314 	add.w	r3, r7, #20
  204e0c:	e893 0003 	ldmia.w	r3, {r0, r1}
  204e10:	e882 0003 	stmia.w	r2, {r0, r1}
}
  204e14:	68f8      	ldr	r0, [r7, #12]
  204e16:	3724      	adds	r7, #36	; 0x24
  204e18:	46bd      	mov	sp, r7
  204e1a:	f85d 7b04 	ldr.w	r7, [sp], #4
  204e1e:	4770      	bx	lr
  204e20:	20001870 	.word	0x20001870

00204e24 <_GetPosXY___>:
structPosition _GetPosXY___(uint32_t posBuff, int k, uint32_t BkpSizeX){
  204e24:	b480      	push	{r7}
  204e26:	b089      	sub	sp, #36	; 0x24
  204e28:	af00      	add	r7, sp, #0
  204e2a:	60f8      	str	r0, [r7, #12]
  204e2c:	60b9      	str	r1, [r7, #8]
  204e2e:	607a      	str	r2, [r7, #4]
  204e30:	603b      	str	r3, [r7, #0]
	structPosition temp;
	int kOffs = k-posBuff;
  204e32:	687a      	ldr	r2, [r7, #4]
  204e34:	68bb      	ldr	r3, [r7, #8]
  204e36:	1ad3      	subs	r3, r2, r3
  204e38:	61fb      	str	r3, [r7, #28]
	temp.y = (kOffs/BkpSizeX);
  204e3a:	69fa      	ldr	r2, [r7, #28]
  204e3c:	683b      	ldr	r3, [r7, #0]
  204e3e:	fbb2 f3f3 	udiv	r3, r2, r3
  204e42:	61bb      	str	r3, [r7, #24]
	temp.x = (kOffs-temp.y*BkpSizeX);
  204e44:	69fa      	ldr	r2, [r7, #28]
  204e46:	69bb      	ldr	r3, [r7, #24]
  204e48:	4619      	mov	r1, r3
  204e4a:	683b      	ldr	r3, [r7, #0]
  204e4c:	fb03 f301 	mul.w	r3, r3, r1
  204e50:	1ad3      	subs	r3, r2, r3
  204e52:	617b      	str	r3, [r7, #20]
	return temp;
  204e54:	68fb      	ldr	r3, [r7, #12]
  204e56:	461a      	mov	r2, r3
  204e58:	f107 0314 	add.w	r3, r7, #20
  204e5c:	e893 0003 	ldmia.w	r3, {r0, r1}
  204e60:	e882 0003 	stmia.w	r2, {r0, r1}
}
  204e64:	68f8      	ldr	r0, [r7, #12]
  204e66:	3724      	adds	r7, #36	; 0x24
  204e68:	46bd      	mov	sp, r7
  204e6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  204e6e:	4770      	bx	lr

00204e70 <_NextDrawLine>:
void _NextDrawLine(uint32_t BkpSizeX,uint32_t width){
  204e70:	b480      	push	{r7}
  204e72:	b083      	sub	sp, #12
  204e74:	af00      	add	r7, sp, #0
  204e76:	6078      	str	r0, [r7, #4]
  204e78:	6039      	str	r1, [r7, #0]
	k+=(BkpSizeX-width);
  204e7a:	687a      	ldr	r2, [r7, #4]
  204e7c:	683b      	ldr	r3, [r7, #0]
  204e7e:	1ad2      	subs	r2, r2, r3
  204e80:	4b05      	ldr	r3, [pc, #20]	; (204e98 <_NextDrawLine+0x28>)
  204e82:	681b      	ldr	r3, [r3, #0]
  204e84:	4413      	add	r3, r2
  204e86:	4a04      	ldr	r2, [pc, #16]	; (204e98 <_NextDrawLine+0x28>)
  204e88:	6013      	str	r3, [r2, #0]
}
  204e8a:	bf00      	nop
  204e8c:	370c      	adds	r7, #12
  204e8e:	46bd      	mov	sp, r7
  204e90:	f85d 7b04 	ldr.w	r7, [sp], #4
  204e94:	4770      	bx	lr
  204e96:	bf00      	nop
  204e98:	20001870 	.word	0x20001870

00204e9c <_DrawRight>:

void _DrawRight(int width, uint32_t color)
{
  204e9c:	b480      	push	{r7}
  204e9e:	b085      	sub	sp, #20
  204ea0:	af00      	add	r7, sp, #0
  204ea2:	6078      	str	r0, [r7, #4]
  204ea4:	6039      	str	r1, [r7, #0]
	int j=width;
  204ea6:	687b      	ldr	r3, [r7, #4]
  204ea8:	60fb      	str	r3, [r7, #12]
	uint32_t *p = pLcd+k;
  204eaa:	4b0e      	ldr	r3, [pc, #56]	; (204ee4 <_DrawRight+0x48>)
  204eac:	681b      	ldr	r3, [r3, #0]
  204eae:	009b      	lsls	r3, r3, #2
  204eb0:	4a0d      	ldr	r2, [pc, #52]	; (204ee8 <_DrawRight+0x4c>)
  204eb2:	4413      	add	r3, r2
  204eb4:	60bb      	str	r3, [r7, #8]
	while(j--)
  204eb6:	e004      	b.n	204ec2 <_DrawRight+0x26>
		*(p++)=color;
  204eb8:	68bb      	ldr	r3, [r7, #8]
  204eba:	1d1a      	adds	r2, r3, #4
  204ebc:	60ba      	str	r2, [r7, #8]
  204ebe:	683a      	ldr	r2, [r7, #0]
  204ec0:	601a      	str	r2, [r3, #0]
	while(j--)
  204ec2:	68fb      	ldr	r3, [r7, #12]
  204ec4:	1e5a      	subs	r2, r3, #1
  204ec6:	60fa      	str	r2, [r7, #12]
  204ec8:	2b00      	cmp	r3, #0
  204eca:	d1f5      	bne.n	204eb8 <_DrawRight+0x1c>
	k+=width;
  204ecc:	4b05      	ldr	r3, [pc, #20]	; (204ee4 <_DrawRight+0x48>)
  204ece:	681a      	ldr	r2, [r3, #0]
  204ed0:	687b      	ldr	r3, [r7, #4]
  204ed2:	4413      	add	r3, r2
  204ed4:	4a03      	ldr	r2, [pc, #12]	; (204ee4 <_DrawRight+0x48>)
  204ed6:	6013      	str	r3, [r2, #0]
}
  204ed8:	bf00      	nop
  204eda:	3714      	adds	r7, #20
  204edc:	46bd      	mov	sp, r7
  204ede:	f85d 7b04 	ldr.w	r7, [sp], #4
  204ee2:	4770      	bx	lr
  204ee4:	20001870 	.word	0x20001870
  204ee8:	c0000000 	.word	0xc0000000

00204eec <Set_AACoeff_Draw>:
		k-=BkpSizeX;
	}
}

void Set_AACoeff_Draw(int pixelsInOneSide, uint32_t colorFrom, uint32_t colorTo, float ratioStart)
{
  204eec:	b590      	push	{r4, r7, lr}
  204eee:	b087      	sub	sp, #28
  204ef0:	af00      	add	r7, sp, #0
  204ef2:	60f8      	str	r0, [r7, #12]
  204ef4:	60b9      	str	r1, [r7, #8]
  204ef6:	607a      	str	r2, [r7, #4]
  204ef8:	ed87 0a00 	vstr	s0, [r7]
	//int pixelsInOneSide;
//
//	if(pixelsInOneSide_==1) pixelsInOneSide=2;
//	else                    pixelsInOneSide=pixelsInOneSide_;

	float incr= (1-ratioStart)/pixelsInOneSide;
  204efc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  204f00:	edd7 7a00 	vldr	s15, [r7]
  204f04:	ee77 6a67 	vsub.f32	s13, s14, s15
  204f08:	68fb      	ldr	r3, [r7, #12]
  204f0a:	ee07 3a90 	vmov	s15, r3
  204f0e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  204f12:	eec6 7a87 	vdiv.f32	s15, s13, s14
  204f16:	edc7 7a04 	vstr	s15, [r7, #16]
	buff_AA[0]=pixelsInOneSide;
  204f1a:	68fb      	ldr	r3, [r7, #12]
  204f1c:	4a17      	ldr	r2, [pc, #92]	; (204f7c <Set_AACoeff_Draw+0x90>)
  204f1e:	6013      	str	r3, [r2, #0]
	for(int i=0;i<pixelsInOneSide;++i){
  204f20:	2300      	movs	r3, #0
  204f22:	617b      	str	r3, [r7, #20]
  204f24:	e020      	b.n	204f68 <Set_AACoeff_Draw+0x7c>
		if(1+i>MAX_SIZE_TAB_AA)
  204f26:	697b      	ldr	r3, [r7, #20]
  204f28:	3301      	adds	r3, #1
  204f2a:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  204f2e:	dc20      	bgt.n	204f72 <Set_AACoeff_Draw+0x86>
			break;
		buff_AA[1+i]= GetTransitionColor(colorFrom,colorTo, ratioStart+i*incr);
  204f30:	697b      	ldr	r3, [r7, #20]
  204f32:	1c5c      	adds	r4, r3, #1
  204f34:	697b      	ldr	r3, [r7, #20]
  204f36:	ee07 3a90 	vmov	s15, r3
  204f3a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
  204f3e:	edd7 7a04 	vldr	s15, [r7, #16]
  204f42:	ee27 7a27 	vmul.f32	s14, s14, s15
  204f46:	edd7 7a00 	vldr	s15, [r7]
  204f4a:	ee77 7a27 	vadd.f32	s15, s14, s15
  204f4e:	eeb0 0a67 	vmov.f32	s0, s15
  204f52:	6879      	ldr	r1, [r7, #4]
  204f54:	68b8      	ldr	r0, [r7, #8]
  204f56:	f002 fb53 	bl	207600 <GetTransitionColor>
  204f5a:	4602      	mov	r2, r0
  204f5c:	4b07      	ldr	r3, [pc, #28]	; (204f7c <Set_AACoeff_Draw+0x90>)
  204f5e:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
	for(int i=0;i<pixelsInOneSide;++i){
  204f62:	697b      	ldr	r3, [r7, #20]
  204f64:	3301      	adds	r3, #1
  204f66:	617b      	str	r3, [r7, #20]
  204f68:	697a      	ldr	r2, [r7, #20]
  204f6a:	68fb      	ldr	r3, [r7, #12]
  204f6c:	429a      	cmp	r2, r3
  204f6e:	dbda      	blt.n	204f26 <Set_AACoeff_Draw+0x3a>
	}
}
  204f70:	e000      	b.n	204f74 <Set_AACoeff_Draw+0x88>
			break;
  204f72:	bf00      	nop
}
  204f74:	bf00      	nop
  204f76:	371c      	adds	r7, #28
  204f78:	46bd      	mov	sp, r7
  204f7a:	bd90      	pop	{r4, r7, pc}
  204f7c:	20001878 	.word	0x20001878

00204f80 <XXX.12102>:
{
	int j=buf[0], i=buf[1], p=2, i_prev;
	uint32_t drawColor=_drawColor;

	void XXX(void)
	{
  204f80:	b590      	push	{r4, r7, lr}
  204f82:	b085      	sub	sp, #20
  204f84:	af00      	add	r7, sp, #0
  204f86:	4664      	mov	r4, ip
  204f88:	f8c7 c004 	str.w	ip, [r7, #4]
		uint16_t aaaa=GetDegFromPosK(0, Circle.x0, Circle.y0, BkpSizeX);
  204f8c:	4b0d      	ldr	r3, [pc, #52]	; (204fc4 <XXX.12102+0x44>)
  204f8e:	f8b3 1208 	ldrh.w	r1, [r3, #520]	; 0x208
  204f92:	4b0c      	ldr	r3, [pc, #48]	; (204fc4 <XXX.12102+0x44>)
  204f94:	f8b3 220a 	ldrh.w	r2, [r3, #522]	; 0x20a
  204f98:	68a3      	ldr	r3, [r4, #8]
  204f9a:	2000      	movs	r0, #0
  204f9c:	f7fd fa4c 	bl	202438 <GetDegFromPosK>
  204fa0:	4603      	mov	r3, r0
  204fa2:	81fb      	strh	r3, [r7, #14]
		if(aaaa>145 && aaaa<170)
  204fa4:	89fb      	ldrh	r3, [r7, #14]
  204fa6:	2b91      	cmp	r3, #145	; 0x91
  204fa8:	d905      	bls.n	204fb6 <XXX.12102+0x36>
  204faa:	89fb      	ldrh	r3, [r7, #14]
  204fac:	2ba9      	cmp	r3, #169	; 0xa9
  204fae:	d802      	bhi.n	204fb6 <XXX.12102+0x36>
			drawColor=MYRED;
  204fb0:	4b05      	ldr	r3, [pc, #20]	; (204fc8 <XXX.12102+0x48>)
  204fb2:	6063      	str	r3, [r4, #4]
  204fb4:	e001      	b.n	204fba <XXX.12102+0x3a>
		else
			drawColor=_drawColor;
  204fb6:	6823      	ldr	r3, [r4, #0]
  204fb8:	6063      	str	r3, [r4, #4]
	}
  204fba:	bf00      	nop
  204fbc:	3714      	adds	r7, #20
  204fbe:	46bd      	mov	sp, r7
  204fc0:	bd90      	pop	{r4, r7, pc}
  204fc2:	bf00      	nop
  204fc4:	2000205c 	.word	0x2000205c
  204fc8:	ffff7878 	.word	0xffff7878

00204fcc <_DrawArrayBuffRightDown_AA>:
{
  204fcc:	b580      	push	{r7, lr}
  204fce:	b090      	sub	sp, #64	; 0x40
  204fd0:	af00      	add	r7, sp, #0
  204fd2:	60f9      	str	r1, [r7, #12]
  204fd4:	60ba      	str	r2, [r7, #8]
  204fd6:	ed87 0a01 	vstr	s0, [r7, #4]
  204fda:	edc7 0a00 	vstr	s1, [r7]
void _DrawArrayBuffRightDown_AA(uint32_t _drawColor, uint32_t outColor, uint32_t inColor, float outRatioStart, float inRatioStart, uint32_t BkpSizeX, int direction, uint8_t *buf)
  204fde:	f107 0248 	add.w	r2, r7, #72	; 0x48
  204fe2:	61fa      	str	r2, [r7, #28]
  204fe4:	6138      	str	r0, [r7, #16]
  204fe6:	61bb      	str	r3, [r7, #24]
	int j=buf[0], i=buf[1], p=2, i_prev;
  204fe8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  204fea:	781b      	ldrb	r3, [r3, #0]
  204fec:	63fb      	str	r3, [r7, #60]	; 0x3c
  204fee:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  204ff0:	3301      	adds	r3, #1
  204ff2:	781b      	ldrb	r3, [r3, #0]
  204ff4:	63bb      	str	r3, [r7, #56]	; 0x38
  204ff6:	2302      	movs	r3, #2
  204ff8:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t drawColor=_drawColor;
  204ffa:	693b      	ldr	r3, [r7, #16]
  204ffc:	617b      	str	r3, [r7, #20]



	if(0==direction)
  204ffe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  205000:	2b00      	cmp	r3, #0
  205002:	f040 80dc 	bne.w	2051be <_DrawArrayBuffRightDown_AA+0x1f2>
	{
		while(j--)
  205006:	e06a      	b.n	2050de <_DrawArrayBuffRightDown_AA+0x112>
		{
			i_prev=i;
  205008:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20500a:	623b      	str	r3, [r7, #32]
			while(i--){
  20500c:	e00d      	b.n	20502a <_DrawArrayBuffRightDown_AA+0x5e>
				pLcd[k++]=drawColor;  XXX();
  20500e:	4b70      	ldr	r3, [pc, #448]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205010:	681b      	ldr	r3, [r3, #0]
  205012:	1c5a      	adds	r2, r3, #1
  205014:	496e      	ldr	r1, [pc, #440]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205016:	600a      	str	r2, [r1, #0]
  205018:	697a      	ldr	r2, [r7, #20]
  20501a:	496e      	ldr	r1, [pc, #440]	; (2051d4 <_DrawArrayBuffRightDown_AA+0x208>)
  20501c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  205020:	f107 0310 	add.w	r3, r7, #16
  205024:	469c      	mov	ip, r3
  205026:	f7ff ffab 	bl	204f80 <XXX.12102>
			while(i--){
  20502a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20502c:	1e5a      	subs	r2, r3, #1
  20502e:	63ba      	str	r2, [r7, #56]	; 0x38
  205030:	2b00      	cmp	r3, #0
  205032:	d1ec      	bne.n	20500e <_DrawArrayBuffRightDown_AA+0x42>
			}

			if(j){
  205034:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205036:	2b00      	cmp	r3, #0
  205038:	d026      	beq.n	205088 <_DrawArrayBuffRightDown_AA+0xbc>
				i=buf[p++];
  20503a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20503c:	1c5a      	adds	r2, r3, #1
  20503e:	637a      	str	r2, [r7, #52]	; 0x34
  205040:	461a      	mov	r2, r3
  205042:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  205044:	4413      	add	r3, r2
  205046:	781b      	ldrb	r3, [r3, #0]
  205048:	63bb      	str	r3, [r7, #56]	; 0x38
				Set_AACoeff_Draw(i,drawColor,outColor,outRatioStart);
  20504a:	697b      	ldr	r3, [r7, #20]
  20504c:	ed97 0a01 	vldr	s0, [r7, #4]
  205050:	68fa      	ldr	r2, [r7, #12]
  205052:	4619      	mov	r1, r3
  205054:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  205056:	f7ff ff49 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  20505a:	2300      	movs	r3, #0
  20505c:	633b      	str	r3, [r7, #48]	; 0x30
  20505e:	e00e      	b.n	20507e <_DrawArrayBuffRightDown_AA+0xb2>
					pLcd[k+a]=buff_AA[1+a];
  205060:	4b5b      	ldr	r3, [pc, #364]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205062:	681a      	ldr	r2, [r3, #0]
  205064:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205066:	4413      	add	r3, r2
  205068:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  20506a:	3201      	adds	r2, #1
  20506c:	495a      	ldr	r1, [pc, #360]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  20506e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  205072:	4958      	ldr	r1, [pc, #352]	; (2051d4 <_DrawArrayBuffRightDown_AA+0x208>)
  205074:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  205078:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20507a:	3301      	adds	r3, #1
  20507c:	633b      	str	r3, [r7, #48]	; 0x30
  20507e:	4b56      	ldr	r3, [pc, #344]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  205080:	681a      	ldr	r2, [r3, #0]
  205082:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205084:	429a      	cmp	r2, r3
  205086:	d8eb      	bhi.n	205060 <_DrawArrayBuffRightDown_AA+0x94>
			}
			k+=BkpSizeX;   XXX();
  205088:	4b51      	ldr	r3, [pc, #324]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  20508a:	681a      	ldr	r2, [r3, #0]
  20508c:	69bb      	ldr	r3, [r7, #24]
  20508e:	4413      	add	r3, r2
  205090:	4a4f      	ldr	r2, [pc, #316]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205092:	6013      	str	r3, [r2, #0]
  205094:	f107 0310 	add.w	r3, r7, #16
  205098:	469c      	mov	ip, r3
  20509a:	f7ff ff71 	bl	204f80 <XXX.12102>

			Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
  20509e:	697b      	ldr	r3, [r7, #20]
  2050a0:	ed97 0a00 	vldr	s0, [r7]
  2050a4:	68ba      	ldr	r2, [r7, #8]
  2050a6:	4619      	mov	r1, r3
  2050a8:	6a38      	ldr	r0, [r7, #32]
  2050aa:	f7ff ff1f 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  2050ae:	2300      	movs	r3, #0
  2050b0:	62fb      	str	r3, [r7, #44]	; 0x2c
  2050b2:	e00f      	b.n	2050d4 <_DrawArrayBuffRightDown_AA+0x108>
				pLcd[k-1-a]=buff_AA[1+a];
  2050b4:	4b46      	ldr	r3, [pc, #280]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  2050b6:	681a      	ldr	r2, [r3, #0]
  2050b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2050ba:	1ad3      	subs	r3, r2, r3
  2050bc:	3b01      	subs	r3, #1
  2050be:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  2050c0:	3201      	adds	r2, #1
  2050c2:	4945      	ldr	r1, [pc, #276]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  2050c4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2050c8:	4942      	ldr	r1, [pc, #264]	; (2051d4 <_DrawArrayBuffRightDown_AA+0x208>)
  2050ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  2050ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2050d0:	3301      	adds	r3, #1
  2050d2:	62fb      	str	r3, [r7, #44]	; 0x2c
  2050d4:	4b40      	ldr	r3, [pc, #256]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  2050d6:	681a      	ldr	r2, [r3, #0]
  2050d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2050da:	429a      	cmp	r2, r3
  2050dc:	d8ea      	bhi.n	2050b4 <_DrawArrayBuffRightDown_AA+0xe8>
		while(j--)
  2050de:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2050e0:	1e5a      	subs	r2, r3, #1
  2050e2:	63fa      	str	r2, [r7, #60]	; 0x3c
  2050e4:	2b00      	cmp	r3, #0
  2050e6:	d18f      	bne.n	205008 <_DrawArrayBuffRightDown_AA+0x3c>
			Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
			for(int a=0;a<buff_AA[0];++a)
				pLcd[k-(a+1)*BkpSizeX]=buff_AA[1+a];
		}
	}
}
  2050e8:	e06e      	b.n	2051c8 <_DrawArrayBuffRightDown_AA+0x1fc>
			i_prev=i;
  2050ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2050ec:	623b      	str	r3, [r7, #32]
			while(i--){
  2050ee:	e00b      	b.n	205108 <_DrawArrayBuffRightDown_AA+0x13c>
				pLcd[k]=drawColor;
  2050f0:	4b37      	ldr	r3, [pc, #220]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  2050f2:	681b      	ldr	r3, [r3, #0]
  2050f4:	697a      	ldr	r2, [r7, #20]
  2050f6:	4937      	ldr	r1, [pc, #220]	; (2051d4 <_DrawArrayBuffRightDown_AA+0x208>)
  2050f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				k+=BkpSizeX;
  2050fc:	4b34      	ldr	r3, [pc, #208]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  2050fe:	681a      	ldr	r2, [r3, #0]
  205100:	69bb      	ldr	r3, [r7, #24]
  205102:	4413      	add	r3, r2
  205104:	4a32      	ldr	r2, [pc, #200]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205106:	6013      	str	r3, [r2, #0]
			while(i--){
  205108:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20510a:	1e5a      	subs	r2, r3, #1
  20510c:	63ba      	str	r2, [r7, #56]	; 0x38
  20510e:	2b00      	cmp	r3, #0
  205110:	d1ee      	bne.n	2050f0 <_DrawArrayBuffRightDown_AA+0x124>
			if(j){
  205112:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205114:	2b00      	cmp	r3, #0
  205116:	d029      	beq.n	20516c <_DrawArrayBuffRightDown_AA+0x1a0>
				i=buf[p++];
  205118:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20511a:	1c5a      	adds	r2, r3, #1
  20511c:	637a      	str	r2, [r7, #52]	; 0x34
  20511e:	461a      	mov	r2, r3
  205120:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  205122:	4413      	add	r3, r2
  205124:	781b      	ldrb	r3, [r3, #0]
  205126:	63bb      	str	r3, [r7, #56]	; 0x38
				Set_AACoeff_Draw(i,drawColor,inColor,inRatioStart);
  205128:	697b      	ldr	r3, [r7, #20]
  20512a:	ed97 0a00 	vldr	s0, [r7]
  20512e:	68ba      	ldr	r2, [r7, #8]
  205130:	4619      	mov	r1, r3
  205132:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  205134:	f7ff feda 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  205138:	2300      	movs	r3, #0
  20513a:	62bb      	str	r3, [r7, #40]	; 0x28
  20513c:	e011      	b.n	205162 <_DrawArrayBuffRightDown_AA+0x196>
					pLcd[k+a*BkpSizeX]=buff_AA[1+a];
  20513e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205140:	69ba      	ldr	r2, [r7, #24]
  205142:	fb02 f203 	mul.w	r2, r2, r3
  205146:	4b22      	ldr	r3, [pc, #136]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205148:	681b      	ldr	r3, [r3, #0]
  20514a:	4413      	add	r3, r2
  20514c:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20514e:	3201      	adds	r2, #1
  205150:	4921      	ldr	r1, [pc, #132]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  205152:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  205156:	491f      	ldr	r1, [pc, #124]	; (2051d4 <_DrawArrayBuffRightDown_AA+0x208>)
  205158:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  20515c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20515e:	3301      	adds	r3, #1
  205160:	62bb      	str	r3, [r7, #40]	; 0x28
  205162:	4b1d      	ldr	r3, [pc, #116]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  205164:	681a      	ldr	r2, [r3, #0]
  205166:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205168:	429a      	cmp	r2, r3
  20516a:	d8e8      	bhi.n	20513e <_DrawArrayBuffRightDown_AA+0x172>
			k++;
  20516c:	4b18      	ldr	r3, [pc, #96]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  20516e:	681b      	ldr	r3, [r3, #0]
  205170:	3301      	adds	r3, #1
  205172:	4a17      	ldr	r2, [pc, #92]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  205174:	6013      	str	r3, [r2, #0]
			Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
  205176:	697b      	ldr	r3, [r7, #20]
  205178:	ed97 0a01 	vldr	s0, [r7, #4]
  20517c:	68fa      	ldr	r2, [r7, #12]
  20517e:	4619      	mov	r1, r3
  205180:	6a38      	ldr	r0, [r7, #32]
  205182:	f7ff feb3 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  205186:	2300      	movs	r3, #0
  205188:	627b      	str	r3, [r7, #36]	; 0x24
  20518a:	e013      	b.n	2051b4 <_DrawArrayBuffRightDown_AA+0x1e8>
				pLcd[k-(a+1)*BkpSizeX]=buff_AA[1+a];
  20518c:	4b10      	ldr	r3, [pc, #64]	; (2051d0 <_DrawArrayBuffRightDown_AA+0x204>)
  20518e:	681a      	ldr	r2, [r3, #0]
  205190:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205192:	3301      	adds	r3, #1
  205194:	4619      	mov	r1, r3
  205196:	69bb      	ldr	r3, [r7, #24]
  205198:	fb03 f301 	mul.w	r3, r3, r1
  20519c:	1ad3      	subs	r3, r2, r3
  20519e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2051a0:	3201      	adds	r2, #1
  2051a2:	490d      	ldr	r1, [pc, #52]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  2051a4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2051a8:	490a      	ldr	r1, [pc, #40]	; (2051d4 <_DrawArrayBuffRightDown_AA+0x208>)
  2051aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  2051ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2051b0:	3301      	adds	r3, #1
  2051b2:	627b      	str	r3, [r7, #36]	; 0x24
  2051b4:	4b08      	ldr	r3, [pc, #32]	; (2051d8 <_DrawArrayBuffRightDown_AA+0x20c>)
  2051b6:	681a      	ldr	r2, [r3, #0]
  2051b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2051ba:	429a      	cmp	r2, r3
  2051bc:	d8e6      	bhi.n	20518c <_DrawArrayBuffRightDown_AA+0x1c0>
		while(j--)
  2051be:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2051c0:	1e5a      	subs	r2, r3, #1
  2051c2:	63fa      	str	r2, [r7, #60]	; 0x3c
  2051c4:	2b00      	cmp	r3, #0
  2051c6:	d190      	bne.n	2050ea <_DrawArrayBuffRightDown_AA+0x11e>
}
  2051c8:	bf00      	nop
  2051ca:	3740      	adds	r7, #64	; 0x40
  2051cc:	46bd      	mov	sp, r7
  2051ce:	bd80      	pop	{r7, pc}
  2051d0:	20001870 	.word	0x20001870
  2051d4:	c0000000 	.word	0xc0000000
  2051d8:	20001878 	.word	0x20001878

002051dc <_DrawArrayBuffRightUp_AA>:
	}
	va_end(va);
}

void _DrawArrayBuffRightUp_AA(uint32_t drawColor, uint32_t outColor, uint32_t inColor, float outRatioStart, float inRatioStart, uint32_t BkpSizeX, int direction, uint8_t *buf)
{
  2051dc:	b580      	push	{r7, lr}
  2051de:	b08e      	sub	sp, #56	; 0x38
  2051e0:	af00      	add	r7, sp, #0
  2051e2:	6178      	str	r0, [r7, #20]
  2051e4:	6139      	str	r1, [r7, #16]
  2051e6:	60fa      	str	r2, [r7, #12]
  2051e8:	ed87 0a02 	vstr	s0, [r7, #8]
  2051ec:	edc7 0a01 	vstr	s1, [r7, #4]
  2051f0:	603b      	str	r3, [r7, #0]
	int j=buf[0], i=buf[1], p=2, i_prev;
  2051f2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2051f4:	781b      	ldrb	r3, [r3, #0]
  2051f6:	637b      	str	r3, [r7, #52]	; 0x34
  2051f8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2051fa:	3301      	adds	r3, #1
  2051fc:	781b      	ldrb	r3, [r3, #0]
  2051fe:	633b      	str	r3, [r7, #48]	; 0x30
  205200:	2302      	movs	r3, #2
  205202:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(0==direction)
  205204:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  205206:	2b00      	cmp	r3, #0
  205208:	f040 80ce 	bne.w	2053a8 <_DrawArrayBuffRightUp_AA+0x1cc>
	{
		while(j--)
  20520c:	e05e      	b.n	2052cc <_DrawArrayBuffRightUp_AA+0xf0>
		{
			i_prev=i;
  20520e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205210:	61bb      	str	r3, [r7, #24]
			while(i--)
  205212:	e008      	b.n	205226 <_DrawArrayBuffRightUp_AA+0x4a>
				pLcd[k++]=drawColor;
  205214:	4b69      	ldr	r3, [pc, #420]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  205216:	681b      	ldr	r3, [r3, #0]
  205218:	1c5a      	adds	r2, r3, #1
  20521a:	4968      	ldr	r1, [pc, #416]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  20521c:	600a      	str	r2, [r1, #0]
  20521e:	4968      	ldr	r1, [pc, #416]	; (2053c0 <_DrawArrayBuffRightUp_AA+0x1e4>)
  205220:	697a      	ldr	r2, [r7, #20]
  205222:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			while(i--)
  205226:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205228:	1e5a      	subs	r2, r3, #1
  20522a:	633a      	str	r2, [r7, #48]	; 0x30
  20522c:	2b00      	cmp	r3, #0
  20522e:	d1f1      	bne.n	205214 <_DrawArrayBuffRightUp_AA+0x38>

			if(j){
  205230:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205232:	2b00      	cmp	r3, #0
  205234:	d025      	beq.n	205282 <_DrawArrayBuffRightUp_AA+0xa6>
				i=buf[p++];
  205236:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205238:	1c5a      	adds	r2, r3, #1
  20523a:	62fa      	str	r2, [r7, #44]	; 0x2c
  20523c:	461a      	mov	r2, r3
  20523e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  205240:	4413      	add	r3, r2
  205242:	781b      	ldrb	r3, [r3, #0]
  205244:	633b      	str	r3, [r7, #48]	; 0x30
				Set_AACoeff_Draw(i,drawColor,inColor,inRatioStart);
  205246:	ed97 0a01 	vldr	s0, [r7, #4]
  20524a:	68fa      	ldr	r2, [r7, #12]
  20524c:	6979      	ldr	r1, [r7, #20]
  20524e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  205250:	f7ff fe4c 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  205254:	2300      	movs	r3, #0
  205256:	62bb      	str	r3, [r7, #40]	; 0x28
  205258:	e00e      	b.n	205278 <_DrawArrayBuffRightUp_AA+0x9c>
					pLcd[k+a]=buff_AA[1+a];
  20525a:	4b58      	ldr	r3, [pc, #352]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  20525c:	681a      	ldr	r2, [r3, #0]
  20525e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205260:	4413      	add	r3, r2
  205262:	6aba      	ldr	r2, [r7, #40]	; 0x28
  205264:	3201      	adds	r2, #1
  205266:	4957      	ldr	r1, [pc, #348]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  205268:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20526c:	4954      	ldr	r1, [pc, #336]	; (2053c0 <_DrawArrayBuffRightUp_AA+0x1e4>)
  20526e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  205272:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205274:	3301      	adds	r3, #1
  205276:	62bb      	str	r3, [r7, #40]	; 0x28
  205278:	4b52      	ldr	r3, [pc, #328]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  20527a:	681a      	ldr	r2, [r3, #0]
  20527c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20527e:	429a      	cmp	r2, r3
  205280:	d8eb      	bhi.n	20525a <_DrawArrayBuffRightUp_AA+0x7e>
			}
			k-=BkpSizeX;
  205282:	4b4e      	ldr	r3, [pc, #312]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  205284:	681a      	ldr	r2, [r3, #0]
  205286:	683b      	ldr	r3, [r7, #0]
  205288:	1ad3      	subs	r3, r2, r3
  20528a:	4a4c      	ldr	r2, [pc, #304]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  20528c:	6013      	str	r3, [r2, #0]
			Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
  20528e:	ed97 0a02 	vldr	s0, [r7, #8]
  205292:	693a      	ldr	r2, [r7, #16]
  205294:	6979      	ldr	r1, [r7, #20]
  205296:	69b8      	ldr	r0, [r7, #24]
  205298:	f7ff fe28 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  20529c:	2300      	movs	r3, #0
  20529e:	627b      	str	r3, [r7, #36]	; 0x24
  2052a0:	e00f      	b.n	2052c2 <_DrawArrayBuffRightUp_AA+0xe6>
				pLcd[k-1-a]=buff_AA[1+a];
  2052a2:	4b46      	ldr	r3, [pc, #280]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  2052a4:	681a      	ldr	r2, [r3, #0]
  2052a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2052a8:	1ad3      	subs	r3, r2, r3
  2052aa:	3b01      	subs	r3, #1
  2052ac:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2052ae:	3201      	adds	r2, #1
  2052b0:	4944      	ldr	r1, [pc, #272]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  2052b2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2052b6:	4942      	ldr	r1, [pc, #264]	; (2053c0 <_DrawArrayBuffRightUp_AA+0x1e4>)
  2052b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  2052bc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2052be:	3301      	adds	r3, #1
  2052c0:	627b      	str	r3, [r7, #36]	; 0x24
  2052c2:	4b40      	ldr	r3, [pc, #256]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  2052c4:	681a      	ldr	r2, [r3, #0]
  2052c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2052c8:	429a      	cmp	r2, r3
  2052ca:	d8ea      	bhi.n	2052a2 <_DrawArrayBuffRightUp_AA+0xc6>
		while(j--)
  2052cc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2052ce:	1e5a      	subs	r2, r3, #1
  2052d0:	637a      	str	r2, [r7, #52]	; 0x34
  2052d2:	2b00      	cmp	r3, #0
  2052d4:	d19b      	bne.n	20520e <_DrawArrayBuffRightUp_AA+0x32>
			Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
			for(int a=0;a<buff_AA[0];++a)
				pLcd[k+(a+1)*BkpSizeX]=buff_AA[1+a];
		}
	}
}
  2052d6:	e06c      	b.n	2053b2 <_DrawArrayBuffRightUp_AA+0x1d6>
			i_prev=i;
  2052d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2052da:	61bb      	str	r3, [r7, #24]
			while(i--){
  2052dc:	e00b      	b.n	2052f6 <_DrawArrayBuffRightUp_AA+0x11a>
				pLcd[k]=drawColor;
  2052de:	4b37      	ldr	r3, [pc, #220]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  2052e0:	681b      	ldr	r3, [r3, #0]
  2052e2:	4937      	ldr	r1, [pc, #220]	; (2053c0 <_DrawArrayBuffRightUp_AA+0x1e4>)
  2052e4:	697a      	ldr	r2, [r7, #20]
  2052e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				k-=BkpSizeX;
  2052ea:	4b34      	ldr	r3, [pc, #208]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  2052ec:	681a      	ldr	r2, [r3, #0]
  2052ee:	683b      	ldr	r3, [r7, #0]
  2052f0:	1ad3      	subs	r3, r2, r3
  2052f2:	4a32      	ldr	r2, [pc, #200]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  2052f4:	6013      	str	r3, [r2, #0]
			while(i--){
  2052f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2052f8:	1e5a      	subs	r2, r3, #1
  2052fa:	633a      	str	r2, [r7, #48]	; 0x30
  2052fc:	2b00      	cmp	r3, #0
  2052fe:	d1ee      	bne.n	2052de <_DrawArrayBuffRightUp_AA+0x102>
			if(j){
  205300:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205302:	2b00      	cmp	r3, #0
  205304:	d028      	beq.n	205358 <_DrawArrayBuffRightUp_AA+0x17c>
				i=buf[p++];
  205306:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205308:	1c5a      	adds	r2, r3, #1
  20530a:	62fa      	str	r2, [r7, #44]	; 0x2c
  20530c:	461a      	mov	r2, r3
  20530e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  205310:	4413      	add	r3, r2
  205312:	781b      	ldrb	r3, [r3, #0]
  205314:	633b      	str	r3, [r7, #48]	; 0x30
				Set_AACoeff_Draw(i,drawColor,outColor,outRatioStart);
  205316:	ed97 0a02 	vldr	s0, [r7, #8]
  20531a:	693a      	ldr	r2, [r7, #16]
  20531c:	6979      	ldr	r1, [r7, #20]
  20531e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  205320:	f7ff fde4 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  205324:	2300      	movs	r3, #0
  205326:	623b      	str	r3, [r7, #32]
  205328:	e011      	b.n	20534e <_DrawArrayBuffRightUp_AA+0x172>
					pLcd[k-a*BkpSizeX]=buff_AA[1+a];
  20532a:	4b24      	ldr	r3, [pc, #144]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  20532c:	681a      	ldr	r2, [r3, #0]
  20532e:	6a3b      	ldr	r3, [r7, #32]
  205330:	6839      	ldr	r1, [r7, #0]
  205332:	fb01 f303 	mul.w	r3, r1, r3
  205336:	1ad3      	subs	r3, r2, r3
  205338:	6a3a      	ldr	r2, [r7, #32]
  20533a:	3201      	adds	r2, #1
  20533c:	4921      	ldr	r1, [pc, #132]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  20533e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  205342:	491f      	ldr	r1, [pc, #124]	; (2053c0 <_DrawArrayBuffRightUp_AA+0x1e4>)
  205344:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  205348:	6a3b      	ldr	r3, [r7, #32]
  20534a:	3301      	adds	r3, #1
  20534c:	623b      	str	r3, [r7, #32]
  20534e:	4b1d      	ldr	r3, [pc, #116]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  205350:	681a      	ldr	r2, [r3, #0]
  205352:	6a3b      	ldr	r3, [r7, #32]
  205354:	429a      	cmp	r2, r3
  205356:	d8e8      	bhi.n	20532a <_DrawArrayBuffRightUp_AA+0x14e>
			k++;
  205358:	4b18      	ldr	r3, [pc, #96]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  20535a:	681b      	ldr	r3, [r3, #0]
  20535c:	3301      	adds	r3, #1
  20535e:	4a17      	ldr	r2, [pc, #92]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  205360:	6013      	str	r3, [r2, #0]
			Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
  205362:	ed97 0a01 	vldr	s0, [r7, #4]
  205366:	68fa      	ldr	r2, [r7, #12]
  205368:	6979      	ldr	r1, [r7, #20]
  20536a:	69b8      	ldr	r0, [r7, #24]
  20536c:	f7ff fdbe 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  205370:	2300      	movs	r3, #0
  205372:	61fb      	str	r3, [r7, #28]
  205374:	e013      	b.n	20539e <_DrawArrayBuffRightUp_AA+0x1c2>
				pLcd[k+(a+1)*BkpSizeX]=buff_AA[1+a];
  205376:	69fb      	ldr	r3, [r7, #28]
  205378:	3301      	adds	r3, #1
  20537a:	461a      	mov	r2, r3
  20537c:	683b      	ldr	r3, [r7, #0]
  20537e:	fb03 f202 	mul.w	r2, r3, r2
  205382:	4b0e      	ldr	r3, [pc, #56]	; (2053bc <_DrawArrayBuffRightUp_AA+0x1e0>)
  205384:	681b      	ldr	r3, [r3, #0]
  205386:	4413      	add	r3, r2
  205388:	69fa      	ldr	r2, [r7, #28]
  20538a:	3201      	adds	r2, #1
  20538c:	490d      	ldr	r1, [pc, #52]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  20538e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  205392:	490b      	ldr	r1, [pc, #44]	; (2053c0 <_DrawArrayBuffRightUp_AA+0x1e4>)
  205394:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  205398:	69fb      	ldr	r3, [r7, #28]
  20539a:	3301      	adds	r3, #1
  20539c:	61fb      	str	r3, [r7, #28]
  20539e:	4b09      	ldr	r3, [pc, #36]	; (2053c4 <_DrawArrayBuffRightUp_AA+0x1e8>)
  2053a0:	681a      	ldr	r2, [r3, #0]
  2053a2:	69fb      	ldr	r3, [r7, #28]
  2053a4:	429a      	cmp	r2, r3
  2053a6:	d8e6      	bhi.n	205376 <_DrawArrayBuffRightUp_AA+0x19a>
		while(j--)
  2053a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2053aa:	1e5a      	subs	r2, r3, #1
  2053ac:	637a      	str	r2, [r7, #52]	; 0x34
  2053ae:	2b00      	cmp	r3, #0
  2053b0:	d192      	bne.n	2052d8 <_DrawArrayBuffRightUp_AA+0xfc>
}
  2053b2:	bf00      	nop
  2053b4:	3738      	adds	r7, #56	; 0x38
  2053b6:	46bd      	mov	sp, r7
  2053b8:	bd80      	pop	{r7, pc}
  2053ba:	bf00      	nop
  2053bc:	20001870 	.word	0x20001870
  2053c0:	c0000000 	.word	0xc0000000
  2053c4:	20001878 	.word	0x20001878

002053c8 <_DrawArrayBuffLeftDown_AA>:
	}
	va_end(va);
}

void _DrawArrayBuffLeftDown_AA(uint32_t drawColor, uint32_t outColor, uint32_t inColor, float outRatioStart, float inRatioStart, uint32_t BkpSizeX, int direction, uint8_t *buf)
{
  2053c8:	b580      	push	{r7, lr}
  2053ca:	b08e      	sub	sp, #56	; 0x38
  2053cc:	af00      	add	r7, sp, #0
  2053ce:	6178      	str	r0, [r7, #20]
  2053d0:	6139      	str	r1, [r7, #16]
  2053d2:	60fa      	str	r2, [r7, #12]
  2053d4:	ed87 0a02 	vstr	s0, [r7, #8]
  2053d8:	edc7 0a01 	vstr	s1, [r7, #4]
  2053dc:	603b      	str	r3, [r7, #0]
	int j=buf[0], i=buf[1], p=2, i_prev;
  2053de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2053e0:	781b      	ldrb	r3, [r3, #0]
  2053e2:	637b      	str	r3, [r7, #52]	; 0x34
  2053e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2053e6:	3301      	adds	r3, #1
  2053e8:	781b      	ldrb	r3, [r3, #0]
  2053ea:	633b      	str	r3, [r7, #48]	; 0x30
  2053ec:	2302      	movs	r3, #2
  2053ee:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(0==direction)
  2053f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2053f2:	2b00      	cmp	r3, #0
  2053f4:	f040 80ce 	bne.w	205594 <_DrawArrayBuffLeftDown_AA+0x1cc>
	{
		while(j--)
  2053f8:	e05e      	b.n	2054b8 <_DrawArrayBuffLeftDown_AA+0xf0>
		{
			i_prev=i;
  2053fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2053fc:	61bb      	str	r3, [r7, #24]
			while(i--)
  2053fe:	e008      	b.n	205412 <_DrawArrayBuffLeftDown_AA+0x4a>
				pLcd[k--]=drawColor;
  205400:	4b69      	ldr	r3, [pc, #420]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205402:	681b      	ldr	r3, [r3, #0]
  205404:	1e5a      	subs	r2, r3, #1
  205406:	4968      	ldr	r1, [pc, #416]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205408:	600a      	str	r2, [r1, #0]
  20540a:	4968      	ldr	r1, [pc, #416]	; (2055ac <_DrawArrayBuffLeftDown_AA+0x1e4>)
  20540c:	697a      	ldr	r2, [r7, #20]
  20540e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			while(i--)
  205412:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205414:	1e5a      	subs	r2, r3, #1
  205416:	633a      	str	r2, [r7, #48]	; 0x30
  205418:	2b00      	cmp	r3, #0
  20541a:	d1f1      	bne.n	205400 <_DrawArrayBuffLeftDown_AA+0x38>

			if(j){
  20541c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20541e:	2b00      	cmp	r3, #0
  205420:	d025      	beq.n	20546e <_DrawArrayBuffLeftDown_AA+0xa6>
				i=buf[p++];
  205422:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205424:	1c5a      	adds	r2, r3, #1
  205426:	62fa      	str	r2, [r7, #44]	; 0x2c
  205428:	461a      	mov	r2, r3
  20542a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20542c:	4413      	add	r3, r2
  20542e:	781b      	ldrb	r3, [r3, #0]
  205430:	633b      	str	r3, [r7, #48]	; 0x30
				Set_AACoeff_Draw(i,drawColor,inColor,inRatioStart);
  205432:	ed97 0a01 	vldr	s0, [r7, #4]
  205436:	68fa      	ldr	r2, [r7, #12]
  205438:	6979      	ldr	r1, [r7, #20]
  20543a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  20543c:	f7ff fd56 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  205440:	2300      	movs	r3, #0
  205442:	62bb      	str	r3, [r7, #40]	; 0x28
  205444:	e00e      	b.n	205464 <_DrawArrayBuffLeftDown_AA+0x9c>
					pLcd[k-a]=buff_AA[1+a];
  205446:	4b58      	ldr	r3, [pc, #352]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205448:	681a      	ldr	r2, [r3, #0]
  20544a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20544c:	1ad3      	subs	r3, r2, r3
  20544e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  205450:	3201      	adds	r2, #1
  205452:	4957      	ldr	r1, [pc, #348]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  205454:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  205458:	4954      	ldr	r1, [pc, #336]	; (2055ac <_DrawArrayBuffLeftDown_AA+0x1e4>)
  20545a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  20545e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205460:	3301      	adds	r3, #1
  205462:	62bb      	str	r3, [r7, #40]	; 0x28
  205464:	4b52      	ldr	r3, [pc, #328]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  205466:	681a      	ldr	r2, [r3, #0]
  205468:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20546a:	429a      	cmp	r2, r3
  20546c:	d8eb      	bhi.n	205446 <_DrawArrayBuffLeftDown_AA+0x7e>
			}
			k+=BkpSizeX;
  20546e:	4b4e      	ldr	r3, [pc, #312]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205470:	681a      	ldr	r2, [r3, #0]
  205472:	683b      	ldr	r3, [r7, #0]
  205474:	4413      	add	r3, r2
  205476:	4a4c      	ldr	r2, [pc, #304]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205478:	6013      	str	r3, [r2, #0]

			Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
  20547a:	ed97 0a02 	vldr	s0, [r7, #8]
  20547e:	693a      	ldr	r2, [r7, #16]
  205480:	6979      	ldr	r1, [r7, #20]
  205482:	69b8      	ldr	r0, [r7, #24]
  205484:	f7ff fd32 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  205488:	2300      	movs	r3, #0
  20548a:	627b      	str	r3, [r7, #36]	; 0x24
  20548c:	e00f      	b.n	2054ae <_DrawArrayBuffLeftDown_AA+0xe6>
				pLcd[k+1+a]=buff_AA[1+a];
  20548e:	4b46      	ldr	r3, [pc, #280]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205490:	681a      	ldr	r2, [r3, #0]
  205492:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205494:	4413      	add	r3, r2
  205496:	3301      	adds	r3, #1
  205498:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  20549a:	3201      	adds	r2, #1
  20549c:	4944      	ldr	r1, [pc, #272]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  20549e:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  2054a2:	4942      	ldr	r1, [pc, #264]	; (2055ac <_DrawArrayBuffLeftDown_AA+0x1e4>)
  2054a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  2054a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2054aa:	3301      	adds	r3, #1
  2054ac:	627b      	str	r3, [r7, #36]	; 0x24
  2054ae:	4b40      	ldr	r3, [pc, #256]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  2054b0:	681a      	ldr	r2, [r3, #0]
  2054b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2054b4:	429a      	cmp	r2, r3
  2054b6:	d8ea      	bhi.n	20548e <_DrawArrayBuffLeftDown_AA+0xc6>
		while(j--)
  2054b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2054ba:	1e5a      	subs	r2, r3, #1
  2054bc:	637a      	str	r2, [r7, #52]	; 0x34
  2054be:	2b00      	cmp	r3, #0
  2054c0:	d19b      	bne.n	2053fa <_DrawArrayBuffLeftDown_AA+0x32>
			Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
			for(int a=0;a<buff_AA[0];++a)
				pLcd[k-(a+1)*BkpSizeX]=buff_AA[1+a];
		}
	}
}
  2054c2:	e06c      	b.n	20559e <_DrawArrayBuffLeftDown_AA+0x1d6>
			i_prev=i;
  2054c4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2054c6:	61bb      	str	r3, [r7, #24]
			while(i--){
  2054c8:	e00b      	b.n	2054e2 <_DrawArrayBuffLeftDown_AA+0x11a>
				pLcd[k]=drawColor;
  2054ca:	4b37      	ldr	r3, [pc, #220]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  2054cc:	681b      	ldr	r3, [r3, #0]
  2054ce:	4937      	ldr	r1, [pc, #220]	; (2055ac <_DrawArrayBuffLeftDown_AA+0x1e4>)
  2054d0:	697a      	ldr	r2, [r7, #20]
  2054d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				k+=BkpSizeX;
  2054d6:	4b34      	ldr	r3, [pc, #208]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  2054d8:	681a      	ldr	r2, [r3, #0]
  2054da:	683b      	ldr	r3, [r7, #0]
  2054dc:	4413      	add	r3, r2
  2054de:	4a32      	ldr	r2, [pc, #200]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  2054e0:	6013      	str	r3, [r2, #0]
			while(i--){
  2054e2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2054e4:	1e5a      	subs	r2, r3, #1
  2054e6:	633a      	str	r2, [r7, #48]	; 0x30
  2054e8:	2b00      	cmp	r3, #0
  2054ea:	d1ee      	bne.n	2054ca <_DrawArrayBuffLeftDown_AA+0x102>
			if(j){
  2054ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2054ee:	2b00      	cmp	r3, #0
  2054f0:	d028      	beq.n	205544 <_DrawArrayBuffLeftDown_AA+0x17c>
				i=buf[p++];
  2054f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2054f4:	1c5a      	adds	r2, r3, #1
  2054f6:	62fa      	str	r2, [r7, #44]	; 0x2c
  2054f8:	461a      	mov	r2, r3
  2054fa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2054fc:	4413      	add	r3, r2
  2054fe:	781b      	ldrb	r3, [r3, #0]
  205500:	633b      	str	r3, [r7, #48]	; 0x30
				Set_AACoeff_Draw(i,drawColor,outColor,outRatioStart);
  205502:	ed97 0a02 	vldr	s0, [r7, #8]
  205506:	693a      	ldr	r2, [r7, #16]
  205508:	6979      	ldr	r1, [r7, #20]
  20550a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  20550c:	f7ff fcee 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  205510:	2300      	movs	r3, #0
  205512:	623b      	str	r3, [r7, #32]
  205514:	e011      	b.n	20553a <_DrawArrayBuffLeftDown_AA+0x172>
					pLcd[k+a*BkpSizeX]=buff_AA[1+a];
  205516:	6a3b      	ldr	r3, [r7, #32]
  205518:	683a      	ldr	r2, [r7, #0]
  20551a:	fb02 f203 	mul.w	r2, r2, r3
  20551e:	4b22      	ldr	r3, [pc, #136]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205520:	681b      	ldr	r3, [r3, #0]
  205522:	4413      	add	r3, r2
  205524:	6a3a      	ldr	r2, [r7, #32]
  205526:	3201      	adds	r2, #1
  205528:	4921      	ldr	r1, [pc, #132]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  20552a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20552e:	491f      	ldr	r1, [pc, #124]	; (2055ac <_DrawArrayBuffLeftDown_AA+0x1e4>)
  205530:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  205534:	6a3b      	ldr	r3, [r7, #32]
  205536:	3301      	adds	r3, #1
  205538:	623b      	str	r3, [r7, #32]
  20553a:	4b1d      	ldr	r3, [pc, #116]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  20553c:	681a      	ldr	r2, [r3, #0]
  20553e:	6a3b      	ldr	r3, [r7, #32]
  205540:	429a      	cmp	r2, r3
  205542:	d8e8      	bhi.n	205516 <_DrawArrayBuffLeftDown_AA+0x14e>
			k--;
  205544:	4b18      	ldr	r3, [pc, #96]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205546:	681b      	ldr	r3, [r3, #0]
  205548:	3b01      	subs	r3, #1
  20554a:	4a17      	ldr	r2, [pc, #92]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  20554c:	6013      	str	r3, [r2, #0]
			Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
  20554e:	ed97 0a01 	vldr	s0, [r7, #4]
  205552:	68fa      	ldr	r2, [r7, #12]
  205554:	6979      	ldr	r1, [r7, #20]
  205556:	69b8      	ldr	r0, [r7, #24]
  205558:	f7ff fcc8 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  20555c:	2300      	movs	r3, #0
  20555e:	61fb      	str	r3, [r7, #28]
  205560:	e013      	b.n	20558a <_DrawArrayBuffLeftDown_AA+0x1c2>
				pLcd[k-(a+1)*BkpSizeX]=buff_AA[1+a];
  205562:	4b11      	ldr	r3, [pc, #68]	; (2055a8 <_DrawArrayBuffLeftDown_AA+0x1e0>)
  205564:	681a      	ldr	r2, [r3, #0]
  205566:	69fb      	ldr	r3, [r7, #28]
  205568:	3301      	adds	r3, #1
  20556a:	4619      	mov	r1, r3
  20556c:	683b      	ldr	r3, [r7, #0]
  20556e:	fb03 f301 	mul.w	r3, r3, r1
  205572:	1ad3      	subs	r3, r2, r3
  205574:	69fa      	ldr	r2, [r7, #28]
  205576:	3201      	adds	r2, #1
  205578:	490d      	ldr	r1, [pc, #52]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  20557a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20557e:	490b      	ldr	r1, [pc, #44]	; (2055ac <_DrawArrayBuffLeftDown_AA+0x1e4>)
  205580:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  205584:	69fb      	ldr	r3, [r7, #28]
  205586:	3301      	adds	r3, #1
  205588:	61fb      	str	r3, [r7, #28]
  20558a:	4b09      	ldr	r3, [pc, #36]	; (2055b0 <_DrawArrayBuffLeftDown_AA+0x1e8>)
  20558c:	681a      	ldr	r2, [r3, #0]
  20558e:	69fb      	ldr	r3, [r7, #28]
  205590:	429a      	cmp	r2, r3
  205592:	d8e6      	bhi.n	205562 <_DrawArrayBuffLeftDown_AA+0x19a>
		while(j--)
  205594:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205596:	1e5a      	subs	r2, r3, #1
  205598:	637a      	str	r2, [r7, #52]	; 0x34
  20559a:	2b00      	cmp	r3, #0
  20559c:	d192      	bne.n	2054c4 <_DrawArrayBuffLeftDown_AA+0xfc>
}
  20559e:	bf00      	nop
  2055a0:	3738      	adds	r7, #56	; 0x38
  2055a2:	46bd      	mov	sp, r7
  2055a4:	bd80      	pop	{r7, pc}
  2055a6:	bf00      	nop
  2055a8:	20001870 	.word	0x20001870
  2055ac:	c0000000 	.word	0xc0000000
  2055b0:	20001878 	.word	0x20001878

002055b4 <_DrawArrayBuffLeftUp_AA>:
	}
	va_end(va);
}

void _DrawArrayBuffLeftUp_AA(uint32_t drawColor, uint32_t outColor, uint32_t inColor, float outRatioStart, float inRatioStart, uint32_t BkpSizeX, int direction, uint8_t *buf)
{
  2055b4:	b580      	push	{r7, lr}
  2055b6:	b08e      	sub	sp, #56	; 0x38
  2055b8:	af00      	add	r7, sp, #0
  2055ba:	6178      	str	r0, [r7, #20]
  2055bc:	6139      	str	r1, [r7, #16]
  2055be:	60fa      	str	r2, [r7, #12]
  2055c0:	ed87 0a02 	vstr	s0, [r7, #8]
  2055c4:	edc7 0a01 	vstr	s1, [r7, #4]
  2055c8:	603b      	str	r3, [r7, #0]
	int j=buf[0], i=buf[1], p=2, i_prev;
  2055ca:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2055cc:	781b      	ldrb	r3, [r3, #0]
  2055ce:	637b      	str	r3, [r7, #52]	; 0x34
  2055d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2055d2:	3301      	adds	r3, #1
  2055d4:	781b      	ldrb	r3, [r3, #0]
  2055d6:	633b      	str	r3, [r7, #48]	; 0x30
  2055d8:	2302      	movs	r3, #2
  2055da:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(0==direction)
  2055dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2055de:	2b00      	cmp	r3, #0
  2055e0:	f040 80ce 	bne.w	205780 <_DrawArrayBuffLeftUp_AA+0x1cc>
	{
		while(j--)
  2055e4:	e05e      	b.n	2056a4 <_DrawArrayBuffLeftUp_AA+0xf0>
		{
			i_prev=i;
  2055e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2055e8:	61bb      	str	r3, [r7, #24]
			while(i--)
  2055ea:	e008      	b.n	2055fe <_DrawArrayBuffLeftUp_AA+0x4a>
				pLcd[k--]=drawColor;
  2055ec:	4b69      	ldr	r3, [pc, #420]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  2055ee:	681b      	ldr	r3, [r3, #0]
  2055f0:	1e5a      	subs	r2, r3, #1
  2055f2:	4968      	ldr	r1, [pc, #416]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  2055f4:	600a      	str	r2, [r1, #0]
  2055f6:	4968      	ldr	r1, [pc, #416]	; (205798 <_DrawArrayBuffLeftUp_AA+0x1e4>)
  2055f8:	697a      	ldr	r2, [r7, #20]
  2055fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			while(i--)
  2055fe:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205600:	1e5a      	subs	r2, r3, #1
  205602:	633a      	str	r2, [r7, #48]	; 0x30
  205604:	2b00      	cmp	r3, #0
  205606:	d1f1      	bne.n	2055ec <_DrawArrayBuffLeftUp_AA+0x38>

			if(j){
  205608:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20560a:	2b00      	cmp	r3, #0
  20560c:	d025      	beq.n	20565a <_DrawArrayBuffLeftUp_AA+0xa6>
				i=buf[p++];
  20560e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205610:	1c5a      	adds	r2, r3, #1
  205612:	62fa      	str	r2, [r7, #44]	; 0x2c
  205614:	461a      	mov	r2, r3
  205616:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  205618:	4413      	add	r3, r2
  20561a:	781b      	ldrb	r3, [r3, #0]
  20561c:	633b      	str	r3, [r7, #48]	; 0x30
				Set_AACoeff_Draw(i,drawColor,outColor,outRatioStart);
  20561e:	ed97 0a02 	vldr	s0, [r7, #8]
  205622:	693a      	ldr	r2, [r7, #16]
  205624:	6979      	ldr	r1, [r7, #20]
  205626:	6b38      	ldr	r0, [r7, #48]	; 0x30
  205628:	f7ff fc60 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  20562c:	2300      	movs	r3, #0
  20562e:	62bb      	str	r3, [r7, #40]	; 0x28
  205630:	e00e      	b.n	205650 <_DrawArrayBuffLeftUp_AA+0x9c>
					pLcd[k-a]=buff_AA[1+a];
  205632:	4b58      	ldr	r3, [pc, #352]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  205634:	681a      	ldr	r2, [r3, #0]
  205636:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205638:	1ad3      	subs	r3, r2, r3
  20563a:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20563c:	3201      	adds	r2, #1
  20563e:	4957      	ldr	r1, [pc, #348]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  205640:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  205644:	4954      	ldr	r1, [pc, #336]	; (205798 <_DrawArrayBuffLeftUp_AA+0x1e4>)
  205646:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  20564a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20564c:	3301      	adds	r3, #1
  20564e:	62bb      	str	r3, [r7, #40]	; 0x28
  205650:	4b52      	ldr	r3, [pc, #328]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  205652:	681a      	ldr	r2, [r3, #0]
  205654:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205656:	429a      	cmp	r2, r3
  205658:	d8eb      	bhi.n	205632 <_DrawArrayBuffLeftUp_AA+0x7e>
			}
			k-=BkpSizeX;
  20565a:	4b4e      	ldr	r3, [pc, #312]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  20565c:	681a      	ldr	r2, [r3, #0]
  20565e:	683b      	ldr	r3, [r7, #0]
  205660:	1ad3      	subs	r3, r2, r3
  205662:	4a4c      	ldr	r2, [pc, #304]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  205664:	6013      	str	r3, [r2, #0]

			Set_AACoeff_Draw(i_prev,drawColor,inColor,inRatioStart);
  205666:	ed97 0a01 	vldr	s0, [r7, #4]
  20566a:	68fa      	ldr	r2, [r7, #12]
  20566c:	6979      	ldr	r1, [r7, #20]
  20566e:	69b8      	ldr	r0, [r7, #24]
  205670:	f7ff fc3c 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  205674:	2300      	movs	r3, #0
  205676:	627b      	str	r3, [r7, #36]	; 0x24
  205678:	e00f      	b.n	20569a <_DrawArrayBuffLeftUp_AA+0xe6>
				pLcd[k+1+a]=buff_AA[1+a];
  20567a:	4b46      	ldr	r3, [pc, #280]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  20567c:	681a      	ldr	r2, [r3, #0]
  20567e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205680:	4413      	add	r3, r2
  205682:	3301      	adds	r3, #1
  205684:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  205686:	3201      	adds	r2, #1
  205688:	4944      	ldr	r1, [pc, #272]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  20568a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20568e:	4942      	ldr	r1, [pc, #264]	; (205798 <_DrawArrayBuffLeftUp_AA+0x1e4>)
  205690:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  205694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205696:	3301      	adds	r3, #1
  205698:	627b      	str	r3, [r7, #36]	; 0x24
  20569a:	4b40      	ldr	r3, [pc, #256]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  20569c:	681a      	ldr	r2, [r3, #0]
  20569e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2056a0:	429a      	cmp	r2, r3
  2056a2:	d8ea      	bhi.n	20567a <_DrawArrayBuffLeftUp_AA+0xc6>
		while(j--)
  2056a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2056a6:	1e5a      	subs	r2, r3, #1
  2056a8:	637a      	str	r2, [r7, #52]	; 0x34
  2056aa:	2b00      	cmp	r3, #0
  2056ac:	d19b      	bne.n	2055e6 <_DrawArrayBuffLeftUp_AA+0x32>
			Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
			for(int a=0;a<buff_AA[0];++a)
				pLcd[k+(a+1)*BkpSizeX]=buff_AA[1+a];
		}
	}
}
  2056ae:	e06c      	b.n	20578a <_DrawArrayBuffLeftUp_AA+0x1d6>
			i_prev=i;
  2056b0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2056b2:	61bb      	str	r3, [r7, #24]
			while(i--){
  2056b4:	e00b      	b.n	2056ce <_DrawArrayBuffLeftUp_AA+0x11a>
				pLcd[k]=drawColor;
  2056b6:	4b37      	ldr	r3, [pc, #220]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  2056b8:	681b      	ldr	r3, [r3, #0]
  2056ba:	4937      	ldr	r1, [pc, #220]	; (205798 <_DrawArrayBuffLeftUp_AA+0x1e4>)
  2056bc:	697a      	ldr	r2, [r7, #20]
  2056be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				k-=BkpSizeX;
  2056c2:	4b34      	ldr	r3, [pc, #208]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  2056c4:	681a      	ldr	r2, [r3, #0]
  2056c6:	683b      	ldr	r3, [r7, #0]
  2056c8:	1ad3      	subs	r3, r2, r3
  2056ca:	4a32      	ldr	r2, [pc, #200]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  2056cc:	6013      	str	r3, [r2, #0]
			while(i--){
  2056ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2056d0:	1e5a      	subs	r2, r3, #1
  2056d2:	633a      	str	r2, [r7, #48]	; 0x30
  2056d4:	2b00      	cmp	r3, #0
  2056d6:	d1ee      	bne.n	2056b6 <_DrawArrayBuffLeftUp_AA+0x102>
			if(j){
  2056d8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2056da:	2b00      	cmp	r3, #0
  2056dc:	d028      	beq.n	205730 <_DrawArrayBuffLeftUp_AA+0x17c>
				i=buf[p++];
  2056de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2056e0:	1c5a      	adds	r2, r3, #1
  2056e2:	62fa      	str	r2, [r7, #44]	; 0x2c
  2056e4:	461a      	mov	r2, r3
  2056e6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2056e8:	4413      	add	r3, r2
  2056ea:	781b      	ldrb	r3, [r3, #0]
  2056ec:	633b      	str	r3, [r7, #48]	; 0x30
				Set_AACoeff_Draw(i,drawColor,inColor,inRatioStart);
  2056ee:	ed97 0a01 	vldr	s0, [r7, #4]
  2056f2:	68fa      	ldr	r2, [r7, #12]
  2056f4:	6979      	ldr	r1, [r7, #20]
  2056f6:	6b38      	ldr	r0, [r7, #48]	; 0x30
  2056f8:	f7ff fbf8 	bl	204eec <Set_AACoeff_Draw>
				for(int a=0;a<buff_AA[0];++a)
  2056fc:	2300      	movs	r3, #0
  2056fe:	623b      	str	r3, [r7, #32]
  205700:	e011      	b.n	205726 <_DrawArrayBuffLeftUp_AA+0x172>
					pLcd[k-a*BkpSizeX]=buff_AA[1+a];
  205702:	4b24      	ldr	r3, [pc, #144]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  205704:	681a      	ldr	r2, [r3, #0]
  205706:	6a3b      	ldr	r3, [r7, #32]
  205708:	6839      	ldr	r1, [r7, #0]
  20570a:	fb01 f303 	mul.w	r3, r1, r3
  20570e:	1ad3      	subs	r3, r2, r3
  205710:	6a3a      	ldr	r2, [r7, #32]
  205712:	3201      	adds	r2, #1
  205714:	4921      	ldr	r1, [pc, #132]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  205716:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20571a:	491f      	ldr	r1, [pc, #124]	; (205798 <_DrawArrayBuffLeftUp_AA+0x1e4>)
  20571c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				for(int a=0;a<buff_AA[0];++a)
  205720:	6a3b      	ldr	r3, [r7, #32]
  205722:	3301      	adds	r3, #1
  205724:	623b      	str	r3, [r7, #32]
  205726:	4b1d      	ldr	r3, [pc, #116]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  205728:	681a      	ldr	r2, [r3, #0]
  20572a:	6a3b      	ldr	r3, [r7, #32]
  20572c:	429a      	cmp	r2, r3
  20572e:	d8e8      	bhi.n	205702 <_DrawArrayBuffLeftUp_AA+0x14e>
			k--;
  205730:	4b18      	ldr	r3, [pc, #96]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  205732:	681b      	ldr	r3, [r3, #0]
  205734:	3b01      	subs	r3, #1
  205736:	4a17      	ldr	r2, [pc, #92]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  205738:	6013      	str	r3, [r2, #0]
			Set_AACoeff_Draw(i_prev,drawColor,outColor,outRatioStart);
  20573a:	ed97 0a02 	vldr	s0, [r7, #8]
  20573e:	693a      	ldr	r2, [r7, #16]
  205740:	6979      	ldr	r1, [r7, #20]
  205742:	69b8      	ldr	r0, [r7, #24]
  205744:	f7ff fbd2 	bl	204eec <Set_AACoeff_Draw>
			for(int a=0;a<buff_AA[0];++a)
  205748:	2300      	movs	r3, #0
  20574a:	61fb      	str	r3, [r7, #28]
  20574c:	e013      	b.n	205776 <_DrawArrayBuffLeftUp_AA+0x1c2>
				pLcd[k+(a+1)*BkpSizeX]=buff_AA[1+a];
  20574e:	69fb      	ldr	r3, [r7, #28]
  205750:	3301      	adds	r3, #1
  205752:	461a      	mov	r2, r3
  205754:	683b      	ldr	r3, [r7, #0]
  205756:	fb03 f202 	mul.w	r2, r3, r2
  20575a:	4b0e      	ldr	r3, [pc, #56]	; (205794 <_DrawArrayBuffLeftUp_AA+0x1e0>)
  20575c:	681b      	ldr	r3, [r3, #0]
  20575e:	4413      	add	r3, r2
  205760:	69fa      	ldr	r2, [r7, #28]
  205762:	3201      	adds	r2, #1
  205764:	490d      	ldr	r1, [pc, #52]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  205766:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  20576a:	490b      	ldr	r1, [pc, #44]	; (205798 <_DrawArrayBuffLeftUp_AA+0x1e4>)
  20576c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int a=0;a<buff_AA[0];++a)
  205770:	69fb      	ldr	r3, [r7, #28]
  205772:	3301      	adds	r3, #1
  205774:	61fb      	str	r3, [r7, #28]
  205776:	4b09      	ldr	r3, [pc, #36]	; (20579c <_DrawArrayBuffLeftUp_AA+0x1e8>)
  205778:	681a      	ldr	r2, [r3, #0]
  20577a:	69fb      	ldr	r3, [r7, #28]
  20577c:	429a      	cmp	r2, r3
  20577e:	d8e6      	bhi.n	20574e <_DrawArrayBuffLeftUp_AA+0x19a>
		while(j--)
  205780:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205782:	1e5a      	subs	r2, r3, #1
  205784:	637a      	str	r2, [r7, #52]	; 0x34
  205786:	2b00      	cmp	r3, #0
  205788:	d192      	bne.n	2056b0 <_DrawArrayBuffLeftUp_AA+0xfc>
}
  20578a:	bf00      	nop
  20578c:	3738      	adds	r7, #56	; 0x38
  20578e:	46bd      	mov	sp, r7
  205790:	bd80      	pop	{r7, pc}
  205792:	bf00      	nop
  205794:	20001870 	.word	0x20001870
  205798:	c0000000 	.word	0xc0000000
  20579c:	20001878 	.word	0x20001878

002057a0 <LCD_Display>:

void LCD_Display(uint32_t posBuff, uint32_t Xpos, uint32_t Ypos, uint32_t width, uint32_t height){
  2057a0:	b580      	push	{r7, lr}
  2057a2:	b086      	sub	sp, #24
  2057a4:	af02      	add	r7, sp, #8
  2057a6:	60f8      	str	r0, [r7, #12]
  2057a8:	60b9      	str	r1, [r7, #8]
  2057aa:	607a      	str	r2, [r7, #4]
  2057ac:	603b      	str	r3, [r7, #0]
	LCD_DisplayBuff(Xpos,Ypos,width,height,  pLcd+posBuff);
  2057ae:	68fb      	ldr	r3, [r7, #12]
  2057b0:	009b      	lsls	r3, r3, #2
  2057b2:	4a06      	ldr	r2, [pc, #24]	; (2057cc <LCD_Display+0x2c>)
  2057b4:	4413      	add	r3, r2
  2057b6:	9300      	str	r3, [sp, #0]
  2057b8:	69bb      	ldr	r3, [r7, #24]
  2057ba:	683a      	ldr	r2, [r7, #0]
  2057bc:	6879      	ldr	r1, [r7, #4]
  2057be:	68b8      	ldr	r0, [r7, #8]
  2057c0:	f002 f968 	bl	207a94 <LCD_DisplayBuff>
}
  2057c4:	bf00      	nop
  2057c6:	3710      	adds	r7, #16
  2057c8:	46bd      	mov	sp, r7
  2057ca:	bd80      	pop	{r7, pc}
  2057cc:	c0000000 	.word	0xc0000000

002057d0 <LCD_Show>:
void LCD_Show(void){
  2057d0:	b590      	push	{r4, r7, lr}
  2057d2:	b083      	sub	sp, #12
  2057d4:	af02      	add	r7, sp, #8
	LCD_Display(0,0,0,LCD_X,LCD_Y);
  2057d6:	f002 f8e7 	bl	2079a8 <LCD_GetXSize>
  2057da:	4604      	mov	r4, r0
  2057dc:	f002 f8f8 	bl	2079d0 <LCD_GetYSize>
  2057e0:	4603      	mov	r3, r0
  2057e2:	9300      	str	r3, [sp, #0]
  2057e4:	4623      	mov	r3, r4
  2057e6:	2200      	movs	r2, #0
  2057e8:	2100      	movs	r1, #0
  2057ea:	2000      	movs	r0, #0
  2057ec:	f7ff ffd8 	bl	2057a0 <LCD_Display>
}
  2057f0:	bf00      	nop
  2057f2:	3704      	adds	r7, #4
  2057f4:	46bd      	mov	sp, r7
  2057f6:	bd90      	pop	{r4, r7, pc}

002057f8 <LCD_Shape>:

void LCD_Shape(uint32_t x,uint32_t y,figureShape pShape,uint32_t width,uint32_t height,uint32_t FrameColor,uint32_t FillColor,uint32_t BkpColor){
  2057f8:	b590      	push	{r4, r7, lr}
  2057fa:	b08d      	sub	sp, #52	; 0x34
  2057fc:	af08      	add	r7, sp, #32
  2057fe:	60f8      	str	r0, [r7, #12]
  205800:	60b9      	str	r1, [r7, #8]
  205802:	607a      	str	r2, [r7, #4]
  205804:	603b      	str	r3, [r7, #0]
	LCD_ShapeWindow(pShape,0,LCD_X,LCD_Y,x,y,width,height,FrameColor,FillColor,BkpColor);
  205806:	f002 f8cf 	bl	2079a8 <LCD_GetXSize>
  20580a:	4604      	mov	r4, r0
  20580c:	f002 f8e0 	bl	2079d0 <LCD_GetYSize>
  205810:	4602      	mov	r2, r0
  205812:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205814:	9306      	str	r3, [sp, #24]
  205816:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205818:	9305      	str	r3, [sp, #20]
  20581a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20581c:	9304      	str	r3, [sp, #16]
  20581e:	6a3b      	ldr	r3, [r7, #32]
  205820:	9303      	str	r3, [sp, #12]
  205822:	683b      	ldr	r3, [r7, #0]
  205824:	9302      	str	r3, [sp, #8]
  205826:	68bb      	ldr	r3, [r7, #8]
  205828:	9301      	str	r3, [sp, #4]
  20582a:	68fb      	ldr	r3, [r7, #12]
  20582c:	9300      	str	r3, [sp, #0]
  20582e:	4613      	mov	r3, r2
  205830:	4622      	mov	r2, r4
  205832:	2100      	movs	r1, #0
  205834:	6878      	ldr	r0, [r7, #4]
  205836:	f000 f804 	bl	205842 <LCD_ShapeWindow>
}
  20583a:	bf00      	nop
  20583c:	3714      	adds	r7, #20
  20583e:	46bd      	mov	sp, r7
  205840:	bd90      	pop	{r4, r7, pc}

00205842 <LCD_ShapeWindow>:
void LCD_ShapeWindow(figureShape pShape,uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205842:	b590      	push	{r4, r7, lr}
  205844:	b08b      	sub	sp, #44	; 0x2c
  205846:	af06      	add	r7, sp, #24
  205848:	60f8      	str	r0, [r7, #12]
  20584a:	60b9      	str	r1, [r7, #8]
  20584c:	607a      	str	r2, [r7, #4]
  20584e:	603b      	str	r3, [r7, #0]
	pShape(posBuff,BkpSizeX,BkpSizeY,x,y,width,height,FrameColor,FillColor,BkpColor);
  205850:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  205852:	9305      	str	r3, [sp, #20]
  205854:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205856:	9304      	str	r3, [sp, #16]
  205858:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20585a:	9303      	str	r3, [sp, #12]
  20585c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20585e:	9302      	str	r3, [sp, #8]
  205860:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205862:	9301      	str	r3, [sp, #4]
  205864:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205866:	9300      	str	r3, [sp, #0]
  205868:	68fc      	ldr	r4, [r7, #12]
  20586a:	6a3b      	ldr	r3, [r7, #32]
  20586c:	683a      	ldr	r2, [r7, #0]
  20586e:	6879      	ldr	r1, [r7, #4]
  205870:	68b8      	ldr	r0, [r7, #8]
  205872:	47a0      	blx	r4
}
  205874:	bf00      	nop
  205876:	3714      	adds	r7, #20
  205878:	46bd      	mov	sp, r7
  20587a:	bd90      	pop	{r4, r7, pc}

0020587c <LCD_ShapeIndirect>:
void LCD_ShapeIndirect(uint32_t xPos,uint32_t yPos,figureShape pShape, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  20587c:	b590      	push	{r4, r7, lr}
  20587e:	b08b      	sub	sp, #44	; 0x2c
  205880:	af06      	add	r7, sp, #24
  205882:	60f8      	str	r0, [r7, #12]
  205884:	60b9      	str	r1, [r7, #8]
  205886:	607a      	str	r2, [r7, #4]
  205888:	603b      	str	r3, [r7, #0]
	pShape(0,width,height,0,0,width,height,FrameColor,FillColor,BkpColor);
  20588a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20588c:	9305      	str	r3, [sp, #20]
  20588e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205890:	9304      	str	r3, [sp, #16]
  205892:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205894:	9303      	str	r3, [sp, #12]
  205896:	6a3b      	ldr	r3, [r7, #32]
  205898:	9302      	str	r3, [sp, #8]
  20589a:	683b      	ldr	r3, [r7, #0]
  20589c:	9301      	str	r3, [sp, #4]
  20589e:	2300      	movs	r3, #0
  2058a0:	9300      	str	r3, [sp, #0]
  2058a2:	687c      	ldr	r4, [r7, #4]
  2058a4:	2300      	movs	r3, #0
  2058a6:	6a3a      	ldr	r2, [r7, #32]
  2058a8:	6839      	ldr	r1, [r7, #0]
  2058aa:	2000      	movs	r0, #0
  2058ac:	47a0      	blx	r4
	LCD_Display(0,xPos,yPos,width,height);
  2058ae:	6a3b      	ldr	r3, [r7, #32]
  2058b0:	9300      	str	r3, [sp, #0]
  2058b2:	683b      	ldr	r3, [r7, #0]
  2058b4:	68ba      	ldr	r2, [r7, #8]
  2058b6:	68f9      	ldr	r1, [r7, #12]
  2058b8:	2000      	movs	r0, #0
  2058ba:	f7ff ff71 	bl	2057a0 <LCD_Display>
}
  2058be:	bf00      	nop
  2058c0:	3714      	adds	r7, #20
  2058c2:	46bd      	mov	sp, r7
  2058c4:	bd90      	pop	{r4, r7, pc}
	...

002058c8 <LCD_Clear>:
void LCD_ShapeWindowIndirect(uint32_t xPos,uint32_t yPos,figureShape pShape,uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
	pShape(posBuff,BkpSizeX,BkpSizeY,x,y,width,height,FrameColor,FillColor,BkpColor);
	LCD_Display(posBuff,xPos,yPos,BkpSizeX,BkpSizeY);
}

void LCD_Clear(uint32_t color){
  2058c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  2058ca:	b08b      	sub	sp, #44	; 0x2c
  2058cc:	af08      	add	r7, sp, #32
  2058ce:	6078      	str	r0, [r7, #4]
	LCD_ShapeWindow(LCD_Rectangle,0,LCD_X,LCD_Y, 0,0, LCD_X, LCD_Y, color,color,color);
  2058d0:	f002 f86a 	bl	2079a8 <LCD_GetXSize>
  2058d4:	4605      	mov	r5, r0
  2058d6:	f002 f87b 	bl	2079d0 <LCD_GetYSize>
  2058da:	4606      	mov	r6, r0
  2058dc:	f002 f864 	bl	2079a8 <LCD_GetXSize>
  2058e0:	4604      	mov	r4, r0
  2058e2:	f002 f875 	bl	2079d0 <LCD_GetYSize>
  2058e6:	4602      	mov	r2, r0
  2058e8:	687b      	ldr	r3, [r7, #4]
  2058ea:	9306      	str	r3, [sp, #24]
  2058ec:	687b      	ldr	r3, [r7, #4]
  2058ee:	9305      	str	r3, [sp, #20]
  2058f0:	687b      	ldr	r3, [r7, #4]
  2058f2:	9304      	str	r3, [sp, #16]
  2058f4:	9203      	str	r2, [sp, #12]
  2058f6:	9402      	str	r4, [sp, #8]
  2058f8:	2300      	movs	r3, #0
  2058fa:	9301      	str	r3, [sp, #4]
  2058fc:	2300      	movs	r3, #0
  2058fe:	9300      	str	r3, [sp, #0]
  205900:	4633      	mov	r3, r6
  205902:	462a      	mov	r2, r5
  205904:	2100      	movs	r1, #0
  205906:	4803      	ldr	r0, [pc, #12]	; (205914 <LCD_Clear+0x4c>)
  205908:	f7ff ff9b 	bl	205842 <LCD_ShapeWindow>
}
  20590c:	bf00      	nop
  20590e:	370c      	adds	r7, #12
  205910:	46bd      	mov	sp, r7
  205912:	bdf0      	pop	{r4, r5, r6, r7, pc}
  205914:	0020593d 	.word	0x0020593d

00205918 <SetColorBoldFrame>:
void LCD_ClearIndirect(uint32_t posBuff, uint32_t BkpSizeX, uint32_t BkpSizeY, uint32_t color){
	LCD_ShapeWindow(LCD_Rectangle,posBuff,BkpSizeX,BkpSizeY, 0,0, BkpSizeX, BkpSizeY, color,color,color);
}
uint32_t SetColorBoldFrame(uint32_t frameColor, uint8_t thickness){
  205918:	b480      	push	{r7}
  20591a:	b083      	sub	sp, #12
  20591c:	af00      	add	r7, sp, #0
  20591e:	6078      	str	r0, [r7, #4]
  205920:	460b      	mov	r3, r1
  205922:	70fb      	strb	r3, [r7, #3]
	return (frameColor&0xFFFFFF)|thickness<<24;
  205924:	687b      	ldr	r3, [r7, #4]
  205926:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  20592a:	78fa      	ldrb	r2, [r7, #3]
  20592c:	0612      	lsls	r2, r2, #24
  20592e:	4313      	orrs	r3, r2
}
  205930:	4618      	mov	r0, r3
  205932:	370c      	adds	r7, #12
  205934:	46bd      	mov	sp, r7
  205936:	f85d 7b04 	ldr.w	r7, [sp], #4
  20593a:	4770      	bx	lr

0020593c <LCD_Rectangle>:

void LCD_Rectangle(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  20593c:	b580      	push	{r7, lr}
  20593e:	b086      	sub	sp, #24
  205940:	af00      	add	r7, sp, #0
  205942:	60f8      	str	r0, [r7, #12]
  205944:	60b9      	str	r1, [r7, #8]
  205946:	607a      	str	r2, [r7, #4]
  205948:	603b      	str	r3, [r7, #0]
	_StartDrawLine(posBuff,BkpSizeX,x,y);
  20594a:	6a3b      	ldr	r3, [r7, #32]
  20594c:	683a      	ldr	r2, [r7, #0]
  20594e:	68b9      	ldr	r1, [r7, #8]
  205950:	68f8      	ldr	r0, [r7, #12]
  205952:	f7ff fa25 	bl	204da0 <_StartDrawLine>
	_FillBuff(width, FrameColor);
  205956:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205958:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  20595a:	4618      	mov	r0, r3
  20595c:	f7ff f974 	bl	204c48 <_FillBuff>
	if(height>1)
  205960:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205962:	2b01      	cmp	r3, #1
  205964:	d925      	bls.n	2059b2 <LCD_Rectangle+0x76>
	{
		_NextDrawLine(BkpSizeX,width);
  205966:	6a79      	ldr	r1, [r7, #36]	; 0x24
  205968:	68b8      	ldr	r0, [r7, #8]
  20596a:	f7ff fa81 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<height-2; j++)
  20596e:	2300      	movs	r3, #0
  205970:	617b      	str	r3, [r7, #20]
  205972:	e014      	b.n	20599e <LCD_Rectangle+0x62>
		{
			_FillBuff(1, FrameColor);
  205974:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  205976:	2001      	movs	r0, #1
  205978:	f7ff f966 	bl	204c48 <_FillBuff>
			_FillBuff(width-2, FillColor);
  20597c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20597e:	3b02      	subs	r3, #2
  205980:	6b39      	ldr	r1, [r7, #48]	; 0x30
  205982:	4618      	mov	r0, r3
  205984:	f7ff f960 	bl	204c48 <_FillBuff>
			_FillBuff(1, FrameColor);
  205988:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  20598a:	2001      	movs	r0, #1
  20598c:	f7ff f95c 	bl	204c48 <_FillBuff>
			_NextDrawLine(BkpSizeX,width);
  205990:	6a79      	ldr	r1, [r7, #36]	; 0x24
  205992:	68b8      	ldr	r0, [r7, #8]
  205994:	f7ff fa6c 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<height-2; j++)
  205998:	697b      	ldr	r3, [r7, #20]
  20599a:	3301      	adds	r3, #1
  20599c:	617b      	str	r3, [r7, #20]
  20599e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2059a0:	1e9a      	subs	r2, r3, #2
  2059a2:	697b      	ldr	r3, [r7, #20]
  2059a4:	429a      	cmp	r2, r3
  2059a6:	d8e5      	bhi.n	205974 <LCD_Rectangle+0x38>
		}
		_FillBuff(width, FrameColor);
  2059a8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2059aa:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  2059ac:	4618      	mov	r0, r3
  2059ae:	f7ff f94b 	bl	204c48 <_FillBuff>
	}
}
  2059b2:	bf00      	nop
  2059b4:	3718      	adds	r7, #24
  2059b6:	46bd      	mov	sp, r7
  2059b8:	bd80      	pop	{r7, pc}
	...

002059bc <LCD_Frame>:
void LCD_Frame(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  2059bc:	b580      	push	{r7, lr}
  2059be:	b086      	sub	sp, #24
  2059c0:	af00      	add	r7, sp, #0
  2059c2:	60f8      	str	r0, [r7, #12]
  2059c4:	60b9      	str	r1, [r7, #8]
  2059c6:	607a      	str	r2, [r7, #4]
  2059c8:	603b      	str	r3, [r7, #0]
	_StartDrawLine(posBuff,BkpSizeX,x,y);
  2059ca:	6a3b      	ldr	r3, [r7, #32]
  2059cc:	683a      	ldr	r2, [r7, #0]
  2059ce:	68b9      	ldr	r1, [r7, #8]
  2059d0:	68f8      	ldr	r0, [r7, #12]
  2059d2:	f7ff f9e5 	bl	204da0 <_StartDrawLine>
	_FillBuff(width, FrameColor);
  2059d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2059d8:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  2059da:	4618      	mov	r0, r3
  2059dc:	f7ff f934 	bl	204c48 <_FillBuff>
	if(height>1)
  2059e0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2059e2:	2b01      	cmp	r3, #1
  2059e4:	d926      	bls.n	205a34 <LCD_Frame+0x78>
	{
		_NextDrawLine(BkpSizeX,width);
  2059e6:	6a79      	ldr	r1, [r7, #36]	; 0x24
  2059e8:	68b8      	ldr	r0, [r7, #8]
  2059ea:	f7ff fa41 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<height-2; j++)
  2059ee:	2300      	movs	r3, #0
  2059f0:	617b      	str	r3, [r7, #20]
  2059f2:	e015      	b.n	205a20 <LCD_Frame+0x64>
		{
			_FillBuff(1, FrameColor);
  2059f4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  2059f6:	2001      	movs	r0, #1
  2059f8:	f7ff f926 	bl	204c48 <_FillBuff>
			k+=width-2;
  2059fc:	4b0f      	ldr	r3, [pc, #60]	; (205a3c <LCD_Frame+0x80>)
  2059fe:	681a      	ldr	r2, [r3, #0]
  205a00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205a02:	4413      	add	r3, r2
  205a04:	3b02      	subs	r3, #2
  205a06:	4a0d      	ldr	r2, [pc, #52]	; (205a3c <LCD_Frame+0x80>)
  205a08:	6013      	str	r3, [r2, #0]
			_FillBuff(1, FrameColor);
  205a0a:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  205a0c:	2001      	movs	r0, #1
  205a0e:	f7ff f91b 	bl	204c48 <_FillBuff>
			_NextDrawLine(BkpSizeX,width);
  205a12:	6a79      	ldr	r1, [r7, #36]	; 0x24
  205a14:	68b8      	ldr	r0, [r7, #8]
  205a16:	f7ff fa2b 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<height-2; j++)
  205a1a:	697b      	ldr	r3, [r7, #20]
  205a1c:	3301      	adds	r3, #1
  205a1e:	617b      	str	r3, [r7, #20]
  205a20:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205a22:	1e9a      	subs	r2, r3, #2
  205a24:	697b      	ldr	r3, [r7, #20]
  205a26:	429a      	cmp	r2, r3
  205a28:	d8e4      	bhi.n	2059f4 <LCD_Frame+0x38>
		}
		_FillBuff(width, FrameColor);
  205a2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205a2c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  205a2e:	4618      	mov	r0, r3
  205a30:	f7ff f90a 	bl	204c48 <_FillBuff>
	}
}
  205a34:	bf00      	nop
  205a36:	3718      	adds	r7, #24
  205a38:	46bd      	mov	sp, r7
  205a3a:	bd80      	pop	{r7, pc}
  205a3c:	20001870 	.word	0x20001870

00205a40 <LCD_BoldRectangle>:

void LCD_BoldRectangle(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205a40:	b580      	push	{r7, lr}
  205a42:	b08c      	sub	sp, #48	; 0x30
  205a44:	af00      	add	r7, sp, #0
  205a46:	60f8      	str	r0, [r7, #12]
  205a48:	60b9      	str	r1, [r7, #8]
  205a4a:	607a      	str	r2, [r7, #4]
  205a4c:	603b      	str	r3, [r7, #0]
	uint8_t thickness = FrameColor>>24;
  205a4e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  205a50:	0e1b      	lsrs	r3, r3, #24
  205a52:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if((thickness==0)||(thickness==1)||(thickness==2)||(thickness==255))
  205a56:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205a5a:	2b00      	cmp	r3, #0
  205a5c:	d00b      	beq.n	205a76 <LCD_BoldRectangle+0x36>
  205a5e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205a62:	2b01      	cmp	r3, #1
  205a64:	d007      	beq.n	205a76 <LCD_BoldRectangle+0x36>
  205a66:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205a6a:	2b02      	cmp	r3, #2
  205a6c:	d003      	beq.n	205a76 <LCD_BoldRectangle+0x36>
  205a6e:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205a72:	2bff      	cmp	r3, #255	; 0xff
  205a74:	d102      	bne.n	205a7c <LCD_BoldRectangle+0x3c>
		thickness=2;
  205a76:	2302      	movs	r3, #2
  205a78:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	int thickness2 = 2*thickness;
  205a7c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205a80:	005b      	lsls	r3, r3, #1
  205a82:	61fb      	str	r3, [r7, #28]
	int fillHeight = height-thickness2;
  205a84:	69fb      	ldr	r3, [r7, #28]
  205a86:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  205a88:	1ad3      	subs	r3, r2, r3
  205a8a:	61bb      	str	r3, [r7, #24]
	int fillWidth = width-thickness2;
  205a8c:	69fb      	ldr	r3, [r7, #28]
  205a8e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  205a90:	1ad3      	subs	r3, r2, r3
  205a92:	617b      	str	r3, [r7, #20]

	_StartDrawLine(posBuff,BkpSizeX,x,y);
  205a94:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  205a96:	683a      	ldr	r2, [r7, #0]
  205a98:	68b9      	ldr	r1, [r7, #8]
  205a9a:	68f8      	ldr	r0, [r7, #12]
  205a9c:	f7ff f980 	bl	204da0 <_StartDrawLine>
	_FillBuff(width, FrameColor);
  205aa0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205aa2:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205aa4:	4618      	mov	r0, r3
  205aa6:	f7ff f8cf 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205aaa:	2300      	movs	r3, #0
  205aac:	62bb      	str	r3, [r7, #40]	; 0x28
  205aae:	e00b      	b.n	205ac8 <LCD_BoldRectangle+0x88>
		_NextDrawLine(BkpSizeX,width);
  205ab0:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205ab2:	68b8      	ldr	r0, [r7, #8]
  205ab4:	f7ff f9dc 	bl	204e70 <_NextDrawLine>
		_FillBuff(width, FrameColor);
  205ab8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205aba:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205abc:	4618      	mov	r0, r3
  205abe:	f7ff f8c3 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205ac2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205ac4:	3301      	adds	r3, #1
  205ac6:	62bb      	str	r3, [r7, #40]	; 0x28
  205ac8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205acc:	1e5a      	subs	r2, r3, #1
  205ace:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205ad0:	429a      	cmp	r2, r3
  205ad2:	dced      	bgt.n	205ab0 <LCD_BoldRectangle+0x70>
	}
	_NextDrawLine(BkpSizeX,width);
  205ad4:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205ad6:	68b8      	ldr	r0, [r7, #8]
  205ad8:	f7ff f9ca 	bl	204e70 <_NextDrawLine>
	if(fillHeight>0)
  205adc:	69bb      	ldr	r3, [r7, #24]
  205ade:	2b00      	cmp	r3, #0
  205ae0:	dd1d      	ble.n	205b1e <LCD_BoldRectangle+0xde>
	{
		for (int j=0; j<fillHeight; j++)
  205ae2:	2300      	movs	r3, #0
  205ae4:	627b      	str	r3, [r7, #36]	; 0x24
  205ae6:	e016      	b.n	205b16 <LCD_BoldRectangle+0xd6>
		{	_FillBuff(thickness, FrameColor);
  205ae8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205aec:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205aee:	4618      	mov	r0, r3
  205af0:	f7ff f8aa 	bl	204c48 <_FillBuff>
			_FillBuff(fillWidth, FillColor);
  205af4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  205af6:	6978      	ldr	r0, [r7, #20]
  205af8:	f7ff f8a6 	bl	204c48 <_FillBuff>
			_FillBuff(thickness, FrameColor);
  205afc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b00:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205b02:	4618      	mov	r0, r3
  205b04:	f7ff f8a0 	bl	204c48 <_FillBuff>
			_NextDrawLine(BkpSizeX,width);
  205b08:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205b0a:	68b8      	ldr	r0, [r7, #8]
  205b0c:	f7ff f9b0 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<fillHeight; j++)
  205b10:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205b12:	3301      	adds	r3, #1
  205b14:	627b      	str	r3, [r7, #36]	; 0x24
  205b16:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  205b18:	69bb      	ldr	r3, [r7, #24]
  205b1a:	429a      	cmp	r2, r3
  205b1c:	dbe4      	blt.n	205ae8 <LCD_BoldRectangle+0xa8>
		}
	}
	_FillBuff(width, FrameColor);
  205b1e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205b20:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205b22:	4618      	mov	r0, r3
  205b24:	f7ff f890 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205b28:	2300      	movs	r3, #0
  205b2a:	623b      	str	r3, [r7, #32]
  205b2c:	e00b      	b.n	205b46 <LCD_BoldRectangle+0x106>
		_NextDrawLine(BkpSizeX,width);
  205b2e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205b30:	68b8      	ldr	r0, [r7, #8]
  205b32:	f7ff f99d 	bl	204e70 <_NextDrawLine>
		_FillBuff(width, FrameColor);
  205b36:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205b38:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205b3a:	4618      	mov	r0, r3
  205b3c:	f7ff f884 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205b40:	6a3b      	ldr	r3, [r7, #32]
  205b42:	3301      	adds	r3, #1
  205b44:	623b      	str	r3, [r7, #32]
  205b46:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b4a:	1e5a      	subs	r2, r3, #1
  205b4c:	6a3b      	ldr	r3, [r7, #32]
  205b4e:	429a      	cmp	r2, r3
  205b50:	dced      	bgt.n	205b2e <LCD_BoldRectangle+0xee>
	}
}
  205b52:	bf00      	nop
  205b54:	3730      	adds	r7, #48	; 0x30
  205b56:	46bd      	mov	sp, r7
  205b58:	bd80      	pop	{r7, pc}
	...

00205b5c <LCD_BoldFrame>:
void LCD_BoldFrame(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205b5c:	b580      	push	{r7, lr}
  205b5e:	b08c      	sub	sp, #48	; 0x30
  205b60:	af00      	add	r7, sp, #0
  205b62:	60f8      	str	r0, [r7, #12]
  205b64:	60b9      	str	r1, [r7, #8]
  205b66:	607a      	str	r2, [r7, #4]
  205b68:	603b      	str	r3, [r7, #0]
	uint8_t thickness = FrameColor>>24;
  205b6a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  205b6c:	0e1b      	lsrs	r3, r3, #24
  205b6e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if((thickness==0)||(thickness==1)||(thickness==2)||(thickness==255))
  205b72:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b76:	2b00      	cmp	r3, #0
  205b78:	d00b      	beq.n	205b92 <LCD_BoldFrame+0x36>
  205b7a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b7e:	2b01      	cmp	r3, #1
  205b80:	d007      	beq.n	205b92 <LCD_BoldFrame+0x36>
  205b82:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b86:	2b02      	cmp	r3, #2
  205b88:	d003      	beq.n	205b92 <LCD_BoldFrame+0x36>
  205b8a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b8e:	2bff      	cmp	r3, #255	; 0xff
  205b90:	d102      	bne.n	205b98 <LCD_BoldFrame+0x3c>
		thickness=2;
  205b92:	2302      	movs	r3, #2
  205b94:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	int thickness2 = 2*thickness;
  205b98:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205b9c:	005b      	lsls	r3, r3, #1
  205b9e:	61fb      	str	r3, [r7, #28]
	int fillHeight = height-thickness2;
  205ba0:	69fb      	ldr	r3, [r7, #28]
  205ba2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  205ba4:	1ad3      	subs	r3, r2, r3
  205ba6:	61bb      	str	r3, [r7, #24]
	int fillWidth = width-thickness2;
  205ba8:	69fb      	ldr	r3, [r7, #28]
  205baa:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  205bac:	1ad3      	subs	r3, r2, r3
  205bae:	617b      	str	r3, [r7, #20]

	_StartDrawLine(posBuff,BkpSizeX,x,y);
  205bb0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  205bb2:	683a      	ldr	r2, [r7, #0]
  205bb4:	68b9      	ldr	r1, [r7, #8]
  205bb6:	68f8      	ldr	r0, [r7, #12]
  205bb8:	f7ff f8f2 	bl	204da0 <_StartDrawLine>
	_FillBuff(width, FrameColor);
  205bbc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205bbe:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205bc0:	4618      	mov	r0, r3
  205bc2:	f7ff f841 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205bc6:	2300      	movs	r3, #0
  205bc8:	62bb      	str	r3, [r7, #40]	; 0x28
  205bca:	e00b      	b.n	205be4 <LCD_BoldFrame+0x88>
		_NextDrawLine(BkpSizeX,width);
  205bcc:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205bce:	68b8      	ldr	r0, [r7, #8]
  205bd0:	f7ff f94e 	bl	204e70 <_NextDrawLine>
		_FillBuff(width, FrameColor);
  205bd4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205bd6:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205bd8:	4618      	mov	r0, r3
  205bda:	f7ff f835 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205bde:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205be0:	3301      	adds	r3, #1
  205be2:	62bb      	str	r3, [r7, #40]	; 0x28
  205be4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205be8:	1e5a      	subs	r2, r3, #1
  205bea:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205bec:	429a      	cmp	r2, r3
  205bee:	dced      	bgt.n	205bcc <LCD_BoldFrame+0x70>
	}
	_NextDrawLine(BkpSizeX,width);
  205bf0:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205bf2:	68b8      	ldr	r0, [r7, #8]
  205bf4:	f7ff f93c 	bl	204e70 <_NextDrawLine>
	if(fillHeight>0)
  205bf8:	69bb      	ldr	r3, [r7, #24]
  205bfa:	2b00      	cmp	r3, #0
  205bfc:	dd1f      	ble.n	205c3e <LCD_BoldFrame+0xe2>
	{
		for (int j=0; j<fillHeight; j++)
  205bfe:	2300      	movs	r3, #0
  205c00:	627b      	str	r3, [r7, #36]	; 0x24
  205c02:	e018      	b.n	205c36 <LCD_BoldFrame+0xda>
		{	_FillBuff(thickness, FrameColor);
  205c04:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205c08:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205c0a:	4618      	mov	r0, r3
  205c0c:	f7ff f81c 	bl	204c48 <_FillBuff>
			k+=fillWidth;
  205c10:	4b1a      	ldr	r3, [pc, #104]	; (205c7c <LCD_BoldFrame+0x120>)
  205c12:	681a      	ldr	r2, [r3, #0]
  205c14:	697b      	ldr	r3, [r7, #20]
  205c16:	4413      	add	r3, r2
  205c18:	4a18      	ldr	r2, [pc, #96]	; (205c7c <LCD_BoldFrame+0x120>)
  205c1a:	6013      	str	r3, [r2, #0]
			_FillBuff(thickness, FrameColor);
  205c1c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205c20:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205c22:	4618      	mov	r0, r3
  205c24:	f7ff f810 	bl	204c48 <_FillBuff>
			_NextDrawLine(BkpSizeX,width);
  205c28:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205c2a:	68b8      	ldr	r0, [r7, #8]
  205c2c:	f7ff f920 	bl	204e70 <_NextDrawLine>
		for (int j=0; j<fillHeight; j++)
  205c30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205c32:	3301      	adds	r3, #1
  205c34:	627b      	str	r3, [r7, #36]	; 0x24
  205c36:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  205c38:	69bb      	ldr	r3, [r7, #24]
  205c3a:	429a      	cmp	r2, r3
  205c3c:	dbe2      	blt.n	205c04 <LCD_BoldFrame+0xa8>
		}
	}
	_FillBuff(width, FrameColor);
  205c3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205c40:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205c42:	4618      	mov	r0, r3
  205c44:	f7ff f800 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205c48:	2300      	movs	r3, #0
  205c4a:	623b      	str	r3, [r7, #32]
  205c4c:	e00b      	b.n	205c66 <LCD_BoldFrame+0x10a>
		_NextDrawLine(BkpSizeX,width);
  205c4e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  205c50:	68b8      	ldr	r0, [r7, #8]
  205c52:	f7ff f90d 	bl	204e70 <_NextDrawLine>
		_FillBuff(width, FrameColor);
  205c56:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205c58:	6c79      	ldr	r1, [r7, #68]	; 0x44
  205c5a:	4618      	mov	r0, r3
  205c5c:	f7fe fff4 	bl	204c48 <_FillBuff>
	for(int i=0;i<thickness-1;++i){
  205c60:	6a3b      	ldr	r3, [r7, #32]
  205c62:	3301      	adds	r3, #1
  205c64:	623b      	str	r3, [r7, #32]
  205c66:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  205c6a:	1e5a      	subs	r2, r3, #1
  205c6c:	6a3b      	ldr	r3, [r7, #32]
  205c6e:	429a      	cmp	r2, r3
  205c70:	dced      	bgt.n	205c4e <LCD_BoldFrame+0xf2>
	}
}
  205c72:	bf00      	nop
  205c74:	3730      	adds	r7, #48	; 0x30
  205c76:	46bd      	mov	sp, r7
  205c78:	bd80      	pop	{r7, pc}
  205c7a:	bf00      	nop
  205c7c:	20001870 	.word	0x20001870

00205c80 <LCD_RoundFrame>:


void LCD_RoundFrame(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205c80:	b580      	push	{r7, lr}
  205c82:	b08c      	sub	sp, #48	; 0x30
  205c84:	af08      	add	r7, sp, #32
  205c86:	60f8      	str	r0, [r7, #12]
  205c88:	60b9      	str	r1, [r7, #8]
  205c8a:	607a      	str	r2, [r7, #4]
  205c8c:	603b      	str	r3, [r7, #0]
	LCD_DrawRoundRectangleFrame(0,posBuff,BkpSizeX,BkpSizeY,x,y,width,height,FrameColor,FillColor,BkpColor);
  205c8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205c90:	9306      	str	r3, [sp, #24]
  205c92:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205c94:	9305      	str	r3, [sp, #20]
  205c96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205c98:	9304      	str	r3, [sp, #16]
  205c9a:	6a3b      	ldr	r3, [r7, #32]
  205c9c:	9303      	str	r3, [sp, #12]
  205c9e:	69fb      	ldr	r3, [r7, #28]
  205ca0:	9302      	str	r3, [sp, #8]
  205ca2:	69bb      	ldr	r3, [r7, #24]
  205ca4:	9301      	str	r3, [sp, #4]
  205ca6:	683b      	ldr	r3, [r7, #0]
  205ca8:	9300      	str	r3, [sp, #0]
  205caa:	687b      	ldr	r3, [r7, #4]
  205cac:	68ba      	ldr	r2, [r7, #8]
  205cae:	68f9      	ldr	r1, [r7, #12]
  205cb0:	2000      	movs	r0, #0
  205cb2:	f7fc f801 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
}
  205cb6:	bf00      	nop
  205cb8:	3710      	adds	r7, #16
  205cba:	46bd      	mov	sp, r7
  205cbc:	bd80      	pop	{r7, pc}

00205cbe <LCD_RoundRectangle>:
void LCD_RoundRectangle(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205cbe:	b580      	push	{r7, lr}
  205cc0:	b08c      	sub	sp, #48	; 0x30
  205cc2:	af08      	add	r7, sp, #32
  205cc4:	60f8      	str	r0, [r7, #12]
  205cc6:	60b9      	str	r1, [r7, #8]
  205cc8:	607a      	str	r2, [r7, #4]
  205cca:	603b      	str	r3, [r7, #0]
	LCD_DrawRoundRectangleFrame(1,posBuff,BkpSizeX,BkpSizeY,x,y,width,height,FrameColor,FillColor,BkpColor);
  205ccc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205cce:	9306      	str	r3, [sp, #24]
  205cd0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205cd2:	9305      	str	r3, [sp, #20]
  205cd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  205cd6:	9304      	str	r3, [sp, #16]
  205cd8:	6a3b      	ldr	r3, [r7, #32]
  205cda:	9303      	str	r3, [sp, #12]
  205cdc:	69fb      	ldr	r3, [r7, #28]
  205cde:	9302      	str	r3, [sp, #8]
  205ce0:	69bb      	ldr	r3, [r7, #24]
  205ce2:	9301      	str	r3, [sp, #4]
  205ce4:	683b      	ldr	r3, [r7, #0]
  205ce6:	9300      	str	r3, [sp, #0]
  205ce8:	687b      	ldr	r3, [r7, #4]
  205cea:	68ba      	ldr	r2, [r7, #8]
  205cec:	68f9      	ldr	r1, [r7, #12]
  205cee:	2001      	movs	r0, #1
  205cf0:	f7fb ffe2 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
}
  205cf4:	bf00      	nop
  205cf6:	3710      	adds	r7, #16
  205cf8:	46bd      	mov	sp, r7
  205cfa:	bd80      	pop	{r7, pc}

00205cfc <LCD_BoldRoundRectangle>:

void LCD_BoldRoundRectangle(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205cfc:	b590      	push	{r4, r7, lr}
  205cfe:	b08f      	sub	sp, #60	; 0x3c
  205d00:	af08      	add	r7, sp, #32
  205d02:	60f8      	str	r0, [r7, #12]
  205d04:	60b9      	str	r1, [r7, #8]
  205d06:	607a      	str	r2, [r7, #4]
  205d08:	603b      	str	r3, [r7, #0]
	uint8_t thickness = FrameColor>>24;
  205d0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205d0c:	0e1b      	lsrs	r3, r3, #24
  205d0e:	75fb      	strb	r3, [r7, #23]
	if((thickness==0)||(thickness==1)||(thickness==2)||(thickness==255))
  205d10:	7dfb      	ldrb	r3, [r7, #23]
  205d12:	2b00      	cmp	r3, #0
  205d14:	d008      	beq.n	205d28 <LCD_BoldRoundRectangle+0x2c>
  205d16:	7dfb      	ldrb	r3, [r7, #23]
  205d18:	2b01      	cmp	r3, #1
  205d1a:	d005      	beq.n	205d28 <LCD_BoldRoundRectangle+0x2c>
  205d1c:	7dfb      	ldrb	r3, [r7, #23]
  205d1e:	2b02      	cmp	r3, #2
  205d20:	d002      	beq.n	205d28 <LCD_BoldRoundRectangle+0x2c>
  205d22:	7dfb      	ldrb	r3, [r7, #23]
  205d24:	2bff      	cmp	r3, #255	; 0xff
  205d26:	d102      	bne.n	205d2e <LCD_BoldRoundRectangle+0x32>
		thickness=1;
  205d28:	2301      	movs	r3, #1
  205d2a:	75fb      	strb	r3, [r7, #23]
  205d2c:	e002      	b.n	205d34 <LCD_BoldRoundRectangle+0x38>
	else
		thickness--;
  205d2e:	7dfb      	ldrb	r3, [r7, #23]
  205d30:	3b01      	subs	r3, #1
  205d32:	75fb      	strb	r3, [r7, #23]
	LCD_DrawRoundRectangleFrame(1,posBuff,BkpSizeX,BkpSizeY,x,y,width,height,FrameColor,FrameColor,BkpColor);
  205d34:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205d36:	9306      	str	r3, [sp, #24]
  205d38:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205d3a:	9305      	str	r3, [sp, #20]
  205d3c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205d3e:	9304      	str	r3, [sp, #16]
  205d40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205d42:	9303      	str	r3, [sp, #12]
  205d44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  205d46:	9302      	str	r3, [sp, #8]
  205d48:	6abb      	ldr	r3, [r7, #40]	; 0x28
  205d4a:	9301      	str	r3, [sp, #4]
  205d4c:	683b      	ldr	r3, [r7, #0]
  205d4e:	9300      	str	r3, [sp, #0]
  205d50:	687b      	ldr	r3, [r7, #4]
  205d52:	68ba      	ldr	r2, [r7, #8]
  205d54:	68f9      	ldr	r1, [r7, #12]
  205d56:	2001      	movs	r0, #1
  205d58:	f7fb ffae 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
	LCD_DrawRoundRectangleFrame(1,posBuff,BkpSizeX,BkpSizeY,x+thickness,y+thickness,width-2*thickness,height-2*thickness,FrameColor,FillColor,1<<24);
  205d5c:	7dfa      	ldrb	r2, [r7, #23]
  205d5e:	683b      	ldr	r3, [r7, #0]
  205d60:	4413      	add	r3, r2
  205d62:	7df9      	ldrb	r1, [r7, #23]
  205d64:	6aba      	ldr	r2, [r7, #40]	; 0x28
  205d66:	440a      	add	r2, r1
  205d68:	7df9      	ldrb	r1, [r7, #23]
  205d6a:	0049      	lsls	r1, r1, #1
  205d6c:	4608      	mov	r0, r1
  205d6e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  205d70:	1a09      	subs	r1, r1, r0
  205d72:	7df8      	ldrb	r0, [r7, #23]
  205d74:	0040      	lsls	r0, r0, #1
  205d76:	4604      	mov	r4, r0
  205d78:	6b38      	ldr	r0, [r7, #48]	; 0x30
  205d7a:	1b00      	subs	r0, r0, r4
  205d7c:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  205d80:	9406      	str	r4, [sp, #24]
  205d82:	6bbc      	ldr	r4, [r7, #56]	; 0x38
  205d84:	9405      	str	r4, [sp, #20]
  205d86:	6b7c      	ldr	r4, [r7, #52]	; 0x34
  205d88:	9404      	str	r4, [sp, #16]
  205d8a:	9003      	str	r0, [sp, #12]
  205d8c:	9102      	str	r1, [sp, #8]
  205d8e:	9201      	str	r2, [sp, #4]
  205d90:	9300      	str	r3, [sp, #0]
  205d92:	687b      	ldr	r3, [r7, #4]
  205d94:	68ba      	ldr	r2, [r7, #8]
  205d96:	68f9      	ldr	r1, [r7, #12]
  205d98:	2001      	movs	r0, #1
  205d9a:	f7fb ff8d 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
}
  205d9e:	bf00      	nop
  205da0:	371c      	adds	r7, #28
  205da2:	46bd      	mov	sp, r7
  205da4:	bd90      	pop	{r4, r7, pc}

00205da6 <LCD_BoldRoundFrame>:

void LCD_BoldRoundFrame(uint32_t posBuff, uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  205da6:	b590      	push	{r4, r7, lr}
  205da8:	b091      	sub	sp, #68	; 0x44
  205daa:	af08      	add	r7, sp, #32
  205dac:	60f8      	str	r0, [r7, #12]
  205dae:	60b9      	str	r1, [r7, #8]
  205db0:	607a      	str	r2, [r7, #4]
  205db2:	603b      	str	r3, [r7, #0]
	int i,k1,k2;
	uint8_t thickness = FrameColor>>24;
  205db4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205db6:	0e1b      	lsrs	r3, r3, #24
  205db8:	76fb      	strb	r3, [r7, #27]
	if((thickness==0)||(thickness==1)||(thickness==2)||(thickness==255))
  205dba:	7efb      	ldrb	r3, [r7, #27]
  205dbc:	2b00      	cmp	r3, #0
  205dbe:	d008      	beq.n	205dd2 <LCD_BoldRoundFrame+0x2c>
  205dc0:	7efb      	ldrb	r3, [r7, #27]
  205dc2:	2b01      	cmp	r3, #1
  205dc4:	d005      	beq.n	205dd2 <LCD_BoldRoundFrame+0x2c>
  205dc6:	7efb      	ldrb	r3, [r7, #27]
  205dc8:	2b02      	cmp	r3, #2
  205dca:	d002      	beq.n	205dd2 <LCD_BoldRoundFrame+0x2c>
  205dcc:	7efb      	ldrb	r3, [r7, #27]
  205dce:	2bff      	cmp	r3, #255	; 0xff
  205dd0:	d101      	bne.n	205dd6 <LCD_BoldRoundFrame+0x30>
		thickness=2;
  205dd2:	2302      	movs	r3, #2
  205dd4:	76fb      	strb	r3, [r7, #27]
	LCD_DrawRoundRectangleFrame(0,posBuff,BkpSizeX,BkpSizeY,x,y,width,height,FrameColor,FrameColor,BkpColor);
  205dd6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  205dd8:	9306      	str	r3, [sp, #24]
  205dda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205ddc:	9305      	str	r3, [sp, #20]
  205dde:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  205de0:	9304      	str	r3, [sp, #16]
  205de2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  205de4:	9303      	str	r3, [sp, #12]
  205de6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  205de8:	9302      	str	r3, [sp, #8]
  205dea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  205dec:	9301      	str	r3, [sp, #4]
  205dee:	683b      	ldr	r3, [r7, #0]
  205df0:	9300      	str	r3, [sp, #0]
  205df2:	687b      	ldr	r3, [r7, #4]
  205df4:	68ba      	ldr	r2, [r7, #8]
  205df6:	68f9      	ldr	r1, [r7, #12]
  205df8:	2000      	movs	r0, #0
  205dfa:	f7fb ff5d 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
	thickness-=2;
  205dfe:	7efb      	ldrb	r3, [r7, #27]
  205e00:	3b02      	subs	r3, #2
  205e02:	76fb      	strb	r3, [r7, #27]
	for(i=0;i<thickness;++i){
  205e04:	2300      	movs	r3, #0
  205e06:	61fb      	str	r3, [r7, #28]
  205e08:	e025      	b.n	205e56 <LCD_BoldRoundFrame+0xb0>
		k1=1+i;
  205e0a:	69fb      	ldr	r3, [r7, #28]
  205e0c:	3301      	adds	r3, #1
  205e0e:	617b      	str	r3, [r7, #20]
		k2=2*k1;
  205e10:	697b      	ldr	r3, [r7, #20]
  205e12:	005b      	lsls	r3, r3, #1
  205e14:	613b      	str	r3, [r7, #16]
		LCD_DrawRoundRectangleFrame(0,posBuff,BkpSizeX,BkpSizeY,x+k1,y+k1,width-k2,height-k2,FrameColor,FrameColor,1<<24);
  205e16:	697a      	ldr	r2, [r7, #20]
  205e18:	683b      	ldr	r3, [r7, #0]
  205e1a:	4413      	add	r3, r2
  205e1c:	6979      	ldr	r1, [r7, #20]
  205e1e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  205e20:	440a      	add	r2, r1
  205e22:	6939      	ldr	r1, [r7, #16]
  205e24:	6b78      	ldr	r0, [r7, #52]	; 0x34
  205e26:	1a41      	subs	r1, r0, r1
  205e28:	6938      	ldr	r0, [r7, #16]
  205e2a:	6bbc      	ldr	r4, [r7, #56]	; 0x38
  205e2c:	1a20      	subs	r0, r4, r0
  205e2e:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  205e32:	9406      	str	r4, [sp, #24]
  205e34:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
  205e36:	9405      	str	r4, [sp, #20]
  205e38:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
  205e3a:	9404      	str	r4, [sp, #16]
  205e3c:	9003      	str	r0, [sp, #12]
  205e3e:	9102      	str	r1, [sp, #8]
  205e40:	9201      	str	r2, [sp, #4]
  205e42:	9300      	str	r3, [sp, #0]
  205e44:	687b      	ldr	r3, [r7, #4]
  205e46:	68ba      	ldr	r2, [r7, #8]
  205e48:	68f9      	ldr	r1, [r7, #12]
  205e4a:	2000      	movs	r0, #0
  205e4c:	f7fb ff34 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
	for(i=0;i<thickness;++i){
  205e50:	69fb      	ldr	r3, [r7, #28]
  205e52:	3301      	adds	r3, #1
  205e54:	61fb      	str	r3, [r7, #28]
  205e56:	7efa      	ldrb	r2, [r7, #27]
  205e58:	69fb      	ldr	r3, [r7, #28]
  205e5a:	429a      	cmp	r2, r3
  205e5c:	dcd5      	bgt.n	205e0a <LCD_BoldRoundFrame+0x64>
	}
	k1=1+i;
  205e5e:	69fb      	ldr	r3, [r7, #28]
  205e60:	3301      	adds	r3, #1
  205e62:	617b      	str	r3, [r7, #20]
	k2=2*k1;
  205e64:	697b      	ldr	r3, [r7, #20]
  205e66:	005b      	lsls	r3, r3, #1
  205e68:	613b      	str	r3, [r7, #16]
	LCD_DrawRoundRectangleFrame(0,posBuff,BkpSizeX,BkpSizeY,x+k1,y+k1,width-k2,height-k2,FrameColor,FillColor,1<<24);
  205e6a:	697a      	ldr	r2, [r7, #20]
  205e6c:	683b      	ldr	r3, [r7, #0]
  205e6e:	4413      	add	r3, r2
  205e70:	6979      	ldr	r1, [r7, #20]
  205e72:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  205e74:	440a      	add	r2, r1
  205e76:	6939      	ldr	r1, [r7, #16]
  205e78:	6b78      	ldr	r0, [r7, #52]	; 0x34
  205e7a:	1a41      	subs	r1, r0, r1
  205e7c:	6938      	ldr	r0, [r7, #16]
  205e7e:	6bbc      	ldr	r4, [r7, #56]	; 0x38
  205e80:	1a20      	subs	r0, r4, r0
  205e82:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  205e86:	9406      	str	r4, [sp, #24]
  205e88:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  205e8a:	9405      	str	r4, [sp, #20]
  205e8c:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
  205e8e:	9404      	str	r4, [sp, #16]
  205e90:	9003      	str	r0, [sp, #12]
  205e92:	9102      	str	r1, [sp, #8]
  205e94:	9201      	str	r2, [sp, #4]
  205e96:	9300      	str	r3, [sp, #0]
  205e98:	687b      	ldr	r3, [r7, #4]
  205e9a:	68ba      	ldr	r2, [r7, #8]
  205e9c:	68f9      	ldr	r1, [r7, #12]
  205e9e:	2000      	movs	r0, #0
  205ea0:	f7fb ff0a 	bl	201cb8 <LCD_DrawRoundRectangleFrame>
}
  205ea4:	bf00      	nop
  205ea6:	3724      	adds	r7, #36	; 0x24
  205ea8:	46bd      	mov	sp, r7
  205eaa:	bd90      	pop	{r4, r7, pc}

00205eac <_FFFFFFFFFF.12856>:
	float param_y;
	float param_x;
	float decision;

	void _FFFFFFFFFF(void)
	{
  205eac:	b480      	push	{r7}
  205eae:	b083      	sub	sp, #12
  205eb0:	af00      	add	r7, sp, #0
  205eb2:	4663      	mov	r3, ip
  205eb4:	f8c7 c004 	str.w	ip, [r7, #4]
		switch(rot)
  205eb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  205eba:	3a01      	subs	r2, #1
  205ebc:	2a07      	cmp	r2, #7
  205ebe:	f200 8081 	bhi.w	205fc4 <_FFFFFFFFFF.12856+0x118>
  205ec2:	a101      	add	r1, pc, #4	; (adr r1, 205ec8 <_FFFFFFFFFF.12856+0x1c>)
  205ec4:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
  205ec8:	00205ee9 	.word	0x00205ee9
  205ecc:	00205f05 	.word	0x00205f05
  205ed0:	00205f21 	.word	0x00205f21
  205ed4:	00205f3f 	.word	0x00205f3f
  205ed8:	00205f5b 	.word	0x00205f5b
  205edc:	00205f75 	.word	0x00205f75
  205ee0:	00205f8f 	.word	0x00205f8f
  205ee4:	00205fa9 	.word	0x00205fa9
		{  case 1: switch(searchDirection){ case 0: k_iteration=-1;	 		 break; case 1: k_iteration=-BkpSizeX-1; break; } break;
  205ee8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205eea:	2a00      	cmp	r2, #0
  205eec:	d002      	beq.n	205ef4 <_FFFFFFFFFF.12856+0x48>
  205eee:	2a01      	cmp	r2, #1
  205ef0:	d004      	beq.n	205efc <_FFFFFFFFFF.12856+0x50>
  205ef2:	e067      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205ef4:	f04f 32ff 	mov.w	r2, #4294967295
  205ef8:	629a      	str	r2, [r3, #40]	; 0x28
  205efa:	e063      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205efc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205efe:	43d2      	mvns	r2, r2
  205f00:	629a      	str	r2, [r3, #40]	; 0x28
  205f02:	e05f      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 2: switch(searchDirection){ case 0: k_iteration=-BkpSizeX; break; case 1: k_iteration=-BkpSizeX-1; break; } break;
  205f04:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205f06:	2a00      	cmp	r2, #0
  205f08:	d002      	beq.n	205f10 <_FFFFFFFFFF.12856+0x64>
  205f0a:	2a01      	cmp	r2, #1
  205f0c:	d004      	beq.n	205f18 <_FFFFFFFFFF.12856+0x6c>
  205f0e:	e059      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f10:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f12:	4252      	negs	r2, r2
  205f14:	629a      	str	r2, [r3, #40]	; 0x28
  205f16:	e055      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f18:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f1a:	43d2      	mvns	r2, r2
  205f1c:	629a      	str	r2, [r3, #40]	; 0x28
  205f1e:	e051      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 3: switch(searchDirection){ case 0: k_iteration=-BkpSizeX; break; case 1: k_iteration=-BkpSizeX+1; break; } break;
  205f20:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205f22:	2a00      	cmp	r2, #0
  205f24:	d002      	beq.n	205f2c <_FFFFFFFFFF.12856+0x80>
  205f26:	2a01      	cmp	r2, #1
  205f28:	d004      	beq.n	205f34 <_FFFFFFFFFF.12856+0x88>
  205f2a:	e04b      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f2c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f2e:	4252      	negs	r2, r2
  205f30:	629a      	str	r2, [r3, #40]	; 0x28
  205f32:	e047      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f34:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f36:	f1c2 0201 	rsb	r2, r2, #1
  205f3a:	629a      	str	r2, [r3, #40]	; 0x28
  205f3c:	e042      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 4: switch(searchDirection){ case 0: k_iteration=1;     	 break; case 1: k_iteration=-BkpSizeX+1; break; } break;
  205f3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205f40:	2a00      	cmp	r2, #0
  205f42:	d002      	beq.n	205f4a <_FFFFFFFFFF.12856+0x9e>
  205f44:	2a01      	cmp	r2, #1
  205f46:	d003      	beq.n	205f50 <_FFFFFFFFFF.12856+0xa4>
  205f48:	e03c      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f4a:	2201      	movs	r2, #1
  205f4c:	629a      	str	r2, [r3, #40]	; 0x28
  205f4e:	e039      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f50:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f52:	f1c2 0201 	rsb	r2, r2, #1
  205f56:	629a      	str	r2, [r3, #40]	; 0x28
  205f58:	e034      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 5: switch(searchDirection){ case 0: k_iteration=1;     	 break; case 1: k_iteration= BkpSizeX+1; break; } break;
  205f5a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205f5c:	2a00      	cmp	r2, #0
  205f5e:	d002      	beq.n	205f66 <_FFFFFFFFFF.12856+0xba>
  205f60:	2a01      	cmp	r2, #1
  205f62:	d003      	beq.n	205f6c <_FFFFFFFFFF.12856+0xc0>
  205f64:	e02e      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f66:	2201      	movs	r2, #1
  205f68:	629a      	str	r2, [r3, #40]	; 0x28
  205f6a:	e02b      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f6c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f6e:	3201      	adds	r2, #1
  205f70:	629a      	str	r2, [r3, #40]	; 0x28
  205f72:	e027      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 6: switch(searchDirection){ case 0: k_iteration=BkpSizeX;  break; case 1: k_iteration= BkpSizeX+1; break; } break;
  205f74:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205f76:	2a00      	cmp	r2, #0
  205f78:	d002      	beq.n	205f80 <_FFFFFFFFFF.12856+0xd4>
  205f7a:	2a01      	cmp	r2, #1
  205f7c:	d003      	beq.n	205f86 <_FFFFFFFFFF.12856+0xda>
  205f7e:	e021      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f80:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f82:	629a      	str	r2, [r3, #40]	; 0x28
  205f84:	e01e      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f86:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f88:	3201      	adds	r2, #1
  205f8a:	629a      	str	r2, [r3, #40]	; 0x28
  205f8c:	e01a      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 7: switch(searchDirection){ case 0: k_iteration=BkpSizeX;  break; case 1: k_iteration= BkpSizeX-1; break; } break;
  205f8e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205f90:	2a00      	cmp	r2, #0
  205f92:	d002      	beq.n	205f9a <_FFFFFFFFFF.12856+0xee>
  205f94:	2a01      	cmp	r2, #1
  205f96:	d003      	beq.n	205fa0 <_FFFFFFFFFF.12856+0xf4>
  205f98:	e014      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205f9a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205f9c:	629a      	str	r2, [r3, #40]	; 0x28
  205f9e:	e011      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205fa0:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205fa2:	3a01      	subs	r2, #1
  205fa4:	629a      	str	r2, [r3, #40]	; 0x28
  205fa6:	e00d      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
			case 8: switch(searchDirection){ case 0: k_iteration=-1;   		 break; case 1: k_iteration= BkpSizeX-1; break; } break;
  205fa8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  205faa:	2a00      	cmp	r2, #0
  205fac:	d002      	beq.n	205fb4 <_FFFFFFFFFF.12856+0x108>
  205fae:	2a01      	cmp	r2, #1
  205fb0:	d004      	beq.n	205fbc <_FFFFFFFFFF.12856+0x110>
  205fb2:	e007      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205fb4:	f04f 32ff 	mov.w	r2, #4294967295
  205fb8:	629a      	str	r2, [r3, #40]	; 0x28
  205fba:	e003      	b.n	205fc4 <_FFFFFFFFFF.12856+0x118>
  205fbc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  205fbe:	3a01      	subs	r2, #1
  205fc0:	629a      	str	r2, [r3, #40]	; 0x28
  205fc2:	bf00      	nop
		}
	}
  205fc4:	bf00      	nop
  205fc6:	370c      	adds	r7, #12
  205fc8:	46bd      	mov	sp, r7
  205fca:	f85d 7b04 	ldr.w	r7, [sp], #4
  205fce:	4770      	bx	lr

00205fd0 <DrawLine>:
{
  205fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  205fd4:	b0ad      	sub	sp, #180	; 0xb4
  205fd6:	af02      	add	r7, sp, #8
  205fd8:	62f8      	str	r0, [r7, #44]	; 0x2c
  205fda:	4618      	mov	r0, r3
  205fdc:	ed87 0a08 	vstr	s0, [r7, #32]
  205fe0:	edc7 0a07 	vstr	s1, [r7, #28]
  205fe4:	f8d7 40e0 	ldr.w	r4, [r7, #224]	; 0xe0
  205fe8:	460b      	mov	r3, r1
  205fea:	857b      	strh	r3, [r7, #42]	; 0x2a
  205fec:	4613      	mov	r3, r2
  205fee:	853b      	strh	r3, [r7, #40]	; 0x28
  205ff0:	4603      	mov	r3, r0
  205ff2:	84fb      	strh	r3, [r7, #38]	; 0x26
void DrawLine(uint32_t posBuff,uint16_t x0, uint16_t y0, uint16_t len, uint16_t degree, uint32_t lineColor,uint32_t BkpSizeX, float ratioAA1, float ratioAA2 ,uint32_t bk1Color, uint32_t bk2Color)
  205ff4:	f107 03d0 	add.w	r3, r7, #208	; 0xd0
  205ff8:	66bb      	str	r3, [r7, #104]	; 0x68
  205ffa:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  205ffe:	64fb      	str	r3, [r7, #76]	; 0x4c
  206000:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
  206004:	65bb      	str	r3, [r7, #88]	; 0x58
  206006:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
  20600a:	64bb      	str	r3, [r7, #72]	; 0x48
  20600c:	643c      	str	r4, [r7, #64]	; 0x40
{
  20600e:	466b      	mov	r3, sp
  206010:	607b      	str	r3, [r7, #4]
	uint16_t degree_copy=degree;
  206012:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206016:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
	uint8_t linesBuff[LINES_BUFF_SIZE];
  20601a:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  20601c:	1d9a      	adds	r2, r3, #6
  20601e:	1e53      	subs	r3, r2, #1
  206020:	657b      	str	r3, [r7, #84]	; 0x54
  206022:	4613      	mov	r3, r2
  206024:	f04f 0400 	mov.w	r4, #0
  206028:	00e1      	lsls	r1, r4, #3
  20602a:	60f9      	str	r1, [r7, #12]
  20602c:	68f9      	ldr	r1, [r7, #12]
  20602e:	ea41 7153 	orr.w	r1, r1, r3, lsr #29
  206032:	60f9      	str	r1, [r7, #12]
  206034:	00db      	lsls	r3, r3, #3
  206036:	60bb      	str	r3, [r7, #8]
  206038:	4613      	mov	r3, r2
  20603a:	f04f 0400 	mov.w	r4, #0
  20603e:	ea4f 0bc4 	mov.w	fp, r4, lsl #3
  206042:	ea4b 7b53 	orr.w	fp, fp, r3, lsr #29
  206046:	ea4f 0ac3 	mov.w	sl, r3, lsl #3
  20604a:	4613      	mov	r3, r2
  20604c:	3307      	adds	r3, #7
  20604e:	08db      	lsrs	r3, r3, #3
  206050:	00db      	lsls	r3, r3, #3
  206052:	ebad 0d03 	sub.w	sp, sp, r3
  206056:	ab02      	add	r3, sp, #8
  206058:	3300      	adds	r3, #0
  20605a:	653b      	str	r3, [r7, #80]	; 0x50
	int k_iteration=0, searchDirection=0;
  20605c:	2300      	movs	r3, #0
  20605e:	65fb      	str	r3, [r7, #92]	; 0x5c
  206060:	2300      	movs	r3, #0
  206062:	663b      	str	r3, [r7, #96]	; 0x60
	int nrPointsPerLine=0, iteration=1;
  206064:	2300      	movs	r3, #0
  206066:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  20606a:	2301      	movs	r3, #1
  20606c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
	int findNoPoint=0, rot;
  206070:	2300      	movs	r3, #0
  206072:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

	if(degree_copy==0)
  206076:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
  20607a:	2b00      	cmp	r3, #0
  20607c:	d103      	bne.n	206086 <DrawLine+0xb6>
		degree_copy=360;
  20607e:	f44f 73b4 	mov.w	r3, #360	; 0x168
  206082:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6

	_StartDrawLine(posBuff,BkpSizeX,x0,y0);
  206086:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  206088:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  20608a:	6db9      	ldr	r1, [r7, #88]	; 0x58
  20608c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  20608e:	f7fe fe87 	bl	204da0 <_StartDrawLine>
	rot=LCD_SearchLinePoints(1,posBuff,x0,y0,degree_copy,BkpSizeX);
  206092:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  206094:	8d78      	ldrh	r0, [r7, #42]	; 0x2a
  206096:	8d3c      	ldrh	r4, [r7, #40]	; 0x28
  206098:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
  20609c:	6dba      	ldr	r2, [r7, #88]	; 0x58
  20609e:	9201      	str	r2, [sp, #4]
  2060a0:	9300      	str	r3, [sp, #0]
  2060a2:	4623      	mov	r3, r4
  2060a4:	4602      	mov	r2, r0
  2060a6:	2001      	movs	r0, #1
  2060a8:	f7fc fa26 	bl	2024f8 <LCD_SearchLinePoints>
  2060ac:	4603      	mov	r3, r0
  2060ae:	667b      	str	r3, [r7, #100]	; 0x64
	_FFFFFFFFFF();
  2060b0:	f107 0334 	add.w	r3, r7, #52	; 0x34
  2060b4:	469c      	mov	ip, r3
  2060b6:	f7ff fef9 	bl	205eac <_FFFFFFFFFF.12856>

	do
	{
		if(LCD_SearchLinePoints(0,posBuff,x0,y0,degree_copy,BkpSizeX)==1)
  2060ba:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  2060bc:	8d78      	ldrh	r0, [r7, #42]	; 0x2a
  2060be:	8d3c      	ldrh	r4, [r7, #40]	; 0x28
  2060c0:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
  2060c4:	6dba      	ldr	r2, [r7, #88]	; 0x58
  2060c6:	9201      	str	r2, [sp, #4]
  2060c8:	9300      	str	r3, [sp, #0]
  2060ca:	4623      	mov	r3, r4
  2060cc:	4602      	mov	r2, r0
  2060ce:	2000      	movs	r0, #0
  2060d0:	f7fc fa12 	bl	2024f8 <LCD_SearchLinePoints>
  2060d4:	4603      	mov	r3, r0
  2060d6:	2b01      	cmp	r3, #1
  2060d8:	d115      	bne.n	206106 <DrawLine+0x136>
		{
			nrPointsPerLine++;
  2060da:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  2060de:	3301      	adds	r3, #1
  2060e0:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
		   if(findNoPoint)
  2060e4:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  2060e8:	2b00      	cmp	r3, #0
  2060ea:	d035      	beq.n	206158 <DrawLine+0x188>
		   {
		   	findNoPoint=0;
  2060ec:	2300      	movs	r3, #0
  2060ee:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
		   	searchDirection=1-searchDirection;
  2060f2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  2060f4:	f1c3 0301 	rsb	r3, r3, #1
  2060f8:	663b      	str	r3, [r7, #96]	; 0x60
		   	_FFFFFFFFFF();
  2060fa:	f107 0334 	add.w	r3, r7, #52	; 0x34
  2060fe:	469c      	mov	ip, r3
  206100:	f7ff fed4 	bl	205eac <_FFFFFFFFFF.12856>
  206104:	e028      	b.n	206158 <DrawLine+0x188>
		   }
		}
		else
		{
		   k-=k_iteration;
  206106:	4bc5      	ldr	r3, [pc, #788]	; (20641c <DrawLine+0x44c>)
  206108:	681b      	ldr	r3, [r3, #0]
  20610a:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  20610c:	1a9b      	subs	r3, r3, r2
  20610e:	4ac3      	ldr	r2, [pc, #780]	; (20641c <DrawLine+0x44c>)
  206110:	6013      	str	r3, [r2, #0]
		   searchDirection=1-searchDirection;
  206112:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  206114:	f1c3 0301 	rsb	r3, r3, #1
  206118:	663b      	str	r3, [r7, #96]	; 0x60
		   if(nrPointsPerLine)
  20611a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  20611e:	2b00      	cmp	r3, #0
  206120:	d00f      	beq.n	206142 <DrawLine+0x172>
		   {
		   	if(iteration<LINES_BUFF_SIZE-2)
  206122:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  206124:	1d1a      	adds	r2, r3, #4
  206126:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  20612a:	429a      	cmp	r2, r3
  20612c:	dd74      	ble.n	206218 <DrawLine+0x248>
		   		linesBuff[iteration++]=nrPointsPerLine;
  20612e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  206132:	1c5a      	adds	r2, r3, #1
  206134:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
  206138:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
  20613c:	b2d1      	uxtb	r1, r2
  20613e:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  206140:	54d1      	strb	r1, [r2, r3]
		   	else break;
		   }
		   nrPointsPerLine=0;
  206142:	2300      	movs	r3, #0
  206144:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
			findNoPoint=1;
  206148:	2301      	movs	r3, #1
  20614a:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
			_FFFFFFFFFF();
  20614e:	f107 0334 	add.w	r3, r7, #52	; 0x34
  206152:	469c      	mov	ip, r3
  206154:	f7ff feaa 	bl	205eac <_FFFFFFFFFF.12856>
		}
		k+=k_iteration;
  206158:	4bb0      	ldr	r3, [pc, #704]	; (20641c <DrawLine+0x44c>)
  20615a:	681b      	ldr	r3, [r3, #0]
  20615c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  20615e:	4413      	add	r3, r2
  206160:	4aae      	ldr	r2, [pc, #696]	; (20641c <DrawLine+0x44c>)
  206162:	6013      	str	r3, [r2, #0]
	   pos = _GetPosXY(posBuff,BkpSizeX);
  206164:	6dba      	ldr	r2, [r7, #88]	; 0x58
  206166:	4cae      	ldr	r4, [pc, #696]	; (206420 <DrawLine+0x450>)
  206168:	f107 0310 	add.w	r3, r7, #16
  20616c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  20616e:	4618      	mov	r0, r3
  206170:	f7fe fe30 	bl	204dd4 <_GetPosXY>
  206174:	4622      	mov	r2, r4
  206176:	f107 0310 	add.w	r3, r7, #16
  20617a:	e893 0003 	ldmia.w	r3, {r0, r1}
  20617e:	e882 0003 	stmia.w	r2, {r0, r1}

		param_y = pow(y0-pos.y,2);
  206182:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  206184:	4ba6      	ldr	r3, [pc, #664]	; (206420 <DrawLine+0x450>)
  206186:	685b      	ldr	r3, [r3, #4]
  206188:	1ad3      	subs	r3, r2, r3
  20618a:	ee07 3a90 	vmov	s15, r3
  20618e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  206192:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  206196:	eeb0 0b47 	vmov.f64	d0, d7
  20619a:	f020 fa85 	bl	2266a8 <pow>
  20619e:	eeb0 7b40 	vmov.f64	d7, d0
  2061a2:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2061a6:	edc7 7a1f 	vstr	s15, [r7, #124]	; 0x7c
		param_x = pow(x0-pos.x,2);
  2061aa:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  2061ac:	4b9c      	ldr	r3, [pc, #624]	; (206420 <DrawLine+0x450>)
  2061ae:	681b      	ldr	r3, [r3, #0]
  2061b0:	1ad3      	subs	r3, r2, r3
  2061b2:	ee07 3a90 	vmov	s15, r3
  2061b6:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  2061ba:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  2061be:	eeb0 0b47 	vmov.f64	d0, d7
  2061c2:	f020 fa71 	bl	2266a8 <pow>
  2061c6:	eeb0 7b40 	vmov.f64	d7, d0
  2061ca:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2061ce:	edc7 7a1e 	vstr	s15, [r7, #120]	; 0x78
		decision = pow((float)(len+1),2);
  2061d2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  2061d4:	3301      	adds	r3, #1
  2061d6:	ee07 3a90 	vmov	s15, r3
  2061da:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2061de:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2061e2:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  2061e6:	eeb0 0b47 	vmov.f64	d0, d7
  2061ea:	f020 fa5d 	bl	2266a8 <pow>
  2061ee:	eeb0 7b40 	vmov.f64	d7, d0
  2061f2:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2061f6:	edc7 7a1d 	vstr	s15, [r7, #116]	; 0x74

	}while((param_x+param_y) <= decision);
  2061fa:	ed97 7a1e 	vldr	s14, [r7, #120]	; 0x78
  2061fe:	edd7 7a1f 	vldr	s15, [r7, #124]	; 0x7c
  206202:	ee37 7a27 	vadd.f32	s14, s14, s15
  206206:	edd7 7a1d 	vldr	s15, [r7, #116]	; 0x74
  20620a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20620e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  206212:	f67f af52 	bls.w	2060ba <DrawLine+0xea>
  206216:	e000      	b.n	20621a <DrawLine+0x24a>
		   	else break;
  206218:	bf00      	nop

	if(nrPointsPerLine)
  20621a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  20621e:	2b00      	cmp	r3, #0
  206220:	d009      	beq.n	206236 <DrawLine+0x266>
		linesBuff[iteration++]=nrPointsPerLine;
  206222:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  206226:	1c5a      	adds	r2, r3, #1
  206228:	f8c7 209c 	str.w	r2, [r7, #156]	; 0x9c
  20622c:	f8d7 20a0 	ldr.w	r2, [r7, #160]	; 0xa0
  206230:	b2d1      	uxtb	r1, r2
  206232:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  206234:	54d1      	strb	r1, [r2, r3]
	linesBuff[0]=iteration-1;
  206236:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  20623a:	b2db      	uxtb	r3, r3
  20623c:	3b01      	subs	r3, #1
  20623e:	b2da      	uxtb	r2, r3
  206240:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206242:	701a      	strb	r2, [r3, #0]

	_StartDrawLine(posBuff,BkpSizeX,x0,y0);
  206244:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  206246:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
  206248:	6db9      	ldr	r1, [r7, #88]	; 0x58
  20624a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  20624c:	f7fe fda8 	bl	204da0 <_StartDrawLine>

	if(correctLine_AA==0)
  206250:	4b74      	ldr	r3, [pc, #464]	; (206424 <DrawLine+0x454>)
  206252:	781b      	ldrb	r3, [r3, #0]
  206254:	2b00      	cmp	r3, #0
  206256:	f040 809e 	bne.w	206396 <DrawLine+0x3c6>
	{
		switch(rot)
  20625a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20625c:	3b01      	subs	r3, #1
  20625e:	2b07      	cmp	r3, #7
  206260:	f200 8463 	bhi.w	206b2a <DrawLine+0xb5a>
  206264:	a201      	add	r2, pc, #4	; (adr r2, 20626c <DrawLine+0x29c>)
  206266:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  20626a:	bf00      	nop
  20626c:	0020628d 	.word	0x0020628d
  206270:	002062af 	.word	0x002062af
  206274:	002062d1 	.word	0x002062d1
  206278:	002062f3 	.word	0x002062f3
  20627c:	00206315 	.word	0x00206315
  206280:	00206335 	.word	0x00206335
  206284:	00206355 	.word	0x00206355
  206288:	00206375 	.word	0x00206375
		{
			case 1:  _DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff); break;
  20628c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20628e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206290:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  206292:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206294:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206296:	9301      	str	r3, [sp, #4]
  206298:	2300      	movs	r3, #0
  20629a:	9300      	str	r3, [sp, #0]
  20629c:	4623      	mov	r3, r4
  20629e:	edd7 0a07 	vldr	s1, [r7, #28]
  2062a2:	ed97 0a08 	vldr	s0, [r7, #32]
  2062a6:	f7ff f985 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
  2062aa:	f000 bc3e 	b.w	206b2a <DrawLine+0xb5a>
			case 2:  _DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff); break;
  2062ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2062b0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2062b2:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2062b4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2062b6:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2062b8:	9301      	str	r3, [sp, #4]
  2062ba:	2301      	movs	r3, #1
  2062bc:	9300      	str	r3, [sp, #0]
  2062be:	4623      	mov	r3, r4
  2062c0:	edd7 0a07 	vldr	s1, [r7, #28]
  2062c4:	ed97 0a08 	vldr	s0, [r7, #32]
  2062c8:	f7ff f974 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
  2062cc:	f000 bc2d 	b.w	206b2a <DrawLine+0xb5a>
			case 3:  _DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff); break;
  2062d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2062d2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2062d4:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2062d6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2062d8:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2062da:	9301      	str	r3, [sp, #4]
  2062dc:	2301      	movs	r3, #1
  2062de:	9300      	str	r3, [sp, #0]
  2062e0:	4623      	mov	r3, r4
  2062e2:	edd7 0a07 	vldr	s1, [r7, #28]
  2062e6:	ed97 0a08 	vldr	s0, [r7, #32]
  2062ea:	f7fe ff77 	bl	2051dc <_DrawArrayBuffRightUp_AA>
  2062ee:	f000 bc1c 	b.w	206b2a <DrawLine+0xb5a>
			case 4:  _DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff); break;
  2062f2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2062f4:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2062f6:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2062f8:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2062fa:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2062fc:	9301      	str	r3, [sp, #4]
  2062fe:	2300      	movs	r3, #0
  206300:	9300      	str	r3, [sp, #0]
  206302:	4623      	mov	r3, r4
  206304:	edd7 0a07 	vldr	s1, [r7, #28]
  206308:	ed97 0a08 	vldr	s0, [r7, #32]
  20630c:	f7fe ff66 	bl	2051dc <_DrawArrayBuffRightUp_AA>
  206310:	f000 bc0b 	b.w	206b2a <DrawLine+0xb5a>
			case 5:  _DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff); break;
  206314:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206316:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206318:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20631a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20631c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  20631e:	9301      	str	r3, [sp, #4]
  206320:	2300      	movs	r3, #0
  206322:	9300      	str	r3, [sp, #0]
  206324:	4623      	mov	r3, r4
  206326:	edd7 0a07 	vldr	s1, [r7, #28]
  20632a:	ed97 0a08 	vldr	s0, [r7, #32]
  20632e:	f7fe fe4d 	bl	204fcc <_DrawArrayBuffRightDown_AA>
  206332:	e3fa      	b.n	206b2a <DrawLine+0xb5a>
			case 6:  _DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff); break;
  206334:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206336:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206338:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20633a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20633c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  20633e:	9301      	str	r3, [sp, #4]
  206340:	2301      	movs	r3, #1
  206342:	9300      	str	r3, [sp, #0]
  206344:	4623      	mov	r3, r4
  206346:	edd7 0a07 	vldr	s1, [r7, #28]
  20634a:	ed97 0a08 	vldr	s0, [r7, #32]
  20634e:	f7fe fe3d 	bl	204fcc <_DrawArrayBuffRightDown_AA>
  206352:	e3ea      	b.n	206b2a <DrawLine+0xb5a>
			case 7:  _DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff); break;
  206354:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206356:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206358:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20635a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20635c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  20635e:	9301      	str	r3, [sp, #4]
  206360:	2301      	movs	r3, #1
  206362:	9300      	str	r3, [sp, #0]
  206364:	4623      	mov	r3, r4
  206366:	edd7 0a07 	vldr	s1, [r7, #28]
  20636a:	ed97 0a08 	vldr	s0, [r7, #32]
  20636e:	f7ff f82b 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
  206372:	e3da      	b.n	206b2a <DrawLine+0xb5a>
			case 8:  _DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff); break;
  206374:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206376:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206378:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20637a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20637c:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  20637e:	9301      	str	r3, [sp, #4]
  206380:	2300      	movs	r3, #0
  206382:	9300      	str	r3, [sp, #0]
  206384:	4623      	mov	r3, r4
  206386:	edd7 0a07 	vldr	s1, [r7, #28]
  20638a:	ed97 0a08 	vldr	s0, [r7, #32]
  20638e:	f7ff f81b 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
  206392:	bf00      	nop
  206394:	e3c9      	b.n	206b2a <DrawLine+0xb5a>
		}
	}
	else
	{
		int  k_p=k;
  206396:	4b21      	ldr	r3, [pc, #132]	; (20641c <DrawLine+0x44c>)
  206398:	681b      	ldr	r3, [r3, #0]
  20639a:	647b      	str	r3, [r7, #68]	; 0x44

		typedef struct
		{	uint16_t nmbPxl;
			uint8_t nmbPxlTheSame;
		}Struct_LinePoints;
		Struct_LinePoints linePoints[_GetNmbPxls()];
  20639c:	f107 0334 	add.w	r3, r7, #52	; 0x34
  2063a0:	469c      	mov	ip, r3
  2063a2:	f000 fbc9 	bl	206b38 <_GetNmbPxls.12910>
  2063a6:	4602      	mov	r2, r0
  2063a8:	466b      	mov	r3, sp
  2063aa:	469a      	mov	sl, r3
  2063ac:	1e53      	subs	r3, r2, #1
  2063ae:	63fb      	str	r3, [r7, #60]	; 0x3c
  2063b0:	4613      	mov	r3, r2
  2063b2:	f04f 0400 	mov.w	r4, #0
  2063b6:	ea4f 1944 	mov.w	r9, r4, lsl #5
  2063ba:	ea49 69d3 	orr.w	r9, r9, r3, lsr #27
  2063be:	ea4f 1843 	mov.w	r8, r3, lsl #5
  2063c2:	4613      	mov	r3, r2
  2063c4:	f04f 0400 	mov.w	r4, #0
  2063c8:	0166      	lsls	r6, r4, #5
  2063ca:	ea46 66d3 	orr.w	r6, r6, r3, lsr #27
  2063ce:	015d      	lsls	r5, r3, #5
  2063d0:	4613      	mov	r3, r2
  2063d2:	009b      	lsls	r3, r3, #2
  2063d4:	3301      	adds	r3, #1
  2063d6:	3307      	adds	r3, #7
  2063d8:	08db      	lsrs	r3, r3, #3
  2063da:	00db      	lsls	r3, r3, #3
  2063dc:	ebad 0d03 	sub.w	sp, sp, r3
  2063e0:	ab02      	add	r3, sp, #8
  2063e2:	3301      	adds	r3, #1
  2063e4:	085b      	lsrs	r3, r3, #1
  2063e6:	005b      	lsls	r3, r3, #1
  2063e8:	63bb      	str	r3, [r7, #56]	; 0x38
				linePoints[it++].nmbPxlTheSame=count1;
			}
			linePointsStructSize=it;
		}

		switch(rot)
  2063ea:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  2063ec:	3b01      	subs	r3, #1
  2063ee:	2b07      	cmp	r3, #7
  2063f0:	f200 815e 	bhi.w	2066b0 <DrawLine+0x6e0>
  2063f4:	a201      	add	r2, pc, #4	; (adr r2, 2063fc <DrawLine+0x42c>)
  2063f6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  2063fa:	bf00      	nop
  2063fc:	00206429 	.word	0x00206429
  206400:	00206479 	.word	0x00206479
  206404:	002064c9 	.word	0x002064c9
  206408:	00206519 	.word	0x00206519
  20640c:	00206569 	.word	0x00206569
  206410:	002065b9 	.word	0x002065b9
  206414:	00206609 	.word	0x00206609
  206418:	0020665d 	.word	0x0020665d
  20641c:	20001870 	.word	0x20001870
  206420:	20002048 	.word	0x20002048
  206424:	20002058 	.word	0x20002058
		{
			case 1:
				if(degree>=45-11 && degree<=45)
  206428:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20642c:	2b21      	cmp	r3, #33	; 0x21
  20642e:	d913      	bls.n	206458 <DrawLine+0x488>
  206430:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206434:	2b2d      	cmp	r3, #45	; 0x2d
  206436:	d80f      	bhi.n	206458 <DrawLine+0x488>
					_DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,0,linesBuff);
  206438:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20643a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20643c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20643e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206440:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206442:	9301      	str	r3, [sp, #4]
  206444:	2300      	movs	r3, #0
  206446:	9300      	str	r3, [sp, #0]
  206448:	4623      	mov	r3, r4
  20644a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  20644e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  206452:	f7ff f8af 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
				else
					_DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
				break;
  206456:	e12b      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
  206458:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20645a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20645c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20645e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206460:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206462:	9301      	str	r3, [sp, #4]
  206464:	2300      	movs	r3, #0
  206466:	9300      	str	r3, [sp, #0]
  206468:	4623      	mov	r3, r4
  20646a:	edd7 0a07 	vldr	s1, [r7, #28]
  20646e:	ed97 0a08 	vldr	s0, [r7, #32]
  206472:	f7ff f89f 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
				break;
  206476:	e11b      	b.n	2066b0 <DrawLine+0x6e0>
			case 2:
				if(degree>45 && degree<=45+11)
  206478:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20647c:	2b2d      	cmp	r3, #45	; 0x2d
  20647e:	d913      	bls.n	2064a8 <DrawLine+0x4d8>
  206480:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206484:	2b38      	cmp	r3, #56	; 0x38
  206486:	d80f      	bhi.n	2064a8 <DrawLine+0x4d8>
					_DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,1,linesBuff);
  206488:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20648a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20648c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20648e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206490:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206492:	9301      	str	r3, [sp, #4]
  206494:	2301      	movs	r3, #1
  206496:	9300      	str	r3, [sp, #0]
  206498:	4623      	mov	r3, r4
  20649a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  20649e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  2064a2:	f7ff f887 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
				else
					_DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
			break;
  2064a6:	e103      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffLeftUp_AA   (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
  2064a8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2064aa:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2064ac:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2064ae:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2064b0:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2064b2:	9301      	str	r3, [sp, #4]
  2064b4:	2301      	movs	r3, #1
  2064b6:	9300      	str	r3, [sp, #0]
  2064b8:	4623      	mov	r3, r4
  2064ba:	edd7 0a07 	vldr	s1, [r7, #28]
  2064be:	ed97 0a08 	vldr	s0, [r7, #32]
  2064c2:	f7ff f877 	bl	2055b4 <_DrawArrayBuffLeftUp_AA>
			break;
  2064c6:	e0f3      	b.n	2066b0 <DrawLine+0x6e0>

			case 3:
				if(degree<=135 && degree>=135-11)
  2064c8:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2064cc:	2b87      	cmp	r3, #135	; 0x87
  2064ce:	d813      	bhi.n	2064f8 <DrawLine+0x528>
  2064d0:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2064d4:	2b7b      	cmp	r3, #123	; 0x7b
  2064d6:	d90f      	bls.n	2064f8 <DrawLine+0x528>
					_DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,1,linesBuff);
  2064d8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2064da:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2064dc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2064de:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2064e0:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2064e2:	9301      	str	r3, [sp, #4]
  2064e4:	2301      	movs	r3, #1
  2064e6:	9300      	str	r3, [sp, #0]
  2064e8:	4623      	mov	r3, r4
  2064ea:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  2064ee:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  2064f2:	f7fe fe73 	bl	2051dc <_DrawArrayBuffRightUp_AA>
				else
					_DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
				break;
  2064f6:	e0db      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
  2064f8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2064fa:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2064fc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2064fe:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206500:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206502:	9301      	str	r3, [sp, #4]
  206504:	2301      	movs	r3, #1
  206506:	9300      	str	r3, [sp, #0]
  206508:	4623      	mov	r3, r4
  20650a:	edd7 0a07 	vldr	s1, [r7, #28]
  20650e:	ed97 0a08 	vldr	s0, [r7, #32]
  206512:	f7fe fe63 	bl	2051dc <_DrawArrayBuffRightUp_AA>
				break;
  206516:	e0cb      	b.n	2066b0 <DrawLine+0x6e0>
			case 4:
				if(degree>135 && degree<=135+11)
  206518:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20651c:	2b87      	cmp	r3, #135	; 0x87
  20651e:	d913      	bls.n	206548 <DrawLine+0x578>
  206520:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206524:	2b92      	cmp	r3, #146	; 0x92
  206526:	d80f      	bhi.n	206548 <DrawLine+0x578>
					_DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,0,linesBuff);
  206528:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20652a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20652c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20652e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206530:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206532:	9301      	str	r3, [sp, #4]
  206534:	2300      	movs	r3, #0
  206536:	9300      	str	r3, [sp, #0]
  206538:	4623      	mov	r3, r4
  20653a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  20653e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  206542:	f7fe fe4b 	bl	2051dc <_DrawArrayBuffRightUp_AA>
				else
					_DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
			break;
  206546:	e0b3      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffRightUp_AA  (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
  206548:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20654a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20654c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20654e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206550:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206552:	9301      	str	r3, [sp, #4]
  206554:	2300      	movs	r3, #0
  206556:	9300      	str	r3, [sp, #0]
  206558:	4623      	mov	r3, r4
  20655a:	edd7 0a07 	vldr	s1, [r7, #28]
  20655e:	ed97 0a08 	vldr	s0, [r7, #32]
  206562:	f7fe fe3b 	bl	2051dc <_DrawArrayBuffRightUp_AA>
			break;
  206566:	e0a3      	b.n	2066b0 <DrawLine+0x6e0>

			case 5:
				if(degree>=225-11 && degree<=225)
  206568:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20656c:	2bd5      	cmp	r3, #213	; 0xd5
  20656e:	d913      	bls.n	206598 <DrawLine+0x5c8>
  206570:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206574:	2be1      	cmp	r3, #225	; 0xe1
  206576:	d80f      	bhi.n	206598 <DrawLine+0x5c8>
					_DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,0,linesBuff);
  206578:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20657a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20657c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20657e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206580:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206582:	9301      	str	r3, [sp, #4]
  206584:	2300      	movs	r3, #0
  206586:	9300      	str	r3, [sp, #0]
  206588:	4623      	mov	r3, r4
  20658a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  20658e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  206592:	f7fe fd1b 	bl	204fcc <_DrawArrayBuffRightDown_AA>
				else
					_DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
				break;
  206596:	e08b      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
  206598:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20659a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20659c:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20659e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2065a0:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2065a2:	9301      	str	r3, [sp, #4]
  2065a4:	2300      	movs	r3, #0
  2065a6:	9300      	str	r3, [sp, #0]
  2065a8:	4623      	mov	r3, r4
  2065aa:	edd7 0a07 	vldr	s1, [r7, #28]
  2065ae:	ed97 0a08 	vldr	s0, [r7, #32]
  2065b2:	f7fe fd0b 	bl	204fcc <_DrawArrayBuffRightDown_AA>
				break;
  2065b6:	e07b      	b.n	2066b0 <DrawLine+0x6e0>
			case 6:
				if(degree>225 && degree<=225+11)
  2065b8:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2065bc:	2be1      	cmp	r3, #225	; 0xe1
  2065be:	d913      	bls.n	2065e8 <DrawLine+0x618>
  2065c0:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2065c4:	2bec      	cmp	r3, #236	; 0xec
  2065c6:	d80f      	bhi.n	2065e8 <DrawLine+0x618>
					_DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,1,linesBuff);
  2065c8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2065ca:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2065cc:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2065ce:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2065d0:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2065d2:	9301      	str	r3, [sp, #4]
  2065d4:	2301      	movs	r3, #1
  2065d6:	9300      	str	r3, [sp, #0]
  2065d8:	4623      	mov	r3, r4
  2065da:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  2065de:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  2065e2:	f7fe fcf3 	bl	204fcc <_DrawArrayBuffRightDown_AA>
				else
					_DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
				break;
  2065e6:	e063      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffRightDown_AA(lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
  2065e8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2065ea:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  2065ec:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  2065ee:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2065f0:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  2065f2:	9301      	str	r3, [sp, #4]
  2065f4:	2301      	movs	r3, #1
  2065f6:	9300      	str	r3, [sp, #0]
  2065f8:	4623      	mov	r3, r4
  2065fa:	edd7 0a07 	vldr	s1, [r7, #28]
  2065fe:	ed97 0a08 	vldr	s0, [r7, #32]
  206602:	f7fe fce3 	bl	204fcc <_DrawArrayBuffRightDown_AA>
				break;
  206606:	e053      	b.n	2066b0 <DrawLine+0x6e0>

			case 7:
				if(degree<315 && degree>=315-11)
  206608:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20660c:	f5b3 7f9d 	cmp.w	r3, #314	; 0x13a
  206610:	d814      	bhi.n	20663c <DrawLine+0x66c>
  206612:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206616:	f5b3 7f98 	cmp.w	r3, #304	; 0x130
  20661a:	d30f      	bcc.n	20663c <DrawLine+0x66c>
					_DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,1,linesBuff);
  20661c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20661e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206620:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  206622:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206624:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206626:	9301      	str	r3, [sp, #4]
  206628:	2301      	movs	r3, #1
  20662a:	9300      	str	r3, [sp, #0]
  20662c:	4623      	mov	r3, r4
  20662e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  206632:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  206636:	f7fe fec7 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
				else
					_DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
				break;
  20663a:	e039      	b.n	2066b0 <DrawLine+0x6e0>
					_DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,1,linesBuff);
  20663c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20663e:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206640:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  206642:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206644:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  206646:	9301      	str	r3, [sp, #4]
  206648:	2301      	movs	r3, #1
  20664a:	9300      	str	r3, [sp, #0]
  20664c:	4623      	mov	r3, r4
  20664e:	edd7 0a07 	vldr	s1, [r7, #28]
  206652:	ed97 0a08 	vldr	s0, [r7, #32]
  206656:	f7fe feb7 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
				break;
  20665a:	e029      	b.n	2066b0 <DrawLine+0x6e0>
			case 8:
				if(degree>=315 && degree<=315+11)
  20665c:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206660:	f5b3 7f9d 	cmp.w	r3, #314	; 0x13a
  206664:	d914      	bls.n	206690 <DrawLine+0x6c0>
  206666:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20666a:	f5b3 7fa3 	cmp.w	r3, #326	; 0x146
  20666e:	d80f      	bhi.n	206690 <DrawLine+0x6c0>
					_DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, 1.0, 1.0, BkpSizeX,0,linesBuff);
  206670:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206672:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206674:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  206676:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206678:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  20667a:	9301      	str	r3, [sp, #4]
  20667c:	2300      	movs	r3, #0
  20667e:	9300      	str	r3, [sp, #0]
  206680:	4623      	mov	r3, r4
  206682:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
  206686:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
  20668a:	f7fe fe9d 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
				else
					_DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
				break;
  20668e:	e00e      	b.n	2066ae <DrawLine+0x6de>
					_DrawArrayBuffLeftDown_AA (lineColor, bk1Color, bk2Color, ratioAA1, ratioAA2, BkpSizeX,0,linesBuff);
  206690:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  206692:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  206694:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  206696:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  206698:	6dbc      	ldr	r4, [r7, #88]	; 0x58
  20669a:	9301      	str	r3, [sp, #4]
  20669c:	2300      	movs	r3, #0
  20669e:	9300      	str	r3, [sp, #0]
  2066a0:	4623      	mov	r3, r4
  2066a2:	edd7 0a07 	vldr	s1, [r7, #28]
  2066a6:	ed97 0a08 	vldr	s0, [r7, #32]
  2066aa:	f7fe fe8d 	bl	2053c8 <_DrawArrayBuffLeftDown_AA>
				break;
  2066ae:	bf00      	nop
		}

		if((degree>=225-11 && degree<=225)||
  2066b0:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066b4:	2bd5      	cmp	r3, #213	; 0xd5
  2066b6:	d903      	bls.n	2066c0 <DrawLine+0x6f0>
  2066b8:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066bc:	2be1      	cmp	r3, #225	; 0xe1
  2066be:	d91b      	bls.n	2066f8 <DrawLine+0x728>
  2066c0:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066c4:	f5b3 7f9d 	cmp.w	r3, #314	; 0x13a
  2066c8:	d904      	bls.n	2066d4 <DrawLine+0x704>
		   (degree>=315    && degree<=315+11)||
  2066ca:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066ce:	f5b3 7fa3 	cmp.w	r3, #326	; 0x146
  2066d2:	d911      	bls.n	2066f8 <DrawLine+0x728>
  2066d4:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066d8:	2b87      	cmp	r3, #135	; 0x87
  2066da:	d903      	bls.n	2066e4 <DrawLine+0x714>
		   (degree>135     && degree<=135+11)||
  2066dc:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066e0:	2b92      	cmp	r3, #146	; 0x92
  2066e2:	d909      	bls.n	2066f8 <DrawLine+0x728>
  2066e4:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066e8:	2b21      	cmp	r3, #33	; 0x21
  2066ea:	f240 8097 	bls.w	20681c <DrawLine+0x84c>
		   (degree>=45-11  && degree<=45))
  2066ee:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2066f2:	2b2d      	cmp	r3, #45	; 0x2d
  2066f4:	f200 8092 	bhi.w	20681c <DrawLine+0x84c>
		{
			_GetNmbPxlsAndLoadToBuff();
  2066f8:	f107 0334 	add.w	r3, r7, #52	; 0x34
  2066fc:	469c      	mov	ip, r3
  2066fe:	f000 fb93 	bl	206e28 <_GetNmbPxlsAndLoadToBuff.12949>

			if((degree>=225-11 && degree<=225)||
  206702:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206706:	2bd5      	cmp	r3, #213	; 0xd5
  206708:	d903      	bls.n	206712 <DrawLine+0x742>
  20670a:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20670e:	2be1      	cmp	r3, #225	; 0xe1
  206710:	d907      	bls.n	206722 <DrawLine+0x752>
  206712:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206716:	2b87      	cmp	r3, #135	; 0x87
  206718:	d907      	bls.n	20672a <DrawLine+0x75a>
				(degree>135     && degree<=135+11)) direction=1;
  20671a:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20671e:	2b92      	cmp	r3, #146	; 0x92
  206720:	d803      	bhi.n	20672a <DrawLine+0x75a>
  206722:	2301      	movs	r3, #1
  206724:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  206728:	e003      	b.n	206732 <DrawLine+0x762>
			else                                   direction=-1;
  20672a:	f04f 33ff 	mov.w	r3, #4294967295
  20672e:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

			if((degree>=225-11 && degree<=225)||
  206732:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206736:	2bd5      	cmp	r3, #213	; 0xd5
  206738:	d903      	bls.n	206742 <DrawLine+0x772>
  20673a:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20673e:	2be1      	cmp	r3, #225	; 0xe1
  206740:	d909      	bls.n	206756 <DrawLine+0x786>
  206742:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206746:	f5b3 7f9d 	cmp.w	r3, #314	; 0x13a
  20674a:	d908      	bls.n	20675e <DrawLine+0x78e>
				(degree>=315    && degree<=315+11)) upDown=1;
  20674c:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206750:	f5b3 7fa3 	cmp.w	r3, #326	; 0x146
  206754:	d803      	bhi.n	20675e <DrawLine+0x78e>
  206756:	2301      	movs	r3, #1
  206758:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  20675c:	e003      	b.n	206766 <DrawLine+0x796>
			else                                   upDown=-1;
  20675e:	f04f 33ff 	mov.w	r3, #4294967295
  206762:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

			for(int j=0; j<linePointsStructSize; ++j)
  206766:	2300      	movs	r3, #0
  206768:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  20676c:	e050      	b.n	206810 <DrawLine+0x840>
			{
				nmbPxl    = linePoints[j].nmbPxl;
  20676e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  206770:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  206774:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  206778:	673b      	str	r3, [r7, #112]	; 0x70
				repeatPxl = linePoints[j].nmbPxlTheSame;
  20677a:	6bba      	ldr	r2, [r7, #56]	; 0x38
  20677c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  206780:	009b      	lsls	r3, r3, #2
  206782:	4413      	add	r3, r2
  206784:	789b      	ldrb	r3, [r3, #2]
  206786:	66fb      	str	r3, [r7, #108]	; 0x6c

				if(repeatPxl>1)
  206788:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20678a:	2b01      	cmp	r3, #1
  20678c:	dd15      	ble.n	2067ba <DrawLine+0x7ea>
					Pxl_H(nmbPxl,repeatPxl,repeatPxl+2,1,direction,upDown);
  20678e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206790:	b2d8      	uxtb	r0, r3
  206792:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206794:	b2d9      	uxtb	r1, r3
  206796:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206798:	b2db      	uxtb	r3, r3
  20679a:	3302      	adds	r3, #2
  20679c:	b2dc      	uxtb	r4, r3
  20679e:	f107 0234 	add.w	r2, r7, #52	; 0x34
  2067a2:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2067a6:	9301      	str	r3, [sp, #4]
  2067a8:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2067ac:	9300      	str	r3, [sp, #0]
  2067ae:	4694      	mov	ip, r2
  2067b0:	2301      	movs	r3, #1
  2067b2:	4622      	mov	r2, r4
  2067b4:	f000 faa4 	bl	206d00 <Pxl_H.12942>
  2067b8:	e025      	b.n	206806 <DrawLine+0x836>
				else{
					if(nmbPxl==2)
  2067ba:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2067bc:	2b02      	cmp	r3, #2
  2067be:	d111      	bne.n	2067e4 <DrawLine+0x814>
						Pxl_H(nmbPxl,repeatPxl,4,4,direction,upDown);
  2067c0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2067c2:	b2d8      	uxtb	r0, r3
  2067c4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2067c6:	b2d9      	uxtb	r1, r3
  2067c8:	f107 0234 	add.w	r2, r7, #52	; 0x34
  2067cc:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2067d0:	9301      	str	r3, [sp, #4]
  2067d2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2067d6:	9300      	str	r3, [sp, #0]
  2067d8:	4694      	mov	ip, r2
  2067da:	2304      	movs	r3, #4
  2067dc:	2204      	movs	r2, #4
  2067de:	f000 fa8f 	bl	206d00 <Pxl_H.12942>
  2067e2:	e010      	b.n	206806 <DrawLine+0x836>
					else
						Pxl_H(nmbPxl,repeatPxl,3,2,direction,upDown);
  2067e4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2067e6:	b2d8      	uxtb	r0, r3
  2067e8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2067ea:	b2d9      	uxtb	r1, r3
  2067ec:	f107 0234 	add.w	r2, r7, #52	; 0x34
  2067f0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2067f4:	9301      	str	r3, [sp, #4]
  2067f6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2067fa:	9300      	str	r3, [sp, #0]
  2067fc:	4694      	mov	ip, r2
  2067fe:	2302      	movs	r3, #2
  206800:	2203      	movs	r2, #3
  206802:	f000 fa7d 	bl	206d00 <Pxl_H.12942>
			for(int j=0; j<linePointsStructSize; ++j)
  206806:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  20680a:	3301      	adds	r3, #1
  20680c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  206810:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  206812:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  206816:	429a      	cmp	r2, r3
  206818:	dba9      	blt.n	20676e <DrawLine+0x79e>
  20681a:	e185      	b.n	206b28 <DrawLine+0xb58>
				}

			}

		}
		else if((degree>225 && degree<=225+11)||
  20681c:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206820:	2be1      	cmp	r3, #225	; 0xe1
  206822:	d903      	bls.n	20682c <DrawLine+0x85c>
  206824:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206828:	2bec      	cmp	r3, #236	; 0xec
  20682a:	d91b      	bls.n	206864 <DrawLine+0x894>
  20682c:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206830:	f5b3 7f9d 	cmp.w	r3, #314	; 0x13a
  206834:	d804      	bhi.n	206840 <DrawLine+0x870>
			    (degree<315  && degree>=315-11)||
  206836:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20683a:	f5b3 7f98 	cmp.w	r3, #304	; 0x130
  20683e:	d211      	bcs.n	206864 <DrawLine+0x894>
  206840:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206844:	2b87      	cmp	r3, #135	; 0x87
  206846:	d803      	bhi.n	206850 <DrawLine+0x880>
				 (degree<=135 && degree>=135-11)||
  206848:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20684c:	2b7b      	cmp	r3, #123	; 0x7b
  20684e:	d809      	bhi.n	206864 <DrawLine+0x894>
  206850:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206854:	2b2d      	cmp	r3, #45	; 0x2d
  206856:	f240 8167 	bls.w	206b28 <DrawLine+0xb58>
				 (degree>45   && degree<=45+11))
  20685a:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20685e:	2b38      	cmp	r3, #56	; 0x38
  206860:	f200 8162 	bhi.w	206b28 <DrawLine+0xb58>
		{
			_GetNmbPxlsAndLoadToBuff();
  206864:	f107 0334 	add.w	r3, r7, #52	; 0x34
  206868:	469c      	mov	ip, r3
  20686a:	f000 fadd 	bl	206e28 <_GetNmbPxlsAndLoadToBuff.12949>

			if((degree>225  && degree<=225+11)||
  20686e:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206872:	2be1      	cmp	r3, #225	; 0xe1
  206874:	d903      	bls.n	20687e <DrawLine+0x8ae>
  206876:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20687a:	2bec      	cmp	r3, #236	; 0xec
  20687c:	d907      	bls.n	20688e <DrawLine+0x8be>
  20687e:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206882:	2b87      	cmp	r3, #135	; 0x87
  206884:	d807      	bhi.n	206896 <DrawLine+0x8c6>
				(degree<=135 && degree>=135-11)) direction=1;
  206886:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20688a:	2b7b      	cmp	r3, #123	; 0x7b
  20688c:	d903      	bls.n	206896 <DrawLine+0x8c6>
  20688e:	2301      	movs	r3, #1
  206890:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  206894:	e003      	b.n	20689e <DrawLine+0x8ce>
			else                               direction=-1;
  206896:	f04f 33ff 	mov.w	r3, #4294967295
  20689a:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90

			if((degree>225 && degree<=225+11)||
  20689e:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068a2:	2be1      	cmp	r3, #225	; 0xe1
  2068a4:	d903      	bls.n	2068ae <DrawLine+0x8de>
  2068a6:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068aa:	2bec      	cmp	r3, #236	; 0xec
  2068ac:	d909      	bls.n	2068c2 <DrawLine+0x8f2>
  2068ae:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068b2:	f5b3 7f9d 	cmp.w	r3, #314	; 0x13a
  2068b6:	d808      	bhi.n	2068ca <DrawLine+0x8fa>
				(degree<315 && degree>=315-11)) upDown=1;
  2068b8:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068bc:	f5b3 7f98 	cmp.w	r3, #304	; 0x130
  2068c0:	d303      	bcc.n	2068ca <DrawLine+0x8fa>
  2068c2:	2301      	movs	r3, #1
  2068c4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  2068c8:	e003      	b.n	2068d2 <DrawLine+0x902>
			else                               upDown=-1;
  2068ca:	f04f 33ff 	mov.w	r3, #4294967295
  2068ce:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c

			if((degree>=225+6 && degree<=225+11)||
  2068d2:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068d6:	2be6      	cmp	r3, #230	; 0xe6
  2068d8:	d903      	bls.n	2068e2 <DrawLine+0x912>
  2068da:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068de:	2bec      	cmp	r3, #236	; 0xec
  2068e0:	d919      	bls.n	206916 <DrawLine+0x946>
  2068e2:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068e6:	f5b3 7f9b 	cmp.w	r3, #310	; 0x136
  2068ea:	d204      	bcs.n	2068f6 <DrawLine+0x926>
				(degree<=315-6 && degree>=315-11)||
  2068ec:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068f0:	f5b3 7f98 	cmp.w	r3, #304	; 0x130
  2068f4:	d20f      	bcs.n	206916 <DrawLine+0x946>
  2068f6:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  2068fa:	2b81      	cmp	r3, #129	; 0x81
  2068fc:	d803      	bhi.n	206906 <DrawLine+0x936>
				(degree<=135-6 && degree>=135-11)||
  2068fe:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206902:	2b7b      	cmp	r3, #123	; 0x7b
  206904:	d807      	bhi.n	206916 <DrawLine+0x946>
  206906:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  20690a:	2b32      	cmp	r3, #50	; 0x32
  20690c:	d976      	bls.n	2069fc <DrawLine+0xa2c>
				(degree>=45+6  && degree<=45+11))
  20690e:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
  206912:	2b38      	cmp	r3, #56	; 0x38
  206914:	d872      	bhi.n	2069fc <DrawLine+0xa2c>
			{
				for(int j=0; j<linePointsStructSize; ++j)
  206916:	2300      	movs	r3, #0
  206918:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  20691c:	e068      	b.n	2069f0 <DrawLine+0xa20>
				{
					nmbPxl    = linePoints[j].nmbPxl;
  20691e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  206920:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  206924:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  206928:	673b      	str	r3, [r7, #112]	; 0x70
					repeatPxl = linePoints[j].nmbPxlTheSame;
  20692a:	6bba      	ldr	r2, [r7, #56]	; 0x38
  20692c:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  206930:	009b      	lsls	r3, r3, #2
  206932:	4413      	add	r3, r2
  206934:	789b      	ldrb	r3, [r3, #2]
  206936:	66fb      	str	r3, [r7, #108]	; 0x6c

					if(repeatPxl>1)
  206938:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20693a:	2b01      	cmp	r3, #1
  20693c:	dd2d      	ble.n	20699a <DrawLine+0x9ca>
					{
						if(repeatPxl==2)
  20693e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206940:	2b02      	cmp	r3, #2
  206942:	d111      	bne.n	206968 <DrawLine+0x998>
							Pxl_V(nmbPxl,repeatPxl,4,1,direction,upDown);
  206944:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206946:	b2d8      	uxtb	r0, r3
  206948:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20694a:	b2d9      	uxtb	r1, r3
  20694c:	f107 0234 	add.w	r2, r7, #52	; 0x34
  206950:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  206954:	9301      	str	r3, [sp, #4]
  206956:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20695a:	9300      	str	r3, [sp, #0]
  20695c:	4694      	mov	ip, r2
  20695e:	2301      	movs	r3, #1
  206960:	2204      	movs	r2, #4
  206962:	f000 f927 	bl	206bb4 <Pxl_V.12930>
  206966:	e03e      	b.n	2069e6 <DrawLine+0xa16>
						else if(repeatPxl>=3)
  206968:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20696a:	2b02      	cmp	r3, #2
  20696c:	dd3b      	ble.n	2069e6 <DrawLine+0xa16>
							Pxl_V(nmbPxl,repeatPxl,repeatPxl+1,0,direction,upDown);
  20696e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206970:	b2d8      	uxtb	r0, r3
  206972:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206974:	b2d9      	uxtb	r1, r3
  206976:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206978:	b2db      	uxtb	r3, r3
  20697a:	3301      	adds	r3, #1
  20697c:	b2dc      	uxtb	r4, r3
  20697e:	f107 0234 	add.w	r2, r7, #52	; 0x34
  206982:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  206986:	9301      	str	r3, [sp, #4]
  206988:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20698c:	9300      	str	r3, [sp, #0]
  20698e:	4694      	mov	ip, r2
  206990:	2300      	movs	r3, #0
  206992:	4622      	mov	r2, r4
  206994:	f000 f90e 	bl	206bb4 <Pxl_V.12930>
  206998:	e025      	b.n	2069e6 <DrawLine+0xa16>
					}
					else
					{
						if(nmbPxl==1)
  20699a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  20699c:	2b01      	cmp	r3, #1
  20699e:	d111      	bne.n	2069c4 <DrawLine+0x9f4>
							Pxl_V(nmbPxl,repeatPxl,3,2,direction,upDown);
  2069a0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2069a2:	b2d8      	uxtb	r0, r3
  2069a4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2069a6:	b2d9      	uxtb	r1, r3
  2069a8:	f107 0234 	add.w	r2, r7, #52	; 0x34
  2069ac:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2069b0:	9301      	str	r3, [sp, #4]
  2069b2:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2069b6:	9300      	str	r3, [sp, #0]
  2069b8:	4694      	mov	ip, r2
  2069ba:	2302      	movs	r3, #2
  2069bc:	2203      	movs	r2, #3
  2069be:	f000 f8f9 	bl	206bb4 <Pxl_V.12930>
  2069c2:	e010      	b.n	2069e6 <DrawLine+0xa16>
						else
							Pxl_V(nmbPxl,repeatPxl,3,3,direction,upDown);
  2069c4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2069c6:	b2d8      	uxtb	r0, r3
  2069c8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2069ca:	b2d9      	uxtb	r1, r3
  2069cc:	f107 0234 	add.w	r2, r7, #52	; 0x34
  2069d0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2069d4:	9301      	str	r3, [sp, #4]
  2069d6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  2069da:	9300      	str	r3, [sp, #0]
  2069dc:	4694      	mov	ip, r2
  2069de:	2303      	movs	r3, #3
  2069e0:	2203      	movs	r2, #3
  2069e2:	f000 f8e7 	bl	206bb4 <Pxl_V.12930>
				for(int j=0; j<linePointsStructSize; ++j)
  2069e6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  2069ea:	3301      	adds	r3, #1
  2069ec:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  2069f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2069f2:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  2069f6:	429a      	cmp	r2, r3
  2069f8:	db91      	blt.n	20691e <DrawLine+0x94e>
  2069fa:	e095      	b.n	206b28 <DrawLine+0xb58>
					}
				}
			}
			else
			{
				for(int j=0; j<linePointsStructSize; ++j)
  2069fc:	2300      	movs	r3, #0
  2069fe:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  206a02:	e089      	b.n	206b18 <DrawLine+0xb48>
				{
					nmbPxl = linePoints[j].nmbPxl;
  206a04:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  206a06:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  206a0a:	f833 3022 	ldrh.w	r3, [r3, r2, lsl #2]
  206a0e:	673b      	str	r3, [r7, #112]	; 0x70
					repeatPxl = linePoints[j].nmbPxlTheSame;
  206a10:	6bba      	ldr	r2, [r7, #56]	; 0x38
  206a12:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  206a16:	009b      	lsls	r3, r3, #2
  206a18:	4413      	add	r3, r2
  206a1a:	789b      	ldrb	r3, [r3, #2]
  206a1c:	66fb      	str	r3, [r7, #108]	; 0x6c
					if(j+1<linePointsStructSize)
  206a1e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  206a22:	1c5a      	adds	r2, r3, #1
  206a24:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  206a26:	429a      	cmp	r2, r3
  206a28:	da08      	bge.n	206a3c <DrawLine+0xa6c>
						repeatPxl_next = linePoints[j+1].nmbPxlTheSame;
  206a2a:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  206a2e:	3301      	adds	r3, #1
  206a30:	6bba      	ldr	r2, [r7, #56]	; 0x38
  206a32:	009b      	lsls	r3, r3, #2
  206a34:	4413      	add	r3, r2
  206a36:	789b      	ldrb	r3, [r3, #2]
  206a38:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94

					if(repeatPxl>1){
  206a3c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206a3e:	2b01      	cmp	r3, #1
  206a40:	dd16      	ble.n	206a70 <DrawLine+0xaa0>
						if(Pxl_V(nmbPxl,repeatPxl,repeatPxl,0,direction,upDown)) break;
  206a42:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206a44:	b2d8      	uxtb	r0, r3
  206a46:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206a48:	b2d9      	uxtb	r1, r3
  206a4a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206a4c:	b2dc      	uxtb	r4, r3
  206a4e:	f107 0234 	add.w	r2, r7, #52	; 0x34
  206a52:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  206a56:	9301      	str	r3, [sp, #4]
  206a58:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  206a5c:	9300      	str	r3, [sp, #0]
  206a5e:	4694      	mov	ip, r2
  206a60:	2300      	movs	r3, #0
  206a62:	4622      	mov	r2, r4
  206a64:	f000 f8a6 	bl	206bb4 <Pxl_V.12930>
  206a68:	4603      	mov	r3, r0
  206a6a:	2b00      	cmp	r3, #0
  206a6c:	d04f      	beq.n	206b0e <DrawLine+0xb3e>
  206a6e:	e05b      	b.n	206b28 <DrawLine+0xb58>
					}
					else{
						if(repeatPxl_next<3){
  206a70:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  206a74:	2b02      	cmp	r3, #2
  206a76:	dc32      	bgt.n	206ade <DrawLine+0xb0e>
							if(repeatPxl==1 && j==linePointsStructSize-1){
  206a78:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206a7a:	2b01      	cmp	r3, #1
  206a7c:	d11a      	bne.n	206ab4 <DrawLine+0xae4>
  206a7e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  206a80:	1e5a      	subs	r2, r3, #1
  206a82:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  206a86:	429a      	cmp	r2, r3
  206a88:	d114      	bne.n	206ab4 <DrawLine+0xae4>
								if(Pxl_V(nmbPxl,repeatPxl,2,2,direction,upDown)) break;
  206a8a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206a8c:	b2d8      	uxtb	r0, r3
  206a8e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206a90:	b2d9      	uxtb	r1, r3
  206a92:	f107 0234 	add.w	r2, r7, #52	; 0x34
  206a96:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  206a9a:	9301      	str	r3, [sp, #4]
  206a9c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  206aa0:	9300      	str	r3, [sp, #0]
  206aa2:	4694      	mov	ip, r2
  206aa4:	2302      	movs	r3, #2
  206aa6:	2202      	movs	r2, #2
  206aa8:	f000 f884 	bl	206bb4 <Pxl_V.12930>
  206aac:	4603      	mov	r3, r0
  206aae:	2b00      	cmp	r3, #0
  206ab0:	d02d      	beq.n	206b0e <DrawLine+0xb3e>
  206ab2:	e039      	b.n	206b28 <DrawLine+0xb58>
							}
							else{
								if(Pxl_V(nmbPxl,repeatPxl,5,5,direction,upDown)) break;
  206ab4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206ab6:	b2d8      	uxtb	r0, r3
  206ab8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206aba:	b2d9      	uxtb	r1, r3
  206abc:	f107 0234 	add.w	r2, r7, #52	; 0x34
  206ac0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  206ac4:	9301      	str	r3, [sp, #4]
  206ac6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  206aca:	9300      	str	r3, [sp, #0]
  206acc:	4694      	mov	ip, r2
  206ace:	2305      	movs	r3, #5
  206ad0:	2205      	movs	r2, #5
  206ad2:	f000 f86f 	bl	206bb4 <Pxl_V.12930>
  206ad6:	4603      	mov	r3, r0
  206ad8:	2b00      	cmp	r3, #0
  206ada:	d018      	beq.n	206b0e <DrawLine+0xb3e>
  206adc:	e024      	b.n	206b28 <DrawLine+0xb58>
							}
						}
						else{
							if(Pxl_V(nmbPxl,repeatPxl,repeatPxl_next,repeatPxl_next,direction,upDown)) break;
  206ade:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  206ae0:	b2d8      	uxtb	r0, r3
  206ae2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  206ae4:	b2d9      	uxtb	r1, r3
  206ae6:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  206aea:	b2dc      	uxtb	r4, r3
  206aec:	f107 0234 	add.w	r2, r7, #52	; 0x34
  206af0:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  206af4:	9301      	str	r3, [sp, #4]
  206af6:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  206afa:	9300      	str	r3, [sp, #0]
  206afc:	4694      	mov	ip, r2
  206afe:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  206b02:	4622      	mov	r2, r4
  206b04:	f000 f856 	bl	206bb4 <Pxl_V.12930>
  206b08:	4603      	mov	r3, r0
  206b0a:	2b00      	cmp	r3, #0
  206b0c:	d10b      	bne.n	206b26 <DrawLine+0xb56>
				for(int j=0; j<linePointsStructSize; ++j)
  206b0e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  206b12:	3301      	adds	r3, #1
  206b14:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  206b18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  206b1a:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  206b1e:	429a      	cmp	r2, r3
  206b20:	f6ff af70 	blt.w	206a04 <DrawLine+0xa34>
  206b24:	e000      	b.n	206b28 <DrawLine+0xb58>
							if(Pxl_V(nmbPxl,repeatPxl,repeatPxl_next,repeatPxl_next,direction,upDown)) break;
  206b26:	bf00      	nop
  206b28:	46d5      	mov	sp, sl
  206b2a:	f8d7 d004 	ldr.w	sp, [r7, #4]
			}
		}
	}

	#undef LINES_BUFF_SIZE
}
  206b2e:	bf00      	nop
  206b30:	37ac      	adds	r7, #172	; 0xac
  206b32:	46bd      	mov	sp, r7
  206b34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

00206b38 <_GetNmbPxls.12910>:
		{
  206b38:	b480      	push	{r7}
  206b3a:	b087      	sub	sp, #28
  206b3c:	af00      	add	r7, sp, #0
  206b3e:	4663      	mov	r3, ip
  206b40:	f8c7 c004 	str.w	ip, [r7, #4]
			int j,it=0,count1=0;
  206b44:	2200      	movs	r2, #0
  206b46:	613a      	str	r2, [r7, #16]
  206b48:	2200      	movs	r2, #0
  206b4a:	60fa      	str	r2, [r7, #12]
			char linesBuff_prev=0;
  206b4c:	2200      	movs	r2, #0
  206b4e:	72fa      	strb	r2, [r7, #11]
			linesBuff_prev=linesBuff[1];
  206b50:	69da      	ldr	r2, [r3, #28]
  206b52:	7852      	ldrb	r2, [r2, #1]
  206b54:	72fa      	strb	r2, [r7, #11]
			for(j=0;j<linesBuff[0];++j){
  206b56:	2200      	movs	r2, #0
  206b58:	617a      	str	r2, [r7, #20]
  206b5a:	e017      	b.n	206b8c <_GetNmbPxls.12910+0x54>
				if(linesBuff[1+j]==linesBuff_prev) count1++;
  206b5c:	697a      	ldr	r2, [r7, #20]
  206b5e:	3201      	adds	r2, #1
  206b60:	69d9      	ldr	r1, [r3, #28]
  206b62:	5c8a      	ldrb	r2, [r1, r2]
  206b64:	7af9      	ldrb	r1, [r7, #11]
  206b66:	4291      	cmp	r1, r2
  206b68:	d103      	bne.n	206b72 <_GetNmbPxls.12910+0x3a>
  206b6a:	68fa      	ldr	r2, [r7, #12]
  206b6c:	3201      	adds	r2, #1
  206b6e:	60fa      	str	r2, [r7, #12]
  206b70:	e009      	b.n	206b86 <_GetNmbPxls.12910+0x4e>
					it++;
  206b72:	693a      	ldr	r2, [r7, #16]
  206b74:	3201      	adds	r2, #1
  206b76:	613a      	str	r2, [r7, #16]
					linesBuff_prev=linesBuff[1+j];
  206b78:	697a      	ldr	r2, [r7, #20]
  206b7a:	3201      	adds	r2, #1
  206b7c:	69d9      	ldr	r1, [r3, #28]
  206b7e:	5c8a      	ldrb	r2, [r1, r2]
  206b80:	72fa      	strb	r2, [r7, #11]
					count1=1;
  206b82:	2201      	movs	r2, #1
  206b84:	60fa      	str	r2, [r7, #12]
			for(j=0;j<linesBuff[0];++j){
  206b86:	697a      	ldr	r2, [r7, #20]
  206b88:	3201      	adds	r2, #1
  206b8a:	617a      	str	r2, [r7, #20]
  206b8c:	69da      	ldr	r2, [r3, #28]
  206b8e:	7812      	ldrb	r2, [r2, #0]
  206b90:	4611      	mov	r1, r2
  206b92:	697a      	ldr	r2, [r7, #20]
  206b94:	4291      	cmp	r1, r2
  206b96:	dce1      	bgt.n	206b5c <_GetNmbPxls.12910+0x24>
			if(count1){
  206b98:	68fb      	ldr	r3, [r7, #12]
  206b9a:	2b00      	cmp	r3, #0
  206b9c:	d002      	beq.n	206ba4 <_GetNmbPxls.12910+0x6c>
				it++;
  206b9e:	693b      	ldr	r3, [r7, #16]
  206ba0:	3301      	adds	r3, #1
  206ba2:	613b      	str	r3, [r7, #16]
			return it;
  206ba4:	693b      	ldr	r3, [r7, #16]
		}
  206ba6:	4618      	mov	r0, r3
  206ba8:	371c      	adds	r7, #28
  206baa:	46bd      	mov	sp, r7
  206bac:	f85d 7b04 	ldr.w	r7, [sp], #4
  206bb0:	4770      	bx	lr
	...

00206bb4 <Pxl_V.12930>:
		{
  206bb4:	b590      	push	{r4, r7, lr}
  206bb6:	b087      	sub	sp, #28
  206bb8:	af00      	add	r7, sp, #0
  206bba:	60bb      	str	r3, [r7, #8]
  206bbc:	4603      	mov	r3, r0
  206bbe:	73fb      	strb	r3, [r7, #15]
  206bc0:	460b      	mov	r3, r1
  206bc2:	73bb      	strb	r3, [r7, #14]
  206bc4:	4613      	mov	r3, r2
  206bc6:	737b      	strb	r3, [r7, #13]
  206bc8:	4664      	mov	r4, ip
  206bca:	f8c7 c004 	str.w	ip, [r7, #4]
			if(repeat>1)
  206bce:	7bbb      	ldrb	r3, [r7, #14]
  206bd0:	2b01      	cmp	r3, #1
  206bd2:	d94d      	bls.n	206c70 <Pxl_V.12930+0xbc>
				for(int i=0;i<repeat;++i)
  206bd4:	2300      	movs	r3, #0
  206bd6:	617b      	str	r3, [r7, #20]
  206bd8:	e045      	b.n	206c66 <Pxl_V.12930+0xb2>
					Set_AACoeff_Draw(stepAA,lineColor,bk1Color,0.0);
  206bda:	7b7b      	ldrb	r3, [r7, #13]
  206bdc:	69a1      	ldr	r1, [r4, #24]
  206bde:	6962      	ldr	r2, [r4, #20]
  206be0:	ed9f 0a44 	vldr	s0, [pc, #272]	; 206cf4 <Pxl_V.12930+0x140>
  206be4:	4618      	mov	r0, r3
  206be6:	f7fe f981 	bl	204eec <Set_AACoeff_Draw>
					pLcd[k_p-			upDown*BkpSizeX]=	buff_AA[offs+1+i];
  206bea:	6923      	ldr	r3, [r4, #16]
  206bec:	4619      	mov	r1, r3
  206bee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  206bf0:	6a62      	ldr	r2, [r4, #36]	; 0x24
  206bf2:	fb02 f303 	mul.w	r3, r2, r3
  206bf6:	1acb      	subs	r3, r1, r3
  206bf8:	68ba      	ldr	r2, [r7, #8]
  206bfa:	1c51      	adds	r1, r2, #1
  206bfc:	697a      	ldr	r2, [r7, #20]
  206bfe:	440a      	add	r2, r1
  206c00:	493d      	ldr	r1, [pc, #244]	; (206cf8 <Pxl_V.12930+0x144>)
  206c02:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206c06:	493d      	ldr	r1, [pc, #244]	; (206cfc <Pxl_V.12930+0x148>)
  206c08:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					Set_AACoeff_Draw(stepAA,lineColor,bk2Color,0.0);
  206c0c:	7b7b      	ldrb	r3, [r7, #13]
  206c0e:	69a1      	ldr	r1, [r4, #24]
  206c10:	68e2      	ldr	r2, [r4, #12]
  206c12:	ed9f 0a38 	vldr	s0, [pc, #224]	; 206cf4 <Pxl_V.12930+0x140>
  206c16:	4618      	mov	r0, r3
  206c18:	f7fe f968 	bl	204eec <Set_AACoeff_Draw>
					pLcd[k_p+upDown*nmbPxl_V*BkpSizeX]=	buff_AA[offs+repeat-i];
  206c1c:	7bfb      	ldrb	r3, [r7, #15]
  206c1e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  206c20:	fb02 f303 	mul.w	r3, r2, r3
  206c24:	461a      	mov	r2, r3
  206c26:	6a63      	ldr	r3, [r4, #36]	; 0x24
  206c28:	fb03 f302 	mul.w	r3, r3, r2
  206c2c:	6922      	ldr	r2, [r4, #16]
  206c2e:	4413      	add	r3, r2
  206c30:	7bb9      	ldrb	r1, [r7, #14]
  206c32:	68ba      	ldr	r2, [r7, #8]
  206c34:	4411      	add	r1, r2
  206c36:	697a      	ldr	r2, [r7, #20]
  206c38:	1a8a      	subs	r2, r1, r2
  206c3a:	492f      	ldr	r1, [pc, #188]	; (206cf8 <Pxl_V.12930+0x144>)
  206c3c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206c40:	492e      	ldr	r1, [pc, #184]	; (206cfc <Pxl_V.12930+0x148>)
  206c42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					 k_p=k_p+upDown*nmbPxl_V*BkpSizeX+direction;
  206c46:	7bfb      	ldrb	r3, [r7, #15]
  206c48:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  206c4a:	fb02 f303 	mul.w	r3, r2, r3
  206c4e:	461a      	mov	r2, r3
  206c50:	6a63      	ldr	r3, [r4, #36]	; 0x24
  206c52:	fb03 f302 	mul.w	r3, r3, r2
  206c56:	6922      	ldr	r2, [r4, #16]
  206c58:	441a      	add	r2, r3
  206c5a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  206c5c:	4413      	add	r3, r2
  206c5e:	6123      	str	r3, [r4, #16]
				for(int i=0;i<repeat;++i)
  206c60:	697b      	ldr	r3, [r7, #20]
  206c62:	3301      	adds	r3, #1
  206c64:	617b      	str	r3, [r7, #20]
  206c66:	7bba      	ldrb	r2, [r7, #14]
  206c68:	697b      	ldr	r3, [r7, #20]
  206c6a:	429a      	cmp	r2, r3
  206c6c:	dcb5      	bgt.n	206bda <Pxl_V.12930+0x26>
  206c6e:	e03b      	b.n	206ce8 <Pxl_V.12930+0x134>
				Set_AACoeff_Draw(stepAA,lineColor,bk1Color,0.0);
  206c70:	7b7b      	ldrb	r3, [r7, #13]
  206c72:	69a1      	ldr	r1, [r4, #24]
  206c74:	6962      	ldr	r2, [r4, #20]
  206c76:	ed9f 0a1f 	vldr	s0, [pc, #124]	; 206cf4 <Pxl_V.12930+0x140>
  206c7a:	4618      	mov	r0, r3
  206c7c:	f7fe f936 	bl	204eec <Set_AACoeff_Draw>
				pLcd[k_p-			upDown*BkpSizeX]=	buff_AA[offs];
  206c80:	6923      	ldr	r3, [r4, #16]
  206c82:	4619      	mov	r1, r3
  206c84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  206c86:	6a62      	ldr	r2, [r4, #36]	; 0x24
  206c88:	fb02 f303 	mul.w	r3, r2, r3
  206c8c:	1acb      	subs	r3, r1, r3
  206c8e:	491a      	ldr	r1, [pc, #104]	; (206cf8 <Pxl_V.12930+0x144>)
  206c90:	68ba      	ldr	r2, [r7, #8]
  206c92:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206c96:	4919      	ldr	r1, [pc, #100]	; (206cfc <Pxl_V.12930+0x148>)
  206c98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				Set_AACoeff_Draw(stepAA,lineColor,bk2Color,0.0);
  206c9c:	7b7b      	ldrb	r3, [r7, #13]
  206c9e:	69a1      	ldr	r1, [r4, #24]
  206ca0:	68e2      	ldr	r2, [r4, #12]
  206ca2:	ed9f 0a14 	vldr	s0, [pc, #80]	; 206cf4 <Pxl_V.12930+0x140>
  206ca6:	4618      	mov	r0, r3
  206ca8:	f7fe f920 	bl	204eec <Set_AACoeff_Draw>
				pLcd[k_p+upDown*nmbPxl_V*BkpSizeX]=	buff_AA[offs];
  206cac:	7bfb      	ldrb	r3, [r7, #15]
  206cae:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  206cb0:	fb02 f303 	mul.w	r3, r2, r3
  206cb4:	461a      	mov	r2, r3
  206cb6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  206cb8:	fb03 f302 	mul.w	r3, r3, r2
  206cbc:	6922      	ldr	r2, [r4, #16]
  206cbe:	4413      	add	r3, r2
  206cc0:	490d      	ldr	r1, [pc, #52]	; (206cf8 <Pxl_V.12930+0x144>)
  206cc2:	68ba      	ldr	r2, [r7, #8]
  206cc4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206cc8:	490c      	ldr	r1, [pc, #48]	; (206cfc <Pxl_V.12930+0x148>)
  206cca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				 k_p=k_p+upDown*nmbPxl_V*BkpSizeX+direction;
  206cce:	7bfb      	ldrb	r3, [r7, #15]
  206cd0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  206cd2:	fb02 f303 	mul.w	r3, r2, r3
  206cd6:	461a      	mov	r2, r3
  206cd8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  206cda:	fb03 f302 	mul.w	r3, r3, r2
  206cde:	6922      	ldr	r2, [r4, #16]
  206ce0:	441a      	add	r2, r3
  206ce2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  206ce4:	4413      	add	r3, r2
  206ce6:	6123      	str	r3, [r4, #16]
			return 0;
  206ce8:	2300      	movs	r3, #0
		}
  206cea:	4618      	mov	r0, r3
  206cec:	371c      	adds	r7, #28
  206cee:	46bd      	mov	sp, r7
  206cf0:	bd90      	pop	{r4, r7, pc}
  206cf2:	bf00      	nop
  206cf4:	00000000 	.word	0x00000000
  206cf8:	20001878 	.word	0x20001878
  206cfc:	c0000000 	.word	0xc0000000

00206d00 <Pxl_H.12942>:
		{
  206d00:	b590      	push	{r4, r7, lr}
  206d02:	b087      	sub	sp, #28
  206d04:	af00      	add	r7, sp, #0
  206d06:	60bb      	str	r3, [r7, #8]
  206d08:	4603      	mov	r3, r0
  206d0a:	73fb      	strb	r3, [r7, #15]
  206d0c:	460b      	mov	r3, r1
  206d0e:	73bb      	strb	r3, [r7, #14]
  206d10:	4613      	mov	r3, r2
  206d12:	737b      	strb	r3, [r7, #13]
  206d14:	4664      	mov	r4, ip
  206d16:	f8c7 c004 	str.w	ip, [r7, #4]
			if(repeat>1)
  206d1a:	7bbb      	ldrb	r3, [r7, #14]
  206d1c:	2b01      	cmp	r3, #1
  206d1e:	d944      	bls.n	206daa <Pxl_H.12942+0xaa>
				for(int i=0;i<repeat;++i)
  206d20:	2300      	movs	r3, #0
  206d22:	617b      	str	r3, [r7, #20]
  206d24:	e03c      	b.n	206da0 <Pxl_H.12942+0xa0>
					Set_AACoeff_Draw(stepAA,lineColor,bk1Color,0.0);
  206d26:	7b7b      	ldrb	r3, [r7, #13]
  206d28:	69a1      	ldr	r1, [r4, #24]
  206d2a:	6962      	ldr	r2, [r4, #20]
  206d2c:	ed9f 0a3b 	vldr	s0, [pc, #236]	; 206e1c <Pxl_H.12942+0x11c>
  206d30:	4618      	mov	r0, r3
  206d32:	f7fe f8db 	bl	204eec <Set_AACoeff_Draw>
					pLcd[k_p-direction]			=	buff_AA[offs+1+i];
  206d36:	6922      	ldr	r2, [r4, #16]
  206d38:	6abb      	ldr	r3, [r7, #40]	; 0x28
  206d3a:	1ad3      	subs	r3, r2, r3
  206d3c:	68ba      	ldr	r2, [r7, #8]
  206d3e:	1c51      	adds	r1, r2, #1
  206d40:	697a      	ldr	r2, [r7, #20]
  206d42:	440a      	add	r2, r1
  206d44:	4936      	ldr	r1, [pc, #216]	; (206e20 <Pxl_H.12942+0x120>)
  206d46:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206d4a:	4936      	ldr	r1, [pc, #216]	; (206e24 <Pxl_H.12942+0x124>)
  206d4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					Set_AACoeff_Draw(stepAA,lineColor,bk2Color,0.0);
  206d50:	7b7b      	ldrb	r3, [r7, #13]
  206d52:	69a1      	ldr	r1, [r4, #24]
  206d54:	68e2      	ldr	r2, [r4, #12]
  206d56:	ed9f 0a31 	vldr	s0, [pc, #196]	; 206e1c <Pxl_H.12942+0x11c>
  206d5a:	4618      	mov	r0, r3
  206d5c:	f7fe f8c6 	bl	204eec <Set_AACoeff_Draw>
					pLcd[k_p+direction*nmbPxl_H]=	buff_AA[offs+repeat-i];
  206d60:	7bfb      	ldrb	r3, [r7, #15]
  206d62:	6aba      	ldr	r2, [r7, #40]	; 0x28
  206d64:	fb02 f203 	mul.w	r2, r2, r3
  206d68:	6923      	ldr	r3, [r4, #16]
  206d6a:	4413      	add	r3, r2
  206d6c:	7bb9      	ldrb	r1, [r7, #14]
  206d6e:	68ba      	ldr	r2, [r7, #8]
  206d70:	4411      	add	r1, r2
  206d72:	697a      	ldr	r2, [r7, #20]
  206d74:	1a8a      	subs	r2, r1, r2
  206d76:	492a      	ldr	r1, [pc, #168]	; (206e20 <Pxl_H.12942+0x120>)
  206d78:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206d7c:	4929      	ldr	r1, [pc, #164]	; (206e24 <Pxl_H.12942+0x124>)
  206d7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
					k_p=k_p+upDown*BkpSizeX+direction*nmbPxl_H;
  206d82:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  206d84:	6a62      	ldr	r2, [r4, #36]	; 0x24
  206d86:	fb02 f303 	mul.w	r3, r2, r3
  206d8a:	7bfa      	ldrb	r2, [r7, #15]
  206d8c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  206d8e:	fb01 f202 	mul.w	r2, r1, r2
  206d92:	4413      	add	r3, r2
  206d94:	6922      	ldr	r2, [r4, #16]
  206d96:	4413      	add	r3, r2
  206d98:	6123      	str	r3, [r4, #16]
				for(int i=0;i<repeat;++i)
  206d9a:	697b      	ldr	r3, [r7, #20]
  206d9c:	3301      	adds	r3, #1
  206d9e:	617b      	str	r3, [r7, #20]
  206da0:	7bba      	ldrb	r2, [r7, #14]
  206da2:	697b      	ldr	r3, [r7, #20]
  206da4:	429a      	cmp	r2, r3
  206da6:	dcbe      	bgt.n	206d26 <Pxl_H.12942+0x26>
  206da8:	e032      	b.n	206e10 <Pxl_H.12942+0x110>
				Set_AACoeff_Draw(stepAA,lineColor,bk1Color,0.0);
  206daa:	7b7b      	ldrb	r3, [r7, #13]
  206dac:	69a1      	ldr	r1, [r4, #24]
  206dae:	6962      	ldr	r2, [r4, #20]
  206db0:	ed9f 0a1a 	vldr	s0, [pc, #104]	; 206e1c <Pxl_H.12942+0x11c>
  206db4:	4618      	mov	r0, r3
  206db6:	f7fe f899 	bl	204eec <Set_AACoeff_Draw>
				pLcd[k_p-direction]			=	buff_AA[offs];
  206dba:	6922      	ldr	r2, [r4, #16]
  206dbc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  206dbe:	1ad3      	subs	r3, r2, r3
  206dc0:	4917      	ldr	r1, [pc, #92]	; (206e20 <Pxl_H.12942+0x120>)
  206dc2:	68ba      	ldr	r2, [r7, #8]
  206dc4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206dc8:	4916      	ldr	r1, [pc, #88]	; (206e24 <Pxl_H.12942+0x124>)
  206dca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				Set_AACoeff_Draw(stepAA,lineColor,bk2Color,0.0);
  206dce:	7b7b      	ldrb	r3, [r7, #13]
  206dd0:	69a1      	ldr	r1, [r4, #24]
  206dd2:	68e2      	ldr	r2, [r4, #12]
  206dd4:	ed9f 0a11 	vldr	s0, [pc, #68]	; 206e1c <Pxl_H.12942+0x11c>
  206dd8:	4618      	mov	r0, r3
  206dda:	f7fe f887 	bl	204eec <Set_AACoeff_Draw>
				pLcd[k_p+direction*nmbPxl_H]=	buff_AA[offs];
  206dde:	7bfb      	ldrb	r3, [r7, #15]
  206de0:	6aba      	ldr	r2, [r7, #40]	; 0x28
  206de2:	fb02 f203 	mul.w	r2, r2, r3
  206de6:	6923      	ldr	r3, [r4, #16]
  206de8:	4413      	add	r3, r2
  206dea:	490d      	ldr	r1, [pc, #52]	; (206e20 <Pxl_H.12942+0x120>)
  206dec:	68ba      	ldr	r2, [r7, #8]
  206dee:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  206df2:	490c      	ldr	r1, [pc, #48]	; (206e24 <Pxl_H.12942+0x124>)
  206df4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
				k_p=k_p+upDown*BkpSizeX+direction*nmbPxl_H;
  206df8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  206dfa:	6a62      	ldr	r2, [r4, #36]	; 0x24
  206dfc:	fb02 f303 	mul.w	r3, r2, r3
  206e00:	7bfa      	ldrb	r2, [r7, #15]
  206e02:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  206e04:	fb01 f202 	mul.w	r2, r1, r2
  206e08:	4413      	add	r3, r2
  206e0a:	6922      	ldr	r2, [r4, #16]
  206e0c:	4413      	add	r3, r2
  206e0e:	6123      	str	r3, [r4, #16]
			return 0;
  206e10:	2300      	movs	r3, #0
		}
  206e12:	4618      	mov	r0, r3
  206e14:	371c      	adds	r7, #28
  206e16:	46bd      	mov	sp, r7
  206e18:	bd90      	pop	{r4, r7, pc}
  206e1a:	bf00      	nop
  206e1c:	00000000 	.word	0x00000000
  206e20:	20001878 	.word	0x20001878
  206e24:	c0000000 	.word	0xc0000000

00206e28 <_GetNmbPxlsAndLoadToBuff.12949>:
		{
  206e28:	b480      	push	{r7}
  206e2a:	b087      	sub	sp, #28
  206e2c:	af00      	add	r7, sp, #0
  206e2e:	4663      	mov	r3, ip
  206e30:	f8c7 c004 	str.w	ip, [r7, #4]
			int j,it=0,count1=0;
  206e34:	2200      	movs	r2, #0
  206e36:	613a      	str	r2, [r7, #16]
  206e38:	2200      	movs	r2, #0
  206e3a:	60fa      	str	r2, [r7, #12]
			char linesBuff_prev=0;
  206e3c:	2200      	movs	r2, #0
  206e3e:	72fa      	strb	r2, [r7, #11]
			linesBuff_prev=linesBuff[1];
  206e40:	69da      	ldr	r2, [r3, #28]
  206e42:	7852      	ldrb	r2, [r2, #1]
  206e44:	72fa      	strb	r2, [r7, #11]
			for(j=1;j<linesBuff[0]+1;++j){
  206e46:	2201      	movs	r2, #1
  206e48:	617a      	str	r2, [r7, #20]
  206e4a:	e024      	b.n	206e96 <_GetNmbPxlsAndLoadToBuff.12949+0x6e>
				if(linesBuff[j]==linesBuff_prev) count1++;
  206e4c:	69d9      	ldr	r1, [r3, #28]
  206e4e:	697a      	ldr	r2, [r7, #20]
  206e50:	440a      	add	r2, r1
  206e52:	7812      	ldrb	r2, [r2, #0]
  206e54:	7af9      	ldrb	r1, [r7, #11]
  206e56:	4291      	cmp	r1, r2
  206e58:	d103      	bne.n	206e62 <_GetNmbPxlsAndLoadToBuff.12949+0x3a>
  206e5a:	68fa      	ldr	r2, [r7, #12]
  206e5c:	3201      	adds	r2, #1
  206e5e:	60fa      	str	r2, [r7, #12]
  206e60:	e016      	b.n	206e90 <_GetNmbPxlsAndLoadToBuff.12949+0x68>
					linePoints[it].nmbPxl=linesBuff_prev;
  206e62:	7afa      	ldrb	r2, [r7, #11]
  206e64:	b290      	uxth	r0, r2
  206e66:	685a      	ldr	r2, [r3, #4]
  206e68:	6939      	ldr	r1, [r7, #16]
  206e6a:	f822 0021 	strh.w	r0, [r2, r1, lsl #2]
					linePoints[it++].nmbPxlTheSame=count1;
  206e6e:	693a      	ldr	r2, [r7, #16]
  206e70:	1c51      	adds	r1, r2, #1
  206e72:	6139      	str	r1, [r7, #16]
  206e74:	68f9      	ldr	r1, [r7, #12]
  206e76:	b2c8      	uxtb	r0, r1
  206e78:	6859      	ldr	r1, [r3, #4]
  206e7a:	0092      	lsls	r2, r2, #2
  206e7c:	440a      	add	r2, r1
  206e7e:	4601      	mov	r1, r0
  206e80:	7091      	strb	r1, [r2, #2]
					linesBuff_prev=linesBuff[j];
  206e82:	69d9      	ldr	r1, [r3, #28]
  206e84:	697a      	ldr	r2, [r7, #20]
  206e86:	440a      	add	r2, r1
  206e88:	7812      	ldrb	r2, [r2, #0]
  206e8a:	72fa      	strb	r2, [r7, #11]
					count1=1;
  206e8c:	2201      	movs	r2, #1
  206e8e:	60fa      	str	r2, [r7, #12]
			for(j=1;j<linesBuff[0]+1;++j){
  206e90:	697a      	ldr	r2, [r7, #20]
  206e92:	3201      	adds	r2, #1
  206e94:	617a      	str	r2, [r7, #20]
  206e96:	69da      	ldr	r2, [r3, #28]
  206e98:	7812      	ldrb	r2, [r2, #0]
  206e9a:	1c51      	adds	r1, r2, #1
  206e9c:	697a      	ldr	r2, [r7, #20]
  206e9e:	4291      	cmp	r1, r2
  206ea0:	dcd4      	bgt.n	206e4c <_GetNmbPxlsAndLoadToBuff.12949+0x24>
			if(count1){
  206ea2:	68fa      	ldr	r2, [r7, #12]
  206ea4:	2a00      	cmp	r2, #0
  206ea6:	d00f      	beq.n	206ec8 <_GetNmbPxlsAndLoadToBuff.12949+0xa0>
				linePoints[it].nmbPxl=linesBuff_prev;
  206ea8:	7afa      	ldrb	r2, [r7, #11]
  206eaa:	b290      	uxth	r0, r2
  206eac:	685a      	ldr	r2, [r3, #4]
  206eae:	6939      	ldr	r1, [r7, #16]
  206eb0:	f822 0021 	strh.w	r0, [r2, r1, lsl #2]
				linePoints[it++].nmbPxlTheSame=count1;
  206eb4:	693a      	ldr	r2, [r7, #16]
  206eb6:	1c51      	adds	r1, r2, #1
  206eb8:	6139      	str	r1, [r7, #16]
  206eba:	68f9      	ldr	r1, [r7, #12]
  206ebc:	b2c8      	uxtb	r0, r1
  206ebe:	6859      	ldr	r1, [r3, #4]
  206ec0:	0092      	lsls	r2, r2, #2
  206ec2:	440a      	add	r2, r1
  206ec4:	4601      	mov	r1, r0
  206ec6:	7091      	strb	r1, [r2, #2]
			linePointsStructSize=it;
  206ec8:	693a      	ldr	r2, [r7, #16]
  206eca:	601a      	str	r2, [r3, #0]
		}
  206ecc:	bf00      	nop
  206ece:	371c      	adds	r7, #28
  206ed0:	46bd      	mov	sp, r7
  206ed2:	f85d 7b04 	ldr.w	r7, [sp], #4
  206ed6:	4770      	bx	lr

00206ed8 <LCD_SetCircleDegreesBuff>:
	for(int i=0;i<Circle.degree[0];++i){
		if(Circle.degree[1+i]==0)
			Circle.degree[1+i]=360;
	}
}
void LCD_SetCircleDegreesBuff(int len, uint16_t *buf){
  206ed8:	b580      	push	{r7, lr}
  206eda:	b086      	sub	sp, #24
  206edc:	af00      	add	r7, sp, #0
  206ede:	6078      	str	r0, [r7, #4]
  206ee0:	6039      	str	r1, [r7, #0]
	int i,deg;
	for(i=0;i<len;i++){
  206ee2:	2300      	movs	r3, #0
  206ee4:	617b      	str	r3, [r7, #20]
  206ee6:	e013      	b.n	206f10 <LCD_SetCircleDegreesBuff+0x38>
		if(i==MAX_DEGREE_CIRCLE) break;
  206ee8:	697b      	ldr	r3, [r7, #20]
  206eea:	2b0a      	cmp	r3, #10
  206eec:	d015      	beq.n	206f1a <LCD_SetCircleDegreesBuff+0x42>
		Circle.degree[1+i]=buf[i];
  206eee:	697b      	ldr	r3, [r7, #20]
  206ef0:	3301      	adds	r3, #1
  206ef2:	697a      	ldr	r2, [r7, #20]
  206ef4:	0052      	lsls	r2, r2, #1
  206ef6:	6839      	ldr	r1, [r7, #0]
  206ef8:	440a      	add	r2, r1
  206efa:	8811      	ldrh	r1, [r2, #0]
  206efc:	4a88      	ldr	r2, [pc, #544]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206efe:	f503 7382 	add.w	r3, r3, #260	; 0x104
  206f02:	005b      	lsls	r3, r3, #1
  206f04:	4413      	add	r3, r2
  206f06:	460a      	mov	r2, r1
  206f08:	809a      	strh	r2, [r3, #4]
	for(i=0;i<len;i++){
  206f0a:	697b      	ldr	r3, [r7, #20]
  206f0c:	3301      	adds	r3, #1
  206f0e:	617b      	str	r3, [r7, #20]
  206f10:	697a      	ldr	r2, [r7, #20]
  206f12:	687b      	ldr	r3, [r7, #4]
  206f14:	429a      	cmp	r2, r3
  206f16:	dbe7      	blt.n	206ee8 <LCD_SetCircleDegreesBuff+0x10>
  206f18:	e000      	b.n	206f1c <LCD_SetCircleDegreesBuff+0x44>
		if(i==MAX_DEGREE_CIRCLE) break;
  206f1a:	bf00      	nop
	}
	Circle.degree[0]=i;
  206f1c:	697b      	ldr	r3, [r7, #20]
  206f1e:	b29a      	uxth	r2, r3
  206f20:	4b7f      	ldr	r3, [pc, #508]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206f22:	f8a3 220c 	strh.w	r2, [r3, #524]	; 0x20c

	for(i=0;i<len;i++)
  206f26:	2300      	movs	r3, #0
  206f28:	617b      	str	r3, [r7, #20]
  206f2a:	e0c8      	b.n	2070be <LCD_SetCircleDegreesBuff+0x1e6>
	{
		deg=Circle.degree[1+i];
  206f2c:	697b      	ldr	r3, [r7, #20]
  206f2e:	3301      	adds	r3, #1
  206f30:	4a7b      	ldr	r2, [pc, #492]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206f32:	f503 7382 	add.w	r3, r3, #260	; 0x104
  206f36:	005b      	lsls	r3, r3, #1
  206f38:	4413      	add	r3, r2
  206f3a:	889b      	ldrh	r3, [r3, #4]
  206f3c:	60fb      	str	r3, [r7, #12]
		Circle.tang[i]= tan(TANG_ARG(deg));
  206f3e:	68fb      	ldr	r3, [r7, #12]
  206f40:	ee07 3a90 	vmov	s15, r3
  206f44:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  206f48:	ed9f 6b73 	vldr	d6, [pc, #460]	; 207118 <LCD_SetCircleDegreesBuff+0x240>
  206f4c:	ee27 7b06 	vmul.f64	d7, d7, d6
  206f50:	eeb0 0b47 	vmov.f64	d0, d7
  206f54:	f01f fb74 	bl	226640 <tan>
  206f58:	eeb0 7b40 	vmov.f64	d7, d0
  206f5c:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  206f60:	4a6f      	ldr	r2, [pc, #444]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206f62:	697b      	ldr	r3, [r7, #20]
  206f64:	3392      	adds	r3, #146	; 0x92
  206f66:	009b      	lsls	r3, r3, #2
  206f68:	4413      	add	r3, r2
  206f6a:	3304      	adds	r3, #4
  206f6c:	edc3 7a00 	vstr	s15, [r3]
		Circle.coeff[i] = 1/ABS(Circle.tang[i]);
  206f70:	4a6b      	ldr	r2, [pc, #428]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206f72:	697b      	ldr	r3, [r7, #20]
  206f74:	3392      	adds	r3, #146	; 0x92
  206f76:	009b      	lsls	r3, r3, #2
  206f78:	4413      	add	r3, r2
  206f7a:	3304      	adds	r3, #4
  206f7c:	edd3 7a00 	vldr	s15, [r3]
  206f80:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  206f84:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  206f88:	dd0c      	ble.n	206fa4 <LCD_SetCircleDegreesBuff+0xcc>
  206f8a:	4a65      	ldr	r2, [pc, #404]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206f8c:	697b      	ldr	r3, [r7, #20]
  206f8e:	3392      	adds	r3, #146	; 0x92
  206f90:	009b      	lsls	r3, r3, #2
  206f92:	4413      	add	r3, r2
  206f94:	3304      	adds	r3, #4
  206f96:	ed93 7a00 	vldr	s14, [r3]
  206f9a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  206f9e:	eec6 7a87 	vdiv.f32	s15, s13, s14
  206fa2:	e00d      	b.n	206fc0 <LCD_SetCircleDegreesBuff+0xe8>
  206fa4:	4a5e      	ldr	r2, [pc, #376]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206fa6:	697b      	ldr	r3, [r7, #20]
  206fa8:	3392      	adds	r3, #146	; 0x92
  206faa:	009b      	lsls	r3, r3, #2
  206fac:	4413      	add	r3, r2
  206fae:	3304      	adds	r3, #4
  206fb0:	edd3 7a00 	vldr	s15, [r3]
  206fb4:	eeb1 7a67 	vneg.f32	s14, s15
  206fb8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
  206fbc:	eec6 7a87 	vdiv.f32	s15, s13, s14
  206fc0:	4a57      	ldr	r2, [pc, #348]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206fc2:	697b      	ldr	r3, [r7, #20]
  206fc4:	339c      	adds	r3, #156	; 0x9c
  206fc6:	009b      	lsls	r3, r3, #2
  206fc8:	4413      	add	r3, r2
  206fca:	3304      	adds	r3, #4
  206fcc:	edc3 7a00 	vstr	s15, [r3]

		if(deg>0 && deg<=45)
  206fd0:	68fb      	ldr	r3, [r7, #12]
  206fd2:	2b00      	cmp	r3, #0
  206fd4:	dd0a      	ble.n	206fec <LCD_SetCircleDegreesBuff+0x114>
  206fd6:	68fb      	ldr	r3, [r7, #12]
  206fd8:	2b2d      	cmp	r3, #45	; 0x2d
  206fda:	dc07      	bgt.n	206fec <LCD_SetCircleDegreesBuff+0x114>
			Circle.rot[i]=1;
  206fdc:	4a50      	ldr	r2, [pc, #320]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206fde:	697b      	ldr	r3, [r7, #20]
  206fe0:	4413      	add	r3, r2
  206fe2:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  206fe6:	2201      	movs	r2, #1
  206fe8:	701a      	strb	r2, [r3, #0]
  206fea:	e065      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>45 && deg<=90)
  206fec:	68fb      	ldr	r3, [r7, #12]
  206fee:	2b2d      	cmp	r3, #45	; 0x2d
  206ff0:	dd0a      	ble.n	207008 <LCD_SetCircleDegreesBuff+0x130>
  206ff2:	68fb      	ldr	r3, [r7, #12]
  206ff4:	2b5a      	cmp	r3, #90	; 0x5a
  206ff6:	dc07      	bgt.n	207008 <LCD_SetCircleDegreesBuff+0x130>
			Circle.rot[i]=2;
  206ff8:	4a49      	ldr	r2, [pc, #292]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  206ffa:	697b      	ldr	r3, [r7, #20]
  206ffc:	4413      	add	r3, r2
  206ffe:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  207002:	2202      	movs	r2, #2
  207004:	701a      	strb	r2, [r3, #0]
  207006:	e057      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>90 && deg<=135)
  207008:	68fb      	ldr	r3, [r7, #12]
  20700a:	2b5a      	cmp	r3, #90	; 0x5a
  20700c:	dd0a      	ble.n	207024 <LCD_SetCircleDegreesBuff+0x14c>
  20700e:	68fb      	ldr	r3, [r7, #12]
  207010:	2b87      	cmp	r3, #135	; 0x87
  207012:	dc07      	bgt.n	207024 <LCD_SetCircleDegreesBuff+0x14c>
			Circle.rot[i]=3;
  207014:	4a42      	ldr	r2, [pc, #264]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  207016:	697b      	ldr	r3, [r7, #20]
  207018:	4413      	add	r3, r2
  20701a:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  20701e:	2203      	movs	r2, #3
  207020:	701a      	strb	r2, [r3, #0]
  207022:	e049      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>135 && deg<=180)
  207024:	68fb      	ldr	r3, [r7, #12]
  207026:	2b87      	cmp	r3, #135	; 0x87
  207028:	dd0a      	ble.n	207040 <LCD_SetCircleDegreesBuff+0x168>
  20702a:	68fb      	ldr	r3, [r7, #12]
  20702c:	2bb4      	cmp	r3, #180	; 0xb4
  20702e:	dc07      	bgt.n	207040 <LCD_SetCircleDegreesBuff+0x168>
			Circle.rot[i]=4;
  207030:	4a3b      	ldr	r2, [pc, #236]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  207032:	697b      	ldr	r3, [r7, #20]
  207034:	4413      	add	r3, r2
  207036:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  20703a:	2204      	movs	r2, #4
  20703c:	701a      	strb	r2, [r3, #0]
  20703e:	e03b      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>180 && deg<=225)
  207040:	68fb      	ldr	r3, [r7, #12]
  207042:	2bb4      	cmp	r3, #180	; 0xb4
  207044:	dd0a      	ble.n	20705c <LCD_SetCircleDegreesBuff+0x184>
  207046:	68fb      	ldr	r3, [r7, #12]
  207048:	2be1      	cmp	r3, #225	; 0xe1
  20704a:	dc07      	bgt.n	20705c <LCD_SetCircleDegreesBuff+0x184>
			Circle.rot[i]=5;
  20704c:	4a34      	ldr	r2, [pc, #208]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  20704e:	697b      	ldr	r3, [r7, #20]
  207050:	4413      	add	r3, r2
  207052:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  207056:	2205      	movs	r2, #5
  207058:	701a      	strb	r2, [r3, #0]
  20705a:	e02d      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>225 && deg<=270)
  20705c:	68fb      	ldr	r3, [r7, #12]
  20705e:	2be1      	cmp	r3, #225	; 0xe1
  207060:	dd0b      	ble.n	20707a <LCD_SetCircleDegreesBuff+0x1a2>
  207062:	68fb      	ldr	r3, [r7, #12]
  207064:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  207068:	dc07      	bgt.n	20707a <LCD_SetCircleDegreesBuff+0x1a2>
			Circle.rot[i]=6;
  20706a:	4a2d      	ldr	r2, [pc, #180]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  20706c:	697b      	ldr	r3, [r7, #20]
  20706e:	4413      	add	r3, r2
  207070:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  207074:	2206      	movs	r2, #6
  207076:	701a      	strb	r2, [r3, #0]
  207078:	e01e      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>270 && deg<=315)
  20707a:	68fb      	ldr	r3, [r7, #12]
  20707c:	f5b3 7f87 	cmp.w	r3, #270	; 0x10e
  207080:	dd0b      	ble.n	20709a <LCD_SetCircleDegreesBuff+0x1c2>
  207082:	68fb      	ldr	r3, [r7, #12]
  207084:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  207088:	da07      	bge.n	20709a <LCD_SetCircleDegreesBuff+0x1c2>
			Circle.rot[i]=7;
  20708a:	4a25      	ldr	r2, [pc, #148]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  20708c:	697b      	ldr	r3, [r7, #20]
  20708e:	4413      	add	r3, r2
  207090:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  207094:	2207      	movs	r2, #7
  207096:	701a      	strb	r2, [r3, #0]
  207098:	e00e      	b.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
		else if(deg>315 && deg<=360)
  20709a:	68fb      	ldr	r3, [r7, #12]
  20709c:	f5b3 7f9e 	cmp.w	r3, #316	; 0x13c
  2070a0:	db0a      	blt.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
  2070a2:	68fb      	ldr	r3, [r7, #12]
  2070a4:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  2070a8:	dc06      	bgt.n	2070b8 <LCD_SetCircleDegreesBuff+0x1e0>
			Circle.rot[i]=8;
  2070aa:	4a1d      	ldr	r2, [pc, #116]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  2070ac:	697b      	ldr	r3, [r7, #20]
  2070ae:	4413      	add	r3, r2
  2070b0:	f503 7327 	add.w	r3, r3, #668	; 0x29c
  2070b4:	2208      	movs	r2, #8
  2070b6:	701a      	strb	r2, [r3, #0]
	for(i=0;i<len;i++)
  2070b8:	697b      	ldr	r3, [r7, #20]
  2070ba:	3301      	adds	r3, #1
  2070bc:	617b      	str	r3, [r7, #20]
  2070be:	697a      	ldr	r2, [r7, #20]
  2070c0:	687b      	ldr	r3, [r7, #4]
  2070c2:	429a      	cmp	r2, r3
  2070c4:	f6ff af32 	blt.w	206f2c <LCD_SetCircleDegreesBuff+0x54>
	}

	for(int i=0;i<Circle.degree[0];++i){
  2070c8:	2300      	movs	r3, #0
  2070ca:	613b      	str	r3, [r7, #16]
  2070cc:	e016      	b.n	2070fc <LCD_SetCircleDegreesBuff+0x224>
		if(Circle.degree[1+i]==0)
  2070ce:	693b      	ldr	r3, [r7, #16]
  2070d0:	3301      	adds	r3, #1
  2070d2:	4a13      	ldr	r2, [pc, #76]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  2070d4:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2070d8:	005b      	lsls	r3, r3, #1
  2070da:	4413      	add	r3, r2
  2070dc:	889b      	ldrh	r3, [r3, #4]
  2070de:	2b00      	cmp	r3, #0
  2070e0:	d109      	bne.n	2070f6 <LCD_SetCircleDegreesBuff+0x21e>
			Circle.degree[1+i]=360;
  2070e2:	693b      	ldr	r3, [r7, #16]
  2070e4:	3301      	adds	r3, #1
  2070e6:	4a0e      	ldr	r2, [pc, #56]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  2070e8:	f503 7382 	add.w	r3, r3, #260	; 0x104
  2070ec:	005b      	lsls	r3, r3, #1
  2070ee:	4413      	add	r3, r2
  2070f0:	f44f 72b4 	mov.w	r2, #360	; 0x168
  2070f4:	809a      	strh	r2, [r3, #4]
	for(int i=0;i<Circle.degree[0];++i){
  2070f6:	693b      	ldr	r3, [r7, #16]
  2070f8:	3301      	adds	r3, #1
  2070fa:	613b      	str	r3, [r7, #16]
  2070fc:	4b08      	ldr	r3, [pc, #32]	; (207120 <LCD_SetCircleDegreesBuff+0x248>)
  2070fe:	f8b3 320c 	ldrh.w	r3, [r3, #524]	; 0x20c
  207102:	461a      	mov	r2, r3
  207104:	693b      	ldr	r3, [r7, #16]
  207106:	429a      	cmp	r2, r3
  207108:	dce1      	bgt.n	2070ce <LCD_SetCircleDegreesBuff+0x1f6>
	}
}
  20710a:	bf00      	nop
  20710c:	3718      	adds	r7, #24
  20710e:	46bd      	mov	sp, r7
  207110:	bd80      	pop	{r7, pc}
  207112:	bf00      	nop
  207114:	f3af 8000 	nop.w
  207118:	6cd799af 	.word	0x6cd799af
  20711c:	3f91df40 	.word	0x3f91df40
  207120:	2000205c 	.word	0x2000205c

00207124 <LCD_SetCircleDegColorsBuff>:
		if(i==MAX_DEGREE_CIRCLE) break;
		Circle.degColor[i]=va_arg(va,int);
	}
	va_end(va);
}
void LCD_SetCircleDegColorsBuff(int len, uint32_t *buf){
  207124:	b480      	push	{r7}
  207126:	b085      	sub	sp, #20
  207128:	af00      	add	r7, sp, #0
  20712a:	6078      	str	r0, [r7, #4]
  20712c:	6039      	str	r1, [r7, #0]
	int i;
	for(i=0;i<len;i++){
  20712e:	2300      	movs	r3, #0
  207130:	60fb      	str	r3, [r7, #12]
  207132:	e010      	b.n	207156 <LCD_SetCircleDegColorsBuff+0x32>
		if(i==MAX_DEGREE_CIRCLE) break;
  207134:	68fb      	ldr	r3, [r7, #12]
  207136:	2b0a      	cmp	r3, #10
  207138:	d012      	beq.n	207160 <LCD_SetCircleDegColorsBuff+0x3c>
		Circle.degColor[i]=buf[i];
  20713a:	68fb      	ldr	r3, [r7, #12]
  20713c:	009b      	lsls	r3, r3, #2
  20713e:	683a      	ldr	r2, [r7, #0]
  207140:	4413      	add	r3, r2
  207142:	681a      	ldr	r2, [r3, #0]
  207144:	490a      	ldr	r1, [pc, #40]	; (207170 <LCD_SetCircleDegColorsBuff+0x4c>)
  207146:	68fb      	ldr	r3, [r7, #12]
  207148:	3388      	adds	r3, #136	; 0x88
  20714a:	009b      	lsls	r3, r3, #2
  20714c:	440b      	add	r3, r1
  20714e:	605a      	str	r2, [r3, #4]
	for(i=0;i<len;i++){
  207150:	68fb      	ldr	r3, [r7, #12]
  207152:	3301      	adds	r3, #1
  207154:	60fb      	str	r3, [r7, #12]
  207156:	68fa      	ldr	r2, [r7, #12]
  207158:	687b      	ldr	r3, [r7, #4]
  20715a:	429a      	cmp	r2, r3
  20715c:	dbea      	blt.n	207134 <LCD_SetCircleDegColorsBuff+0x10>
	}
}
  20715e:	e000      	b.n	207162 <LCD_SetCircleDegColorsBuff+0x3e>
		if(i==MAX_DEGREE_CIRCLE) break;
  207160:	bf00      	nop
}
  207162:	bf00      	nop
  207164:	3714      	adds	r7, #20
  207166:	46bd      	mov	sp, r7
  207168:	f85d 7b04 	ldr.w	r7, [sp], #4
  20716c:	4770      	bx	lr
  20716e:	bf00      	nop
  207170:	2000205c 	.word	0x2000205c

00207174 <LCD_SetCirclePercentParam>:
void LCD_SetCirclePercentParam(int len, uint16_t *degBuff, uint32_t *degColorBuff){
  207174:	b580      	push	{r7, lr}
  207176:	b084      	sub	sp, #16
  207178:	af00      	add	r7, sp, #0
  20717a:	60f8      	str	r0, [r7, #12]
  20717c:	60b9      	str	r1, [r7, #8]
  20717e:	607a      	str	r2, [r7, #4]
	LCD_SetCircleDegreesBuff(len,degBuff);
  207180:	68b9      	ldr	r1, [r7, #8]
  207182:	68f8      	ldr	r0, [r7, #12]
  207184:	f7ff fea8 	bl	206ed8 <LCD_SetCircleDegreesBuff>
	LCD_SetCircleDegColorsBuff(len,degColorBuff);
  207188:	6879      	ldr	r1, [r7, #4]
  20718a:	68f8      	ldr	r0, [r7, #12]
  20718c:	f7ff ffca 	bl	207124 <LCD_SetCircleDegColorsBuff>
}
  207190:	bf00      	nop
  207192:	3710      	adds	r7, #16
  207194:	46bd      	mov	sp, r7
  207196:	bd80      	pop	{r7, pc}

00207198 <LCD_SetCircleAA>:
	Circle.lineBuff[lineNr]=val;
}
void LCD_OffsCircleLine(uint8_t lineNr, int offs){
	Circle.lineBuff[lineNr]+=offs;
}
void LCD_SetCircleAA(float outRatio, float inRetio){
  207198:	b480      	push	{r7}
  20719a:	b083      	sub	sp, #12
  20719c:	af00      	add	r7, sp, #0
  20719e:	ed87 0a01 	vstr	s0, [r7, #4]
  2071a2:	edc7 0a00 	vstr	s1, [r7]
	Circle.outRatioStart=outRatio;
  2071a6:	4a07      	ldr	r2, [pc, #28]	; (2071c4 <LCD_SetCircleAA+0x2c>)
  2071a8:	687b      	ldr	r3, [r7, #4]
  2071aa:	f8c2 31f4 	str.w	r3, [r2, #500]	; 0x1f4
	Circle.inRatioStart=inRetio;
  2071ae:	4a05      	ldr	r2, [pc, #20]	; (2071c4 <LCD_SetCircleAA+0x2c>)
  2071b0:	683b      	ldr	r3, [r7, #0]
  2071b2:	f8c2 31f8 	str.w	r3, [r2, #504]	; 0x1f8
}
  2071b6:	bf00      	nop
  2071b8:	370c      	adds	r7, #12
  2071ba:	46bd      	mov	sp, r7
  2071bc:	f85d 7b04 	ldr.w	r7, [sp], #4
  2071c0:	4770      	bx	lr
  2071c2:	bf00      	nop
  2071c4:	2000205c 	.word	0x2000205c

002071c8 <LCD_CopyCircleWidth>:
}

uint16_t LCD_GetCircleWidth(void){
	return Circle.width;
}
void LCD_CopyCircleWidth(void){
  2071c8:	b480      	push	{r7}
  2071ca:	af00      	add	r7, sp, #0
	Circle.width_prev=Circle.width;
  2071cc:	4b05      	ldr	r3, [pc, #20]	; (2071e4 <LCD_CopyCircleWidth+0x1c>)
  2071ce:	f8b3 2204 	ldrh.w	r2, [r3, #516]	; 0x204
  2071d2:	4b04      	ldr	r3, [pc, #16]	; (2071e4 <LCD_CopyCircleWidth+0x1c>)
  2071d4:	f8a3 2206 	strh.w	r2, [r3, #518]	; 0x206
}
  2071d8:	bf00      	nop
  2071da:	46bd      	mov	sp, r7
  2071dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  2071e0:	4770      	bx	lr
  2071e2:	bf00      	nop
  2071e4:	2000205c 	.word	0x2000205c

002071e8 <LCD_SetCopyCircleWidth>:
void LCD_SetCopyCircleWidth(void){
  2071e8:	b480      	push	{r7}
  2071ea:	af00      	add	r7, sp, #0
	Circle.width=Circle.width_prev;
  2071ec:	4b05      	ldr	r3, [pc, #20]	; (207204 <LCD_SetCopyCircleWidth+0x1c>)
  2071ee:	f8b3 2206 	ldrh.w	r2, [r3, #518]	; 0x206
  2071f2:	4b04      	ldr	r3, [pc, #16]	; (207204 <LCD_SetCopyCircleWidth+0x1c>)
  2071f4:	f8a3 2204 	strh.w	r2, [r3, #516]	; 0x204
}
  2071f8:	bf00      	nop
  2071fa:	46bd      	mov	sp, r7
  2071fc:	f85d 7b04 	ldr.w	r7, [sp], #4
  207200:	4770      	bx	lr
  207202:	bf00      	nop
  207204:	2000205c 	.word	0x2000205c

00207208 <LCD_CalculateCircleWidth>:

uint16_t LCD_CalculateCircleWidth(uint32_t width)
{
  207208:	b580      	push	{r7, lr}
  20720a:	b096      	sub	sp, #88	; 0x58
  20720c:	af00      	add	r7, sp, #0
  20720e:	6078      	str	r0, [r7, #4]
	#define buf			Circle.lineBuff

	uint32_t x=0, y=0;
  207210:	2300      	movs	r3, #0
  207212:	657b      	str	r3, [r7, #84]	; 0x54
  207214:	2300      	movs	r3, #0
  207216:	633b      	str	r3, [r7, #48]	; 0x30
	int matchWidth=0;
  207218:	2300      	movs	r3, #0
  20721a:	653b      	str	r3, [r7, #80]	; 0x50
	uint32_t _width=(width&0x0000FFFF)-matchWidth;
  20721c:	687b      	ldr	r3, [r7, #4]
  20721e:	b29a      	uxth	r2, r3
  207220:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207222:	1ad3      	subs	r3, r2, r3
  207224:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint32_t height=_width;
  207226:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207228:	62bb      	str	r3, [r7, #40]	; 0x28

	GOTO_ToCalculateRadius:
	  _width=(width&0x0000FFFF)-matchWidth;
  20722a:	687b      	ldr	r3, [r7, #4]
  20722c:	b29a      	uxth	r2, r3
  20722e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207230:	1ad3      	subs	r3, r2, r3
  207232:	62fb      	str	r3, [r7, #44]	; 0x2c

	uint32_t R=_width/2, err=0.5;
  207234:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207236:	085b      	lsrs	r3, r3, #1
  207238:	627b      	str	r3, [r7, #36]	; 0x24
  20723a:	2300      	movs	r3, #0
  20723c:	623b      	str	r3, [r7, #32]
	uint32_t pxl_width = R/3;
  20723e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207240:	4a83      	ldr	r2, [pc, #524]	; (207450 <LCD_CalculateCircleWidth+0x248>)
  207242:	fba2 2303 	umull	r2, r3, r2, r3
  207246:	085b      	lsrs	r3, r3, #1
  207248:	61fb      	str	r3, [r7, #28]

	x=_width/2 + matchWidth/2;
  20724a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20724c:	085a      	lsrs	r2, r3, #1
  20724e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207250:	2b00      	cmp	r3, #0
  207252:	da00      	bge.n	207256 <LCD_CalculateCircleWidth+0x4e>
  207254:	3301      	adds	r3, #1
  207256:	105b      	asrs	r3, r3, #1
  207258:	4413      	add	r3, r2
  20725a:	657b      	str	r3, [r7, #84]	; 0x54
	if(_width%2) x++;
  20725c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20725e:	f003 0301 	and.w	r3, r3, #1
  207262:	2b00      	cmp	r3, #0
  207264:	d002      	beq.n	20726c <LCD_CalculateCircleWidth+0x64>
  207266:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  207268:	3301      	adds	r3, #1
  20726a:	657b      	str	r3, [r7, #84]	; 0x54
	y=0;
  20726c:	2300      	movs	r3, #0
  20726e:	633b      	str	r3, [r7, #48]	; 0x30

	float _x=(float)x, _y=(float)y;
  207270:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  207272:	ee07 3a90 	vmov	s15, r3
  207276:	eef8 7a67 	vcvt.f32.u32	s15, s15
  20727a:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
  20727e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  207280:	ee07 3a90 	vmov	s15, r3
  207284:	eef8 7a67 	vcvt.f32.u32	s15, s15
  207288:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
	float x0=(float)x, y0=(float)y+R;
  20728c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20728e:	ee07 3a90 	vmov	s15, r3
  207292:	eef8 7a67 	vcvt.f32.u32	s15, s15
  207296:	edc7 7a06 	vstr	s15, [r7, #24]
  20729a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20729c:	ee07 3a90 	vmov	s15, r3
  2072a0:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  2072a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2072a6:	ee07 3a90 	vmov	s15, r3
  2072aa:	eef8 7a67 	vcvt.f32.u32	s15, s15
  2072ae:	ee77 7a27 	vadd.f32	s15, s14, s15
  2072b2:	edc7 7a05 	vstr	s15, [r7, #20]

	float param_y = pow(y0-_y,2);
  2072b6:	ed97 7a05 	vldr	s14, [r7, #20]
  2072ba:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
  2072be:	ee77 7a67 	vsub.f32	s15, s14, s15
  2072c2:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2072c6:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  2072ca:	eeb0 0b47 	vmov.f64	d0, d7
  2072ce:	f01f f9eb 	bl	2266a8 <pow>
  2072d2:	eeb0 7b40 	vmov.f64	d7, d0
  2072d6:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2072da:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
	float param_x = pow(_x-x0,2);
  2072de:	ed97 7a13 	vldr	s14, [r7, #76]	; 0x4c
  2072e2:	edd7 7a06 	vldr	s15, [r7, #24]
  2072e6:	ee77 7a67 	vsub.f32	s15, s14, s15
  2072ea:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2072ee:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  2072f2:	eeb0 0b47 	vmov.f64	d0, d7
  2072f6:	f01f f9d7 	bl	2266a8 <pow>
  2072fa:	eeb0 7b40 	vmov.f64	d7, d0
  2072fe:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  207302:	edc7 7a04 	vstr	s15, [r7, #16]
	float decision = pow(R+err,2);
  207306:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  207308:	6a3b      	ldr	r3, [r7, #32]
  20730a:	4413      	add	r3, r2
  20730c:	ee07 3a90 	vmov	s15, r3
  207310:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  207314:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  207318:	eeb0 0b47 	vmov.f64	d0, d7
  20731c:	f01f f9c4 	bl	2266a8 <pow>
  207320:	eeb0 7b40 	vmov.f64	d7, d0
  207324:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  207328:	edc7 7a03 	vstr	s15, [r7, #12]

	int pxl_line=0,i=0;
  20732c:	2300      	movs	r3, #0
  20732e:	643b      	str	r3, [r7, #64]	; 0x40
  207330:	2300      	movs	r3, #0
  207332:	63fb      	str	r3, [r7, #60]	; 0x3c

	buf[0]=pxl_width;
  207334:	69fb      	ldr	r3, [r7, #28]
  207336:	b2da      	uxtb	r2, r3
  207338:	4b46      	ldr	r3, [pc, #280]	; (207454 <LCD_CalculateCircleWidth+0x24c>)
  20733a:	701a      	strb	r2, [r3, #0]
	do{
		_x++;  pxl_line++;
  20733c:	edd7 7a13 	vldr	s15, [r7, #76]	; 0x4c
  207340:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  207344:	ee77 7a87 	vadd.f32	s15, s15, s14
  207348:	edc7 7a13 	vstr	s15, [r7, #76]	; 0x4c
  20734c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20734e:	3301      	adds	r3, #1
  207350:	643b      	str	r3, [r7, #64]	; 0x40
		param_x = pow(_x-x0,2);
  207352:	ed97 7a13 	vldr	s14, [r7, #76]	; 0x4c
  207356:	edd7 7a06 	vldr	s15, [r7, #24]
  20735a:	ee77 7a67 	vsub.f32	s15, s14, s15
  20735e:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  207362:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  207366:	eeb0 0b47 	vmov.f64	d0, d7
  20736a:	f01f f99d 	bl	2266a8 <pow>
  20736e:	eeb0 7b40 	vmov.f64	d7, d0
  207372:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  207376:	edc7 7a04 	vstr	s15, [r7, #16]
		if((param_x+param_y) > decision){
  20737a:	ed97 7a04 	vldr	s14, [r7, #16]
  20737e:	edd7 7a11 	vldr	s15, [r7, #68]	; 0x44
  207382:	ee37 7a27 	vadd.f32	s14, s14, s15
  207386:	edd7 7a03 	vldr	s15, [r7, #12]
  20738a:	eeb4 7ae7 	vcmpe.f32	s14, s15
  20738e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  207392:	dd27      	ble.n	2073e4 <LCD_CalculateCircleWidth+0x1dc>
			_y++;
  207394:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
  207398:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  20739c:	ee77 7a87 	vadd.f32	s15, s15, s14
  2073a0:	edc7 7a12 	vstr	s15, [r7, #72]	; 0x48
			param_y = pow(y0-_y,2);
  2073a4:	ed97 7a05 	vldr	s14, [r7, #20]
  2073a8:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
  2073ac:	ee77 7a67 	vsub.f32	s15, s14, s15
  2073b0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2073b4:	eeb0 1b00 	vmov.f64	d1, #0	; 0x40000000  2.0
  2073b8:	eeb0 0b47 	vmov.f64	d0, d7
  2073bc:	f01f f974 	bl	2266a8 <pow>
  2073c0:	eeb0 7b40 	vmov.f64	d7, d0
  2073c4:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2073c8:	edc7 7a11 	vstr	s15, [r7, #68]	; 0x44
			buf[1+i++]=pxl_line-1;
  2073cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2073ce:	1c5a      	adds	r2, r3, #1
  2073d0:	63fa      	str	r2, [r7, #60]	; 0x3c
  2073d2:	3301      	adds	r3, #1
  2073d4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  2073d6:	b2d2      	uxtb	r2, r2
  2073d8:	3a01      	subs	r2, #1
  2073da:	b2d1      	uxtb	r1, r2
  2073dc:	4a1d      	ldr	r2, [pc, #116]	; (207454 <LCD_CalculateCircleWidth+0x24c>)
  2073de:	54d1      	strb	r1, [r2, r3]
			pxl_line=1;
  2073e0:	2301      	movs	r3, #1
  2073e2:	643b      	str	r3, [r7, #64]	; 0x40
		}
	}while(i<pxl_width);
  2073e4:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  2073e6:	69fb      	ldr	r3, [r7, #28]
  2073e8:	429a      	cmp	r2, r3
  2073ea:	d3a7      	bcc.n	20733c <LCD_CalculateCircleWidth+0x134>

   uint16_t _height=buf[0];
  2073ec:	4b19      	ldr	r3, [pc, #100]	; (207454 <LCD_CalculateCircleWidth+0x24c>)
  2073ee:	781b      	ldrb	r3, [r3, #0]
  2073f0:	877b      	strh	r3, [r7, #58]	; 0x3a
  	for(int i=0;i<buf[0];++i) _height+=buf[buf[0]-i];
  2073f2:	2300      	movs	r3, #0
  2073f4:	637b      	str	r3, [r7, #52]	; 0x34
  2073f6:	e00d      	b.n	207414 <LCD_CalculateCircleWidth+0x20c>
  2073f8:	4b16      	ldr	r3, [pc, #88]	; (207454 <LCD_CalculateCircleWidth+0x24c>)
  2073fa:	781b      	ldrb	r3, [r3, #0]
  2073fc:	461a      	mov	r2, r3
  2073fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  207400:	1ad3      	subs	r3, r2, r3
  207402:	4a14      	ldr	r2, [pc, #80]	; (207454 <LCD_CalculateCircleWidth+0x24c>)
  207404:	5cd3      	ldrb	r3, [r2, r3]
  207406:	b29a      	uxth	r2, r3
  207408:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
  20740a:	4413      	add	r3, r2
  20740c:	877b      	strh	r3, [r7, #58]	; 0x3a
  20740e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  207410:	3301      	adds	r3, #1
  207412:	637b      	str	r3, [r7, #52]	; 0x34
  207414:	4b0f      	ldr	r3, [pc, #60]	; (207454 <LCD_CalculateCircleWidth+0x24c>)
  207416:	781b      	ldrb	r3, [r3, #0]
  207418:	461a      	mov	r2, r3
  20741a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20741c:	429a      	cmp	r2, r3
  20741e:	dceb      	bgt.n	2073f8 <LCD_CalculateCircleWidth+0x1f0>
  	_height = 2*_height;
  207420:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
  207422:	005b      	lsls	r3, r3, #1
  207424:	877b      	strh	r3, [r7, #58]	; 0x3a

	if(height>=_height)
  207426:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
  207428:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20742a:	429a      	cmp	r2, r3
  20742c:	d807      	bhi.n	20743e <LCD_CalculateCircleWidth+0x236>
		y= y+(height-_height)/2;
  20742e:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
  207430:	6aba      	ldr	r2, [r7, #40]	; 0x28
  207432:	1ad3      	subs	r3, r2, r3
  207434:	085b      	lsrs	r3, r3, #1
  207436:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  207438:	4413      	add	r3, r2
  20743a:	633b      	str	r3, [r7, #48]	; 0x30
  20743c:	e003      	b.n	207446 <LCD_CalculateCircleWidth+0x23e>
	else{
		matchWidth+=1;
  20743e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207440:	3301      	adds	r3, #1
  207442:	653b      	str	r3, [r7, #80]	; 0x50
		goto GOTO_ToCalculateRadius;
  207444:	e6f1      	b.n	20722a <LCD_CalculateCircleWidth+0x22>
	}
	return _height;
  207446:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
}
  207448:	4618      	mov	r0, r3
  20744a:	3758      	adds	r7, #88	; 0x58
  20744c:	46bd      	mov	sp, r7
  20744e:	bd80      	pop	{r7, pc}
  207450:	aaaaaaab 	.word	0xaaaaaaab
  207454:	2000205c 	.word	0x2000205c

00207458 <LCD_Circle>:
//MOZLIWOSC rysowania polkul np dla zakonczen ramek !!!!!!!
void LCD_Circle(uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x, uint32_t y, uint32_t _width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor){
  207458:	b590      	push	{r4, r7, lr}
  20745a:	b091      	sub	sp, #68	; 0x44
  20745c:	af06      	add	r7, sp, #24
  20745e:	60f8      	str	r0, [r7, #12]
  207460:	60b9      	str	r1, [r7, #8]
  207462:	607a      	str	r2, [r7, #4]
  207464:	603b      	str	r3, [r7, #0]
	uint32_t width = _width&0xFFFF;
  207466:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207468:	b29b      	uxth	r3, r3
  20746a:	623b      	str	r3, [r7, #32]
	uint16_t param = _width>>16;
  20746c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20746e:	0c1b      	lsrs	r3, r3, #16
  207470:	83fb      	strh	r3, [r7, #30]
	uint8_t thickness = FrameColor>>24;
  207472:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  207474:	0e1b      	lsrs	r3, r3, #24
  207476:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	if((thickness==0)||(thickness==255))
  20747a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  20747e:	2b00      	cmp	r3, #0
  207480:	d003      	beq.n	20748a <LCD_Circle+0x32>
  207482:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  207486:	2bff      	cmp	r3, #255	; 0xff
  207488:	d103      	bne.n	207492 <LCD_Circle+0x3a>
		thickness=0;
  20748a:	2300      	movs	r3, #0
  20748c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  207490:	e006      	b.n	2074a0 <LCD_Circle+0x48>
	else
		thickness=3*thickness;
  207492:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  207496:	461a      	mov	r2, r3
  207498:	0052      	lsls	r2, r2, #1
  20749a:	4413      	add	r3, r2
  20749c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	if((param==Percent_Circle)||(param==Degree_Circle))   //Degree_Circle usunac
  2074a0:	8bfb      	ldrh	r3, [r7, #30]
  2074a2:	2b04      	cmp	r3, #4
  2074a4:	d002      	beq.n	2074ac <LCD_Circle+0x54>
  2074a6:	8bfb      	ldrh	r3, [r7, #30]
  2074a8:	2b05      	cmp	r3, #5
  2074aa:	d102      	bne.n	2074b2 <LCD_Circle+0x5a>
		thickness=0;
  2074ac:	2300      	movs	r3, #0
  2074ae:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	if(thickness){
  2074b2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  2074b6:	2b00      	cmp	r3, #0
  2074b8:	d042      	beq.n	207540 <LCD_Circle+0xe8>
		LCD_DrawCircle(posBuff,BkpSizeX,BkpSizeY,x,y, width,height, FrameColor, FrameColor, BkpColor);
  2074ba:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2074bc:	9305      	str	r3, [sp, #20]
  2074be:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2074c0:	9304      	str	r3, [sp, #16]
  2074c2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2074c4:	9303      	str	r3, [sp, #12]
  2074c6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2074c8:	9302      	str	r3, [sp, #8]
  2074ca:	6a3b      	ldr	r3, [r7, #32]
  2074cc:	9301      	str	r3, [sp, #4]
  2074ce:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2074d0:	9300      	str	r3, [sp, #0]
  2074d2:	683b      	ldr	r3, [r7, #0]
  2074d4:	687a      	ldr	r2, [r7, #4]
  2074d6:	68b9      	ldr	r1, [r7, #8]
  2074d8:	68f8      	ldr	r0, [r7, #12]
  2074da:	f7fc fa1f 	bl	20391c <LCD_DrawCircle>
		LCD_CopyCircleWidth();
  2074de:	f7ff fe73 	bl	2071c8 <LCD_CopyCircleWidth>

   	uint32_t width_new = width-2*thickness;
  2074e2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  2074e6:	005b      	lsls	r3, r3, #1
  2074e8:	461a      	mov	r2, r3
  2074ea:	6a3b      	ldr	r3, [r7, #32]
  2074ec:	1a9b      	subs	r3, r3, r2
  2074ee:	61bb      	str	r3, [r7, #24]
		int offs= (Circle.width-LCD_CalculateCircleWidth(width_new))/2;
  2074f0:	4b1e      	ldr	r3, [pc, #120]	; (20756c <LCD_Circle+0x114>)
  2074f2:	f8b3 3204 	ldrh.w	r3, [r3, #516]	; 0x204
  2074f6:	461c      	mov	r4, r3
  2074f8:	69b8      	ldr	r0, [r7, #24]
  2074fa:	f7ff fe85 	bl	207208 <LCD_CalculateCircleWidth>
  2074fe:	4603      	mov	r3, r0
  207500:	1ae3      	subs	r3, r4, r3
  207502:	2b00      	cmp	r3, #0
  207504:	da00      	bge.n	207508 <LCD_Circle+0xb0>
  207506:	3301      	adds	r3, #1
  207508:	105b      	asrs	r3, r3, #1
  20750a:	617b      	str	r3, [r7, #20]

		LCD_DrawCircle(posBuff,BkpSizeX,BkpSizeY,x+offs,y+offs, width_new,width_new, FrameColor, FillColor, FrameColor);
  20750c:	697a      	ldr	r2, [r7, #20]
  20750e:	683b      	ldr	r3, [r7, #0]
  207510:	18d1      	adds	r1, r2, r3
  207512:	697a      	ldr	r2, [r7, #20]
  207514:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207516:	4413      	add	r3, r2
  207518:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20751a:	9205      	str	r2, [sp, #20]
  20751c:	6cba      	ldr	r2, [r7, #72]	; 0x48
  20751e:	9204      	str	r2, [sp, #16]
  207520:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  207522:	9203      	str	r2, [sp, #12]
  207524:	69ba      	ldr	r2, [r7, #24]
  207526:	9202      	str	r2, [sp, #8]
  207528:	69ba      	ldr	r2, [r7, #24]
  20752a:	9201      	str	r2, [sp, #4]
  20752c:	9300      	str	r3, [sp, #0]
  20752e:	460b      	mov	r3, r1
  207530:	687a      	ldr	r2, [r7, #4]
  207532:	68b9      	ldr	r1, [r7, #8]
  207534:	68f8      	ldr	r0, [r7, #12]
  207536:	f7fc f9f1 	bl	20391c <LCD_DrawCircle>
		LCD_SetCopyCircleWidth();
  20753a:	f7ff fe55 	bl	2071e8 <LCD_SetCopyCircleWidth>
	}
	else LCD_DrawCircle(posBuff,BkpSizeX,BkpSizeY,x,y, _width,height, FrameColor, FillColor, BkpColor);
}
  20753e:	e011      	b.n	207564 <LCD_Circle+0x10c>
	else LCD_DrawCircle(posBuff,BkpSizeX,BkpSizeY,x,y, _width,height, FrameColor, FillColor, BkpColor);
  207540:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  207542:	9305      	str	r3, [sp, #20]
  207544:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  207546:	9304      	str	r3, [sp, #16]
  207548:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20754a:	9303      	str	r3, [sp, #12]
  20754c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20754e:	9302      	str	r3, [sp, #8]
  207550:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207552:	9301      	str	r3, [sp, #4]
  207554:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207556:	9300      	str	r3, [sp, #0]
  207558:	683b      	ldr	r3, [r7, #0]
  20755a:	687a      	ldr	r2, [r7, #4]
  20755c:	68b9      	ldr	r1, [r7, #8]
  20755e:	68f8      	ldr	r0, [r7, #12]
  207560:	f7fc f9dc 	bl	20391c <LCD_DrawCircle>
}
  207564:	bf00      	nop
  207566:	372c      	adds	r7, #44	; 0x2c
  207568:	46bd      	mov	sp, r7
  20756a:	bd90      	pop	{r4, r7, pc}
  20756c:	2000205c 	.word	0x2000205c

00207570 <LCD_AllRefreshScreenClear>:

#define MAX_ELEMENTS_REFRESH_IN_SCREEN	40

portTickType refreshScreenVar[MAX_ELEMENTS_REFRESH_IN_SCREEN];

void LCD_AllRefreshScreenClear(void){
  207570:	b580      	push	{r7, lr}
  207572:	b082      	sub	sp, #8
  207574:	af00      	add	r7, sp, #0
	for(int i=0; i<MAX_ELEMENTS_REFRESH_IN_SCREEN; ++i)
  207576:	2300      	movs	r3, #0
  207578:	607b      	str	r3, [r7, #4]
  20757a:	e009      	b.n	207590 <LCD_AllRefreshScreenClear+0x20>
		refreshScreenVar[i] = xTaskGetTickCount();
  20757c:	f01e f9ee 	bl	22595c <xTaskGetTickCount>
  207580:	4601      	mov	r1, r0
  207582:	4a07      	ldr	r2, [pc, #28]	; (2075a0 <LCD_AllRefreshScreenClear+0x30>)
  207584:	687b      	ldr	r3, [r7, #4]
  207586:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	for(int i=0; i<MAX_ELEMENTS_REFRESH_IN_SCREEN; ++i)
  20758a:	687b      	ldr	r3, [r7, #4]
  20758c:	3301      	adds	r3, #1
  20758e:	607b      	str	r3, [r7, #4]
  207590:	687b      	ldr	r3, [r7, #4]
  207592:	2b27      	cmp	r3, #39	; 0x27
  207594:	ddf2      	ble.n	20757c <LCD_AllRefreshScreenClear+0xc>
}
  207596:	bf00      	nop
  207598:	3708      	adds	r7, #8
  20759a:	46bd      	mov	sp, r7
  20759c:	bd80      	pop	{r7, pc}
  20759e:	bf00      	nop
  2075a0:	200149a4 	.word	0x200149a4

002075a4 <LCD_RefreshScreenClear>:
void LCD_RefreshScreenClear(int nrRefresh){
  2075a4:	b580      	push	{r7, lr}
  2075a6:	b082      	sub	sp, #8
  2075a8:	af00      	add	r7, sp, #0
  2075aa:	6078      	str	r0, [r7, #4]
	refreshScreenVar[nrRefresh] = xTaskGetTickCount();
  2075ac:	f01e f9d6 	bl	22595c <xTaskGetTickCount>
  2075b0:	4601      	mov	r1, r0
  2075b2:	4a04      	ldr	r2, [pc, #16]	; (2075c4 <LCD_RefreshScreenClear+0x20>)
  2075b4:	687b      	ldr	r3, [r7, #4]
  2075b6:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
  2075ba:	bf00      	nop
  2075bc:	3708      	adds	r7, #8
  2075be:	46bd      	mov	sp, r7
  2075c0:	bd80      	pop	{r7, pc}
  2075c2:	bf00      	nop
  2075c4:	200149a4 	.word	0x200149a4

002075c8 <LCD_IsRefreshScreenTimeout>:
int LCD_IsRefreshScreenTimeout(int nrRefresh, int timeout){
  2075c8:	b580      	push	{r7, lr}
  2075ca:	b082      	sub	sp, #8
  2075cc:	af00      	add	r7, sp, #0
  2075ce:	6078      	str	r0, [r7, #4]
  2075d0:	6039      	str	r1, [r7, #0]
	if((xTaskGetTickCount()-refreshScreenVar[nrRefresh])>timeout){
  2075d2:	f01e f9c3 	bl	22595c <xTaskGetTickCount>
  2075d6:	4601      	mov	r1, r0
  2075d8:	4a08      	ldr	r2, [pc, #32]	; (2075fc <LCD_IsRefreshScreenTimeout+0x34>)
  2075da:	687b      	ldr	r3, [r7, #4]
  2075dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  2075e0:	1aca      	subs	r2, r1, r3
  2075e2:	683b      	ldr	r3, [r7, #0]
  2075e4:	429a      	cmp	r2, r3
  2075e6:	d904      	bls.n	2075f2 <LCD_IsRefreshScreenTimeout+0x2a>
		LCD_RefreshScreenClear(nrRefresh);
  2075e8:	6878      	ldr	r0, [r7, #4]
  2075ea:	f7ff ffdb 	bl	2075a4 <LCD_RefreshScreenClear>
		return 1;
  2075ee:	2301      	movs	r3, #1
  2075f0:	e000      	b.n	2075f4 <LCD_IsRefreshScreenTimeout+0x2c>
	}
	else return 0;
  2075f2:	2300      	movs	r3, #0
}
  2075f4:	4618      	mov	r0, r3
  2075f6:	3708      	adds	r7, #8
  2075f8:	46bd      	mov	sp, r7
  2075fa:	bd80      	pop	{r7, pc}
  2075fc:	200149a4 	.word	0x200149a4

00207600 <GetTransitionColor>:


//float dfeee = GetTransitionCoeff(WHITE, uint32_t colorTo, GetTransitionColor(WHITE, MYGRAY, 0.43));

uint32_t GetTransitionColor(uint32_t colorFrom, uint32_t colorTo, float transCoeff)
{
  207600:	b480      	push	{r7}
  207602:	b089      	sub	sp, #36	; 0x24
  207604:	af00      	add	r7, sp, #0
  207606:	60f8      	str	r0, [r7, #12]
  207608:	60b9      	str	r1, [r7, #8]
  20760a:	ed87 0a01 	vstr	s0, [r7, #4]
		  if(1.0<=transCoeff) return colorTo;
  20760e:	edd7 7a01 	vldr	s15, [r7, #4]
  207612:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
  207616:	eef4 7ac7 	vcmpe.f32	s15, s14
  20761a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20761e:	db01      	blt.n	207624 <GetTransitionColor+0x24>
  207620:	68bb      	ldr	r3, [r7, #8]
  207622:	e08d      	b.n	207740 <GetTransitionColor+0x140>
	else if(0.0>=transCoeff) return colorFrom;
  207624:	edd7 7a01 	vldr	s15, [r7, #4]
  207628:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  20762c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  207630:	d801      	bhi.n	207636 <GetTransitionColor+0x36>
  207632:	68fb      	ldr	r3, [r7, #12]
  207634:	e084      	b.n	207740 <GetTransitionColor+0x140>

	uint8_t R_1= (colorFrom>>16)&0x000000FF;
  207636:	68fb      	ldr	r3, [r7, #12]
  207638:	0c1b      	lsrs	r3, r3, #16
  20763a:	77fb      	strb	r3, [r7, #31]
	uint8_t G_1= (colorFrom>>8) &0x000000FF;
  20763c:	68fb      	ldr	r3, [r7, #12]
  20763e:	0a1b      	lsrs	r3, r3, #8
  207640:	77bb      	strb	r3, [r7, #30]
	uint8_t B_1=  colorFrom     &0x000000FF;
  207642:	68fb      	ldr	r3, [r7, #12]
  207644:	777b      	strb	r3, [r7, #29]

	uint8_t R_2= (colorTo>>16)&0x000000FF;
  207646:	68bb      	ldr	r3, [r7, #8]
  207648:	0c1b      	lsrs	r3, r3, #16
  20764a:	773b      	strb	r3, [r7, #28]
	uint8_t G_2= (colorTo>>8) &0x000000FF;
  20764c:	68bb      	ldr	r3, [r7, #8]
  20764e:	0a1b      	lsrs	r3, r3, #8
  207650:	76fb      	strb	r3, [r7, #27]
	uint8_t B_2=  colorTo     &0x000000FF;
  207652:	68bb      	ldr	r3, [r7, #8]
  207654:	76bb      	strb	r3, [r7, #26]

	uint8_t R_delta= ABS((int)R_1-(int)R_2);
  207656:	7ffa      	ldrb	r2, [r7, #31]
  207658:	7f3b      	ldrb	r3, [r7, #28]
  20765a:	1ad3      	subs	r3, r2, r3
  20765c:	2b00      	cmp	r3, #0
  20765e:	bfb8      	it	lt
  207660:	425b      	neglt	r3, r3
  207662:	767b      	strb	r3, [r7, #25]
	uint8_t G_delta= ABS((int)G_1-(int)G_2);
  207664:	7fba      	ldrb	r2, [r7, #30]
  207666:	7efb      	ldrb	r3, [r7, #27]
  207668:	1ad3      	subs	r3, r2, r3
  20766a:	2b00      	cmp	r3, #0
  20766c:	bfb8      	it	lt
  20766e:	425b      	neglt	r3, r3
  207670:	763b      	strb	r3, [r7, #24]
	uint8_t B_delta= ABS((int)B_1-(int)B_2);
  207672:	7f7a      	ldrb	r2, [r7, #29]
  207674:	7ebb      	ldrb	r3, [r7, #26]
  207676:	1ad3      	subs	r3, r2, r3
  207678:	2b00      	cmp	r3, #0
  20767a:	bfb8      	it	lt
  20767c:	425b      	neglt	r3, r3
  20767e:	75fb      	strb	r3, [r7, #23]

	uint8_t R_coeff=  (uint8_t)((float)R_delta*transCoeff);
  207680:	7e7b      	ldrb	r3, [r7, #25]
  207682:	ee07 3a90 	vmov	s15, r3
  207686:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  20768a:	edd7 7a01 	vldr	s15, [r7, #4]
  20768e:	ee67 7a27 	vmul.f32	s15, s14, s15
  207692:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  207696:	edc7 7a00 	vstr	s15, [r7]
  20769a:	783b      	ldrb	r3, [r7, #0]
  20769c:	75bb      	strb	r3, [r7, #22]
	uint8_t G_coeff=  (uint8_t)((float)G_delta*transCoeff);
  20769e:	7e3b      	ldrb	r3, [r7, #24]
  2076a0:	ee07 3a90 	vmov	s15, r3
  2076a4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  2076a8:	edd7 7a01 	vldr	s15, [r7, #4]
  2076ac:	ee67 7a27 	vmul.f32	s15, s14, s15
  2076b0:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  2076b4:	edc7 7a00 	vstr	s15, [r7]
  2076b8:	783b      	ldrb	r3, [r7, #0]
  2076ba:	757b      	strb	r3, [r7, #21]
	uint8_t B_coeff=  (uint8_t)((float)B_delta*transCoeff);
  2076bc:	7dfb      	ldrb	r3, [r7, #23]
  2076be:	ee07 3a90 	vmov	s15, r3
  2076c2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
  2076c6:	edd7 7a01 	vldr	s15, [r7, #4]
  2076ca:	ee67 7a27 	vmul.f32	s15, s14, s15
  2076ce:	eefc 7ae7 	vcvt.u32.f32	s15, s15
  2076d2:	edc7 7a00 	vstr	s15, [r7]
  2076d6:	783b      	ldrb	r3, [r7, #0]
  2076d8:	753b      	strb	r3, [r7, #20]

	uint8_t R_out = R_1>R_2 ? R_1-R_coeff : R_1+R_coeff;
  2076da:	7ffa      	ldrb	r2, [r7, #31]
  2076dc:	7f3b      	ldrb	r3, [r7, #28]
  2076de:	429a      	cmp	r2, r3
  2076e0:	d904      	bls.n	2076ec <GetTransitionColor+0xec>
  2076e2:	7ffa      	ldrb	r2, [r7, #31]
  2076e4:	7dbb      	ldrb	r3, [r7, #22]
  2076e6:	1ad3      	subs	r3, r2, r3
  2076e8:	b2db      	uxtb	r3, r3
  2076ea:	e003      	b.n	2076f4 <GetTransitionColor+0xf4>
  2076ec:	7ffa      	ldrb	r2, [r7, #31]
  2076ee:	7dbb      	ldrb	r3, [r7, #22]
  2076f0:	4413      	add	r3, r2
  2076f2:	b2db      	uxtb	r3, r3
  2076f4:	74fb      	strb	r3, [r7, #19]
	uint8_t G_out = G_1>G_2 ? G_1-G_coeff : G_1+G_coeff;
  2076f6:	7fba      	ldrb	r2, [r7, #30]
  2076f8:	7efb      	ldrb	r3, [r7, #27]
  2076fa:	429a      	cmp	r2, r3
  2076fc:	d904      	bls.n	207708 <GetTransitionColor+0x108>
  2076fe:	7fba      	ldrb	r2, [r7, #30]
  207700:	7d7b      	ldrb	r3, [r7, #21]
  207702:	1ad3      	subs	r3, r2, r3
  207704:	b2db      	uxtb	r3, r3
  207706:	e003      	b.n	207710 <GetTransitionColor+0x110>
  207708:	7fba      	ldrb	r2, [r7, #30]
  20770a:	7d7b      	ldrb	r3, [r7, #21]
  20770c:	4413      	add	r3, r2
  20770e:	b2db      	uxtb	r3, r3
  207710:	74bb      	strb	r3, [r7, #18]
	uint8_t B_out = B_1>B_2 ? B_1-B_coeff : B_1+B_coeff;
  207712:	7f7a      	ldrb	r2, [r7, #29]
  207714:	7ebb      	ldrb	r3, [r7, #26]
  207716:	429a      	cmp	r2, r3
  207718:	d904      	bls.n	207724 <GetTransitionColor+0x124>
  20771a:	7f7a      	ldrb	r2, [r7, #29]
  20771c:	7d3b      	ldrb	r3, [r7, #20]
  20771e:	1ad3      	subs	r3, r2, r3
  207720:	b2db      	uxtb	r3, r3
  207722:	e003      	b.n	20772c <GetTransitionColor+0x12c>
  207724:	7f7a      	ldrb	r2, [r7, #29]
  207726:	7d3b      	ldrb	r3, [r7, #20]
  207728:	4413      	add	r3, r2
  20772a:	b2db      	uxtb	r3, r3
  20772c:	747b      	strb	r3, [r7, #17]

	return RGB2INT(R_out,G_out,B_out);
  20772e:	7cfb      	ldrb	r3, [r7, #19]
  207730:	041a      	lsls	r2, r3, #16
  207732:	7cbb      	ldrb	r3, [r7, #18]
  207734:	021b      	lsls	r3, r3, #8
  207736:	431a      	orrs	r2, r3
  207738:	7c7b      	ldrb	r3, [r7, #17]
  20773a:	4313      	orrs	r3, r2
  20773c:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
}
  207740:	4618      	mov	r0, r3
  207742:	3724      	adds	r7, #36	; 0x24
  207744:	46bd      	mov	sp, r7
  207746:	f85d 7b04 	ldr.w	r7, [sp], #4
  20774a:	4770      	bx	lr

0020774c <GetTransitionCoeff>:

float GetTransitionCoeff(uint32_t colorFrom, uint32_t colorTo, uint32_t colorTrans)
{
  20774c:	b480      	push	{r7}
  20774e:	b08d      	sub	sp, #52	; 0x34
  207750:	af00      	add	r7, sp, #0
  207752:	60f8      	str	r0, [r7, #12]
  207754:	60b9      	str	r1, [r7, #8]
  207756:	607a      	str	r2, [r7, #4]
	int div=0;
  207758:	2300      	movs	r3, #0
  20775a:	62fb      	str	r3, [r7, #44]	; 0x2c
	float average=0;
  20775c:	f04f 0300 	mov.w	r3, #0
  207760:	62bb      	str	r3, [r7, #40]	; 0x28

	uint8_t R_1= (colorFrom>>16)&0x000000FF;
  207762:	68fb      	ldr	r3, [r7, #12]
  207764:	0c1b      	lsrs	r3, r3, #16
  207766:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	uint8_t G_1= (colorFrom>>8) &0x000000FF;
  20776a:	68fb      	ldr	r3, [r7, #12]
  20776c:	0a1b      	lsrs	r3, r3, #8
  20776e:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	uint8_t B_1=  colorFrom     &0x000000FF;
  207772:	68fb      	ldr	r3, [r7, #12]
  207774:	f887 3025 	strb.w	r3, [r7, #37]	; 0x25

	uint8_t R_2= (colorTo>>16)&0x000000FF;
  207778:	68bb      	ldr	r3, [r7, #8]
  20777a:	0c1b      	lsrs	r3, r3, #16
  20777c:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	uint8_t G_2= (colorTo>>8) &0x000000FF;
  207780:	68bb      	ldr	r3, [r7, #8]
  207782:	0a1b      	lsrs	r3, r3, #8
  207784:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	uint8_t B_2=  colorTo     &0x000000FF;
  207788:	68bb      	ldr	r3, [r7, #8]
  20778a:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22

	uint8_t R_tr= (colorTrans>>16)&0x000000FF;
  20778e:	687b      	ldr	r3, [r7, #4]
  207790:	0c1b      	lsrs	r3, r3, #16
  207792:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
	uint8_t G_tr= (colorTrans>>8) &0x000000FF;
  207796:	687b      	ldr	r3, [r7, #4]
  207798:	0a1b      	lsrs	r3, r3, #8
  20779a:	f887 3020 	strb.w	r3, [r7, #32]
	uint8_t B_tr=  colorTrans     &0x000000FF;
  20779e:	687b      	ldr	r3, [r7, #4]
  2077a0:	77fb      	strb	r3, [r7, #31]

	float R_delta= ABS((int)R_1-(int)R_2);	 if(R_delta>0) div++;
  2077a2:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  2077a6:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
  2077aa:	1ad3      	subs	r3, r2, r3
  2077ac:	2b00      	cmp	r3, #0
  2077ae:	bfb8      	it	lt
  2077b0:	425b      	neglt	r3, r3
  2077b2:	ee07 3a90 	vmov	s15, r3
  2077b6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2077ba:	edc7 7a06 	vstr	s15, [r7, #24]
  2077be:	edd7 7a06 	vldr	s15, [r7, #24]
  2077c2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  2077c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2077ca:	dd02      	ble.n	2077d2 <GetTransitionCoeff+0x86>
  2077cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2077ce:	3301      	adds	r3, #1
  2077d0:	62fb      	str	r3, [r7, #44]	; 0x2c
	float G_delta= ABS((int)G_1-(int)G_2);	 if(G_delta>0) div++;
  2077d2:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
  2077d6:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  2077da:	1ad3      	subs	r3, r2, r3
  2077dc:	2b00      	cmp	r3, #0
  2077de:	bfb8      	it	lt
  2077e0:	425b      	neglt	r3, r3
  2077e2:	ee07 3a90 	vmov	s15, r3
  2077e6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2077ea:	edc7 7a05 	vstr	s15, [r7, #20]
  2077ee:	edd7 7a05 	vldr	s15, [r7, #20]
  2077f2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  2077f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2077fa:	dd02      	ble.n	207802 <GetTransitionCoeff+0xb6>
  2077fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2077fe:	3301      	adds	r3, #1
  207800:	62fb      	str	r3, [r7, #44]	; 0x2c
	float B_delta= ABS((int)B_1-(int)B_2);	 if(B_delta>0) div++;
  207802:	f897 2025 	ldrb.w	r2, [r7, #37]	; 0x25
  207806:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
  20780a:	1ad3      	subs	r3, r2, r3
  20780c:	2b00      	cmp	r3, #0
  20780e:	bfb8      	it	lt
  207810:	425b      	neglt	r3, r3
  207812:	ee07 3a90 	vmov	s15, r3
  207816:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  20781a:	edc7 7a04 	vstr	s15, [r7, #16]
  20781e:	edd7 7a04 	vldr	s15, [r7, #16]
  207822:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  207826:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20782a:	dd02      	ble.n	207832 <GetTransitionCoeff+0xe6>
  20782c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20782e:	3301      	adds	r3, #1
  207830:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(R_delta>0) average += (float)ABS(R_tr-R_1)/R_delta;
  207832:	edd7 7a06 	vldr	s15, [r7, #24]
  207836:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  20783a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20783e:	dd23      	ble.n	207888 <GetTransitionCoeff+0x13c>
  207840:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
  207844:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  207848:	1ad3      	subs	r3, r2, r3
  20784a:	2b00      	cmp	r3, #0
  20784c:	dd09      	ble.n	207862 <GetTransitionCoeff+0x116>
  20784e:	f897 2021 	ldrb.w	r2, [r7, #33]	; 0x21
  207852:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  207856:	1ad3      	subs	r3, r2, r3
  207858:	ee07 3a90 	vmov	s15, r3
  20785c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  207860:	e008      	b.n	207874 <GetTransitionCoeff+0x128>
  207862:	f897 2027 	ldrb.w	r2, [r7, #39]	; 0x27
  207866:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
  20786a:	1ad3      	subs	r3, r2, r3
  20786c:	ee07 3a90 	vmov	s15, r3
  207870:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  207874:	edd7 6a06 	vldr	s13, [r7, #24]
  207878:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  20787c:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  207880:	ee77 7a87 	vadd.f32	s15, s15, s14
  207884:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
	if(G_delta>0) average += (float)ABS(G_tr-G_1)/G_delta;
  207888:	edd7 7a05 	vldr	s15, [r7, #20]
  20788c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  207890:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  207894:	dd23      	ble.n	2078de <GetTransitionCoeff+0x192>
  207896:	f897 2020 	ldrb.w	r2, [r7, #32]
  20789a:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  20789e:	1ad3      	subs	r3, r2, r3
  2078a0:	2b00      	cmp	r3, #0
  2078a2:	dd09      	ble.n	2078b8 <GetTransitionCoeff+0x16c>
  2078a4:	f897 2020 	ldrb.w	r2, [r7, #32]
  2078a8:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  2078ac:	1ad3      	subs	r3, r2, r3
  2078ae:	ee07 3a90 	vmov	s15, r3
  2078b2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2078b6:	e008      	b.n	2078ca <GetTransitionCoeff+0x17e>
  2078b8:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
  2078bc:	f897 3020 	ldrb.w	r3, [r7, #32]
  2078c0:	1ad3      	subs	r3, r2, r3
  2078c2:	ee07 3a90 	vmov	s15, r3
  2078c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  2078ca:	edd7 6a05 	vldr	s13, [r7, #20]
  2078ce:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  2078d2:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  2078d6:	ee77 7a87 	vadd.f32	s15, s15, s14
  2078da:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28
	if(B_delta>0) average += (float)ABS(B_tr-B_1)/B_delta;
  2078de:	edd7 7a04 	vldr	s15, [r7, #16]
  2078e2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
  2078e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2078ea:	dd20      	ble.n	20792e <GetTransitionCoeff+0x1e2>
  2078ec:	7ffa      	ldrb	r2, [r7, #31]
  2078ee:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
  2078f2:	1ad3      	subs	r3, r2, r3
  2078f4:	2b00      	cmp	r3, #0
  2078f6:	dd08      	ble.n	20790a <GetTransitionCoeff+0x1be>
  2078f8:	7ffa      	ldrb	r2, [r7, #31]
  2078fa:	f897 3025 	ldrb.w	r3, [r7, #37]	; 0x25
  2078fe:	1ad3      	subs	r3, r2, r3
  207900:	ee07 3a90 	vmov	s15, r3
  207904:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  207908:	e007      	b.n	20791a <GetTransitionCoeff+0x1ce>
  20790a:	f897 2025 	ldrb.w	r2, [r7, #37]	; 0x25
  20790e:	7ffb      	ldrb	r3, [r7, #31]
  207910:	1ad3      	subs	r3, r2, r3
  207912:	ee07 3a90 	vmov	s15, r3
  207916:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  20791a:	edd7 6a04 	vldr	s13, [r7, #16]
  20791e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
  207922:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  207926:	ee77 7a87 	vadd.f32	s15, s15, s14
  20792a:	edc7 7a0a 	vstr	s15, [r7, #40]	; 0x28

	return (average/div);
  20792e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207930:	ee07 3a90 	vmov	s15, r3
  207934:	eef8 7ae7 	vcvt.f32.s32	s15, s15
  207938:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  20793c:	eec7 6a27 	vdiv.f32	s13, s14, s15
  207940:	eef0 7a66 	vmov.f32	s15, s13
}
  207944:	eeb0 0a67 	vmov.f32	s0, s15
  207948:	3734      	adds	r7, #52	; 0x34
  20794a:	46bd      	mov	sp, r7
  20794c:	f85d 7b04 	ldr.w	r7, [sp], #4
  207950:	4770      	bx	lr
	...

00207954 <SCB_InvalidateDCache_by_Addr>:
  \details Invalidates D-Cache for the given address
  \param[in]   addr    address (aligned to 32-byte boundary)
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_INLINE void SCB_InvalidateDCache_by_Addr (uint32_t *addr, int32_t dsize)
{
  207954:	b480      	push	{r7}
  207956:	b087      	sub	sp, #28
  207958:	af00      	add	r7, sp, #0
  20795a:	6078      	str	r0, [r7, #4]
  20795c:	6039      	str	r1, [r7, #0]
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
     int32_t op_size = dsize;
  20795e:	683b      	ldr	r3, [r7, #0]
  207960:	617b      	str	r3, [r7, #20]
    uint32_t op_addr = (uint32_t)addr;
  207962:	687b      	ldr	r3, [r7, #4]
  207964:	613b      	str	r3, [r7, #16]
     int32_t linesize = 32;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
  207966:	2320      	movs	r3, #32
  207968:	60fb      	str	r3, [r7, #12]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  20796a:	f3bf 8f4f 	dsb	sy

    __DSB();

    while (op_size > 0) {
  20796e:	e00b      	b.n	207988 <SCB_InvalidateDCache_by_Addr+0x34>
      SCB->DCIMVAC = op_addr;
  207970:	4a0c      	ldr	r2, [pc, #48]	; (2079a4 <SCB_InvalidateDCache_by_Addr+0x50>)
  207972:	693b      	ldr	r3, [r7, #16]
  207974:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
  207978:	68fb      	ldr	r3, [r7, #12]
  20797a:	693a      	ldr	r2, [r7, #16]
  20797c:	4413      	add	r3, r2
  20797e:	613b      	str	r3, [r7, #16]
      op_size -=           linesize;
  207980:	697a      	ldr	r2, [r7, #20]
  207982:	68fb      	ldr	r3, [r7, #12]
  207984:	1ad3      	subs	r3, r2, r3
  207986:	617b      	str	r3, [r7, #20]
    while (op_size > 0) {
  207988:	697b      	ldr	r3, [r7, #20]
  20798a:	2b00      	cmp	r3, #0
  20798c:	dcf0      	bgt.n	207970 <SCB_InvalidateDCache_by_Addr+0x1c>
  20798e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  207992:	f3bf 8f6f 	isb	sy
    }

    __DSB();
    __ISB();
  #endif
}
  207996:	bf00      	nop
  207998:	371c      	adds	r7, #28
  20799a:	46bd      	mov	sp, r7
  20799c:	f85d 7b04 	ldr.w	r7, [sp], #4
  2079a0:	4770      	bx	lr
  2079a2:	bf00      	nop
  2079a4:	e000ed00 	.word	0xe000ed00

002079a8 <LCD_GetXSize>:
#include "ltdc.h"
#include "dma2d.h"

static uint32_t  ActiveLayer=0;

uint32_t LCD_GetXSize(void){
  2079a8:	b480      	push	{r7}
  2079aa:	af00      	add	r7, sp, #0
  return hltdc.LayerCfg[ActiveLayer].ImageWidth;
  2079ac:	4b06      	ldr	r3, [pc, #24]	; (2079c8 <LCD_GetXSize+0x20>)
  2079ae:	681b      	ldr	r3, [r3, #0]
  2079b0:	4a06      	ldr	r2, [pc, #24]	; (2079cc <LCD_GetXSize+0x24>)
  2079b2:	2134      	movs	r1, #52	; 0x34
  2079b4:	fb01 f303 	mul.w	r3, r1, r3
  2079b8:	4413      	add	r3, r2
  2079ba:	3360      	adds	r3, #96	; 0x60
  2079bc:	681b      	ldr	r3, [r3, #0]
}
  2079be:	4618      	mov	r0, r3
  2079c0:	46bd      	mov	sp, r7
  2079c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  2079c6:	4770      	bx	lr
  2079c8:	2000230c 	.word	0x2000230c
  2079cc:	20014af4 	.word	0x20014af4

002079d0 <LCD_GetYSize>:
uint32_t LCD_GetYSize(void){
  2079d0:	b480      	push	{r7}
  2079d2:	af00      	add	r7, sp, #0
  return hltdc.LayerCfg[ActiveLayer].ImageHeight;
  2079d4:	4b06      	ldr	r3, [pc, #24]	; (2079f0 <LCD_GetYSize+0x20>)
  2079d6:	681b      	ldr	r3, [r3, #0]
  2079d8:	4a06      	ldr	r2, [pc, #24]	; (2079f4 <LCD_GetYSize+0x24>)
  2079da:	2134      	movs	r1, #52	; 0x34
  2079dc:	fb01 f303 	mul.w	r3, r1, r3
  2079e0:	4413      	add	r3, r2
  2079e2:	3364      	adds	r3, #100	; 0x64
  2079e4:	681b      	ldr	r3, [r3, #0]
}
  2079e6:	4618      	mov	r0, r3
  2079e8:	46bd      	mov	sp, r7
  2079ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  2079ee:	4770      	bx	lr
  2079f0:	2000230c 	.word	0x2000230c
  2079f4:	20014af4 	.word	0x20014af4

002079f8 <LCD_GetBytesPerPixel>:
//static uint32_t LCD_GetAddress(uint32_t Xpos, uint32_t Ypos){
//  return hltdc.LayerCfg[ActiveLayer].FBStartAdress;
//}

static int LCD_GetBytesPerPixel(void)
{
  2079f8:	b480      	push	{r7}
  2079fa:	af00      	add	r7, sp, #0
	switch(hdma2d.Init.ColorMode)
  2079fc:	4b07      	ldr	r3, [pc, #28]	; (207a1c <LCD_GetBytesPerPixel+0x24>)
  2079fe:	689b      	ldr	r3, [r3, #8]
  207a00:	2b01      	cmp	r3, #1
  207a02:	d003      	beq.n	207a0c <LCD_GetBytesPerPixel+0x14>
  207a04:	2b02      	cmp	r3, #2
  207a06:	d103      	bne.n	207a10 <LCD_GetBytesPerPixel+0x18>
	{
	case DMA2D_OUTPUT_RGB565:
		return 2;
  207a08:	2302      	movs	r3, #2
  207a0a:	e002      	b.n	207a12 <LCD_GetBytesPerPixel+0x1a>
	case DMA2D_OUTPUT_RGB888:
		return 3;
  207a0c:	2303      	movs	r3, #3
  207a0e:	e000      	b.n	207a12 <LCD_GetBytesPerPixel+0x1a>
	default:
	case DMA2D_OUTPUT_ARGB8888:
		return 4;
  207a10:	2304      	movs	r3, #4
	}
}
  207a12:	4618      	mov	r0, r3
  207a14:	46bd      	mov	sp, r7
  207a16:	f85d 7b04 	ldr.w	r7, [sp], #4
  207a1a:	4770      	bx	lr
  207a1c:	20014a54 	.word	0x20014a54

00207a20 <LCD_GetPositionAddress>:

static uint32_t LCD_GetPositionAddress(uint32_t Xpos, uint32_t Ypos){
  207a20:	b5b0      	push	{r4, r5, r7, lr}
  207a22:	b082      	sub	sp, #8
  207a24:	af00      	add	r7, sp, #0
  207a26:	6078      	str	r0, [r7, #4]
  207a28:	6039      	str	r1, [r7, #0]
  return hltdc.LayerCfg[ActiveLayer].FBStartAdress + (((LCD_GetXSize()*Ypos) + Xpos)*LCD_GetBytesPerPixel());
  207a2a:	4b0d      	ldr	r3, [pc, #52]	; (207a60 <LCD_GetPositionAddress+0x40>)
  207a2c:	681b      	ldr	r3, [r3, #0]
  207a2e:	4a0d      	ldr	r2, [pc, #52]	; (207a64 <LCD_GetPositionAddress+0x44>)
  207a30:	2134      	movs	r1, #52	; 0x34
  207a32:	fb01 f303 	mul.w	r3, r1, r3
  207a36:	4413      	add	r3, r2
  207a38:	335c      	adds	r3, #92	; 0x5c
  207a3a:	681c      	ldr	r4, [r3, #0]
  207a3c:	f7ff ffb4 	bl	2079a8 <LCD_GetXSize>
  207a40:	4602      	mov	r2, r0
  207a42:	683b      	ldr	r3, [r7, #0]
  207a44:	fb03 f202 	mul.w	r2, r3, r2
  207a48:	687b      	ldr	r3, [r7, #4]
  207a4a:	18d5      	adds	r5, r2, r3
  207a4c:	f7ff ffd4 	bl	2079f8 <LCD_GetBytesPerPixel>
  207a50:	4603      	mov	r3, r0
  207a52:	fb03 f305 	mul.w	r3, r3, r5
  207a56:	4423      	add	r3, r4
}
  207a58:	4618      	mov	r0, r3
  207a5a:	3708      	adds	r7, #8
  207a5c:	46bd      	mov	sp, r7
  207a5e:	bdb0      	pop	{r4, r5, r7, pc}
  207a60:	2000230c 	.word	0x2000230c
  207a64:	20014af4 	.word	0x20014af4

00207a68 <LCD_SetOutputOffset>:

static int LCD_SetOutputOffset(uint32_t width)
{
  207a68:	b580      	push	{r7, lr}
  207a6a:	b082      	sub	sp, #8
  207a6c:	af00      	add	r7, sp, #0
  207a6e:	6078      	str	r0, [r7, #4]
	hdma2d.Init.OutputOffset = LCD_GetXSize() - width;
  207a70:	f7ff ff9a 	bl	2079a8 <LCD_GetXSize>
  207a74:	4602      	mov	r2, r0
  207a76:	687b      	ldr	r3, [r7, #4]
  207a78:	1ad3      	subs	r3, r2, r3
  207a7a:	4a05      	ldr	r2, [pc, #20]	; (207a90 <LCD_SetOutputOffset+0x28>)
  207a7c:	60d3      	str	r3, [r2, #12]
	return HAL_DMA2D_Init(&hdma2d);
  207a7e:	4804      	ldr	r0, [pc, #16]	; (207a90 <LCD_SetOutputOffset+0x28>)
  207a80:	f011 ff70 	bl	219964 <HAL_DMA2D_Init>
  207a84:	4603      	mov	r3, r0
}
  207a86:	4618      	mov	r0, r3
  207a88:	3708      	adds	r7, #8
  207a8a:	46bd      	mov	sp, r7
  207a8c:	bd80      	pop	{r7, pc}
  207a8e:	bf00      	nop
  207a90:	20014a54 	.word	0x20014a54

00207a94 <LCD_DisplayBuff>:

void LCD_DisplayBuff(uint32_t Xpos, uint32_t Ypos, uint32_t width, uint32_t height, uint32_t *pbmp)
{
  207a94:	b590      	push	{r4, r7, lr}
  207a96:	b087      	sub	sp, #28
  207a98:	af02      	add	r7, sp, #8
  207a9a:	60f8      	str	r0, [r7, #12]
  207a9c:	60b9      	str	r1, [r7, #8]
  207a9e:	607a      	str	r2, [r7, #4]
  207aa0:	603b      	str	r3, [r7, #0]
	while(HAL_DMA2D_STATE_READY!=HAL_DMA2D_GetState(&hdma2d));
  207aa2:	bf00      	nop
  207aa4:	4814      	ldr	r0, [pc, #80]	; (207af8 <LCD_DisplayBuff+0x64>)
  207aa6:	f012 f997 	bl	219dd8 <HAL_DMA2D_GetState>
  207aaa:	4603      	mov	r3, r0
  207aac:	2b01      	cmp	r3, #1
  207aae:	d1f9      	bne.n	207aa4 <LCD_DisplayBuff+0x10>
	LCD_SetOutputOffset(width);
  207ab0:	6878      	ldr	r0, [r7, #4]
  207ab2:	f7ff ffd9 	bl	207a68 <LCD_SetOutputOffset>
	SCB_InvalidateDCache_by_Addr(pbmp, width*height*sizeof(uint32_t));
  207ab6:	687b      	ldr	r3, [r7, #4]
  207ab8:	683a      	ldr	r2, [r7, #0]
  207aba:	fb02 f303 	mul.w	r3, r2, r3
  207abe:	009b      	lsls	r3, r3, #2
  207ac0:	4619      	mov	r1, r3
  207ac2:	6a38      	ldr	r0, [r7, #32]
  207ac4:	f7ff ff46 	bl	207954 <SCB_InvalidateDCache_by_Addr>
   HAL_DMA2D_Start_IT(&hdma2d, (uint32_t)pbmp, LCD_GetPositionAddress(Xpos,Ypos), width, height);
  207ac8:	6a3c      	ldr	r4, [r7, #32]
  207aca:	68b9      	ldr	r1, [r7, #8]
  207acc:	68f8      	ldr	r0, [r7, #12]
  207ace:	f7ff ffa7 	bl	207a20 <LCD_GetPositionAddress>
  207ad2:	4602      	mov	r2, r0
  207ad4:	683b      	ldr	r3, [r7, #0]
  207ad6:	9300      	str	r3, [sp, #0]
  207ad8:	687b      	ldr	r3, [r7, #4]
  207ada:	4621      	mov	r1, r4
  207adc:	4806      	ldr	r0, [pc, #24]	; (207af8 <LCD_DisplayBuff+0x64>)
  207ade:	f011 ff9b 	bl	219a18 <HAL_DMA2D_Start_IT>
   while(HAL_DMA2D_STATE_READY!=HAL_DMA2D_GetState(&hdma2d));
  207ae2:	bf00      	nop
  207ae4:	4804      	ldr	r0, [pc, #16]	; (207af8 <LCD_DisplayBuff+0x64>)
  207ae6:	f012 f977 	bl	219dd8 <HAL_DMA2D_GetState>
  207aea:	4603      	mov	r3, r0
  207aec:	2b01      	cmp	r3, #1
  207aee:	d1f9      	bne.n	207ae4 <LCD_DisplayBuff+0x50>
}
  207af0:	bf00      	nop
  207af2:	3714      	adds	r7, #20
  207af4:	46bd      	mov	sp, r7
  207af6:	bd90      	pop	{r4, r7, pc}
  207af8:	20014a54 	.word	0x20014a54

00207afc <MyRealizeSpaceCorrect>:
static uint32_t CounterBusyBytesForFontsImages=0;

//####################### -- My Settings -- #######################################################################

static int MyRealizeSpaceCorrect(char *txt, int id)
{
  207afc:	b480      	push	{r7}
  207afe:	b083      	sub	sp, #12
  207b00:	af00      	add	r7, sp, #0
  207b02:	6078      	str	r0, [r7, #4]
  207b04:	6039      	str	r1, [r7, #0]
//		if((FONT_20==FontID[id].size)&&(Times_New_Roman==FontID[id].style))
//		{
//			if((txt[0]=='i')&&(txt[1]=='j'))
//				return 20;
//		}
	return 0;
  207b06:	2300      	movs	r3, #0
}
  207b08:	4618      	mov	r0, r3
  207b0a:	370c      	adds	r7, #12
  207b0c:	46bd      	mov	sp, r7
  207b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
  207b12:	4770      	bx	lr

00207b14 <RealizeWidthConst>:

static int RealizeWidthConst(const char _char)
{
  207b14:	b480      	push	{r7}
  207b16:	b083      	sub	sp, #12
  207b18:	af00      	add	r7, sp, #0
  207b1a:	4603      	mov	r3, r0
  207b1c:	71fb      	strb	r3, [r7, #7]
	if(((_char > 0x2F) && (_char < 0x3A)) || (_char == ':') || (_char == '-'))
  207b1e:	79fb      	ldrb	r3, [r7, #7]
  207b20:	2b2f      	cmp	r3, #47	; 0x2f
  207b22:	d902      	bls.n	207b2a <RealizeWidthConst+0x16>
  207b24:	79fb      	ldrb	r3, [r7, #7]
  207b26:	2b39      	cmp	r3, #57	; 0x39
  207b28:	d905      	bls.n	207b36 <RealizeWidthConst+0x22>
  207b2a:	79fb      	ldrb	r3, [r7, #7]
  207b2c:	2b3a      	cmp	r3, #58	; 0x3a
  207b2e:	d002      	beq.n	207b36 <RealizeWidthConst+0x22>
  207b30:	79fb      	ldrb	r3, [r7, #7]
  207b32:	2b2d      	cmp	r3, #45	; 0x2d
  207b34:	d101      	bne.n	207b3a <RealizeWidthConst+0x26>
		return 1;
  207b36:	2301      	movs	r3, #1
  207b38:	e000      	b.n	207b3c <RealizeWidthConst+0x28>
	else
		return 0;
  207b3a:	2300      	movs	r3, #0
}
  207b3c:	4618      	mov	r0, r3
  207b3e:	370c      	adds	r7, #12
  207b40:	46bd      	mov	sp, r7
  207b42:	f85d 7b04 	ldr.w	r7, [sp], #4
  207b46:	4770      	bx	lr

00207b48 <LCD_CopyBuff2pLcd>:

//################################################################################################################

static void LCD_CopyBuff2pLcd(int rot, uint32_t posBuff, uint32_t *buff, uint32_t xImgWidth, uint32_t yImgHeight, int posWin, uint16_t windowWidth, uint16_t xPosLcd, uint16_t yPosLcd, int param)
{
  207b48:	b5b0      	push	{r4, r5, r7, lr}
  207b4a:	b090      	sub	sp, #64	; 0x40
  207b4c:	af00      	add	r7, sp, #0
  207b4e:	60f8      	str	r0, [r7, #12]
  207b50:	60b9      	str	r1, [r7, #8]
  207b52:	607a      	str	r2, [r7, #4]
  207b54:	603b      	str	r3, [r7, #0]
	uint32_t n=0, offsX,offsY, pos=posBuff+posWin, posLcd=yPosLcd*LCD_GetXSize()+xPosLcd;
  207b56:	2300      	movs	r3, #0
  207b58:	63fb      	str	r3, [r7, #60]	; 0x3c
  207b5a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  207b5c:	68ba      	ldr	r2, [r7, #8]
  207b5e:	4413      	add	r3, r2
  207b60:	61bb      	str	r3, [r7, #24]
  207b62:	f8b7 4060 	ldrh.w	r4, [r7, #96]	; 0x60
  207b66:	f7ff ff1f 	bl	2079a8 <LCD_GetXSize>
  207b6a:	4603      	mov	r3, r0
  207b6c:	fb03 f204 	mul.w	r2, r3, r4
  207b70:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
  207b74:	4413      	add	r3, r2
  207b76:	637b      	str	r3, [r7, #52]	; 0x34
	switch(rot)
  207b78:	68fb      	ldr	r3, [r7, #12]
  207b7a:	2b01      	cmp	r3, #1
  207b7c:	d036      	beq.n	207bec <LCD_CopyBuff2pLcd+0xa4>
  207b7e:	2b02      	cmp	r3, #2
  207b80:	d06d      	beq.n	207c5e <LCD_CopyBuff2pLcd+0x116>
  207b82:	2b00      	cmp	r3, #0
  207b84:	d000      	beq.n	207b88 <LCD_CopyBuff2pLcd+0x40>
			n+=xImgWidth-windowWidth;
			offsX++;
		}
		break;
	}
}
  207b86:	e0aa      	b.n	207cde <LCD_CopyBuff2pLcd+0x196>
		for(int j=0; j<yImgHeight; ++j){
  207b88:	2300      	movs	r3, #0
  207b8a:	633b      	str	r3, [r7, #48]	; 0x30
  207b8c:	e029      	b.n	207be2 <LCD_CopyBuff2pLcd+0x9a>
			for(int i=0; i<windowWidth; ++i)
  207b8e:	2300      	movs	r3, #0
  207b90:	62fb      	str	r3, [r7, #44]	; 0x2c
  207b92:	e011      	b.n	207bb8 <LCD_CopyBuff2pLcd+0x70>
				pLcd[posLcd+i] = buff[pos+n++];
  207b94:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  207b96:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  207b98:	441a      	add	r2, r3
  207b9a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207b9c:	1c59      	adds	r1, r3, #1
  207b9e:	63f9      	str	r1, [r7, #60]	; 0x3c
  207ba0:	69b9      	ldr	r1, [r7, #24]
  207ba2:	440b      	add	r3, r1
  207ba4:	009b      	lsls	r3, r3, #2
  207ba6:	6879      	ldr	r1, [r7, #4]
  207ba8:	440b      	add	r3, r1
  207baa:	681b      	ldr	r3, [r3, #0]
  207bac:	494e      	ldr	r1, [pc, #312]	; (207ce8 <LCD_CopyBuff2pLcd+0x1a0>)
  207bae:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			for(int i=0; i<windowWidth; ++i)
  207bb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207bb4:	3301      	adds	r3, #1
  207bb6:	62fb      	str	r3, [r7, #44]	; 0x2c
  207bb8:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
  207bbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207bbe:	429a      	cmp	r2, r3
  207bc0:	dce8      	bgt.n	207b94 <LCD_CopyBuff2pLcd+0x4c>
			n+=xImgWidth-windowWidth;
  207bc2:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
  207bc6:	683a      	ldr	r2, [r7, #0]
  207bc8:	1ad3      	subs	r3, r2, r3
  207bca:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  207bcc:	4413      	add	r3, r2
  207bce:	63fb      	str	r3, [r7, #60]	; 0x3c
			posLcd+=LCD_GetXSize();
  207bd0:	f7ff feea 	bl	2079a8 <LCD_GetXSize>
  207bd4:	4602      	mov	r2, r0
  207bd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  207bd8:	4413      	add	r3, r2
  207bda:	637b      	str	r3, [r7, #52]	; 0x34
		for(int j=0; j<yImgHeight; ++j){
  207bdc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  207bde:	3301      	adds	r3, #1
  207be0:	633b      	str	r3, [r7, #48]	; 0x30
  207be2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  207be4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207be6:	429a      	cmp	r2, r3
  207be8:	d3d1      	bcc.n	207b8e <LCD_CopyBuff2pLcd+0x46>
		break;
  207bea:	e078      	b.n	207cde <LCD_CopyBuff2pLcd+0x196>
		offsX=yImgHeight-1;
  207bec:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207bee:	3b01      	subs	r3, #1
  207bf0:	63bb      	str	r3, [r7, #56]	; 0x38
		for(int j=0; j<yImgHeight; ++j){
  207bf2:	2300      	movs	r3, #0
  207bf4:	62bb      	str	r3, [r7, #40]	; 0x28
  207bf6:	e02d      	b.n	207c54 <LCD_CopyBuff2pLcd+0x10c>
			for(int i=0; i<windowWidth; ++i)
  207bf8:	2300      	movs	r3, #0
  207bfa:	627b      	str	r3, [r7, #36]	; 0x24
  207bfc:	e018      	b.n	207c30 <LCD_CopyBuff2pLcd+0xe8>
				pLcd[posLcd+offsX+i*LCD_GetXSize()] = buff[pos+n++];
  207bfe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  207c00:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207c02:	18d4      	adds	r4, r2, r3
  207c04:	f7ff fed0 	bl	2079a8 <LCD_GetXSize>
  207c08:	4602      	mov	r2, r0
  207c0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207c0c:	fb03 f302 	mul.w	r3, r3, r2
  207c10:	18e2      	adds	r2, r4, r3
  207c12:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207c14:	1c59      	adds	r1, r3, #1
  207c16:	63f9      	str	r1, [r7, #60]	; 0x3c
  207c18:	69b9      	ldr	r1, [r7, #24]
  207c1a:	440b      	add	r3, r1
  207c1c:	009b      	lsls	r3, r3, #2
  207c1e:	6879      	ldr	r1, [r7, #4]
  207c20:	440b      	add	r3, r1
  207c22:	681b      	ldr	r3, [r3, #0]
  207c24:	4930      	ldr	r1, [pc, #192]	; (207ce8 <LCD_CopyBuff2pLcd+0x1a0>)
  207c26:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			for(int i=0; i<windowWidth; ++i)
  207c2a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207c2c:	3301      	adds	r3, #1
  207c2e:	627b      	str	r3, [r7, #36]	; 0x24
  207c30:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
  207c34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207c36:	429a      	cmp	r2, r3
  207c38:	dce1      	bgt.n	207bfe <LCD_CopyBuff2pLcd+0xb6>
			n+=xImgWidth-windowWidth;
  207c3a:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
  207c3e:	683a      	ldr	r2, [r7, #0]
  207c40:	1ad3      	subs	r3, r2, r3
  207c42:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  207c44:	4413      	add	r3, r2
  207c46:	63fb      	str	r3, [r7, #60]	; 0x3c
			offsX--;
  207c48:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207c4a:	3b01      	subs	r3, #1
  207c4c:	63bb      	str	r3, [r7, #56]	; 0x38
		for(int j=0; j<yImgHeight; ++j){
  207c4e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  207c50:	3301      	adds	r3, #1
  207c52:	62bb      	str	r3, [r7, #40]	; 0x28
  207c54:	6aba      	ldr	r2, [r7, #40]	; 0x28
  207c56:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207c58:	429a      	cmp	r2, r3
  207c5a:	d3cd      	bcc.n	207bf8 <LCD_CopyBuff2pLcd+0xb0>
		break;
  207c5c:	e03f      	b.n	207cde <LCD_CopyBuff2pLcd+0x196>
		offsX=0;
  207c5e:	2300      	movs	r3, #0
  207c60:	63bb      	str	r3, [r7, #56]	; 0x38
		offsY=param;
  207c62:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  207c64:	617b      	str	r3, [r7, #20]
		for(int j=0; j<yImgHeight; ++j){
  207c66:	2300      	movs	r3, #0
  207c68:	623b      	str	r3, [r7, #32]
  207c6a:	e033      	b.n	207cd4 <LCD_CopyBuff2pLcd+0x18c>
			for(int i=0; i<windowWidth; ++i)
  207c6c:	2300      	movs	r3, #0
  207c6e:	61fb      	str	r3, [r7, #28]
  207c70:	e01e      	b.n	207cb0 <LCD_CopyBuff2pLcd+0x168>
				pLcd[posLcd+offsX+(offsY+windowWidth-1-i)*LCD_GetXSize()] = buff[pos+n++];
  207c72:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  207c74:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207c76:	18d4      	adds	r4, r2, r3
  207c78:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
  207c7c:	697b      	ldr	r3, [r7, #20]
  207c7e:	441a      	add	r2, r3
  207c80:	69fb      	ldr	r3, [r7, #28]
  207c82:	1ad3      	subs	r3, r2, r3
  207c84:	1e5d      	subs	r5, r3, #1
  207c86:	f7ff fe8f 	bl	2079a8 <LCD_GetXSize>
  207c8a:	4603      	mov	r3, r0
  207c8c:	fb03 f305 	mul.w	r3, r3, r5
  207c90:	18e2      	adds	r2, r4, r3
  207c92:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207c94:	1c59      	adds	r1, r3, #1
  207c96:	63f9      	str	r1, [r7, #60]	; 0x3c
  207c98:	69b9      	ldr	r1, [r7, #24]
  207c9a:	440b      	add	r3, r1
  207c9c:	009b      	lsls	r3, r3, #2
  207c9e:	6879      	ldr	r1, [r7, #4]
  207ca0:	440b      	add	r3, r1
  207ca2:	681b      	ldr	r3, [r3, #0]
  207ca4:	4910      	ldr	r1, [pc, #64]	; (207ce8 <LCD_CopyBuff2pLcd+0x1a0>)
  207ca6:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			for(int i=0; i<windowWidth; ++i)
  207caa:	69fb      	ldr	r3, [r7, #28]
  207cac:	3301      	adds	r3, #1
  207cae:	61fb      	str	r3, [r7, #28]
  207cb0:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
  207cb4:	69fb      	ldr	r3, [r7, #28]
  207cb6:	429a      	cmp	r2, r3
  207cb8:	dcdb      	bgt.n	207c72 <LCD_CopyBuff2pLcd+0x12a>
			n+=xImgWidth-windowWidth;
  207cba:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
  207cbe:	683a      	ldr	r2, [r7, #0]
  207cc0:	1ad3      	subs	r3, r2, r3
  207cc2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  207cc4:	4413      	add	r3, r2
  207cc6:	63fb      	str	r3, [r7, #60]	; 0x3c
			offsX++;
  207cc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207cca:	3301      	adds	r3, #1
  207ccc:	63bb      	str	r3, [r7, #56]	; 0x38
		for(int j=0; j<yImgHeight; ++j){
  207cce:	6a3b      	ldr	r3, [r7, #32]
  207cd0:	3301      	adds	r3, #1
  207cd2:	623b      	str	r3, [r7, #32]
  207cd4:	6a3a      	ldr	r2, [r7, #32]
  207cd6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  207cd8:	429a      	cmp	r2, r3
  207cda:	d3c7      	bcc.n	207c6c <LCD_CopyBuff2pLcd+0x124>
		break;
  207cdc:	bf00      	nop
}
  207cde:	bf00      	nop
  207ce0:	3740      	adds	r7, #64	; 0x40
  207ce2:	46bd      	mov	sp, r7
  207ce4:	bdb0      	pop	{r4, r5, r7, pc}
  207ce6:	bf00      	nop
  207ce8:	c0000000 	.word	0xc0000000

00207cec <LCD_CopyBuff2pLcdIndirect>:

static void LCD_CopyBuff2pLcdIndirect(int rot, uint32_t posBuff, uint32_t *buff, uint32_t xImgWidth, uint32_t yImgHeight, int posWin, uint16_t windowWidth, int param)
{
  207cec:	b480      	push	{r7}
  207cee:	b091      	sub	sp, #68	; 0x44
  207cf0:	af00      	add	r7, sp, #0
  207cf2:	60f8      	str	r0, [r7, #12]
  207cf4:	60b9      	str	r1, [r7, #8]
  207cf6:	607a      	str	r2, [r7, #4]
  207cf8:	603b      	str	r3, [r7, #0]
	uint32_t offsX,offsY,k=0,n=0,pos=posBuff+posWin;
  207cfa:	2300      	movs	r3, #0
  207cfc:	63bb      	str	r3, [r7, #56]	; 0x38
  207cfe:	2300      	movs	r3, #0
  207d00:	637b      	str	r3, [r7, #52]	; 0x34
  207d02:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  207d04:	68ba      	ldr	r2, [r7, #8]
  207d06:	4413      	add	r3, r2
  207d08:	61bb      	str	r3, [r7, #24]
	switch(rot)
  207d0a:	68fb      	ldr	r3, [r7, #12]
  207d0c:	2b01      	cmp	r3, #1
  207d0e:	d030      	beq.n	207d72 <LCD_CopyBuff2pLcdIndirect+0x86>
  207d10:	2b02      	cmp	r3, #2
  207d12:	d063      	beq.n	207ddc <LCD_CopyBuff2pLcdIndirect+0xf0>
  207d14:	2b00      	cmp	r3, #0
  207d16:	d000      	beq.n	207d1a <LCD_CopyBuff2pLcdIndirect+0x2e>
			n+=xImgWidth-windowWidth;
			offsX++;
		}
		break;
	}
}
  207d18:	e09c      	b.n	207e54 <LCD_CopyBuff2pLcdIndirect+0x168>
		for(int j=0; j<yImgHeight; ++j){
  207d1a:	2300      	movs	r3, #0
  207d1c:	633b      	str	r3, [r7, #48]	; 0x30
  207d1e:	e023      	b.n	207d68 <LCD_CopyBuff2pLcdIndirect+0x7c>
			for(int i=0; i<windowWidth; ++i)
  207d20:	2300      	movs	r3, #0
  207d22:	62fb      	str	r3, [r7, #44]	; 0x2c
  207d24:	e011      	b.n	207d4a <LCD_CopyBuff2pLcdIndirect+0x5e>
				pLcd[k++] = buff[pos+n++];
  207d26:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  207d28:	1c5a      	adds	r2, r3, #1
  207d2a:	63ba      	str	r2, [r7, #56]	; 0x38
  207d2c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  207d2e:	1c51      	adds	r1, r2, #1
  207d30:	6379      	str	r1, [r7, #52]	; 0x34
  207d32:	69b9      	ldr	r1, [r7, #24]
  207d34:	440a      	add	r2, r1
  207d36:	0092      	lsls	r2, r2, #2
  207d38:	6879      	ldr	r1, [r7, #4]
  207d3a:	440a      	add	r2, r1
  207d3c:	6812      	ldr	r2, [r2, #0]
  207d3e:	4948      	ldr	r1, [pc, #288]	; (207e60 <LCD_CopyBuff2pLcdIndirect+0x174>)
  207d40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
			for(int i=0; i<windowWidth; ++i)
  207d44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207d46:	3301      	adds	r3, #1
  207d48:	62fb      	str	r3, [r7, #44]	; 0x2c
  207d4a:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
  207d4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207d50:	429a      	cmp	r2, r3
  207d52:	dce8      	bgt.n	207d26 <LCD_CopyBuff2pLcdIndirect+0x3a>
			n+=xImgWidth-windowWidth;
  207d54:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
  207d58:	683a      	ldr	r2, [r7, #0]
  207d5a:	1ad3      	subs	r3, r2, r3
  207d5c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  207d5e:	4413      	add	r3, r2
  207d60:	637b      	str	r3, [r7, #52]	; 0x34
		for(int j=0; j<yImgHeight; ++j){
  207d62:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  207d64:	3301      	adds	r3, #1
  207d66:	633b      	str	r3, [r7, #48]	; 0x30
  207d68:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  207d6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  207d6c:	429a      	cmp	r2, r3
  207d6e:	d3d7      	bcc.n	207d20 <LCD_CopyBuff2pLcdIndirect+0x34>
		break;
  207d70:	e070      	b.n	207e54 <LCD_CopyBuff2pLcdIndirect+0x168>
		offsX=yImgHeight-1;
  207d72:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  207d74:	3b01      	subs	r3, #1
  207d76:	63fb      	str	r3, [r7, #60]	; 0x3c
		for(int j=0; j<yImgHeight; ++j){
  207d78:	2300      	movs	r3, #0
  207d7a:	62bb      	str	r3, [r7, #40]	; 0x28
  207d7c:	e029      	b.n	207dd2 <LCD_CopyBuff2pLcdIndirect+0xe6>
			for(int i=0; i<windowWidth; ++i)
  207d7e:	2300      	movs	r3, #0
  207d80:	627b      	str	r3, [r7, #36]	; 0x24
  207d82:	e014      	b.n	207dae <LCD_CopyBuff2pLcdIndirect+0xc2>
				pLcd[offsX+i*yImgHeight] = buff[pos+n++];
  207d84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207d86:	6cba      	ldr	r2, [r7, #72]	; 0x48
  207d88:	fb02 f203 	mul.w	r2, r2, r3
  207d8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207d8e:	441a      	add	r2, r3
  207d90:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  207d92:	1c59      	adds	r1, r3, #1
  207d94:	6379      	str	r1, [r7, #52]	; 0x34
  207d96:	69b9      	ldr	r1, [r7, #24]
  207d98:	440b      	add	r3, r1
  207d9a:	009b      	lsls	r3, r3, #2
  207d9c:	6879      	ldr	r1, [r7, #4]
  207d9e:	440b      	add	r3, r1
  207da0:	681b      	ldr	r3, [r3, #0]
  207da2:	492f      	ldr	r1, [pc, #188]	; (207e60 <LCD_CopyBuff2pLcdIndirect+0x174>)
  207da4:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			for(int i=0; i<windowWidth; ++i)
  207da8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207daa:	3301      	adds	r3, #1
  207dac:	627b      	str	r3, [r7, #36]	; 0x24
  207dae:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
  207db2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207db4:	429a      	cmp	r2, r3
  207db6:	dce5      	bgt.n	207d84 <LCD_CopyBuff2pLcdIndirect+0x98>
			n+=xImgWidth-windowWidth;
  207db8:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
  207dbc:	683a      	ldr	r2, [r7, #0]
  207dbe:	1ad3      	subs	r3, r2, r3
  207dc0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  207dc2:	4413      	add	r3, r2
  207dc4:	637b      	str	r3, [r7, #52]	; 0x34
			offsX--;
  207dc6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207dc8:	3b01      	subs	r3, #1
  207dca:	63fb      	str	r3, [r7, #60]	; 0x3c
		for(int j=0; j<yImgHeight; ++j){
  207dcc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  207dce:	3301      	adds	r3, #1
  207dd0:	62bb      	str	r3, [r7, #40]	; 0x28
  207dd2:	6aba      	ldr	r2, [r7, #40]	; 0x28
  207dd4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  207dd6:	429a      	cmp	r2, r3
  207dd8:	d3d1      	bcc.n	207d7e <LCD_CopyBuff2pLcdIndirect+0x92>
		break;
  207dda:	e03b      	b.n	207e54 <LCD_CopyBuff2pLcdIndirect+0x168>
		offsX=0;
  207ddc:	2300      	movs	r3, #0
  207dde:	63fb      	str	r3, [r7, #60]	; 0x3c
		offsY=param;
  207de0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  207de2:	617b      	str	r3, [r7, #20]
		for(int j=0; j<yImgHeight; ++j){
  207de4:	2300      	movs	r3, #0
  207de6:	623b      	str	r3, [r7, #32]
  207de8:	e02f      	b.n	207e4a <LCD_CopyBuff2pLcdIndirect+0x15e>
			for(int i=0; i<windowWidth; ++i)
  207dea:	2300      	movs	r3, #0
  207dec:	61fb      	str	r3, [r7, #28]
  207dee:	e01a      	b.n	207e26 <LCD_CopyBuff2pLcdIndirect+0x13a>
				pLcd[offsX+(offsY+windowWidth-1-i)*yImgHeight] = buff[pos+n++];
  207df0:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
  207df4:	697b      	ldr	r3, [r7, #20]
  207df6:	441a      	add	r2, r3
  207df8:	69fb      	ldr	r3, [r7, #28]
  207dfa:	1ad3      	subs	r3, r2, r3
  207dfc:	3b01      	subs	r3, #1
  207dfe:	6cba      	ldr	r2, [r7, #72]	; 0x48
  207e00:	fb02 f203 	mul.w	r2, r2, r3
  207e04:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207e06:	441a      	add	r2, r3
  207e08:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  207e0a:	1c59      	adds	r1, r3, #1
  207e0c:	6379      	str	r1, [r7, #52]	; 0x34
  207e0e:	69b9      	ldr	r1, [r7, #24]
  207e10:	440b      	add	r3, r1
  207e12:	009b      	lsls	r3, r3, #2
  207e14:	6879      	ldr	r1, [r7, #4]
  207e16:	440b      	add	r3, r1
  207e18:	681b      	ldr	r3, [r3, #0]
  207e1a:	4911      	ldr	r1, [pc, #68]	; (207e60 <LCD_CopyBuff2pLcdIndirect+0x174>)
  207e1c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
			for(int i=0; i<windowWidth; ++i)
  207e20:	69fb      	ldr	r3, [r7, #28]
  207e22:	3301      	adds	r3, #1
  207e24:	61fb      	str	r3, [r7, #28]
  207e26:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
  207e2a:	69fb      	ldr	r3, [r7, #28]
  207e2c:	429a      	cmp	r2, r3
  207e2e:	dcdf      	bgt.n	207df0 <LCD_CopyBuff2pLcdIndirect+0x104>
			n+=xImgWidth-windowWidth;
  207e30:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
  207e34:	683a      	ldr	r2, [r7, #0]
  207e36:	1ad3      	subs	r3, r2, r3
  207e38:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  207e3a:	4413      	add	r3, r2
  207e3c:	637b      	str	r3, [r7, #52]	; 0x34
			offsX++;
  207e3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  207e40:	3301      	adds	r3, #1
  207e42:	63fb      	str	r3, [r7, #60]	; 0x3c
		for(int j=0; j<yImgHeight; ++j){
  207e44:	6a3b      	ldr	r3, [r7, #32]
  207e46:	3301      	adds	r3, #1
  207e48:	623b      	str	r3, [r7, #32]
  207e4a:	6a3a      	ldr	r2, [r7, #32]
  207e4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  207e4e:	429a      	cmp	r2, r3
  207e50:	d3cb      	bcc.n	207dea <LCD_CopyBuff2pLcdIndirect+0xfe>
		break;
  207e52:	bf00      	nop
}
  207e54:	bf00      	nop
  207e56:	3744      	adds	r7, #68	; 0x44
  207e58:	46bd      	mov	sp, r7
  207e5a:	f85d 7b04 	ldr.w	r7, [sp], #4
  207e5e:	4770      	bx	lr
  207e60:	c0000000 	.word	0xc0000000

00207e64 <_StartLine>:

static uint32_t k;
static void _StartLine(uint32_t posBuff,uint32_t BkpSizeX,uint32_t x,uint32_t y){
  207e64:	b480      	push	{r7}
  207e66:	b085      	sub	sp, #20
  207e68:	af00      	add	r7, sp, #0
  207e6a:	60f8      	str	r0, [r7, #12]
  207e6c:	60b9      	str	r1, [r7, #8]
  207e6e:	607a      	str	r2, [r7, #4]
  207e70:	603b      	str	r3, [r7, #0]
	k=posBuff+(y*BkpSizeX+x);
  207e72:	683b      	ldr	r3, [r7, #0]
  207e74:	68ba      	ldr	r2, [r7, #8]
  207e76:	fb02 f203 	mul.w	r2, r2, r3
  207e7a:	687b      	ldr	r3, [r7, #4]
  207e7c:	441a      	add	r2, r3
  207e7e:	68fb      	ldr	r3, [r7, #12]
  207e80:	4413      	add	r3, r2
  207e82:	4a04      	ldr	r2, [pc, #16]	; (207e94 <_StartLine+0x30>)
  207e84:	6013      	str	r3, [r2, #0]
}
  207e86:	bf00      	nop
  207e88:	3714      	adds	r7, #20
  207e8a:	46bd      	mov	sp, r7
  207e8c:	f85d 7b04 	ldr.w	r7, [sp], #4
  207e90:	4770      	bx	lr
  207e92:	bf00      	nop
  207e94:	20010374 	.word	0x20010374

00207e98 <_NextLine>:
static void _NextLine(uint32_t BkpSizeX,uint32_t width){
  207e98:	b480      	push	{r7}
  207e9a:	b083      	sub	sp, #12
  207e9c:	af00      	add	r7, sp, #0
  207e9e:	6078      	str	r0, [r7, #4]
  207ea0:	6039      	str	r1, [r7, #0]
	k+=(BkpSizeX-width);
  207ea2:	687a      	ldr	r2, [r7, #4]
  207ea4:	683b      	ldr	r3, [r7, #0]
  207ea6:	1ad2      	subs	r2, r2, r3
  207ea8:	4b05      	ldr	r3, [pc, #20]	; (207ec0 <_NextLine+0x28>)
  207eaa:	681b      	ldr	r3, [r3, #0]
  207eac:	4413      	add	r3, r2
  207eae:	4a04      	ldr	r2, [pc, #16]	; (207ec0 <_NextLine+0x28>)
  207eb0:	6013      	str	r3, [r2, #0]
}
  207eb2:	bf00      	nop
  207eb4:	370c      	adds	r7, #12
  207eb6:	46bd      	mov	sp, r7
  207eb8:	f85d 7b04 	ldr.w	r7, [sp], #4
  207ebc:	4770      	bx	lr
  207ebe:	bf00      	nop
  207ec0:	20010374 	.word	0x20010374

00207ec4 <_FillBuff>:
static void _FillBuff(uint32_t *buff, int itCount, uint32_t color)
{
  207ec4:	b4b0      	push	{r4, r5, r7}
  207ec6:	b08b      	sub	sp, #44	; 0x2c
  207ec8:	af00      	add	r7, sp, #0
  207eca:	60f8      	str	r0, [r7, #12]
  207ecc:	60b9      	str	r1, [r7, #8]
  207ece:	607a      	str	r2, [r7, #4]
	if(itCount>10)
  207ed0:	68bb      	ldr	r3, [r7, #8]
  207ed2:	2b0a      	cmp	r3, #10
  207ed4:	dd56      	ble.n	207f84 <_FillBuff+0xc0>
	{
		int j=itCount/2;
  207ed6:	68bb      	ldr	r3, [r7, #8]
  207ed8:	2b00      	cmp	r3, #0
  207eda:	da00      	bge.n	207ede <_FillBuff+0x1a>
  207edc:	3301      	adds	r3, #1
  207ede:	105b      	asrs	r3, r3, #1
  207ee0:	627b      	str	r3, [r7, #36]	; 0x24
		int a=j;
  207ee2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207ee4:	61fb      	str	r3, [r7, #28]

		uint64_t *pLcd64=(uint64_t*) (buff+k);
  207ee6:	4b34      	ldr	r3, [pc, #208]	; (207fb8 <_FillBuff+0xf4>)
  207ee8:	681b      	ldr	r3, [r3, #0]
  207eea:	009b      	lsls	r3, r3, #2
  207eec:	68fa      	ldr	r2, [r7, #12]
  207eee:	4413      	add	r3, r2
  207ef0:	61bb      	str	r3, [r7, #24]
		uint64_t color64=(((uint64_t)color)<<32)|((uint64_t)color);
  207ef2:	687b      	ldr	r3, [r7, #4]
  207ef4:	461a      	mov	r2, r3
  207ef6:	f04f 0300 	mov.w	r3, #0
  207efa:	0015      	movs	r5, r2
  207efc:	2400      	movs	r4, #0
  207efe:	687b      	ldr	r3, [r7, #4]
  207f00:	461a      	mov	r2, r3
  207f02:	f04f 0300 	mov.w	r3, #0
  207f06:	ea44 0002 	orr.w	r0, r4, r2
  207f0a:	ea45 0103 	orr.w	r1, r5, r3
  207f0e:	4603      	mov	r3, r0
  207f10:	460c      	mov	r4, r1
  207f12:	e9c7 3404 	strd	r3, r4, [r7, #16]

		j--;
  207f16:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207f18:	3b01      	subs	r3, #1
  207f1a:	627b      	str	r3, [r7, #36]	; 0x24
		while (j)
  207f1c:	e009      	b.n	207f32 <_FillBuff+0x6e>
			pLcd64[j--]=color64;
  207f1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207f20:	1e5a      	subs	r2, r3, #1
  207f22:	627a      	str	r2, [r7, #36]	; 0x24
  207f24:	00db      	lsls	r3, r3, #3
  207f26:	69ba      	ldr	r2, [r7, #24]
  207f28:	441a      	add	r2, r3
  207f2a:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
  207f2e:	e882 0018 	stmia.w	r2, {r3, r4}
		while (j)
  207f32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207f34:	2b00      	cmp	r3, #0
  207f36:	d1f2      	bne.n	207f1e <_FillBuff+0x5a>

		pLcd64[j]=color64;
  207f38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207f3a:	00db      	lsls	r3, r3, #3
  207f3c:	69ba      	ldr	r2, [r7, #24]
  207f3e:	441a      	add	r2, r3
  207f40:	e9d7 3404 	ldrd	r3, r4, [r7, #16]
  207f44:	e882 0018 	stmia.w	r2, {r3, r4}
		k+=a+itCount/2;
  207f48:	68bb      	ldr	r3, [r7, #8]
  207f4a:	2b00      	cmp	r3, #0
  207f4c:	da00      	bge.n	207f50 <_FillBuff+0x8c>
  207f4e:	3301      	adds	r3, #1
  207f50:	105b      	asrs	r3, r3, #1
  207f52:	461a      	mov	r2, r3
  207f54:	69fb      	ldr	r3, [r7, #28]
  207f56:	4413      	add	r3, r2
  207f58:	461a      	mov	r2, r3
  207f5a:	4b17      	ldr	r3, [pc, #92]	; (207fb8 <_FillBuff+0xf4>)
  207f5c:	681b      	ldr	r3, [r3, #0]
  207f5e:	4413      	add	r3, r2
  207f60:	4a15      	ldr	r2, [pc, #84]	; (207fb8 <_FillBuff+0xf4>)
  207f62:	6013      	str	r3, [r2, #0]

		if (itCount%2)
  207f64:	68bb      	ldr	r3, [r7, #8]
  207f66:	f003 0301 	and.w	r3, r3, #1
  207f6a:	2b00      	cmp	r3, #0
  207f6c:	d01e      	beq.n	207fac <_FillBuff+0xe8>
			buff[k++]=color;
  207f6e:	4b12      	ldr	r3, [pc, #72]	; (207fb8 <_FillBuff+0xf4>)
  207f70:	681b      	ldr	r3, [r3, #0]
  207f72:	1c5a      	adds	r2, r3, #1
  207f74:	4910      	ldr	r1, [pc, #64]	; (207fb8 <_FillBuff+0xf4>)
  207f76:	600a      	str	r2, [r1, #0]
  207f78:	009b      	lsls	r3, r3, #2
  207f7a:	68fa      	ldr	r2, [r7, #12]
  207f7c:	4413      	add	r3, r2
  207f7e:	687a      	ldr	r2, [r7, #4]
  207f80:	601a      	str	r2, [r3, #0]
	else
	{
		for(int i=0;i<itCount;++i)
			buff[k++]=color;
	}
}
  207f82:	e013      	b.n	207fac <_FillBuff+0xe8>
		for(int i=0;i<itCount;++i)
  207f84:	2300      	movs	r3, #0
  207f86:	623b      	str	r3, [r7, #32]
  207f88:	e00c      	b.n	207fa4 <_FillBuff+0xe0>
			buff[k++]=color;
  207f8a:	4b0b      	ldr	r3, [pc, #44]	; (207fb8 <_FillBuff+0xf4>)
  207f8c:	681b      	ldr	r3, [r3, #0]
  207f8e:	1c5a      	adds	r2, r3, #1
  207f90:	4909      	ldr	r1, [pc, #36]	; (207fb8 <_FillBuff+0xf4>)
  207f92:	600a      	str	r2, [r1, #0]
  207f94:	009b      	lsls	r3, r3, #2
  207f96:	68fa      	ldr	r2, [r7, #12]
  207f98:	4413      	add	r3, r2
  207f9a:	687a      	ldr	r2, [r7, #4]
  207f9c:	601a      	str	r2, [r3, #0]
		for(int i=0;i<itCount;++i)
  207f9e:	6a3b      	ldr	r3, [r7, #32]
  207fa0:	3301      	adds	r3, #1
  207fa2:	623b      	str	r3, [r7, #32]
  207fa4:	6a3a      	ldr	r2, [r7, #32]
  207fa6:	68bb      	ldr	r3, [r7, #8]
  207fa8:	429a      	cmp	r2, r3
  207faa:	dbee      	blt.n	207f8a <_FillBuff+0xc6>
}
  207fac:	bf00      	nop
  207fae:	372c      	adds	r7, #44	; 0x2c
  207fb0:	46bd      	mov	sp, r7
  207fb2:	bcb0      	pop	{r4, r5, r7}
  207fb4:	4770      	bx	lr
  207fb6:	bf00      	nop
  207fb8:	20010374 	.word	0x20010374

00207fbc <LCD_RectangleBuff>:
static void LCD_RectangleBuff(uint32_t *buff, uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY, uint32_t x,uint32_t y, uint32_t width, uint32_t height, uint32_t FrameColor, uint32_t FillColor, uint32_t BkpColor)
{
  207fbc:	b580      	push	{r7, lr}
  207fbe:	b086      	sub	sp, #24
  207fc0:	af00      	add	r7, sp, #0
  207fc2:	60f8      	str	r0, [r7, #12]
  207fc4:	60b9      	str	r1, [r7, #8]
  207fc6:	607a      	str	r2, [r7, #4]
  207fc8:	603b      	str	r3, [r7, #0]
	_StartLine(posBuff,BkpSizeX,x,y);
  207fca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  207fcc:	6a3a      	ldr	r2, [r7, #32]
  207fce:	6879      	ldr	r1, [r7, #4]
  207fd0:	68b8      	ldr	r0, [r7, #8]
  207fd2:	f7ff ff47 	bl	207e64 <_StartLine>
	_FillBuff(buff, width, FrameColor);
  207fd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  207fd8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  207fda:	4619      	mov	r1, r3
  207fdc:	68f8      	ldr	r0, [r7, #12]
  207fde:	f7ff ff71 	bl	207ec4 <_FillBuff>
	if(height>1)
  207fe2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  207fe4:	2b01      	cmp	r3, #1
  207fe6:	d937      	bls.n	208058 <LCD_RectangleBuff+0x9c>
	{
		_NextLine(BkpSizeX,width);
  207fe8:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  207fea:	6878      	ldr	r0, [r7, #4]
  207fec:	f7ff ff54 	bl	207e98 <_NextLine>
		for (int j=0; j<height-2; j++)
  207ff0:	2300      	movs	r3, #0
  207ff2:	617b      	str	r3, [r7, #20]
  207ff4:	e025      	b.n	208042 <LCD_RectangleBuff+0x86>
		{
			if(width>1)
  207ff6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  207ff8:	2b01      	cmp	r3, #1
  207ffa:	d915      	bls.n	208028 <LCD_RectangleBuff+0x6c>
			{
				_FillBuff(buff,1, FrameColor);
  207ffc:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  207ffe:	2101      	movs	r1, #1
  208000:	68f8      	ldr	r0, [r7, #12]
  208002:	f7ff ff5f 	bl	207ec4 <_FillBuff>
				_FillBuff(buff,width-2, FillColor);
  208006:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208008:	3b02      	subs	r3, #2
  20800a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20800c:	4619      	mov	r1, r3
  20800e:	68f8      	ldr	r0, [r7, #12]
  208010:	f7ff ff58 	bl	207ec4 <_FillBuff>
				_FillBuff(buff,1, FrameColor);
  208014:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  208016:	2101      	movs	r1, #1
  208018:	68f8      	ldr	r0, [r7, #12]
  20801a:	f7ff ff53 	bl	207ec4 <_FillBuff>
				_NextLine(BkpSizeX,width);
  20801e:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  208020:	6878      	ldr	r0, [r7, #4]
  208022:	f7ff ff39 	bl	207e98 <_NextLine>
  208026:	e009      	b.n	20803c <LCD_RectangleBuff+0x80>
			}
			else
			{
				_FillBuff(buff,width, FillColor);
  208028:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20802a:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20802c:	4619      	mov	r1, r3
  20802e:	68f8      	ldr	r0, [r7, #12]
  208030:	f7ff ff48 	bl	207ec4 <_FillBuff>
				_NextLine(BkpSizeX,width);
  208034:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  208036:	6878      	ldr	r0, [r7, #4]
  208038:	f7ff ff2e 	bl	207e98 <_NextLine>
		for (int j=0; j<height-2; j++)
  20803c:	697b      	ldr	r3, [r7, #20]
  20803e:	3301      	adds	r3, #1
  208040:	617b      	str	r3, [r7, #20]
  208042:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208044:	1e9a      	subs	r2, r3, #2
  208046:	697b      	ldr	r3, [r7, #20]
  208048:	429a      	cmp	r2, r3
  20804a:	d8d4      	bhi.n	207ff6 <LCD_RectangleBuff+0x3a>
			}
		}
		_FillBuff(buff,width, FrameColor);
  20804c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20804e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  208050:	4619      	mov	r1, r3
  208052:	68f8      	ldr	r0, [r7, #12]
  208054:	f7ff ff36 	bl	207ec4 <_FillBuff>
	}
}
  208058:	bf00      	nop
  20805a:	3718      	adds	r7, #24
  20805c:	46bd      	mov	sp, r7
  20805e:	bd80      	pop	{r7, pc}

00208060 <RealizeSpaceCorrect>:

static int RealizeSpaceCorrect(char *txt, int id)
{
  208060:	b590      	push	{r4, r7, lr}
  208062:	b085      	sub	sp, #20
  208064:	af00      	add	r7, sp, #0
  208066:	6078      	str	r0, [r7, #4]
  208068:	6039      	str	r1, [r7, #0]
	if(StructSpaceCount){
  20806a:	4b30      	ldr	r3, [pc, #192]	; (20812c <RealizeSpaceCorrect+0xcc>)
  20806c:	781b      	ldrb	r3, [r3, #0]
  20806e:	2b00      	cmp	r3, #0
  208070:	d053      	beq.n	20811a <RealizeSpaceCorrect+0xba>
		for(int i=0;i < StructSpaceCount;i++){
  208072:	2300      	movs	r3, #0
  208074:	60fb      	str	r3, [r7, #12]
  208076:	e04a      	b.n	20810e <RealizeSpaceCorrect+0xae>
			if((FontID[id].style == space[i].fontStyle) && (FontID[id].size == space[i].fontSize)){
  208078:	4a2d      	ldr	r2, [pc, #180]	; (208130 <RealizeSpaceCorrect+0xd0>)
  20807a:	683b      	ldr	r3, [r7, #0]
  20807c:	011b      	lsls	r3, r3, #4
  20807e:	4413      	add	r3, r2
  208080:	3304      	adds	r3, #4
  208082:	6819      	ldr	r1, [r3, #0]
  208084:	482b      	ldr	r0, [pc, #172]	; (208134 <RealizeSpaceCorrect+0xd4>)
  208086:	68fa      	ldr	r2, [r7, #12]
  208088:	4613      	mov	r3, r2
  20808a:	009b      	lsls	r3, r3, #2
  20808c:	4413      	add	r3, r2
  20808e:	4403      	add	r3, r0
  208090:	781b      	ldrb	r3, [r3, #0]
  208092:	4299      	cmp	r1, r3
  208094:	d138      	bne.n	208108 <RealizeSpaceCorrect+0xa8>
  208096:	4a26      	ldr	r2, [pc, #152]	; (208130 <RealizeSpaceCorrect+0xd0>)
  208098:	683b      	ldr	r3, [r7, #0]
  20809a:	011b      	lsls	r3, r3, #4
  20809c:	4413      	add	r3, r2
  20809e:	6819      	ldr	r1, [r3, #0]
  2080a0:	4824      	ldr	r0, [pc, #144]	; (208134 <RealizeSpaceCorrect+0xd4>)
  2080a2:	68fa      	ldr	r2, [r7, #12]
  2080a4:	4613      	mov	r3, r2
  2080a6:	009b      	lsls	r3, r3, #2
  2080a8:	4413      	add	r3, r2
  2080aa:	4403      	add	r3, r0
  2080ac:	3301      	adds	r3, #1
  2080ae:	781b      	ldrb	r3, [r3, #0]
  2080b0:	4299      	cmp	r1, r3
  2080b2:	d129      	bne.n	208108 <RealizeSpaceCorrect+0xa8>
				if((txt[0] == space[i].char1) && (txt[1] == space[i].char2))
  2080b4:	687b      	ldr	r3, [r7, #4]
  2080b6:	7819      	ldrb	r1, [r3, #0]
  2080b8:	481e      	ldr	r0, [pc, #120]	; (208134 <RealizeSpaceCorrect+0xd4>)
  2080ba:	68fa      	ldr	r2, [r7, #12]
  2080bc:	4613      	mov	r3, r2
  2080be:	009b      	lsls	r3, r3, #2
  2080c0:	4413      	add	r3, r2
  2080c2:	4403      	add	r3, r0
  2080c4:	3302      	adds	r3, #2
  2080c6:	781b      	ldrb	r3, [r3, #0]
  2080c8:	4299      	cmp	r1, r3
  2080ca:	d11d      	bne.n	208108 <RealizeSpaceCorrect+0xa8>
  2080cc:	687b      	ldr	r3, [r7, #4]
  2080ce:	3301      	adds	r3, #1
  2080d0:	7819      	ldrb	r1, [r3, #0]
  2080d2:	4818      	ldr	r0, [pc, #96]	; (208134 <RealizeSpaceCorrect+0xd4>)
  2080d4:	68fa      	ldr	r2, [r7, #12]
  2080d6:	4613      	mov	r3, r2
  2080d8:	009b      	lsls	r3, r3, #2
  2080da:	4413      	add	r3, r2
  2080dc:	4403      	add	r3, r0
  2080de:	3303      	adds	r3, #3
  2080e0:	781b      	ldrb	r3, [r3, #0]
  2080e2:	4299      	cmp	r1, r3
  2080e4:	d110      	bne.n	208108 <RealizeSpaceCorrect+0xa8>
					return space[i].val + MyRealizeSpaceCorrect(txt,id);
  2080e6:	4913      	ldr	r1, [pc, #76]	; (208134 <RealizeSpaceCorrect+0xd4>)
  2080e8:	68fa      	ldr	r2, [r7, #12]
  2080ea:	4613      	mov	r3, r2
  2080ec:	009b      	lsls	r3, r3, #2
  2080ee:	4413      	add	r3, r2
  2080f0:	440b      	add	r3, r1
  2080f2:	3304      	adds	r3, #4
  2080f4:	f993 3000 	ldrsb.w	r3, [r3]
  2080f8:	461c      	mov	r4, r3
  2080fa:	6839      	ldr	r1, [r7, #0]
  2080fc:	6878      	ldr	r0, [r7, #4]
  2080fe:	f7ff fcfd 	bl	207afc <MyRealizeSpaceCorrect>
  208102:	4603      	mov	r3, r0
  208104:	4423      	add	r3, r4
  208106:	e00d      	b.n	208124 <RealizeSpaceCorrect+0xc4>
		for(int i=0;i < StructSpaceCount;i++){
  208108:	68fb      	ldr	r3, [r7, #12]
  20810a:	3301      	adds	r3, #1
  20810c:	60fb      	str	r3, [r7, #12]
  20810e:	4b07      	ldr	r3, [pc, #28]	; (20812c <RealizeSpaceCorrect+0xcc>)
  208110:	781b      	ldrb	r3, [r3, #0]
  208112:	461a      	mov	r2, r3
  208114:	68fb      	ldr	r3, [r7, #12]
  208116:	429a      	cmp	r2, r3
  208118:	dcae      	bgt.n	208078 <RealizeSpaceCorrect+0x18>
	}}}
	return MyRealizeSpaceCorrect(txt,id);
  20811a:	6839      	ldr	r1, [r7, #0]
  20811c:	6878      	ldr	r0, [r7, #4]
  20811e:	f7ff fced 	bl	207afc <MyRealizeSpaceCorrect>
  208122:	4603      	mov	r3, r0
}
  208124:	4618      	mov	r0, r3
  208126:	3714      	adds	r7, #20
  208128:	46bd      	mov	sp, r7
  20812a:	bd90      	pop	{r4, r7, pc}
  20812c:	2001036c 	.word	0x2001036c
  208130:	20003480 	.word	0x20003480
  208134:	20010178 	.word	0x20010178

00208138 <CorrectFloatRange>:

static void CorrectFloatRange(float *data, float rangeDown, float rangeUp)
{
  208138:	b480      	push	{r7}
  20813a:	b085      	sub	sp, #20
  20813c:	af00      	add	r7, sp, #0
  20813e:	60f8      	str	r0, [r7, #12]
  208140:	ed87 0a02 	vstr	s0, [r7, #8]
  208144:	edc7 0a01 	vstr	s1, [r7, #4]
	if(*data>rangeUp)
  208148:	68fb      	ldr	r3, [r7, #12]
  20814a:	ed93 7a00 	vldr	s14, [r3]
  20814e:	edd7 7a01 	vldr	s15, [r7, #4]
  208152:	eeb4 7ae7 	vcmpe.f32	s14, s15
  208156:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  20815a:	dd03      	ble.n	208164 <CorrectFloatRange+0x2c>
		*data=rangeUp;
  20815c:	68fb      	ldr	r3, [r7, #12]
  20815e:	687a      	ldr	r2, [r7, #4]
  208160:	601a      	str	r2, [r3, #0]
	else if(*data<rangeDown)
		*data=rangeDown;
}
  208162:	e00d      	b.n	208180 <CorrectFloatRange+0x48>
	else if(*data<rangeDown)
  208164:	68fb      	ldr	r3, [r7, #12]
  208166:	ed93 7a00 	vldr	s14, [r3]
  20816a:	edd7 7a02 	vldr	s15, [r7, #8]
  20816e:	eeb4 7ae7 	vcmpe.f32	s14, s15
  208172:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  208176:	d400      	bmi.n	20817a <CorrectFloatRange+0x42>
}
  208178:	e002      	b.n	208180 <CorrectFloatRange+0x48>
		*data=rangeDown;
  20817a:	68fb      	ldr	r3, [r7, #12]
  20817c:	68ba      	ldr	r2, [r7, #8]
  20817e:	601a      	str	r2, [r3, #0]
}
  208180:	bf00      	nop
  208182:	3714      	adds	r7, #20
  208184:	46bd      	mov	sp, r7
  208186:	f85d 7b04 	ldr.w	r7, [sp], #4
  20818a:	4770      	bx	lr
  20818c:	0000      	movs	r0, r0
	...

00208190 <_Color2YCrCb.12380>:
	coeff.colorIn[1]	= 0x00FFFFFF & colorIn_2;
	coeff.colorOut[0]	= 0x00FFFFFF & colorOut_1;
	coeff.colorOut[1]	= 0x00FFFFFF & colorOut_2;

	void _Color2YCrCb(int nr, uint32_t color, float *y, float *cr, float *cb)
	{
  208190:	b480      	push	{r7}
  208192:	b087      	sub	sp, #28
  208194:	af00      	add	r7, sp, #0
  208196:	6178      	str	r0, [r7, #20]
  208198:	6139      	str	r1, [r7, #16]
  20819a:	60fa      	str	r2, [r7, #12]
  20819c:	60bb      	str	r3, [r7, #8]
  20819e:	4663      	mov	r3, ip
  2081a0:	f8c7 c004 	str.w	ip, [r7, #4]
		R= (color>>16)&0x000000FF;
  2081a4:	693a      	ldr	r2, [r7, #16]
  2081a6:	0c12      	lsrs	r2, r2, #16
  2081a8:	b2d2      	uxtb	r2, r2
  2081aa:	609a      	str	r2, [r3, #8]
		G= (color>>8) &0x000000FF;
  2081ac:	693a      	ldr	r2, [r7, #16]
  2081ae:	0a12      	lsrs	r2, r2, #8
  2081b0:	b2d2      	uxtb	r2, r2
  2081b2:	605a      	str	r2, [r3, #4]
		B=  color     &0x000000FF;
  2081b4:	693a      	ldr	r2, [r7, #16]
  2081b6:	b2d2      	uxtb	r2, r2
  2081b8:	601a      	str	r2, [r3, #0]

		if(nr)
  2081ba:	697a      	ldr	r2, [r7, #20]
  2081bc:	2a00      	cmp	r2, #0
  2081be:	d014      	beq.n	2081ea <_Color2YCrCb.12380+0x5a>
		{
			if(R>maxVal) R=maxVal;
  2081c0:	7b1a      	ldrb	r2, [r3, #12]
  2081c2:	4611      	mov	r1, r2
  2081c4:	689a      	ldr	r2, [r3, #8]
  2081c6:	4291      	cmp	r1, r2
  2081c8:	d201      	bcs.n	2081ce <_Color2YCrCb.12380+0x3e>
  2081ca:	7b1a      	ldrb	r2, [r3, #12]
  2081cc:	609a      	str	r2, [r3, #8]
			if(G>maxVal) G=maxVal;
  2081ce:	7b1a      	ldrb	r2, [r3, #12]
  2081d0:	4611      	mov	r1, r2
  2081d2:	685a      	ldr	r2, [r3, #4]
  2081d4:	4291      	cmp	r1, r2
  2081d6:	d201      	bcs.n	2081dc <_Color2YCrCb.12380+0x4c>
  2081d8:	7b1a      	ldrb	r2, [r3, #12]
  2081da:	605a      	str	r2, [r3, #4]
			if(B>maxVal) B=maxVal;
  2081dc:	7b1a      	ldrb	r2, [r3, #12]
  2081de:	4611      	mov	r1, r2
  2081e0:	681a      	ldr	r2, [r3, #0]
  2081e2:	4291      	cmp	r1, r2
  2081e4:	d201      	bcs.n	2081ea <_Color2YCrCb.12380+0x5a>
  2081e6:	7b1a      	ldrb	r2, [r3, #12]
  2081e8:	601a      	str	r2, [r3, #0]
		}

		*y = _Y (R,G,B);
  2081ea:	689a      	ldr	r2, [r3, #8]
  2081ec:	ee07 2a90 	vmov	s15, r2
  2081f0:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2081f4:	ed9f 6b3a 	vldr	d6, [pc, #232]	; 2082e0 <_Color2YCrCb.12380+0x150>
  2081f8:	ee27 6b06 	vmul.f64	d6, d7, d6
  2081fc:	685a      	ldr	r2, [r3, #4]
  2081fe:	ee07 2a90 	vmov	s15, r2
  208202:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  208206:	ed9f 5b38 	vldr	d5, [pc, #224]	; 2082e8 <_Color2YCrCb.12380+0x158>
  20820a:	ee27 7b05 	vmul.f64	d7, d7, d5
  20820e:	ee36 6b07 	vadd.f64	d6, d6, d7
  208212:	681a      	ldr	r2, [r3, #0]
  208214:	ee07 2a90 	vmov	s15, r2
  208218:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20821c:	ed9f 5b34 	vldr	d5, [pc, #208]	; 2082f0 <_Color2YCrCb.12380+0x160>
  208220:	ee27 7b05 	vmul.f64	d7, d7, d5
  208224:	ee36 7b07 	vadd.f64	d7, d6, d7
  208228:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  20822c:	68fa      	ldr	r2, [r7, #12]
  20822e:	edc2 7a00 	vstr	s15, [r2]
		*cr= _Cr(R,G,B);
  208232:	689a      	ldr	r2, [r3, #8]
  208234:	ee07 2a90 	vmov	s15, r2
  208238:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20823c:	eeb6 6b00 	vmov.f64	d6, #96	; 0x3f000000  0.5
  208240:	ee27 7b06 	vmul.f64	d7, d7, d6
  208244:	ed9f 6b2c 	vldr	d6, [pc, #176]	; 2082f8 <_Color2YCrCb.12380+0x168>
  208248:	ee37 6b06 	vadd.f64	d6, d7, d6
  20824c:	685a      	ldr	r2, [r3, #4]
  20824e:	ee07 2a90 	vmov	s15, r2
  208252:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  208256:	ed9f 5b2a 	vldr	d5, [pc, #168]	; 208300 <_Color2YCrCb.12380+0x170>
  20825a:	ee27 7b05 	vmul.f64	d7, d7, d5
  20825e:	ee36 6b47 	vsub.f64	d6, d6, d7
  208262:	681a      	ldr	r2, [r3, #0]
  208264:	ee07 2a90 	vmov	s15, r2
  208268:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20826c:	ed9f 5b26 	vldr	d5, [pc, #152]	; 208308 <_Color2YCrCb.12380+0x178>
  208270:	ee27 7b05 	vmul.f64	d7, d7, d5
  208274:	ee36 7b47 	vsub.f64	d7, d6, d7
  208278:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  20827c:	68ba      	ldr	r2, [r7, #8]
  20827e:	edc2 7a00 	vstr	s15, [r2]
		*cb= _Cb(R,G,B);
  208282:	689a      	ldr	r2, [r3, #8]
  208284:	ee07 2a90 	vmov	s15, r2
  208288:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20828c:	ed9f 6b20 	vldr	d6, [pc, #128]	; 208310 <_Color2YCrCb.12380+0x180>
  208290:	ee27 7b06 	vmul.f64	d7, d7, d6
  208294:	ed9f 6b18 	vldr	d6, [pc, #96]	; 2082f8 <_Color2YCrCb.12380+0x168>
  208298:	ee36 6b47 	vsub.f64	d6, d6, d7
  20829c:	685a      	ldr	r2, [r3, #4]
  20829e:	ee07 2a90 	vmov	s15, r2
  2082a2:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2082a6:	ed9f 5b1c 	vldr	d5, [pc, #112]	; 208318 <_Color2YCrCb.12380+0x188>
  2082aa:	ee27 7b05 	vmul.f64	d7, d7, d5
  2082ae:	ee36 6b47 	vsub.f64	d6, d6, d7
  2082b2:	681b      	ldr	r3, [r3, #0]
  2082b4:	ee07 3a90 	vmov	s15, r3
  2082b8:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2082bc:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
  2082c0:	ee27 7b05 	vmul.f64	d7, d7, d5
  2082c4:	ee36 7b07 	vadd.f64	d7, d6, d7
  2082c8:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2082cc:	6a3b      	ldr	r3, [r7, #32]
  2082ce:	edc3 7a00 	vstr	s15, [r3]
	}
  2082d2:	bf00      	nop
  2082d4:	371c      	adds	r7, #28
  2082d6:	46bd      	mov	sp, r7
  2082d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  2082dc:	4770      	bx	lr
  2082de:	bf00      	nop
  2082e0:	e5604189 	.word	0xe5604189
  2082e4:	3fd322d0 	.word	0x3fd322d0
  2082e8:	39581062 	.word	0x39581062
  2082ec:	3fe2c8b4 	.word	0x3fe2c8b4
  2082f0:	9fbe76c9 	.word	0x9fbe76c9
  2082f4:	3fbd2f1a 	.word	0x3fbd2f1a
  2082f8:	00000000 	.word	0x00000000
  2082fc:	40600000 	.word	0x40600000
  208300:	c0ce91c9 	.word	0xc0ce91c9
  208304:	3fdacbc8 	.word	0x3fdacbc8
  208308:	fcc5b8dc 	.word	0xfcc5b8dc
  20830c:	3fb4d0dc 	.word	0x3fb4d0dc
  208310:	28d434a0 	.word	0x28d434a0
  208314:	3fc59924 	.word	0x3fc59924
  208318:	eb95e5b0 	.word	0xeb95e5b0
  20831c:	3fd5336d 	.word	0x3fd5336d

00208320 <CalculateFontCoeff>:
{
  208320:	b590      	push	{r4, r7, lr}
  208322:	b099      	sub	sp, #100	; 0x64
  208324:	af02      	add	r7, sp, #8
  208326:	60f8      	str	r0, [r7, #12]
  208328:	60b9      	str	r1, [r7, #8]
  20832a:	607a      	str	r2, [r7, #4]
  20832c:	603b      	str	r3, [r7, #0]
static void CalculateFontCoeff(uint32_t colorIn_1, uint32_t colorIn_2, uint32_t colorOut_1, uint32_t colorOut_2,uint8_t maxVal)
  20832e:	f107 0368 	add.w	r3, r7, #104	; 0x68
  208332:	627b      	str	r3, [r7, #36]	; 0x24
  208334:	f897 3068 	ldrb.w	r3, [r7, #104]	; 0x68
  208338:	f887 3020 	strb.w	r3, [r7, #32]
	coeff.colorIn[0]	= 0x00FFFFFF & colorIn_1;
  20833c:	68fb      	ldr	r3, [r7, #12]
  20833e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  208342:	4a5e      	ldr	r2, [pc, #376]	; (2084bc <CalculateFontCoeff+0x19c>)
  208344:	6013      	str	r3, [r2, #0]
	coeff.colorIn[1]	= 0x00FFFFFF & colorIn_2;
  208346:	68bb      	ldr	r3, [r7, #8]
  208348:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  20834c:	4a5b      	ldr	r2, [pc, #364]	; (2084bc <CalculateFontCoeff+0x19c>)
  20834e:	6053      	str	r3, [r2, #4]
	coeff.colorOut[0]	= 0x00FFFFFF & colorOut_1;
  208350:	687b      	ldr	r3, [r7, #4]
  208352:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  208356:	4a59      	ldr	r2, [pc, #356]	; (2084bc <CalculateFontCoeff+0x19c>)
  208358:	6093      	str	r3, [r2, #8]
	coeff.colorOut[1]	= 0x00FFFFFF & colorOut_2;
  20835a:	683b      	ldr	r3, [r7, #0]
  20835c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  208360:	4a56      	ldr	r2, [pc, #344]	; (2084bc <CalculateFontCoeff+0x19c>)
  208362:	60d3      	str	r3, [r2, #12]

	_Color2YCrCb(0,coeff.colorIn[0], &Y_in[0], &Cr_in[0], &Cb_in[0]);
  208364:	4b55      	ldr	r3, [pc, #340]	; (2084bc <CalculateFontCoeff+0x19c>)
  208366:	6819      	ldr	r1, [r3, #0]
  208368:	f107 0448 	add.w	r4, r7, #72	; 0x48
  20836c:	f107 0050 	add.w	r0, r7, #80	; 0x50
  208370:	f107 0214 	add.w	r2, r7, #20
  208374:	f107 0340 	add.w	r3, r7, #64	; 0x40
  208378:	9300      	str	r3, [sp, #0]
  20837a:	4694      	mov	ip, r2
  20837c:	4623      	mov	r3, r4
  20837e:	4602      	mov	r2, r0
  208380:	2000      	movs	r0, #0
  208382:	f7ff ff05 	bl	208190 <_Color2YCrCb.12380>
	_Color2YCrCb(0,coeff.colorIn[1], &Y_in[1], &Cr_in[1], &Cb_in[1]);
  208386:	4b4d      	ldr	r3, [pc, #308]	; (2084bc <CalculateFontCoeff+0x19c>)
  208388:	6859      	ldr	r1, [r3, #4]
  20838a:	f107 0348 	add.w	r3, r7, #72	; 0x48
  20838e:	1d1c      	adds	r4, r3, #4
  208390:	f107 0350 	add.w	r3, r7, #80	; 0x50
  208394:	1d18      	adds	r0, r3, #4
  208396:	f107 0214 	add.w	r2, r7, #20
  20839a:	f107 0340 	add.w	r3, r7, #64	; 0x40
  20839e:	3304      	adds	r3, #4
  2083a0:	9300      	str	r3, [sp, #0]
  2083a2:	4694      	mov	ip, r2
  2083a4:	4623      	mov	r3, r4
  2083a6:	4602      	mov	r2, r0
  2083a8:	2000      	movs	r0, #0
  2083aa:	f7ff fef1 	bl	208190 <_Color2YCrCb.12380>

	_Color2YCrCb(1,coeff.colorOut[0], &Y_out[0], &Cr_out[0], &Cb_out[0]);
  2083ae:	4b43      	ldr	r3, [pc, #268]	; (2084bc <CalculateFontCoeff+0x19c>)
  2083b0:	6899      	ldr	r1, [r3, #8]
  2083b2:	f107 0430 	add.w	r4, r7, #48	; 0x30
  2083b6:	f107 0038 	add.w	r0, r7, #56	; 0x38
  2083ba:	f107 0214 	add.w	r2, r7, #20
  2083be:	f107 0328 	add.w	r3, r7, #40	; 0x28
  2083c2:	9300      	str	r3, [sp, #0]
  2083c4:	4694      	mov	ip, r2
  2083c6:	4623      	mov	r3, r4
  2083c8:	4602      	mov	r2, r0
  2083ca:	2001      	movs	r0, #1
  2083cc:	f7ff fee0 	bl	208190 <_Color2YCrCb.12380>
	_Color2YCrCb(1,coeff.colorOut[1], &Y_out[1], &Cr_out[1], &Cb_out[1]);
  2083d0:	4b3a      	ldr	r3, [pc, #232]	; (2084bc <CalculateFontCoeff+0x19c>)
  2083d2:	68d9      	ldr	r1, [r3, #12]
  2083d4:	f107 0330 	add.w	r3, r7, #48	; 0x30
  2083d8:	1d1c      	adds	r4, r3, #4
  2083da:	f107 0338 	add.w	r3, r7, #56	; 0x38
  2083de:	1d18      	adds	r0, r3, #4
  2083e0:	f107 0214 	add.w	r2, r7, #20
  2083e4:	f107 0328 	add.w	r3, r7, #40	; 0x28
  2083e8:	3304      	adds	r3, #4
  2083ea:	9300      	str	r3, [sp, #0]
  2083ec:	4694      	mov	ip, r2
  2083ee:	4623      	mov	r3, r4
  2083f0:	4602      	mov	r2, r0
  2083f2:	2001      	movs	r0, #1
  2083f4:	f7ff fecc 	bl	208190 <_Color2YCrCb.12380>

	coeff.aY  = (Y_out[1] -Y_out[0])  / (Y_in[1] -Y_in[0]);
  2083f8:	ed97 7a0f 	vldr	s14, [r7, #60]	; 0x3c
  2083fc:	edd7 7a0e 	vldr	s15, [r7, #56]	; 0x38
  208400:	ee77 6a67 	vsub.f32	s13, s14, s15
  208404:	ed97 7a15 	vldr	s14, [r7, #84]	; 0x54
  208408:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
  20840c:	ee37 7a67 	vsub.f32	s14, s14, s15
  208410:	eec6 7a87 	vdiv.f32	s15, s13, s14
  208414:	4b29      	ldr	r3, [pc, #164]	; (2084bc <CalculateFontCoeff+0x19c>)
  208416:	edc3 7a04 	vstr	s15, [r3, #16]
	coeff.aCr = (Cr_out[1]-Cr_out[0]) / (Cr_in[1]-Cr_in[0]);
  20841a:	ed97 7a0d 	vldr	s14, [r7, #52]	; 0x34
  20841e:	edd7 7a0c 	vldr	s15, [r7, #48]	; 0x30
  208422:	ee77 6a67 	vsub.f32	s13, s14, s15
  208426:	ed97 7a13 	vldr	s14, [r7, #76]	; 0x4c
  20842a:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
  20842e:	ee37 7a67 	vsub.f32	s14, s14, s15
  208432:	eec6 7a87 	vdiv.f32	s15, s13, s14
  208436:	4b21      	ldr	r3, [pc, #132]	; (2084bc <CalculateFontCoeff+0x19c>)
  208438:	edc3 7a05 	vstr	s15, [r3, #20]
	coeff.aCb = (Cb_out[1]-Cb_out[0]) / (Cb_in[1]-Cb_in[0]);
  20843c:	ed97 7a0b 	vldr	s14, [r7, #44]	; 0x2c
  208440:	edd7 7a0a 	vldr	s15, [r7, #40]	; 0x28
  208444:	ee77 6a67 	vsub.f32	s13, s14, s15
  208448:	ed97 7a11 	vldr	s14, [r7, #68]	; 0x44
  20844c:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
  208450:	ee37 7a67 	vsub.f32	s14, s14, s15
  208454:	eec6 7a87 	vdiv.f32	s15, s13, s14
  208458:	4b18      	ldr	r3, [pc, #96]	; (2084bc <CalculateFontCoeff+0x19c>)
  20845a:	edc3 7a06 	vstr	s15, [r3, #24]

	coeff.bY  = Y_out[0]  - coeff.aY  * Y_in[0];
  20845e:	ed97 7a0e 	vldr	s14, [r7, #56]	; 0x38
  208462:	4b16      	ldr	r3, [pc, #88]	; (2084bc <CalculateFontCoeff+0x19c>)
  208464:	edd3 6a04 	vldr	s13, [r3, #16]
  208468:	edd7 7a14 	vldr	s15, [r7, #80]	; 0x50
  20846c:	ee66 7aa7 	vmul.f32	s15, s13, s15
  208470:	ee77 7a67 	vsub.f32	s15, s14, s15
  208474:	4b11      	ldr	r3, [pc, #68]	; (2084bc <CalculateFontCoeff+0x19c>)
  208476:	edc3 7a07 	vstr	s15, [r3, #28]
	coeff.bCr = Cr_out[0] - coeff.aCr * Cr_in[0];
  20847a:	ed97 7a0c 	vldr	s14, [r7, #48]	; 0x30
  20847e:	4b0f      	ldr	r3, [pc, #60]	; (2084bc <CalculateFontCoeff+0x19c>)
  208480:	edd3 6a05 	vldr	s13, [r3, #20]
  208484:	edd7 7a12 	vldr	s15, [r7, #72]	; 0x48
  208488:	ee66 7aa7 	vmul.f32	s15, s13, s15
  20848c:	ee77 7a67 	vsub.f32	s15, s14, s15
  208490:	4b0a      	ldr	r3, [pc, #40]	; (2084bc <CalculateFontCoeff+0x19c>)
  208492:	edc3 7a08 	vstr	s15, [r3, #32]
	coeff.bCb = Cb_out[0] - coeff.aCb * Cb_in[0];
  208496:	ed97 7a0a 	vldr	s14, [r7, #40]	; 0x28
  20849a:	4b08      	ldr	r3, [pc, #32]	; (2084bc <CalculateFontCoeff+0x19c>)
  20849c:	edd3 6a06 	vldr	s13, [r3, #24]
  2084a0:	edd7 7a10 	vldr	s15, [r7, #64]	; 0x40
  2084a4:	ee66 7aa7 	vmul.f32	s15, s13, s15
  2084a8:	ee77 7a67 	vsub.f32	s15, s14, s15
  2084ac:	4b03      	ldr	r3, [pc, #12]	; (2084bc <CalculateFontCoeff+0x19c>)
  2084ae:	edc3 7a09 	vstr	s15, [r3, #36]	; 0x24
}
  2084b2:	bf00      	nop
  2084b4:	375c      	adds	r7, #92	; 0x5c
  2084b6:	46bd      	mov	sp, r7
  2084b8:	bd90      	pop	{r4, r7, pc}
  2084ba:	bf00      	nop
  2084bc:	2000f7f0 	.word	0x2000f7f0

002084c0 <GetCalculatedRGB>:

static uint32_t GetCalculatedRGB(uint8_t red, uint8_t green, uint8_t blue)
{
  2084c0:	b580      	push	{r7, lr}
  2084c2:	b088      	sub	sp, #32
  2084c4:	af00      	add	r7, sp, #0
  2084c6:	4603      	mov	r3, r0
  2084c8:	71fb      	strb	r3, [r7, #7]
  2084ca:	460b      	mov	r3, r1
  2084cc:	71bb      	strb	r3, [r7, #6]
  2084ce:	4613      	mov	r3, r2
  2084d0:	717b      	strb	r3, [r7, #5]
	uint32_t temp = RGB2INT(red,green,blue);
  2084d2:	79fb      	ldrb	r3, [r7, #7]
  2084d4:	041a      	lsls	r2, r3, #16
  2084d6:	79bb      	ldrb	r3, [r7, #6]
  2084d8:	021b      	lsls	r3, r3, #8
  2084da:	431a      	orrs	r2, r3
  2084dc:	797b      	ldrb	r3, [r7, #5]
  2084de:	4313      	orrs	r3, r2
  2084e0:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  2084e4:	61bb      	str	r3, [r7, #24]

   for(int i=0; i<idxChangeColorBuff; i++){
  2084e6:	2300      	movs	r3, #0
  2084e8:	61fb      	str	r3, [r7, #28]
  2084ea:	e00e      	b.n	20850a <GetCalculatedRGB+0x4a>
   	if(buffChangeColorIN[i]==temp)
  2084ec:	4ab6      	ldr	r2, [pc, #728]	; (2087c8 <GetCalculatedRGB+0x308>)
  2084ee:	69fb      	ldr	r3, [r7, #28]
  2084f0:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
  2084f4:	69bb      	ldr	r3, [r7, #24]
  2084f6:	429a      	cmp	r2, r3
  2084f8:	d104      	bne.n	208504 <GetCalculatedRGB+0x44>
   			return buffChangeColorOUT[i];
  2084fa:	4ab4      	ldr	r2, [pc, #720]	; (2087cc <GetCalculatedRGB+0x30c>)
  2084fc:	69fb      	ldr	r3, [r7, #28]
  2084fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  208502:	e12d      	b.n	208760 <GetCalculatedRGB+0x2a0>
   for(int i=0; i<idxChangeColorBuff; i++){
  208504:	69fb      	ldr	r3, [r7, #28]
  208506:	3301      	adds	r3, #1
  208508:	61fb      	str	r3, [r7, #28]
  20850a:	4bb1      	ldr	r3, [pc, #708]	; (2087d0 <GetCalculatedRGB+0x310>)
  20850c:	681b      	ldr	r3, [r3, #0]
  20850e:	69fa      	ldr	r2, [r7, #28]
  208510:	429a      	cmp	r2, r3
  208512:	dbeb      	blt.n	2084ec <GetCalculatedRGB+0x2c>
   }
   buffChangeColorIN[idxChangeColorBuff]=temp;
  208514:	4bae      	ldr	r3, [pc, #696]	; (2087d0 <GetCalculatedRGB+0x310>)
  208516:	681b      	ldr	r3, [r3, #0]
  208518:	49ab      	ldr	r1, [pc, #684]	; (2087c8 <GetCalculatedRGB+0x308>)
  20851a:	69ba      	ldr	r2, [r7, #24]
  20851c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	float Y  = coeff.aY  * _Y (red,green,blue) + coeff.bY;
  208520:	4bac      	ldr	r3, [pc, #688]	; (2087d4 <GetCalculatedRGB+0x314>)
  208522:	edd3 7a04 	vldr	s15, [r3, #16]
  208526:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  20852a:	79fb      	ldrb	r3, [r7, #7]
  20852c:	ee07 3a90 	vmov	s15, r3
  208530:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  208534:	ed9f 5b8c 	vldr	d5, [pc, #560]	; 208768 <GetCalculatedRGB+0x2a8>
  208538:	ee27 5b05 	vmul.f64	d5, d7, d5
  20853c:	79bb      	ldrb	r3, [r7, #6]
  20853e:	ee07 3a90 	vmov	s15, r3
  208542:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  208546:	ed9f 4b8a 	vldr	d4, [pc, #552]	; 208770 <GetCalculatedRGB+0x2b0>
  20854a:	ee27 7b04 	vmul.f64	d7, d7, d4
  20854e:	ee35 5b07 	vadd.f64	d5, d5, d7
  208552:	797b      	ldrb	r3, [r7, #5]
  208554:	ee07 3a90 	vmov	s15, r3
  208558:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  20855c:	ed9f 4b86 	vldr	d4, [pc, #536]	; 208778 <GetCalculatedRGB+0x2b8>
  208560:	ee27 7b04 	vmul.f64	d7, d7, d4
  208564:	ee35 7b07 	vadd.f64	d7, d5, d7
  208568:	ee26 6b07 	vmul.f64	d6, d6, d7
  20856c:	4b99      	ldr	r3, [pc, #612]	; (2087d4 <GetCalculatedRGB+0x314>)
  20856e:	edd3 7a07 	vldr	s15, [r3, #28]
  208572:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  208576:	ee36 7b07 	vadd.f64	d7, d6, d7
  20857a:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  20857e:	edc7 7a05 	vstr	s15, [r7, #20]
	float Cr = coeff.aCr * _Cr(red,green,blue) + coeff.bCr;
  208582:	4b94      	ldr	r3, [pc, #592]	; (2087d4 <GetCalculatedRGB+0x314>)
  208584:	edd3 7a05 	vldr	s15, [r3, #20]
  208588:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  20858c:	79fb      	ldrb	r3, [r7, #7]
  20858e:	ee07 3a90 	vmov	s15, r3
  208592:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  208596:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
  20859a:	ee27 7b05 	vmul.f64	d7, d7, d5
  20859e:	ed9f 5b78 	vldr	d5, [pc, #480]	; 208780 <GetCalculatedRGB+0x2c0>
  2085a2:	ee37 5b05 	vadd.f64	d5, d7, d5
  2085a6:	79bb      	ldrb	r3, [r7, #6]
  2085a8:	ee07 3a90 	vmov	s15, r3
  2085ac:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  2085b0:	ed9f 4b75 	vldr	d4, [pc, #468]	; 208788 <GetCalculatedRGB+0x2c8>
  2085b4:	ee27 7b04 	vmul.f64	d7, d7, d4
  2085b8:	ee35 5b47 	vsub.f64	d5, d5, d7
  2085bc:	797b      	ldrb	r3, [r7, #5]
  2085be:	ee07 3a90 	vmov	s15, r3
  2085c2:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  2085c6:	ed9f 4b72 	vldr	d4, [pc, #456]	; 208790 <GetCalculatedRGB+0x2d0>
  2085ca:	ee27 7b04 	vmul.f64	d7, d7, d4
  2085ce:	ee35 7b47 	vsub.f64	d7, d5, d7
  2085d2:	ee26 6b07 	vmul.f64	d6, d6, d7
  2085d6:	4b7f      	ldr	r3, [pc, #508]	; (2087d4 <GetCalculatedRGB+0x314>)
  2085d8:	edd3 7a08 	vldr	s15, [r3, #32]
  2085dc:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2085e0:	ee36 7b07 	vadd.f64	d7, d6, d7
  2085e4:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  2085e8:	edc7 7a04 	vstr	s15, [r7, #16]
	float Cb = coeff.aCb * _Cb(red,green,blue) + coeff.bCb;
  2085ec:	4b79      	ldr	r3, [pc, #484]	; (2087d4 <GetCalculatedRGB+0x314>)
  2085ee:	edd3 7a06 	vldr	s15, [r3, #24]
  2085f2:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  2085f6:	79fb      	ldrb	r3, [r7, #7]
  2085f8:	ee07 3a90 	vmov	s15, r3
  2085fc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  208600:	ed9f 5b65 	vldr	d5, [pc, #404]	; 208798 <GetCalculatedRGB+0x2d8>
  208604:	ee27 7b05 	vmul.f64	d7, d7, d5
  208608:	ed9f 5b5d 	vldr	d5, [pc, #372]	; 208780 <GetCalculatedRGB+0x2c0>
  20860c:	ee35 5b47 	vsub.f64	d5, d5, d7
  208610:	79bb      	ldrb	r3, [r7, #6]
  208612:	ee07 3a90 	vmov	s15, r3
  208616:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  20861a:	ed9f 4b61 	vldr	d4, [pc, #388]	; 2087a0 <GetCalculatedRGB+0x2e0>
  20861e:	ee27 7b04 	vmul.f64	d7, d7, d4
  208622:	ee35 5b47 	vsub.f64	d5, d5, d7
  208626:	797b      	ldrb	r3, [r7, #5]
  208628:	ee07 3a90 	vmov	s15, r3
  20862c:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  208630:	eeb6 4b00 	vmov.f64	d4, #96	; 0x3f000000  0.5
  208634:	ee27 7b04 	vmul.f64	d7, d7, d4
  208638:	ee35 7b07 	vadd.f64	d7, d5, d7
  20863c:	ee26 6b07 	vmul.f64	d6, d6, d7
  208640:	4b64      	ldr	r3, [pc, #400]	; (2087d4 <GetCalculatedRGB+0x314>)
  208642:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
  208646:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  20864a:	ee36 7b07 	vadd.f64	d7, d6, d7
  20864e:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  208652:	edc7 7a03 	vstr	s15, [r7, #12]

	CorrectFloatRange(&Y,0,255);
  208656:	f107 0314 	add.w	r3, r7, #20
  20865a:	eddf 0a5f 	vldr	s1, [pc, #380]	; 2087d8 <GetCalculatedRGB+0x318>
  20865e:	ed9f 0a5f 	vldr	s0, [pc, #380]	; 2087dc <GetCalculatedRGB+0x31c>
  208662:	4618      	mov	r0, r3
  208664:	f7ff fd68 	bl	208138 <CorrectFloatRange>
	CorrectFloatRange(&Cr,0,255);
  208668:	f107 0310 	add.w	r3, r7, #16
  20866c:	eddf 0a5a 	vldr	s1, [pc, #360]	; 2087d8 <GetCalculatedRGB+0x318>
  208670:	ed9f 0a5a 	vldr	s0, [pc, #360]	; 2087dc <GetCalculatedRGB+0x31c>
  208674:	4618      	mov	r0, r3
  208676:	f7ff fd5f 	bl	208138 <CorrectFloatRange>
	CorrectFloatRange(&Cb,0,255);
  20867a:	f107 030c 	add.w	r3, r7, #12
  20867e:	eddf 0a56 	vldr	s1, [pc, #344]	; 2087d8 <GetCalculatedRGB+0x318>
  208682:	ed9f 0a56 	vldr	s0, [pc, #344]	; 2087dc <GetCalculatedRGB+0x31c>
  208686:	4618      	mov	r0, r3
  208688:	f7ff fd56 	bl	208138 <CorrectFloatRange>

	temp = RGB2INT((uint32_t)_R(Y,Cb,Cr),(uint32_t)_G(Y,Cb,Cr),(uint32_t)_B(Y,Cb,Cr));
  20868c:	edd7 7a05 	vldr	s15, [r7, #20]
  208690:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  208694:	edd7 7a04 	vldr	s15, [r7, #16]
  208698:	ed9f 7a51 	vldr	s14, [pc, #324]	; 2087e0 <GetCalculatedRGB+0x320>
  20869c:	ee77 7ac7 	vsub.f32	s15, s15, s14
  2086a0:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2086a4:	ed9f 5b40 	vldr	d5, [pc, #256]	; 2087a8 <GetCalculatedRGB+0x2e8>
  2086a8:	ee27 7b05 	vmul.f64	d7, d7, d5
  2086ac:	ee36 7b07 	vadd.f64	d7, d6, d7
  2086b0:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  2086b4:	ee17 3a90 	vmov	r3, s15
  2086b8:	041a      	lsls	r2, r3, #16
  2086ba:	edd7 7a05 	vldr	s15, [r7, #20]
  2086be:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  2086c2:	edd7 7a03 	vldr	s15, [r7, #12]
  2086c6:	ed9f 7a46 	vldr	s14, [pc, #280]	; 2087e0 <GetCalculatedRGB+0x320>
  2086ca:	ee77 7ac7 	vsub.f32	s15, s15, s14
  2086ce:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2086d2:	ed9f 5b37 	vldr	d5, [pc, #220]	; 2087b0 <GetCalculatedRGB+0x2f0>
  2086d6:	ee27 7b05 	vmul.f64	d7, d7, d5
  2086da:	ee36 6b47 	vsub.f64	d6, d6, d7
  2086de:	edd7 7a04 	vldr	s15, [r7, #16]
  2086e2:	ed9f 7a3f 	vldr	s14, [pc, #252]	; 2087e0 <GetCalculatedRGB+0x320>
  2086e6:	ee77 7ac7 	vsub.f32	s15, s15, s14
  2086ea:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  2086ee:	ed9f 5b32 	vldr	d5, [pc, #200]	; 2087b8 <GetCalculatedRGB+0x2f8>
  2086f2:	ee27 7b05 	vmul.f64	d7, d7, d5
  2086f6:	ee36 7b47 	vsub.f64	d7, d6, d7
  2086fa:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  2086fe:	ee17 3a90 	vmov	r3, s15
  208702:	021b      	lsls	r3, r3, #8
  208704:	4313      	orrs	r3, r2
  208706:	edd7 7a05 	vldr	s15, [r7, #20]
  20870a:	eeb7 6ae7 	vcvt.f64.f32	d6, s15
  20870e:	edd7 7a03 	vldr	s15, [r7, #12]
  208712:	ed9f 7a33 	vldr	s14, [pc, #204]	; 2087e0 <GetCalculatedRGB+0x320>
  208716:	ee77 7ac7 	vsub.f32	s15, s15, s14
  20871a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  20871e:	ed9f 5b28 	vldr	d5, [pc, #160]	; 2087c0 <GetCalculatedRGB+0x300>
  208722:	ee27 7b05 	vmul.f64	d7, d7, d5
  208726:	ee36 7b07 	vadd.f64	d7, d6, d7
  20872a:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  20872e:	ee17 2a90 	vmov	r2, s15
  208732:	4313      	orrs	r3, r2
  208734:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  208738:	61bb      	str	r3, [r7, #24]

   buffChangeColorOUT[idxChangeColorBuff++]=temp;
  20873a:	4b25      	ldr	r3, [pc, #148]	; (2087d0 <GetCalculatedRGB+0x310>)
  20873c:	681b      	ldr	r3, [r3, #0]
  20873e:	1c5a      	adds	r2, r3, #1
  208740:	4923      	ldr	r1, [pc, #140]	; (2087d0 <GetCalculatedRGB+0x310>)
  208742:	600a      	str	r2, [r1, #0]
  208744:	4921      	ldr	r1, [pc, #132]	; (2087cc <GetCalculatedRGB+0x30c>)
  208746:	69ba      	ldr	r2, [r7, #24]
  208748:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
   if(idxChangeColorBuff>MAX_SIZE_CHANGECOLOR_BUFF){
  20874c:	4b20      	ldr	r3, [pc, #128]	; (2087d0 <GetCalculatedRGB+0x310>)
  20874e:	681b      	ldr	r3, [r3, #0]
  208750:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
  208754:	dd03      	ble.n	20875e <GetCalculatedRGB+0x29e>
   	ERROR_StrChangeColor();
  208756:	f7f8 fcc9 	bl	2010ec <ERROR_StrChangeColor>
   	return 0;
  20875a:	2300      	movs	r3, #0
  20875c:	e000      	b.n	208760 <GetCalculatedRGB+0x2a0>
   }
	return temp;
  20875e:	69bb      	ldr	r3, [r7, #24]
}
  208760:	4618      	mov	r0, r3
  208762:	3720      	adds	r7, #32
  208764:	46bd      	mov	sp, r7
  208766:	bd80      	pop	{r7, pc}
  208768:	e5604189 	.word	0xe5604189
  20876c:	3fd322d0 	.word	0x3fd322d0
  208770:	39581062 	.word	0x39581062
  208774:	3fe2c8b4 	.word	0x3fe2c8b4
  208778:	9fbe76c9 	.word	0x9fbe76c9
  20877c:	3fbd2f1a 	.word	0x3fbd2f1a
  208780:	00000000 	.word	0x00000000
  208784:	40600000 	.word	0x40600000
  208788:	c0ce91c9 	.word	0xc0ce91c9
  20878c:	3fdacbc8 	.word	0x3fdacbc8
  208790:	fcc5b8dc 	.word	0xfcc5b8dc
  208794:	3fb4d0dc 	.word	0x3fb4d0dc
  208798:	28d434a0 	.word	0x28d434a0
  20879c:	3fc59924 	.word	0x3fc59924
  2087a0:	eb95e5b0 	.word	0xeb95e5b0
  2087a4:	3fd5336d 	.word	0x3fd5336d
  2087a8:	8d4fdf3b 	.word	0x8d4fdf3b
  2087ac:	3ff66e97 	.word	0x3ff66e97
  2087b0:	c74fb54a 	.word	0xc74fb54a
  2087b4:	3fd60663 	.word	0x3fd60663
  2087b8:	21187e7c 	.word	0x21187e7c
  2087bc:	3fe6da3c 	.word	0x3fe6da3c
  2087c0:	ac083127 	.word	0xac083127
  2087c4:	3ffc5a1c 	.word	0x3ffc5a1c
  2087c8:	20002310 	.word	0x20002310
  2087cc:	200027c0 	.word	0x200027c0
  2087d0:	20002c70 	.word	0x20002c70
  2087d4:	2000f7f0 	.word	0x2000f7f0
  2087d8:	437f0000 	.word	0x437f0000
  2087dc:	00000000 	.word	0x00000000
  2087e0:	43000000 	.word	0x43000000

002087e4 <LoadFontIndex>:

static int LoadFontIndex(int fontSize, int fontStyle, uint32_t backgroundColor, uint32_t fontColor)
{
  2087e4:	b480      	push	{r7}
  2087e6:	b087      	sub	sp, #28
  2087e8:	af00      	add	r7, sp, #0
  2087ea:	60f8      	str	r0, [r7, #12]
  2087ec:	60b9      	str	r1, [r7, #8]
  2087ee:	607a      	str	r2, [r7, #4]
  2087f0:	603b      	str	r3, [r7, #0]
    int i;
    for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  2087f2:	2300      	movs	r3, #0
  2087f4:	617b      	str	r3, [r7, #20]
  2087f6:	e037      	b.n	208868 <LoadFontIndex+0x84>
    {
    	if(0==Font[i].fontSizeToIndex)
  2087f8:	4921      	ldr	r1, [pc, #132]	; (208880 <LoadFontIndex+0x9c>)
  2087fa:	697a      	ldr	r2, [r7, #20]
  2087fc:	4613      	mov	r3, r2
  2087fe:	019b      	lsls	r3, r3, #6
  208800:	4413      	add	r3, r2
  208802:	015b      	lsls	r3, r3, #5
  208804:	440b      	add	r3, r1
  208806:	681b      	ldr	r3, [r3, #0]
  208808:	2b00      	cmp	r3, #0
  20880a:	d12a      	bne.n	208862 <LoadFontIndex+0x7e>
    	{
    		Font[i].fontSizeToIndex = fontSize+1;
  20880c:	68fb      	ldr	r3, [r7, #12]
  20880e:	3301      	adds	r3, #1
  208810:	4618      	mov	r0, r3
  208812:	491b      	ldr	r1, [pc, #108]	; (208880 <LoadFontIndex+0x9c>)
  208814:	697a      	ldr	r2, [r7, #20]
  208816:	4613      	mov	r3, r2
  208818:	019b      	lsls	r3, r3, #6
  20881a:	4413      	add	r3, r2
  20881c:	015b      	lsls	r3, r3, #5
  20881e:	440b      	add	r3, r1
  208820:	6018      	str	r0, [r3, #0]
    		Font[i].fontStyleToIndex = fontStyle;
  208822:	68b9      	ldr	r1, [r7, #8]
  208824:	4816      	ldr	r0, [pc, #88]	; (208880 <LoadFontIndex+0x9c>)
  208826:	697a      	ldr	r2, [r7, #20]
  208828:	4613      	mov	r3, r2
  20882a:	019b      	lsls	r3, r3, #6
  20882c:	4413      	add	r3, r2
  20882e:	015b      	lsls	r3, r3, #5
  208830:	4403      	add	r3, r0
  208832:	3304      	adds	r3, #4
  208834:	6019      	str	r1, [r3, #0]
    		Font[i].fontBkColorToIndex = backgroundColor;
  208836:	4912      	ldr	r1, [pc, #72]	; (208880 <LoadFontIndex+0x9c>)
  208838:	697a      	ldr	r2, [r7, #20]
  20883a:	4613      	mov	r3, r2
  20883c:	019b      	lsls	r3, r3, #6
  20883e:	4413      	add	r3, r2
  208840:	015b      	lsls	r3, r3, #5
  208842:	440b      	add	r3, r1
  208844:	3308      	adds	r3, #8
  208846:	687a      	ldr	r2, [r7, #4]
  208848:	601a      	str	r2, [r3, #0]
    		Font[i].fontColorToIndex = fontColor;
  20884a:	490d      	ldr	r1, [pc, #52]	; (208880 <LoadFontIndex+0x9c>)
  20884c:	697a      	ldr	r2, [r7, #20]
  20884e:	4613      	mov	r3, r2
  208850:	019b      	lsls	r3, r3, #6
  208852:	4413      	add	r3, r2
  208854:	015b      	lsls	r3, r3, #5
  208856:	440b      	add	r3, r1
  208858:	330c      	adds	r3, #12
  20885a:	683a      	ldr	r2, [r7, #0]
  20885c:	601a      	str	r2, [r3, #0]
    		return i;
  20885e:	697b      	ldr	r3, [r7, #20]
  208860:	e007      	b.n	208872 <LoadFontIndex+0x8e>
    for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  208862:	697b      	ldr	r3, [r7, #20]
  208864:	3301      	adds	r3, #1
  208866:	617b      	str	r3, [r7, #20]
  208868:	697b      	ldr	r3, [r7, #20]
  20886a:	2b10      	cmp	r3, #16
  20886c:	ddc4      	ble.n	2087f8 <LoadFontIndex+0x14>
    	}
    }
    return -1;
  20886e:	f04f 33ff 	mov.w	r3, #4294967295
}
  208872:	4618      	mov	r0, r3
  208874:	371c      	adds	r7, #28
  208876:	46bd      	mov	sp, r7
  208878:	f85d 7b04 	ldr.w	r7, [sp], #4
  20887c:	4770      	bx	lr
  20887e:	bf00      	nop
  208880:	20003590 	.word	0x20003590

00208884 <SearchFontIndex>:

static int SearchFontIndex(int fontSize, int fontStyle, uint32_t backgroundColor, uint32_t fontColor)
{
  208884:	b480      	push	{r7}
  208886:	b087      	sub	sp, #28
  208888:	af00      	add	r7, sp, #0
  20888a:	60f8      	str	r0, [r7, #12]
  20888c:	60b9      	str	r1, [r7, #8]
  20888e:	607a      	str	r2, [r7, #4]
  208890:	603b      	str	r3, [r7, #0]
    int i;
    for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  208892:	2300      	movs	r3, #0
  208894:	617b      	str	r3, [r7, #20]
  208896:	e035      	b.n	208904 <SearchFontIndex+0x80>
    {
    	if(((fontSize+1)	==	Font[i].fontSizeToIndex)&&
  208898:	68fb      	ldr	r3, [r7, #12]
  20889a:	3301      	adds	r3, #1
  20889c:	4618      	mov	r0, r3
  20889e:	491f      	ldr	r1, [pc, #124]	; (20891c <SearchFontIndex+0x98>)
  2088a0:	697a      	ldr	r2, [r7, #20]
  2088a2:	4613      	mov	r3, r2
  2088a4:	019b      	lsls	r3, r3, #6
  2088a6:	4413      	add	r3, r2
  2088a8:	015b      	lsls	r3, r3, #5
  2088aa:	440b      	add	r3, r1
  2088ac:	681b      	ldr	r3, [r3, #0]
  2088ae:	4298      	cmp	r0, r3
  2088b0:	d125      	bne.n	2088fe <SearchFontIndex+0x7a>
    		(fontStyle	    ==	Font[i].fontStyleToIndex)&&
  2088b2:	491a      	ldr	r1, [pc, #104]	; (20891c <SearchFontIndex+0x98>)
  2088b4:	697a      	ldr	r2, [r7, #20]
  2088b6:	4613      	mov	r3, r2
  2088b8:	019b      	lsls	r3, r3, #6
  2088ba:	4413      	add	r3, r2
  2088bc:	015b      	lsls	r3, r3, #5
  2088be:	440b      	add	r3, r1
  2088c0:	3304      	adds	r3, #4
  2088c2:	681a      	ldr	r2, [r3, #0]
  2088c4:	68bb      	ldr	r3, [r7, #8]
    	if(((fontSize+1)	==	Font[i].fontSizeToIndex)&&
  2088c6:	429a      	cmp	r2, r3
  2088c8:	d119      	bne.n	2088fe <SearchFontIndex+0x7a>
			(backgroundColor==	Font[i].fontBkColorToIndex)&&
  2088ca:	4914      	ldr	r1, [pc, #80]	; (20891c <SearchFontIndex+0x98>)
  2088cc:	697a      	ldr	r2, [r7, #20]
  2088ce:	4613      	mov	r3, r2
  2088d0:	019b      	lsls	r3, r3, #6
  2088d2:	4413      	add	r3, r2
  2088d4:	015b      	lsls	r3, r3, #5
  2088d6:	440b      	add	r3, r1
  2088d8:	3308      	adds	r3, #8
  2088da:	681a      	ldr	r2, [r3, #0]
    		(fontStyle	    ==	Font[i].fontStyleToIndex)&&
  2088dc:	687b      	ldr	r3, [r7, #4]
  2088de:	429a      	cmp	r2, r3
  2088e0:	d10d      	bne.n	2088fe <SearchFontIndex+0x7a>
			(fontColor	    ==	Font[i].fontColorToIndex))
  2088e2:	490e      	ldr	r1, [pc, #56]	; (20891c <SearchFontIndex+0x98>)
  2088e4:	697a      	ldr	r2, [r7, #20]
  2088e6:	4613      	mov	r3, r2
  2088e8:	019b      	lsls	r3, r3, #6
  2088ea:	4413      	add	r3, r2
  2088ec:	015b      	lsls	r3, r3, #5
  2088ee:	440b      	add	r3, r1
  2088f0:	330c      	adds	r3, #12
  2088f2:	681a      	ldr	r2, [r3, #0]
			(backgroundColor==	Font[i].fontBkColorToIndex)&&
  2088f4:	683b      	ldr	r3, [r7, #0]
  2088f6:	429a      	cmp	r2, r3
  2088f8:	d101      	bne.n	2088fe <SearchFontIndex+0x7a>
    		return i;
  2088fa:	697b      	ldr	r3, [r7, #20]
  2088fc:	e007      	b.n	20890e <SearchFontIndex+0x8a>
    for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  2088fe:	697b      	ldr	r3, [r7, #20]
  208900:	3301      	adds	r3, #1
  208902:	617b      	str	r3, [r7, #20]
  208904:	697b      	ldr	r3, [r7, #20]
  208906:	2b10      	cmp	r3, #16
  208908:	ddc6      	ble.n	208898 <SearchFontIndex+0x14>
    }
    return -1;
  20890a:	f04f 33ff 	mov.w	r3, #4294967295
}
  20890e:	4618      	mov	r0, r3
  208910:	371c      	adds	r7, #28
  208912:	46bd      	mov	sp, r7
  208914:	f85d 7b04 	ldr.w	r7, [sp], #4
  208918:	4770      	bx	lr
  20891a:	bf00      	nop
  20891c:	20003590 	.word	0x20003590

00208920 <ReturnFontSize>:

static uint8_t ReturnFontSize(int fontIndex){
  208920:	b480      	push	{r7}
  208922:	b083      	sub	sp, #12
  208924:	af00      	add	r7, sp, #0
  208926:	6078      	str	r0, [r7, #4]
	return Font[fontIndex].fontSizeToIndex-1;
  208928:	4908      	ldr	r1, [pc, #32]	; (20894c <ReturnFontSize+0x2c>)
  20892a:	687a      	ldr	r2, [r7, #4]
  20892c:	4613      	mov	r3, r2
  20892e:	019b      	lsls	r3, r3, #6
  208930:	4413      	add	r3, r2
  208932:	015b      	lsls	r3, r3, #5
  208934:	440b      	add	r3, r1
  208936:	681b      	ldr	r3, [r3, #0]
  208938:	b2db      	uxtb	r3, r3
  20893a:	3b01      	subs	r3, #1
  20893c:	b2db      	uxtb	r3, r3
}
  20893e:	4618      	mov	r0, r3
  208940:	370c      	adds	r7, #12
  208942:	46bd      	mov	sp, r7
  208944:	f85d 7b04 	ldr.w	r7, [sp], #4
  208948:	4770      	bx	lr
  20894a:	bf00      	nop
  20894c:	20003590 	.word	0x20003590

00208950 <SetFontHeightHalf>:

static void SetFontHeightHalf(int fontIndex, int heightHalf){
  208950:	b480      	push	{r7}
  208952:	b083      	sub	sp, #12
  208954:	af00      	add	r7, sp, #0
  208956:	6078      	str	r0, [r7, #4]
  208958:	6039      	str	r1, [r7, #0]
	Font[fontIndex].heightHalf = heightHalf;
  20895a:	4908      	ldr	r1, [pc, #32]	; (20897c <SetFontHeightHalf+0x2c>)
  20895c:	687a      	ldr	r2, [r7, #4]
  20895e:	4613      	mov	r3, r2
  208960:	019b      	lsls	r3, r3, #6
  208962:	4413      	add	r3, r2
  208964:	015b      	lsls	r3, r3, #5
  208966:	440b      	add	r3, r1
  208968:	f603 0314 	addw	r3, r3, #2068	; 0x814
  20896c:	683a      	ldr	r2, [r7, #0]
  20896e:	601a      	str	r2, [r3, #0]
}
  208970:	bf00      	nop
  208972:	370c      	adds	r7, #12
  208974:	46bd      	mov	sp, r7
  208976:	f85d 7b04 	ldr.w	r7, [sp], #4
  20897a:	4770      	bx	lr
  20897c:	20003590 	.word	0x20003590

00208980 <LCD_GetFontID>:

static int LCD_GetFontID(int fontSize, int fontStyle, uint32_t backgroundColor, uint32_t fontColor)
{
  208980:	b480      	push	{r7}
  208982:	b087      	sub	sp, #28
  208984:	af00      	add	r7, sp, #0
  208986:	60f8      	str	r0, [r7, #12]
  208988:	60b9      	str	r1, [r7, #8]
  20898a:	607a      	str	r2, [r7, #4]
  20898c:	603b      	str	r3, [r7, #0]
    int i;
    for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  20898e:	2300      	movs	r3, #0
  208990:	617b      	str	r3, [r7, #20]
  208992:	e027      	b.n	2089e4 <LCD_GetFontID+0x64>
    {
    	if((fontSize			==	FontID[i].size)&&
  208994:	4a19      	ldr	r2, [pc, #100]	; (2089fc <LCD_GetFontID+0x7c>)
  208996:	697b      	ldr	r3, [r7, #20]
  208998:	011b      	lsls	r3, r3, #4
  20899a:	4413      	add	r3, r2
  20899c:	681a      	ldr	r2, [r3, #0]
  20899e:	68fb      	ldr	r3, [r7, #12]
  2089a0:	429a      	cmp	r2, r3
  2089a2:	d11c      	bne.n	2089de <LCD_GetFontID+0x5e>
    	   (fontStyle	    	==	FontID[i].style)&&
  2089a4:	4a15      	ldr	r2, [pc, #84]	; (2089fc <LCD_GetFontID+0x7c>)
  2089a6:	697b      	ldr	r3, [r7, #20]
  2089a8:	011b      	lsls	r3, r3, #4
  2089aa:	4413      	add	r3, r2
  2089ac:	3304      	adds	r3, #4
  2089ae:	681a      	ldr	r2, [r3, #0]
  2089b0:	68bb      	ldr	r3, [r7, #8]
    	if((fontSize			==	FontID[i].size)&&
  2089b2:	429a      	cmp	r2, r3
  2089b4:	d113      	bne.n	2089de <LCD_GetFontID+0x5e>
		   (backgroundColor	==	FontID[i].bkColor)&&
  2089b6:	4a11      	ldr	r2, [pc, #68]	; (2089fc <LCD_GetFontID+0x7c>)
  2089b8:	697b      	ldr	r3, [r7, #20]
  2089ba:	011b      	lsls	r3, r3, #4
  2089bc:	4413      	add	r3, r2
  2089be:	3308      	adds	r3, #8
  2089c0:	681a      	ldr	r2, [r3, #0]
    	   (fontStyle	    	==	FontID[i].style)&&
  2089c2:	687b      	ldr	r3, [r7, #4]
  2089c4:	429a      	cmp	r2, r3
  2089c6:	d10a      	bne.n	2089de <LCD_GetFontID+0x5e>
		   (fontColor	   	==	FontID[i].color))
  2089c8:	4a0c      	ldr	r2, [pc, #48]	; (2089fc <LCD_GetFontID+0x7c>)
  2089ca:	697b      	ldr	r3, [r7, #20]
  2089cc:	011b      	lsls	r3, r3, #4
  2089ce:	4413      	add	r3, r2
  2089d0:	330c      	adds	r3, #12
  2089d2:	681a      	ldr	r2, [r3, #0]
		   (backgroundColor	==	FontID[i].bkColor)&&
  2089d4:	683b      	ldr	r3, [r7, #0]
  2089d6:	429a      	cmp	r2, r3
  2089d8:	d101      	bne.n	2089de <LCD_GetFontID+0x5e>
    			return i;
  2089da:	697b      	ldr	r3, [r7, #20]
  2089dc:	e007      	b.n	2089ee <LCD_GetFontID+0x6e>
    for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  2089de:	697b      	ldr	r3, [r7, #20]
  2089e0:	3301      	adds	r3, #1
  2089e2:	617b      	str	r3, [r7, #20]
  2089e4:	697b      	ldr	r3, [r7, #20]
  2089e6:	2b10      	cmp	r3, #16
  2089e8:	ddd4      	ble.n	208994 <LCD_GetFontID+0x14>
    }
    return -1;
  2089ea:	f04f 33ff 	mov.w	r3, #4294967295
}
  2089ee:	4618      	mov	r0, r3
  2089f0:	371c      	adds	r7, #28
  2089f2:	46bd      	mov	sp, r7
  2089f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  2089f8:	4770      	bx	lr
  2089fa:	bf00      	nop
  2089fc:	20003480 	.word	0x20003480

00208a00 <DynamicFontMemoryAllocation>:

static bool DynamicFontMemoryAllocation(uint32_t fontFileSize, int fontIndex)
{
  208a00:	b480      	push	{r7}
  208a02:	b083      	sub	sp, #12
  208a04:	af00      	add	r7, sp, #0
  208a06:	6078      	str	r0, [r7, #4]
  208a08:	6039      	str	r1, [r7, #0]
	if(CounterBusyBytesForFontsImages+fontFileSize < MAX_FONTS_AND_IMAGES_MEMORY_SIZE)
  208a0a:	4b17      	ldr	r3, [pc, #92]	; (208a68 <DynamicFontMemoryAllocation+0x68>)
  208a0c:	681a      	ldr	r2, [r3, #0]
  208a0e:	687b      	ldr	r3, [r7, #4]
  208a10:	4413      	add	r3, r2
  208a12:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
  208a16:	d220      	bcs.n	208a5a <DynamicFontMemoryAllocation+0x5a>
	{
		Font[fontIndex].fontSdramLenght=fontFileSize;
  208a18:	4914      	ldr	r1, [pc, #80]	; (208a6c <DynamicFontMemoryAllocation+0x6c>)
  208a1a:	683a      	ldr	r2, [r7, #0]
  208a1c:	4613      	mov	r3, r2
  208a1e:	019b      	lsls	r3, r3, #6
  208a20:	4413      	add	r3, r2
  208a22:	015b      	lsls	r3, r3, #5
  208a24:	440b      	add	r3, r1
  208a26:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  208a2a:	687a      	ldr	r2, [r7, #4]
  208a2c:	601a      	str	r2, [r3, #0]
		Font[fontIndex].pointerToMemoryFont=(char*)( fontsImagesMemoryBuffer + CounterBusyBytesForFontsImages );
  208a2e:	4b0e      	ldr	r3, [pc, #56]	; (208a68 <DynamicFontMemoryAllocation+0x68>)
  208a30:	681b      	ldr	r3, [r3, #0]
  208a32:	4a0f      	ldr	r2, [pc, #60]	; (208a70 <DynamicFontMemoryAllocation+0x70>)
  208a34:	1899      	adds	r1, r3, r2
  208a36:	480d      	ldr	r0, [pc, #52]	; (208a6c <DynamicFontMemoryAllocation+0x6c>)
  208a38:	683a      	ldr	r2, [r7, #0]
  208a3a:	4613      	mov	r3, r2
  208a3c:	019b      	lsls	r3, r3, #6
  208a3e:	4413      	add	r3, r2
  208a40:	015b      	lsls	r3, r3, #5
  208a42:	4403      	add	r3, r0
  208a44:	f603 0318 	addw	r3, r3, #2072	; 0x818
  208a48:	6019      	str	r1, [r3, #0]
		CounterBusyBytesForFontsImages += fontFileSize;
  208a4a:	4b07      	ldr	r3, [pc, #28]	; (208a68 <DynamicFontMemoryAllocation+0x68>)
  208a4c:	681a      	ldr	r2, [r3, #0]
  208a4e:	687b      	ldr	r3, [r7, #4]
  208a50:	4413      	add	r3, r2
  208a52:	4a05      	ldr	r2, [pc, #20]	; (208a68 <DynamicFontMemoryAllocation+0x68>)
  208a54:	6013      	str	r3, [r2, #0]
		return true;
  208a56:	2301      	movs	r3, #1
  208a58:	e000      	b.n	208a5c <DynamicFontMemoryAllocation+0x5c>
	}
	else
		return false;
  208a5a:	2300      	movs	r3, #0
}
  208a5c:	4618      	mov	r0, r3
  208a5e:	370c      	adds	r7, #12
  208a60:	46bd      	mov	sp, r7
  208a62:	f85d 7b04 	ldr.w	r7, [sp], #4
  208a66:	4770      	bx	lr
  208a68:	20010370 	.word	0x20010370
  208a6c:	20003590 	.word	0x20003590
  208a70:	c007f800 	.word	0xc007f800

00208a74 <SearchFontsField>:

static void SearchFontsField(char *pbmp, uint32_t width, uint32_t height, uint32_t bit_pixel, uint32_t *shiftXpos, uint8_t *backGround)
{
  208a74:	b480      	push	{r7}
  208a76:	b089      	sub	sp, #36	; 0x24
  208a78:	af00      	add	r7, sp, #0
  208a7a:	60f8      	str	r0, [r7, #12]
  208a7c:	60b9      	str	r1, [r7, #8]
  208a7e:	607a      	str	r2, [r7, #4]
  208a80:	603b      	str	r3, [r7, #0]
	int i,j,k;
	char *pbmp1;
	j=0;
  208a82:	2300      	movs	r3, #0
  208a84:	61bb      	str	r3, [r7, #24]
	do
	{
		pbmp1=pbmp+3*(j+*shiftXpos);
  208a86:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208a88:	681a      	ldr	r2, [r3, #0]
  208a8a:	69bb      	ldr	r3, [r7, #24]
  208a8c:	441a      	add	r2, r3
  208a8e:	4613      	mov	r3, r2
  208a90:	005b      	lsls	r3, r3, #1
  208a92:	4413      	add	r3, r2
  208a94:	68fa      	ldr	r2, [r7, #12]
  208a96:	4413      	add	r3, r2
  208a98:	613b      	str	r3, [r7, #16]
		k=0;
  208a9a:	2300      	movs	r3, #0
  208a9c:	617b      	str	r3, [r7, #20]
		for(i=0; i < height; i++)
  208a9e:	2300      	movs	r3, #0
  208aa0:	61fb      	str	r3, [r7, #28]
  208aa2:	e023      	b.n	208aec <SearchFontsField+0x78>
		{
			if((*(pbmp1+0)==backGround[0])&&(*(pbmp1+1)==backGround[1])&&(*(pbmp1+2)==backGround[2]))
  208aa4:	693b      	ldr	r3, [r7, #16]
  208aa6:	781a      	ldrb	r2, [r3, #0]
  208aa8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208aaa:	781b      	ldrb	r3, [r3, #0]
  208aac:	429a      	cmp	r2, r3
  208aae:	d121      	bne.n	208af4 <SearchFontsField+0x80>
  208ab0:	693b      	ldr	r3, [r7, #16]
  208ab2:	3301      	adds	r3, #1
  208ab4:	781a      	ldrb	r2, [r3, #0]
  208ab6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208ab8:	3301      	adds	r3, #1
  208aba:	781b      	ldrb	r3, [r3, #0]
  208abc:	429a      	cmp	r2, r3
  208abe:	d119      	bne.n	208af4 <SearchFontsField+0x80>
  208ac0:	693b      	ldr	r3, [r7, #16]
  208ac2:	3302      	adds	r3, #2
  208ac4:	781a      	ldrb	r2, [r3, #0]
  208ac6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208ac8:	3302      	adds	r3, #2
  208aca:	781b      	ldrb	r3, [r3, #0]
  208acc:	429a      	cmp	r2, r3
  208ace:	d111      	bne.n	208af4 <SearchFontsField+0x80>
				k++;
  208ad0:	697b      	ldr	r3, [r7, #20]
  208ad2:	3301      	adds	r3, #1
  208ad4:	617b      	str	r3, [r7, #20]
			else
				break;
			pbmp1 -= width*bit_pixel;
  208ad6:	68bb      	ldr	r3, [r7, #8]
  208ad8:	683a      	ldr	r2, [r7, #0]
  208ada:	fb02 f303 	mul.w	r3, r2, r3
  208ade:	425b      	negs	r3, r3
  208ae0:	693a      	ldr	r2, [r7, #16]
  208ae2:	4413      	add	r3, r2
  208ae4:	613b      	str	r3, [r7, #16]
		for(i=0; i < height; i++)
  208ae6:	69fb      	ldr	r3, [r7, #28]
  208ae8:	3301      	adds	r3, #1
  208aea:	61fb      	str	r3, [r7, #28]
  208aec:	69fa      	ldr	r2, [r7, #28]
  208aee:	687b      	ldr	r3, [r7, #4]
  208af0:	429a      	cmp	r2, r3
  208af2:	d3d7      	bcc.n	208aa4 <SearchFontsField+0x30>
		}
		if(k!=height)
  208af4:	697a      	ldr	r2, [r7, #20]
  208af6:	687b      	ldr	r3, [r7, #4]
  208af8:	429a      	cmp	r2, r3
  208afa:	d006      	beq.n	208b0a <SearchFontsField+0x96>
		{
			*shiftXpos+=j;
  208afc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208afe:	681a      	ldr	r2, [r3, #0]
  208b00:	69bb      	ldr	r3, [r7, #24]
  208b02:	441a      	add	r2, r3
  208b04:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208b06:	601a      	str	r2, [r3, #0]
			break;
  208b08:	e003      	b.n	208b12 <SearchFontsField+0x9e>
		}
		j++;
  208b0a:	69bb      	ldr	r3, [r7, #24]
  208b0c:	3301      	adds	r3, #1
  208b0e:	61bb      	str	r3, [r7, #24]
		pbmp1=pbmp+3*(j+*shiftXpos);
  208b10:	e7b9      	b.n	208a86 <SearchFontsField+0x12>
	}while(1);
}
  208b12:	bf00      	nop
  208b14:	3724      	adds	r7, #36	; 0x24
  208b16:	46bd      	mov	sp, r7
  208b18:	f85d 7b04 	ldr.w	r7, [sp], #4
  208b1c:	4770      	bx	lr

00208b1e <CountCharLenght>:

static uint32_t CountCharLenght(char *pbmp, uint32_t width, uint32_t height, uint32_t bit_pixel, uint32_t *shiftXpos, uint8_t *backGround)
{
  208b1e:	b480      	push	{r7}
  208b20:	b08b      	sub	sp, #44	; 0x2c
  208b22:	af00      	add	r7, sp, #0
  208b24:	60f8      	str	r0, [r7, #12]
  208b26:	60b9      	str	r1, [r7, #8]
  208b28:	607a      	str	r2, [r7, #4]
  208b2a:	603b      	str	r3, [r7, #0]
	int i,j,k;
	char *pbmp1;
	uint32_t charLenght=0;
  208b2c:	2300      	movs	r3, #0
  208b2e:	617b      	str	r3, [r7, #20]
	j=0;
  208b30:	2300      	movs	r3, #0
  208b32:	623b      	str	r3, [r7, #32]
	do
	{
		pbmp1=pbmp+3*(j+*shiftXpos);
  208b34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  208b36:	681a      	ldr	r2, [r3, #0]
  208b38:	6a3b      	ldr	r3, [r7, #32]
  208b3a:	441a      	add	r2, r3
  208b3c:	4613      	mov	r3, r2
  208b3e:	005b      	lsls	r3, r3, #1
  208b40:	4413      	add	r3, r2
  208b42:	68fa      	ldr	r2, [r7, #12]
  208b44:	4413      	add	r3, r2
  208b46:	61bb      	str	r3, [r7, #24]
		k=0;
  208b48:	2300      	movs	r3, #0
  208b4a:	61fb      	str	r3, [r7, #28]
		for(i=0; i < height; i++)
  208b4c:	2300      	movs	r3, #0
  208b4e:	627b      	str	r3, [r7, #36]	; 0x24
  208b50:	e027      	b.n	208ba2 <CountCharLenght+0x84>
		{
			if((*(pbmp1+0)==backGround[0])&&(*(pbmp1+1)==backGround[1])&&(*(pbmp1+2)==backGround[2]))
  208b52:	69bb      	ldr	r3, [r7, #24]
  208b54:	781a      	ldrb	r2, [r3, #0]
  208b56:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  208b58:	781b      	ldrb	r3, [r3, #0]
  208b5a:	429a      	cmp	r2, r3
  208b5c:	d11e      	bne.n	208b9c <CountCharLenght+0x7e>
  208b5e:	69bb      	ldr	r3, [r7, #24]
  208b60:	3301      	adds	r3, #1
  208b62:	781a      	ldrb	r2, [r3, #0]
  208b64:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  208b66:	3301      	adds	r3, #1
  208b68:	781b      	ldrb	r3, [r3, #0]
  208b6a:	429a      	cmp	r2, r3
  208b6c:	d116      	bne.n	208b9c <CountCharLenght+0x7e>
  208b6e:	69bb      	ldr	r3, [r7, #24]
  208b70:	3302      	adds	r3, #2
  208b72:	781a      	ldrb	r2, [r3, #0]
  208b74:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  208b76:	3302      	adds	r3, #2
  208b78:	781b      	ldrb	r3, [r3, #0]
  208b7a:	429a      	cmp	r2, r3
  208b7c:	d10e      	bne.n	208b9c <CountCharLenght+0x7e>
				k++;
  208b7e:	69fb      	ldr	r3, [r7, #28]
  208b80:	3301      	adds	r3, #1
  208b82:	61fb      	str	r3, [r7, #28]
			else
			{
				k=0;
				break;
			}
			pbmp1 -= width*bit_pixel;
  208b84:	68bb      	ldr	r3, [r7, #8]
  208b86:	683a      	ldr	r2, [r7, #0]
  208b88:	fb02 f303 	mul.w	r3, r2, r3
  208b8c:	425b      	negs	r3, r3
  208b8e:	69ba      	ldr	r2, [r7, #24]
  208b90:	4413      	add	r3, r2
  208b92:	61bb      	str	r3, [r7, #24]
		for(i=0; i < height; i++)
  208b94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  208b96:	3301      	adds	r3, #1
  208b98:	627b      	str	r3, [r7, #36]	; 0x24
  208b9a:	e002      	b.n	208ba2 <CountCharLenght+0x84>
				k=0;
  208b9c:	2300      	movs	r3, #0
  208b9e:	61fb      	str	r3, [r7, #28]
				break;
  208ba0:	e003      	b.n	208baa <CountCharLenght+0x8c>
		for(i=0; i < height; i++)
  208ba2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  208ba4:	687b      	ldr	r3, [r7, #4]
  208ba6:	429a      	cmp	r2, r3
  208ba8:	d3d3      	bcc.n	208b52 <CountCharLenght+0x34>
		}
		if(k==height)
  208baa:	69fa      	ldr	r2, [r7, #28]
  208bac:	687b      	ldr	r3, [r7, #4]
  208bae:	429a      	cmp	r2, r3
  208bb0:	d104      	bne.n	208bbc <CountCharLenght+0x9e>
		{
			charLenght+=j;
  208bb2:	6a3b      	ldr	r3, [r7, #32]
  208bb4:	697a      	ldr	r2, [r7, #20]
  208bb6:	4413      	add	r3, r2
  208bb8:	617b      	str	r3, [r7, #20]
			break;
  208bba:	e003      	b.n	208bc4 <CountCharLenght+0xa6>
		}
		j++;
  208bbc:	6a3b      	ldr	r3, [r7, #32]
  208bbe:	3301      	adds	r3, #1
  208bc0:	623b      	str	r3, [r7, #32]
		pbmp1=pbmp+3*(j+*shiftXpos);
  208bc2:	e7b7      	b.n	208b34 <CountCharLenght+0x16>

	}while(1);
	return charLenght;
  208bc4:	697b      	ldr	r3, [r7, #20]
}
  208bc6:	4618      	mov	r0, r3
  208bc8:	372c      	adds	r7, #44	; 0x2c
  208bca:	46bd      	mov	sp, r7
  208bcc:	f85d 7b04 	ldr.w	r7, [sp], #4
  208bd0:	4770      	bx	lr

00208bd2 <CountHalfHeightForDot>:

static int CountHalfHeightForDot(char *pbmp, uint32_t width, uint32_t height, uint32_t bit_pixel, uint32_t shiftXpos, uint8_t *backGround)
{
  208bd2:	b480      	push	{r7}
  208bd4:	b089      	sub	sp, #36	; 0x24
  208bd6:	af00      	add	r7, sp, #0
  208bd8:	60f8      	str	r0, [r7, #12]
  208bda:	60b9      	str	r1, [r7, #8]
  208bdc:	607a      	str	r2, [r7, #4]
  208bde:	603b      	str	r3, [r7, #0]
	int i,j=0,m=0;
  208be0:	2300      	movs	r3, #0
  208be2:	613b      	str	r3, [r7, #16]
  208be4:	2300      	movs	r3, #0
  208be6:	61bb      	str	r3, [r7, #24]
	char *pbmp1;

	pbmp1=pbmp + 3 * (j + shiftXpos);
  208be8:	693a      	ldr	r2, [r7, #16]
  208bea:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208bec:	441a      	add	r2, r3
  208bee:	4613      	mov	r3, r2
  208bf0:	005b      	lsls	r3, r3, #1
  208bf2:	4413      	add	r3, r2
  208bf4:	68fa      	ldr	r2, [r7, #12]
  208bf6:	4413      	add	r3, r2
  208bf8:	617b      	str	r3, [r7, #20]
	m=0;
  208bfa:	2300      	movs	r3, #0
  208bfc:	61bb      	str	r3, [r7, #24]
	for(i=0;i < height;i++)
  208bfe:	2300      	movs	r3, #0
  208c00:	61fb      	str	r3, [r7, #28]
  208c02:	e027      	b.n	208c54 <CountHalfHeightForDot+0x82>
	{
		if((*(pbmp1 + 0) == backGround[0]) && (*(pbmp1 + 1) == backGround[1]) && (*(pbmp1 + 2) == backGround[2]))
  208c04:	697b      	ldr	r3, [r7, #20]
  208c06:	781a      	ldrb	r2, [r3, #0]
  208c08:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208c0a:	781b      	ldrb	r3, [r3, #0]
  208c0c:	429a      	cmp	r2, r3
  208c0e:	d114      	bne.n	208c3a <CountHalfHeightForDot+0x68>
  208c10:	697b      	ldr	r3, [r7, #20]
  208c12:	3301      	adds	r3, #1
  208c14:	781a      	ldrb	r2, [r3, #0]
  208c16:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208c18:	3301      	adds	r3, #1
  208c1a:	781b      	ldrb	r3, [r3, #0]
  208c1c:	429a      	cmp	r2, r3
  208c1e:	d10c      	bne.n	208c3a <CountHalfHeightForDot+0x68>
  208c20:	697b      	ldr	r3, [r7, #20]
  208c22:	3302      	adds	r3, #2
  208c24:	781a      	ldrb	r2, [r3, #0]
  208c26:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  208c28:	3302      	adds	r3, #2
  208c2a:	781b      	ldrb	r3, [r3, #0]
  208c2c:	429a      	cmp	r2, r3
  208c2e:	d104      	bne.n	208c3a <CountHalfHeightForDot+0x68>
		{
			if(m == 1)
  208c30:	69bb      	ldr	r3, [r7, #24]
  208c32:	2b01      	cmp	r3, #1
  208c34:	d103      	bne.n	208c3e <CountHalfHeightForDot+0x6c>
				return i;
  208c36:	69fb      	ldr	r3, [r7, #28]
  208c38:	e012      	b.n	208c60 <CountHalfHeightForDot+0x8e>
		}
		else
			m=1;
  208c3a:	2301      	movs	r3, #1
  208c3c:	61bb      	str	r3, [r7, #24]
		pbmp1-=width * bit_pixel;
  208c3e:	68bb      	ldr	r3, [r7, #8]
  208c40:	683a      	ldr	r2, [r7, #0]
  208c42:	fb02 f303 	mul.w	r3, r2, r3
  208c46:	425b      	negs	r3, r3
  208c48:	697a      	ldr	r2, [r7, #20]
  208c4a:	4413      	add	r3, r2
  208c4c:	617b      	str	r3, [r7, #20]
	for(i=0;i < height;i++)
  208c4e:	69fb      	ldr	r3, [r7, #28]
  208c50:	3301      	adds	r3, #1
  208c52:	61fb      	str	r3, [r7, #28]
  208c54:	69fa      	ldr	r2, [r7, #28]
  208c56:	687b      	ldr	r3, [r7, #4]
  208c58:	429a      	cmp	r2, r3
  208c5a:	d3d3      	bcc.n	208c04 <CountHalfHeightForDot+0x32>
	}
	return -1;
  208c5c:	f04f 33ff 	mov.w	r3, #4294967295
}
  208c60:	4618      	mov	r0, r3
  208c62:	3724      	adds	r7, #36	; 0x24
  208c64:	46bd      	mov	sp, r7
  208c66:	f85d 7b04 	ldr.w	r7, [sp], #4
  208c6a:	4770      	bx	lr

00208c6c <SearchCurrentFont_TablePos>:

static void SearchCurrentFont_TablePos(char *pbmp, int fontIndex)
{
  208c6c:	b590      	push	{r4, r7, lr}
  208c6e:	b08f      	sub	sp, #60	; 0x3c
  208c70:	af02      	add	r7, sp, #8
  208c72:	6078      	str	r0, [r7, #4]
  208c74:	6039      	str	r1, [r7, #0]
	const char *pChar;
	uint8_t fontSize=ReturnFontSize(fontIndex);
  208c76:	6838      	ldr	r0, [r7, #0]
  208c78:	f7ff fe52 	bl	208920 <ReturnFontSize>
  208c7c:	4603      	mov	r3, r0
  208c7e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	switch(fontSize)
  208c82:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  208c86:	3b2d      	subs	r3, #45	; 0x2d
  208c88:	2b05      	cmp	r3, #5
  208c8a:	d802      	bhi.n	208c92 <SearchCurrentFont_TablePos+0x26>
	case FONT_72_bold:
	case FONT_72_italics:
	case FONT_130:
	case FONT_130_bold:
	case FONT_130_italics:
		pChar=CharsTab_digits;
  208c8c:	4b94      	ldr	r3, [pc, #592]	; (208ee0 <SearchCurrentFont_TablePos+0x274>)
  208c8e:	62fb      	str	r3, [r7, #44]	; 0x2c
		break;
  208c90:	e002      	b.n	208c98 <SearchCurrentFont_TablePos+0x2c>
	default:
		pChar=CharsTab_full;
  208c92:	4b94      	ldr	r3, [pc, #592]	; (208ee4 <SearchCurrentFont_TablePos+0x278>)
  208c94:	62fb      	str	r3, [r7, #44]	; 0x2c
		break;
  208c96:	bf00      	nop
	}

	int j, lenTab=strlen(pChar);
  208c98:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  208c9a:	f7f7 fad1 	bl	200240 <strlen>
  208c9e:	4603      	mov	r3, r0
  208ca0:	623b      	str	r3, [r7, #32]
	uint32_t shiftXpos=0, index = 0, width = 0, height = 0, bit_pixel = 0;
  208ca2:	2300      	movs	r3, #0
  208ca4:	60fb      	str	r3, [r7, #12]
  208ca6:	2300      	movs	r3, #0
  208ca8:	61fb      	str	r3, [r7, #28]
  208caa:	2300      	movs	r3, #0
  208cac:	61bb      	str	r3, [r7, #24]
  208cae:	2300      	movs	r3, #0
  208cb0:	617b      	str	r3, [r7, #20]
  208cb2:	2300      	movs	r3, #0
  208cb4:	613b      	str	r3, [r7, #16]
	uint8_t backGround[3];

	/* Get bitmap data address offset */
	index = pbmp[10] + (pbmp[11] << 8) + (pbmp[12] << 16)  + (pbmp[13] << 24);
  208cb6:	687b      	ldr	r3, [r7, #4]
  208cb8:	330a      	adds	r3, #10
  208cba:	781b      	ldrb	r3, [r3, #0]
  208cbc:	461a      	mov	r2, r3
  208cbe:	687b      	ldr	r3, [r7, #4]
  208cc0:	330b      	adds	r3, #11
  208cc2:	781b      	ldrb	r3, [r3, #0]
  208cc4:	021b      	lsls	r3, r3, #8
  208cc6:	441a      	add	r2, r3
  208cc8:	687b      	ldr	r3, [r7, #4]
  208cca:	330c      	adds	r3, #12
  208ccc:	781b      	ldrb	r3, [r3, #0]
  208cce:	041b      	lsls	r3, r3, #16
  208cd0:	441a      	add	r2, r3
  208cd2:	687b      	ldr	r3, [r7, #4]
  208cd4:	330d      	adds	r3, #13
  208cd6:	781b      	ldrb	r3, [r3, #0]
  208cd8:	061b      	lsls	r3, r3, #24
  208cda:	4413      	add	r3, r2
  208cdc:	61fb      	str	r3, [r7, #28]

	/* Read bitmap width */
	width = pbmp[18] + (pbmp[19] << 8) + (pbmp[20] << 16)  + (pbmp[21] << 24);  //!!! szerokosc musi byc wielokrotnoscia 4
  208cde:	687b      	ldr	r3, [r7, #4]
  208ce0:	3312      	adds	r3, #18
  208ce2:	781b      	ldrb	r3, [r3, #0]
  208ce4:	461a      	mov	r2, r3
  208ce6:	687b      	ldr	r3, [r7, #4]
  208ce8:	3313      	adds	r3, #19
  208cea:	781b      	ldrb	r3, [r3, #0]
  208cec:	021b      	lsls	r3, r3, #8
  208cee:	441a      	add	r2, r3
  208cf0:	687b      	ldr	r3, [r7, #4]
  208cf2:	3314      	adds	r3, #20
  208cf4:	781b      	ldrb	r3, [r3, #0]
  208cf6:	041b      	lsls	r3, r3, #16
  208cf8:	441a      	add	r2, r3
  208cfa:	687b      	ldr	r3, [r7, #4]
  208cfc:	3315      	adds	r3, #21
  208cfe:	781b      	ldrb	r3, [r3, #0]
  208d00:	061b      	lsls	r3, r3, #24
  208d02:	4413      	add	r3, r2
  208d04:	61bb      	str	r3, [r7, #24]

	/* Read bitmap height */
	height = pbmp[22] + (pbmp[23] << 8) + (pbmp[24] << 16)  + (pbmp[25] << 24);
  208d06:	687b      	ldr	r3, [r7, #4]
  208d08:	3316      	adds	r3, #22
  208d0a:	781b      	ldrb	r3, [r3, #0]
  208d0c:	461a      	mov	r2, r3
  208d0e:	687b      	ldr	r3, [r7, #4]
  208d10:	3317      	adds	r3, #23
  208d12:	781b      	ldrb	r3, [r3, #0]
  208d14:	021b      	lsls	r3, r3, #8
  208d16:	441a      	add	r2, r3
  208d18:	687b      	ldr	r3, [r7, #4]
  208d1a:	3318      	adds	r3, #24
  208d1c:	781b      	ldrb	r3, [r3, #0]
  208d1e:	041b      	lsls	r3, r3, #16
  208d20:	441a      	add	r2, r3
  208d22:	687b      	ldr	r3, [r7, #4]
  208d24:	3319      	adds	r3, #25
  208d26:	781b      	ldrb	r3, [r3, #0]
  208d28:	061b      	lsls	r3, r3, #24
  208d2a:	4413      	add	r3, r2
  208d2c:	617b      	str	r3, [r7, #20]

	/* Read bit/pixel */
	bit_pixel = pbmp[28] + (pbmp[29] << 8);
  208d2e:	687b      	ldr	r3, [r7, #4]
  208d30:	331c      	adds	r3, #28
  208d32:	781b      	ldrb	r3, [r3, #0]
  208d34:	461a      	mov	r2, r3
  208d36:	687b      	ldr	r3, [r7, #4]
  208d38:	331d      	adds	r3, #29
  208d3a:	781b      	ldrb	r3, [r3, #0]
  208d3c:	021b      	lsls	r3, r3, #8
  208d3e:	4413      	add	r3, r2
  208d40:	613b      	str	r3, [r7, #16]
	bit_pixel/=8;
  208d42:	693b      	ldr	r3, [r7, #16]
  208d44:	08db      	lsrs	r3, r3, #3
  208d46:	613b      	str	r3, [r7, #16]

	pbmp += (index + (width * height * bit_pixel));
  208d48:	69bb      	ldr	r3, [r7, #24]
  208d4a:	697a      	ldr	r2, [r7, #20]
  208d4c:	fb02 f303 	mul.w	r3, r2, r3
  208d50:	693a      	ldr	r2, [r7, #16]
  208d52:	fb02 f203 	mul.w	r2, r2, r3
  208d56:	69fb      	ldr	r3, [r7, #28]
  208d58:	4413      	add	r3, r2
  208d5a:	687a      	ldr	r2, [r7, #4]
  208d5c:	4413      	add	r3, r2
  208d5e:	607b      	str	r3, [r7, #4]
	pbmp -= width*bit_pixel;
  208d60:	69bb      	ldr	r3, [r7, #24]
  208d62:	693a      	ldr	r2, [r7, #16]
  208d64:	fb02 f303 	mul.w	r3, r2, r3
  208d68:	425b      	negs	r3, r3
  208d6a:	687a      	ldr	r2, [r7, #4]
  208d6c:	4413      	add	r3, r2
  208d6e:	607b      	str	r3, [r7, #4]

	backGround[0]=pbmp[0];
  208d70:	687b      	ldr	r3, [r7, #4]
  208d72:	781b      	ldrb	r3, [r3, #0]
  208d74:	723b      	strb	r3, [r7, #8]
	backGround[1]=pbmp[1];
  208d76:	687b      	ldr	r3, [r7, #4]
  208d78:	3301      	adds	r3, #1
  208d7a:	781b      	ldrb	r3, [r3, #0]
  208d7c:	727b      	strb	r3, [r7, #9]
	backGround[2]=pbmp[2];
  208d7e:	687b      	ldr	r3, [r7, #4]
  208d80:	3302      	adds	r3, #2
  208d82:	781b      	ldrb	r3, [r3, #0]
  208d84:	72bb      	strb	r3, [r7, #10]

	Font[fontIndex].height=height;
  208d86:	6979      	ldr	r1, [r7, #20]
  208d88:	4857      	ldr	r0, [pc, #348]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208d8a:	683a      	ldr	r2, [r7, #0]
  208d8c:	4613      	mov	r3, r2
  208d8e:	019b      	lsls	r3, r3, #6
  208d90:	4413      	add	r3, r2
  208d92:	015b      	lsls	r3, r3, #5
  208d94:	4403      	add	r3, r0
  208d96:	f503 6301 	add.w	r3, r3, #2064	; 0x810
  208d9a:	6019      	str	r1, [r3, #0]

	for(j=0; j < lenTab; j++)
  208d9c:	2300      	movs	r3, #0
  208d9e:	62bb      	str	r3, [r7, #40]	; 0x28
  208da0:	e089      	b.n	208eb6 <SearchCurrentFont_TablePos+0x24a>
	{
		SearchFontsField(pbmp,width,height,bit_pixel,&shiftXpos,backGround);
  208da2:	f107 0308 	add.w	r3, r7, #8
  208da6:	9301      	str	r3, [sp, #4]
  208da8:	f107 030c 	add.w	r3, r7, #12
  208dac:	9300      	str	r3, [sp, #0]
  208dae:	693b      	ldr	r3, [r7, #16]
  208db0:	697a      	ldr	r2, [r7, #20]
  208db2:	69b9      	ldr	r1, [r7, #24]
  208db4:	6878      	ldr	r0, [r7, #4]
  208db6:	f7ff fe5d 	bl	208a74 <SearchFontsField>
		if(pChar[j]=='.')  SetFontHeightHalf(fontIndex, CountHalfHeightForDot(pbmp,width,height,bit_pixel,shiftXpos,backGround)+2);
  208dba:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208dbc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  208dbe:	4413      	add	r3, r2
  208dc0:	781b      	ldrb	r3, [r3, #0]
  208dc2:	2b2e      	cmp	r3, #46	; 0x2e
  208dc4:	d110      	bne.n	208de8 <SearchCurrentFont_TablePos+0x17c>
  208dc6:	68fb      	ldr	r3, [r7, #12]
  208dc8:	f107 0208 	add.w	r2, r7, #8
  208dcc:	9201      	str	r2, [sp, #4]
  208dce:	9300      	str	r3, [sp, #0]
  208dd0:	693b      	ldr	r3, [r7, #16]
  208dd2:	697a      	ldr	r2, [r7, #20]
  208dd4:	69b9      	ldr	r1, [r7, #24]
  208dd6:	6878      	ldr	r0, [r7, #4]
  208dd8:	f7ff fefb 	bl	208bd2 <CountHalfHeightForDot>
  208ddc:	4603      	mov	r3, r0
  208dde:	3302      	adds	r3, #2
  208de0:	4619      	mov	r1, r3
  208de2:	6838      	ldr	r0, [r7, #0]
  208de4:	f7ff fdb4 	bl	208950 <SetFontHeightHalf>
		Font[fontIndex].fontsTabPos[ (int)pChar[j] ][1] = CountCharLenght(pbmp,width,height,bit_pixel,&shiftXpos,backGround);
  208de8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208dea:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  208dec:	4413      	add	r3, r2
  208dee:	781b      	ldrb	r3, [r3, #0]
  208df0:	461c      	mov	r4, r3
  208df2:	f107 0308 	add.w	r3, r7, #8
  208df6:	9301      	str	r3, [sp, #4]
  208df8:	f107 030c 	add.w	r3, r7, #12
  208dfc:	9300      	str	r3, [sp, #0]
  208dfe:	693b      	ldr	r3, [r7, #16]
  208e00:	697a      	ldr	r2, [r7, #20]
  208e02:	69b9      	ldr	r1, [r7, #24]
  208e04:	6878      	ldr	r0, [r7, #4]
  208e06:	f7ff fe8a 	bl	208b1e <CountCharLenght>
  208e0a:	4603      	mov	r3, r0
  208e0c:	4618      	mov	r0, r3
  208e0e:	4936      	ldr	r1, [pc, #216]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208e10:	683a      	ldr	r2, [r7, #0]
  208e12:	4613      	mov	r3, r2
  208e14:	019b      	lsls	r3, r3, #6
  208e16:	4413      	add	r3, r2
  208e18:	009b      	lsls	r3, r3, #2
  208e1a:	4423      	add	r3, r4
  208e1c:	00db      	lsls	r3, r3, #3
  208e1e:	440b      	add	r3, r1
  208e20:	6158      	str	r0, [r3, #20]
		Font[fontIndex].fontsTabPos[ (int)pChar[j] ][0] = shiftXpos;
  208e22:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208e24:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  208e26:	4413      	add	r3, r2
  208e28:	781b      	ldrb	r3, [r3, #0]
  208e2a:	461c      	mov	r4, r3
  208e2c:	68fb      	ldr	r3, [r7, #12]
  208e2e:	4618      	mov	r0, r3
  208e30:	492d      	ldr	r1, [pc, #180]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208e32:	683a      	ldr	r2, [r7, #0]
  208e34:	4613      	mov	r3, r2
  208e36:	019b      	lsls	r3, r3, #6
  208e38:	4413      	add	r3, r2
  208e3a:	009b      	lsls	r3, r3, #2
  208e3c:	4423      	add	r3, r4
  208e3e:	3302      	adds	r3, #2
  208e40:	f841 0033 	str.w	r0, [r1, r3, lsl #3]
		shiftXpos += (Font[fontIndex].fontsTabPos[ (int)pChar[j] ][1]+1);
  208e44:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208e46:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  208e48:	4413      	add	r3, r2
  208e4a:	781b      	ldrb	r3, [r3, #0]
  208e4c:	4618      	mov	r0, r3
  208e4e:	4926      	ldr	r1, [pc, #152]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208e50:	683a      	ldr	r2, [r7, #0]
  208e52:	4613      	mov	r3, r2
  208e54:	019b      	lsls	r3, r3, #6
  208e56:	4413      	add	r3, r2
  208e58:	009b      	lsls	r3, r3, #2
  208e5a:	4403      	add	r3, r0
  208e5c:	00db      	lsls	r3, r3, #3
  208e5e:	440b      	add	r3, r1
  208e60:	695b      	ldr	r3, [r3, #20]
  208e62:	461a      	mov	r2, r3
  208e64:	68fb      	ldr	r3, [r7, #12]
  208e66:	4413      	add	r3, r2
  208e68:	3301      	adds	r3, #1
  208e6a:	60fb      	str	r3, [r7, #12]
		if(j==0)
  208e6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208e6e:	2b00      	cmp	r3, #0
  208e70:	d11e      	bne.n	208eb0 <SearchCurrentFont_TablePos+0x244>
			Font[fontIndex].fontsTabPos[(int)' '][1] = (2*Font[fontIndex].fontsTabPos[ (int)pChar[j] ][1])/3; //spacja na podstawie 2/3 dugosci pierwszej litery z pChar
  208e72:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208e74:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  208e76:	4413      	add	r3, r2
  208e78:	781b      	ldrb	r3, [r3, #0]
  208e7a:	4618      	mov	r0, r3
  208e7c:	491a      	ldr	r1, [pc, #104]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208e7e:	683a      	ldr	r2, [r7, #0]
  208e80:	4613      	mov	r3, r2
  208e82:	019b      	lsls	r3, r3, #6
  208e84:	4413      	add	r3, r2
  208e86:	009b      	lsls	r3, r3, #2
  208e88:	4403      	add	r3, r0
  208e8a:	00db      	lsls	r3, r3, #3
  208e8c:	440b      	add	r3, r1
  208e8e:	695b      	ldr	r3, [r3, #20]
  208e90:	005b      	lsls	r3, r3, #1
  208e92:	4a16      	ldr	r2, [pc, #88]	; (208eec <SearchCurrentFont_TablePos+0x280>)
  208e94:	fb82 1203 	smull	r1, r2, r2, r3
  208e98:	17db      	asrs	r3, r3, #31
  208e9a:	1ad1      	subs	r1, r2, r3
  208e9c:	4812      	ldr	r0, [pc, #72]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208e9e:	683a      	ldr	r2, [r7, #0]
  208ea0:	4613      	mov	r3, r2
  208ea2:	019b      	lsls	r3, r3, #6
  208ea4:	4413      	add	r3, r2
  208ea6:	015b      	lsls	r3, r3, #5
  208ea8:	4403      	add	r3, r0
  208eaa:	f503 738a 	add.w	r3, r3, #276	; 0x114
  208eae:	6019      	str	r1, [r3, #0]
	for(j=0; j < lenTab; j++)
  208eb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  208eb2:	3301      	adds	r3, #1
  208eb4:	62bb      	str	r3, [r7, #40]	; 0x28
  208eb6:	6aba      	ldr	r2, [r7, #40]	; 0x28
  208eb8:	6a3b      	ldr	r3, [r7, #32]
  208eba:	429a      	cmp	r2, r3
  208ebc:	f6ff af71 	blt.w	208da2 <SearchCurrentFont_TablePos+0x136>
	}
	Font[fontIndex].fontsTabPos[(int)' '][0] = shiftXpos;
  208ec0:	68fb      	ldr	r3, [r7, #12]
  208ec2:	4618      	mov	r0, r3
  208ec4:	4908      	ldr	r1, [pc, #32]	; (208ee8 <SearchCurrentFont_TablePos+0x27c>)
  208ec6:	683a      	ldr	r2, [r7, #0]
  208ec8:	4613      	mov	r3, r2
  208eca:	019b      	lsls	r3, r3, #6
  208ecc:	4413      	add	r3, r2
  208ece:	015b      	lsls	r3, r3, #5
  208ed0:	440b      	add	r3, r1
  208ed2:	f503 7388 	add.w	r3, r3, #272	; 0x110
  208ed6:	6018      	str	r0, [r3, #0]
}
  208ed8:	bf00      	nop
  208eda:	3734      	adds	r7, #52	; 0x34
  208edc:	46bd      	mov	sp, r7
  208ede:	bd90      	pop	{r4, r7, pc}
  208ee0:	00229310 	.word	0x00229310
  208ee4:	002292a0 	.word	0x002292a0
  208ee8:	20003590 	.word	0x20003590
  208eec:	55555556 	.word	0x55555556

00208ef0 <LCD_Set_ConstWidthFonts>:

static void LCD_Set_ConstWidthFonts(int fontIndex)
{
  208ef0:	b5b0      	push	{r4, r5, r7, lr}
  208ef2:	b088      	sub	sp, #32
  208ef4:	af00      	add	r7, sp, #0
  208ef6:	6078      	str	r0, [r7, #4]
	const char *pChar;
	uint8_t fontSize=ReturnFontSize(fontIndex);
  208ef8:	6878      	ldr	r0, [r7, #4]
  208efa:	f7ff fd11 	bl	208920 <ReturnFontSize>
  208efe:	4603      	mov	r3, r0
  208f00:	74fb      	strb	r3, [r7, #19]

	switch(fontSize)
  208f02:	7cfb      	ldrb	r3, [r7, #19]
  208f04:	3b2d      	subs	r3, #45	; 0x2d
  208f06:	2b05      	cmp	r3, #5
  208f08:	d802      	bhi.n	208f10 <LCD_Set_ConstWidthFonts+0x20>
	case FONT_72_bold:
	case FONT_72_italics:
	case FONT_130:
	case FONT_130_bold:
	case FONT_130_italics:
		pChar=CharsTab_digits;
  208f0a:	4b74      	ldr	r3, [pc, #464]	; (2090dc <LCD_Set_ConstWidthFonts+0x1ec>)
  208f0c:	61fb      	str	r3, [r7, #28]
		break;
  208f0e:	e002      	b.n	208f16 <LCD_Set_ConstWidthFonts+0x26>
	default:
		pChar=CharsTab_full;
  208f10:	4b73      	ldr	r3, [pc, #460]	; (2090e0 <LCD_Set_ConstWidthFonts+0x1f0>)
  208f12:	61fb      	str	r3, [r7, #28]
		break;
  208f14:	bf00      	nop
	}
	int j, lenTab=strlen(pChar);
  208f16:	69f8      	ldr	r0, [r7, #28]
  208f18:	f7f7 f992 	bl	200240 <strlen>
  208f1c:	4603      	mov	r3, r0
  208f1e:	60fb      	str	r3, [r7, #12]

	int maxWidth=0;
  208f20:	2300      	movs	r3, #0
  208f22:	617b      	str	r3, [r7, #20]
	for(j=0;j < lenTab;j++)
  208f24:	2300      	movs	r3, #0
  208f26:	61bb      	str	r3, [r7, #24]
  208f28:	e02e      	b.n	208f88 <LCD_Set_ConstWidthFonts+0x98>
	{
		if(RealizeWidthConst(pChar[j]))
  208f2a:	69bb      	ldr	r3, [r7, #24]
  208f2c:	69fa      	ldr	r2, [r7, #28]
  208f2e:	4413      	add	r3, r2
  208f30:	781b      	ldrb	r3, [r3, #0]
  208f32:	4618      	mov	r0, r3
  208f34:	f7fe fdee 	bl	207b14 <RealizeWidthConst>
  208f38:	4603      	mov	r3, r0
  208f3a:	2b00      	cmp	r3, #0
  208f3c:	d021      	beq.n	208f82 <LCD_Set_ConstWidthFonts+0x92>
		{
			if(Font[fontIndex].fontsTabPos[(int) pChar[j]][1] > maxWidth)
  208f3e:	69bb      	ldr	r3, [r7, #24]
  208f40:	69fa      	ldr	r2, [r7, #28]
  208f42:	4413      	add	r3, r2
  208f44:	781b      	ldrb	r3, [r3, #0]
  208f46:	4618      	mov	r0, r3
  208f48:	4966      	ldr	r1, [pc, #408]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  208f4a:	687a      	ldr	r2, [r7, #4]
  208f4c:	4613      	mov	r3, r2
  208f4e:	019b      	lsls	r3, r3, #6
  208f50:	4413      	add	r3, r2
  208f52:	009b      	lsls	r3, r3, #2
  208f54:	4403      	add	r3, r0
  208f56:	00db      	lsls	r3, r3, #3
  208f58:	440b      	add	r3, r1
  208f5a:	695a      	ldr	r2, [r3, #20]
  208f5c:	697b      	ldr	r3, [r7, #20]
  208f5e:	429a      	cmp	r2, r3
  208f60:	dd0f      	ble.n	208f82 <LCD_Set_ConstWidthFonts+0x92>
				maxWidth=Font[fontIndex].fontsTabPos[(int) pChar[j]][1];
  208f62:	69bb      	ldr	r3, [r7, #24]
  208f64:	69fa      	ldr	r2, [r7, #28]
  208f66:	4413      	add	r3, r2
  208f68:	781b      	ldrb	r3, [r3, #0]
  208f6a:	4618      	mov	r0, r3
  208f6c:	495d      	ldr	r1, [pc, #372]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  208f6e:	687a      	ldr	r2, [r7, #4]
  208f70:	4613      	mov	r3, r2
  208f72:	019b      	lsls	r3, r3, #6
  208f74:	4413      	add	r3, r2
  208f76:	009b      	lsls	r3, r3, #2
  208f78:	4403      	add	r3, r0
  208f7a:	00db      	lsls	r3, r3, #3
  208f7c:	440b      	add	r3, r1
  208f7e:	695b      	ldr	r3, [r3, #20]
  208f80:	617b      	str	r3, [r7, #20]
	for(j=0;j < lenTab;j++)
  208f82:	69bb      	ldr	r3, [r7, #24]
  208f84:	3301      	adds	r3, #1
  208f86:	61bb      	str	r3, [r7, #24]
  208f88:	69ba      	ldr	r2, [r7, #24]
  208f8a:	68fb      	ldr	r3, [r7, #12]
  208f8c:	429a      	cmp	r2, r3
  208f8e:	dbcc      	blt.n	208f2a <LCD_Set_ConstWidthFonts+0x3a>
		}
	}
	for(j=0;j < lenTab;j++)
  208f90:	2300      	movs	r3, #0
  208f92:	61bb      	str	r3, [r7, #24]
  208f94:	e080      	b.n	209098 <LCD_Set_ConstWidthFonts+0x1a8>
	{
		if(RealizeWidthConst(pChar[j]))
  208f96:	69bb      	ldr	r3, [r7, #24]
  208f98:	69fa      	ldr	r2, [r7, #28]
  208f9a:	4413      	add	r3, r2
  208f9c:	781b      	ldrb	r3, [r3, #0]
  208f9e:	4618      	mov	r0, r3
  208fa0:	f7fe fdb8 	bl	207b14 <RealizeWidthConst>
  208fa4:	4603      	mov	r3, r0
  208fa6:	2b00      	cmp	r3, #0
  208fa8:	d073      	beq.n	209092 <LCD_Set_ConstWidthFonts+0x1a2>
		{
			fontsTabPos_temp[(int) pChar[j]][0]=Font[fontIndex].fontsTabPos[(int) pChar[j]][0];
  208faa:	69bb      	ldr	r3, [r7, #24]
  208fac:	69fa      	ldr	r2, [r7, #28]
  208fae:	4413      	add	r3, r2
  208fb0:	781b      	ldrb	r3, [r3, #0]
  208fb2:	4618      	mov	r0, r3
  208fb4:	69bb      	ldr	r3, [r7, #24]
  208fb6:	69fa      	ldr	r2, [r7, #28]
  208fb8:	4413      	add	r3, r2
  208fba:	781b      	ldrb	r3, [r3, #0]
  208fbc:	461c      	mov	r4, r3
  208fbe:	4949      	ldr	r1, [pc, #292]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  208fc0:	687a      	ldr	r2, [r7, #4]
  208fc2:	4613      	mov	r3, r2
  208fc4:	019b      	lsls	r3, r3, #6
  208fc6:	4413      	add	r3, r2
  208fc8:	009b      	lsls	r3, r3, #2
  208fca:	4423      	add	r3, r4
  208fcc:	3302      	adds	r3, #2
  208fce:	f851 3033 	ldr.w	r3, [r1, r3, lsl #3]
  208fd2:	4a45      	ldr	r2, [pc, #276]	; (2090e8 <LCD_Set_ConstWidthFonts+0x1f8>)
  208fd4:	f842 3030 	str.w	r3, [r2, r0, lsl #3]
			fontsTabPos_temp[(int) pChar[j]][1]=Font[fontIndex].fontsTabPos[(int) pChar[j]][1];
  208fd8:	69bb      	ldr	r3, [r7, #24]
  208fda:	69fa      	ldr	r2, [r7, #28]
  208fdc:	4413      	add	r3, r2
  208fde:	781b      	ldrb	r3, [r3, #0]
  208fe0:	4618      	mov	r0, r3
  208fe2:	69bb      	ldr	r3, [r7, #24]
  208fe4:	69fa      	ldr	r2, [r7, #28]
  208fe6:	4413      	add	r3, r2
  208fe8:	781b      	ldrb	r3, [r3, #0]
  208fea:	461c      	mov	r4, r3
  208fec:	493d      	ldr	r1, [pc, #244]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  208fee:	687a      	ldr	r2, [r7, #4]
  208ff0:	4613      	mov	r3, r2
  208ff2:	019b      	lsls	r3, r3, #6
  208ff4:	4413      	add	r3, r2
  208ff6:	009b      	lsls	r3, r3, #2
  208ff8:	4423      	add	r3, r4
  208ffa:	00db      	lsls	r3, r3, #3
  208ffc:	440b      	add	r3, r1
  208ffe:	695a      	ldr	r2, [r3, #20]
  209000:	4939      	ldr	r1, [pc, #228]	; (2090e8 <LCD_Set_ConstWidthFonts+0x1f8>)
  209002:	00c3      	lsls	r3, r0, #3
  209004:	440b      	add	r3, r1
  209006:	605a      	str	r2, [r3, #4]

			Font[fontIndex].fontsTabPos[(int) pChar[j]][0]-=(maxWidth - Font[fontIndex].fontsTabPos[(int) pChar[j]][1]) / 2;
  209008:	69bb      	ldr	r3, [r7, #24]
  20900a:	69fa      	ldr	r2, [r7, #28]
  20900c:	4413      	add	r3, r2
  20900e:	781b      	ldrb	r3, [r3, #0]
  209010:	461c      	mov	r4, r3
  209012:	69bb      	ldr	r3, [r7, #24]
  209014:	69fa      	ldr	r2, [r7, #28]
  209016:	4413      	add	r3, r2
  209018:	781b      	ldrb	r3, [r3, #0]
  20901a:	4618      	mov	r0, r3
  20901c:	4931      	ldr	r1, [pc, #196]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  20901e:	687a      	ldr	r2, [r7, #4]
  209020:	4613      	mov	r3, r2
  209022:	019b      	lsls	r3, r3, #6
  209024:	4413      	add	r3, r2
  209026:	009b      	lsls	r3, r3, #2
  209028:	4403      	add	r3, r0
  20902a:	3302      	adds	r3, #2
  20902c:	f851 1033 	ldr.w	r1, [r1, r3, lsl #3]
  209030:	69bb      	ldr	r3, [r7, #24]
  209032:	69fa      	ldr	r2, [r7, #28]
  209034:	4413      	add	r3, r2
  209036:	781b      	ldrb	r3, [r3, #0]
  209038:	461d      	mov	r5, r3
  20903a:	482a      	ldr	r0, [pc, #168]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  20903c:	687a      	ldr	r2, [r7, #4]
  20903e:	4613      	mov	r3, r2
  209040:	019b      	lsls	r3, r3, #6
  209042:	4413      	add	r3, r2
  209044:	009b      	lsls	r3, r3, #2
  209046:	442b      	add	r3, r5
  209048:	00db      	lsls	r3, r3, #3
  20904a:	4403      	add	r3, r0
  20904c:	695b      	ldr	r3, [r3, #20]
  20904e:	697a      	ldr	r2, [r7, #20]
  209050:	1ad3      	subs	r3, r2, r3
  209052:	2b00      	cmp	r3, #0
  209054:	da00      	bge.n	209058 <LCD_Set_ConstWidthFonts+0x168>
  209056:	3301      	adds	r3, #1
  209058:	105b      	asrs	r3, r3, #1
  20905a:	425b      	negs	r3, r3
  20905c:	4419      	add	r1, r3
  20905e:	4821      	ldr	r0, [pc, #132]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  209060:	687a      	ldr	r2, [r7, #4]
  209062:	4613      	mov	r3, r2
  209064:	019b      	lsls	r3, r3, #6
  209066:	4413      	add	r3, r2
  209068:	009b      	lsls	r3, r3, #2
  20906a:	4423      	add	r3, r4
  20906c:	3302      	adds	r3, #2
  20906e:	f840 1033 	str.w	r1, [r0, r3, lsl #3]
			Font[fontIndex].fontsTabPos[(int) pChar[j]][1]=maxWidth;
  209072:	69bb      	ldr	r3, [r7, #24]
  209074:	69fa      	ldr	r2, [r7, #28]
  209076:	4413      	add	r3, r2
  209078:	781b      	ldrb	r3, [r3, #0]
  20907a:	4618      	mov	r0, r3
  20907c:	4919      	ldr	r1, [pc, #100]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  20907e:	687a      	ldr	r2, [r7, #4]
  209080:	4613      	mov	r3, r2
  209082:	019b      	lsls	r3, r3, #6
  209084:	4413      	add	r3, r2
  209086:	009b      	lsls	r3, r3, #2
  209088:	4403      	add	r3, r0
  20908a:	00db      	lsls	r3, r3, #3
  20908c:	440b      	add	r3, r1
  20908e:	697a      	ldr	r2, [r7, #20]
  209090:	615a      	str	r2, [r3, #20]
	for(j=0;j < lenTab;j++)
  209092:	69bb      	ldr	r3, [r7, #24]
  209094:	3301      	adds	r3, #1
  209096:	61bb      	str	r3, [r7, #24]
  209098:	69ba      	ldr	r2, [r7, #24]
  20909a:	68fb      	ldr	r3, [r7, #12]
  20909c:	429a      	cmp	r2, r3
  20909e:	f6ff af7a 	blt.w	208f96 <LCD_Set_ConstWidthFonts+0xa6>
		}
	}
	fontsTabPos_temp[(int) ' '][1]=Font[fontIndex].fontsTabPos[(int) ' '][1];
  2090a2:	4910      	ldr	r1, [pc, #64]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  2090a4:	687a      	ldr	r2, [r7, #4]
  2090a6:	4613      	mov	r3, r2
  2090a8:	019b      	lsls	r3, r3, #6
  2090aa:	4413      	add	r3, r2
  2090ac:	015b      	lsls	r3, r3, #5
  2090ae:	440b      	add	r3, r1
  2090b0:	f503 738a 	add.w	r3, r3, #276	; 0x114
  2090b4:	681b      	ldr	r3, [r3, #0]
  2090b6:	4a0c      	ldr	r2, [pc, #48]	; (2090e8 <LCD_Set_ConstWidthFonts+0x1f8>)
  2090b8:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
	Font[fontIndex].fontsTabPos[(int) ' '][1]=maxWidth;
  2090bc:	4909      	ldr	r1, [pc, #36]	; (2090e4 <LCD_Set_ConstWidthFonts+0x1f4>)
  2090be:	687a      	ldr	r2, [r7, #4]
  2090c0:	4613      	mov	r3, r2
  2090c2:	019b      	lsls	r3, r3, #6
  2090c4:	4413      	add	r3, r2
  2090c6:	015b      	lsls	r3, r3, #5
  2090c8:	440b      	add	r3, r1
  2090ca:	f503 738a 	add.w	r3, r3, #276	; 0x114
  2090ce:	697a      	ldr	r2, [r7, #20]
  2090d0:	601a      	str	r2, [r3, #0]
}
  2090d2:	bf00      	nop
  2090d4:	3720      	adds	r7, #32
  2090d6:	46bd      	mov	sp, r7
  2090d8:	bdb0      	pop	{r4, r5, r7, pc}
  2090da:	bf00      	nop
  2090dc:	00229310 	.word	0x00229310
  2090e0:	002292a0 	.word	0x002292a0
  2090e4:	20003590 	.word	0x20003590
  2090e8:	20002c74 	.word	0x20002c74

002090ec <LCD_Reset_ConstWidthFonts>:

static void LCD_Reset_ConstWidthFonts(int fontIndex)
{
  2090ec:	b590      	push	{r4, r7, lr}
  2090ee:	b087      	sub	sp, #28
  2090f0:	af00      	add	r7, sp, #0
  2090f2:	6078      	str	r0, [r7, #4]
	const char *pChar;
	uint8_t fontSize=ReturnFontSize(fontIndex);
  2090f4:	6878      	ldr	r0, [r7, #4]
  2090f6:	f7ff fc13 	bl	208920 <ReturnFontSize>
  2090fa:	4603      	mov	r3, r0
  2090fc:	73fb      	strb	r3, [r7, #15]

	switch(fontSize)
  2090fe:	7bfb      	ldrb	r3, [r7, #15]
  209100:	3b2d      	subs	r3, #45	; 0x2d
  209102:	2b05      	cmp	r3, #5
  209104:	d802      	bhi.n	20910c <LCD_Reset_ConstWidthFonts+0x20>
	case FONT_72_bold:
	case FONT_72_italics:
	case FONT_130:
	case FONT_130_bold:
	case FONT_130_italics:
		pChar=CharsTab_digits;
  209106:	4b2f      	ldr	r3, [pc, #188]	; (2091c4 <LCD_Reset_ConstWidthFonts+0xd8>)
  209108:	617b      	str	r3, [r7, #20]
		break;
  20910a:	e002      	b.n	209112 <LCD_Reset_ConstWidthFonts+0x26>
	default:
		pChar=CharsTab_full;
  20910c:	4b2e      	ldr	r3, [pc, #184]	; (2091c8 <LCD_Reset_ConstWidthFonts+0xdc>)
  20910e:	617b      	str	r3, [r7, #20]
		break;
  209110:	bf00      	nop
	}
	int j, lenTab=strlen(pChar);
  209112:	6978      	ldr	r0, [r7, #20]
  209114:	f7f7 f894 	bl	200240 <strlen>
  209118:	4603      	mov	r3, r0
  20911a:	60bb      	str	r3, [r7, #8]

	for(j=0; j < lenTab; j++)
  20911c:	2300      	movs	r3, #0
  20911e:	613b      	str	r3, [r7, #16]
  209120:	e03a      	b.n	209198 <LCD_Reset_ConstWidthFonts+0xac>
	{
		if(RealizeWidthConst(pChar[j]))
  209122:	693b      	ldr	r3, [r7, #16]
  209124:	697a      	ldr	r2, [r7, #20]
  209126:	4413      	add	r3, r2
  209128:	781b      	ldrb	r3, [r3, #0]
  20912a:	4618      	mov	r0, r3
  20912c:	f7fe fcf2 	bl	207b14 <RealizeWidthConst>
  209130:	4603      	mov	r3, r0
  209132:	2b00      	cmp	r3, #0
  209134:	d02d      	beq.n	209192 <LCD_Reset_ConstWidthFonts+0xa6>
		{
			Font[fontIndex].fontsTabPos[ (int)pChar[j] ][0] = fontsTabPos_temp[(int)pChar[j]][0];
  209136:	693b      	ldr	r3, [r7, #16]
  209138:	697a      	ldr	r2, [r7, #20]
  20913a:	4413      	add	r3, r2
  20913c:	781b      	ldrb	r3, [r3, #0]
  20913e:	461c      	mov	r4, r3
  209140:	693b      	ldr	r3, [r7, #16]
  209142:	697a      	ldr	r2, [r7, #20]
  209144:	4413      	add	r3, r2
  209146:	781b      	ldrb	r3, [r3, #0]
  209148:	461a      	mov	r2, r3
  20914a:	4b20      	ldr	r3, [pc, #128]	; (2091cc <LCD_Reset_ConstWidthFonts+0xe0>)
  20914c:	f853 1032 	ldr.w	r1, [r3, r2, lsl #3]
  209150:	481f      	ldr	r0, [pc, #124]	; (2091d0 <LCD_Reset_ConstWidthFonts+0xe4>)
  209152:	687a      	ldr	r2, [r7, #4]
  209154:	4613      	mov	r3, r2
  209156:	019b      	lsls	r3, r3, #6
  209158:	4413      	add	r3, r2
  20915a:	009b      	lsls	r3, r3, #2
  20915c:	4423      	add	r3, r4
  20915e:	3302      	adds	r3, #2
  209160:	f840 1033 	str.w	r1, [r0, r3, lsl #3]
			Font[fontIndex].fontsTabPos[ (int)pChar[j] ][1] = fontsTabPos_temp[(int)pChar[j]][1];
  209164:	693b      	ldr	r3, [r7, #16]
  209166:	697a      	ldr	r2, [r7, #20]
  209168:	4413      	add	r3, r2
  20916a:	781b      	ldrb	r3, [r3, #0]
  20916c:	461c      	mov	r4, r3
  20916e:	693b      	ldr	r3, [r7, #16]
  209170:	697a      	ldr	r2, [r7, #20]
  209172:	4413      	add	r3, r2
  209174:	781b      	ldrb	r3, [r3, #0]
  209176:	4a15      	ldr	r2, [pc, #84]	; (2091cc <LCD_Reset_ConstWidthFonts+0xe0>)
  209178:	00db      	lsls	r3, r3, #3
  20917a:	4413      	add	r3, r2
  20917c:	6859      	ldr	r1, [r3, #4]
  20917e:	4814      	ldr	r0, [pc, #80]	; (2091d0 <LCD_Reset_ConstWidthFonts+0xe4>)
  209180:	687a      	ldr	r2, [r7, #4]
  209182:	4613      	mov	r3, r2
  209184:	019b      	lsls	r3, r3, #6
  209186:	4413      	add	r3, r2
  209188:	009b      	lsls	r3, r3, #2
  20918a:	4423      	add	r3, r4
  20918c:	00db      	lsls	r3, r3, #3
  20918e:	4403      	add	r3, r0
  209190:	6159      	str	r1, [r3, #20]
	for(j=0; j < lenTab; j++)
  209192:	693b      	ldr	r3, [r7, #16]
  209194:	3301      	adds	r3, #1
  209196:	613b      	str	r3, [r7, #16]
  209198:	693a      	ldr	r2, [r7, #16]
  20919a:	68bb      	ldr	r3, [r7, #8]
  20919c:	429a      	cmp	r2, r3
  20919e:	dbc0      	blt.n	209122 <LCD_Reset_ConstWidthFonts+0x36>
		}
	}
	Font[fontIndex].fontsTabPos[(int)' '][1] = fontsTabPos_temp[(int)' '][1];
  2091a0:	4b0a      	ldr	r3, [pc, #40]	; (2091cc <LCD_Reset_ConstWidthFonts+0xe0>)
  2091a2:	f8d3 1104 	ldr.w	r1, [r3, #260]	; 0x104
  2091a6:	480a      	ldr	r0, [pc, #40]	; (2091d0 <LCD_Reset_ConstWidthFonts+0xe4>)
  2091a8:	687a      	ldr	r2, [r7, #4]
  2091aa:	4613      	mov	r3, r2
  2091ac:	019b      	lsls	r3, r3, #6
  2091ae:	4413      	add	r3, r2
  2091b0:	015b      	lsls	r3, r3, #5
  2091b2:	4403      	add	r3, r0
  2091b4:	f503 738a 	add.w	r3, r3, #276	; 0x114
  2091b8:	6019      	str	r1, [r3, #0]
}
  2091ba:	bf00      	nop
  2091bc:	371c      	adds	r7, #28
  2091be:	46bd      	mov	sp, r7
  2091c0:	bd90      	pop	{r4, r7, pc}
  2091c2:	bf00      	nop
  2091c4:	00229310 	.word	0x00229310
  2091c8:	002292a0 	.word	0x002292a0
  2091cc:	20002c74 	.word	0x20002c74
  2091d0:	20003590 	.word	0x20003590
  2091d4:	00000000 	.word	0x00000000

002091d8 <LCD_DrawStrToBuff>:

static StructTxtPxlLen LCD_DrawStrToBuff(uint32_t posBuff,uint32_t windowX,uint32_t windowY,int id, int X, int Y, char *txt, uint32_t *LcdBuffer,int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth)
{
  2091d8:	b590      	push	{r4, r7, lr}
  2091da:	b0a5      	sub	sp, #148	; 0x94
  2091dc:	af08      	add	r7, sp, #32
  2091de:	60f8      	str	r0, [r7, #12]
  2091e0:	60b9      	str	r1, [r7, #8]
  2091e2:	607a      	str	r2, [r7, #4]
  2091e4:	603b      	str	r3, [r7, #0]
	StructTxtPxlLen structTemp={0,0,0};
  2091e6:	2300      	movs	r3, #0
  2091e8:	82bb      	strh	r3, [r7, #20]
  2091ea:	2300      	movs	r3, #0
  2091ec:	82fb      	strh	r3, [r7, #22]
  2091ee:	2300      	movs	r3, #0
  2091f0:	833b      	strh	r3, [r7, #24]
	int fontIndex=SearchFontIndex(FontID[id].size, FontID[id].style, FontID[id].bkColor, FontID[id].color);
  2091f2:	4a90      	ldr	r2, [pc, #576]	; (209434 <LCD_DrawStrToBuff+0x25c>)
  2091f4:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  2091f8:	011b      	lsls	r3, r3, #4
  2091fa:	4413      	add	r3, r2
  2091fc:	681b      	ldr	r3, [r3, #0]
  2091fe:	4618      	mov	r0, r3
  209200:	4a8c      	ldr	r2, [pc, #560]	; (209434 <LCD_DrawStrToBuff+0x25c>)
  209202:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  209206:	011b      	lsls	r3, r3, #4
  209208:	4413      	add	r3, r2
  20920a:	3304      	adds	r3, #4
  20920c:	681b      	ldr	r3, [r3, #0]
  20920e:	461c      	mov	r4, r3
  209210:	4a88      	ldr	r2, [pc, #544]	; (209434 <LCD_DrawStrToBuff+0x25c>)
  209212:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  209216:	011b      	lsls	r3, r3, #4
  209218:	4413      	add	r3, r2
  20921a:	3308      	adds	r3, #8
  20921c:	6819      	ldr	r1, [r3, #0]
  20921e:	4a85      	ldr	r2, [pc, #532]	; (209434 <LCD_DrawStrToBuff+0x25c>)
  209220:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  209224:	011b      	lsls	r3, r3, #4
  209226:	4413      	add	r3, r2
  209228:	330c      	adds	r3, #12
  20922a:	681b      	ldr	r3, [r3, #0]
  20922c:	460a      	mov	r2, r1
  20922e:	4621      	mov	r1, r4
  209230:	f7ff fb28 	bl	208884 <SearchFontIndex>
  209234:	64b8      	str	r0, [r7, #72]	; 0x48
	if(fontIndex==-1)
  209236:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  209238:	f1b3 3fff 	cmp.w	r3, #4294967295
  20923c:	d108      	bne.n	209250 <LCD_DrawStrToBuff+0x78>
		return structTemp;
  20923e:	68fb      	ldr	r3, [r7, #12]
  209240:	461a      	mov	r2, r3
  209242:	f107 0314 	add.w	r3, r7, #20
  209246:	6818      	ldr	r0, [r3, #0]
  209248:	6010      	str	r0, [r2, #0]
  20924a:	889b      	ldrh	r3, [r3, #4]
  20924c:	8093      	strh	r3, [r2, #4]
  20924e:	e2a6      	b.n	20979e <LCD_DrawStrToBuff+0x5c6>
	char *fontsBuffer=Font[fontIndex].pointerToMemoryFont;
  209250:	4979      	ldr	r1, [pc, #484]	; (209438 <LCD_DrawStrToBuff+0x260>)
  209252:	6cba      	ldr	r2, [r7, #72]	; 0x48
  209254:	4613      	mov	r3, r2
  209256:	019b      	lsls	r3, r3, #6
  209258:	4413      	add	r3, r2
  20925a:	015b      	lsls	r3, r3, #5
  20925c:	440b      	add	r3, r1
  20925e:	f603 0318 	addw	r3, r3, #2072	; 0x818
  209262:	681b      	ldr	r3, [r3, #0]
  209264:	647b      	str	r3, [r7, #68]	; 0x44
	int i,j,n,o,temp,lenTxt,lenTxtInPixel=0;
  209266:	2300      	movs	r3, #0
  209268:	65fb      	str	r3, [r7, #92]	; 0x5c
	int posX=X, posY=Y;
  20926a:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  20926e:	65bb      	str	r3, [r7, #88]	; 0x58
  209270:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  209274:	643b      	str	r3, [r7, #64]	; 0x40
	char *pbmp;
	uint32_t index=0, width=0, height=0, bit_pixel=0;
  209276:	2300      	movs	r3, #0
  209278:	63fb      	str	r3, [r7, #60]	; 0x3c
  20927a:	2300      	movs	r3, #0
  20927c:	63bb      	str	r3, [r7, #56]	; 0x38
  20927e:	2300      	movs	r3, #0
  209280:	653b      	str	r3, [r7, #80]	; 0x50
  209282:	2300      	movs	r3, #0
  209284:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t backGround;
	uint32_t pos, pos2, xi;
	uint32_t Y_bkColor;

	if(constWidth)
  209286:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
  20928a:	2b00      	cmp	r3, #0
  20928c:	d002      	beq.n	209294 <LCD_DrawStrToBuff+0xbc>
		LCD_Set_ConstWidthFonts(fontIndex);
  20928e:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  209290:	f7ff fe2e 	bl	208ef0 <LCD_Set_ConstWidthFonts>

//	touchTemp.x_Start= posX;
//	touchTemp.y_Start= posY;

	/* Get bitmap data address offset */
	index = fontsBuffer[10] + (fontsBuffer[11] << 8) + (fontsBuffer[12] << 16)  + (fontsBuffer[13] << 24);
  209294:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209296:	330a      	adds	r3, #10
  209298:	781b      	ldrb	r3, [r3, #0]
  20929a:	461a      	mov	r2, r3
  20929c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20929e:	330b      	adds	r3, #11
  2092a0:	781b      	ldrb	r3, [r3, #0]
  2092a2:	021b      	lsls	r3, r3, #8
  2092a4:	441a      	add	r2, r3
  2092a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092a8:	330c      	adds	r3, #12
  2092aa:	781b      	ldrb	r3, [r3, #0]
  2092ac:	041b      	lsls	r3, r3, #16
  2092ae:	441a      	add	r2, r3
  2092b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092b2:	330d      	adds	r3, #13
  2092b4:	781b      	ldrb	r3, [r3, #0]
  2092b6:	061b      	lsls	r3, r3, #24
  2092b8:	4413      	add	r3, r2
  2092ba:	63fb      	str	r3, [r7, #60]	; 0x3c
	/* Read bitmap width */
	width = fontsBuffer[18] + (fontsBuffer[19] << 8) + (fontsBuffer[20] << 16)  + (fontsBuffer[21] << 24);  //!!! szerokosc musi byc wielokrotnoscia 4
  2092bc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092be:	3312      	adds	r3, #18
  2092c0:	781b      	ldrb	r3, [r3, #0]
  2092c2:	461a      	mov	r2, r3
  2092c4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092c6:	3313      	adds	r3, #19
  2092c8:	781b      	ldrb	r3, [r3, #0]
  2092ca:	021b      	lsls	r3, r3, #8
  2092cc:	441a      	add	r2, r3
  2092ce:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092d0:	3314      	adds	r3, #20
  2092d2:	781b      	ldrb	r3, [r3, #0]
  2092d4:	041b      	lsls	r3, r3, #16
  2092d6:	441a      	add	r2, r3
  2092d8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092da:	3315      	adds	r3, #21
  2092dc:	781b      	ldrb	r3, [r3, #0]
  2092de:	061b      	lsls	r3, r3, #24
  2092e0:	4413      	add	r3, r2
  2092e2:	63bb      	str	r3, [r7, #56]	; 0x38
	/* Read bitmap height */
	height = fontsBuffer[22] + (fontsBuffer[23] << 8) + (fontsBuffer[24] << 16)  + (fontsBuffer[25] << 24);
  2092e4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092e6:	3316      	adds	r3, #22
  2092e8:	781b      	ldrb	r3, [r3, #0]
  2092ea:	461a      	mov	r2, r3
  2092ec:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092ee:	3317      	adds	r3, #23
  2092f0:	781b      	ldrb	r3, [r3, #0]
  2092f2:	021b      	lsls	r3, r3, #8
  2092f4:	441a      	add	r2, r3
  2092f6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2092f8:	3318      	adds	r3, #24
  2092fa:	781b      	ldrb	r3, [r3, #0]
  2092fc:	041b      	lsls	r3, r3, #16
  2092fe:	441a      	add	r2, r3
  209300:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209302:	3319      	adds	r3, #25
  209304:	781b      	ldrb	r3, [r3, #0]
  209306:	061b      	lsls	r3, r3, #24
  209308:	4413      	add	r3, r2
  20930a:	653b      	str	r3, [r7, #80]	; 0x50
	/* Read bit/pixel */
	bit_pixel = fontsBuffer[28] + (fontsBuffer[29] << 8);
  20930c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20930e:	331c      	adds	r3, #28
  209310:	781b      	ldrb	r3, [r3, #0]
  209312:	461a      	mov	r2, r3
  209314:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209316:	331d      	adds	r3, #29
  209318:	781b      	ldrb	r3, [r3, #0]
  20931a:	021b      	lsls	r3, r3, #8
  20931c:	4413      	add	r3, r2
  20931e:	637b      	str	r3, [r7, #52]	; 0x34
	bit_pixel/=8;
  209320:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  209322:	08db      	lsrs	r3, r3, #3
  209324:	637b      	str	r3, [r7, #52]	; 0x34

	fontsBuffer += (index + (width * height * bit_pixel));
  209326:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  209328:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20932a:	fb02 f303 	mul.w	r3, r2, r3
  20932e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  209330:	fb02 f203 	mul.w	r2, r2, r3
  209334:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209336:	4413      	add	r3, r2
  209338:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20933a:	4413      	add	r3, r2
  20933c:	647b      	str	r3, [r7, #68]	; 0x44
	fontsBuffer -= width*bit_pixel;
  20933e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  209340:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  209342:	fb02 f303 	mul.w	r3, r2, r3
  209346:	425b      	negs	r3, r3
  209348:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20934a:	4413      	add	r3, r2
  20934c:	647b      	str	r3, [r7, #68]	; 0x44

	backGround= fontsBuffer[2]<<16 | fontsBuffer[1]<<8 | fontsBuffer[0];
  20934e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209350:	3302      	adds	r3, #2
  209352:	781b      	ldrb	r3, [r3, #0]
  209354:	041a      	lsls	r2, r3, #16
  209356:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209358:	3301      	adds	r3, #1
  20935a:	781b      	ldrb	r3, [r3, #0]
  20935c:	021b      	lsls	r3, r3, #8
  20935e:	4313      	orrs	r3, r2
  209360:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  209362:	7812      	ldrb	r2, [r2, #0]
  209364:	4313      	orrs	r3, r2
  209366:	633b      	str	r3, [r7, #48]	; 0x30

	if(OnlyDigits==halfHight)
  209368:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  20936c:	f113 0f02 	cmn.w	r3, #2
  209370:	d10a      	bne.n	209388 <LCD_DrawStrToBuff+0x1b0>
		height=Font[fontIndex].heightHalf;
  209372:	4931      	ldr	r1, [pc, #196]	; (209438 <LCD_DrawStrToBuff+0x260>)
  209374:	6cba      	ldr	r2, [r7, #72]	; 0x48
  209376:	4613      	mov	r3, r2
  209378:	019b      	lsls	r3, r3, #6
  20937a:	4413      	add	r3, r2
  20937c:	015b      	lsls	r3, r3, #5
  20937e:	440b      	add	r3, r1
  209380:	f603 0314 	addw	r3, r3, #2068	; 0x814
  209384:	681b      	ldr	r3, [r3, #0]
  209386:	653b      	str	r3, [r7, #80]	; 0x50

	j=strlen(txt);
  209388:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
  20938c:	f7f6 ff58 	bl	200240 <strlen>
  209390:	4603      	mov	r3, r0
  209392:	66bb      	str	r3, [r7, #104]	; 0x68
	for(i=0;i<j;i++)
  209394:	2300      	movs	r3, #0
  209396:	66fb      	str	r3, [r7, #108]	; 0x6c
  209398:	e02e      	b.n	2093f8 <LCD_DrawStrToBuff+0x220>
	{
		temp = Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,id);
  20939a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20939c:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  2093a0:	4413      	add	r3, r2
  2093a2:	781b      	ldrb	r3, [r3, #0]
  2093a4:	4618      	mov	r0, r3
  2093a6:	4924      	ldr	r1, [pc, #144]	; (209438 <LCD_DrawStrToBuff+0x260>)
  2093a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
  2093aa:	4613      	mov	r3, r2
  2093ac:	019b      	lsls	r3, r3, #6
  2093ae:	4413      	add	r3, r2
  2093b0:	009b      	lsls	r3, r3, #2
  2093b2:	4403      	add	r3, r0
  2093b4:	00db      	lsls	r3, r3, #3
  2093b6:	440b      	add	r3, r1
  2093b8:	695a      	ldr	r2, [r3, #20]
  2093ba:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  2093be:	18d4      	adds	r4, r2, r3
  2093c0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2093c2:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  2093c6:	4413      	add	r3, r2
  2093c8:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
  2093cc:	4618      	mov	r0, r3
  2093ce:	f7fe fe47 	bl	208060 <RealizeSpaceCorrect>
  2093d2:	4603      	mov	r3, r0
  2093d4:	4423      	add	r3, r4
  2093d6:	62fb      	str	r3, [r7, #44]	; 0x2c
		if(posX+lenTxtInPixel+temp <= windowX)
  2093d8:	6dba      	ldr	r2, [r7, #88]	; 0x58
  2093da:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  2093dc:	441a      	add	r2, r3
  2093de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2093e0:	4413      	add	r3, r2
  2093e2:	461a      	mov	r2, r3
  2093e4:	687b      	ldr	r3, [r7, #4]
  2093e6:	429a      	cmp	r2, r3
  2093e8:	d80b      	bhi.n	209402 <LCD_DrawStrToBuff+0x22a>
			lenTxtInPixel += temp;
  2093ea:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  2093ec:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2093ee:	4413      	add	r3, r2
  2093f0:	65fb      	str	r3, [r7, #92]	; 0x5c
	for(i=0;i<j;i++)
  2093f2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2093f4:	3301      	adds	r3, #1
  2093f6:	66fb      	str	r3, [r7, #108]	; 0x6c
  2093f8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  2093fa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  2093fc:	429a      	cmp	r2, r3
  2093fe:	dbcc      	blt.n	20939a <LCD_DrawStrToBuff+0x1c2>
  209400:	e000      	b.n	209404 <LCD_DrawStrToBuff+0x22c>
		else break;
  209402:	bf00      	nop
	}
	lenTxt=i;
  209404:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  209406:	62bb      	str	r3, [r7, #40]	; 0x28

	if(bkColor)
  209408:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  20940c:	2b00      	cmp	r3, #0
  20940e:	d05e      	beq.n	2094ce <LCD_DrawStrToBuff+0x2f6>
	{
		LCD_RectangleBuff(LcdBuffer,posBuff,windowX,windowY,X,Y,lenTxtInPixel, Y+height>windowY?windowY-Y:height, bkColor,bkColor,bkColor);
  209410:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  209414:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
  209418:	6df8      	ldr	r0, [r7, #92]	; 0x5c
  20941a:	f8d7 4088 	ldr.w	r4, [r7, #136]	; 0x88
  20941e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  209420:	441c      	add	r4, r3
  209422:	683b      	ldr	r3, [r7, #0]
  209424:	429c      	cmp	r4, r3
  209426:	d909      	bls.n	20943c <LCD_DrawStrToBuff+0x264>
  209428:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  20942c:	683c      	ldr	r4, [r7, #0]
  20942e:	1ae3      	subs	r3, r4, r3
  209430:	e005      	b.n	20943e <LCD_DrawStrToBuff+0x266>
  209432:	bf00      	nop
  209434:	20003480 	.word	0x20003480
  209438:	20003590 	.word	0x20003590
  20943c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20943e:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
  209442:	9406      	str	r4, [sp, #24]
  209444:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
  209448:	9405      	str	r4, [sp, #20]
  20944a:	f8d7 409c 	ldr.w	r4, [r7, #156]	; 0x9c
  20944e:	9404      	str	r4, [sp, #16]
  209450:	9303      	str	r3, [sp, #12]
  209452:	9002      	str	r0, [sp, #8]
  209454:	9101      	str	r1, [sp, #4]
  209456:	9200      	str	r2, [sp, #0]
  209458:	683b      	ldr	r3, [r7, #0]
  20945a:	687a      	ldr	r2, [r7, #4]
  20945c:	68b9      	ldr	r1, [r7, #8]
  20945e:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  209462:	f7fe fdab 	bl	207fbc <LCD_RectangleBuff>
		Y_bkColor= COLOR_TO_Y(bkColor)+coeff;
  209466:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  20946a:	0c1b      	lsrs	r3, r3, #16
  20946c:	b2db      	uxtb	r3, r3
  20946e:	ee07 3a90 	vmov	s15, r3
  209472:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209476:	ed9f 6ba8 	vldr	d6, [pc, #672]	; 209718 <LCD_DrawStrToBuff+0x540>
  20947a:	ee27 6b06 	vmul.f64	d6, d7, d6
  20947e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  209482:	0a1b      	lsrs	r3, r3, #8
  209484:	b2db      	uxtb	r3, r3
  209486:	ee07 3a90 	vmov	s15, r3
  20948a:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20948e:	ed9f 5ba4 	vldr	d5, [pc, #656]	; 209720 <LCD_DrawStrToBuff+0x548>
  209492:	ee27 7b05 	vmul.f64	d7, d7, d5
  209496:	ee36 6b07 	vadd.f64	d6, d6, d7
  20949a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  20949e:	b2db      	uxtb	r3, r3
  2094a0:	ee07 3a90 	vmov	s15, r3
  2094a4:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2094a8:	ed9f 5b9f 	vldr	d5, [pc, #636]	; 209728 <LCD_DrawStrToBuff+0x550>
  2094ac:	ee27 7b05 	vmul.f64	d7, d7, d5
  2094b0:	ee36 6b07 	vadd.f64	d6, d6, d7
  2094b4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  2094b8:	ee07 3a90 	vmov	s15, r3
  2094bc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  2094c0:	ee36 7b07 	vadd.f64	d7, d6, d7
  2094c4:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  2094c8:	ee17 3a90 	vmov	r3, s15
  2094cc:	64fb      	str	r3, [r7, #76]	; 0x4c
	}

	for(n=0;n<lenTxt;++n)
  2094ce:	2300      	movs	r3, #0
  2094d0:	667b      	str	r3, [r7, #100]	; 0x64
  2094d2:	e147      	b.n	209764 <LCD_DrawStrToBuff+0x58c>
	{
		pbmp=fontsBuffer+3*Font[fontIndex].fontsTabPos[ (int)txt[n] ][0];
  2094d4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  2094d6:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  2094da:	4413      	add	r3, r2
  2094dc:	781b      	ldrb	r3, [r3, #0]
  2094de:	4618      	mov	r0, r3
  2094e0:	4993      	ldr	r1, [pc, #588]	; (209730 <LCD_DrawStrToBuff+0x558>)
  2094e2:	6cba      	ldr	r2, [r7, #72]	; 0x48
  2094e4:	4613      	mov	r3, r2
  2094e6:	019b      	lsls	r3, r3, #6
  2094e8:	4413      	add	r3, r2
  2094ea:	009b      	lsls	r3, r3, #2
  2094ec:	4403      	add	r3, r0
  2094ee:	3302      	adds	r3, #2
  2094f0:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
  2094f4:	4613      	mov	r3, r2
  2094f6:	005b      	lsls	r3, r3, #1
  2094f8:	4413      	add	r3, r2
  2094fa:	461a      	mov	r2, r3
  2094fc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2094fe:	4413      	add	r3, r2
  209500:	657b      	str	r3, [r7, #84]	; 0x54
		pos2= posBuff+(windowX*posY + posX);
  209502:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209504:	687a      	ldr	r2, [r7, #4]
  209506:	fb02 f203 	mul.w	r2, r2, r3
  20950a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20950c:	441a      	add	r2, r3
  20950e:	68bb      	ldr	r3, [r7, #8]
  209510:	4413      	add	r3, r2
  209512:	627b      	str	r3, [r7, #36]	; 0x24
		xi=Font[fontIndex].fontsTabPos[ (int)txt[n] ][1];
  209514:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209516:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  20951a:	4413      	add	r3, r2
  20951c:	781b      	ldrb	r3, [r3, #0]
  20951e:	4618      	mov	r0, r3
  209520:	4983      	ldr	r1, [pc, #524]	; (209730 <LCD_DrawStrToBuff+0x558>)
  209522:	6cba      	ldr	r2, [r7, #72]	; 0x48
  209524:	4613      	mov	r3, r2
  209526:	019b      	lsls	r3, r3, #6
  209528:	4413      	add	r3, r2
  20952a:	009b      	lsls	r3, r3, #2
  20952c:	4403      	add	r3, r0
  20952e:	00db      	lsls	r3, r3, #3
  209530:	440b      	add	r3, r1
  209532:	695b      	ldr	r3, [r3, #20]
  209534:	623b      	str	r3, [r7, #32]

		for(j=0; j < height; ++j)
  209536:	2300      	movs	r3, #0
  209538:	66bb      	str	r3, [r7, #104]	; 0x68
  20953a:	e0e4      	b.n	209706 <LCD_DrawStrToBuff+0x52e>
		{
			if(Y+j>=windowY)
  20953c:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  209540:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  209542:	4413      	add	r3, r2
  209544:	461a      	mov	r2, r3
  209546:	683b      	ldr	r3, [r7, #0]
  209548:	429a      	cmp	r2, r3
  20954a:	f080 80f3 	bcs.w	209734 <LCD_DrawStrToBuff+0x55c>
				break;
			pos=pos2+windowX*j;
  20954e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  209550:	687a      	ldr	r2, [r7, #4]
  209552:	fb02 f203 	mul.w	r2, r2, r3
  209556:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  209558:	4413      	add	r3, r2
  20955a:	61fb      	str	r3, [r7, #28]
			o=0;
  20955c:	2300      	movs	r3, #0
  20955e:	663b      	str	r3, [r7, #96]	; 0x60
			for(i=0; i<xi; ++i)
  209560:	2300      	movs	r3, #0
  209562:	66fb      	str	r3, [r7, #108]	; 0x6c
  209564:	e0bf      	b.n	2096e6 <LCD_DrawStrToBuff+0x50e>
			{
				if ((*((uint32_t*)(pbmp+o))&0x00FFFFFF)!=backGround)
  209566:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  209568:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  20956a:	4413      	add	r3, r2
  20956c:	681b      	ldr	r3, [r3, #0]
  20956e:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
  209572:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  209574:	429a      	cmp	r2, r3
  209576:	f000 80b0 	beq.w	2096da <LCD_DrawStrToBuff+0x502>
				{
					LcdBuffer[pos+i]= *((uint32_t*)(pbmp+o));
  20957a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  20957c:	69fb      	ldr	r3, [r7, #28]
  20957e:	4413      	add	r3, r2
  209580:	009b      	lsls	r3, r3, #2
  209582:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  209586:	4413      	add	r3, r2
  209588:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20958a:	6d79      	ldr	r1, [r7, #84]	; 0x54
  20958c:	440a      	add	r2, r1
  20958e:	6812      	ldr	r2, [r2, #0]
  209590:	601a      	str	r2, [r3, #0]

					if(coeff!=0)
  209592:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  209596:	2b00      	cmp	r3, #0
  209598:	f000 809f 	beq.w	2096da <LCD_DrawStrToBuff+0x502>
					{
						if(coeff>0)
  20959c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  2095a0:	2b00      	cmp	r3, #0
  2095a2:	dd4d      	ble.n	209640 <LCD_DrawStrToBuff+0x468>
						{
							if(COLOR_TO_Y(LcdBuffer[pos+i]) < Y_bkColor)
  2095a4:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  2095a6:	69fb      	ldr	r3, [r7, #28]
  2095a8:	4413      	add	r3, r2
  2095aa:	009b      	lsls	r3, r3, #2
  2095ac:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  2095b0:	4413      	add	r3, r2
  2095b2:	681b      	ldr	r3, [r3, #0]
  2095b4:	0c1b      	lsrs	r3, r3, #16
  2095b6:	b2db      	uxtb	r3, r3
  2095b8:	ee07 3a90 	vmov	s15, r3
  2095bc:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2095c0:	ed9f 6b55 	vldr	d6, [pc, #340]	; 209718 <LCD_DrawStrToBuff+0x540>
  2095c4:	ee27 6b06 	vmul.f64	d6, d7, d6
  2095c8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  2095ca:	69fb      	ldr	r3, [r7, #28]
  2095cc:	4413      	add	r3, r2
  2095ce:	009b      	lsls	r3, r3, #2
  2095d0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  2095d4:	4413      	add	r3, r2
  2095d6:	681b      	ldr	r3, [r3, #0]
  2095d8:	0a1b      	lsrs	r3, r3, #8
  2095da:	b2db      	uxtb	r3, r3
  2095dc:	ee07 3a90 	vmov	s15, r3
  2095e0:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2095e4:	ed9f 5b4e 	vldr	d5, [pc, #312]	; 209720 <LCD_DrawStrToBuff+0x548>
  2095e8:	ee27 7b05 	vmul.f64	d7, d7, d5
  2095ec:	ee36 6b07 	vadd.f64	d6, d6, d7
  2095f0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  2095f2:	69fb      	ldr	r3, [r7, #28]
  2095f4:	4413      	add	r3, r2
  2095f6:	009b      	lsls	r3, r3, #2
  2095f8:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  2095fc:	4413      	add	r3, r2
  2095fe:	681b      	ldr	r3, [r3, #0]
  209600:	b2db      	uxtb	r3, r3
  209602:	ee07 3a90 	vmov	s15, r3
  209606:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20960a:	ed9f 5b47 	vldr	d5, [pc, #284]	; 209728 <LCD_DrawStrToBuff+0x550>
  20960e:	ee27 7b05 	vmul.f64	d7, d7, d5
  209612:	ee36 6b07 	vadd.f64	d6, d6, d7
  209616:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  209618:	ee07 3a90 	vmov	s15, r3
  20961c:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209620:	eeb4 6bc7 	vcmpe.f64	d6, d7
  209624:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  209628:	d557      	bpl.n	2096da <LCD_DrawStrToBuff+0x502>
								LcdBuffer[pos+i]= bkColor;
  20962a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  20962c:	69fb      	ldr	r3, [r7, #28]
  20962e:	4413      	add	r3, r2
  209630:	009b      	lsls	r3, r3, #2
  209632:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  209636:	4413      	add	r3, r2
  209638:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
  20963c:	601a      	str	r2, [r3, #0]
  20963e:	e04c      	b.n	2096da <LCD_DrawStrToBuff+0x502>
						}
						else
						{
							if(COLOR_TO_Y(LcdBuffer[pos+i]) > Y_bkColor)
  209640:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  209642:	69fb      	ldr	r3, [r7, #28]
  209644:	4413      	add	r3, r2
  209646:	009b      	lsls	r3, r3, #2
  209648:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  20964c:	4413      	add	r3, r2
  20964e:	681b      	ldr	r3, [r3, #0]
  209650:	0c1b      	lsrs	r3, r3, #16
  209652:	b2db      	uxtb	r3, r3
  209654:	ee07 3a90 	vmov	s15, r3
  209658:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  20965c:	ed9f 6b2e 	vldr	d6, [pc, #184]	; 209718 <LCD_DrawStrToBuff+0x540>
  209660:	ee27 6b06 	vmul.f64	d6, d7, d6
  209664:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  209666:	69fb      	ldr	r3, [r7, #28]
  209668:	4413      	add	r3, r2
  20966a:	009b      	lsls	r3, r3, #2
  20966c:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  209670:	4413      	add	r3, r2
  209672:	681b      	ldr	r3, [r3, #0]
  209674:	0a1b      	lsrs	r3, r3, #8
  209676:	b2db      	uxtb	r3, r3
  209678:	ee07 3a90 	vmov	s15, r3
  20967c:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209680:	ed9f 5b27 	vldr	d5, [pc, #156]	; 209720 <LCD_DrawStrToBuff+0x548>
  209684:	ee27 7b05 	vmul.f64	d7, d7, d5
  209688:	ee36 6b07 	vadd.f64	d6, d6, d7
  20968c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  20968e:	69fb      	ldr	r3, [r7, #28]
  209690:	4413      	add	r3, r2
  209692:	009b      	lsls	r3, r3, #2
  209694:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  209698:	4413      	add	r3, r2
  20969a:	681b      	ldr	r3, [r3, #0]
  20969c:	b2db      	uxtb	r3, r3
  20969e:	ee07 3a90 	vmov	s15, r3
  2096a2:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2096a6:	ed9f 5b20 	vldr	d5, [pc, #128]	; 209728 <LCD_DrawStrToBuff+0x550>
  2096aa:	ee27 7b05 	vmul.f64	d7, d7, d5
  2096ae:	ee36 6b07 	vadd.f64	d6, d6, d7
  2096b2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2096b4:	ee07 3a90 	vmov	s15, r3
  2096b8:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  2096bc:	eeb4 6bc7 	vcmpe.f64	d6, d7
  2096c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2096c4:	dd09      	ble.n	2096da <LCD_DrawStrToBuff+0x502>
								LcdBuffer[pos+i]= bkColor;
  2096c6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  2096c8:	69fb      	ldr	r3, [r7, #28]
  2096ca:	4413      	add	r3, r2
  2096cc:	009b      	lsls	r3, r3, #2
  2096ce:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  2096d2:	4413      	add	r3, r2
  2096d4:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
  2096d8:	601a      	str	r2, [r3, #0]
						}
					}
				}
				o+=3;
  2096da:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  2096dc:	3303      	adds	r3, #3
  2096de:	663b      	str	r3, [r7, #96]	; 0x60
			for(i=0; i<xi; ++i)
  2096e0:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  2096e2:	3301      	adds	r3, #1
  2096e4:	66fb      	str	r3, [r7, #108]	; 0x6c
  2096e6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  2096e8:	6a3b      	ldr	r3, [r7, #32]
  2096ea:	429a      	cmp	r2, r3
  2096ec:	f4ff af3b 	bcc.w	209566 <LCD_DrawStrToBuff+0x38e>
			}
			pbmp -= width*bit_pixel;
  2096f0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2096f2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  2096f4:	fb02 f303 	mul.w	r3, r2, r3
  2096f8:	425b      	negs	r3, r3
  2096fa:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  2096fc:	4413      	add	r3, r2
  2096fe:	657b      	str	r3, [r7, #84]	; 0x54
		for(j=0; j < height; ++j)
  209700:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  209702:	3301      	adds	r3, #1
  209704:	66bb      	str	r3, [r7, #104]	; 0x68
  209706:	6eba      	ldr	r2, [r7, #104]	; 0x68
  209708:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20970a:	429a      	cmp	r2, r3
  20970c:	f4ff af16 	bcc.w	20953c <LCD_DrawStrToBuff+0x364>
  209710:	e011      	b.n	209736 <LCD_DrawStrToBuff+0x55e>
  209712:	bf00      	nop
  209714:	f3af 8000 	nop.w
  209718:	e5604189 	.word	0xe5604189
  20971c:	3fd322d0 	.word	0x3fd322d0
  209720:	39581062 	.word	0x39581062
  209724:	3fe2c8b4 	.word	0x3fe2c8b4
  209728:	9fbe76c9 	.word	0x9fbe76c9
  20972c:	3fbd2f1a 	.word	0x3fbd2f1a
  209730:	20003590 	.word	0x20003590
				break;
  209734:	bf00      	nop
		}
		posX += xi;
  209736:	6dba      	ldr	r2, [r7, #88]	; 0x58
  209738:	6a3b      	ldr	r3, [r7, #32]
  20973a:	4413      	add	r3, r2
  20973c:	65bb      	str	r3, [r7, #88]	; 0x58
		posX += space + RealizeSpaceCorrect(txt+n,id);
  20973e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209740:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209744:	4413      	add	r3, r2
  209746:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
  20974a:	4618      	mov	r0, r3
  20974c:	f7fe fc88 	bl	208060 <RealizeSpaceCorrect>
  209750:	4602      	mov	r2, r0
  209752:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  209756:	4413      	add	r3, r2
  209758:	6dba      	ldr	r2, [r7, #88]	; 0x58
  20975a:	4413      	add	r3, r2
  20975c:	65bb      	str	r3, [r7, #88]	; 0x58
	for(n=0;n<lenTxt;++n)
  20975e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209760:	3301      	adds	r3, #1
  209762:	667b      	str	r3, [r7, #100]	; 0x64
  209764:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209766:	6abb      	ldr	r3, [r7, #40]	; 0x28
  209768:	429a      	cmp	r2, r3
  20976a:	f6ff aeb3 	blt.w	2094d4 <LCD_DrawStrToBuff+0x2fc>
	}

	if(constWidth)
  20976e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
  209772:	2b00      	cmp	r3, #0
  209774:	d002      	beq.n	20977c <LCD_DrawStrToBuff+0x5a4>
		LCD_Reset_ConstWidthFonts(fontIndex);
  209776:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  209778:	f7ff fcb8 	bl	2090ec <LCD_Reset_ConstWidthFonts>
//	touchTemp.x_End= posX;
//	touchTemp.y_End= posY+height;
	structTemp.inChar=lenTxt;
  20977c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20977e:	b29b      	uxth	r3, r3
  209780:	82bb      	strh	r3, [r7, #20]
	structTemp.inPixel=lenTxtInPixel;
  209782:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  209784:	b29b      	uxth	r3, r3
  209786:	82fb      	strh	r3, [r7, #22]
	structTemp.height=j;
  209788:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20978a:	b29b      	uxth	r3, r3
  20978c:	833b      	strh	r3, [r7, #24]
	return structTemp;
  20978e:	68fb      	ldr	r3, [r7, #12]
  209790:	461a      	mov	r2, r3
  209792:	f107 0314 	add.w	r3, r7, #20
  209796:	6818      	ldr	r0, [r3, #0]
  209798:	6010      	str	r0, [r2, #0]
  20979a:	889b      	ldrh	r3, [r3, #4]
  20979c:	8093      	strh	r3, [r2, #4]
}
  20979e:	68f8      	ldr	r0, [r7, #12]
  2097a0:	3774      	adds	r7, #116	; 0x74
  2097a2:	46bd      	mov	sp, r7
  2097a4:	bd90      	pop	{r4, r7, pc}
  2097a6:	bf00      	nop

002097a8 <LCD_DrawStrIndirectToBuffAndDisplay>:
static StructTxtPxlLen LCD_DrawStrIndirectToBuffAndDisplay(uint32_t posBuff, int displayOn, uint32_t maxSizeX, uint32_t maxSizeY, int id, int X, int Y, char *txt, uint32_t *LcdBuffer,int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth)
{
  2097a8:	b5b0      	push	{r4, r5, r7, lr}
  2097aa:	b0a2      	sub	sp, #136	; 0x88
  2097ac:	af08      	add	r7, sp, #32
  2097ae:	60f8      	str	r0, [r7, #12]
  2097b0:	60b9      	str	r1, [r7, #8]
  2097b2:	607a      	str	r2, [r7, #4]
  2097b4:	603b      	str	r3, [r7, #0]
	StructTxtPxlLen structTemp={0,0,0};
  2097b6:	2300      	movs	r3, #0
  2097b8:	823b      	strh	r3, [r7, #16]
  2097ba:	2300      	movs	r3, #0
  2097bc:	827b      	strh	r3, [r7, #18]
  2097be:	2300      	movs	r3, #0
  2097c0:	82bb      	strh	r3, [r7, #20]
	int fontIndex=SearchFontIndex(FontID[id].size, FontID[id].style, FontID[id].bkColor, FontID[id].color);
  2097c2:	4ab7      	ldr	r2, [pc, #732]	; (209aa0 <LCD_DrawStrIndirectToBuffAndDisplay+0x2f8>)
  2097c4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2097c6:	011b      	lsls	r3, r3, #4
  2097c8:	4413      	add	r3, r2
  2097ca:	681b      	ldr	r3, [r3, #0]
  2097cc:	4618      	mov	r0, r3
  2097ce:	4ab4      	ldr	r2, [pc, #720]	; (209aa0 <LCD_DrawStrIndirectToBuffAndDisplay+0x2f8>)
  2097d0:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2097d2:	011b      	lsls	r3, r3, #4
  2097d4:	4413      	add	r3, r2
  2097d6:	3304      	adds	r3, #4
  2097d8:	681b      	ldr	r3, [r3, #0]
  2097da:	461c      	mov	r4, r3
  2097dc:	4ab0      	ldr	r2, [pc, #704]	; (209aa0 <LCD_DrawStrIndirectToBuffAndDisplay+0x2f8>)
  2097de:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2097e0:	011b      	lsls	r3, r3, #4
  2097e2:	4413      	add	r3, r2
  2097e4:	3308      	adds	r3, #8
  2097e6:	6819      	ldr	r1, [r3, #0]
  2097e8:	4aad      	ldr	r2, [pc, #692]	; (209aa0 <LCD_DrawStrIndirectToBuffAndDisplay+0x2f8>)
  2097ea:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2097ec:	011b      	lsls	r3, r3, #4
  2097ee:	4413      	add	r3, r2
  2097f0:	330c      	adds	r3, #12
  2097f2:	681b      	ldr	r3, [r3, #0]
  2097f4:	460a      	mov	r2, r1
  2097f6:	4621      	mov	r1, r4
  2097f8:	f7ff f844 	bl	208884 <SearchFontIndex>
  2097fc:	6438      	str	r0, [r7, #64]	; 0x40
	if(fontIndex==-1)
  2097fe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209800:	f1b3 3fff 	cmp.w	r3, #4294967295
  209804:	d108      	bne.n	209818 <LCD_DrawStrIndirectToBuffAndDisplay+0x70>
		return structTemp;
  209806:	68fb      	ldr	r3, [r7, #12]
  209808:	461a      	mov	r2, r3
  20980a:	f107 0310 	add.w	r3, r7, #16
  20980e:	6818      	ldr	r0, [r3, #0]
  209810:	6010      	str	r0, [r2, #0]
  209812:	889b      	ldrh	r3, [r3, #4]
  209814:	8093      	strh	r3, [r2, #4]
  209816:	e2a9      	b.n	209d6c <LCD_DrawStrIndirectToBuffAndDisplay+0x5c4>
	char *fontsBuffer=Font[fontIndex].pointerToMemoryFont;
  209818:	49a2      	ldr	r1, [pc, #648]	; (209aa4 <LCD_DrawStrIndirectToBuffAndDisplay+0x2fc>)
  20981a:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20981c:	4613      	mov	r3, r2
  20981e:	019b      	lsls	r3, r3, #6
  209820:	4413      	add	r3, r2
  209822:	015b      	lsls	r3, r3, #5
  209824:	440b      	add	r3, r1
  209826:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20982a:	681b      	ldr	r3, [r3, #0]
  20982c:	63fb      	str	r3, [r7, #60]	; 0x3c
	int i,j,n,o,lenTxt,temp,lenTxtInPixel=0;
  20982e:	2300      	movs	r3, #0
  209830:	657b      	str	r3, [r7, #84]	; 0x54
	int posX=0;
  209832:	2300      	movs	r3, #0
  209834:	653b      	str	r3, [r7, #80]	; 0x50
	char *pbmp;
	uint32_t index=0, width=0, height=0, bit_pixel=0;
  209836:	2300      	movs	r3, #0
  209838:	63bb      	str	r3, [r7, #56]	; 0x38
  20983a:	2300      	movs	r3, #0
  20983c:	637b      	str	r3, [r7, #52]	; 0x34
  20983e:	2300      	movs	r3, #0
  209840:	64bb      	str	r3, [r7, #72]	; 0x48
  209842:	2300      	movs	r3, #0
  209844:	633b      	str	r3, [r7, #48]	; 0x30
	uint32_t backGround;
	uint32_t pos, pos2, xi;
	uint32_t Y_bkColor;

	if(constWidth)
  209846:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  20984a:	2b00      	cmp	r3, #0
  20984c:	d002      	beq.n	209854 <LCD_DrawStrIndirectToBuffAndDisplay+0xac>
		LCD_Set_ConstWidthFonts(fontIndex);
  20984e:	6c38      	ldr	r0, [r7, #64]	; 0x40
  209850:	f7ff fb4e 	bl	208ef0 <LCD_Set_ConstWidthFonts>

	/* Get bitmap data address offset */
	index = fontsBuffer[10] + (fontsBuffer[11] << 8) + (fontsBuffer[12] << 16)  + (fontsBuffer[13] << 24);
  209854:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209856:	330a      	adds	r3, #10
  209858:	781b      	ldrb	r3, [r3, #0]
  20985a:	461a      	mov	r2, r3
  20985c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20985e:	330b      	adds	r3, #11
  209860:	781b      	ldrb	r3, [r3, #0]
  209862:	021b      	lsls	r3, r3, #8
  209864:	441a      	add	r2, r3
  209866:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209868:	330c      	adds	r3, #12
  20986a:	781b      	ldrb	r3, [r3, #0]
  20986c:	041b      	lsls	r3, r3, #16
  20986e:	441a      	add	r2, r3
  209870:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209872:	330d      	adds	r3, #13
  209874:	781b      	ldrb	r3, [r3, #0]
  209876:	061b      	lsls	r3, r3, #24
  209878:	4413      	add	r3, r2
  20987a:	63bb      	str	r3, [r7, #56]	; 0x38
	/* Read bitmap width */
	width = fontsBuffer[18] + (fontsBuffer[19] << 8) + (fontsBuffer[20] << 16)  + (fontsBuffer[21] << 24);  //!!! szerokosc musi byc wielokrotnoscia 4
  20987c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20987e:	3312      	adds	r3, #18
  209880:	781b      	ldrb	r3, [r3, #0]
  209882:	461a      	mov	r2, r3
  209884:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209886:	3313      	adds	r3, #19
  209888:	781b      	ldrb	r3, [r3, #0]
  20988a:	021b      	lsls	r3, r3, #8
  20988c:	441a      	add	r2, r3
  20988e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209890:	3314      	adds	r3, #20
  209892:	781b      	ldrb	r3, [r3, #0]
  209894:	041b      	lsls	r3, r3, #16
  209896:	441a      	add	r2, r3
  209898:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20989a:	3315      	adds	r3, #21
  20989c:	781b      	ldrb	r3, [r3, #0]
  20989e:	061b      	lsls	r3, r3, #24
  2098a0:	4413      	add	r3, r2
  2098a2:	637b      	str	r3, [r7, #52]	; 0x34
	/* Read bitmap height */
	height = fontsBuffer[22] + (fontsBuffer[23] << 8) + (fontsBuffer[24] << 16)  + (fontsBuffer[25] << 24);
  2098a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2098a6:	3316      	adds	r3, #22
  2098a8:	781b      	ldrb	r3, [r3, #0]
  2098aa:	461a      	mov	r2, r3
  2098ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2098ae:	3317      	adds	r3, #23
  2098b0:	781b      	ldrb	r3, [r3, #0]
  2098b2:	021b      	lsls	r3, r3, #8
  2098b4:	441a      	add	r2, r3
  2098b6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2098b8:	3318      	adds	r3, #24
  2098ba:	781b      	ldrb	r3, [r3, #0]
  2098bc:	041b      	lsls	r3, r3, #16
  2098be:	441a      	add	r2, r3
  2098c0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2098c2:	3319      	adds	r3, #25
  2098c4:	781b      	ldrb	r3, [r3, #0]
  2098c6:	061b      	lsls	r3, r3, #24
  2098c8:	4413      	add	r3, r2
  2098ca:	64bb      	str	r3, [r7, #72]	; 0x48
	/* Read bit/pixel */
	bit_pixel = fontsBuffer[28] + (fontsBuffer[29] << 8);
  2098cc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2098ce:	331c      	adds	r3, #28
  2098d0:	781b      	ldrb	r3, [r3, #0]
  2098d2:	461a      	mov	r2, r3
  2098d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2098d6:	331d      	adds	r3, #29
  2098d8:	781b      	ldrb	r3, [r3, #0]
  2098da:	021b      	lsls	r3, r3, #8
  2098dc:	4413      	add	r3, r2
  2098de:	633b      	str	r3, [r7, #48]	; 0x30
	bit_pixel/=8;
  2098e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2098e2:	08db      	lsrs	r3, r3, #3
  2098e4:	633b      	str	r3, [r7, #48]	; 0x30

	fontsBuffer += (index + (width * height * bit_pixel));
  2098e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2098e8:	6cba      	ldr	r2, [r7, #72]	; 0x48
  2098ea:	fb02 f303 	mul.w	r3, r2, r3
  2098ee:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  2098f0:	fb02 f203 	mul.w	r2, r2, r3
  2098f4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2098f6:	4413      	add	r3, r2
  2098f8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  2098fa:	4413      	add	r3, r2
  2098fc:	63fb      	str	r3, [r7, #60]	; 0x3c
	fontsBuffer -= width*bit_pixel;
  2098fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  209900:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  209902:	fb02 f303 	mul.w	r3, r2, r3
  209906:	425b      	negs	r3, r3
  209908:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20990a:	4413      	add	r3, r2
  20990c:	63fb      	str	r3, [r7, #60]	; 0x3c

	backGround= fontsBuffer[2]<<16 | fontsBuffer[1]<<8 | fontsBuffer[0];
  20990e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209910:	3302      	adds	r3, #2
  209912:	781b      	ldrb	r3, [r3, #0]
  209914:	041a      	lsls	r2, r3, #16
  209916:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209918:	3301      	adds	r3, #1
  20991a:	781b      	ldrb	r3, [r3, #0]
  20991c:	021b      	lsls	r3, r3, #8
  20991e:	4313      	orrs	r3, r2
  209920:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  209922:	7812      	ldrb	r2, [r2, #0]
  209924:	4313      	orrs	r3, r2
  209926:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(OnlyDigits==halfHight)
  209928:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20992c:	f113 0f02 	cmn.w	r3, #2
  209930:	d10a      	bne.n	209948 <LCD_DrawStrIndirectToBuffAndDisplay+0x1a0>
		height=Font[fontIndex].heightHalf;
  209932:	495c      	ldr	r1, [pc, #368]	; (209aa4 <LCD_DrawStrIndirectToBuffAndDisplay+0x2fc>)
  209934:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  209936:	4613      	mov	r3, r2
  209938:	019b      	lsls	r3, r3, #6
  20993a:	4413      	add	r3, r2
  20993c:	015b      	lsls	r3, r3, #5
  20993e:	440b      	add	r3, r1
  209940:	f603 0314 	addw	r3, r3, #2068	; 0x814
  209944:	681b      	ldr	r3, [r3, #0]
  209946:	64bb      	str	r3, [r7, #72]	; 0x48

	j=strlen(txt);
  209948:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
  20994c:	f7f6 fc78 	bl	200240 <strlen>
  209950:	4603      	mov	r3, r0
  209952:	663b      	str	r3, [r7, #96]	; 0x60
	for(i=0;i<j;i++)
  209954:	2300      	movs	r3, #0
  209956:	667b      	str	r3, [r7, #100]	; 0x64
  209958:	e02e      	b.n	2099b8 <LCD_DrawStrIndirectToBuffAndDisplay+0x210>
	{
		temp = Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,id);
  20995a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20995c:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  209960:	4413      	add	r3, r2
  209962:	781b      	ldrb	r3, [r3, #0]
  209964:	4618      	mov	r0, r3
  209966:	494f      	ldr	r1, [pc, #316]	; (209aa4 <LCD_DrawStrIndirectToBuffAndDisplay+0x2fc>)
  209968:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20996a:	4613      	mov	r3, r2
  20996c:	019b      	lsls	r3, r3, #6
  20996e:	4413      	add	r3, r2
  209970:	009b      	lsls	r3, r3, #2
  209972:	4403      	add	r3, r0
  209974:	00db      	lsls	r3, r3, #3
  209976:	440b      	add	r3, r1
  209978:	695a      	ldr	r2, [r3, #20]
  20997a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  20997e:	18d4      	adds	r4, r2, r3
  209980:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209982:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  209986:	4413      	add	r3, r2
  209988:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
  20998a:	4618      	mov	r0, r3
  20998c:	f7fe fb68 	bl	208060 <RealizeSpaceCorrect>
  209990:	4603      	mov	r3, r0
  209992:	4423      	add	r3, r4
  209994:	62bb      	str	r3, [r7, #40]	; 0x28
		if(X+lenTxtInPixel+temp <= maxSizeX)
  209996:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20999a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20999c:	441a      	add	r2, r3
  20999e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2099a0:	4413      	add	r3, r2
  2099a2:	461a      	mov	r2, r3
  2099a4:	683b      	ldr	r3, [r7, #0]
  2099a6:	429a      	cmp	r2, r3
  2099a8:	d80b      	bhi.n	2099c2 <LCD_DrawStrIndirectToBuffAndDisplay+0x21a>
			lenTxtInPixel += temp;
  2099aa:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  2099ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2099ae:	4413      	add	r3, r2
  2099b0:	657b      	str	r3, [r7, #84]	; 0x54
	for(i=0;i<j;i++)
  2099b2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  2099b4:	3301      	adds	r3, #1
  2099b6:	667b      	str	r3, [r7, #100]	; 0x64
  2099b8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  2099ba:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  2099bc:	429a      	cmp	r2, r3
  2099be:	dbcc      	blt.n	20995a <LCD_DrawStrIndirectToBuffAndDisplay+0x1b2>
  2099c0:	e000      	b.n	2099c4 <LCD_DrawStrIndirectToBuffAndDisplay+0x21c>
		else break;
  2099c2:	bf00      	nop
	}
	lenTxt=i;
  2099c4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  2099c6:	627b      	str	r3, [r7, #36]	; 0x24

	if(bkColor){
  2099c8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  2099cc:	2b00      	cmp	r3, #0
  2099ce:	d058      	beq.n	209a82 <LCD_DrawStrIndirectToBuffAndDisplay+0x2da>
		LCD_RectangleBuff(LcdBuffer,posBuff,lenTxtInPixel,height,0,0,lenTxtInPixel,Y+height>maxSizeY?maxSizeY-Y:height,bkColor,bkColor,bkColor);
  2099d0:	6d78      	ldr	r0, [r7, #84]	; 0x54
  2099d2:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  2099d4:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  2099d8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  2099da:	4419      	add	r1, r3
  2099dc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  2099de:	4299      	cmp	r1, r3
  2099e0:	d904      	bls.n	2099ec <LCD_DrawStrIndirectToBuffAndDisplay+0x244>
  2099e2:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  2099e6:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  2099e8:	1acb      	subs	r3, r1, r3
  2099ea:	e000      	b.n	2099ee <LCD_DrawStrIndirectToBuffAndDisplay+0x246>
  2099ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  2099ee:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
  2099f2:	9106      	str	r1, [sp, #24]
  2099f4:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
  2099f8:	9105      	str	r1, [sp, #20]
  2099fa:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
  2099fe:	9104      	str	r1, [sp, #16]
  209a00:	9303      	str	r3, [sp, #12]
  209a02:	9202      	str	r2, [sp, #8]
  209a04:	2300      	movs	r3, #0
  209a06:	9301      	str	r3, [sp, #4]
  209a08:	2300      	movs	r3, #0
  209a0a:	9300      	str	r3, [sp, #0]
  209a0c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  209a0e:	4602      	mov	r2, r0
  209a10:	68b9      	ldr	r1, [r7, #8]
  209a12:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
  209a16:	f7fe fad1 	bl	207fbc <LCD_RectangleBuff>
		Y_bkColor= COLOR_TO_Y(bkColor)+coeff;
  209a1a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  209a1e:	0c1b      	lsrs	r3, r3, #16
  209a20:	b2db      	uxtb	r3, r3
  209a22:	ee07 3a90 	vmov	s15, r3
  209a26:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209a2a:	ed9f 6b17 	vldr	d6, [pc, #92]	; 209a88 <LCD_DrawStrIndirectToBuffAndDisplay+0x2e0>
  209a2e:	ee27 6b06 	vmul.f64	d6, d7, d6
  209a32:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  209a36:	0a1b      	lsrs	r3, r3, #8
  209a38:	b2db      	uxtb	r3, r3
  209a3a:	ee07 3a90 	vmov	s15, r3
  209a3e:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209a42:	ed9f 5b13 	vldr	d5, [pc, #76]	; 209a90 <LCD_DrawStrIndirectToBuffAndDisplay+0x2e8>
  209a46:	ee27 7b05 	vmul.f64	d7, d7, d5
  209a4a:	ee36 6b07 	vadd.f64	d6, d6, d7
  209a4e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  209a52:	b2db      	uxtb	r3, r3
  209a54:	ee07 3a90 	vmov	s15, r3
  209a58:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209a5c:	ed9f 5b0e 	vldr	d5, [pc, #56]	; 209a98 <LCD_DrawStrIndirectToBuffAndDisplay+0x2f0>
  209a60:	ee27 7b05 	vmul.f64	d7, d7, d5
  209a64:	ee36 6b07 	vadd.f64	d6, d6, d7
  209a68:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  209a6c:	ee07 3a90 	vmov	s15, r3
  209a70:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  209a74:	ee36 7b07 	vadd.f64	d7, d6, d7
  209a78:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  209a7c:	ee17 3a90 	vmov	r3, s15
  209a80:	647b      	str	r3, [r7, #68]	; 0x44
	}

	for(n=0;n<lenTxt;++n)
  209a82:	2300      	movs	r3, #0
  209a84:	65fb      	str	r3, [r7, #92]	; 0x5c
  209a86:	e141      	b.n	209d0c <LCD_DrawStrIndirectToBuffAndDisplay+0x564>
  209a88:	e5604189 	.word	0xe5604189
  209a8c:	3fd322d0 	.word	0x3fd322d0
  209a90:	39581062 	.word	0x39581062
  209a94:	3fe2c8b4 	.word	0x3fe2c8b4
  209a98:	9fbe76c9 	.word	0x9fbe76c9
  209a9c:	3fbd2f1a 	.word	0x3fbd2f1a
  209aa0:	20003480 	.word	0x20003480
  209aa4:	20003590 	.word	0x20003590
	{
		pbmp=fontsBuffer+3*Font[fontIndex].fontsTabPos[ (int)txt[n] ][0];
  209aa8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  209aaa:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  209aae:	4413      	add	r3, r2
  209ab0:	781b      	ldrb	r3, [r3, #0]
  209ab2:	4618      	mov	r0, r3
  209ab4:	49b6      	ldr	r1, [pc, #728]	; (209d90 <LCD_DrawStrIndirectToBuffAndDisplay+0x5e8>)
  209ab6:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  209ab8:	4613      	mov	r3, r2
  209aba:	019b      	lsls	r3, r3, #6
  209abc:	4413      	add	r3, r2
  209abe:	009b      	lsls	r3, r3, #2
  209ac0:	4403      	add	r3, r0
  209ac2:	3302      	adds	r3, #2
  209ac4:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
  209ac8:	4613      	mov	r3, r2
  209aca:	005b      	lsls	r3, r3, #1
  209acc:	4413      	add	r3, r2
  209ace:	461a      	mov	r2, r3
  209ad0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  209ad2:	4413      	add	r3, r2
  209ad4:	64fb      	str	r3, [r7, #76]	; 0x4c
		pos2= posBuff+posX;
  209ad6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  209ad8:	68ba      	ldr	r2, [r7, #8]
  209ada:	4413      	add	r3, r2
  209adc:	623b      	str	r3, [r7, #32]
		xi=Font[fontIndex].fontsTabPos[ (int)txt[n] ][1];
  209ade:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  209ae0:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  209ae4:	4413      	add	r3, r2
  209ae6:	781b      	ldrb	r3, [r3, #0]
  209ae8:	4618      	mov	r0, r3
  209aea:	49a9      	ldr	r1, [pc, #676]	; (209d90 <LCD_DrawStrIndirectToBuffAndDisplay+0x5e8>)
  209aec:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  209aee:	4613      	mov	r3, r2
  209af0:	019b      	lsls	r3, r3, #6
  209af2:	4413      	add	r3, r2
  209af4:	009b      	lsls	r3, r3, #2
  209af6:	4403      	add	r3, r0
  209af8:	00db      	lsls	r3, r3, #3
  209afa:	440b      	add	r3, r1
  209afc:	695b      	ldr	r3, [r3, #20]
  209afe:	61fb      	str	r3, [r7, #28]

		for(j=0; j < height; ++j)
  209b00:	2300      	movs	r3, #0
  209b02:	663b      	str	r3, [r7, #96]	; 0x60
  209b04:	e0e5      	b.n	209cd2 <LCD_DrawStrIndirectToBuffAndDisplay+0x52a>
		{
			if(Y+j>=maxSizeY)
  209b06:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  209b0a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  209b0c:	4413      	add	r3, r2
  209b0e:	461a      	mov	r2, r3
  209b10:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  209b12:	429a      	cmp	r2, r3
  209b14:	f080 80e3 	bcs.w	209cde <LCD_DrawStrIndirectToBuffAndDisplay+0x536>
				break;
			pos=pos2+lenTxtInPixel*j;
  209b18:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  209b1a:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  209b1c:	fb02 f303 	mul.w	r3, r2, r3
  209b20:	461a      	mov	r2, r3
  209b22:	6a3b      	ldr	r3, [r7, #32]
  209b24:	4413      	add	r3, r2
  209b26:	61bb      	str	r3, [r7, #24]
			o=0;
  209b28:	2300      	movs	r3, #0
  209b2a:	65bb      	str	r3, [r7, #88]	; 0x58
			for(i=0; i<xi; ++i)
  209b2c:	2300      	movs	r3, #0
  209b2e:	667b      	str	r3, [r7, #100]	; 0x64
  209b30:	e0bf      	b.n	209cb2 <LCD_DrawStrIndirectToBuffAndDisplay+0x50a>
			{
				if ((*((uint32_t*)(pbmp+o))&0x00FFFFFF)!=backGround)
  209b32:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  209b34:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  209b36:	4413      	add	r3, r2
  209b38:	681b      	ldr	r3, [r3, #0]
  209b3a:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
  209b3e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  209b40:	429a      	cmp	r2, r3
  209b42:	f000 80b0 	beq.w	209ca6 <LCD_DrawStrIndirectToBuffAndDisplay+0x4fe>
				{
					LcdBuffer[pos+i]= *((uint32_t*)(pbmp+o));
  209b46:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209b48:	69bb      	ldr	r3, [r7, #24]
  209b4a:	4413      	add	r3, r2
  209b4c:	009b      	lsls	r3, r3, #2
  209b4e:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209b52:	4413      	add	r3, r2
  209b54:	6dba      	ldr	r2, [r7, #88]	; 0x58
  209b56:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
  209b58:	440a      	add	r2, r1
  209b5a:	6812      	ldr	r2, [r2, #0]
  209b5c:	601a      	str	r2, [r3, #0]

					if(coeff!=0)
  209b5e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  209b62:	2b00      	cmp	r3, #0
  209b64:	f000 809f 	beq.w	209ca6 <LCD_DrawStrIndirectToBuffAndDisplay+0x4fe>
					{
						if(coeff>0)
  209b68:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  209b6c:	2b00      	cmp	r3, #0
  209b6e:	dd4d      	ble.n	209c0c <LCD_DrawStrIndirectToBuffAndDisplay+0x464>
						{
							if(COLOR_TO_Y(LcdBuffer[pos+i]) < Y_bkColor)
  209b70:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209b72:	69bb      	ldr	r3, [r7, #24]
  209b74:	4413      	add	r3, r2
  209b76:	009b      	lsls	r3, r3, #2
  209b78:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209b7c:	4413      	add	r3, r2
  209b7e:	681b      	ldr	r3, [r3, #0]
  209b80:	0c1b      	lsrs	r3, r3, #16
  209b82:	b2db      	uxtb	r3, r3
  209b84:	ee07 3a90 	vmov	s15, r3
  209b88:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209b8c:	ed9f 6b7a 	vldr	d6, [pc, #488]	; 209d78 <LCD_DrawStrIndirectToBuffAndDisplay+0x5d0>
  209b90:	ee27 6b06 	vmul.f64	d6, d7, d6
  209b94:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209b96:	69bb      	ldr	r3, [r7, #24]
  209b98:	4413      	add	r3, r2
  209b9a:	009b      	lsls	r3, r3, #2
  209b9c:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209ba0:	4413      	add	r3, r2
  209ba2:	681b      	ldr	r3, [r3, #0]
  209ba4:	0a1b      	lsrs	r3, r3, #8
  209ba6:	b2db      	uxtb	r3, r3
  209ba8:	ee07 3a90 	vmov	s15, r3
  209bac:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209bb0:	ed9f 5b73 	vldr	d5, [pc, #460]	; 209d80 <LCD_DrawStrIndirectToBuffAndDisplay+0x5d8>
  209bb4:	ee27 7b05 	vmul.f64	d7, d7, d5
  209bb8:	ee36 6b07 	vadd.f64	d6, d6, d7
  209bbc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209bbe:	69bb      	ldr	r3, [r7, #24]
  209bc0:	4413      	add	r3, r2
  209bc2:	009b      	lsls	r3, r3, #2
  209bc4:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209bc8:	4413      	add	r3, r2
  209bca:	681b      	ldr	r3, [r3, #0]
  209bcc:	b2db      	uxtb	r3, r3
  209bce:	ee07 3a90 	vmov	s15, r3
  209bd2:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209bd6:	ed9f 5b6c 	vldr	d5, [pc, #432]	; 209d88 <LCD_DrawStrIndirectToBuffAndDisplay+0x5e0>
  209bda:	ee27 7b05 	vmul.f64	d7, d7, d5
  209bde:	ee36 6b07 	vadd.f64	d6, d6, d7
  209be2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209be4:	ee07 3a90 	vmov	s15, r3
  209be8:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209bec:	eeb4 6bc7 	vcmpe.f64	d6, d7
  209bf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  209bf4:	d557      	bpl.n	209ca6 <LCD_DrawStrIndirectToBuffAndDisplay+0x4fe>
								LcdBuffer[pos+i]= bkColor;
  209bf6:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209bf8:	69bb      	ldr	r3, [r7, #24]
  209bfa:	4413      	add	r3, r2
  209bfc:	009b      	lsls	r3, r3, #2
  209bfe:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209c02:	4413      	add	r3, r2
  209c04:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
  209c08:	601a      	str	r2, [r3, #0]
  209c0a:	e04c      	b.n	209ca6 <LCD_DrawStrIndirectToBuffAndDisplay+0x4fe>
						}
						else
						{
							if(COLOR_TO_Y(LcdBuffer[pos+i]) > Y_bkColor)
  209c0c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209c0e:	69bb      	ldr	r3, [r7, #24]
  209c10:	4413      	add	r3, r2
  209c12:	009b      	lsls	r3, r3, #2
  209c14:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209c18:	4413      	add	r3, r2
  209c1a:	681b      	ldr	r3, [r3, #0]
  209c1c:	0c1b      	lsrs	r3, r3, #16
  209c1e:	b2db      	uxtb	r3, r3
  209c20:	ee07 3a90 	vmov	s15, r3
  209c24:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209c28:	ed9f 6b53 	vldr	d6, [pc, #332]	; 209d78 <LCD_DrawStrIndirectToBuffAndDisplay+0x5d0>
  209c2c:	ee27 6b06 	vmul.f64	d6, d7, d6
  209c30:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209c32:	69bb      	ldr	r3, [r7, #24]
  209c34:	4413      	add	r3, r2
  209c36:	009b      	lsls	r3, r3, #2
  209c38:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209c3c:	4413      	add	r3, r2
  209c3e:	681b      	ldr	r3, [r3, #0]
  209c40:	0a1b      	lsrs	r3, r3, #8
  209c42:	b2db      	uxtb	r3, r3
  209c44:	ee07 3a90 	vmov	s15, r3
  209c48:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209c4c:	ed9f 5b4c 	vldr	d5, [pc, #304]	; 209d80 <LCD_DrawStrIndirectToBuffAndDisplay+0x5d8>
  209c50:	ee27 7b05 	vmul.f64	d7, d7, d5
  209c54:	ee36 6b07 	vadd.f64	d6, d6, d7
  209c58:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209c5a:	69bb      	ldr	r3, [r7, #24]
  209c5c:	4413      	add	r3, r2
  209c5e:	009b      	lsls	r3, r3, #2
  209c60:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209c64:	4413      	add	r3, r2
  209c66:	681b      	ldr	r3, [r3, #0]
  209c68:	b2db      	uxtb	r3, r3
  209c6a:	ee07 3a90 	vmov	s15, r3
  209c6e:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209c72:	ed9f 5b45 	vldr	d5, [pc, #276]	; 209d88 <LCD_DrawStrIndirectToBuffAndDisplay+0x5e0>
  209c76:	ee27 7b05 	vmul.f64	d7, d7, d5
  209c7a:	ee36 6b07 	vadd.f64	d6, d6, d7
  209c7e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209c80:	ee07 3a90 	vmov	s15, r3
  209c84:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  209c88:	eeb4 6bc7 	vcmpe.f64	d6, d7
  209c8c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  209c90:	dd09      	ble.n	209ca6 <LCD_DrawStrIndirectToBuffAndDisplay+0x4fe>
								LcdBuffer[pos+i]= bkColor;
  209c92:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209c94:	69bb      	ldr	r3, [r7, #24]
  209c96:	4413      	add	r3, r2
  209c98:	009b      	lsls	r3, r3, #2
  209c9a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209c9e:	4413      	add	r3, r2
  209ca0:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
  209ca4:	601a      	str	r2, [r3, #0]
						}
					}
				}
				o+=3;
  209ca6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  209ca8:	3303      	adds	r3, #3
  209caa:	65bb      	str	r3, [r7, #88]	; 0x58
			for(i=0; i<xi; ++i)
  209cac:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209cae:	3301      	adds	r3, #1
  209cb0:	667b      	str	r3, [r7, #100]	; 0x64
  209cb2:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209cb4:	69fb      	ldr	r3, [r7, #28]
  209cb6:	429a      	cmp	r2, r3
  209cb8:	f4ff af3b 	bcc.w	209b32 <LCD_DrawStrIndirectToBuffAndDisplay+0x38a>
			}
			pbmp -= width*bit_pixel;
  209cbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  209cbe:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  209cc0:	fb02 f303 	mul.w	r3, r2, r3
  209cc4:	425b      	negs	r3, r3
  209cc6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  209cc8:	4413      	add	r3, r2
  209cca:	64fb      	str	r3, [r7, #76]	; 0x4c
		for(j=0; j < height; ++j)
  209ccc:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  209cce:	3301      	adds	r3, #1
  209cd0:	663b      	str	r3, [r7, #96]	; 0x60
  209cd2:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  209cd4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  209cd6:	429a      	cmp	r2, r3
  209cd8:	f4ff af15 	bcc.w	209b06 <LCD_DrawStrIndirectToBuffAndDisplay+0x35e>
  209cdc:	e000      	b.n	209ce0 <LCD_DrawStrIndirectToBuffAndDisplay+0x538>
				break;
  209cde:	bf00      	nop
		}
		posX += xi;
  209ce0:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  209ce2:	69fb      	ldr	r3, [r7, #28]
  209ce4:	4413      	add	r3, r2
  209ce6:	653b      	str	r3, [r7, #80]	; 0x50
		posX += space + RealizeSpaceCorrect(txt+n,id);
  209ce8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  209cea:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  209cee:	4413      	add	r3, r2
  209cf0:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
  209cf2:	4618      	mov	r0, r3
  209cf4:	f7fe f9b4 	bl	208060 <RealizeSpaceCorrect>
  209cf8:	4602      	mov	r2, r0
  209cfa:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  209cfe:	4413      	add	r3, r2
  209d00:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  209d02:	4413      	add	r3, r2
  209d04:	653b      	str	r3, [r7, #80]	; 0x50
	for(n=0;n<lenTxt;++n)
  209d06:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  209d08:	3301      	adds	r3, #1
  209d0a:	65fb      	str	r3, [r7, #92]	; 0x5c
  209d0c:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  209d0e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  209d10:	429a      	cmp	r2, r3
  209d12:	f6ff aec9 	blt.w	209aa8 <LCD_DrawStrIndirectToBuffAndDisplay+0x300>
	}

	if(constWidth)
  209d16:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  209d1a:	2b00      	cmp	r3, #0
  209d1c:	d002      	beq.n	209d24 <LCD_DrawStrIndirectToBuffAndDisplay+0x57c>
		LCD_Reset_ConstWidthFonts(fontIndex);
  209d1e:	6c38      	ldr	r0, [r7, #64]	; 0x40
  209d20:	f7ff f9e4 	bl	2090ec <LCD_Reset_ConstWidthFonts>

	if(displayOn)
  209d24:	687b      	ldr	r3, [r7, #4]
  209d26:	2b00      	cmp	r3, #0
  209d28:	d00f      	beq.n	209d4a <LCD_DrawStrIndirectToBuffAndDisplay+0x5a2>
		LCD_DisplayBuff((uint32_t)X,(uint32_t)Y,(uint32_t)lenTxtInPixel,(uint32_t)j,LcdBuffer+posBuff);
  209d2a:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
  209d2e:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  209d32:	6d7c      	ldr	r4, [r7, #84]	; 0x54
  209d34:	6e3d      	ldr	r5, [r7, #96]	; 0x60
  209d36:	68bb      	ldr	r3, [r7, #8]
  209d38:	009b      	lsls	r3, r3, #2
  209d3a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  209d3e:	4413      	add	r3, r2
  209d40:	9300      	str	r3, [sp, #0]
  209d42:	462b      	mov	r3, r5
  209d44:	4622      	mov	r2, r4
  209d46:	f7fd fea5 	bl	207a94 <LCD_DisplayBuff>
	structTemp.inChar=lenTxt;
  209d4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  209d4c:	b29b      	uxth	r3, r3
  209d4e:	823b      	strh	r3, [r7, #16]
	structTemp.inPixel=lenTxtInPixel;
  209d50:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  209d52:	b29b      	uxth	r3, r3
  209d54:	827b      	strh	r3, [r7, #18]
	structTemp.height=j;
  209d56:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  209d58:	b29b      	uxth	r3, r3
  209d5a:	82bb      	strh	r3, [r7, #20]
	return structTemp;
  209d5c:	68fb      	ldr	r3, [r7, #12]
  209d5e:	461a      	mov	r2, r3
  209d60:	f107 0310 	add.w	r3, r7, #16
  209d64:	6818      	ldr	r0, [r3, #0]
  209d66:	6010      	str	r0, [r2, #0]
  209d68:	889b      	ldrh	r3, [r3, #4]
  209d6a:	8093      	strh	r3, [r2, #4]

}
  209d6c:	68f8      	ldr	r0, [r7, #12]
  209d6e:	3768      	adds	r7, #104	; 0x68
  209d70:	46bd      	mov	sp, r7
  209d72:	bdb0      	pop	{r4, r5, r7, pc}
  209d74:	f3af 8000 	nop.w
  209d78:	e5604189 	.word	0xe5604189
  209d7c:	3fd322d0 	.word	0x3fd322d0
  209d80:	39581062 	.word	0x39581062
  209d84:	3fe2c8b4 	.word	0x3fe2c8b4
  209d88:	9fbe76c9 	.word	0x9fbe76c9
  209d8c:	3fbd2f1a 	.word	0x3fbd2f1a
  209d90:	20003590 	.word	0x20003590

00209d94 <LCD_DrawStrChangeColorToBuff>:
static StructTxtPxlLen LCD_DrawStrChangeColorToBuff(uint32_t posBuff,uint32_t windowX,uint32_t windowY,int id, int X, int Y, char *txt, uint32_t *LcdBuffer,int OnlyDigits, int space, uint32_t NewBkColor, uint32_t NewFontColor, int constWidth)
{
  209d94:	b590      	push	{r4, r7, lr}
  209d96:	b0a3      	sub	sp, #140	; 0x8c
  209d98:	af08      	add	r7, sp, #32
  209d9a:	60f8      	str	r0, [r7, #12]
  209d9c:	60b9      	str	r1, [r7, #8]
  209d9e:	607a      	str	r2, [r7, #4]
  209da0:	603b      	str	r3, [r7, #0]
	StructTxtPxlLen structTemp={0,0,0};
  209da2:	2300      	movs	r3, #0
  209da4:	823b      	strh	r3, [r7, #16]
  209da6:	2300      	movs	r3, #0
  209da8:	827b      	strh	r3, [r7, #18]
  209daa:	2300      	movs	r3, #0
  209dac:	82bb      	strh	r3, [r7, #20]
	int fontIndex=SearchFontIndex(FontID[id].size, FontID[id].style, FontID[id].bkColor, FontID[id].color);
  209dae:	4aa2      	ldr	r2, [pc, #648]	; (20a038 <LCD_DrawStrChangeColorToBuff+0x2a4>)
  209db0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  209db2:	011b      	lsls	r3, r3, #4
  209db4:	4413      	add	r3, r2
  209db6:	681b      	ldr	r3, [r3, #0]
  209db8:	4618      	mov	r0, r3
  209dba:	4a9f      	ldr	r2, [pc, #636]	; (20a038 <LCD_DrawStrChangeColorToBuff+0x2a4>)
  209dbc:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  209dbe:	011b      	lsls	r3, r3, #4
  209dc0:	4413      	add	r3, r2
  209dc2:	3304      	adds	r3, #4
  209dc4:	681b      	ldr	r3, [r3, #0]
  209dc6:	461c      	mov	r4, r3
  209dc8:	4a9b      	ldr	r2, [pc, #620]	; (20a038 <LCD_DrawStrChangeColorToBuff+0x2a4>)
  209dca:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  209dcc:	011b      	lsls	r3, r3, #4
  209dce:	4413      	add	r3, r2
  209dd0:	3308      	adds	r3, #8
  209dd2:	6819      	ldr	r1, [r3, #0]
  209dd4:	4a98      	ldr	r2, [pc, #608]	; (20a038 <LCD_DrawStrChangeColorToBuff+0x2a4>)
  209dd6:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  209dd8:	011b      	lsls	r3, r3, #4
  209dda:	4413      	add	r3, r2
  209ddc:	330c      	adds	r3, #12
  209dde:	681b      	ldr	r3, [r3, #0]
  209de0:	460a      	mov	r2, r1
  209de2:	4621      	mov	r1, r4
  209de4:	f7fe fd4e 	bl	208884 <SearchFontIndex>
  209de8:	6478      	str	r0, [r7, #68]	; 0x44
	if(fontIndex==-1)
  209dea:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  209dec:	f1b3 3fff 	cmp.w	r3, #4294967295
  209df0:	d108      	bne.n	209e04 <LCD_DrawStrChangeColorToBuff+0x70>
		return structTemp;
  209df2:	68fb      	ldr	r3, [r7, #12]
  209df4:	461a      	mov	r2, r3
  209df6:	f107 0310 	add.w	r3, r7, #16
  209dfa:	6818      	ldr	r0, [r3, #0]
  209dfc:	6010      	str	r0, [r2, #0]
  209dfe:	889b      	ldrh	r3, [r3, #4]
  209e00:	8093      	strh	r3, [r2, #4]
  209e02:	e1dc      	b.n	20a1be <LCD_DrawStrChangeColorToBuff+0x42a>
	char *fontsBuffer=Font[fontIndex].pointerToMemoryFont;
  209e04:	498d      	ldr	r1, [pc, #564]	; (20a03c <LCD_DrawStrChangeColorToBuff+0x2a8>)
  209e06:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  209e08:	4613      	mov	r3, r2
  209e0a:	019b      	lsls	r3, r3, #6
  209e0c:	4413      	add	r3, r2
  209e0e:	015b      	lsls	r3, r3, #5
  209e10:	440b      	add	r3, r1
  209e12:	f603 0318 	addw	r3, r3, #2072	; 0x818
  209e16:	681b      	ldr	r3, [r3, #0]
  209e18:	643b      	str	r3, [r7, #64]	; 0x40
	int i,j,n,o,lenTxt,temp,lenTxtInPixel=0;
  209e1a:	2300      	movs	r3, #0
  209e1c:	657b      	str	r3, [r7, #84]	; 0x54
	int posX=X, posY=Y;
  209e1e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  209e20:	653b      	str	r3, [r7, #80]	; 0x50
  209e22:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  209e26:	63fb      	str	r3, [r7, #60]	; 0x3c
	char *pbmp;
	uint32_t index=0, width=0, height=0, bit_pixel=0;
  209e28:	2300      	movs	r3, #0
  209e2a:	63bb      	str	r3, [r7, #56]	; 0x38
  209e2c:	2300      	movs	r3, #0
  209e2e:	637b      	str	r3, [r7, #52]	; 0x34
  209e30:	2300      	movs	r3, #0
  209e32:	64bb      	str	r3, [r7, #72]	; 0x48
  209e34:	2300      	movs	r3, #0
  209e36:	633b      	str	r3, [r7, #48]	; 0x30
	uint32_t backGround;
	uint32_t pos, pos2, xi;

	if(constWidth)
  209e38:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  209e3c:	2b00      	cmp	r3, #0
  209e3e:	d002      	beq.n	209e46 <LCD_DrawStrChangeColorToBuff+0xb2>
		LCD_Set_ConstWidthFonts(fontIndex);
  209e40:	6c78      	ldr	r0, [r7, #68]	; 0x44
  209e42:	f7ff f855 	bl	208ef0 <LCD_Set_ConstWidthFonts>

//	touchTemp.x_Start= posX;
//	touchTemp.y_Start= posY;

	/* Get bitmap data address offset */
	index = fontsBuffer[10] + (fontsBuffer[11] << 8) + (fontsBuffer[12] << 16)  + (fontsBuffer[13] << 24);
  209e46:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e48:	330a      	adds	r3, #10
  209e4a:	781b      	ldrb	r3, [r3, #0]
  209e4c:	461a      	mov	r2, r3
  209e4e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e50:	330b      	adds	r3, #11
  209e52:	781b      	ldrb	r3, [r3, #0]
  209e54:	021b      	lsls	r3, r3, #8
  209e56:	441a      	add	r2, r3
  209e58:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e5a:	330c      	adds	r3, #12
  209e5c:	781b      	ldrb	r3, [r3, #0]
  209e5e:	041b      	lsls	r3, r3, #16
  209e60:	441a      	add	r2, r3
  209e62:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e64:	330d      	adds	r3, #13
  209e66:	781b      	ldrb	r3, [r3, #0]
  209e68:	061b      	lsls	r3, r3, #24
  209e6a:	4413      	add	r3, r2
  209e6c:	63bb      	str	r3, [r7, #56]	; 0x38
	/* Read bitmap width */
	width = fontsBuffer[18] + (fontsBuffer[19] << 8) + (fontsBuffer[20] << 16)  + (fontsBuffer[21] << 24);  //!!! szerokosc musi byc wielokrotnoscia 4
  209e6e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e70:	3312      	adds	r3, #18
  209e72:	781b      	ldrb	r3, [r3, #0]
  209e74:	461a      	mov	r2, r3
  209e76:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e78:	3313      	adds	r3, #19
  209e7a:	781b      	ldrb	r3, [r3, #0]
  209e7c:	021b      	lsls	r3, r3, #8
  209e7e:	441a      	add	r2, r3
  209e80:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e82:	3314      	adds	r3, #20
  209e84:	781b      	ldrb	r3, [r3, #0]
  209e86:	041b      	lsls	r3, r3, #16
  209e88:	441a      	add	r2, r3
  209e8a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e8c:	3315      	adds	r3, #21
  209e8e:	781b      	ldrb	r3, [r3, #0]
  209e90:	061b      	lsls	r3, r3, #24
  209e92:	4413      	add	r3, r2
  209e94:	637b      	str	r3, [r7, #52]	; 0x34
	/* Read bitmap height */
	height = fontsBuffer[22] + (fontsBuffer[23] << 8) + (fontsBuffer[24] << 16)  + (fontsBuffer[25] << 24);
  209e96:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209e98:	3316      	adds	r3, #22
  209e9a:	781b      	ldrb	r3, [r3, #0]
  209e9c:	461a      	mov	r2, r3
  209e9e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209ea0:	3317      	adds	r3, #23
  209ea2:	781b      	ldrb	r3, [r3, #0]
  209ea4:	021b      	lsls	r3, r3, #8
  209ea6:	441a      	add	r2, r3
  209ea8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209eaa:	3318      	adds	r3, #24
  209eac:	781b      	ldrb	r3, [r3, #0]
  209eae:	041b      	lsls	r3, r3, #16
  209eb0:	441a      	add	r2, r3
  209eb2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209eb4:	3319      	adds	r3, #25
  209eb6:	781b      	ldrb	r3, [r3, #0]
  209eb8:	061b      	lsls	r3, r3, #24
  209eba:	4413      	add	r3, r2
  209ebc:	64bb      	str	r3, [r7, #72]	; 0x48
	/* Read bit/pixel */
	bit_pixel = fontsBuffer[28] + (fontsBuffer[29] << 8);
  209ebe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209ec0:	331c      	adds	r3, #28
  209ec2:	781b      	ldrb	r3, [r3, #0]
  209ec4:	461a      	mov	r2, r3
  209ec6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209ec8:	331d      	adds	r3, #29
  209eca:	781b      	ldrb	r3, [r3, #0]
  209ecc:	021b      	lsls	r3, r3, #8
  209ece:	4413      	add	r3, r2
  209ed0:	633b      	str	r3, [r7, #48]	; 0x30
	bit_pixel/=8;
  209ed2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  209ed4:	08db      	lsrs	r3, r3, #3
  209ed6:	633b      	str	r3, [r7, #48]	; 0x30

	fontsBuffer += (index + (width * height * bit_pixel));
  209ed8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  209eda:	6cba      	ldr	r2, [r7, #72]	; 0x48
  209edc:	fb02 f303 	mul.w	r3, r2, r3
  209ee0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  209ee2:	fb02 f203 	mul.w	r2, r2, r3
  209ee6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  209ee8:	4413      	add	r3, r2
  209eea:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  209eec:	4413      	add	r3, r2
  209eee:	643b      	str	r3, [r7, #64]	; 0x40
	fontsBuffer -= width*bit_pixel;
  209ef0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  209ef2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  209ef4:	fb02 f303 	mul.w	r3, r2, r3
  209ef8:	425b      	negs	r3, r3
  209efa:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  209efc:	4413      	add	r3, r2
  209efe:	643b      	str	r3, [r7, #64]	; 0x40

	backGround= fontsBuffer[2]<<16 | fontsBuffer[1]<<8 | fontsBuffer[0];
  209f00:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209f02:	3302      	adds	r3, #2
  209f04:	781b      	ldrb	r3, [r3, #0]
  209f06:	041a      	lsls	r2, r3, #16
  209f08:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  209f0a:	3301      	adds	r3, #1
  209f0c:	781b      	ldrb	r3, [r3, #0]
  209f0e:	021b      	lsls	r3, r3, #8
  209f10:	4313      	orrs	r3, r2
  209f12:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  209f14:	7812      	ldrb	r2, [r2, #0]
  209f16:	4313      	orrs	r3, r2
  209f18:	62fb      	str	r3, [r7, #44]	; 0x2c

	if(OnlyDigits==halfHight)
  209f1a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  209f1e:	f113 0f02 	cmn.w	r3, #2
  209f22:	d10a      	bne.n	209f3a <LCD_DrawStrChangeColorToBuff+0x1a6>
		height=Font[fontIndex].heightHalf;
  209f24:	4945      	ldr	r1, [pc, #276]	; (20a03c <LCD_DrawStrChangeColorToBuff+0x2a8>)
  209f26:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  209f28:	4613      	mov	r3, r2
  209f2a:	019b      	lsls	r3, r3, #6
  209f2c:	4413      	add	r3, r2
  209f2e:	015b      	lsls	r3, r3, #5
  209f30:	440b      	add	r3, r1
  209f32:	f603 0314 	addw	r3, r3, #2068	; 0x814
  209f36:	681b      	ldr	r3, [r3, #0]
  209f38:	64bb      	str	r3, [r7, #72]	; 0x48

	j=strlen(txt);
  209f3a:	f8d7 0084 	ldr.w	r0, [r7, #132]	; 0x84
  209f3e:	f7f6 f97f 	bl	200240 <strlen>
  209f42:	4603      	mov	r3, r0
  209f44:	663b      	str	r3, [r7, #96]	; 0x60
	for(i=0;i<j;i++)
  209f46:	2300      	movs	r3, #0
  209f48:	667b      	str	r3, [r7, #100]	; 0x64
  209f4a:	e02d      	b.n	209fa8 <LCD_DrawStrChangeColorToBuff+0x214>
	{
		temp = Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,id);
  209f4c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209f4e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  209f52:	4413      	add	r3, r2
  209f54:	781b      	ldrb	r3, [r3, #0]
  209f56:	4618      	mov	r0, r3
  209f58:	4938      	ldr	r1, [pc, #224]	; (20a03c <LCD_DrawStrChangeColorToBuff+0x2a8>)
  209f5a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  209f5c:	4613      	mov	r3, r2
  209f5e:	019b      	lsls	r3, r3, #6
  209f60:	4413      	add	r3, r2
  209f62:	009b      	lsls	r3, r3, #2
  209f64:	4403      	add	r3, r0
  209f66:	00db      	lsls	r3, r3, #3
  209f68:	440b      	add	r3, r1
  209f6a:	695a      	ldr	r2, [r3, #20]
  209f6c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  209f70:	18d4      	adds	r4, r2, r3
  209f72:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209f74:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  209f78:	4413      	add	r3, r2
  209f7a:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  209f7c:	4618      	mov	r0, r3
  209f7e:	f7fe f86f 	bl	208060 <RealizeSpaceCorrect>
  209f82:	4603      	mov	r3, r0
  209f84:	4423      	add	r3, r4
  209f86:	62bb      	str	r3, [r7, #40]	; 0x28
		if(posX+lenTxtInPixel+temp <= windowX)
  209f88:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  209f8a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  209f8c:	441a      	add	r2, r3
  209f8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  209f90:	4413      	add	r3, r2
  209f92:	461a      	mov	r2, r3
  209f94:	687b      	ldr	r3, [r7, #4]
  209f96:	429a      	cmp	r2, r3
  209f98:	d80b      	bhi.n	209fb2 <LCD_DrawStrChangeColorToBuff+0x21e>
			lenTxtInPixel += temp;
  209f9a:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  209f9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  209f9e:	4413      	add	r3, r2
  209fa0:	657b      	str	r3, [r7, #84]	; 0x54
	for(i=0;i<j;i++)
  209fa2:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209fa4:	3301      	adds	r3, #1
  209fa6:	667b      	str	r3, [r7, #100]	; 0x64
  209fa8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  209faa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  209fac:	429a      	cmp	r2, r3
  209fae:	dbcd      	blt.n	209f4c <LCD_DrawStrChangeColorToBuff+0x1b8>
  209fb0:	e000      	b.n	209fb4 <LCD_DrawStrChangeColorToBuff+0x220>
		else break;
  209fb2:	bf00      	nop
	}
	lenTxt=i;
  209fb4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  209fb6:	627b      	str	r3, [r7, #36]	; 0x24

	LCD_RectangleBuff(LcdBuffer,posBuff,windowX,windowY,X,Y,lenTxtInPixel,Y+height>windowY?windowY-Y:height,NewBkColor,NewBkColor,NewBkColor);
  209fb8:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  209fba:	f8d7 1080 	ldr.w	r1, [r7, #128]	; 0x80
  209fbe:	6d78      	ldr	r0, [r7, #84]	; 0x54
  209fc0:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
  209fc4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  209fc6:	441c      	add	r4, r3
  209fc8:	683b      	ldr	r3, [r7, #0]
  209fca:	429c      	cmp	r4, r3
  209fcc:	d904      	bls.n	209fd8 <LCD_DrawStrChangeColorToBuff+0x244>
  209fce:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  209fd2:	683c      	ldr	r4, [r7, #0]
  209fd4:	1ae3      	subs	r3, r4, r3
  209fd6:	e000      	b.n	209fda <LCD_DrawStrChangeColorToBuff+0x246>
  209fd8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  209fda:	f8d7 4094 	ldr.w	r4, [r7, #148]	; 0x94
  209fde:	9406      	str	r4, [sp, #24]
  209fe0:	f8d7 4094 	ldr.w	r4, [r7, #148]	; 0x94
  209fe4:	9405      	str	r4, [sp, #20]
  209fe6:	f8d7 4094 	ldr.w	r4, [r7, #148]	; 0x94
  209fea:	9404      	str	r4, [sp, #16]
  209fec:	9303      	str	r3, [sp, #12]
  209fee:	9002      	str	r0, [sp, #8]
  209ff0:	9101      	str	r1, [sp, #4]
  209ff2:	9200      	str	r2, [sp, #0]
  209ff4:	683b      	ldr	r3, [r7, #0]
  209ff6:	687a      	ldr	r2, [r7, #4]
  209ff8:	68b9      	ldr	r1, [r7, #8]
  209ffa:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
  209ffe:	f7fd ffdd 	bl	207fbc <LCD_RectangleBuff>
	idxChangeColorBuff=0;
  20a002:	4b0f      	ldr	r3, [pc, #60]	; (20a040 <LCD_DrawStrChangeColorToBuff+0x2ac>)
  20a004:	2200      	movs	r2, #0
  20a006:	601a      	str	r2, [r3, #0]
   for(i=0;i<MAX_SIZE_CHANGECOLOR_BUFF;++i){
  20a008:	2300      	movs	r3, #0
  20a00a:	667b      	str	r3, [r7, #100]	; 0x64
  20a00c:	e00c      	b.n	20a028 <LCD_DrawStrChangeColorToBuff+0x294>
   	buffChangeColorIN[i]=0;
  20a00e:	4a0d      	ldr	r2, [pc, #52]	; (20a044 <LCD_DrawStrChangeColorToBuff+0x2b0>)
  20a010:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a012:	2100      	movs	r1, #0
  20a014:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   	buffChangeColorOUT[i]=0;
  20a018:	4a0b      	ldr	r2, [pc, #44]	; (20a048 <LCD_DrawStrChangeColorToBuff+0x2b4>)
  20a01a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a01c:	2100      	movs	r1, #0
  20a01e:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   for(i=0;i<MAX_SIZE_CHANGECOLOR_BUFF;++i){
  20a022:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a024:	3301      	adds	r3, #1
  20a026:	667b      	str	r3, [r7, #100]	; 0x64
  20a028:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a02a:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
  20a02e:	dbee      	blt.n	20a00e <LCD_DrawStrChangeColorToBuff+0x27a>
   }

	for(n=0;n<lenTxt;++n)
  20a030:	2300      	movs	r3, #0
  20a032:	65fb      	str	r3, [r7, #92]	; 0x5c
  20a034:	e0a6      	b.n	20a184 <LCD_DrawStrChangeColorToBuff+0x3f0>
  20a036:	bf00      	nop
  20a038:	20003480 	.word	0x20003480
  20a03c:	20003590 	.word	0x20003590
  20a040:	20002c70 	.word	0x20002c70
  20a044:	20002310 	.word	0x20002310
  20a048:	200027c0 	.word	0x200027c0
	{
		pbmp=fontsBuffer+3*Font[fontIndex].fontsTabPos[ (int)txt[n] ][0];
  20a04c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a04e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  20a052:	4413      	add	r3, r2
  20a054:	781b      	ldrb	r3, [r3, #0]
  20a056:	4618      	mov	r0, r3
  20a058:	495b      	ldr	r1, [pc, #364]	; (20a1c8 <LCD_DrawStrChangeColorToBuff+0x434>)
  20a05a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a05c:	4613      	mov	r3, r2
  20a05e:	019b      	lsls	r3, r3, #6
  20a060:	4413      	add	r3, r2
  20a062:	009b      	lsls	r3, r3, #2
  20a064:	4403      	add	r3, r0
  20a066:	3302      	adds	r3, #2
  20a068:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
  20a06c:	4613      	mov	r3, r2
  20a06e:	005b      	lsls	r3, r3, #1
  20a070:	4413      	add	r3, r2
  20a072:	461a      	mov	r2, r3
  20a074:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a076:	4413      	add	r3, r2
  20a078:	64fb      	str	r3, [r7, #76]	; 0x4c
		pos2= posBuff+(windowX*posY + posX);
  20a07a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20a07c:	687a      	ldr	r2, [r7, #4]
  20a07e:	fb02 f203 	mul.w	r2, r2, r3
  20a082:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20a084:	441a      	add	r2, r3
  20a086:	68bb      	ldr	r3, [r7, #8]
  20a088:	4413      	add	r3, r2
  20a08a:	623b      	str	r3, [r7, #32]
		xi=Font[fontIndex].fontsTabPos[ (int)txt[n] ][1];
  20a08c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a08e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  20a092:	4413      	add	r3, r2
  20a094:	781b      	ldrb	r3, [r3, #0]
  20a096:	4618      	mov	r0, r3
  20a098:	494b      	ldr	r1, [pc, #300]	; (20a1c8 <LCD_DrawStrChangeColorToBuff+0x434>)
  20a09a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a09c:	4613      	mov	r3, r2
  20a09e:	019b      	lsls	r3, r3, #6
  20a0a0:	4413      	add	r3, r2
  20a0a2:	009b      	lsls	r3, r3, #2
  20a0a4:	4403      	add	r3, r0
  20a0a6:	00db      	lsls	r3, r3, #3
  20a0a8:	440b      	add	r3, r1
  20a0aa:	695b      	ldr	r3, [r3, #20]
  20a0ac:	61fb      	str	r3, [r7, #28]

		for(j=0; j < height; ++j)
  20a0ae:	2300      	movs	r3, #0
  20a0b0:	663b      	str	r3, [r7, #96]	; 0x60
  20a0b2:	e04b      	b.n	20a14c <LCD_DrawStrChangeColorToBuff+0x3b8>
		{
			if(Y+j>=windowY)
  20a0b4:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20a0b8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a0ba:	4413      	add	r3, r2
  20a0bc:	461a      	mov	r2, r3
  20a0be:	683b      	ldr	r3, [r7, #0]
  20a0c0:	429a      	cmp	r2, r3
  20a0c2:	d248      	bcs.n	20a156 <LCD_DrawStrChangeColorToBuff+0x3c2>
				break;
			pos=pos2+windowX*j;
  20a0c4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a0c6:	687a      	ldr	r2, [r7, #4]
  20a0c8:	fb02 f203 	mul.w	r2, r2, r3
  20a0cc:	6a3b      	ldr	r3, [r7, #32]
  20a0ce:	4413      	add	r3, r2
  20a0d0:	61bb      	str	r3, [r7, #24]
			o=0;
  20a0d2:	2300      	movs	r3, #0
  20a0d4:	65bb      	str	r3, [r7, #88]	; 0x58
			for(i=0; i<xi; ++i)
  20a0d6:	2300      	movs	r3, #0
  20a0d8:	667b      	str	r3, [r7, #100]	; 0x64
  20a0da:	e028      	b.n	20a12e <LCD_DrawStrChangeColorToBuff+0x39a>
			{
				if ((*((uint32_t*)(pbmp+o))&0x00FFFFFF)!=backGround)
  20a0dc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a0de:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a0e0:	4413      	add	r3, r2
  20a0e2:	681b      	ldr	r3, [r3, #0]
  20a0e4:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
  20a0e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a0ea:	429a      	cmp	r2, r3
  20a0ec:	d019      	beq.n	20a122 <LCD_DrawStrChangeColorToBuff+0x38e>
					LcdBuffer[pos+i] = GetCalculatedRGB(*(pbmp+o+2),*(pbmp+o+1),*(pbmp+o+0));
  20a0ee:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20a0f0:	69bb      	ldr	r3, [r7, #24]
  20a0f2:	4413      	add	r3, r2
  20a0f4:	009b      	lsls	r3, r3, #2
  20a0f6:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20a0fa:	18d4      	adds	r4, r2, r3
  20a0fc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a0fe:	3302      	adds	r3, #2
  20a100:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a102:	4413      	add	r3, r2
  20a104:	7818      	ldrb	r0, [r3, #0]
  20a106:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a108:	3301      	adds	r3, #1
  20a10a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a10c:	4413      	add	r3, r2
  20a10e:	7819      	ldrb	r1, [r3, #0]
  20a110:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a112:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a114:	4413      	add	r3, r2
  20a116:	781b      	ldrb	r3, [r3, #0]
  20a118:	461a      	mov	r2, r3
  20a11a:	f7fe f9d1 	bl	2084c0 <GetCalculatedRGB>
  20a11e:	4603      	mov	r3, r0
  20a120:	6023      	str	r3, [r4, #0]
				o+=3;
  20a122:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a124:	3303      	adds	r3, #3
  20a126:	65bb      	str	r3, [r7, #88]	; 0x58
			for(i=0; i<xi; ++i)
  20a128:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a12a:	3301      	adds	r3, #1
  20a12c:	667b      	str	r3, [r7, #100]	; 0x64
  20a12e:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20a130:	69fb      	ldr	r3, [r7, #28]
  20a132:	429a      	cmp	r2, r3
  20a134:	d3d2      	bcc.n	20a0dc <LCD_DrawStrChangeColorToBuff+0x348>
			}
			pbmp -= width*bit_pixel;
  20a136:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20a138:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  20a13a:	fb02 f303 	mul.w	r3, r2, r3
  20a13e:	425b      	negs	r3, r3
  20a140:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a142:	4413      	add	r3, r2
  20a144:	64fb      	str	r3, [r7, #76]	; 0x4c
		for(j=0; j < height; ++j)
  20a146:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a148:	3301      	adds	r3, #1
  20a14a:	663b      	str	r3, [r7, #96]	; 0x60
  20a14c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20a14e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20a150:	429a      	cmp	r2, r3
  20a152:	d3af      	bcc.n	20a0b4 <LCD_DrawStrChangeColorToBuff+0x320>
  20a154:	e000      	b.n	20a158 <LCD_DrawStrChangeColorToBuff+0x3c4>
				break;
  20a156:	bf00      	nop
		}
		posX += xi;
  20a158:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20a15a:	69fb      	ldr	r3, [r7, #28]
  20a15c:	4413      	add	r3, r2
  20a15e:	653b      	str	r3, [r7, #80]	; 0x50
		posX += space + RealizeSpaceCorrect(txt+n,id);
  20a160:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a162:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  20a166:	4413      	add	r3, r2
  20a168:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  20a16a:	4618      	mov	r0, r3
  20a16c:	f7fd ff78 	bl	208060 <RealizeSpaceCorrect>
  20a170:	4602      	mov	r2, r0
  20a172:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20a176:	4413      	add	r3, r2
  20a178:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20a17a:	4413      	add	r3, r2
  20a17c:	653b      	str	r3, [r7, #80]	; 0x50
	for(n=0;n<lenTxt;++n)
  20a17e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a180:	3301      	adds	r3, #1
  20a182:	65fb      	str	r3, [r7, #92]	; 0x5c
  20a184:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  20a186:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a188:	429a      	cmp	r2, r3
  20a18a:	f6ff af5f 	blt.w	20a04c <LCD_DrawStrChangeColorToBuff+0x2b8>
	}
//	touchTemp.x_End= posX;
//	touchTemp.y_End= posY+height;

	if(constWidth)
  20a18e:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  20a192:	2b00      	cmp	r3, #0
  20a194:	d002      	beq.n	20a19c <LCD_DrawStrChangeColorToBuff+0x408>
		LCD_Reset_ConstWidthFonts(fontIndex);
  20a196:	6c78      	ldr	r0, [r7, #68]	; 0x44
  20a198:	f7fe ffa8 	bl	2090ec <LCD_Reset_ConstWidthFonts>

	structTemp.inChar=lenTxt;
  20a19c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a19e:	b29b      	uxth	r3, r3
  20a1a0:	823b      	strh	r3, [r7, #16]
	structTemp.inPixel=lenTxtInPixel;
  20a1a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20a1a4:	b29b      	uxth	r3, r3
  20a1a6:	827b      	strh	r3, [r7, #18]
	structTemp.height=j;
  20a1a8:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a1aa:	b29b      	uxth	r3, r3
  20a1ac:	82bb      	strh	r3, [r7, #20]
	return structTemp;
  20a1ae:	68fb      	ldr	r3, [r7, #12]
  20a1b0:	461a      	mov	r2, r3
  20a1b2:	f107 0310 	add.w	r3, r7, #16
  20a1b6:	6818      	ldr	r0, [r3, #0]
  20a1b8:	6010      	str	r0, [r2, #0]
  20a1ba:	889b      	ldrh	r3, [r3, #4]
  20a1bc:	8093      	strh	r3, [r2, #4]

}
  20a1be:	68f8      	ldr	r0, [r7, #12]
  20a1c0:	376c      	adds	r7, #108	; 0x6c
  20a1c2:	46bd      	mov	sp, r7
  20a1c4:	bd90      	pop	{r4, r7, pc}
  20a1c6:	bf00      	nop
  20a1c8:	20003590 	.word	0x20003590

0020a1cc <LCD_DrawStrChangeColorIndirectToBuffAndDisplay>:
static StructTxtPxlLen LCD_DrawStrChangeColorIndirectToBuffAndDisplay(uint32_t posBuff, int displayOn, uint32_t maxSizeX, uint32_t maxSizeY, int id, int X, int Y, char *txt, uint32_t *LcdBuffer,int OnlyDigits, int space, uint32_t NewBkColor, uint32_t NewFontColor, int constWidth)
{
  20a1cc:	b5b0      	push	{r4, r5, r7, lr}
  20a1ce:	b0a2      	sub	sp, #136	; 0x88
  20a1d0:	af08      	add	r7, sp, #32
  20a1d2:	60f8      	str	r0, [r7, #12]
  20a1d4:	60b9      	str	r1, [r7, #8]
  20a1d6:	607a      	str	r2, [r7, #4]
  20a1d8:	603b      	str	r3, [r7, #0]
	StructTxtPxlLen structTemp={0,0,0};
  20a1da:	2300      	movs	r3, #0
  20a1dc:	82bb      	strh	r3, [r7, #20]
  20a1de:	2300      	movs	r3, #0
  20a1e0:	82fb      	strh	r3, [r7, #22]
  20a1e2:	2300      	movs	r3, #0
  20a1e4:	833b      	strh	r3, [r7, #24]
	int fontIndex=SearchFontIndex(FontID[id].size, FontID[id].style, FontID[id].bkColor, FontID[id].color);
  20a1e6:	4aa1      	ldr	r2, [pc, #644]	; (20a46c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a0>)
  20a1e8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20a1ea:	011b      	lsls	r3, r3, #4
  20a1ec:	4413      	add	r3, r2
  20a1ee:	681b      	ldr	r3, [r3, #0]
  20a1f0:	4618      	mov	r0, r3
  20a1f2:	4a9e      	ldr	r2, [pc, #632]	; (20a46c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a0>)
  20a1f4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20a1f6:	011b      	lsls	r3, r3, #4
  20a1f8:	4413      	add	r3, r2
  20a1fa:	3304      	adds	r3, #4
  20a1fc:	681b      	ldr	r3, [r3, #0]
  20a1fe:	461c      	mov	r4, r3
  20a200:	4a9a      	ldr	r2, [pc, #616]	; (20a46c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a0>)
  20a202:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20a204:	011b      	lsls	r3, r3, #4
  20a206:	4413      	add	r3, r2
  20a208:	3308      	adds	r3, #8
  20a20a:	6819      	ldr	r1, [r3, #0]
  20a20c:	4a97      	ldr	r2, [pc, #604]	; (20a46c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a0>)
  20a20e:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20a210:	011b      	lsls	r3, r3, #4
  20a212:	4413      	add	r3, r2
  20a214:	330c      	adds	r3, #12
  20a216:	681b      	ldr	r3, [r3, #0]
  20a218:	460a      	mov	r2, r1
  20a21a:	4621      	mov	r1, r4
  20a21c:	f7fe fb32 	bl	208884 <SearchFontIndex>
  20a220:	6478      	str	r0, [r7, #68]	; 0x44
	if(fontIndex==-1)
  20a222:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20a224:	f1b3 3fff 	cmp.w	r3, #4294967295
  20a228:	d108      	bne.n	20a23c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x70>
		return structTemp;
  20a22a:	68fb      	ldr	r3, [r7, #12]
  20a22c:	461a      	mov	r2, r3
  20a22e:	f107 0314 	add.w	r3, r7, #20
  20a232:	6818      	ldr	r0, [r3, #0]
  20a234:	6010      	str	r0, [r2, #0]
  20a236:	889b      	ldrh	r3, [r3, #4]
  20a238:	8093      	strh	r3, [r2, #4]
  20a23a:	e1e9      	b.n	20a610 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x444>
	char *fontsBuffer=Font[fontIndex].pointerToMemoryFont;
  20a23c:	498c      	ldr	r1, [pc, #560]	; (20a470 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a4>)
  20a23e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a240:	4613      	mov	r3, r2
  20a242:	019b      	lsls	r3, r3, #6
  20a244:	4413      	add	r3, r2
  20a246:	015b      	lsls	r3, r3, #5
  20a248:	440b      	add	r3, r1
  20a24a:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20a24e:	681b      	ldr	r3, [r3, #0]
  20a250:	643b      	str	r3, [r7, #64]	; 0x40
	int i,j,n,o,lenTxt,temp,lenTxtInPixel=0;
  20a252:	2300      	movs	r3, #0
  20a254:	657b      	str	r3, [r7, #84]	; 0x54
	int posX=0;
  20a256:	2300      	movs	r3, #0
  20a258:	653b      	str	r3, [r7, #80]	; 0x50
	char *pbmp;
	uint32_t index=0, width=0, height=0, bit_pixel=0;
  20a25a:	2300      	movs	r3, #0
  20a25c:	63fb      	str	r3, [r7, #60]	; 0x3c
  20a25e:	2300      	movs	r3, #0
  20a260:	63bb      	str	r3, [r7, #56]	; 0x38
  20a262:	2300      	movs	r3, #0
  20a264:	64bb      	str	r3, [r7, #72]	; 0x48
  20a266:	2300      	movs	r3, #0
  20a268:	637b      	str	r3, [r7, #52]	; 0x34
	uint32_t backGround;
	uint32_t pos, pos2, xi;

	if(constWidth)
  20a26a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  20a26e:	2b00      	cmp	r3, #0
  20a270:	d002      	beq.n	20a278 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0xac>
		LCD_Set_ConstWidthFonts(fontIndex);
  20a272:	6c78      	ldr	r0, [r7, #68]	; 0x44
  20a274:	f7fe fe3c 	bl	208ef0 <LCD_Set_ConstWidthFonts>

	/* Get bitmap data address offset */
	index = fontsBuffer[10] + (fontsBuffer[11] << 8) + (fontsBuffer[12] << 16)  + (fontsBuffer[13] << 24);
  20a278:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a27a:	330a      	adds	r3, #10
  20a27c:	781b      	ldrb	r3, [r3, #0]
  20a27e:	461a      	mov	r2, r3
  20a280:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a282:	330b      	adds	r3, #11
  20a284:	781b      	ldrb	r3, [r3, #0]
  20a286:	021b      	lsls	r3, r3, #8
  20a288:	441a      	add	r2, r3
  20a28a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a28c:	330c      	adds	r3, #12
  20a28e:	781b      	ldrb	r3, [r3, #0]
  20a290:	041b      	lsls	r3, r3, #16
  20a292:	441a      	add	r2, r3
  20a294:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a296:	330d      	adds	r3, #13
  20a298:	781b      	ldrb	r3, [r3, #0]
  20a29a:	061b      	lsls	r3, r3, #24
  20a29c:	4413      	add	r3, r2
  20a29e:	63fb      	str	r3, [r7, #60]	; 0x3c
	/* Read bitmap width */
	width = fontsBuffer[18] + (fontsBuffer[19] << 8) + (fontsBuffer[20] << 16)  + (fontsBuffer[21] << 24);  //!!! szerokosc musi byc wielokrotnoscia 4
  20a2a0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2a2:	3312      	adds	r3, #18
  20a2a4:	781b      	ldrb	r3, [r3, #0]
  20a2a6:	461a      	mov	r2, r3
  20a2a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2aa:	3313      	adds	r3, #19
  20a2ac:	781b      	ldrb	r3, [r3, #0]
  20a2ae:	021b      	lsls	r3, r3, #8
  20a2b0:	441a      	add	r2, r3
  20a2b2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2b4:	3314      	adds	r3, #20
  20a2b6:	781b      	ldrb	r3, [r3, #0]
  20a2b8:	041b      	lsls	r3, r3, #16
  20a2ba:	441a      	add	r2, r3
  20a2bc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2be:	3315      	adds	r3, #21
  20a2c0:	781b      	ldrb	r3, [r3, #0]
  20a2c2:	061b      	lsls	r3, r3, #24
  20a2c4:	4413      	add	r3, r2
  20a2c6:	63bb      	str	r3, [r7, #56]	; 0x38
	/* Read bitmap height */
	height = fontsBuffer[22] + (fontsBuffer[23] << 8) + (fontsBuffer[24] << 16)  + (fontsBuffer[25] << 24);
  20a2c8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2ca:	3316      	adds	r3, #22
  20a2cc:	781b      	ldrb	r3, [r3, #0]
  20a2ce:	461a      	mov	r2, r3
  20a2d0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2d2:	3317      	adds	r3, #23
  20a2d4:	781b      	ldrb	r3, [r3, #0]
  20a2d6:	021b      	lsls	r3, r3, #8
  20a2d8:	441a      	add	r2, r3
  20a2da:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2dc:	3318      	adds	r3, #24
  20a2de:	781b      	ldrb	r3, [r3, #0]
  20a2e0:	041b      	lsls	r3, r3, #16
  20a2e2:	441a      	add	r2, r3
  20a2e4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2e6:	3319      	adds	r3, #25
  20a2e8:	781b      	ldrb	r3, [r3, #0]
  20a2ea:	061b      	lsls	r3, r3, #24
  20a2ec:	4413      	add	r3, r2
  20a2ee:	64bb      	str	r3, [r7, #72]	; 0x48
	/* Read bit/pixel */
	bit_pixel = fontsBuffer[28] + (fontsBuffer[29] << 8);
  20a2f0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2f2:	331c      	adds	r3, #28
  20a2f4:	781b      	ldrb	r3, [r3, #0]
  20a2f6:	461a      	mov	r2, r3
  20a2f8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a2fa:	331d      	adds	r3, #29
  20a2fc:	781b      	ldrb	r3, [r3, #0]
  20a2fe:	021b      	lsls	r3, r3, #8
  20a300:	4413      	add	r3, r2
  20a302:	637b      	str	r3, [r7, #52]	; 0x34
	bit_pixel/=8;
  20a304:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20a306:	08db      	lsrs	r3, r3, #3
  20a308:	637b      	str	r3, [r7, #52]	; 0x34

	fontsBuffer += (index + (width * height * bit_pixel));
  20a30a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a30c:	6cba      	ldr	r2, [r7, #72]	; 0x48
  20a30e:	fb02 f303 	mul.w	r3, r2, r3
  20a312:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20a314:	fb02 f203 	mul.w	r2, r2, r3
  20a318:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20a31a:	4413      	add	r3, r2
  20a31c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20a31e:	4413      	add	r3, r2
  20a320:	643b      	str	r3, [r7, #64]	; 0x40
	fontsBuffer -= width*bit_pixel;
  20a322:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a324:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20a326:	fb02 f303 	mul.w	r3, r2, r3
  20a32a:	425b      	negs	r3, r3
  20a32c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20a32e:	4413      	add	r3, r2
  20a330:	643b      	str	r3, [r7, #64]	; 0x40

	backGround= fontsBuffer[2]<<16 | fontsBuffer[1]<<8 | fontsBuffer[0];
  20a332:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a334:	3302      	adds	r3, #2
  20a336:	781b      	ldrb	r3, [r3, #0]
  20a338:	041a      	lsls	r2, r3, #16
  20a33a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a33c:	3301      	adds	r3, #1
  20a33e:	781b      	ldrb	r3, [r3, #0]
  20a340:	021b      	lsls	r3, r3, #8
  20a342:	4313      	orrs	r3, r2
  20a344:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20a346:	7812      	ldrb	r2, [r2, #0]
  20a348:	4313      	orrs	r3, r2
  20a34a:	633b      	str	r3, [r7, #48]	; 0x30

	if(OnlyDigits==halfHight)
  20a34c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20a350:	f113 0f02 	cmn.w	r3, #2
  20a354:	d10a      	bne.n	20a36c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x1a0>
		height=Font[fontIndex].heightHalf;
  20a356:	4946      	ldr	r1, [pc, #280]	; (20a470 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a4>)
  20a358:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a35a:	4613      	mov	r3, r2
  20a35c:	019b      	lsls	r3, r3, #6
  20a35e:	4413      	add	r3, r2
  20a360:	015b      	lsls	r3, r3, #5
  20a362:	440b      	add	r3, r1
  20a364:	f603 0314 	addw	r3, r3, #2068	; 0x814
  20a368:	681b      	ldr	r3, [r3, #0]
  20a36a:	64bb      	str	r3, [r7, #72]	; 0x48

	j=strlen(txt);
  20a36c:	f8d7 0088 	ldr.w	r0, [r7, #136]	; 0x88
  20a370:	f7f5 ff66 	bl	200240 <strlen>
  20a374:	4603      	mov	r3, r0
  20a376:	663b      	str	r3, [r7, #96]	; 0x60
	for(i=0;i<j;i++)
  20a378:	2300      	movs	r3, #0
  20a37a:	667b      	str	r3, [r7, #100]	; 0x64
  20a37c:	e02e      	b.n	20a3dc <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x210>
	{
		temp = Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,id);
  20a37e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a380:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20a384:	4413      	add	r3, r2
  20a386:	781b      	ldrb	r3, [r3, #0]
  20a388:	4618      	mov	r0, r3
  20a38a:	4939      	ldr	r1, [pc, #228]	; (20a470 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a4>)
  20a38c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a38e:	4613      	mov	r3, r2
  20a390:	019b      	lsls	r3, r3, #6
  20a392:	4413      	add	r3, r2
  20a394:	009b      	lsls	r3, r3, #2
  20a396:	4403      	add	r3, r0
  20a398:	00db      	lsls	r3, r3, #3
  20a39a:	440b      	add	r3, r1
  20a39c:	695a      	ldr	r2, [r3, #20]
  20a39e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  20a3a2:	18d4      	adds	r4, r2, r3
  20a3a4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a3a6:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20a3aa:	4413      	add	r3, r2
  20a3ac:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
  20a3ae:	4618      	mov	r0, r3
  20a3b0:	f7fd fe56 	bl	208060 <RealizeSpaceCorrect>
  20a3b4:	4603      	mov	r3, r0
  20a3b6:	4423      	add	r3, r4
  20a3b8:	62fb      	str	r3, [r7, #44]	; 0x2c
		if(X+lenTxtInPixel+temp <= maxSizeX)
  20a3ba:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20a3be:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20a3c0:	441a      	add	r2, r3
  20a3c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a3c4:	4413      	add	r3, r2
  20a3c6:	461a      	mov	r2, r3
  20a3c8:	683b      	ldr	r3, [r7, #0]
  20a3ca:	429a      	cmp	r2, r3
  20a3cc:	d80b      	bhi.n	20a3e6 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x21a>
			lenTxtInPixel += temp;
  20a3ce:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  20a3d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a3d2:	4413      	add	r3, r2
  20a3d4:	657b      	str	r3, [r7, #84]	; 0x54
	for(i=0;i<j;i++)
  20a3d6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a3d8:	3301      	adds	r3, #1
  20a3da:	667b      	str	r3, [r7, #100]	; 0x64
  20a3dc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20a3de:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a3e0:	429a      	cmp	r2, r3
  20a3e2:	dbcc      	blt.n	20a37e <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x1b2>
  20a3e4:	e000      	b.n	20a3e8 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x21c>
		else break;
  20a3e6:	bf00      	nop
	}
	lenTxt=i;
  20a3e8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a3ea:	62bb      	str	r3, [r7, #40]	; 0x28

	LCD_RectangleBuff(LcdBuffer,posBuff,lenTxtInPixel,height,0,0,lenTxtInPixel,Y+height>maxSizeY?maxSizeY-Y:height,NewBkColor,NewBkColor,NewBkColor);
  20a3ec:	6d78      	ldr	r0, [r7, #84]	; 0x54
  20a3ee:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  20a3f0:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20a3f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20a3f6:	4419      	add	r1, r3
  20a3f8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  20a3fa:	4299      	cmp	r1, r3
  20a3fc:	d904      	bls.n	20a408 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x23c>
  20a3fe:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  20a402:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  20a404:	1acb      	subs	r3, r1, r3
  20a406:	e000      	b.n	20a40a <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x23e>
  20a408:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20a40a:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
  20a40e:	9106      	str	r1, [sp, #24]
  20a410:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
  20a414:	9105      	str	r1, [sp, #20]
  20a416:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
  20a41a:	9104      	str	r1, [sp, #16]
  20a41c:	9303      	str	r3, [sp, #12]
  20a41e:	9202      	str	r2, [sp, #8]
  20a420:	2300      	movs	r3, #0
  20a422:	9301      	str	r3, [sp, #4]
  20a424:	2300      	movs	r3, #0
  20a426:	9300      	str	r3, [sp, #0]
  20a428:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20a42a:	4602      	mov	r2, r0
  20a42c:	68b9      	ldr	r1, [r7, #8]
  20a42e:	f8d7 008c 	ldr.w	r0, [r7, #140]	; 0x8c
  20a432:	f7fd fdc3 	bl	207fbc <LCD_RectangleBuff>
	idxChangeColorBuff=0;
  20a436:	4b0f      	ldr	r3, [pc, #60]	; (20a474 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2a8>)
  20a438:	2200      	movs	r2, #0
  20a43a:	601a      	str	r2, [r3, #0]
   for(i=0;i<MAX_SIZE_CHANGECOLOR_BUFF;++i){
  20a43c:	2300      	movs	r3, #0
  20a43e:	667b      	str	r3, [r7, #100]	; 0x64
  20a440:	e00c      	b.n	20a45c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x290>
   	buffChangeColorIN[i]=0;
  20a442:	4a0d      	ldr	r2, [pc, #52]	; (20a478 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2ac>)
  20a444:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a446:	2100      	movs	r1, #0
  20a448:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   	buffChangeColorOUT[i]=0;
  20a44c:	4a0b      	ldr	r2, [pc, #44]	; (20a47c <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2b0>)
  20a44e:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a450:	2100      	movs	r1, #0
  20a452:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
   for(i=0;i<MAX_SIZE_CHANGECOLOR_BUFF;++i){
  20a456:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a458:	3301      	adds	r3, #1
  20a45a:	667b      	str	r3, [r7, #100]	; 0x64
  20a45c:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a45e:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
  20a462:	dbee      	blt.n	20a442 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x276>
   }

	for(n=0;n<lenTxt;++n)
  20a464:	2300      	movs	r3, #0
  20a466:	65fb      	str	r3, [r7, #92]	; 0x5c
  20a468:	e0a2      	b.n	20a5b0 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x3e4>
  20a46a:	bf00      	nop
  20a46c:	20003480 	.word	0x20003480
  20a470:	20003590 	.word	0x20003590
  20a474:	20002c70 	.word	0x20002c70
  20a478:	20002310 	.word	0x20002310
  20a47c:	200027c0 	.word	0x200027c0
	{
		pbmp=fontsBuffer+3*Font[fontIndex].fontsTabPos[ (int)txt[n] ][0];
  20a480:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a482:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20a486:	4413      	add	r3, r2
  20a488:	781b      	ldrb	r3, [r3, #0]
  20a48a:	4618      	mov	r0, r3
  20a48c:	4962      	ldr	r1, [pc, #392]	; (20a618 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x44c>)
  20a48e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a490:	4613      	mov	r3, r2
  20a492:	019b      	lsls	r3, r3, #6
  20a494:	4413      	add	r3, r2
  20a496:	009b      	lsls	r3, r3, #2
  20a498:	4403      	add	r3, r0
  20a49a:	3302      	adds	r3, #2
  20a49c:	f851 2033 	ldr.w	r2, [r1, r3, lsl #3]
  20a4a0:	4613      	mov	r3, r2
  20a4a2:	005b      	lsls	r3, r3, #1
  20a4a4:	4413      	add	r3, r2
  20a4a6:	461a      	mov	r2, r3
  20a4a8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a4aa:	4413      	add	r3, r2
  20a4ac:	64fb      	str	r3, [r7, #76]	; 0x4c
		pos2= posBuff+posX;
  20a4ae:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20a4b0:	68ba      	ldr	r2, [r7, #8]
  20a4b2:	4413      	add	r3, r2
  20a4b4:	627b      	str	r3, [r7, #36]	; 0x24
		xi=Font[fontIndex].fontsTabPos[ (int)txt[n] ][1];
  20a4b6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a4b8:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20a4bc:	4413      	add	r3, r2
  20a4be:	781b      	ldrb	r3, [r3, #0]
  20a4c0:	4618      	mov	r0, r3
  20a4c2:	4955      	ldr	r1, [pc, #340]	; (20a618 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x44c>)
  20a4c4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20a4c6:	4613      	mov	r3, r2
  20a4c8:	019b      	lsls	r3, r3, #6
  20a4ca:	4413      	add	r3, r2
  20a4cc:	009b      	lsls	r3, r3, #2
  20a4ce:	4403      	add	r3, r0
  20a4d0:	00db      	lsls	r3, r3, #3
  20a4d2:	440b      	add	r3, r1
  20a4d4:	695b      	ldr	r3, [r3, #20]
  20a4d6:	623b      	str	r3, [r7, #32]

		for(j=0; j < height; ++j)
  20a4d8:	2300      	movs	r3, #0
  20a4da:	663b      	str	r3, [r7, #96]	; 0x60
  20a4dc:	e04c      	b.n	20a578 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x3ac>
		{
			if(Y+j>=maxSizeY)
  20a4de:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  20a4e2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a4e4:	4413      	add	r3, r2
  20a4e6:	461a      	mov	r2, r3
  20a4e8:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  20a4ea:	429a      	cmp	r2, r3
  20a4ec:	d249      	bcs.n	20a582 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x3b6>
				break;
			pos=pos2+lenTxtInPixel*j;
  20a4ee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20a4f0:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20a4f2:	fb02 f303 	mul.w	r3, r2, r3
  20a4f6:	461a      	mov	r2, r3
  20a4f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a4fa:	4413      	add	r3, r2
  20a4fc:	61fb      	str	r3, [r7, #28]
			o=0;
  20a4fe:	2300      	movs	r3, #0
  20a500:	65bb      	str	r3, [r7, #88]	; 0x58
			for(i=0; i<xi; ++i)
  20a502:	2300      	movs	r3, #0
  20a504:	667b      	str	r3, [r7, #100]	; 0x64
  20a506:	e028      	b.n	20a55a <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x38e>
			{
				if ((*((uint32_t*)(pbmp+o))&0x00FFFFFF)!=backGround)
  20a508:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a50a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a50c:	4413      	add	r3, r2
  20a50e:	681b      	ldr	r3, [r3, #0]
  20a510:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
  20a514:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20a516:	429a      	cmp	r2, r3
  20a518:	d019      	beq.n	20a54e <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x382>
					LcdBuffer[pos+i] = GetCalculatedRGB(*(pbmp+o+2),*(pbmp+o+1),*(pbmp+o+0));
  20a51a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20a51c:	69fb      	ldr	r3, [r7, #28]
  20a51e:	4413      	add	r3, r2
  20a520:	009b      	lsls	r3, r3, #2
  20a522:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  20a526:	18d4      	adds	r4, r2, r3
  20a528:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a52a:	3302      	adds	r3, #2
  20a52c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a52e:	4413      	add	r3, r2
  20a530:	7818      	ldrb	r0, [r3, #0]
  20a532:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a534:	3301      	adds	r3, #1
  20a536:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a538:	4413      	add	r3, r2
  20a53a:	7819      	ldrb	r1, [r3, #0]
  20a53c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a53e:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a540:	4413      	add	r3, r2
  20a542:	781b      	ldrb	r3, [r3, #0]
  20a544:	461a      	mov	r2, r3
  20a546:	f7fd ffbb 	bl	2084c0 <GetCalculatedRGB>
  20a54a:	4603      	mov	r3, r0
  20a54c:	6023      	str	r3, [r4, #0]
				o+=3;
  20a54e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20a550:	3303      	adds	r3, #3
  20a552:	65bb      	str	r3, [r7, #88]	; 0x58
			for(i=0; i<xi; ++i)
  20a554:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20a556:	3301      	adds	r3, #1
  20a558:	667b      	str	r3, [r7, #100]	; 0x64
  20a55a:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20a55c:	6a3b      	ldr	r3, [r7, #32]
  20a55e:	429a      	cmp	r2, r3
  20a560:	d3d2      	bcc.n	20a508 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x33c>
			}
			pbmp -= width*bit_pixel;
  20a562:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a564:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20a566:	fb02 f303 	mul.w	r3, r2, r3
  20a56a:	425b      	negs	r3, r3
  20a56c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20a56e:	4413      	add	r3, r2
  20a570:	64fb      	str	r3, [r7, #76]	; 0x4c
		for(j=0; j < height; ++j)
  20a572:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a574:	3301      	adds	r3, #1
  20a576:	663b      	str	r3, [r7, #96]	; 0x60
  20a578:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20a57a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20a57c:	429a      	cmp	r2, r3
  20a57e:	d3ae      	bcc.n	20a4de <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x312>
  20a580:	e000      	b.n	20a584 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x3b8>
				break;
  20a582:	bf00      	nop
		}
		posX += xi;
  20a584:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20a586:	6a3b      	ldr	r3, [r7, #32]
  20a588:	4413      	add	r3, r2
  20a58a:	653b      	str	r3, [r7, #80]	; 0x50
		posX += space + RealizeSpaceCorrect(txt+n,id);
  20a58c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a58e:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20a592:	4413      	add	r3, r2
  20a594:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
  20a596:	4618      	mov	r0, r3
  20a598:	f7fd fd62 	bl	208060 <RealizeSpaceCorrect>
  20a59c:	4602      	mov	r2, r0
  20a59e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
  20a5a2:	4413      	add	r3, r2
  20a5a4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20a5a6:	4413      	add	r3, r2
  20a5a8:	653b      	str	r3, [r7, #80]	; 0x50
	for(n=0;n<lenTxt;++n)
  20a5aa:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20a5ac:	3301      	adds	r3, #1
  20a5ae:	65fb      	str	r3, [r7, #92]	; 0x5c
  20a5b0:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  20a5b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20a5b4:	429a      	cmp	r2, r3
  20a5b6:	f6ff af63 	blt.w	20a480 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x2b4>
	}

	if(constWidth)
  20a5ba:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
  20a5be:	2b00      	cmp	r3, #0
  20a5c0:	d002      	beq.n	20a5c8 <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x3fc>
		LCD_Reset_ConstWidthFonts(fontIndex);
  20a5c2:	6c78      	ldr	r0, [r7, #68]	; 0x44
  20a5c4:	f7fe fd92 	bl	2090ec <LCD_Reset_ConstWidthFonts>

	if(displayOn)
  20a5c8:	687b      	ldr	r3, [r7, #4]
  20a5ca:	2b00      	cmp	r3, #0
  20a5cc:	d00f      	beq.n	20a5ee <LCD_DrawStrChangeColorIndirectToBuffAndDisplay+0x422>
		LCD_DisplayBuff((uint32_t)X,(uint32_t)Y,(uint32_t)lenTxtInPixel,(uint32_t)j,LcdBuffer+posBuff);
  20a5ce:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
  20a5d2:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20a5d6:	6d7c      	ldr	r4, [r7, #84]	; 0x54
  20a5d8:	6e3d      	ldr	r5, [r7, #96]	; 0x60
  20a5da:	68bb      	ldr	r3, [r7, #8]
  20a5dc:	009b      	lsls	r3, r3, #2
  20a5de:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  20a5e2:	4413      	add	r3, r2
  20a5e4:	9300      	str	r3, [sp, #0]
  20a5e6:	462b      	mov	r3, r5
  20a5e8:	4622      	mov	r2, r4
  20a5ea:	f7fd fa53 	bl	207a94 <LCD_DisplayBuff>
	structTemp.inChar=lenTxt;
  20a5ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20a5f0:	b29b      	uxth	r3, r3
  20a5f2:	82bb      	strh	r3, [r7, #20]
	structTemp.inPixel=lenTxtInPixel;
  20a5f4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20a5f6:	b29b      	uxth	r3, r3
  20a5f8:	82fb      	strh	r3, [r7, #22]
	structTemp.height=j;
  20a5fa:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20a5fc:	b29b      	uxth	r3, r3
  20a5fe:	833b      	strh	r3, [r7, #24]
	return structTemp;
  20a600:	68fb      	ldr	r3, [r7, #12]
  20a602:	461a      	mov	r2, r3
  20a604:	f107 0314 	add.w	r3, r7, #20
  20a608:	6818      	ldr	r0, [r3, #0]
  20a60a:	6010      	str	r0, [r2, #0]
  20a60c:	889b      	ldrh	r3, [r3, #4]
  20a60e:	8093      	strh	r3, [r2, #4]
}
  20a610:	68f8      	ldr	r0, [r7, #12]
  20a612:	3768      	adds	r7, #104	; 0x68
  20a614:	46bd      	mov	sp, r7
  20a616:	bdb0      	pop	{r4, r5, r7, pc}
  20a618:	20003590 	.word	0x20003590

0020a61c <LCD_DrawStr>:

static StructTxtPxlLen LCD_DrawStr(uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY,int fontID, int Xpos, int Ypos, char *txt, uint32_t *LcdBuffer, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth){
  20a61c:	b580      	push	{r7, lr}
  20a61e:	b08e      	sub	sp, #56	; 0x38
  20a620:	af0a      	add	r7, sp, #40	; 0x28
  20a622:	60f8      	str	r0, [r7, #12]
  20a624:	60b9      	str	r1, [r7, #8]
  20a626:	607a      	str	r2, [r7, #4]
  20a628:	603b      	str	r3, [r7, #0]
	if(fontID < MAX_OPEN_FONTS_SIMULTANEOUSLY)
  20a62a:	69bb      	ldr	r3, [r7, #24]
  20a62c:	2b10      	cmp	r3, #16
  20a62e:	dc1a      	bgt.n	20a666 <LCD_DrawStr+0x4a>
		return LCD_DrawStrToBuff(posBuff,BkpSizeX,BkpSizeY,fontID,Xpos,Ypos,txt,LcdBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  20a630:	68f8      	ldr	r0, [r7, #12]
  20a632:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20a634:	9309      	str	r3, [sp, #36]	; 0x24
  20a636:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a638:	9308      	str	r3, [sp, #32]
  20a63a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20a63c:	9307      	str	r3, [sp, #28]
  20a63e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20a640:	9306      	str	r3, [sp, #24]
  20a642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a644:	9305      	str	r3, [sp, #20]
  20a646:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20a648:	9304      	str	r3, [sp, #16]
  20a64a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a64c:	9303      	str	r3, [sp, #12]
  20a64e:	6a3b      	ldr	r3, [r7, #32]
  20a650:	9302      	str	r3, [sp, #8]
  20a652:	69fb      	ldr	r3, [r7, #28]
  20a654:	9301      	str	r3, [sp, #4]
  20a656:	69bb      	ldr	r3, [r7, #24]
  20a658:	9300      	str	r3, [sp, #0]
  20a65a:	683b      	ldr	r3, [r7, #0]
  20a65c:	687a      	ldr	r2, [r7, #4]
  20a65e:	68b9      	ldr	r1, [r7, #8]
  20a660:	f7fe fdba 	bl	2091d8 <LCD_DrawStrToBuff>
  20a664:	e005      	b.n	20a672 <LCD_DrawStr+0x56>
	else
		return StructTxtPxlLen_ZeroValue;
  20a666:	68fb      	ldr	r3, [r7, #12]
  20a668:	4a04      	ldr	r2, [pc, #16]	; (20a67c <LCD_DrawStr+0x60>)
  20a66a:	6810      	ldr	r0, [r2, #0]
  20a66c:	6018      	str	r0, [r3, #0]
  20a66e:	8892      	ldrh	r2, [r2, #4]
  20a670:	809a      	strh	r2, [r3, #4]
}
  20a672:	68f8      	ldr	r0, [r7, #12]
  20a674:	3710      	adds	r7, #16
  20a676:	46bd      	mov	sp, r7
  20a678:	bd80      	pop	{r7, pc}
  20a67a:	bf00      	nop
  20a67c:	20003474 	.word	0x20003474

0020a680 <LCD_DrawStrIndirect>:
static StructTxtPxlLen LCD_DrawStrIndirect(uint32_t posBuff,int displayOn,uint32_t maxSizeX,uint32_t maxSizeY,int fontID, int Xpos, int Ypos, char *txt, uint32_t *LcdBuffer, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth){
  20a680:	b580      	push	{r7, lr}
  20a682:	b090      	sub	sp, #64	; 0x40
  20a684:	af0c      	add	r7, sp, #48	; 0x30
  20a686:	60f8      	str	r0, [r7, #12]
  20a688:	60b9      	str	r1, [r7, #8]
  20a68a:	607a      	str	r2, [r7, #4]
  20a68c:	603b      	str	r3, [r7, #0]
	if(fontID < MAX_OPEN_FONTS_SIMULTANEOUSLY)
  20a68e:	69fb      	ldr	r3, [r7, #28]
  20a690:	2b10      	cmp	r3, #16
  20a692:	dc1c      	bgt.n	20a6ce <LCD_DrawStrIndirect+0x4e>
		return LCD_DrawStrIndirectToBuffAndDisplay(posBuff,displayOn,maxSizeX,maxSizeY,fontID,Xpos,Ypos,txt,LcdBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  20a694:	68f8      	ldr	r0, [r7, #12]
  20a696:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a698:	930a      	str	r3, [sp, #40]	; 0x28
  20a69a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20a69c:	9309      	str	r3, [sp, #36]	; 0x24
  20a69e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a6a0:	9308      	str	r3, [sp, #32]
  20a6a2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20a6a4:	9307      	str	r3, [sp, #28]
  20a6a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20a6a8:	9306      	str	r3, [sp, #24]
  20a6aa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a6ac:	9305      	str	r3, [sp, #20]
  20a6ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20a6b0:	9304      	str	r3, [sp, #16]
  20a6b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a6b4:	9303      	str	r3, [sp, #12]
  20a6b6:	6a3b      	ldr	r3, [r7, #32]
  20a6b8:	9302      	str	r3, [sp, #8]
  20a6ba:	69fb      	ldr	r3, [r7, #28]
  20a6bc:	9301      	str	r3, [sp, #4]
  20a6be:	69bb      	ldr	r3, [r7, #24]
  20a6c0:	9300      	str	r3, [sp, #0]
  20a6c2:	683b      	ldr	r3, [r7, #0]
  20a6c4:	687a      	ldr	r2, [r7, #4]
  20a6c6:	68b9      	ldr	r1, [r7, #8]
  20a6c8:	f7ff f86e 	bl	2097a8 <LCD_DrawStrIndirectToBuffAndDisplay>
  20a6cc:	e005      	b.n	20a6da <LCD_DrawStrIndirect+0x5a>
	else
		return StructTxtPxlLen_ZeroValue;
  20a6ce:	68fb      	ldr	r3, [r7, #12]
  20a6d0:	4a04      	ldr	r2, [pc, #16]	; (20a6e4 <LCD_DrawStrIndirect+0x64>)
  20a6d2:	6810      	ldr	r0, [r2, #0]
  20a6d4:	6018      	str	r0, [r3, #0]
  20a6d6:	8892      	ldrh	r2, [r2, #4]
  20a6d8:	809a      	strh	r2, [r3, #4]
}
  20a6da:	68f8      	ldr	r0, [r7, #12]
  20a6dc:	3710      	adds	r7, #16
  20a6de:	46bd      	mov	sp, r7
  20a6e0:	bd80      	pop	{r7, pc}
  20a6e2:	bf00      	nop
  20a6e4:	20003474 	.word	0x20003474

0020a6e8 <LCD_DrawStrChangeColor>:
static StructTxtPxlLen LCD_DrawStrChangeColor(uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY,int fontID, int Xpos, int Ypos, char *txt, uint32_t *LcdBuffer, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, uint8_t maxVal, int constWidth){
  20a6e8:	b580      	push	{r7, lr}
  20a6ea:	b08e      	sub	sp, #56	; 0x38
  20a6ec:	af0a      	add	r7, sp, #40	; 0x28
  20a6ee:	60f8      	str	r0, [r7, #12]
  20a6f0:	60b9      	str	r1, [r7, #8]
  20a6f2:	607a      	str	r2, [r7, #4]
  20a6f4:	603b      	str	r3, [r7, #0]
	if(fontID < MAX_OPEN_FONTS_SIMULTANEOUSLY){
  20a6f6:	69bb      	ldr	r3, [r7, #24]
  20a6f8:	2b10      	cmp	r3, #16
  20a6fa:	dc2d      	bgt.n	20a758 <LCD_DrawStrChangeColor+0x70>
		CalculateFontCoeff(FontID[fontID].bkColor,FontID[fontID].color,bkColor,fontColor,maxVal);
  20a6fc:	4a1b      	ldr	r2, [pc, #108]	; (20a76c <LCD_DrawStrChangeColor+0x84>)
  20a6fe:	69bb      	ldr	r3, [r7, #24]
  20a700:	011b      	lsls	r3, r3, #4
  20a702:	4413      	add	r3, r2
  20a704:	3308      	adds	r3, #8
  20a706:	6818      	ldr	r0, [r3, #0]
  20a708:	4a18      	ldr	r2, [pc, #96]	; (20a76c <LCD_DrawStrChangeColor+0x84>)
  20a70a:	69bb      	ldr	r3, [r7, #24]
  20a70c:	011b      	lsls	r3, r3, #4
  20a70e:	4413      	add	r3, r2
  20a710:	330c      	adds	r3, #12
  20a712:	6819      	ldr	r1, [r3, #0]
  20a714:	f897 303c 	ldrb.w	r3, [r7, #60]	; 0x3c
  20a718:	9300      	str	r3, [sp, #0]
  20a71a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a71c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20a71e:	f7fd fdff 	bl	208320 <CalculateFontCoeff>
		return LCD_DrawStrChangeColorToBuff(posBuff,BkpSizeX,BkpSizeY,fontID,Xpos,Ypos,txt,LcdBuffer,OnlyDigits,space,bkColor,fontColor,constWidth);
  20a722:	68f8      	ldr	r0, [r7, #12]
  20a724:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20a726:	9309      	str	r3, [sp, #36]	; 0x24
  20a728:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a72a:	9308      	str	r3, [sp, #32]
  20a72c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20a72e:	9307      	str	r3, [sp, #28]
  20a730:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20a732:	9306      	str	r3, [sp, #24]
  20a734:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a736:	9305      	str	r3, [sp, #20]
  20a738:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20a73a:	9304      	str	r3, [sp, #16]
  20a73c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a73e:	9303      	str	r3, [sp, #12]
  20a740:	6a3b      	ldr	r3, [r7, #32]
  20a742:	9302      	str	r3, [sp, #8]
  20a744:	69fb      	ldr	r3, [r7, #28]
  20a746:	9301      	str	r3, [sp, #4]
  20a748:	69bb      	ldr	r3, [r7, #24]
  20a74a:	9300      	str	r3, [sp, #0]
  20a74c:	683b      	ldr	r3, [r7, #0]
  20a74e:	687a      	ldr	r2, [r7, #4]
  20a750:	68b9      	ldr	r1, [r7, #8]
  20a752:	f7ff fb1f 	bl	209d94 <LCD_DrawStrChangeColorToBuff>
  20a756:	e005      	b.n	20a764 <LCD_DrawStrChangeColor+0x7c>
	}
	else
		return StructTxtPxlLen_ZeroValue;
  20a758:	68fb      	ldr	r3, [r7, #12]
  20a75a:	4a05      	ldr	r2, [pc, #20]	; (20a770 <LCD_DrawStrChangeColor+0x88>)
  20a75c:	6810      	ldr	r0, [r2, #0]
  20a75e:	6018      	str	r0, [r3, #0]
  20a760:	8892      	ldrh	r2, [r2, #4]
  20a762:	809a      	strh	r2, [r3, #4]
}
  20a764:	68f8      	ldr	r0, [r7, #12]
  20a766:	3710      	adds	r7, #16
  20a768:	46bd      	mov	sp, r7
  20a76a:	bd80      	pop	{r7, pc}
  20a76c:	20003480 	.word	0x20003480
  20a770:	20003474 	.word	0x20003474

0020a774 <LCD_DrawStrChangeColorIndirect>:
static StructTxtPxlLen LCD_DrawStrChangeColorIndirect(uint32_t posBuff,int displayOn,uint32_t maxSizeX,uint32_t maxSizeY,int fontID, int Xpos, int Ypos, char *txt, uint32_t *LcdBuffer, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, uint8_t maxVal, int constWidth){
  20a774:	b580      	push	{r7, lr}
  20a776:	b090      	sub	sp, #64	; 0x40
  20a778:	af0c      	add	r7, sp, #48	; 0x30
  20a77a:	60f8      	str	r0, [r7, #12]
  20a77c:	60b9      	str	r1, [r7, #8]
  20a77e:	607a      	str	r2, [r7, #4]
  20a780:	603b      	str	r3, [r7, #0]
	if(fontID < MAX_OPEN_FONTS_SIMULTANEOUSLY){
  20a782:	69fb      	ldr	r3, [r7, #28]
  20a784:	2b10      	cmp	r3, #16
  20a786:	dc2f      	bgt.n	20a7e8 <LCD_DrawStrChangeColorIndirect+0x74>
		CalculateFontCoeff(FontID[fontID].bkColor,FontID[fontID].color,bkColor,fontColor,maxVal);
  20a788:	4a1c      	ldr	r2, [pc, #112]	; (20a7fc <LCD_DrawStrChangeColorIndirect+0x88>)
  20a78a:	69fb      	ldr	r3, [r7, #28]
  20a78c:	011b      	lsls	r3, r3, #4
  20a78e:	4413      	add	r3, r2
  20a790:	3308      	adds	r3, #8
  20a792:	6818      	ldr	r0, [r3, #0]
  20a794:	4a19      	ldr	r2, [pc, #100]	; (20a7fc <LCD_DrawStrChangeColorIndirect+0x88>)
  20a796:	69fb      	ldr	r3, [r7, #28]
  20a798:	011b      	lsls	r3, r3, #4
  20a79a:	4413      	add	r3, r2
  20a79c:	330c      	adds	r3, #12
  20a79e:	6819      	ldr	r1, [r3, #0]
  20a7a0:	f897 3040 	ldrb.w	r3, [r7, #64]	; 0x40
  20a7a4:	9300      	str	r3, [sp, #0]
  20a7a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20a7a8:	6bba      	ldr	r2, [r7, #56]	; 0x38
  20a7aa:	f7fd fdb9 	bl	208320 <CalculateFontCoeff>
		return LCD_DrawStrChangeColorIndirectToBuffAndDisplay(posBuff,displayOn,maxSizeX,maxSizeY,fontID,Xpos,Ypos,txt,LcdBuffer,OnlyDigits,space,bkColor,fontColor,constWidth);
  20a7ae:	68f8      	ldr	r0, [r7, #12]
  20a7b0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20a7b2:	930a      	str	r3, [sp, #40]	; 0x28
  20a7b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20a7b6:	9309      	str	r3, [sp, #36]	; 0x24
  20a7b8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20a7ba:	9308      	str	r3, [sp, #32]
  20a7bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20a7be:	9307      	str	r3, [sp, #28]
  20a7c0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20a7c2:	9306      	str	r3, [sp, #24]
  20a7c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20a7c6:	9305      	str	r3, [sp, #20]
  20a7c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20a7ca:	9304      	str	r3, [sp, #16]
  20a7cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20a7ce:	9303      	str	r3, [sp, #12]
  20a7d0:	6a3b      	ldr	r3, [r7, #32]
  20a7d2:	9302      	str	r3, [sp, #8]
  20a7d4:	69fb      	ldr	r3, [r7, #28]
  20a7d6:	9301      	str	r3, [sp, #4]
  20a7d8:	69bb      	ldr	r3, [r7, #24]
  20a7da:	9300      	str	r3, [sp, #0]
  20a7dc:	683b      	ldr	r3, [r7, #0]
  20a7de:	687a      	ldr	r2, [r7, #4]
  20a7e0:	68b9      	ldr	r1, [r7, #8]
  20a7e2:	f7ff fcf3 	bl	20a1cc <LCD_DrawStrChangeColorIndirectToBuffAndDisplay>
  20a7e6:	e005      	b.n	20a7f4 <LCD_DrawStrChangeColorIndirect+0x80>
	}
	else
		return StructTxtPxlLen_ZeroValue;
  20a7e8:	68fb      	ldr	r3, [r7, #12]
  20a7ea:	4a05      	ldr	r2, [pc, #20]	; (20a800 <LCD_DrawStrChangeColorIndirect+0x8c>)
  20a7ec:	6810      	ldr	r0, [r2, #0]
  20a7ee:	6018      	str	r0, [r3, #0]
  20a7f0:	8892      	ldrh	r2, [r2, #4]
  20a7f2:	809a      	strh	r2, [r3, #4]
}
  20a7f4:	68f8      	ldr	r0, [r7, #12]
  20a7f6:	3710      	adds	r7, #16
  20a7f8:	46bd      	mov	sp, r7
  20a7fa:	bd80      	pop	{r7, pc}
  20a7fc:	20003480 	.word	0x20003480
  20a800:	20003474 	.word	0x20003474

0020a804 <LCD_StartInsertingSpacesBetweenFonts>:

static void LCD_StartInsertingSpacesBetweenFonts(void){
  20a804:	b480      	push	{r7}
  20a806:	b083      	sub	sp, #12
  20a808:	af00      	add	r7, sp, #0
	for(int i=0;i<MAX_SPACE_CORRECT;i++){
  20a80a:	2300      	movs	r3, #0
  20a80c:	607b      	str	r3, [r7, #4]
  20a80e:	e02e      	b.n	20a86e <LCD_StartInsertingSpacesBetweenFonts+0x6a>
		space[i].fontStyle=0;
  20a810:	491d      	ldr	r1, [pc, #116]	; (20a888 <LCD_StartInsertingSpacesBetweenFonts+0x84>)
  20a812:	687a      	ldr	r2, [r7, #4]
  20a814:	4613      	mov	r3, r2
  20a816:	009b      	lsls	r3, r3, #2
  20a818:	4413      	add	r3, r2
  20a81a:	440b      	add	r3, r1
  20a81c:	2200      	movs	r2, #0
  20a81e:	701a      	strb	r2, [r3, #0]
		space[i].fontSize=0;
  20a820:	4919      	ldr	r1, [pc, #100]	; (20a888 <LCD_StartInsertingSpacesBetweenFonts+0x84>)
  20a822:	687a      	ldr	r2, [r7, #4]
  20a824:	4613      	mov	r3, r2
  20a826:	009b      	lsls	r3, r3, #2
  20a828:	4413      	add	r3, r2
  20a82a:	440b      	add	r3, r1
  20a82c:	3301      	adds	r3, #1
  20a82e:	2200      	movs	r2, #0
  20a830:	701a      	strb	r2, [r3, #0]
		space[i].char1=0;
  20a832:	4915      	ldr	r1, [pc, #84]	; (20a888 <LCD_StartInsertingSpacesBetweenFonts+0x84>)
  20a834:	687a      	ldr	r2, [r7, #4]
  20a836:	4613      	mov	r3, r2
  20a838:	009b      	lsls	r3, r3, #2
  20a83a:	4413      	add	r3, r2
  20a83c:	440b      	add	r3, r1
  20a83e:	3302      	adds	r3, #2
  20a840:	2200      	movs	r2, #0
  20a842:	701a      	strb	r2, [r3, #0]
		space[i].char2=0;
  20a844:	4910      	ldr	r1, [pc, #64]	; (20a888 <LCD_StartInsertingSpacesBetweenFonts+0x84>)
  20a846:	687a      	ldr	r2, [r7, #4]
  20a848:	4613      	mov	r3, r2
  20a84a:	009b      	lsls	r3, r3, #2
  20a84c:	4413      	add	r3, r2
  20a84e:	440b      	add	r3, r1
  20a850:	3303      	adds	r3, #3
  20a852:	2200      	movs	r2, #0
  20a854:	701a      	strb	r2, [r3, #0]
		space[i].val=0;
  20a856:	490c      	ldr	r1, [pc, #48]	; (20a888 <LCD_StartInsertingSpacesBetweenFonts+0x84>)
  20a858:	687a      	ldr	r2, [r7, #4]
  20a85a:	4613      	mov	r3, r2
  20a85c:	009b      	lsls	r3, r3, #2
  20a85e:	4413      	add	r3, r2
  20a860:	440b      	add	r3, r1
  20a862:	3304      	adds	r3, #4
  20a864:	2200      	movs	r2, #0
  20a866:	701a      	strb	r2, [r3, #0]
	for(int i=0;i<MAX_SPACE_CORRECT;i++){
  20a868:	687b      	ldr	r3, [r7, #4]
  20a86a:	3301      	adds	r3, #1
  20a86c:	607b      	str	r3, [r7, #4]
  20a86e:	687b      	ldr	r3, [r7, #4]
  20a870:	2b63      	cmp	r3, #99	; 0x63
  20a872:	ddcd      	ble.n	20a810 <LCD_StartInsertingSpacesBetweenFonts+0xc>
	}
	StructSpaceCount=0;
  20a874:	4b05      	ldr	r3, [pc, #20]	; (20a88c <LCD_StartInsertingSpacesBetweenFonts+0x88>)
  20a876:	2200      	movs	r2, #0
  20a878:	701a      	strb	r2, [r3, #0]
}
  20a87a:	bf00      	nop
  20a87c:	370c      	adds	r7, #12
  20a87e:	46bd      	mov	sp, r7
  20a880:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a884:	4770      	bx	lr
  20a886:	bf00      	nop
  20a888:	20010178 	.word	0x20010178
  20a88c:	2001036c 	.word	0x2001036c

0020a890 <LCD_GetPtr2SpacesBetweenFontsStruct>:
static uint8_t* LCD_GetPtr2SpacesBetweenFontsStruct(void){
  20a890:	b480      	push	{r7}
  20a892:	af00      	add	r7, sp, #0
	return &space[0].fontStyle;
  20a894:	4b02      	ldr	r3, [pc, #8]	; (20a8a0 <LCD_GetPtr2SpacesBetweenFontsStruct+0x10>)
}
  20a896:	4618      	mov	r0, r3
  20a898:	46bd      	mov	sp, r7
  20a89a:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a89e:	4770      	bx	lr
  20a8a0:	20010178 	.word	0x20010178

0020a8a4 <LCD_GetSpacesBetweenFontsStructSize>:
static int LCD_GetSpacesBetweenFontsStructSize(void){
  20a8a4:	b480      	push	{r7}
  20a8a6:	af00      	add	r7, sp, #0
	return sizeof(space);
  20a8a8:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
}
  20a8ac:	4618      	mov	r0, r3
  20a8ae:	46bd      	mov	sp, r7
  20a8b0:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a8b4:	4770      	bx	lr
	...

0020a8b8 <LCD_GetStructSpaceCount>:
static uint8_t* LCD_GetStructSpaceCount(void){
  20a8b8:	b480      	push	{r7}
  20a8ba:	af00      	add	r7, sp, #0
	return &StructSpaceCount;
  20a8bc:	4b02      	ldr	r3, [pc, #8]	; (20a8c8 <LCD_GetStructSpaceCount+0x10>)
}
  20a8be:	4618      	mov	r0, r3
  20a8c0:	46bd      	mov	sp, r7
  20a8c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a8c6:	4770      	bx	lr
  20a8c8:	2001036c 	.word	0x2001036c

0020a8cc <ReadSpacesBetweenFontsFromSDcard>:
static int ReadSpacesBetweenFontsFromSDcard(void){
  20a8cc:	b598      	push	{r3, r4, r7, lr}
  20a8ce:	af00      	add	r7, sp, #0
	if(FR_OK==SDCardFileOpen(0,"Spaces_Between_Font.bin",FA_READ)){
  20a8d0:	2201      	movs	r2, #1
  20a8d2:	4911      	ldr	r1, [pc, #68]	; (20a918 <ReadSpacesBetweenFontsFromSDcard+0x4c>)
  20a8d4:	2000      	movs	r0, #0
  20a8d6:	f7f6 fe15 	bl	201504 <SDCardFileOpen>
  20a8da:	4603      	mov	r3, r0
  20a8dc:	2b00      	cmp	r3, #0
  20a8de:	d117      	bne.n	20a910 <ReadSpacesBetweenFontsFromSDcard+0x44>
		SDCardFileRead(0,(char*)LCD_GetStructSpaceCount(),1);
  20a8e0:	f7ff ffea 	bl	20a8b8 <LCD_GetStructSpaceCount>
  20a8e4:	4603      	mov	r3, r0
  20a8e6:	2201      	movs	r2, #1
  20a8e8:	4619      	mov	r1, r3
  20a8ea:	2000      	movs	r0, #0
  20a8ec:	f7f6 fe2e 	bl	20154c <SDCardFileRead>
		SDCardFileRead(0,(char*)LCD_GetPtr2SpacesBetweenFontsStruct(),LCD_GetSpacesBetweenFontsStructSize());
  20a8f0:	f7ff ffce 	bl	20a890 <LCD_GetPtr2SpacesBetweenFontsStruct>
  20a8f4:	4604      	mov	r4, r0
  20a8f6:	f7ff ffd5 	bl	20a8a4 <LCD_GetSpacesBetweenFontsStructSize>
  20a8fa:	4603      	mov	r3, r0
  20a8fc:	461a      	mov	r2, r3
  20a8fe:	4621      	mov	r1, r4
  20a900:	2000      	movs	r0, #0
  20a902:	f7f6 fe23 	bl	20154c <SDCardFileRead>
		SDCardFileClose(0);
  20a906:	2000      	movs	r0, #0
  20a908:	f7f6 fe74 	bl	2015f4 <SDCardFileClose>
		return 0;
  20a90c:	2300      	movs	r3, #0
  20a90e:	e000      	b.n	20a912 <ReadSpacesBetweenFontsFromSDcard+0x46>
	}
	else return 1;
  20a910:	2301      	movs	r3, #1
}
  20a912:	4618      	mov	r0, r3
  20a914:	bd98      	pop	{r3, r4, r7, pc}
  20a916:	bf00      	nop
  20a918:	00228528 	.word	0x00228528

0020a91c <LCD_SetStrVar_bkColor>:

//################################## -- Global Declarations -- #########################################################
//################################## -- Global Declarations -- #########################################################
//################################## -- Global Declarations -- #########################################################

void LCD_SetStrVar_bkColor(int idVar, uint32_t bkColor){
  20a91c:	b480      	push	{r7}
  20a91e:	b083      	sub	sp, #12
  20a920:	af00      	add	r7, sp, #0
  20a922:	6078      	str	r0, [r7, #4]
  20a924:	6039      	str	r1, [r7, #0]
	FontVar[idVar].bkColor=bkColor;
  20a926:	4908      	ldr	r1, [pc, #32]	; (20a948 <LCD_SetStrVar_bkColor+0x2c>)
  20a928:	687a      	ldr	r2, [r7, #4]
  20a92a:	4613      	mov	r3, r2
  20a92c:	011b      	lsls	r3, r3, #4
  20a92e:	1a9b      	subs	r3, r3, r2
  20a930:	009b      	lsls	r3, r3, #2
  20a932:	440b      	add	r3, r1
  20a934:	3308      	adds	r3, #8
  20a936:	683a      	ldr	r2, [r7, #0]
  20a938:	601a      	str	r2, [r3, #0]
}
  20a93a:	bf00      	nop
  20a93c:	370c      	adds	r7, #12
  20a93e:	46bd      	mov	sp, r7
  20a940:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a944:	4770      	bx	lr
  20a946:	bf00      	nop
  20a948:	2000f818 	.word	0x2000f818

0020a94c <LCD_SetStrVar_fontColor>:
void LCD_SetStrVar_fontColor(int idVar, uint32_t fontColor){
  20a94c:	b480      	push	{r7}
  20a94e:	b083      	sub	sp, #12
  20a950:	af00      	add	r7, sp, #0
  20a952:	6078      	str	r0, [r7, #4]
  20a954:	6039      	str	r1, [r7, #0]
	FontVar[idVar].fontColor=fontColor;
  20a956:	4908      	ldr	r1, [pc, #32]	; (20a978 <LCD_SetStrVar_fontColor+0x2c>)
  20a958:	687a      	ldr	r2, [r7, #4]
  20a95a:	4613      	mov	r3, r2
  20a95c:	011b      	lsls	r3, r3, #4
  20a95e:	1a9b      	subs	r3, r3, r2
  20a960:	009b      	lsls	r3, r3, #2
  20a962:	440b      	add	r3, r1
  20a964:	3310      	adds	r3, #16
  20a966:	683a      	ldr	r2, [r7, #0]
  20a968:	601a      	str	r2, [r3, #0]
}
  20a96a:	bf00      	nop
  20a96c:	370c      	adds	r7, #12
  20a96e:	46bd      	mov	sp, r7
  20a970:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a974:	4770      	bx	lr
  20a976:	bf00      	nop
  20a978:	2000f818 	.word	0x2000f818

0020a97c <LCD_SetStrVar_x>:
void LCD_SetStrVar_x(int idVar,int x){
  20a97c:	b480      	push	{r7}
  20a97e:	b083      	sub	sp, #12
  20a980:	af00      	add	r7, sp, #0
  20a982:	6078      	str	r0, [r7, #4]
  20a984:	6039      	str	r1, [r7, #0]
	FontVar[idVar].xPos=x;
  20a986:	683b      	ldr	r3, [r7, #0]
  20a988:	b298      	uxth	r0, r3
  20a98a:	4908      	ldr	r1, [pc, #32]	; (20a9ac <LCD_SetStrVar_x+0x30>)
  20a98c:	687a      	ldr	r2, [r7, #4]
  20a98e:	4613      	mov	r3, r2
  20a990:	011b      	lsls	r3, r3, #4
  20a992:	1a9b      	subs	r3, r3, r2
  20a994:	009b      	lsls	r3, r3, #2
  20a996:	440b      	add	r3, r1
  20a998:	3302      	adds	r3, #2
  20a99a:	4602      	mov	r2, r0
  20a99c:	801a      	strh	r2, [r3, #0]
}
  20a99e:	bf00      	nop
  20a9a0:	370c      	adds	r7, #12
  20a9a2:	46bd      	mov	sp, r7
  20a9a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a9a8:	4770      	bx	lr
  20a9aa:	bf00      	nop
  20a9ac:	2000f818 	.word	0x2000f818

0020a9b0 <LCD_SetStrVar_y>:
void LCD_SetStrVar_y(int idVar,int y){
  20a9b0:	b480      	push	{r7}
  20a9b2:	b083      	sub	sp, #12
  20a9b4:	af00      	add	r7, sp, #0
  20a9b6:	6078      	str	r0, [r7, #4]
  20a9b8:	6039      	str	r1, [r7, #0]
	FontVar[idVar].yPos=y;
  20a9ba:	683b      	ldr	r3, [r7, #0]
  20a9bc:	b298      	uxth	r0, r3
  20a9be:	4908      	ldr	r1, [pc, #32]	; (20a9e0 <LCD_SetStrVar_y+0x30>)
  20a9c0:	687a      	ldr	r2, [r7, #4]
  20a9c2:	4613      	mov	r3, r2
  20a9c4:	011b      	lsls	r3, r3, #4
  20a9c6:	1a9b      	subs	r3, r3, r2
  20a9c8:	009b      	lsls	r3, r3, #2
  20a9ca:	440b      	add	r3, r1
  20a9cc:	3304      	adds	r3, #4
  20a9ce:	4602      	mov	r2, r0
  20a9d0:	801a      	strh	r2, [r3, #0]
}
  20a9d2:	bf00      	nop
  20a9d4:	370c      	adds	r7, #12
  20a9d6:	46bd      	mov	sp, r7
  20a9d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  20a9dc:	4770      	bx	lr
  20a9de:	bf00      	nop
  20a9e0:	2000f818 	.word	0x2000f818

0020a9e4 <LCD_OffsStrVar_x>:
void LCD_OffsStrVar_x(int idVar,int x){
  20a9e4:	b480      	push	{r7}
  20a9e6:	b083      	sub	sp, #12
  20a9e8:	af00      	add	r7, sp, #0
  20a9ea:	6078      	str	r0, [r7, #4]
  20a9ec:	6039      	str	r1, [r7, #0]
	FontVar[idVar].xPos+=x;
  20a9ee:	490e      	ldr	r1, [pc, #56]	; (20aa28 <LCD_OffsStrVar_x+0x44>)
  20a9f0:	687a      	ldr	r2, [r7, #4]
  20a9f2:	4613      	mov	r3, r2
  20a9f4:	011b      	lsls	r3, r3, #4
  20a9f6:	1a9b      	subs	r3, r3, r2
  20a9f8:	009b      	lsls	r3, r3, #2
  20a9fa:	440b      	add	r3, r1
  20a9fc:	3302      	adds	r3, #2
  20a9fe:	881a      	ldrh	r2, [r3, #0]
  20aa00:	683b      	ldr	r3, [r7, #0]
  20aa02:	b29b      	uxth	r3, r3
  20aa04:	4413      	add	r3, r2
  20aa06:	b298      	uxth	r0, r3
  20aa08:	4907      	ldr	r1, [pc, #28]	; (20aa28 <LCD_OffsStrVar_x+0x44>)
  20aa0a:	687a      	ldr	r2, [r7, #4]
  20aa0c:	4613      	mov	r3, r2
  20aa0e:	011b      	lsls	r3, r3, #4
  20aa10:	1a9b      	subs	r3, r3, r2
  20aa12:	009b      	lsls	r3, r3, #2
  20aa14:	440b      	add	r3, r1
  20aa16:	3302      	adds	r3, #2
  20aa18:	4602      	mov	r2, r0
  20aa1a:	801a      	strh	r2, [r3, #0]
}
  20aa1c:	bf00      	nop
  20aa1e:	370c      	adds	r7, #12
  20aa20:	46bd      	mov	sp, r7
  20aa22:	f85d 7b04 	ldr.w	r7, [sp], #4
  20aa26:	4770      	bx	lr
  20aa28:	2000f818 	.word	0x2000f818

0020aa2c <LCD_OffsStrVar_y>:
void LCD_OffsStrVar_y(int idVar,int y){
  20aa2c:	b480      	push	{r7}
  20aa2e:	b083      	sub	sp, #12
  20aa30:	af00      	add	r7, sp, #0
  20aa32:	6078      	str	r0, [r7, #4]
  20aa34:	6039      	str	r1, [r7, #0]
	FontVar[idVar].yPos+=y;
  20aa36:	490e      	ldr	r1, [pc, #56]	; (20aa70 <LCD_OffsStrVar_y+0x44>)
  20aa38:	687a      	ldr	r2, [r7, #4]
  20aa3a:	4613      	mov	r3, r2
  20aa3c:	011b      	lsls	r3, r3, #4
  20aa3e:	1a9b      	subs	r3, r3, r2
  20aa40:	009b      	lsls	r3, r3, #2
  20aa42:	440b      	add	r3, r1
  20aa44:	3304      	adds	r3, #4
  20aa46:	881a      	ldrh	r2, [r3, #0]
  20aa48:	683b      	ldr	r3, [r7, #0]
  20aa4a:	b29b      	uxth	r3, r3
  20aa4c:	4413      	add	r3, r2
  20aa4e:	b298      	uxth	r0, r3
  20aa50:	4907      	ldr	r1, [pc, #28]	; (20aa70 <LCD_OffsStrVar_y+0x44>)
  20aa52:	687a      	ldr	r2, [r7, #4]
  20aa54:	4613      	mov	r3, r2
  20aa56:	011b      	lsls	r3, r3, #4
  20aa58:	1a9b      	subs	r3, r3, r2
  20aa5a:	009b      	lsls	r3, r3, #2
  20aa5c:	440b      	add	r3, r1
  20aa5e:	3304      	adds	r3, #4
  20aa60:	4602      	mov	r2, r0
  20aa62:	801a      	strh	r2, [r3, #0]
}
  20aa64:	bf00      	nop
  20aa66:	370c      	adds	r7, #12
  20aa68:	46bd      	mov	sp, r7
  20aa6a:	f85d 7b04 	ldr.w	r7, [sp], #4
  20aa6e:	4770      	bx	lr
  20aa70:	2000f818 	.word	0x2000f818

0020aa74 <LCD_SetStrVar_coeff>:
	FontVar[idVar].heightType=OnlyDigits;
}
void LCD_SetStrVar_widthType(int idVar, int constWidth){
	FontVar[idVar].widthType=constWidth;
}
void LCD_SetStrVar_coeff(int idVar, int coeff){
  20aa74:	b480      	push	{r7}
  20aa76:	b083      	sub	sp, #12
  20aa78:	af00      	add	r7, sp, #0
  20aa7a:	6078      	str	r0, [r7, #4]
  20aa7c:	6039      	str	r1, [r7, #0]
	FontVar[idVar].coeff=coeff;
  20aa7e:	4908      	ldr	r1, [pc, #32]	; (20aaa0 <LCD_SetStrVar_coeff+0x2c>)
  20aa80:	687a      	ldr	r2, [r7, #4]
  20aa82:	4613      	mov	r3, r2
  20aa84:	011b      	lsls	r3, r3, #4
  20aa86:	1a9b      	subs	r3, r3, r2
  20aa88:	009b      	lsls	r3, r3, #2
  20aa8a:	440b      	add	r3, r1
  20aa8c:	3318      	adds	r3, #24
  20aa8e:	683a      	ldr	r2, [r7, #0]
  20aa90:	601a      	str	r2, [r3, #0]
}
  20aa92:	bf00      	nop
  20aa94:	370c      	adds	r7, #12
  20aa96:	46bd      	mov	sp, r7
  20aa98:	f85d 7b04 	ldr.w	r7, [sp], #4
  20aa9c:	4770      	bx	lr
  20aa9e:	bf00      	nop
  20aaa0:	2000f818 	.word	0x2000f818

0020aaa4 <LCD_SetStrVar_fontID>:
void LCD_SetStrVar_space(int idVar, int space){
	FontVar[idVar].space=space;
}
void LCD_SetStrVar_fontID(int idVar, int fontID){
  20aaa4:	b480      	push	{r7}
  20aaa6:	b083      	sub	sp, #12
  20aaa8:	af00      	add	r7, sp, #0
  20aaaa:	6078      	str	r0, [r7, #4]
  20aaac:	6039      	str	r1, [r7, #0]
	FontVar[idVar].id=fontID;
  20aaae:	683b      	ldr	r3, [r7, #0]
  20aab0:	b298      	uxth	r0, r3
  20aab2:	4907      	ldr	r1, [pc, #28]	; (20aad0 <LCD_SetStrVar_fontID+0x2c>)
  20aab4:	687a      	ldr	r2, [r7, #4]
  20aab6:	4613      	mov	r3, r2
  20aab8:	011b      	lsls	r3, r3, #4
  20aaba:	1a9b      	subs	r3, r3, r2
  20aabc:	009b      	lsls	r3, r3, #2
  20aabe:	440b      	add	r3, r1
  20aac0:	4602      	mov	r2, r0
  20aac2:	801a      	strh	r2, [r3, #0]
}
  20aac4:	bf00      	nop
  20aac6:	370c      	adds	r7, #12
  20aac8:	46bd      	mov	sp, r7
  20aaca:	f85d 7b04 	ldr.w	r7, [sp], #4
  20aace:	4770      	bx	lr
  20aad0:	2000f818 	.word	0x2000f818

0020aad4 <LCD_GetStrVar_x>:
	return FontVar[idVar].bkColor;
}
uint32_t LCD_GetStrVar_fontColor(int idVar){
	return FontVar[idVar].bkColor;
}
int LCD_GetStrVar_x(int idVar){
  20aad4:	b480      	push	{r7}
  20aad6:	b083      	sub	sp, #12
  20aad8:	af00      	add	r7, sp, #0
  20aada:	6078      	str	r0, [r7, #4]
	return FontVar[idVar].xPos;
  20aadc:	4907      	ldr	r1, [pc, #28]	; (20aafc <LCD_GetStrVar_x+0x28>)
  20aade:	687a      	ldr	r2, [r7, #4]
  20aae0:	4613      	mov	r3, r2
  20aae2:	011b      	lsls	r3, r3, #4
  20aae4:	1a9b      	subs	r3, r3, r2
  20aae6:	009b      	lsls	r3, r3, #2
  20aae8:	440b      	add	r3, r1
  20aaea:	3302      	adds	r3, #2
  20aaec:	881b      	ldrh	r3, [r3, #0]
}
  20aaee:	4618      	mov	r0, r3
  20aaf0:	370c      	adds	r7, #12
  20aaf2:	46bd      	mov	sp, r7
  20aaf4:	f85d 7b04 	ldr.w	r7, [sp], #4
  20aaf8:	4770      	bx	lr
  20aafa:	bf00      	nop
  20aafc:	2000f818 	.word	0x2000f818

0020ab00 <LCD_GetStrVar_y>:
int LCD_GetStrVar_y(int idVar){
  20ab00:	b480      	push	{r7}
  20ab02:	b083      	sub	sp, #12
  20ab04:	af00      	add	r7, sp, #0
  20ab06:	6078      	str	r0, [r7, #4]
	return FontVar[idVar].yPos;
  20ab08:	4907      	ldr	r1, [pc, #28]	; (20ab28 <LCD_GetStrVar_y+0x28>)
  20ab0a:	687a      	ldr	r2, [r7, #4]
  20ab0c:	4613      	mov	r3, r2
  20ab0e:	011b      	lsls	r3, r3, #4
  20ab10:	1a9b      	subs	r3, r3, r2
  20ab12:	009b      	lsls	r3, r3, #2
  20ab14:	440b      	add	r3, r1
  20ab16:	3304      	adds	r3, #4
  20ab18:	881b      	ldrh	r3, [r3, #0]
}
  20ab1a:	4618      	mov	r0, r3
  20ab1c:	370c      	adds	r7, #12
  20ab1e:	46bd      	mov	sp, r7
  20ab20:	f85d 7b04 	ldr.w	r7, [sp], #4
  20ab24:	4770      	bx	lr
  20ab26:	bf00      	nop
  20ab28:	2000f818 	.word	0x2000f818

0020ab2c <LCD_DeleteAllFontAndImages>:
int LCD_GetStrVar_Mov_posWin(int idVar){
	return FontVar[idVar].FontMov.posWin;
}

void LCD_DeleteAllFontAndImages(void)
{
  20ab2c:	b480      	push	{r7}
  20ab2e:	b083      	sub	sp, #12
  20ab30:	af00      	add	r7, sp, #0
	int i;
	CounterBusyBytesForFontsImages=0;
  20ab32:	4b56      	ldr	r3, [pc, #344]	; (20ac8c <LCD_DeleteAllFontAndImages+0x160>)
  20ab34:	2200      	movs	r2, #0
  20ab36:	601a      	str	r2, [r3, #0]
	for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  20ab38:	2300      	movs	r3, #0
  20ab3a:	607b      	str	r3, [r7, #4]
  20ab3c:	e03f      	b.n	20abbe <LCD_DeleteAllFontAndImages+0x92>
	{
		Font[i].fontSizeToIndex=0;
  20ab3e:	4954      	ldr	r1, [pc, #336]	; (20ac90 <LCD_DeleteAllFontAndImages+0x164>)
  20ab40:	687a      	ldr	r2, [r7, #4]
  20ab42:	4613      	mov	r3, r2
  20ab44:	019b      	lsls	r3, r3, #6
  20ab46:	4413      	add	r3, r2
  20ab48:	015b      	lsls	r3, r3, #5
  20ab4a:	440b      	add	r3, r1
  20ab4c:	2200      	movs	r2, #0
  20ab4e:	601a      	str	r2, [r3, #0]
		Font[i].fontStyleToIndex=0;
  20ab50:	494f      	ldr	r1, [pc, #316]	; (20ac90 <LCD_DeleteAllFontAndImages+0x164>)
  20ab52:	687a      	ldr	r2, [r7, #4]
  20ab54:	4613      	mov	r3, r2
  20ab56:	019b      	lsls	r3, r3, #6
  20ab58:	4413      	add	r3, r2
  20ab5a:	015b      	lsls	r3, r3, #5
  20ab5c:	440b      	add	r3, r1
  20ab5e:	3304      	adds	r3, #4
  20ab60:	2200      	movs	r2, #0
  20ab62:	601a      	str	r2, [r3, #0]
		Font[i].fontBkColorToIndex=0;
  20ab64:	494a      	ldr	r1, [pc, #296]	; (20ac90 <LCD_DeleteAllFontAndImages+0x164>)
  20ab66:	687a      	ldr	r2, [r7, #4]
  20ab68:	4613      	mov	r3, r2
  20ab6a:	019b      	lsls	r3, r3, #6
  20ab6c:	4413      	add	r3, r2
  20ab6e:	015b      	lsls	r3, r3, #5
  20ab70:	440b      	add	r3, r1
  20ab72:	3308      	adds	r3, #8
  20ab74:	2200      	movs	r2, #0
  20ab76:	601a      	str	r2, [r3, #0]
		Font[i].fontColorToIndex=0;
  20ab78:	4945      	ldr	r1, [pc, #276]	; (20ac90 <LCD_DeleteAllFontAndImages+0x164>)
  20ab7a:	687a      	ldr	r2, [r7, #4]
  20ab7c:	4613      	mov	r3, r2
  20ab7e:	019b      	lsls	r3, r3, #6
  20ab80:	4413      	add	r3, r2
  20ab82:	015b      	lsls	r3, r3, #5
  20ab84:	440b      	add	r3, r1
  20ab86:	330c      	adds	r3, #12
  20ab88:	2200      	movs	r2, #0
  20ab8a:	601a      	str	r2, [r3, #0]
		Font[i].pointerToMemoryFont=0;
  20ab8c:	4940      	ldr	r1, [pc, #256]	; (20ac90 <LCD_DeleteAllFontAndImages+0x164>)
  20ab8e:	687a      	ldr	r2, [r7, #4]
  20ab90:	4613      	mov	r3, r2
  20ab92:	019b      	lsls	r3, r3, #6
  20ab94:	4413      	add	r3, r2
  20ab96:	015b      	lsls	r3, r3, #5
  20ab98:	440b      	add	r3, r1
  20ab9a:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20ab9e:	2200      	movs	r2, #0
  20aba0:	601a      	str	r2, [r3, #0]
		Font[i].fontSdramLenght=0;
  20aba2:	493b      	ldr	r1, [pc, #236]	; (20ac90 <LCD_DeleteAllFontAndImages+0x164>)
  20aba4:	687a      	ldr	r2, [r7, #4]
  20aba6:	4613      	mov	r3, r2
  20aba8:	019b      	lsls	r3, r3, #6
  20abaa:	4413      	add	r3, r2
  20abac:	015b      	lsls	r3, r3, #5
  20abae:	440b      	add	r3, r1
  20abb0:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  20abb4:	2200      	movs	r2, #0
  20abb6:	601a      	str	r2, [r3, #0]
	for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  20abb8:	687b      	ldr	r3, [r7, #4]
  20abba:	3301      	adds	r3, #1
  20abbc:	607b      	str	r3, [r7, #4]
  20abbe:	687b      	ldr	r3, [r7, #4]
  20abc0:	2b10      	cmp	r3, #16
  20abc2:	ddbc      	ble.n	20ab3e <LCD_DeleteAllFontAndImages+0x12>
	}
	for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  20abc4:	2300      	movs	r3, #0
  20abc6:	607b      	str	r3, [r7, #4]
  20abc8:	e01d      	b.n	20ac06 <LCD_DeleteAllFontAndImages+0xda>
	{
		FontID[i].size=0;
  20abca:	4a32      	ldr	r2, [pc, #200]	; (20ac94 <LCD_DeleteAllFontAndImages+0x168>)
  20abcc:	687b      	ldr	r3, [r7, #4]
  20abce:	011b      	lsls	r3, r3, #4
  20abd0:	4413      	add	r3, r2
  20abd2:	2200      	movs	r2, #0
  20abd4:	601a      	str	r2, [r3, #0]
		FontID[i].style=0;
  20abd6:	4a2f      	ldr	r2, [pc, #188]	; (20ac94 <LCD_DeleteAllFontAndImages+0x168>)
  20abd8:	687b      	ldr	r3, [r7, #4]
  20abda:	011b      	lsls	r3, r3, #4
  20abdc:	4413      	add	r3, r2
  20abde:	3304      	adds	r3, #4
  20abe0:	2200      	movs	r2, #0
  20abe2:	601a      	str	r2, [r3, #0]
		FontID[i].bkColor=0;
  20abe4:	4a2b      	ldr	r2, [pc, #172]	; (20ac94 <LCD_DeleteAllFontAndImages+0x168>)
  20abe6:	687b      	ldr	r3, [r7, #4]
  20abe8:	011b      	lsls	r3, r3, #4
  20abea:	4413      	add	r3, r2
  20abec:	3308      	adds	r3, #8
  20abee:	2200      	movs	r2, #0
  20abf0:	601a      	str	r2, [r3, #0]
		FontID[i].color=0;
  20abf2:	4a28      	ldr	r2, [pc, #160]	; (20ac94 <LCD_DeleteAllFontAndImages+0x168>)
  20abf4:	687b      	ldr	r3, [r7, #4]
  20abf6:	011b      	lsls	r3, r3, #4
  20abf8:	4413      	add	r3, r2
  20abfa:	330c      	adds	r3, #12
  20abfc:	2200      	movs	r2, #0
  20abfe:	601a      	str	r2, [r3, #0]
	for(i=0; i<MAX_OPEN_FONTS_SIMULTANEOUSLY; i++)
  20ac00:	687b      	ldr	r3, [r7, #4]
  20ac02:	3301      	adds	r3, #1
  20ac04:	607b      	str	r3, [r7, #4]
  20ac06:	687b      	ldr	r3, [r7, #4]
  20ac08:	2b10      	cmp	r3, #16
  20ac0a:	ddde      	ble.n	20abca <LCD_DeleteAllFontAndImages+0x9e>
	}
	for(i=0; i<MAX_OPEN_IMAGES_SIMULTANEOUSLY; i++)
  20ac0c:	2300      	movs	r3, #0
  20ac0e:	607b      	str	r3, [r7, #4]
  20ac10:	e01f      	b.n	20ac52 <LCD_DeleteAllFontAndImages+0x126>
	{
		Image[i].name[0]=0;
  20ac12:	4921      	ldr	r1, [pc, #132]	; (20ac98 <LCD_DeleteAllFontAndImages+0x16c>)
  20ac14:	687a      	ldr	r2, [r7, #4]
  20ac16:	4613      	mov	r3, r2
  20ac18:	005b      	lsls	r3, r3, #1
  20ac1a:	4413      	add	r3, r2
  20ac1c:	011b      	lsls	r3, r3, #4
  20ac1e:	440b      	add	r3, r1
  20ac20:	2200      	movs	r2, #0
  20ac22:	701a      	strb	r2, [r3, #0]
		Image[i].pointerToMemory=0;
  20ac24:	491c      	ldr	r1, [pc, #112]	; (20ac98 <LCD_DeleteAllFontAndImages+0x16c>)
  20ac26:	687a      	ldr	r2, [r7, #4]
  20ac28:	4613      	mov	r3, r2
  20ac2a:	005b      	lsls	r3, r3, #1
  20ac2c:	4413      	add	r3, r2
  20ac2e:	011b      	lsls	r3, r3, #4
  20ac30:	440b      	add	r3, r1
  20ac32:	3320      	adds	r3, #32
  20ac34:	2200      	movs	r2, #0
  20ac36:	601a      	str	r2, [r3, #0]
		Image[i].sdramLenght=0;
  20ac38:	4917      	ldr	r1, [pc, #92]	; (20ac98 <LCD_DeleteAllFontAndImages+0x16c>)
  20ac3a:	687a      	ldr	r2, [r7, #4]
  20ac3c:	4613      	mov	r3, r2
  20ac3e:	005b      	lsls	r3, r3, #1
  20ac40:	4413      	add	r3, r2
  20ac42:	011b      	lsls	r3, r3, #4
  20ac44:	440b      	add	r3, r1
  20ac46:	3324      	adds	r3, #36	; 0x24
  20ac48:	2200      	movs	r2, #0
  20ac4a:	601a      	str	r2, [r3, #0]
	for(i=0; i<MAX_OPEN_IMAGES_SIMULTANEOUSLY; i++)
  20ac4c:	687b      	ldr	r3, [r7, #4]
  20ac4e:	3301      	adds	r3, #1
  20ac50:	607b      	str	r3, [r7, #4]
  20ac52:	687b      	ldr	r3, [r7, #4]
  20ac54:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
  20ac58:	dbdb      	blt.n	20ac12 <LCD_DeleteAllFontAndImages+0xe6>
	}
	for(i=0; i<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY; i++)
  20ac5a:	2300      	movs	r3, #0
  20ac5c:	607b      	str	r3, [r7, #4]
  20ac5e:	e00b      	b.n	20ac78 <LCD_DeleteAllFontAndImages+0x14c>
	{
		FontVar[i].id=0;
  20ac60:	490e      	ldr	r1, [pc, #56]	; (20ac9c <LCD_DeleteAllFontAndImages+0x170>)
  20ac62:	687a      	ldr	r2, [r7, #4]
  20ac64:	4613      	mov	r3, r2
  20ac66:	011b      	lsls	r3, r3, #4
  20ac68:	1a9b      	subs	r3, r3, r2
  20ac6a:	009b      	lsls	r3, r3, #2
  20ac6c:	440b      	add	r3, r1
  20ac6e:	2200      	movs	r2, #0
  20ac70:	801a      	strh	r2, [r3, #0]
	for(i=0; i<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY; i++)
  20ac72:	687b      	ldr	r3, [r7, #4]
  20ac74:	3301      	adds	r3, #1
  20ac76:	607b      	str	r3, [r7, #4]
  20ac78:	687b      	ldr	r3, [r7, #4]
  20ac7a:	2b27      	cmp	r3, #39	; 0x27
  20ac7c:	ddf0      	ble.n	20ac60 <LCD_DeleteAllFontAndImages+0x134>
	}
}
  20ac7e:	bf00      	nop
  20ac80:	370c      	adds	r7, #12
  20ac82:	46bd      	mov	sp, r7
  20ac84:	f85d 7b04 	ldr.w	r7, [sp], #4
  20ac88:	4770      	bx	lr
  20ac8a:	bf00      	nop
  20ac8c:	20010370 	.word	0x20010370
  20ac90:	20003590 	.word	0x20003590
  20ac94:	20003480 	.word	0x20003480
  20ac98:	2000bfb0 	.word	0x2000bfb0
  20ac9c:	2000f818 	.word	0x2000f818

0020aca0 <LCD_DeleteFont>:

int LCD_DeleteFont(uint32_t fontID)
{
  20aca0:	b590      	push	{r4, r7, lr}
  20aca2:	b085      	sub	sp, #20
  20aca4:	af00      	add	r7, sp, #0
  20aca6:	6078      	str	r0, [r7, #4]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  20aca8:	4a56      	ldr	r2, [pc, #344]	; (20ae04 <LCD_DeleteFont+0x164>)
  20acaa:	687b      	ldr	r3, [r7, #4]
  20acac:	011b      	lsls	r3, r3, #4
  20acae:	4413      	add	r3, r2
  20acb0:	681b      	ldr	r3, [r3, #0]
  20acb2:	4618      	mov	r0, r3
  20acb4:	4a53      	ldr	r2, [pc, #332]	; (20ae04 <LCD_DeleteFont+0x164>)
  20acb6:	687b      	ldr	r3, [r7, #4]
  20acb8:	011b      	lsls	r3, r3, #4
  20acba:	4413      	add	r3, r2
  20acbc:	3304      	adds	r3, #4
  20acbe:	681b      	ldr	r3, [r3, #0]
  20acc0:	461c      	mov	r4, r3
  20acc2:	4a50      	ldr	r2, [pc, #320]	; (20ae04 <LCD_DeleteFont+0x164>)
  20acc4:	687b      	ldr	r3, [r7, #4]
  20acc6:	011b      	lsls	r3, r3, #4
  20acc8:	4413      	add	r3, r2
  20acca:	3308      	adds	r3, #8
  20accc:	6819      	ldr	r1, [r3, #0]
  20acce:	4a4d      	ldr	r2, [pc, #308]	; (20ae04 <LCD_DeleteFont+0x164>)
  20acd0:	687b      	ldr	r3, [r7, #4]
  20acd2:	011b      	lsls	r3, r3, #4
  20acd4:	4413      	add	r3, r2
  20acd6:	330c      	adds	r3, #12
  20acd8:	681b      	ldr	r3, [r3, #0]
  20acda:	460a      	mov	r2, r1
  20acdc:	4621      	mov	r1, r4
  20acde:	f7fd fdd1 	bl	208884 <SearchFontIndex>
  20ace2:	60f8      	str	r0, [r7, #12]
	if(fontIndex==-1)
  20ace4:	68fb      	ldr	r3, [r7, #12]
  20ace6:	f1b3 3fff 	cmp.w	r3, #4294967295
  20acea:	d101      	bne.n	20acf0 <LCD_DeleteFont+0x50>
		return 1;
  20acec:	2301      	movs	r3, #1
  20acee:	e085      	b.n	20adfc <LCD_DeleteFont+0x15c>
	Font[fontIndex].fontSizeToIndex=0;
  20acf0:	4945      	ldr	r1, [pc, #276]	; (20ae08 <LCD_DeleteFont+0x168>)
  20acf2:	68fa      	ldr	r2, [r7, #12]
  20acf4:	4613      	mov	r3, r2
  20acf6:	019b      	lsls	r3, r3, #6
  20acf8:	4413      	add	r3, r2
  20acfa:	015b      	lsls	r3, r3, #5
  20acfc:	440b      	add	r3, r1
  20acfe:	2200      	movs	r2, #0
  20ad00:	601a      	str	r2, [r3, #0]
	Font[fontIndex].fontStyleToIndex=0;
  20ad02:	4941      	ldr	r1, [pc, #260]	; (20ae08 <LCD_DeleteFont+0x168>)
  20ad04:	68fa      	ldr	r2, [r7, #12]
  20ad06:	4613      	mov	r3, r2
  20ad08:	019b      	lsls	r3, r3, #6
  20ad0a:	4413      	add	r3, r2
  20ad0c:	015b      	lsls	r3, r3, #5
  20ad0e:	440b      	add	r3, r1
  20ad10:	3304      	adds	r3, #4
  20ad12:	2200      	movs	r2, #0
  20ad14:	601a      	str	r2, [r3, #0]
	Font[fontIndex].fontBkColorToIndex=0;
  20ad16:	493c      	ldr	r1, [pc, #240]	; (20ae08 <LCD_DeleteFont+0x168>)
  20ad18:	68fa      	ldr	r2, [r7, #12]
  20ad1a:	4613      	mov	r3, r2
  20ad1c:	019b      	lsls	r3, r3, #6
  20ad1e:	4413      	add	r3, r2
  20ad20:	015b      	lsls	r3, r3, #5
  20ad22:	440b      	add	r3, r1
  20ad24:	3308      	adds	r3, #8
  20ad26:	2200      	movs	r2, #0
  20ad28:	601a      	str	r2, [r3, #0]
	Font[fontIndex].fontColorToIndex=0;
  20ad2a:	4937      	ldr	r1, [pc, #220]	; (20ae08 <LCD_DeleteFont+0x168>)
  20ad2c:	68fa      	ldr	r2, [r7, #12]
  20ad2e:	4613      	mov	r3, r2
  20ad30:	019b      	lsls	r3, r3, #6
  20ad32:	4413      	add	r3, r2
  20ad34:	015b      	lsls	r3, r3, #5
  20ad36:	440b      	add	r3, r1
  20ad38:	330c      	adds	r3, #12
  20ad3a:	2200      	movs	r2, #0
  20ad3c:	601a      	str	r2, [r3, #0]
	Font[fontIndex].pointerToMemoryFont=0;
  20ad3e:	4932      	ldr	r1, [pc, #200]	; (20ae08 <LCD_DeleteFont+0x168>)
  20ad40:	68fa      	ldr	r2, [r7, #12]
  20ad42:	4613      	mov	r3, r2
  20ad44:	019b      	lsls	r3, r3, #6
  20ad46:	4413      	add	r3, r2
  20ad48:	015b      	lsls	r3, r3, #5
  20ad4a:	440b      	add	r3, r1
  20ad4c:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20ad50:	2200      	movs	r2, #0
  20ad52:	601a      	str	r2, [r3, #0]

	FontID[fontID].size=0;
  20ad54:	4a2b      	ldr	r2, [pc, #172]	; (20ae04 <LCD_DeleteFont+0x164>)
  20ad56:	687b      	ldr	r3, [r7, #4]
  20ad58:	011b      	lsls	r3, r3, #4
  20ad5a:	4413      	add	r3, r2
  20ad5c:	2200      	movs	r2, #0
  20ad5e:	601a      	str	r2, [r3, #0]
	FontID[fontID].style=0;
  20ad60:	4a28      	ldr	r2, [pc, #160]	; (20ae04 <LCD_DeleteFont+0x164>)
  20ad62:	687b      	ldr	r3, [r7, #4]
  20ad64:	011b      	lsls	r3, r3, #4
  20ad66:	4413      	add	r3, r2
  20ad68:	3304      	adds	r3, #4
  20ad6a:	2200      	movs	r2, #0
  20ad6c:	601a      	str	r2, [r3, #0]
	FontID[fontID].bkColor=0;
  20ad6e:	4a25      	ldr	r2, [pc, #148]	; (20ae04 <LCD_DeleteFont+0x164>)
  20ad70:	687b      	ldr	r3, [r7, #4]
  20ad72:	011b      	lsls	r3, r3, #4
  20ad74:	4413      	add	r3, r2
  20ad76:	3308      	adds	r3, #8
  20ad78:	2200      	movs	r2, #0
  20ad7a:	601a      	str	r2, [r3, #0]
	FontID[fontID].color=0;
  20ad7c:	4a21      	ldr	r2, [pc, #132]	; (20ae04 <LCD_DeleteFont+0x164>)
  20ad7e:	687b      	ldr	r3, [r7, #4]
  20ad80:	011b      	lsls	r3, r3, #4
  20ad82:	4413      	add	r3, r2
  20ad84:	330c      	adds	r3, #12
  20ad86:	2200      	movs	r2, #0
  20ad88:	601a      	str	r2, [r3, #0]

	if( CounterBusyBytesForFontsImages >= Font[fontIndex].fontSdramLenght )
  20ad8a:	491f      	ldr	r1, [pc, #124]	; (20ae08 <LCD_DeleteFont+0x168>)
  20ad8c:	68fa      	ldr	r2, [r7, #12]
  20ad8e:	4613      	mov	r3, r2
  20ad90:	019b      	lsls	r3, r3, #6
  20ad92:	4413      	add	r3, r2
  20ad94:	015b      	lsls	r3, r3, #5
  20ad96:	440b      	add	r3, r1
  20ad98:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  20ad9c:	681a      	ldr	r2, [r3, #0]
  20ad9e:	4b1b      	ldr	r3, [pc, #108]	; (20ae0c <LCD_DeleteFont+0x16c>)
  20ada0:	681b      	ldr	r3, [r3, #0]
  20ada2:	429a      	cmp	r2, r3
  20ada4:	d81b      	bhi.n	20adde <LCD_DeleteFont+0x13e>
	{
		CounterBusyBytesForFontsImages -= Font[fontIndex].fontSdramLenght;
  20ada6:	4b19      	ldr	r3, [pc, #100]	; (20ae0c <LCD_DeleteFont+0x16c>)
  20ada8:	6819      	ldr	r1, [r3, #0]
  20adaa:	4817      	ldr	r0, [pc, #92]	; (20ae08 <LCD_DeleteFont+0x168>)
  20adac:	68fa      	ldr	r2, [r7, #12]
  20adae:	4613      	mov	r3, r2
  20adb0:	019b      	lsls	r3, r3, #6
  20adb2:	4413      	add	r3, r2
  20adb4:	015b      	lsls	r3, r3, #5
  20adb6:	4403      	add	r3, r0
  20adb8:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  20adbc:	681b      	ldr	r3, [r3, #0]
  20adbe:	1acb      	subs	r3, r1, r3
  20adc0:	4a12      	ldr	r2, [pc, #72]	; (20ae0c <LCD_DeleteFont+0x16c>)
  20adc2:	6013      	str	r3, [r2, #0]
		Font[fontIndex].fontSdramLenght=0;
  20adc4:	4910      	ldr	r1, [pc, #64]	; (20ae08 <LCD_DeleteFont+0x168>)
  20adc6:	68fa      	ldr	r2, [r7, #12]
  20adc8:	4613      	mov	r3, r2
  20adca:	019b      	lsls	r3, r3, #6
  20adcc:	4413      	add	r3, r2
  20adce:	015b      	lsls	r3, r3, #5
  20add0:	440b      	add	r3, r1
  20add2:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  20add6:	2200      	movs	r2, #0
  20add8:	601a      	str	r2, [r3, #0]
		return 0;
  20adda:	2300      	movs	r3, #0
  20addc:	e00e      	b.n	20adfc <LCD_DeleteFont+0x15c>
	}
	else
	{
		CounterBusyBytesForFontsImages=0;
  20adde:	4b0b      	ldr	r3, [pc, #44]	; (20ae0c <LCD_DeleteFont+0x16c>)
  20ade0:	2200      	movs	r2, #0
  20ade2:	601a      	str	r2, [r3, #0]
		Font[fontIndex].fontSdramLenght=0;
  20ade4:	4908      	ldr	r1, [pc, #32]	; (20ae08 <LCD_DeleteFont+0x168>)
  20ade6:	68fa      	ldr	r2, [r7, #12]
  20ade8:	4613      	mov	r3, r2
  20adea:	019b      	lsls	r3, r3, #6
  20adec:	4413      	add	r3, r2
  20adee:	015b      	lsls	r3, r3, #5
  20adf0:	440b      	add	r3, r1
  20adf2:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  20adf6:	2200      	movs	r2, #0
  20adf8:	601a      	str	r2, [r3, #0]
		return 2;
  20adfa:	2302      	movs	r3, #2
	}
}
  20adfc:	4618      	mov	r0, r3
  20adfe:	3714      	adds	r7, #20
  20ae00:	46bd      	mov	sp, r7
  20ae02:	bd90      	pop	{r4, r7, pc}
  20ae04:	20003480 	.word	0x20003480
  20ae08:	20003590 	.word	0x20003590
  20ae0c:	20010370 	.word	0x20010370

0020ae10 <LCD_FontSize2Str>:

char *LCD_FontSize2Str(char *buffTemp, int fontSize)
{
  20ae10:	b4b0      	push	{r4, r5, r7}
  20ae12:	b083      	sub	sp, #12
  20ae14:	af00      	add	r7, sp, #0
  20ae16:	6078      	str	r0, [r7, #4]
  20ae18:	6039      	str	r1, [r7, #0]
	switch(fontSize)
  20ae1a:	683b      	ldr	r3, [r7, #0]
  20ae1c:	2b32      	cmp	r3, #50	; 0x32
  20ae1e:	f200 82a8 	bhi.w	20b372 <LCD_FontSize2Str+0x562>
  20ae22:	a201      	add	r2, pc, #4	; (adr r2, 20ae28 <LCD_FontSize2Str+0x18>)
  20ae24:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  20ae28:	0020aef5 	.word	0x0020aef5
  20ae2c:	0020af07 	.word	0x0020af07
  20ae30:	0020af19 	.word	0x0020af19
  20ae34:	0020af33 	.word	0x0020af33
  20ae38:	0020af45 	.word	0x0020af45
  20ae3c:	0020af57 	.word	0x0020af57
  20ae40:	0020af71 	.word	0x0020af71
  20ae44:	0020af81 	.word	0x0020af81
  20ae48:	0020af97 	.word	0x0020af97
  20ae4c:	0020afab 	.word	0x0020afab
  20ae50:	0020afbb 	.word	0x0020afbb
  20ae54:	0020afd1 	.word	0x0020afd1
  20ae58:	0020afe5 	.word	0x0020afe5
  20ae5c:	0020aff5 	.word	0x0020aff5
  20ae60:	0020b00b 	.word	0x0020b00b
  20ae64:	0020b01f 	.word	0x0020b01f
  20ae68:	0020b02f 	.word	0x0020b02f
  20ae6c:	0020b045 	.word	0x0020b045
  20ae70:	0020b059 	.word	0x0020b059
  20ae74:	0020b069 	.word	0x0020b069
  20ae78:	0020b07f 	.word	0x0020b07f
  20ae7c:	0020b093 	.word	0x0020b093
  20ae80:	0020b0a3 	.word	0x0020b0a3
  20ae84:	0020b0b9 	.word	0x0020b0b9
  20ae88:	0020b0cd 	.word	0x0020b0cd
  20ae8c:	0020b0dd 	.word	0x0020b0dd
  20ae90:	0020b0f3 	.word	0x0020b0f3
  20ae94:	0020b107 	.word	0x0020b107
  20ae98:	0020b117 	.word	0x0020b117
  20ae9c:	0020b12d 	.word	0x0020b12d
  20aea0:	0020b141 	.word	0x0020b141
  20aea4:	0020b151 	.word	0x0020b151
  20aea8:	0020b167 	.word	0x0020b167
  20aeac:	0020b17b 	.word	0x0020b17b
  20aeb0:	0020b18b 	.word	0x0020b18b
  20aeb4:	0020b1a1 	.word	0x0020b1a1
  20aeb8:	0020b1b5 	.word	0x0020b1b5
  20aebc:	0020b259 	.word	0x0020b259
  20aec0:	0020b26f 	.word	0x0020b26f
  20aec4:	0020b283 	.word	0x0020b283
  20aec8:	0020b293 	.word	0x0020b293
  20aecc:	0020b2a9 	.word	0x0020b2a9
  20aed0:	0020b2bd 	.word	0x0020b2bd
  20aed4:	0020b2cd 	.word	0x0020b2cd
  20aed8:	0020b2e3 	.word	0x0020b2e3
  20aedc:	0020b2f7 	.word	0x0020b2f7
  20aee0:	0020b307 	.word	0x0020b307
  20aee4:	0020b31d 	.word	0x0020b31d
  20aee8:	0020b331 	.word	0x0020b331
  20aeec:	0020b345 	.word	0x0020b345
  20aef0:	0020b35b 	.word	0x0020b35b
	{
	case FONT_8:   			strcpy(buffTemp,"font_8"); break;
  20aef4:	687b      	ldr	r3, [r7, #4]
  20aef6:	4ab3      	ldr	r2, [pc, #716]	; (20b1c4 <LCD_FontSize2Str+0x3b4>)
  20aef8:	6810      	ldr	r0, [r2, #0]
  20aefa:	6018      	str	r0, [r3, #0]
  20aefc:	8891      	ldrh	r1, [r2, #4]
  20aefe:	7992      	ldrb	r2, [r2, #6]
  20af00:	8099      	strh	r1, [r3, #4]
  20af02:	719a      	strb	r2, [r3, #6]
  20af04:	e239      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_8_bold:   		strcpy(buffTemp,"font_8_bold"); break;
  20af06:	687b      	ldr	r3, [r7, #4]
  20af08:	4aaf      	ldr	r2, [pc, #700]	; (20b1c8 <LCD_FontSize2Str+0x3b8>)
  20af0a:	461c      	mov	r4, r3
  20af0c:	4613      	mov	r3, r2
  20af0e:	cb07      	ldmia	r3!, {r0, r1, r2}
  20af10:	6020      	str	r0, [r4, #0]
  20af12:	6061      	str	r1, [r4, #4]
  20af14:	60a2      	str	r2, [r4, #8]
  20af16:	e230      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_8_italics: 	strcpy(buffTemp,"font_8_italics"); break;
  20af18:	687b      	ldr	r3, [r7, #4]
  20af1a:	4aac      	ldr	r2, [pc, #688]	; (20b1cc <LCD_FontSize2Str+0x3bc>)
  20af1c:	461c      	mov	r4, r3
  20af1e:	4613      	mov	r3, r2
  20af20:	cb07      	ldmia	r3!, {r0, r1, r2}
  20af22:	6020      	str	r0, [r4, #0]
  20af24:	6061      	str	r1, [r4, #4]
  20af26:	60a2      	str	r2, [r4, #8]
  20af28:	881a      	ldrh	r2, [r3, #0]
  20af2a:	789b      	ldrb	r3, [r3, #2]
  20af2c:	81a2      	strh	r2, [r4, #12]
  20af2e:	73a3      	strb	r3, [r4, #14]
  20af30:	e223      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_9:   			strcpy(buffTemp,"font_9"); break;
  20af32:	687b      	ldr	r3, [r7, #4]
  20af34:	4aa6      	ldr	r2, [pc, #664]	; (20b1d0 <LCD_FontSize2Str+0x3c0>)
  20af36:	6810      	ldr	r0, [r2, #0]
  20af38:	6018      	str	r0, [r3, #0]
  20af3a:	8891      	ldrh	r1, [r2, #4]
  20af3c:	7992      	ldrb	r2, [r2, #6]
  20af3e:	8099      	strh	r1, [r3, #4]
  20af40:	719a      	strb	r2, [r3, #6]
  20af42:	e21a      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_9_bold:   		strcpy(buffTemp,"font_9_bold"); break;
  20af44:	687b      	ldr	r3, [r7, #4]
  20af46:	4aa3      	ldr	r2, [pc, #652]	; (20b1d4 <LCD_FontSize2Str+0x3c4>)
  20af48:	461c      	mov	r4, r3
  20af4a:	4613      	mov	r3, r2
  20af4c:	cb07      	ldmia	r3!, {r0, r1, r2}
  20af4e:	6020      	str	r0, [r4, #0]
  20af50:	6061      	str	r1, [r4, #4]
  20af52:	60a2      	str	r2, [r4, #8]
  20af54:	e211      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_9_italics: 	strcpy(buffTemp,"font_9_italics"); break;
  20af56:	687b      	ldr	r3, [r7, #4]
  20af58:	4a9f      	ldr	r2, [pc, #636]	; (20b1d8 <LCD_FontSize2Str+0x3c8>)
  20af5a:	461c      	mov	r4, r3
  20af5c:	4613      	mov	r3, r2
  20af5e:	cb07      	ldmia	r3!, {r0, r1, r2}
  20af60:	6020      	str	r0, [r4, #0]
  20af62:	6061      	str	r1, [r4, #4]
  20af64:	60a2      	str	r2, [r4, #8]
  20af66:	881a      	ldrh	r2, [r3, #0]
  20af68:	789b      	ldrb	r3, [r3, #2]
  20af6a:	81a2      	strh	r2, [r4, #12]
  20af6c:	73a3      	strb	r3, [r4, #14]
  20af6e:	e204      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_10:   			strcpy(buffTemp,"font_10"); break;
  20af70:	687b      	ldr	r3, [r7, #4]
  20af72:	499a      	ldr	r1, [pc, #616]	; (20b1dc <LCD_FontSize2Str+0x3cc>)
  20af74:	461a      	mov	r2, r3
  20af76:	460b      	mov	r3, r1
  20af78:	cb03      	ldmia	r3!, {r0, r1}
  20af7a:	6010      	str	r0, [r2, #0]
  20af7c:	6051      	str	r1, [r2, #4]
  20af7e:	e1fc      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_10_bold:   	strcpy(buffTemp,"font_10_bold"); break;
  20af80:	687b      	ldr	r3, [r7, #4]
  20af82:	4a97      	ldr	r2, [pc, #604]	; (20b1e0 <LCD_FontSize2Str+0x3d0>)
  20af84:	461c      	mov	r4, r3
  20af86:	4613      	mov	r3, r2
  20af88:	cb07      	ldmia	r3!, {r0, r1, r2}
  20af8a:	6020      	str	r0, [r4, #0]
  20af8c:	6061      	str	r1, [r4, #4]
  20af8e:	60a2      	str	r2, [r4, #8]
  20af90:	781b      	ldrb	r3, [r3, #0]
  20af92:	7323      	strb	r3, [r4, #12]
  20af94:	e1f1      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_10_italics: 	strcpy(buffTemp,"font_10_italics"); break;
  20af96:	687b      	ldr	r3, [r7, #4]
  20af98:	4a92      	ldr	r2, [pc, #584]	; (20b1e4 <LCD_FontSize2Str+0x3d4>)
  20af9a:	461c      	mov	r4, r3
  20af9c:	4615      	mov	r5, r2
  20af9e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20afa0:	6020      	str	r0, [r4, #0]
  20afa2:	6061      	str	r1, [r4, #4]
  20afa4:	60a2      	str	r2, [r4, #8]
  20afa6:	60e3      	str	r3, [r4, #12]
  20afa8:	e1e7      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_11:   			strcpy(buffTemp,"font_11"); break;
  20afaa:	687b      	ldr	r3, [r7, #4]
  20afac:	498e      	ldr	r1, [pc, #568]	; (20b1e8 <LCD_FontSize2Str+0x3d8>)
  20afae:	461a      	mov	r2, r3
  20afb0:	460b      	mov	r3, r1
  20afb2:	cb03      	ldmia	r3!, {r0, r1}
  20afb4:	6010      	str	r0, [r2, #0]
  20afb6:	6051      	str	r1, [r2, #4]
  20afb8:	e1df      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_11_bold:   	strcpy(buffTemp,"font_11_bold"); break;
  20afba:	687b      	ldr	r3, [r7, #4]
  20afbc:	4a8b      	ldr	r2, [pc, #556]	; (20b1ec <LCD_FontSize2Str+0x3dc>)
  20afbe:	461c      	mov	r4, r3
  20afc0:	4613      	mov	r3, r2
  20afc2:	cb07      	ldmia	r3!, {r0, r1, r2}
  20afc4:	6020      	str	r0, [r4, #0]
  20afc6:	6061      	str	r1, [r4, #4]
  20afc8:	60a2      	str	r2, [r4, #8]
  20afca:	781b      	ldrb	r3, [r3, #0]
  20afcc:	7323      	strb	r3, [r4, #12]
  20afce:	e1d4      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_11_italics: 	strcpy(buffTemp,"font_11_italics"); break;
  20afd0:	687b      	ldr	r3, [r7, #4]
  20afd2:	4a87      	ldr	r2, [pc, #540]	; (20b1f0 <LCD_FontSize2Str+0x3e0>)
  20afd4:	461c      	mov	r4, r3
  20afd6:	4615      	mov	r5, r2
  20afd8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20afda:	6020      	str	r0, [r4, #0]
  20afdc:	6061      	str	r1, [r4, #4]
  20afde:	60a2      	str	r2, [r4, #8]
  20afe0:	60e3      	str	r3, [r4, #12]
  20afe2:	e1ca      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_12:   			strcpy(buffTemp,"font_12"); break;
  20afe4:	687b      	ldr	r3, [r7, #4]
  20afe6:	4983      	ldr	r1, [pc, #524]	; (20b1f4 <LCD_FontSize2Str+0x3e4>)
  20afe8:	461a      	mov	r2, r3
  20afea:	460b      	mov	r3, r1
  20afec:	cb03      	ldmia	r3!, {r0, r1}
  20afee:	6010      	str	r0, [r2, #0]
  20aff0:	6051      	str	r1, [r2, #4]
  20aff2:	e1c2      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_12_bold:   	strcpy(buffTemp,"font_12_bold"); break;
  20aff4:	687b      	ldr	r3, [r7, #4]
  20aff6:	4a80      	ldr	r2, [pc, #512]	; (20b1f8 <LCD_FontSize2Str+0x3e8>)
  20aff8:	461c      	mov	r4, r3
  20affa:	4613      	mov	r3, r2
  20affc:	cb07      	ldmia	r3!, {r0, r1, r2}
  20affe:	6020      	str	r0, [r4, #0]
  20b000:	6061      	str	r1, [r4, #4]
  20b002:	60a2      	str	r2, [r4, #8]
  20b004:	781b      	ldrb	r3, [r3, #0]
  20b006:	7323      	strb	r3, [r4, #12]
  20b008:	e1b7      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_12_italics: 	strcpy(buffTemp,"font_12_italics"); break;
  20b00a:	687b      	ldr	r3, [r7, #4]
  20b00c:	4a7b      	ldr	r2, [pc, #492]	; (20b1fc <LCD_FontSize2Str+0x3ec>)
  20b00e:	461c      	mov	r4, r3
  20b010:	4615      	mov	r5, r2
  20b012:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b014:	6020      	str	r0, [r4, #0]
  20b016:	6061      	str	r1, [r4, #4]
  20b018:	60a2      	str	r2, [r4, #8]
  20b01a:	60e3      	str	r3, [r4, #12]
  20b01c:	e1ad      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_14:   			strcpy(buffTemp,"font_14"); break;
  20b01e:	687b      	ldr	r3, [r7, #4]
  20b020:	4977      	ldr	r1, [pc, #476]	; (20b200 <LCD_FontSize2Str+0x3f0>)
  20b022:	461a      	mov	r2, r3
  20b024:	460b      	mov	r3, r1
  20b026:	cb03      	ldmia	r3!, {r0, r1}
  20b028:	6010      	str	r0, [r2, #0]
  20b02a:	6051      	str	r1, [r2, #4]
  20b02c:	e1a5      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_14_bold:   	strcpy(buffTemp,"font_14_bold"); break;
  20b02e:	687b      	ldr	r3, [r7, #4]
  20b030:	4a74      	ldr	r2, [pc, #464]	; (20b204 <LCD_FontSize2Str+0x3f4>)
  20b032:	461c      	mov	r4, r3
  20b034:	4613      	mov	r3, r2
  20b036:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b038:	6020      	str	r0, [r4, #0]
  20b03a:	6061      	str	r1, [r4, #4]
  20b03c:	60a2      	str	r2, [r4, #8]
  20b03e:	781b      	ldrb	r3, [r3, #0]
  20b040:	7323      	strb	r3, [r4, #12]
  20b042:	e19a      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_14_italics: 	strcpy(buffTemp,"font_14_italics"); break;
  20b044:	687b      	ldr	r3, [r7, #4]
  20b046:	4a70      	ldr	r2, [pc, #448]	; (20b208 <LCD_FontSize2Str+0x3f8>)
  20b048:	461c      	mov	r4, r3
  20b04a:	4615      	mov	r5, r2
  20b04c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b04e:	6020      	str	r0, [r4, #0]
  20b050:	6061      	str	r1, [r4, #4]
  20b052:	60a2      	str	r2, [r4, #8]
  20b054:	60e3      	str	r3, [r4, #12]
  20b056:	e190      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_16:   			strcpy(buffTemp,"font_16"); break;
  20b058:	687b      	ldr	r3, [r7, #4]
  20b05a:	496c      	ldr	r1, [pc, #432]	; (20b20c <LCD_FontSize2Str+0x3fc>)
  20b05c:	461a      	mov	r2, r3
  20b05e:	460b      	mov	r3, r1
  20b060:	cb03      	ldmia	r3!, {r0, r1}
  20b062:	6010      	str	r0, [r2, #0]
  20b064:	6051      	str	r1, [r2, #4]
  20b066:	e188      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_16_bold:   	strcpy(buffTemp,"font_16_bold"); break;
  20b068:	687b      	ldr	r3, [r7, #4]
  20b06a:	4a69      	ldr	r2, [pc, #420]	; (20b210 <LCD_FontSize2Str+0x400>)
  20b06c:	461c      	mov	r4, r3
  20b06e:	4613      	mov	r3, r2
  20b070:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b072:	6020      	str	r0, [r4, #0]
  20b074:	6061      	str	r1, [r4, #4]
  20b076:	60a2      	str	r2, [r4, #8]
  20b078:	781b      	ldrb	r3, [r3, #0]
  20b07a:	7323      	strb	r3, [r4, #12]
  20b07c:	e17d      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_16_italics: 	strcpy(buffTemp,"font_16_italics"); break;
  20b07e:	687b      	ldr	r3, [r7, #4]
  20b080:	4a64      	ldr	r2, [pc, #400]	; (20b214 <LCD_FontSize2Str+0x404>)
  20b082:	461c      	mov	r4, r3
  20b084:	4615      	mov	r5, r2
  20b086:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b088:	6020      	str	r0, [r4, #0]
  20b08a:	6061      	str	r1, [r4, #4]
  20b08c:	60a2      	str	r2, [r4, #8]
  20b08e:	60e3      	str	r3, [r4, #12]
  20b090:	e173      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_18:   			strcpy(buffTemp,"font_18"); break;
  20b092:	687b      	ldr	r3, [r7, #4]
  20b094:	4960      	ldr	r1, [pc, #384]	; (20b218 <LCD_FontSize2Str+0x408>)
  20b096:	461a      	mov	r2, r3
  20b098:	460b      	mov	r3, r1
  20b09a:	cb03      	ldmia	r3!, {r0, r1}
  20b09c:	6010      	str	r0, [r2, #0]
  20b09e:	6051      	str	r1, [r2, #4]
  20b0a0:	e16b      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_18_bold:   	strcpy(buffTemp,"font_18_bold"); break;
  20b0a2:	687b      	ldr	r3, [r7, #4]
  20b0a4:	4a5d      	ldr	r2, [pc, #372]	; (20b21c <LCD_FontSize2Str+0x40c>)
  20b0a6:	461c      	mov	r4, r3
  20b0a8:	4613      	mov	r3, r2
  20b0aa:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b0ac:	6020      	str	r0, [r4, #0]
  20b0ae:	6061      	str	r1, [r4, #4]
  20b0b0:	60a2      	str	r2, [r4, #8]
  20b0b2:	781b      	ldrb	r3, [r3, #0]
  20b0b4:	7323      	strb	r3, [r4, #12]
  20b0b6:	e160      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_18_italics: 	strcpy(buffTemp,"font_18_italics"); break;
  20b0b8:	687b      	ldr	r3, [r7, #4]
  20b0ba:	4a59      	ldr	r2, [pc, #356]	; (20b220 <LCD_FontSize2Str+0x410>)
  20b0bc:	461c      	mov	r4, r3
  20b0be:	4615      	mov	r5, r2
  20b0c0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b0c2:	6020      	str	r0, [r4, #0]
  20b0c4:	6061      	str	r1, [r4, #4]
  20b0c6:	60a2      	str	r2, [r4, #8]
  20b0c8:	60e3      	str	r3, [r4, #12]
  20b0ca:	e156      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_20:   			strcpy(buffTemp,"font_20"); break;
  20b0cc:	687b      	ldr	r3, [r7, #4]
  20b0ce:	4955      	ldr	r1, [pc, #340]	; (20b224 <LCD_FontSize2Str+0x414>)
  20b0d0:	461a      	mov	r2, r3
  20b0d2:	460b      	mov	r3, r1
  20b0d4:	cb03      	ldmia	r3!, {r0, r1}
  20b0d6:	6010      	str	r0, [r2, #0]
  20b0d8:	6051      	str	r1, [r2, #4]
  20b0da:	e14e      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_20_bold:   	strcpy(buffTemp,"font_20_bold"); break;
  20b0dc:	687b      	ldr	r3, [r7, #4]
  20b0de:	4a52      	ldr	r2, [pc, #328]	; (20b228 <LCD_FontSize2Str+0x418>)
  20b0e0:	461c      	mov	r4, r3
  20b0e2:	4613      	mov	r3, r2
  20b0e4:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b0e6:	6020      	str	r0, [r4, #0]
  20b0e8:	6061      	str	r1, [r4, #4]
  20b0ea:	60a2      	str	r2, [r4, #8]
  20b0ec:	781b      	ldrb	r3, [r3, #0]
  20b0ee:	7323      	strb	r3, [r4, #12]
  20b0f0:	e143      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_20_italics: 	strcpy(buffTemp,"font_20_italics"); break;
  20b0f2:	687b      	ldr	r3, [r7, #4]
  20b0f4:	4a4d      	ldr	r2, [pc, #308]	; (20b22c <LCD_FontSize2Str+0x41c>)
  20b0f6:	461c      	mov	r4, r3
  20b0f8:	4615      	mov	r5, r2
  20b0fa:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b0fc:	6020      	str	r0, [r4, #0]
  20b0fe:	6061      	str	r1, [r4, #4]
  20b100:	60a2      	str	r2, [r4, #8]
  20b102:	60e3      	str	r3, [r4, #12]
  20b104:	e139      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_22:   			strcpy(buffTemp,"font_22"); break;
  20b106:	687b      	ldr	r3, [r7, #4]
  20b108:	4949      	ldr	r1, [pc, #292]	; (20b230 <LCD_FontSize2Str+0x420>)
  20b10a:	461a      	mov	r2, r3
  20b10c:	460b      	mov	r3, r1
  20b10e:	cb03      	ldmia	r3!, {r0, r1}
  20b110:	6010      	str	r0, [r2, #0]
  20b112:	6051      	str	r1, [r2, #4]
  20b114:	e131      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_22_bold:   	strcpy(buffTemp,"font_22_bold"); break;
  20b116:	687b      	ldr	r3, [r7, #4]
  20b118:	4a46      	ldr	r2, [pc, #280]	; (20b234 <LCD_FontSize2Str+0x424>)
  20b11a:	461c      	mov	r4, r3
  20b11c:	4613      	mov	r3, r2
  20b11e:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b120:	6020      	str	r0, [r4, #0]
  20b122:	6061      	str	r1, [r4, #4]
  20b124:	60a2      	str	r2, [r4, #8]
  20b126:	781b      	ldrb	r3, [r3, #0]
  20b128:	7323      	strb	r3, [r4, #12]
  20b12a:	e126      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_22_italics: 	strcpy(buffTemp,"font_22_italics"); break;
  20b12c:	687b      	ldr	r3, [r7, #4]
  20b12e:	4a42      	ldr	r2, [pc, #264]	; (20b238 <LCD_FontSize2Str+0x428>)
  20b130:	461c      	mov	r4, r3
  20b132:	4615      	mov	r5, r2
  20b134:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b136:	6020      	str	r0, [r4, #0]
  20b138:	6061      	str	r1, [r4, #4]
  20b13a:	60a2      	str	r2, [r4, #8]
  20b13c:	60e3      	str	r3, [r4, #12]
  20b13e:	e11c      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_24:   			strcpy(buffTemp,"font_24"); break;
  20b140:	687b      	ldr	r3, [r7, #4]
  20b142:	493e      	ldr	r1, [pc, #248]	; (20b23c <LCD_FontSize2Str+0x42c>)
  20b144:	461a      	mov	r2, r3
  20b146:	460b      	mov	r3, r1
  20b148:	cb03      	ldmia	r3!, {r0, r1}
  20b14a:	6010      	str	r0, [r2, #0]
  20b14c:	6051      	str	r1, [r2, #4]
  20b14e:	e114      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_24_bold:   	strcpy(buffTemp,"font_24_bold"); break;
  20b150:	687b      	ldr	r3, [r7, #4]
  20b152:	4a3b      	ldr	r2, [pc, #236]	; (20b240 <LCD_FontSize2Str+0x430>)
  20b154:	461c      	mov	r4, r3
  20b156:	4613      	mov	r3, r2
  20b158:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b15a:	6020      	str	r0, [r4, #0]
  20b15c:	6061      	str	r1, [r4, #4]
  20b15e:	60a2      	str	r2, [r4, #8]
  20b160:	781b      	ldrb	r3, [r3, #0]
  20b162:	7323      	strb	r3, [r4, #12]
  20b164:	e109      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_24_italics: 	strcpy(buffTemp,"font_24_italics"); break;
  20b166:	687b      	ldr	r3, [r7, #4]
  20b168:	4a36      	ldr	r2, [pc, #216]	; (20b244 <LCD_FontSize2Str+0x434>)
  20b16a:	461c      	mov	r4, r3
  20b16c:	4615      	mov	r5, r2
  20b16e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b170:	6020      	str	r0, [r4, #0]
  20b172:	6061      	str	r1, [r4, #4]
  20b174:	60a2      	str	r2, [r4, #8]
  20b176:	60e3      	str	r3, [r4, #12]
  20b178:	e0ff      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_26:   			strcpy(buffTemp,"font_26"); break;
  20b17a:	687b      	ldr	r3, [r7, #4]
  20b17c:	4932      	ldr	r1, [pc, #200]	; (20b248 <LCD_FontSize2Str+0x438>)
  20b17e:	461a      	mov	r2, r3
  20b180:	460b      	mov	r3, r1
  20b182:	cb03      	ldmia	r3!, {r0, r1}
  20b184:	6010      	str	r0, [r2, #0]
  20b186:	6051      	str	r1, [r2, #4]
  20b188:	e0f7      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_26_bold:   	strcpy(buffTemp,"font_26_bold"); break;
  20b18a:	687b      	ldr	r3, [r7, #4]
  20b18c:	4a2f      	ldr	r2, [pc, #188]	; (20b24c <LCD_FontSize2Str+0x43c>)
  20b18e:	461c      	mov	r4, r3
  20b190:	4613      	mov	r3, r2
  20b192:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b194:	6020      	str	r0, [r4, #0]
  20b196:	6061      	str	r1, [r4, #4]
  20b198:	60a2      	str	r2, [r4, #8]
  20b19a:	781b      	ldrb	r3, [r3, #0]
  20b19c:	7323      	strb	r3, [r4, #12]
  20b19e:	e0ec      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_26_italics: 	strcpy(buffTemp,"font_26_italics"); break;
  20b1a0:	687b      	ldr	r3, [r7, #4]
  20b1a2:	4a2b      	ldr	r2, [pc, #172]	; (20b250 <LCD_FontSize2Str+0x440>)
  20b1a4:	461c      	mov	r4, r3
  20b1a6:	4615      	mov	r5, r2
  20b1a8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b1aa:	6020      	str	r0, [r4, #0]
  20b1ac:	6061      	str	r1, [r4, #4]
  20b1ae:	60a2      	str	r2, [r4, #8]
  20b1b0:	60e3      	str	r3, [r4, #12]
  20b1b2:	e0e2      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_28:   			strcpy(buffTemp,"font_28"); break;
  20b1b4:	687b      	ldr	r3, [r7, #4]
  20b1b6:	4927      	ldr	r1, [pc, #156]	; (20b254 <LCD_FontSize2Str+0x444>)
  20b1b8:	461a      	mov	r2, r3
  20b1ba:	460b      	mov	r3, r1
  20b1bc:	cb03      	ldmia	r3!, {r0, r1}
  20b1be:	6010      	str	r0, [r2, #0]
  20b1c0:	6051      	str	r1, [r2, #4]
  20b1c2:	e0da      	b.n	20b37a <LCD_FontSize2Str+0x56a>
  20b1c4:	00228540 	.word	0x00228540
  20b1c8:	00228548 	.word	0x00228548
  20b1cc:	00228554 	.word	0x00228554
  20b1d0:	00228564 	.word	0x00228564
  20b1d4:	0022856c 	.word	0x0022856c
  20b1d8:	00228578 	.word	0x00228578
  20b1dc:	00228588 	.word	0x00228588
  20b1e0:	00228590 	.word	0x00228590
  20b1e4:	002285a0 	.word	0x002285a0
  20b1e8:	002285b0 	.word	0x002285b0
  20b1ec:	002285b8 	.word	0x002285b8
  20b1f0:	002285c8 	.word	0x002285c8
  20b1f4:	002285d8 	.word	0x002285d8
  20b1f8:	002285e0 	.word	0x002285e0
  20b1fc:	002285f0 	.word	0x002285f0
  20b200:	00228600 	.word	0x00228600
  20b204:	00228608 	.word	0x00228608
  20b208:	00228618 	.word	0x00228618
  20b20c:	00228628 	.word	0x00228628
  20b210:	00228630 	.word	0x00228630
  20b214:	00228640 	.word	0x00228640
  20b218:	00228650 	.word	0x00228650
  20b21c:	00228658 	.word	0x00228658
  20b220:	00228668 	.word	0x00228668
  20b224:	00228678 	.word	0x00228678
  20b228:	00228680 	.word	0x00228680
  20b22c:	00228690 	.word	0x00228690
  20b230:	002286a0 	.word	0x002286a0
  20b234:	002286a8 	.word	0x002286a8
  20b238:	002286b8 	.word	0x002286b8
  20b23c:	002286c8 	.word	0x002286c8
  20b240:	002286d0 	.word	0x002286d0
  20b244:	002286e0 	.word	0x002286e0
  20b248:	002286f0 	.word	0x002286f0
  20b24c:	002286f8 	.word	0x002286f8
  20b250:	00228708 	.word	0x00228708
  20b254:	00228718 	.word	0x00228718
	case FONT_28_bold:   	strcpy(buffTemp,"font_28_bold"); break;
  20b258:	687b      	ldr	r3, [r7, #4]
  20b25a:	4a4b      	ldr	r2, [pc, #300]	; (20b388 <LCD_FontSize2Str+0x578>)
  20b25c:	461c      	mov	r4, r3
  20b25e:	4613      	mov	r3, r2
  20b260:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b262:	6020      	str	r0, [r4, #0]
  20b264:	6061      	str	r1, [r4, #4]
  20b266:	60a2      	str	r2, [r4, #8]
  20b268:	781b      	ldrb	r3, [r3, #0]
  20b26a:	7323      	strb	r3, [r4, #12]
  20b26c:	e085      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_28_italics: 	strcpy(buffTemp,"font_28_italics"); break;
  20b26e:	687b      	ldr	r3, [r7, #4]
  20b270:	4a46      	ldr	r2, [pc, #280]	; (20b38c <LCD_FontSize2Str+0x57c>)
  20b272:	461c      	mov	r4, r3
  20b274:	4615      	mov	r5, r2
  20b276:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b278:	6020      	str	r0, [r4, #0]
  20b27a:	6061      	str	r1, [r4, #4]
  20b27c:	60a2      	str	r2, [r4, #8]
  20b27e:	60e3      	str	r3, [r4, #12]
  20b280:	e07b      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_36:   			strcpy(buffTemp,"font_36"); break;
  20b282:	687b      	ldr	r3, [r7, #4]
  20b284:	4942      	ldr	r1, [pc, #264]	; (20b390 <LCD_FontSize2Str+0x580>)
  20b286:	461a      	mov	r2, r3
  20b288:	460b      	mov	r3, r1
  20b28a:	cb03      	ldmia	r3!, {r0, r1}
  20b28c:	6010      	str	r0, [r2, #0]
  20b28e:	6051      	str	r1, [r2, #4]
  20b290:	e073      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_36_bold:   	strcpy(buffTemp,"font_36_bold"); break;
  20b292:	687b      	ldr	r3, [r7, #4]
  20b294:	4a3f      	ldr	r2, [pc, #252]	; (20b394 <LCD_FontSize2Str+0x584>)
  20b296:	461c      	mov	r4, r3
  20b298:	4613      	mov	r3, r2
  20b29a:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b29c:	6020      	str	r0, [r4, #0]
  20b29e:	6061      	str	r1, [r4, #4]
  20b2a0:	60a2      	str	r2, [r4, #8]
  20b2a2:	781b      	ldrb	r3, [r3, #0]
  20b2a4:	7323      	strb	r3, [r4, #12]
  20b2a6:	e068      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_36_italics: 	strcpy(buffTemp,"font_36_italics"); break;
  20b2a8:	687b      	ldr	r3, [r7, #4]
  20b2aa:	4a3b      	ldr	r2, [pc, #236]	; (20b398 <LCD_FontSize2Str+0x588>)
  20b2ac:	461c      	mov	r4, r3
  20b2ae:	4615      	mov	r5, r2
  20b2b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b2b2:	6020      	str	r0, [r4, #0]
  20b2b4:	6061      	str	r1, [r4, #4]
  20b2b6:	60a2      	str	r2, [r4, #8]
  20b2b8:	60e3      	str	r3, [r4, #12]
  20b2ba:	e05e      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_48:   			strcpy(buffTemp,"font_48"); break;
  20b2bc:	687b      	ldr	r3, [r7, #4]
  20b2be:	4937      	ldr	r1, [pc, #220]	; (20b39c <LCD_FontSize2Str+0x58c>)
  20b2c0:	461a      	mov	r2, r3
  20b2c2:	460b      	mov	r3, r1
  20b2c4:	cb03      	ldmia	r3!, {r0, r1}
  20b2c6:	6010      	str	r0, [r2, #0]
  20b2c8:	6051      	str	r1, [r2, #4]
  20b2ca:	e056      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_48_bold:   	strcpy(buffTemp,"font_48_bold"); break;
  20b2cc:	687b      	ldr	r3, [r7, #4]
  20b2ce:	4a34      	ldr	r2, [pc, #208]	; (20b3a0 <LCD_FontSize2Str+0x590>)
  20b2d0:	461c      	mov	r4, r3
  20b2d2:	4613      	mov	r3, r2
  20b2d4:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b2d6:	6020      	str	r0, [r4, #0]
  20b2d8:	6061      	str	r1, [r4, #4]
  20b2da:	60a2      	str	r2, [r4, #8]
  20b2dc:	781b      	ldrb	r3, [r3, #0]
  20b2de:	7323      	strb	r3, [r4, #12]
  20b2e0:	e04b      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_48_italics: 	strcpy(buffTemp,"font_48_italics"); break;
  20b2e2:	687b      	ldr	r3, [r7, #4]
  20b2e4:	4a2f      	ldr	r2, [pc, #188]	; (20b3a4 <LCD_FontSize2Str+0x594>)
  20b2e6:	461c      	mov	r4, r3
  20b2e8:	4615      	mov	r5, r2
  20b2ea:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b2ec:	6020      	str	r0, [r4, #0]
  20b2ee:	6061      	str	r1, [r4, #4]
  20b2f0:	60a2      	str	r2, [r4, #8]
  20b2f2:	60e3      	str	r3, [r4, #12]
  20b2f4:	e041      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_72:   			strcpy(buffTemp,"font_72"); break;
  20b2f6:	687b      	ldr	r3, [r7, #4]
  20b2f8:	492b      	ldr	r1, [pc, #172]	; (20b3a8 <LCD_FontSize2Str+0x598>)
  20b2fa:	461a      	mov	r2, r3
  20b2fc:	460b      	mov	r3, r1
  20b2fe:	cb03      	ldmia	r3!, {r0, r1}
  20b300:	6010      	str	r0, [r2, #0]
  20b302:	6051      	str	r1, [r2, #4]
  20b304:	e039      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_72_bold:   	strcpy(buffTemp,"font_72_bold "); break;
  20b306:	687b      	ldr	r3, [r7, #4]
  20b308:	4a28      	ldr	r2, [pc, #160]	; (20b3ac <LCD_FontSize2Str+0x59c>)
  20b30a:	461c      	mov	r4, r3
  20b30c:	4613      	mov	r3, r2
  20b30e:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b310:	6020      	str	r0, [r4, #0]
  20b312:	6061      	str	r1, [r4, #4]
  20b314:	60a2      	str	r2, [r4, #8]
  20b316:	881b      	ldrh	r3, [r3, #0]
  20b318:	81a3      	strh	r3, [r4, #12]
  20b31a:	e02e      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_72_italics: 	strcpy(buffTemp,"font_72_italics"); break;
  20b31c:	687b      	ldr	r3, [r7, #4]
  20b31e:	4a24      	ldr	r2, [pc, #144]	; (20b3b0 <LCD_FontSize2Str+0x5a0>)
  20b320:	461c      	mov	r4, r3
  20b322:	4615      	mov	r5, r2
  20b324:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b326:	6020      	str	r0, [r4, #0]
  20b328:	6061      	str	r1, [r4, #4]
  20b32a:	60a2      	str	r2, [r4, #8]
  20b32c:	60e3      	str	r3, [r4, #12]
  20b32e:	e024      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_130:   			strcpy(buffTemp,"font_130"); break;
  20b330:	687b      	ldr	r3, [r7, #4]
  20b332:	4920      	ldr	r1, [pc, #128]	; (20b3b4 <LCD_FontSize2Str+0x5a4>)
  20b334:	461a      	mov	r2, r3
  20b336:	460b      	mov	r3, r1
  20b338:	cb03      	ldmia	r3!, {r0, r1}
  20b33a:	6010      	str	r0, [r2, #0]
  20b33c:	6051      	str	r1, [r2, #4]
  20b33e:	781b      	ldrb	r3, [r3, #0]
  20b340:	7213      	strb	r3, [r2, #8]
  20b342:	e01a      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_130_bold:   	strcpy(buffTemp,"font_130_bold"); break;
  20b344:	687b      	ldr	r3, [r7, #4]
  20b346:	4a1c      	ldr	r2, [pc, #112]	; (20b3b8 <LCD_FontSize2Str+0x5a8>)
  20b348:	461c      	mov	r4, r3
  20b34a:	4613      	mov	r3, r2
  20b34c:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b34e:	6020      	str	r0, [r4, #0]
  20b350:	6061      	str	r1, [r4, #4]
  20b352:	60a2      	str	r2, [r4, #8]
  20b354:	881b      	ldrh	r3, [r3, #0]
  20b356:	81a3      	strh	r3, [r4, #12]
  20b358:	e00f      	b.n	20b37a <LCD_FontSize2Str+0x56a>
	case FONT_130_italics: 	strcpy(buffTemp,"font_130_italics"); break;
  20b35a:	687b      	ldr	r3, [r7, #4]
  20b35c:	4a17      	ldr	r2, [pc, #92]	; (20b3bc <LCD_FontSize2Str+0x5ac>)
  20b35e:	461d      	mov	r5, r3
  20b360:	4614      	mov	r4, r2
  20b362:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b364:	6028      	str	r0, [r5, #0]
  20b366:	6069      	str	r1, [r5, #4]
  20b368:	60aa      	str	r2, [r5, #8]
  20b36a:	60eb      	str	r3, [r5, #12]
  20b36c:	7823      	ldrb	r3, [r4, #0]
  20b36e:	742b      	strb	r3, [r5, #16]
  20b370:	e003      	b.n	20b37a <LCD_FontSize2Str+0x56a>

	default:	buffTemp[0]=0; break;
  20b372:	687b      	ldr	r3, [r7, #4]
  20b374:	2200      	movs	r2, #0
  20b376:	701a      	strb	r2, [r3, #0]
  20b378:	bf00      	nop
	}
	return buffTemp;
  20b37a:	687b      	ldr	r3, [r7, #4]
}
  20b37c:	4618      	mov	r0, r3
  20b37e:	370c      	adds	r7, #12
  20b380:	46bd      	mov	sp, r7
  20b382:	bcb0      	pop	{r4, r5, r7}
  20b384:	4770      	bx	lr
  20b386:	bf00      	nop
  20b388:	00228720 	.word	0x00228720
  20b38c:	00228730 	.word	0x00228730
  20b390:	00228740 	.word	0x00228740
  20b394:	00228748 	.word	0x00228748
  20b398:	00228758 	.word	0x00228758
  20b39c:	00228768 	.word	0x00228768
  20b3a0:	00228770 	.word	0x00228770
  20b3a4:	00228780 	.word	0x00228780
  20b3a8:	00228790 	.word	0x00228790
  20b3ac:	00228798 	.word	0x00228798
  20b3b0:	002287a8 	.word	0x002287a8
  20b3b4:	002287b8 	.word	0x002287b8
  20b3b8:	002287c4 	.word	0x002287c4
  20b3bc:	002287d4 	.word	0x002287d4

0020b3c0 <LCD_FontStyle2Str>:

char *LCD_FontStyle2Str(char *buffTemp, int fontStyle)
{
  20b3c0:	b4b0      	push	{r4, r5, r7}
  20b3c2:	b083      	sub	sp, #12
  20b3c4:	af00      	add	r7, sp, #0
  20b3c6:	6078      	str	r0, [r7, #4]
  20b3c8:	6039      	str	r1, [r7, #0]
	switch(fontStyle)
  20b3ca:	683b      	ldr	r3, [r7, #0]
  20b3cc:	2b04      	cmp	r3, #4
  20b3ce:	d00b      	beq.n	20b3e8 <LCD_FontStyle2Str+0x28>
  20b3d0:	2b05      	cmp	r3, #5
  20b3d2:	d002      	beq.n	20b3da <LCD_FontStyle2Str+0x1a>
  20b3d4:	2b03      	cmp	r3, #3
  20b3d6:	d011      	beq.n	20b3fc <LCD_FontStyle2Str+0x3c>
  20b3d8:	e01d      	b.n	20b416 <LCD_FontStyle2Str+0x56>
	{
	case Arial:   			  strcpy(buffTemp,"Arial"); break;
  20b3da:	687b      	ldr	r3, [r7, #4]
  20b3dc:	4a13      	ldr	r2, [pc, #76]	; (20b42c <LCD_FontStyle2Str+0x6c>)
  20b3de:	6810      	ldr	r0, [r2, #0]
  20b3e0:	6018      	str	r0, [r3, #0]
  20b3e2:	8892      	ldrh	r2, [r2, #4]
  20b3e4:	809a      	strh	r2, [r3, #4]
  20b3e6:	e01a      	b.n	20b41e <LCD_FontStyle2Str+0x5e>
	case Times_New_Roman:  strcpy(buffTemp,"Times_New_Roman"); break;
  20b3e8:	687b      	ldr	r3, [r7, #4]
  20b3ea:	4a11      	ldr	r2, [pc, #68]	; (20b430 <LCD_FontStyle2Str+0x70>)
  20b3ec:	461c      	mov	r4, r3
  20b3ee:	4615      	mov	r5, r2
  20b3f0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b3f2:	6020      	str	r0, [r4, #0]
  20b3f4:	6061      	str	r1, [r4, #4]
  20b3f6:	60a2      	str	r2, [r4, #8]
  20b3f8:	60e3      	str	r3, [r4, #12]
  20b3fa:	e010      	b.n	20b41e <LCD_FontStyle2Str+0x5e>
	case Comic_Saens_MS:   strcpy(buffTemp,"Comic_Saens_MS"); break;
  20b3fc:	687b      	ldr	r3, [r7, #4]
  20b3fe:	4a0d      	ldr	r2, [pc, #52]	; (20b434 <LCD_FontStyle2Str+0x74>)
  20b400:	461c      	mov	r4, r3
  20b402:	4613      	mov	r3, r2
  20b404:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b406:	6020      	str	r0, [r4, #0]
  20b408:	6061      	str	r1, [r4, #4]
  20b40a:	60a2      	str	r2, [r4, #8]
  20b40c:	881a      	ldrh	r2, [r3, #0]
  20b40e:	789b      	ldrb	r3, [r3, #2]
  20b410:	81a2      	strh	r2, [r4, #12]
  20b412:	73a3      	strb	r3, [r4, #14]
  20b414:	e003      	b.n	20b41e <LCD_FontStyle2Str+0x5e>

	default:	buffTemp[0]=0;	break;
  20b416:	687b      	ldr	r3, [r7, #4]
  20b418:	2200      	movs	r2, #0
  20b41a:	701a      	strb	r2, [r3, #0]
  20b41c:	bf00      	nop
	}
	return buffTemp;
  20b41e:	687b      	ldr	r3, [r7, #4]
}
  20b420:	4618      	mov	r0, r3
  20b422:	370c      	adds	r7, #12
  20b424:	46bd      	mov	sp, r7
  20b426:	bcb0      	pop	{r4, r5, r7}
  20b428:	4770      	bx	lr
  20b42a:	bf00      	nop
  20b42c:	002287e8 	.word	0x002287e8
  20b430:	002287f0 	.word	0x002287f0
  20b434:	00228800 	.word	0x00228800

0020b438 <DisplayFontsStructState>:

void DisplayFontsStructState(void){
  20b438:	b5b0      	push	{r4, r5, r7, lr}
  20b43a:	b092      	sub	sp, #72	; 0x48
  20b43c:	af04      	add	r7, sp, #16
	char bufTemp[50];
	DbgVar(1,250,"\r\nADDRESS:0x%x  FONTS_MEMORY_SIZE:0x%x  Counter:0x%06x\r\n",fontsImagesMemoryBuffer, MAX_FONTS_AND_IMAGES_MEMORY_SIZE, CounterBusyBytesForFontsImages);
  20b43e:	4b32      	ldr	r3, [pc, #200]	; (20b508 <DisplayFontsStructState+0xd0>)
  20b440:	681b      	ldr	r3, [r3, #0]
  20b442:	9301      	str	r3, [sp, #4]
  20b444:	f44f 03c0 	mov.w	r3, #6291456	; 0x600000
  20b448:	9300      	str	r3, [sp, #0]
  20b44a:	4b30      	ldr	r3, [pc, #192]	; (20b50c <DisplayFontsStructState+0xd4>)
  20b44c:	4a30      	ldr	r2, [pc, #192]	; (20b510 <DisplayFontsStructState+0xd8>)
  20b44e:	21fa      	movs	r1, #250	; 0xfa
  20b450:	2001      	movs	r0, #1
  20b452:	f7f5 fa3a 	bl	2008ca <DbgVar>
	for(int i=0; i < MAX_OPEN_FONTS_SIMULTANEOUSLY; i++){
  20b456:	2300      	movs	r3, #0
  20b458:	637b      	str	r3, [r7, #52]	; 0x34
  20b45a:	e04d      	b.n	20b4f8 <DisplayFontsStructState+0xc0>
		if(Font[i].fontSizeToIndex)
  20b45c:	492d      	ldr	r1, [pc, #180]	; (20b514 <DisplayFontsStructState+0xdc>)
  20b45e:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20b460:	4613      	mov	r3, r2
  20b462:	019b      	lsls	r3, r3, #6
  20b464:	4413      	add	r3, r2
  20b466:	015b      	lsls	r3, r3, #5
  20b468:	440b      	add	r3, r1
  20b46a:	681b      	ldr	r3, [r3, #0]
  20b46c:	2b00      	cmp	r3, #0
  20b46e:	d040      	beq.n	20b4f2 <DisplayFontsStructState+0xba>
			DbgVar(1,250,"Idx:%d  %s  %s  FontAddr:0x%06x  fontSdramLenght:%d\r\n",i, LCD_FontStyle2Str(bufTemp,Font[i].fontStyleToIndex), LCD_FontSize2Str(bufTemp+20,Font[i].fontSizeToIndex-1), Font[i].pointerToMemoryFont-fontsImagesMemoryBuffer, Font[i].fontSdramLenght);
  20b470:	4928      	ldr	r1, [pc, #160]	; (20b514 <DisplayFontsStructState+0xdc>)
  20b472:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20b474:	4613      	mov	r3, r2
  20b476:	019b      	lsls	r3, r3, #6
  20b478:	4413      	add	r3, r2
  20b47a:	015b      	lsls	r3, r3, #5
  20b47c:	440b      	add	r3, r1
  20b47e:	3304      	adds	r3, #4
  20b480:	681b      	ldr	r3, [r3, #0]
  20b482:	461a      	mov	r2, r3
  20b484:	463b      	mov	r3, r7
  20b486:	4611      	mov	r1, r2
  20b488:	4618      	mov	r0, r3
  20b48a:	f7ff ff99 	bl	20b3c0 <LCD_FontStyle2Str>
  20b48e:	4604      	mov	r4, r0
  20b490:	463a      	mov	r2, r7
  20b492:	3214      	adds	r2, #20
  20b494:	481f      	ldr	r0, [pc, #124]	; (20b514 <DisplayFontsStructState+0xdc>)
  20b496:	6b79      	ldr	r1, [r7, #52]	; 0x34
  20b498:	460b      	mov	r3, r1
  20b49a:	019b      	lsls	r3, r3, #6
  20b49c:	440b      	add	r3, r1
  20b49e:	015b      	lsls	r3, r3, #5
  20b4a0:	4403      	add	r3, r0
  20b4a2:	681b      	ldr	r3, [r3, #0]
  20b4a4:	3b01      	subs	r3, #1
  20b4a6:	4619      	mov	r1, r3
  20b4a8:	4610      	mov	r0, r2
  20b4aa:	f7ff fcb1 	bl	20ae10 <LCD_FontSize2Str>
  20b4ae:	4605      	mov	r5, r0
  20b4b0:	4918      	ldr	r1, [pc, #96]	; (20b514 <DisplayFontsStructState+0xdc>)
  20b4b2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20b4b4:	4613      	mov	r3, r2
  20b4b6:	019b      	lsls	r3, r3, #6
  20b4b8:	4413      	add	r3, r2
  20b4ba:	015b      	lsls	r3, r3, #5
  20b4bc:	440b      	add	r3, r1
  20b4be:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20b4c2:	681b      	ldr	r3, [r3, #0]
  20b4c4:	461a      	mov	r2, r3
  20b4c6:	4b11      	ldr	r3, [pc, #68]	; (20b50c <DisplayFontsStructState+0xd4>)
  20b4c8:	1ad1      	subs	r1, r2, r3
  20b4ca:	4812      	ldr	r0, [pc, #72]	; (20b514 <DisplayFontsStructState+0xdc>)
  20b4cc:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20b4ce:	4613      	mov	r3, r2
  20b4d0:	019b      	lsls	r3, r3, #6
  20b4d2:	4413      	add	r3, r2
  20b4d4:	015b      	lsls	r3, r3, #5
  20b4d6:	4403      	add	r3, r0
  20b4d8:	f603 031c 	addw	r3, r3, #2076	; 0x81c
  20b4dc:	681b      	ldr	r3, [r3, #0]
  20b4de:	9303      	str	r3, [sp, #12]
  20b4e0:	9102      	str	r1, [sp, #8]
  20b4e2:	9501      	str	r5, [sp, #4]
  20b4e4:	9400      	str	r4, [sp, #0]
  20b4e6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20b4e8:	4a0b      	ldr	r2, [pc, #44]	; (20b518 <DisplayFontsStructState+0xe0>)
  20b4ea:	21fa      	movs	r1, #250	; 0xfa
  20b4ec:	2001      	movs	r0, #1
  20b4ee:	f7f5 f9ec 	bl	2008ca <DbgVar>
	for(int i=0; i < MAX_OPEN_FONTS_SIMULTANEOUSLY; i++){
  20b4f2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20b4f4:	3301      	adds	r3, #1
  20b4f6:	637b      	str	r3, [r7, #52]	; 0x34
  20b4f8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20b4fa:	2b10      	cmp	r3, #16
  20b4fc:	ddae      	ble.n	20b45c <DisplayFontsStructState+0x24>
	}
}
  20b4fe:	bf00      	nop
  20b500:	3738      	adds	r7, #56	; 0x38
  20b502:	46bd      	mov	sp, r7
  20b504:	bdb0      	pop	{r4, r5, r7, pc}
  20b506:	bf00      	nop
  20b508:	20010370 	.word	0x20010370
  20b50c:	c007f800 	.word	0xc007f800
  20b510:	00228810 	.word	0x00228810
  20b514:	20003590 	.word	0x20003590
  20b518:	0022884c 	.word	0x0022884c

0020b51c <LCD_LoadFont>:
void InfoForImagesFonts(void){
	DbgVar(1,250,"\r\nImages SDRAM size: 0x%08x\r\nCounterBusyBytesForFontsImages: 0x%08x\r\nStruct size Font+Image: %d+%d=%d  ",MAX_FONTS_AND_IMAGES_MEMORY_SIZE,CounterBusyBytesForFontsImages,sizeof(Font),sizeof(Image), sizeof(Font)+sizeof(Image));
}

int LCD_LoadFont(int fontSize, int fontStyle, uint32_t backgroundColor, uint32_t fontColor, uint32_t fontID)
{
  20b51c:	b5b0      	push	{r4, r5, r7, lr}
  20b51e:	b0a0      	sub	sp, #128	; 0x80
  20b520:	af00      	add	r7, sp, #0
  20b522:	60f8      	str	r0, [r7, #12]
  20b524:	60b9      	str	r1, [r7, #8]
  20b526:	607a      	str	r2, [r7, #4]
  20b528:	603b      	str	r3, [r7, #0]
	int resultSearch;
	uint32_t fontFileSize;

	resultSearch=SearchFontIndex(fontSize,fontStyle,backgroundColor,fontColor);
  20b52a:	683b      	ldr	r3, [r7, #0]
  20b52c:	687a      	ldr	r2, [r7, #4]
  20b52e:	68b9      	ldr	r1, [r7, #8]
  20b530:	68f8      	ldr	r0, [r7, #12]
  20b532:	f7fd f9a7 	bl	208884 <SearchFontIndex>
  20b536:	67f8      	str	r0, [r7, #124]	; 0x7c
	if(-1!=resultSearch)
  20b538:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20b53a:	f1b3 3fff 	cmp.w	r3, #4294967295
  20b53e:	d008      	beq.n	20b552 <LCD_LoadFont+0x36>
		return LCD_GetFontID(fontSize,fontStyle,backgroundColor,fontColor);
  20b540:	683b      	ldr	r3, [r7, #0]
  20b542:	687a      	ldr	r2, [r7, #4]
  20b544:	68b9      	ldr	r1, [r7, #8]
  20b546:	68f8      	ldr	r0, [r7, #12]
  20b548:	f7fd fa1a 	bl	208980 <LCD_GetFontID>
  20b54c:	4603      	mov	r3, r0
  20b54e:	f000 bf13 	b.w	20c378 <LCD_LoadFont+0xe5c>

	int fontIndex=LoadFontIndex(fontSize,fontStyle,backgroundColor,fontColor);
  20b552:	683b      	ldr	r3, [r7, #0]
  20b554:	687a      	ldr	r2, [r7, #4]
  20b556:	68b9      	ldr	r1, [r7, #8]
  20b558:	68f8      	ldr	r0, [r7, #12]
  20b55a:	f7fd f943 	bl	2087e4 <LoadFontIndex>
  20b55e:	67b8      	str	r0, [r7, #120]	; 0x78
	if(-1==fontIndex)
  20b560:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  20b562:	f1b3 3fff 	cmp.w	r3, #4294967295
  20b566:	d103      	bne.n	20b570 <LCD_LoadFont+0x54>
		return -2;
  20b568:	f06f 0301 	mvn.w	r3, #1
  20b56c:	f000 bf04 	b.w	20c378 <LCD_LoadFont+0xe5c>
	char fileOpenName[100]="Fonts/";
  20b570:	4ac0      	ldr	r2, [pc, #768]	; (20b874 <LCD_LoadFont+0x358>)
  20b572:	f107 0310 	add.w	r3, r7, #16
  20b576:	e892 0003 	ldmia.w	r2, {r0, r1}
  20b57a:	6018      	str	r0, [r3, #0]
  20b57c:	3304      	adds	r3, #4
  20b57e:	8019      	strh	r1, [r3, #0]
  20b580:	3302      	adds	r3, #2
  20b582:	0c0a      	lsrs	r2, r1, #16
  20b584:	701a      	strb	r2, [r3, #0]
  20b586:	f107 0317 	add.w	r3, r7, #23
  20b58a:	225d      	movs	r2, #93	; 0x5d
  20b58c:	2100      	movs	r1, #0
  20b58e:	4618      	mov	r0, r3
  20b590:	f01a ffcf 	bl	226532 <memset>

	switch(backgroundColor)
  20b594:	687b      	ldr	r3, [r7, #4]
  20b596:	4ab8      	ldr	r2, [pc, #736]	; (20b878 <LCD_LoadFont+0x35c>)
  20b598:	4293      	cmp	r3, r2
  20b59a:	d00d      	beq.n	20b5b8 <LCD_LoadFont+0x9c>
  20b59c:	4ab6      	ldr	r2, [pc, #728]	; (20b878 <LCD_LoadFont+0x35c>)
  20b59e:	4293      	cmp	r3, r2
  20b5a0:	d803      	bhi.n	20b5aa <LCD_LoadFont+0x8e>
  20b5a2:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
  20b5a6:	d01e      	beq.n	20b5e6 <LCD_LoadFont+0xca>
		break;
	case WHITE:
		strncat(fileOpenName,"BackGround_white/",17);
		break;
	default:
		break;
  20b5a8:	e05c      	b.n	20b664 <LCD_LoadFont+0x148>
	switch(backgroundColor)
  20b5aa:	4ab4      	ldr	r2, [pc, #720]	; (20b87c <LCD_LoadFont+0x360>)
  20b5ac:	4293      	cmp	r3, r2
  20b5ae:	d02f      	beq.n	20b610 <LCD_LoadFont+0xf4>
  20b5b0:	f1b3 3fff 	cmp.w	r3, #4294967295
  20b5b4:	d041      	beq.n	20b63a <LCD_LoadFont+0x11e>
		break;
  20b5b6:	e055      	b.n	20b664 <LCD_LoadFont+0x148>
		strncat(fileOpenName,"BackGround_darkGray/",20);
  20b5b8:	f107 0310 	add.w	r3, r7, #16
  20b5bc:	4618      	mov	r0, r3
  20b5be:	f7f4 fe3f 	bl	200240 <strlen>
  20b5c2:	4603      	mov	r3, r0
  20b5c4:	461a      	mov	r2, r3
  20b5c6:	f107 0310 	add.w	r3, r7, #16
  20b5ca:	4413      	add	r3, r2
  20b5cc:	4aac      	ldr	r2, [pc, #688]	; (20b880 <LCD_LoadFont+0x364>)
  20b5ce:	461d      	mov	r5, r3
  20b5d0:	4614      	mov	r4, r2
  20b5d2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b5d4:	6028      	str	r0, [r5, #0]
  20b5d6:	6069      	str	r1, [r5, #4]
  20b5d8:	60aa      	str	r2, [r5, #8]
  20b5da:	60eb      	str	r3, [r5, #12]
  20b5dc:	6820      	ldr	r0, [r4, #0]
  20b5de:	6128      	str	r0, [r5, #16]
  20b5e0:	7923      	ldrb	r3, [r4, #4]
  20b5e2:	752b      	strb	r3, [r5, #20]
		break;
  20b5e4:	e03e      	b.n	20b664 <LCD_LoadFont+0x148>
		strncat(fileOpenName,"BackGround_black/",17);
  20b5e6:	f107 0310 	add.w	r3, r7, #16
  20b5ea:	4618      	mov	r0, r3
  20b5ec:	f7f4 fe28 	bl	200240 <strlen>
  20b5f0:	4603      	mov	r3, r0
  20b5f2:	461a      	mov	r2, r3
  20b5f4:	f107 0310 	add.w	r3, r7, #16
  20b5f8:	4413      	add	r3, r2
  20b5fa:	4aa2      	ldr	r2, [pc, #648]	; (20b884 <LCD_LoadFont+0x368>)
  20b5fc:	461d      	mov	r5, r3
  20b5fe:	4614      	mov	r4, r2
  20b600:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b602:	6028      	str	r0, [r5, #0]
  20b604:	6069      	str	r1, [r5, #4]
  20b606:	60aa      	str	r2, [r5, #8]
  20b608:	60eb      	str	r3, [r5, #12]
  20b60a:	8823      	ldrh	r3, [r4, #0]
  20b60c:	822b      	strh	r3, [r5, #16]
		break;
  20b60e:	e029      	b.n	20b664 <LCD_LoadFont+0x148>
		strncat(fileOpenName,"BackGround_brown/",17);
  20b610:	f107 0310 	add.w	r3, r7, #16
  20b614:	4618      	mov	r0, r3
  20b616:	f7f4 fe13 	bl	200240 <strlen>
  20b61a:	4603      	mov	r3, r0
  20b61c:	461a      	mov	r2, r3
  20b61e:	f107 0310 	add.w	r3, r7, #16
  20b622:	4413      	add	r3, r2
  20b624:	4a98      	ldr	r2, [pc, #608]	; (20b888 <LCD_LoadFont+0x36c>)
  20b626:	461d      	mov	r5, r3
  20b628:	4614      	mov	r4, r2
  20b62a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b62c:	6028      	str	r0, [r5, #0]
  20b62e:	6069      	str	r1, [r5, #4]
  20b630:	60aa      	str	r2, [r5, #8]
  20b632:	60eb      	str	r3, [r5, #12]
  20b634:	8823      	ldrh	r3, [r4, #0]
  20b636:	822b      	strh	r3, [r5, #16]
		break;
  20b638:	e014      	b.n	20b664 <LCD_LoadFont+0x148>
		strncat(fileOpenName,"BackGround_white/",17);
  20b63a:	f107 0310 	add.w	r3, r7, #16
  20b63e:	4618      	mov	r0, r3
  20b640:	f7f4 fdfe 	bl	200240 <strlen>
  20b644:	4603      	mov	r3, r0
  20b646:	461a      	mov	r2, r3
  20b648:	f107 0310 	add.w	r3, r7, #16
  20b64c:	4413      	add	r3, r2
  20b64e:	4a8f      	ldr	r2, [pc, #572]	; (20b88c <LCD_LoadFont+0x370>)
  20b650:	461d      	mov	r5, r3
  20b652:	4614      	mov	r4, r2
  20b654:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b656:	6028      	str	r0, [r5, #0]
  20b658:	6069      	str	r1, [r5, #4]
  20b65a:	60aa      	str	r2, [r5, #8]
  20b65c:	60eb      	str	r3, [r5, #12]
  20b65e:	8823      	ldrh	r3, [r4, #0]
  20b660:	822b      	strh	r3, [r5, #16]
		break;
  20b662:	bf00      	nop
	}

	switch(fontColor)
  20b664:	683b      	ldr	r3, [r7, #0]
  20b666:	f06f 12af 	mvn.w	r2, #11468975	; 0xaf00af
  20b66a:	4293      	cmp	r3, r2
  20b66c:	d04b      	beq.n	20b706 <LCD_LoadFont+0x1ea>
  20b66e:	f113 1faf 	cmn.w	r3, #11468975	; 0xaf00af
  20b672:	d206      	bcs.n	20b682 <LCD_LoadFont+0x166>
  20b674:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
  20b678:	d059      	beq.n	20b72e <LCD_LoadFont+0x212>
  20b67a:	4a85      	ldr	r2, [pc, #532]	; (20b890 <LCD_LoadFont+0x374>)
  20b67c:	4293      	cmp	r3, r2
  20b67e:	d01b      	beq.n	20b6b8 <LCD_LoadFont+0x19c>
		break;
	case BLACK:
		strncat(fileOpenName,"Color_black/",12);
		break;
	default:
		break;
  20b680:	e069      	b.n	20b756 <LCD_LoadFont+0x23a>
	switch(fontColor)
  20b682:	4a84      	ldr	r2, [pc, #528]	; (20b894 <LCD_LoadFont+0x378>)
  20b684:	4293      	cmp	r3, r2
  20b686:	d029      	beq.n	20b6dc <LCD_LoadFont+0x1c0>
  20b688:	f1b3 3fff 	cmp.w	r3, #4294967295
  20b68c:	d000      	beq.n	20b690 <LCD_LoadFont+0x174>
		break;
  20b68e:	e062      	b.n	20b756 <LCD_LoadFont+0x23a>
		strncat(fileOpenName,"Color_white/",12);
  20b690:	f107 0310 	add.w	r3, r7, #16
  20b694:	4618      	mov	r0, r3
  20b696:	f7f4 fdd3 	bl	200240 <strlen>
  20b69a:	4603      	mov	r3, r0
  20b69c:	461a      	mov	r2, r3
  20b69e:	f107 0310 	add.w	r3, r7, #16
  20b6a2:	4413      	add	r3, r2
  20b6a4:	4a7c      	ldr	r2, [pc, #496]	; (20b898 <LCD_LoadFont+0x37c>)
  20b6a6:	461c      	mov	r4, r3
  20b6a8:	4613      	mov	r3, r2
  20b6aa:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b6ac:	6020      	str	r0, [r4, #0]
  20b6ae:	6061      	str	r1, [r4, #4]
  20b6b0:	60a2      	str	r2, [r4, #8]
  20b6b2:	781b      	ldrb	r3, [r3, #0]
  20b6b4:	7323      	strb	r3, [r4, #12]
		break;
  20b6b6:	e04e      	b.n	20b756 <LCD_LoadFont+0x23a>
		strncat(fileOpenName,"Color_blue/",11);
  20b6b8:	f107 0310 	add.w	r3, r7, #16
  20b6bc:	4618      	mov	r0, r3
  20b6be:	f7f4 fdbf 	bl	200240 <strlen>
  20b6c2:	4603      	mov	r3, r0
  20b6c4:	461a      	mov	r2, r3
  20b6c6:	f107 0310 	add.w	r3, r7, #16
  20b6ca:	4413      	add	r3, r2
  20b6cc:	4a73      	ldr	r2, [pc, #460]	; (20b89c <LCD_LoadFont+0x380>)
  20b6ce:	461c      	mov	r4, r3
  20b6d0:	4613      	mov	r3, r2
  20b6d2:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b6d4:	6020      	str	r0, [r4, #0]
  20b6d6:	6061      	str	r1, [r4, #4]
  20b6d8:	60a2      	str	r2, [r4, #8]
		break;
  20b6da:	e03c      	b.n	20b756 <LCD_LoadFont+0x23a>
		strncat(fileOpenName,"Color_red/",10);
  20b6dc:	f107 0310 	add.w	r3, r7, #16
  20b6e0:	4618      	mov	r0, r3
  20b6e2:	f7f4 fdad 	bl	200240 <strlen>
  20b6e6:	4603      	mov	r3, r0
  20b6e8:	461a      	mov	r2, r3
  20b6ea:	f107 0310 	add.w	r3, r7, #16
  20b6ee:	4413      	add	r3, r2
  20b6f0:	496b      	ldr	r1, [pc, #428]	; (20b8a0 <LCD_LoadFont+0x384>)
  20b6f2:	461a      	mov	r2, r3
  20b6f4:	460b      	mov	r3, r1
  20b6f6:	cb03      	ldmia	r3!, {r0, r1}
  20b6f8:	6010      	str	r0, [r2, #0]
  20b6fa:	6051      	str	r1, [r2, #4]
  20b6fc:	8819      	ldrh	r1, [r3, #0]
  20b6fe:	789b      	ldrb	r3, [r3, #2]
  20b700:	8111      	strh	r1, [r2, #8]
  20b702:	7293      	strb	r3, [r2, #10]
		break;
  20b704:	e027      	b.n	20b756 <LCD_LoadFont+0x23a>
		strncat(fileOpenName,"Color_green/",12);
  20b706:	f107 0310 	add.w	r3, r7, #16
  20b70a:	4618      	mov	r0, r3
  20b70c:	f7f4 fd98 	bl	200240 <strlen>
  20b710:	4603      	mov	r3, r0
  20b712:	461a      	mov	r2, r3
  20b714:	f107 0310 	add.w	r3, r7, #16
  20b718:	4413      	add	r3, r2
  20b71a:	4a62      	ldr	r2, [pc, #392]	; (20b8a4 <LCD_LoadFont+0x388>)
  20b71c:	461c      	mov	r4, r3
  20b71e:	4613      	mov	r3, r2
  20b720:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b722:	6020      	str	r0, [r4, #0]
  20b724:	6061      	str	r1, [r4, #4]
  20b726:	60a2      	str	r2, [r4, #8]
  20b728:	781b      	ldrb	r3, [r3, #0]
  20b72a:	7323      	strb	r3, [r4, #12]
		break;
  20b72c:	e013      	b.n	20b756 <LCD_LoadFont+0x23a>
		strncat(fileOpenName,"Color_black/",12);
  20b72e:	f107 0310 	add.w	r3, r7, #16
  20b732:	4618      	mov	r0, r3
  20b734:	f7f4 fd84 	bl	200240 <strlen>
  20b738:	4603      	mov	r3, r0
  20b73a:	461a      	mov	r2, r3
  20b73c:	f107 0310 	add.w	r3, r7, #16
  20b740:	4413      	add	r3, r2
  20b742:	4a59      	ldr	r2, [pc, #356]	; (20b8a8 <LCD_LoadFont+0x38c>)
  20b744:	461c      	mov	r4, r3
  20b746:	4613      	mov	r3, r2
  20b748:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b74a:	6020      	str	r0, [r4, #0]
  20b74c:	6061      	str	r1, [r4, #4]
  20b74e:	60a2      	str	r2, [r4, #8]
  20b750:	781b      	ldrb	r3, [r3, #0]
  20b752:	7323      	strb	r3, [r4, #12]
		break;
  20b754:	bf00      	nop
	}

	switch(fontStyle)
  20b756:	68bb      	ldr	r3, [r7, #8]
  20b758:	2b05      	cmp	r3, #5
  20b75a:	f200 80b3 	bhi.w	20b8c4 <LCD_LoadFont+0x3a8>
  20b75e:	a201      	add	r2, pc, #4	; (adr r2, 20b764 <LCD_LoadFont+0x248>)
  20b760:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  20b764:	0020b77d 	.word	0x0020b77d
  20b768:	0020b7a5 	.word	0x0020b7a5
  20b76c:	0020b7d1 	.word	0x0020b7d1
  20b770:	0020b7ff 	.word	0x0020b7ff
  20b774:	0020b825 	.word	0x0020b825
  20b778:	0020b84f 	.word	0x0020b84f
	{
	case Arial_Narrow:
		strncat(fileOpenName,"Arial_Narrow/",13);
  20b77c:	f107 0310 	add.w	r3, r7, #16
  20b780:	4618      	mov	r0, r3
  20b782:	f7f4 fd5d 	bl	200240 <strlen>
  20b786:	4603      	mov	r3, r0
  20b788:	461a      	mov	r2, r3
  20b78a:	f107 0310 	add.w	r3, r7, #16
  20b78e:	4413      	add	r3, r2
  20b790:	4a46      	ldr	r2, [pc, #280]	; (20b8ac <LCD_LoadFont+0x390>)
  20b792:	461c      	mov	r4, r3
  20b794:	4613      	mov	r3, r2
  20b796:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b798:	6020      	str	r0, [r4, #0]
  20b79a:	6061      	str	r1, [r4, #4]
  20b79c:	60a2      	str	r2, [r4, #8]
  20b79e:	881b      	ldrh	r3, [r3, #0]
  20b7a0:	81a3      	strh	r3, [r4, #12]
		break;
  20b7a2:	e090      	b.n	20b8c6 <LCD_LoadFont+0x3aa>
	case Calibri_Light:
		strncat(fileOpenName,"Calibri_Light/",14);
  20b7a4:	f107 0310 	add.w	r3, r7, #16
  20b7a8:	4618      	mov	r0, r3
  20b7aa:	f7f4 fd49 	bl	200240 <strlen>
  20b7ae:	4603      	mov	r3, r0
  20b7b0:	461a      	mov	r2, r3
  20b7b2:	f107 0310 	add.w	r3, r7, #16
  20b7b6:	4413      	add	r3, r2
  20b7b8:	4a3d      	ldr	r2, [pc, #244]	; (20b8b0 <LCD_LoadFont+0x394>)
  20b7ba:	461c      	mov	r4, r3
  20b7bc:	4613      	mov	r3, r2
  20b7be:	cb07      	ldmia	r3!, {r0, r1, r2}
  20b7c0:	6020      	str	r0, [r4, #0]
  20b7c2:	6061      	str	r1, [r4, #4]
  20b7c4:	60a2      	str	r2, [r4, #8]
  20b7c6:	881a      	ldrh	r2, [r3, #0]
  20b7c8:	789b      	ldrb	r3, [r3, #2]
  20b7ca:	81a2      	strh	r2, [r4, #12]
  20b7cc:	73a3      	strb	r3, [r4, #14]
		break;
  20b7ce:	e07a      	b.n	20b8c6 <LCD_LoadFont+0x3aa>
	case Bodoni_MT_Condenset:
		strncat(fileOpenName,"Bodoni_MT_Condenset/",20);
  20b7d0:	f107 0310 	add.w	r3, r7, #16
  20b7d4:	4618      	mov	r0, r3
  20b7d6:	f7f4 fd33 	bl	200240 <strlen>
  20b7da:	4603      	mov	r3, r0
  20b7dc:	461a      	mov	r2, r3
  20b7de:	f107 0310 	add.w	r3, r7, #16
  20b7e2:	4413      	add	r3, r2
  20b7e4:	4a33      	ldr	r2, [pc, #204]	; (20b8b4 <LCD_LoadFont+0x398>)
  20b7e6:	461d      	mov	r5, r3
  20b7e8:	4614      	mov	r4, r2
  20b7ea:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b7ec:	6028      	str	r0, [r5, #0]
  20b7ee:	6069      	str	r1, [r5, #4]
  20b7f0:	60aa      	str	r2, [r5, #8]
  20b7f2:	60eb      	str	r3, [r5, #12]
  20b7f4:	6820      	ldr	r0, [r4, #0]
  20b7f6:	6128      	str	r0, [r5, #16]
  20b7f8:	7923      	ldrb	r3, [r4, #4]
  20b7fa:	752b      	strb	r3, [r5, #20]
		break;
  20b7fc:	e063      	b.n	20b8c6 <LCD_LoadFont+0x3aa>
	case Comic_Saens_MS:
		strncat(fileOpenName,"Comic_Saens_MS/",15);
  20b7fe:	f107 0310 	add.w	r3, r7, #16
  20b802:	4618      	mov	r0, r3
  20b804:	f7f4 fd1c 	bl	200240 <strlen>
  20b808:	4603      	mov	r3, r0
  20b80a:	461a      	mov	r2, r3
  20b80c:	f107 0310 	add.w	r3, r7, #16
  20b810:	4413      	add	r3, r2
  20b812:	4a29      	ldr	r2, [pc, #164]	; (20b8b8 <LCD_LoadFont+0x39c>)
  20b814:	461c      	mov	r4, r3
  20b816:	4615      	mov	r5, r2
  20b818:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20b81a:	6020      	str	r0, [r4, #0]
  20b81c:	6061      	str	r1, [r4, #4]
  20b81e:	60a2      	str	r2, [r4, #8]
  20b820:	60e3      	str	r3, [r4, #12]
		break;
  20b822:	e050      	b.n	20b8c6 <LCD_LoadFont+0x3aa>
	case Times_New_Roman:
		strncat(fileOpenName,"Times_New_Roman/",16);
  20b824:	f107 0310 	add.w	r3, r7, #16
  20b828:	4618      	mov	r0, r3
  20b82a:	f7f4 fd09 	bl	200240 <strlen>
  20b82e:	4603      	mov	r3, r0
  20b830:	461a      	mov	r2, r3
  20b832:	f107 0310 	add.w	r3, r7, #16
  20b836:	4413      	add	r3, r2
  20b838:	4a20      	ldr	r2, [pc, #128]	; (20b8bc <LCD_LoadFont+0x3a0>)
  20b83a:	461d      	mov	r5, r3
  20b83c:	4614      	mov	r4, r2
  20b83e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20b840:	6028      	str	r0, [r5, #0]
  20b842:	6069      	str	r1, [r5, #4]
  20b844:	60aa      	str	r2, [r5, #8]
  20b846:	60eb      	str	r3, [r5, #12]
  20b848:	7823      	ldrb	r3, [r4, #0]
  20b84a:	742b      	strb	r3, [r5, #16]
		break;
  20b84c:	e03b      	b.n	20b8c6 <LCD_LoadFont+0x3aa>
	case Arial:
		strncat(fileOpenName,"Arial/",6);
  20b84e:	f107 0310 	add.w	r3, r7, #16
  20b852:	4618      	mov	r0, r3
  20b854:	f7f4 fcf4 	bl	200240 <strlen>
  20b858:	4603      	mov	r3, r0
  20b85a:	461a      	mov	r2, r3
  20b85c:	f107 0310 	add.w	r3, r7, #16
  20b860:	4413      	add	r3, r2
  20b862:	4a17      	ldr	r2, [pc, #92]	; (20b8c0 <LCD_LoadFont+0x3a4>)
  20b864:	6810      	ldr	r0, [r2, #0]
  20b866:	6018      	str	r0, [r3, #0]
  20b868:	8891      	ldrh	r1, [r2, #4]
  20b86a:	7992      	ldrb	r2, [r2, #6]
  20b86c:	8099      	strh	r1, [r3, #4]
  20b86e:	719a      	strb	r2, [r3, #6]
		break;
  20b870:	e029      	b.n	20b8c6 <LCD_LoadFont+0x3aa>
  20b872:	bf00      	nop
  20b874:	00228d60 	.word	0x00228d60
  20b878:	ff404040 	.word	0xff404040
  20b87c:	ffa52a2a 	.word	0xffa52a2a
  20b880:	002288ec 	.word	0x002288ec
  20b884:	00228904 	.word	0x00228904
  20b888:	00228918 	.word	0x00228918
  20b88c:	0022892c 	.word	0x0022892c
  20b890:	ff50c8ff 	.word	0xff50c8ff
  20b894:	ffff7878 	.word	0xffff7878
  20b898:	00228940 	.word	0x00228940
  20b89c:	00228950 	.word	0x00228950
  20b8a0:	0022895c 	.word	0x0022895c
  20b8a4:	00228968 	.word	0x00228968
  20b8a8:	00228978 	.word	0x00228978
  20b8ac:	00228988 	.word	0x00228988
  20b8b0:	00228998 	.word	0x00228998
  20b8b4:	002289a8 	.word	0x002289a8
  20b8b8:	002289c0 	.word	0x002289c0
  20b8bc:	002289d0 	.word	0x002289d0
  20b8c0:	002289e4 	.word	0x002289e4
	default:
		break;
  20b8c4:	bf00      	nop
	}

	switch(fontSize)
  20b8c6:	68fb      	ldr	r3, [r7, #12]
  20b8c8:	2b32      	cmp	r3, #50	; 0x32
  20b8ca:	f200 84d0 	bhi.w	20c26e <LCD_LoadFont+0xd52>
  20b8ce:	a201      	add	r2, pc, #4	; (adr r2, 20b8d4 <LCD_LoadFont+0x3b8>)
  20b8d0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  20b8d4:	0020b9a1 	.word	0x0020b9a1
  20b8d8:	0020bc1f 	.word	0x0020bc1f
  20b8dc:	0020bf3f 	.word	0x0020bf3f
  20b8e0:	0020b9cd 	.word	0x0020b9cd
  20b8e4:	0020bc45 	.word	0x0020bc45
  20b8e8:	0020bf6f 	.word	0x0020bf6f
  20b8ec:	0020b9f9 	.word	0x0020b9f9
  20b8f0:	0020bc6b 	.word	0x0020bc6b
  20b8f4:	0020bf9f 	.word	0x0020bf9f
  20b8f8:	0020ba1f 	.word	0x0020ba1f
  20b8fc:	0020bc95 	.word	0x0020bc95
  20b900:	0020bfc9 	.word	0x0020bfc9
  20b904:	0020ba45 	.word	0x0020ba45
  20b908:	0020bcbf 	.word	0x0020bcbf
  20b90c:	0020bff3 	.word	0x0020bff3
  20b910:	0020ba6b 	.word	0x0020ba6b
  20b914:	0020bce9 	.word	0x0020bce9
  20b918:	0020c01d 	.word	0x0020c01d
  20b91c:	0020ba8f 	.word	0x0020ba8f
  20b920:	0020bd71 	.word	0x0020bd71
  20b924:	0020c047 	.word	0x0020c047
  20b928:	0020bab3 	.word	0x0020bab3
  20b92c:	0020bd9b 	.word	0x0020bd9b
  20b930:	0020c071 	.word	0x0020c071
  20b934:	0020bad7 	.word	0x0020bad7
  20b938:	0020bdc5 	.word	0x0020bdc5
  20b93c:	0020c09b 	.word	0x0020c09b
  20b940:	0020bafb 	.word	0x0020bafb
  20b944:	0020bdef 	.word	0x0020bdef
  20b948:	0020c0c5 	.word	0x0020c0c5
  20b94c:	0020bb1f 	.word	0x0020bb1f
  20b950:	0020be19 	.word	0x0020be19
  20b954:	0020c145 	.word	0x0020c145
  20b958:	0020bb43 	.word	0x0020bb43
  20b95c:	0020be43 	.word	0x0020be43
  20b960:	0020c16f 	.word	0x0020c16f
  20b964:	0020bb67 	.word	0x0020bb67
  20b968:	0020be6d 	.word	0x0020be6d
  20b96c:	0020c199 	.word	0x0020c199
  20b970:	0020bb8b 	.word	0x0020bb8b
  20b974:	0020be97 	.word	0x0020be97
  20b978:	0020c1c3 	.word	0x0020c1c3
  20b97c:	0020bbaf 	.word	0x0020bbaf
  20b980:	0020bec1 	.word	0x0020bec1
  20b984:	0020c1ed 	.word	0x0020c1ed
  20b988:	0020bbd3 	.word	0x0020bbd3
  20b98c:	0020beeb 	.word	0x0020beeb
  20b990:	0020c217 	.word	0x0020c217
  20b994:	0020bbf7 	.word	0x0020bbf7
  20b998:	0020bf15 	.word	0x0020bf15
  20b99c:	0020c241 	.word	0x0020c241
	{
	case FONT_8:
		strncat(fileOpenName,"font_8.bmp",10);
  20b9a0:	f107 0310 	add.w	r3, r7, #16
  20b9a4:	4618      	mov	r0, r3
  20b9a6:	f7f4 fc4b 	bl	200240 <strlen>
  20b9aa:	4603      	mov	r3, r0
  20b9ac:	461a      	mov	r2, r3
  20b9ae:	f107 0310 	add.w	r3, r7, #16
  20b9b2:	4413      	add	r3, r2
  20b9b4:	49d7      	ldr	r1, [pc, #860]	; (20bd14 <LCD_LoadFont+0x7f8>)
  20b9b6:	461a      	mov	r2, r3
  20b9b8:	460b      	mov	r3, r1
  20b9ba:	cb03      	ldmia	r3!, {r0, r1}
  20b9bc:	6010      	str	r0, [r2, #0]
  20b9be:	6051      	str	r1, [r2, #4]
  20b9c0:	8819      	ldrh	r1, [r3, #0]
  20b9c2:	789b      	ldrb	r3, [r3, #2]
  20b9c4:	8111      	strh	r1, [r2, #8]
  20b9c6:	7293      	strb	r3, [r2, #10]
		break;
  20b9c8:	f000 bc52 	b.w	20c270 <LCD_LoadFont+0xd54>
	case FONT_9:
		strncat(fileOpenName,"font_9.bmp",10);
  20b9cc:	f107 0310 	add.w	r3, r7, #16
  20b9d0:	4618      	mov	r0, r3
  20b9d2:	f7f4 fc35 	bl	200240 <strlen>
  20b9d6:	4603      	mov	r3, r0
  20b9d8:	461a      	mov	r2, r3
  20b9da:	f107 0310 	add.w	r3, r7, #16
  20b9de:	4413      	add	r3, r2
  20b9e0:	49cd      	ldr	r1, [pc, #820]	; (20bd18 <LCD_LoadFont+0x7fc>)
  20b9e2:	461a      	mov	r2, r3
  20b9e4:	460b      	mov	r3, r1
  20b9e6:	cb03      	ldmia	r3!, {r0, r1}
  20b9e8:	6010      	str	r0, [r2, #0]
  20b9ea:	6051      	str	r1, [r2, #4]
  20b9ec:	8819      	ldrh	r1, [r3, #0]
  20b9ee:	789b      	ldrb	r3, [r3, #2]
  20b9f0:	8111      	strh	r1, [r2, #8]
  20b9f2:	7293      	strb	r3, [r2, #10]
		break;
  20b9f4:	f000 bc3c 	b.w	20c270 <LCD_LoadFont+0xd54>
	case FONT_10:
		strncat(fileOpenName,"font_10.bmp",11);
  20b9f8:	f107 0310 	add.w	r3, r7, #16
  20b9fc:	4618      	mov	r0, r3
  20b9fe:	f7f4 fc1f 	bl	200240 <strlen>
  20ba02:	4603      	mov	r3, r0
  20ba04:	461a      	mov	r2, r3
  20ba06:	f107 0310 	add.w	r3, r7, #16
  20ba0a:	4413      	add	r3, r2
  20ba0c:	4ac3      	ldr	r2, [pc, #780]	; (20bd1c <LCD_LoadFont+0x800>)
  20ba0e:	461c      	mov	r4, r3
  20ba10:	4613      	mov	r3, r2
  20ba12:	cb07      	ldmia	r3!, {r0, r1, r2}
  20ba14:	6020      	str	r0, [r4, #0]
  20ba16:	6061      	str	r1, [r4, #4]
  20ba18:	60a2      	str	r2, [r4, #8]
		break;
  20ba1a:	f000 bc29 	b.w	20c270 <LCD_LoadFont+0xd54>
	case FONT_11:
		strncat(fileOpenName,"font_11.bmp",11);
  20ba1e:	f107 0310 	add.w	r3, r7, #16
  20ba22:	4618      	mov	r0, r3
  20ba24:	f7f4 fc0c 	bl	200240 <strlen>
  20ba28:	4603      	mov	r3, r0
  20ba2a:	461a      	mov	r2, r3
  20ba2c:	f107 0310 	add.w	r3, r7, #16
  20ba30:	4413      	add	r3, r2
  20ba32:	4abb      	ldr	r2, [pc, #748]	; (20bd20 <LCD_LoadFont+0x804>)
  20ba34:	461c      	mov	r4, r3
  20ba36:	4613      	mov	r3, r2
  20ba38:	cb07      	ldmia	r3!, {r0, r1, r2}
  20ba3a:	6020      	str	r0, [r4, #0]
  20ba3c:	6061      	str	r1, [r4, #4]
  20ba3e:	60a2      	str	r2, [r4, #8]
		break;
  20ba40:	f000 bc16 	b.w	20c270 <LCD_LoadFont+0xd54>
	case FONT_12:
		strncat(fileOpenName,"font_12.bmp",11);
  20ba44:	f107 0310 	add.w	r3, r7, #16
  20ba48:	4618      	mov	r0, r3
  20ba4a:	f7f4 fbf9 	bl	200240 <strlen>
  20ba4e:	4603      	mov	r3, r0
  20ba50:	461a      	mov	r2, r3
  20ba52:	f107 0310 	add.w	r3, r7, #16
  20ba56:	4413      	add	r3, r2
  20ba58:	4ab2      	ldr	r2, [pc, #712]	; (20bd24 <LCD_LoadFont+0x808>)
  20ba5a:	461c      	mov	r4, r3
  20ba5c:	4613      	mov	r3, r2
  20ba5e:	cb07      	ldmia	r3!, {r0, r1, r2}
  20ba60:	6020      	str	r0, [r4, #0]
  20ba62:	6061      	str	r1, [r4, #4]
  20ba64:	60a2      	str	r2, [r4, #8]
		break;
  20ba66:	f000 bc03 	b.w	20c270 <LCD_LoadFont+0xd54>
	case FONT_14:
		strncat(fileOpenName,"font_14.bmp",11);
  20ba6a:	f107 0310 	add.w	r3, r7, #16
  20ba6e:	4618      	mov	r0, r3
  20ba70:	f7f4 fbe6 	bl	200240 <strlen>
  20ba74:	4603      	mov	r3, r0
  20ba76:	461a      	mov	r2, r3
  20ba78:	f107 0310 	add.w	r3, r7, #16
  20ba7c:	4413      	add	r3, r2
  20ba7e:	4aaa      	ldr	r2, [pc, #680]	; (20bd28 <LCD_LoadFont+0x80c>)
  20ba80:	461c      	mov	r4, r3
  20ba82:	4613      	mov	r3, r2
  20ba84:	cb07      	ldmia	r3!, {r0, r1, r2}
  20ba86:	6020      	str	r0, [r4, #0]
  20ba88:	6061      	str	r1, [r4, #4]
  20ba8a:	60a2      	str	r2, [r4, #8]
		break;
  20ba8c:	e3f0      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_16:
		strncat(fileOpenName,"font_16.bmp",11);
  20ba8e:	f107 0310 	add.w	r3, r7, #16
  20ba92:	4618      	mov	r0, r3
  20ba94:	f7f4 fbd4 	bl	200240 <strlen>
  20ba98:	4603      	mov	r3, r0
  20ba9a:	461a      	mov	r2, r3
  20ba9c:	f107 0310 	add.w	r3, r7, #16
  20baa0:	4413      	add	r3, r2
  20baa2:	4aa2      	ldr	r2, [pc, #648]	; (20bd2c <LCD_LoadFont+0x810>)
  20baa4:	461c      	mov	r4, r3
  20baa6:	4613      	mov	r3, r2
  20baa8:	cb07      	ldmia	r3!, {r0, r1, r2}
  20baaa:	6020      	str	r0, [r4, #0]
  20baac:	6061      	str	r1, [r4, #4]
  20baae:	60a2      	str	r2, [r4, #8]
		break;
  20bab0:	e3de      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_18:
		strncat(fileOpenName,"font_18.bmp",11);
  20bab2:	f107 0310 	add.w	r3, r7, #16
  20bab6:	4618      	mov	r0, r3
  20bab8:	f7f4 fbc2 	bl	200240 <strlen>
  20babc:	4603      	mov	r3, r0
  20babe:	461a      	mov	r2, r3
  20bac0:	f107 0310 	add.w	r3, r7, #16
  20bac4:	4413      	add	r3, r2
  20bac6:	4a9a      	ldr	r2, [pc, #616]	; (20bd30 <LCD_LoadFont+0x814>)
  20bac8:	461c      	mov	r4, r3
  20baca:	4613      	mov	r3, r2
  20bacc:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bace:	6020      	str	r0, [r4, #0]
  20bad0:	6061      	str	r1, [r4, #4]
  20bad2:	60a2      	str	r2, [r4, #8]
		break;
  20bad4:	e3cc      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_20:
		strncat(fileOpenName,"font_20.bmp",11);
  20bad6:	f107 0310 	add.w	r3, r7, #16
  20bada:	4618      	mov	r0, r3
  20badc:	f7f4 fbb0 	bl	200240 <strlen>
  20bae0:	4603      	mov	r3, r0
  20bae2:	461a      	mov	r2, r3
  20bae4:	f107 0310 	add.w	r3, r7, #16
  20bae8:	4413      	add	r3, r2
  20baea:	4a92      	ldr	r2, [pc, #584]	; (20bd34 <LCD_LoadFont+0x818>)
  20baec:	461c      	mov	r4, r3
  20baee:	4613      	mov	r3, r2
  20baf0:	cb07      	ldmia	r3!, {r0, r1, r2}
  20baf2:	6020      	str	r0, [r4, #0]
  20baf4:	6061      	str	r1, [r4, #4]
  20baf6:	60a2      	str	r2, [r4, #8]
		break;
  20baf8:	e3ba      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_22:
		strncat(fileOpenName,"font_22.bmp",11);
  20bafa:	f107 0310 	add.w	r3, r7, #16
  20bafe:	4618      	mov	r0, r3
  20bb00:	f7f4 fb9e 	bl	200240 <strlen>
  20bb04:	4603      	mov	r3, r0
  20bb06:	461a      	mov	r2, r3
  20bb08:	f107 0310 	add.w	r3, r7, #16
  20bb0c:	4413      	add	r3, r2
  20bb0e:	4a8a      	ldr	r2, [pc, #552]	; (20bd38 <LCD_LoadFont+0x81c>)
  20bb10:	461c      	mov	r4, r3
  20bb12:	4613      	mov	r3, r2
  20bb14:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bb16:	6020      	str	r0, [r4, #0]
  20bb18:	6061      	str	r1, [r4, #4]
  20bb1a:	60a2      	str	r2, [r4, #8]
		break;
  20bb1c:	e3a8      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_24:
		strncat(fileOpenName,"font_24.bmp",11);
  20bb1e:	f107 0310 	add.w	r3, r7, #16
  20bb22:	4618      	mov	r0, r3
  20bb24:	f7f4 fb8c 	bl	200240 <strlen>
  20bb28:	4603      	mov	r3, r0
  20bb2a:	461a      	mov	r2, r3
  20bb2c:	f107 0310 	add.w	r3, r7, #16
  20bb30:	4413      	add	r3, r2
  20bb32:	4a82      	ldr	r2, [pc, #520]	; (20bd3c <LCD_LoadFont+0x820>)
  20bb34:	461c      	mov	r4, r3
  20bb36:	4613      	mov	r3, r2
  20bb38:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bb3a:	6020      	str	r0, [r4, #0]
  20bb3c:	6061      	str	r1, [r4, #4]
  20bb3e:	60a2      	str	r2, [r4, #8]
		break;
  20bb40:	e396      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_26:
		strncat(fileOpenName,"font_26.bmp",11);
  20bb42:	f107 0310 	add.w	r3, r7, #16
  20bb46:	4618      	mov	r0, r3
  20bb48:	f7f4 fb7a 	bl	200240 <strlen>
  20bb4c:	4603      	mov	r3, r0
  20bb4e:	461a      	mov	r2, r3
  20bb50:	f107 0310 	add.w	r3, r7, #16
  20bb54:	4413      	add	r3, r2
  20bb56:	4a7a      	ldr	r2, [pc, #488]	; (20bd40 <LCD_LoadFont+0x824>)
  20bb58:	461c      	mov	r4, r3
  20bb5a:	4613      	mov	r3, r2
  20bb5c:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bb5e:	6020      	str	r0, [r4, #0]
  20bb60:	6061      	str	r1, [r4, #4]
  20bb62:	60a2      	str	r2, [r4, #8]
		break;
  20bb64:	e384      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_28:
		strncat(fileOpenName,"font_28.bmp",11);
  20bb66:	f107 0310 	add.w	r3, r7, #16
  20bb6a:	4618      	mov	r0, r3
  20bb6c:	f7f4 fb68 	bl	200240 <strlen>
  20bb70:	4603      	mov	r3, r0
  20bb72:	461a      	mov	r2, r3
  20bb74:	f107 0310 	add.w	r3, r7, #16
  20bb78:	4413      	add	r3, r2
  20bb7a:	4a72      	ldr	r2, [pc, #456]	; (20bd44 <LCD_LoadFont+0x828>)
  20bb7c:	461c      	mov	r4, r3
  20bb7e:	4613      	mov	r3, r2
  20bb80:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bb82:	6020      	str	r0, [r4, #0]
  20bb84:	6061      	str	r1, [r4, #4]
  20bb86:	60a2      	str	r2, [r4, #8]
		break;
  20bb88:	e372      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_36:
		strncat(fileOpenName,"font_36.bmp",11);
  20bb8a:	f107 0310 	add.w	r3, r7, #16
  20bb8e:	4618      	mov	r0, r3
  20bb90:	f7f4 fb56 	bl	200240 <strlen>
  20bb94:	4603      	mov	r3, r0
  20bb96:	461a      	mov	r2, r3
  20bb98:	f107 0310 	add.w	r3, r7, #16
  20bb9c:	4413      	add	r3, r2
  20bb9e:	4a6a      	ldr	r2, [pc, #424]	; (20bd48 <LCD_LoadFont+0x82c>)
  20bba0:	461c      	mov	r4, r3
  20bba2:	4613      	mov	r3, r2
  20bba4:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bba6:	6020      	str	r0, [r4, #0]
  20bba8:	6061      	str	r1, [r4, #4]
  20bbaa:	60a2      	str	r2, [r4, #8]
		break;
  20bbac:	e360      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_48:
		strncat(fileOpenName,"font_48.bmp",11);
  20bbae:	f107 0310 	add.w	r3, r7, #16
  20bbb2:	4618      	mov	r0, r3
  20bbb4:	f7f4 fb44 	bl	200240 <strlen>
  20bbb8:	4603      	mov	r3, r0
  20bbba:	461a      	mov	r2, r3
  20bbbc:	f107 0310 	add.w	r3, r7, #16
  20bbc0:	4413      	add	r3, r2
  20bbc2:	4a62      	ldr	r2, [pc, #392]	; (20bd4c <LCD_LoadFont+0x830>)
  20bbc4:	461c      	mov	r4, r3
  20bbc6:	4613      	mov	r3, r2
  20bbc8:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bbca:	6020      	str	r0, [r4, #0]
  20bbcc:	6061      	str	r1, [r4, #4]
  20bbce:	60a2      	str	r2, [r4, #8]
		break;
  20bbd0:	e34e      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_72:
		strncat(fileOpenName,"font_72.bmp",11);
  20bbd2:	f107 0310 	add.w	r3, r7, #16
  20bbd6:	4618      	mov	r0, r3
  20bbd8:	f7f4 fb32 	bl	200240 <strlen>
  20bbdc:	4603      	mov	r3, r0
  20bbde:	461a      	mov	r2, r3
  20bbe0:	f107 0310 	add.w	r3, r7, #16
  20bbe4:	4413      	add	r3, r2
  20bbe6:	4a5a      	ldr	r2, [pc, #360]	; (20bd50 <LCD_LoadFont+0x834>)
  20bbe8:	461c      	mov	r4, r3
  20bbea:	4613      	mov	r3, r2
  20bbec:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bbee:	6020      	str	r0, [r4, #0]
  20bbf0:	6061      	str	r1, [r4, #4]
  20bbf2:	60a2      	str	r2, [r4, #8]
		break;
  20bbf4:	e33c      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_130:
		strncat(fileOpenName,"font_130.bmp",12);
  20bbf6:	f107 0310 	add.w	r3, r7, #16
  20bbfa:	4618      	mov	r0, r3
  20bbfc:	f7f4 fb20 	bl	200240 <strlen>
  20bc00:	4603      	mov	r3, r0
  20bc02:	461a      	mov	r2, r3
  20bc04:	f107 0310 	add.w	r3, r7, #16
  20bc08:	4413      	add	r3, r2
  20bc0a:	4a52      	ldr	r2, [pc, #328]	; (20bd54 <LCD_LoadFont+0x838>)
  20bc0c:	461c      	mov	r4, r3
  20bc0e:	4613      	mov	r3, r2
  20bc10:	cb07      	ldmia	r3!, {r0, r1, r2}
  20bc12:	6020      	str	r0, [r4, #0]
  20bc14:	6061      	str	r1, [r4, #4]
  20bc16:	60a2      	str	r2, [r4, #8]
  20bc18:	781b      	ldrb	r3, [r3, #0]
  20bc1a:	7323      	strb	r3, [r4, #12]
		break;
  20bc1c:	e328      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_8_bold:
		strncat(fileOpenName,"font_8_bold.bmp",15);
  20bc1e:	f107 0310 	add.w	r3, r7, #16
  20bc22:	4618      	mov	r0, r3
  20bc24:	f7f4 fb0c 	bl	200240 <strlen>
  20bc28:	4603      	mov	r3, r0
  20bc2a:	461a      	mov	r2, r3
  20bc2c:	f107 0310 	add.w	r3, r7, #16
  20bc30:	4413      	add	r3, r2
  20bc32:	4a49      	ldr	r2, [pc, #292]	; (20bd58 <LCD_LoadFont+0x83c>)
  20bc34:	461c      	mov	r4, r3
  20bc36:	4615      	mov	r5, r2
  20bc38:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20bc3a:	6020      	str	r0, [r4, #0]
  20bc3c:	6061      	str	r1, [r4, #4]
  20bc3e:	60a2      	str	r2, [r4, #8]
  20bc40:	60e3      	str	r3, [r4, #12]
		break;
  20bc42:	e315      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_9_bold:
		strncat(fileOpenName,"font_9_bold.bmp",15);
  20bc44:	f107 0310 	add.w	r3, r7, #16
  20bc48:	4618      	mov	r0, r3
  20bc4a:	f7f4 faf9 	bl	200240 <strlen>
  20bc4e:	4603      	mov	r3, r0
  20bc50:	461a      	mov	r2, r3
  20bc52:	f107 0310 	add.w	r3, r7, #16
  20bc56:	4413      	add	r3, r2
  20bc58:	4a40      	ldr	r2, [pc, #256]	; (20bd5c <LCD_LoadFont+0x840>)
  20bc5a:	461c      	mov	r4, r3
  20bc5c:	4615      	mov	r5, r2
  20bc5e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  20bc60:	6020      	str	r0, [r4, #0]
  20bc62:	6061      	str	r1, [r4, #4]
  20bc64:	60a2      	str	r2, [r4, #8]
  20bc66:	60e3      	str	r3, [r4, #12]
		break;
  20bc68:	e302      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_10_bold:
		strncat(fileOpenName,"font_10_bold.bmp",16);
  20bc6a:	f107 0310 	add.w	r3, r7, #16
  20bc6e:	4618      	mov	r0, r3
  20bc70:	f7f4 fae6 	bl	200240 <strlen>
  20bc74:	4603      	mov	r3, r0
  20bc76:	461a      	mov	r2, r3
  20bc78:	f107 0310 	add.w	r3, r7, #16
  20bc7c:	4413      	add	r3, r2
  20bc7e:	4a38      	ldr	r2, [pc, #224]	; (20bd60 <LCD_LoadFont+0x844>)
  20bc80:	461d      	mov	r5, r3
  20bc82:	4614      	mov	r4, r2
  20bc84:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bc86:	6028      	str	r0, [r5, #0]
  20bc88:	6069      	str	r1, [r5, #4]
  20bc8a:	60aa      	str	r2, [r5, #8]
  20bc8c:	60eb      	str	r3, [r5, #12]
  20bc8e:	7823      	ldrb	r3, [r4, #0]
  20bc90:	742b      	strb	r3, [r5, #16]
		break;
  20bc92:	e2ed      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_11_bold:
		strncat(fileOpenName,"font_11_bold.bmp",16);
  20bc94:	f107 0310 	add.w	r3, r7, #16
  20bc98:	4618      	mov	r0, r3
  20bc9a:	f7f4 fad1 	bl	200240 <strlen>
  20bc9e:	4603      	mov	r3, r0
  20bca0:	461a      	mov	r2, r3
  20bca2:	f107 0310 	add.w	r3, r7, #16
  20bca6:	4413      	add	r3, r2
  20bca8:	4a2e      	ldr	r2, [pc, #184]	; (20bd64 <LCD_LoadFont+0x848>)
  20bcaa:	461d      	mov	r5, r3
  20bcac:	4614      	mov	r4, r2
  20bcae:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bcb0:	6028      	str	r0, [r5, #0]
  20bcb2:	6069      	str	r1, [r5, #4]
  20bcb4:	60aa      	str	r2, [r5, #8]
  20bcb6:	60eb      	str	r3, [r5, #12]
  20bcb8:	7823      	ldrb	r3, [r4, #0]
  20bcba:	742b      	strb	r3, [r5, #16]
		break;
  20bcbc:	e2d8      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_12_bold:
		strncat(fileOpenName,"font_12_bold.bmp",16);
  20bcbe:	f107 0310 	add.w	r3, r7, #16
  20bcc2:	4618      	mov	r0, r3
  20bcc4:	f7f4 fabc 	bl	200240 <strlen>
  20bcc8:	4603      	mov	r3, r0
  20bcca:	461a      	mov	r2, r3
  20bccc:	f107 0310 	add.w	r3, r7, #16
  20bcd0:	4413      	add	r3, r2
  20bcd2:	4a25      	ldr	r2, [pc, #148]	; (20bd68 <LCD_LoadFont+0x84c>)
  20bcd4:	461d      	mov	r5, r3
  20bcd6:	4614      	mov	r4, r2
  20bcd8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bcda:	6028      	str	r0, [r5, #0]
  20bcdc:	6069      	str	r1, [r5, #4]
  20bcde:	60aa      	str	r2, [r5, #8]
  20bce0:	60eb      	str	r3, [r5, #12]
  20bce2:	7823      	ldrb	r3, [r4, #0]
  20bce4:	742b      	strb	r3, [r5, #16]
		break;
  20bce6:	e2c3      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_14_bold:
		strncat(fileOpenName,"font_14_bold.bmp",16);
  20bce8:	f107 0310 	add.w	r3, r7, #16
  20bcec:	4618      	mov	r0, r3
  20bcee:	f7f4 faa7 	bl	200240 <strlen>
  20bcf2:	4603      	mov	r3, r0
  20bcf4:	461a      	mov	r2, r3
  20bcf6:	f107 0310 	add.w	r3, r7, #16
  20bcfa:	4413      	add	r3, r2
  20bcfc:	4a1b      	ldr	r2, [pc, #108]	; (20bd6c <LCD_LoadFont+0x850>)
  20bcfe:	461d      	mov	r5, r3
  20bd00:	4614      	mov	r4, r2
  20bd02:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bd04:	6028      	str	r0, [r5, #0]
  20bd06:	6069      	str	r1, [r5, #4]
  20bd08:	60aa      	str	r2, [r5, #8]
  20bd0a:	60eb      	str	r3, [r5, #12]
  20bd0c:	7823      	ldrb	r3, [r4, #0]
  20bd0e:	742b      	strb	r3, [r5, #16]
		break;
  20bd10:	e2ae      	b.n	20c270 <LCD_LoadFont+0xd54>
  20bd12:	bf00      	nop
  20bd14:	002289ec 	.word	0x002289ec
  20bd18:	002289f8 	.word	0x002289f8
  20bd1c:	00228a04 	.word	0x00228a04
  20bd20:	00228a10 	.word	0x00228a10
  20bd24:	00228a1c 	.word	0x00228a1c
  20bd28:	00228a28 	.word	0x00228a28
  20bd2c:	00228a34 	.word	0x00228a34
  20bd30:	00228a40 	.word	0x00228a40
  20bd34:	00228a4c 	.word	0x00228a4c
  20bd38:	00228a58 	.word	0x00228a58
  20bd3c:	00228a64 	.word	0x00228a64
  20bd40:	00228a70 	.word	0x00228a70
  20bd44:	00228a7c 	.word	0x00228a7c
  20bd48:	00228a88 	.word	0x00228a88
  20bd4c:	00228a94 	.word	0x00228a94
  20bd50:	00228aa0 	.word	0x00228aa0
  20bd54:	00228aac 	.word	0x00228aac
  20bd58:	00228abc 	.word	0x00228abc
  20bd5c:	00228acc 	.word	0x00228acc
  20bd60:	00228adc 	.word	0x00228adc
  20bd64:	00228af0 	.word	0x00228af0
  20bd68:	00228b04 	.word	0x00228b04
  20bd6c:	00228b18 	.word	0x00228b18
	case FONT_16_bold:
		strncat(fileOpenName,"font_16_bold.bmp",16);
  20bd70:	f107 0310 	add.w	r3, r7, #16
  20bd74:	4618      	mov	r0, r3
  20bd76:	f7f4 fa63 	bl	200240 <strlen>
  20bd7a:	4603      	mov	r3, r0
  20bd7c:	461a      	mov	r2, r3
  20bd7e:	f107 0310 	add.w	r3, r7, #16
  20bd82:	4413      	add	r3, r2
  20bd84:	4ada      	ldr	r2, [pc, #872]	; (20c0f0 <LCD_LoadFont+0xbd4>)
  20bd86:	461d      	mov	r5, r3
  20bd88:	4614      	mov	r4, r2
  20bd8a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bd8c:	6028      	str	r0, [r5, #0]
  20bd8e:	6069      	str	r1, [r5, #4]
  20bd90:	60aa      	str	r2, [r5, #8]
  20bd92:	60eb      	str	r3, [r5, #12]
  20bd94:	7823      	ldrb	r3, [r4, #0]
  20bd96:	742b      	strb	r3, [r5, #16]
		break;
  20bd98:	e26a      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_18_bold:
		strncat(fileOpenName,"font_18_bold.bmp",16);
  20bd9a:	f107 0310 	add.w	r3, r7, #16
  20bd9e:	4618      	mov	r0, r3
  20bda0:	f7f4 fa4e 	bl	200240 <strlen>
  20bda4:	4603      	mov	r3, r0
  20bda6:	461a      	mov	r2, r3
  20bda8:	f107 0310 	add.w	r3, r7, #16
  20bdac:	4413      	add	r3, r2
  20bdae:	4ad1      	ldr	r2, [pc, #836]	; (20c0f4 <LCD_LoadFont+0xbd8>)
  20bdb0:	461d      	mov	r5, r3
  20bdb2:	4614      	mov	r4, r2
  20bdb4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bdb6:	6028      	str	r0, [r5, #0]
  20bdb8:	6069      	str	r1, [r5, #4]
  20bdba:	60aa      	str	r2, [r5, #8]
  20bdbc:	60eb      	str	r3, [r5, #12]
  20bdbe:	7823      	ldrb	r3, [r4, #0]
  20bdc0:	742b      	strb	r3, [r5, #16]
		break;
  20bdc2:	e255      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_20_bold:
		strncat(fileOpenName,"font_20_bold.bmp",16);
  20bdc4:	f107 0310 	add.w	r3, r7, #16
  20bdc8:	4618      	mov	r0, r3
  20bdca:	f7f4 fa39 	bl	200240 <strlen>
  20bdce:	4603      	mov	r3, r0
  20bdd0:	461a      	mov	r2, r3
  20bdd2:	f107 0310 	add.w	r3, r7, #16
  20bdd6:	4413      	add	r3, r2
  20bdd8:	4ac7      	ldr	r2, [pc, #796]	; (20c0f8 <LCD_LoadFont+0xbdc>)
  20bdda:	461d      	mov	r5, r3
  20bddc:	4614      	mov	r4, r2
  20bdde:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bde0:	6028      	str	r0, [r5, #0]
  20bde2:	6069      	str	r1, [r5, #4]
  20bde4:	60aa      	str	r2, [r5, #8]
  20bde6:	60eb      	str	r3, [r5, #12]
  20bde8:	7823      	ldrb	r3, [r4, #0]
  20bdea:	742b      	strb	r3, [r5, #16]
		break;
  20bdec:	e240      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_22_bold:
		strncat(fileOpenName,"font_22_bold.bmp",16);
  20bdee:	f107 0310 	add.w	r3, r7, #16
  20bdf2:	4618      	mov	r0, r3
  20bdf4:	f7f4 fa24 	bl	200240 <strlen>
  20bdf8:	4603      	mov	r3, r0
  20bdfa:	461a      	mov	r2, r3
  20bdfc:	f107 0310 	add.w	r3, r7, #16
  20be00:	4413      	add	r3, r2
  20be02:	4abe      	ldr	r2, [pc, #760]	; (20c0fc <LCD_LoadFont+0xbe0>)
  20be04:	461d      	mov	r5, r3
  20be06:	4614      	mov	r4, r2
  20be08:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20be0a:	6028      	str	r0, [r5, #0]
  20be0c:	6069      	str	r1, [r5, #4]
  20be0e:	60aa      	str	r2, [r5, #8]
  20be10:	60eb      	str	r3, [r5, #12]
  20be12:	7823      	ldrb	r3, [r4, #0]
  20be14:	742b      	strb	r3, [r5, #16]
		break;
  20be16:	e22b      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_24_bold:
		strncat(fileOpenName,"font_24_bold.bmp",16);
  20be18:	f107 0310 	add.w	r3, r7, #16
  20be1c:	4618      	mov	r0, r3
  20be1e:	f7f4 fa0f 	bl	200240 <strlen>
  20be22:	4603      	mov	r3, r0
  20be24:	461a      	mov	r2, r3
  20be26:	f107 0310 	add.w	r3, r7, #16
  20be2a:	4413      	add	r3, r2
  20be2c:	4ab4      	ldr	r2, [pc, #720]	; (20c100 <LCD_LoadFont+0xbe4>)
  20be2e:	461d      	mov	r5, r3
  20be30:	4614      	mov	r4, r2
  20be32:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20be34:	6028      	str	r0, [r5, #0]
  20be36:	6069      	str	r1, [r5, #4]
  20be38:	60aa      	str	r2, [r5, #8]
  20be3a:	60eb      	str	r3, [r5, #12]
  20be3c:	7823      	ldrb	r3, [r4, #0]
  20be3e:	742b      	strb	r3, [r5, #16]
		break;
  20be40:	e216      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_26_bold:
		strncat(fileOpenName,"font_26_bold.bmp",16);
  20be42:	f107 0310 	add.w	r3, r7, #16
  20be46:	4618      	mov	r0, r3
  20be48:	f7f4 f9fa 	bl	200240 <strlen>
  20be4c:	4603      	mov	r3, r0
  20be4e:	461a      	mov	r2, r3
  20be50:	f107 0310 	add.w	r3, r7, #16
  20be54:	4413      	add	r3, r2
  20be56:	4aab      	ldr	r2, [pc, #684]	; (20c104 <LCD_LoadFont+0xbe8>)
  20be58:	461d      	mov	r5, r3
  20be5a:	4614      	mov	r4, r2
  20be5c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20be5e:	6028      	str	r0, [r5, #0]
  20be60:	6069      	str	r1, [r5, #4]
  20be62:	60aa      	str	r2, [r5, #8]
  20be64:	60eb      	str	r3, [r5, #12]
  20be66:	7823      	ldrb	r3, [r4, #0]
  20be68:	742b      	strb	r3, [r5, #16]
		break;
  20be6a:	e201      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_28_bold:
		strncat(fileOpenName,"font_28_bold.bmp",16);
  20be6c:	f107 0310 	add.w	r3, r7, #16
  20be70:	4618      	mov	r0, r3
  20be72:	f7f4 f9e5 	bl	200240 <strlen>
  20be76:	4603      	mov	r3, r0
  20be78:	461a      	mov	r2, r3
  20be7a:	f107 0310 	add.w	r3, r7, #16
  20be7e:	4413      	add	r3, r2
  20be80:	4aa1      	ldr	r2, [pc, #644]	; (20c108 <LCD_LoadFont+0xbec>)
  20be82:	461d      	mov	r5, r3
  20be84:	4614      	mov	r4, r2
  20be86:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20be88:	6028      	str	r0, [r5, #0]
  20be8a:	6069      	str	r1, [r5, #4]
  20be8c:	60aa      	str	r2, [r5, #8]
  20be8e:	60eb      	str	r3, [r5, #12]
  20be90:	7823      	ldrb	r3, [r4, #0]
  20be92:	742b      	strb	r3, [r5, #16]
		break;
  20be94:	e1ec      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_36_bold:
		strncat(fileOpenName,"font_36_bold.bmp",16);
  20be96:	f107 0310 	add.w	r3, r7, #16
  20be9a:	4618      	mov	r0, r3
  20be9c:	f7f4 f9d0 	bl	200240 <strlen>
  20bea0:	4603      	mov	r3, r0
  20bea2:	461a      	mov	r2, r3
  20bea4:	f107 0310 	add.w	r3, r7, #16
  20bea8:	4413      	add	r3, r2
  20beaa:	4a98      	ldr	r2, [pc, #608]	; (20c10c <LCD_LoadFont+0xbf0>)
  20beac:	461d      	mov	r5, r3
  20beae:	4614      	mov	r4, r2
  20beb0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20beb2:	6028      	str	r0, [r5, #0]
  20beb4:	6069      	str	r1, [r5, #4]
  20beb6:	60aa      	str	r2, [r5, #8]
  20beb8:	60eb      	str	r3, [r5, #12]
  20beba:	7823      	ldrb	r3, [r4, #0]
  20bebc:	742b      	strb	r3, [r5, #16]
		break;
  20bebe:	e1d7      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_48_bold:
		strncat(fileOpenName,"font_48_bold.bmp",16);
  20bec0:	f107 0310 	add.w	r3, r7, #16
  20bec4:	4618      	mov	r0, r3
  20bec6:	f7f4 f9bb 	bl	200240 <strlen>
  20beca:	4603      	mov	r3, r0
  20becc:	461a      	mov	r2, r3
  20bece:	f107 0310 	add.w	r3, r7, #16
  20bed2:	4413      	add	r3, r2
  20bed4:	4a8e      	ldr	r2, [pc, #568]	; (20c110 <LCD_LoadFont+0xbf4>)
  20bed6:	461d      	mov	r5, r3
  20bed8:	4614      	mov	r4, r2
  20beda:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bedc:	6028      	str	r0, [r5, #0]
  20bede:	6069      	str	r1, [r5, #4]
  20bee0:	60aa      	str	r2, [r5, #8]
  20bee2:	60eb      	str	r3, [r5, #12]
  20bee4:	7823      	ldrb	r3, [r4, #0]
  20bee6:	742b      	strb	r3, [r5, #16]
		break;
  20bee8:	e1c2      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_72_bold:
		strncat(fileOpenName,"font_72_bold.bmp",16);
  20beea:	f107 0310 	add.w	r3, r7, #16
  20beee:	4618      	mov	r0, r3
  20bef0:	f7f4 f9a6 	bl	200240 <strlen>
  20bef4:	4603      	mov	r3, r0
  20bef6:	461a      	mov	r2, r3
  20bef8:	f107 0310 	add.w	r3, r7, #16
  20befc:	4413      	add	r3, r2
  20befe:	4a85      	ldr	r2, [pc, #532]	; (20c114 <LCD_LoadFont+0xbf8>)
  20bf00:	461d      	mov	r5, r3
  20bf02:	4614      	mov	r4, r2
  20bf04:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bf06:	6028      	str	r0, [r5, #0]
  20bf08:	6069      	str	r1, [r5, #4]
  20bf0a:	60aa      	str	r2, [r5, #8]
  20bf0c:	60eb      	str	r3, [r5, #12]
  20bf0e:	7823      	ldrb	r3, [r4, #0]
  20bf10:	742b      	strb	r3, [r5, #16]
		break;
  20bf12:	e1ad      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_130_bold:
		strncat(fileOpenName,"font_130_bold.bmp",17);
  20bf14:	f107 0310 	add.w	r3, r7, #16
  20bf18:	4618      	mov	r0, r3
  20bf1a:	f7f4 f991 	bl	200240 <strlen>
  20bf1e:	4603      	mov	r3, r0
  20bf20:	461a      	mov	r2, r3
  20bf22:	f107 0310 	add.w	r3, r7, #16
  20bf26:	4413      	add	r3, r2
  20bf28:	4a7b      	ldr	r2, [pc, #492]	; (20c118 <LCD_LoadFont+0xbfc>)
  20bf2a:	461d      	mov	r5, r3
  20bf2c:	4614      	mov	r4, r2
  20bf2e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bf30:	6028      	str	r0, [r5, #0]
  20bf32:	6069      	str	r1, [r5, #4]
  20bf34:	60aa      	str	r2, [r5, #8]
  20bf36:	60eb      	str	r3, [r5, #12]
  20bf38:	8823      	ldrh	r3, [r4, #0]
  20bf3a:	822b      	strh	r3, [r5, #16]
		break;
  20bf3c:	e198      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_8_italics:
		strncat(fileOpenName,"font_8_italics.bmp",18);
  20bf3e:	f107 0310 	add.w	r3, r7, #16
  20bf42:	4618      	mov	r0, r3
  20bf44:	f7f4 f97c 	bl	200240 <strlen>
  20bf48:	4603      	mov	r3, r0
  20bf4a:	461a      	mov	r2, r3
  20bf4c:	f107 0310 	add.w	r3, r7, #16
  20bf50:	4413      	add	r3, r2
  20bf52:	4a72      	ldr	r2, [pc, #456]	; (20c11c <LCD_LoadFont+0xc00>)
  20bf54:	461d      	mov	r5, r3
  20bf56:	4614      	mov	r4, r2
  20bf58:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bf5a:	6028      	str	r0, [r5, #0]
  20bf5c:	6069      	str	r1, [r5, #4]
  20bf5e:	60aa      	str	r2, [r5, #8]
  20bf60:	60eb      	str	r3, [r5, #12]
  20bf62:	8823      	ldrh	r3, [r4, #0]
  20bf64:	78a2      	ldrb	r2, [r4, #2]
  20bf66:	822b      	strh	r3, [r5, #16]
  20bf68:	4613      	mov	r3, r2
  20bf6a:	74ab      	strb	r3, [r5, #18]
		break;
  20bf6c:	e180      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_9_italics:
		strncat(fileOpenName,"font_9_italics.bmp",18);
  20bf6e:	f107 0310 	add.w	r3, r7, #16
  20bf72:	4618      	mov	r0, r3
  20bf74:	f7f4 f964 	bl	200240 <strlen>
  20bf78:	4603      	mov	r3, r0
  20bf7a:	461a      	mov	r2, r3
  20bf7c:	f107 0310 	add.w	r3, r7, #16
  20bf80:	4413      	add	r3, r2
  20bf82:	4a67      	ldr	r2, [pc, #412]	; (20c120 <LCD_LoadFont+0xc04>)
  20bf84:	461d      	mov	r5, r3
  20bf86:	4614      	mov	r4, r2
  20bf88:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bf8a:	6028      	str	r0, [r5, #0]
  20bf8c:	6069      	str	r1, [r5, #4]
  20bf8e:	60aa      	str	r2, [r5, #8]
  20bf90:	60eb      	str	r3, [r5, #12]
  20bf92:	8823      	ldrh	r3, [r4, #0]
  20bf94:	78a2      	ldrb	r2, [r4, #2]
  20bf96:	822b      	strh	r3, [r5, #16]
  20bf98:	4613      	mov	r3, r2
  20bf9a:	74ab      	strb	r3, [r5, #18]
		break;
  20bf9c:	e168      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_10_italics:
		strncat(fileOpenName,"font_10_italics.bmp",19);
  20bf9e:	f107 0310 	add.w	r3, r7, #16
  20bfa2:	4618      	mov	r0, r3
  20bfa4:	f7f4 f94c 	bl	200240 <strlen>
  20bfa8:	4603      	mov	r3, r0
  20bfaa:	461a      	mov	r2, r3
  20bfac:	f107 0310 	add.w	r3, r7, #16
  20bfb0:	4413      	add	r3, r2
  20bfb2:	4a5c      	ldr	r2, [pc, #368]	; (20c124 <LCD_LoadFont+0xc08>)
  20bfb4:	461d      	mov	r5, r3
  20bfb6:	4614      	mov	r4, r2
  20bfb8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bfba:	6028      	str	r0, [r5, #0]
  20bfbc:	6069      	str	r1, [r5, #4]
  20bfbe:	60aa      	str	r2, [r5, #8]
  20bfc0:	60eb      	str	r3, [r5, #12]
  20bfc2:	6820      	ldr	r0, [r4, #0]
  20bfc4:	6128      	str	r0, [r5, #16]
		break;
  20bfc6:	e153      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_11_italics:
		strncat(fileOpenName,"font_11_italics.bmp",19);
  20bfc8:	f107 0310 	add.w	r3, r7, #16
  20bfcc:	4618      	mov	r0, r3
  20bfce:	f7f4 f937 	bl	200240 <strlen>
  20bfd2:	4603      	mov	r3, r0
  20bfd4:	461a      	mov	r2, r3
  20bfd6:	f107 0310 	add.w	r3, r7, #16
  20bfda:	4413      	add	r3, r2
  20bfdc:	4a52      	ldr	r2, [pc, #328]	; (20c128 <LCD_LoadFont+0xc0c>)
  20bfde:	461d      	mov	r5, r3
  20bfe0:	4614      	mov	r4, r2
  20bfe2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20bfe4:	6028      	str	r0, [r5, #0]
  20bfe6:	6069      	str	r1, [r5, #4]
  20bfe8:	60aa      	str	r2, [r5, #8]
  20bfea:	60eb      	str	r3, [r5, #12]
  20bfec:	6820      	ldr	r0, [r4, #0]
  20bfee:	6128      	str	r0, [r5, #16]
		break;
  20bff0:	e13e      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_12_italics:
		strncat(fileOpenName,"font_12_italics.bmp",19);
  20bff2:	f107 0310 	add.w	r3, r7, #16
  20bff6:	4618      	mov	r0, r3
  20bff8:	f7f4 f922 	bl	200240 <strlen>
  20bffc:	4603      	mov	r3, r0
  20bffe:	461a      	mov	r2, r3
  20c000:	f107 0310 	add.w	r3, r7, #16
  20c004:	4413      	add	r3, r2
  20c006:	4a49      	ldr	r2, [pc, #292]	; (20c12c <LCD_LoadFont+0xc10>)
  20c008:	461d      	mov	r5, r3
  20c00a:	4614      	mov	r4, r2
  20c00c:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c00e:	6028      	str	r0, [r5, #0]
  20c010:	6069      	str	r1, [r5, #4]
  20c012:	60aa      	str	r2, [r5, #8]
  20c014:	60eb      	str	r3, [r5, #12]
  20c016:	6820      	ldr	r0, [r4, #0]
  20c018:	6128      	str	r0, [r5, #16]
		break;
  20c01a:	e129      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_14_italics:
		strncat(fileOpenName,"font_14_italics.bmp",19);
  20c01c:	f107 0310 	add.w	r3, r7, #16
  20c020:	4618      	mov	r0, r3
  20c022:	f7f4 f90d 	bl	200240 <strlen>
  20c026:	4603      	mov	r3, r0
  20c028:	461a      	mov	r2, r3
  20c02a:	f107 0310 	add.w	r3, r7, #16
  20c02e:	4413      	add	r3, r2
  20c030:	4a3f      	ldr	r2, [pc, #252]	; (20c130 <LCD_LoadFont+0xc14>)
  20c032:	461d      	mov	r5, r3
  20c034:	4614      	mov	r4, r2
  20c036:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c038:	6028      	str	r0, [r5, #0]
  20c03a:	6069      	str	r1, [r5, #4]
  20c03c:	60aa      	str	r2, [r5, #8]
  20c03e:	60eb      	str	r3, [r5, #12]
  20c040:	6820      	ldr	r0, [r4, #0]
  20c042:	6128      	str	r0, [r5, #16]
		break;
  20c044:	e114      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_16_italics:
		strncat(fileOpenName,"font_16_italics.bmp",19);
  20c046:	f107 0310 	add.w	r3, r7, #16
  20c04a:	4618      	mov	r0, r3
  20c04c:	f7f4 f8f8 	bl	200240 <strlen>
  20c050:	4603      	mov	r3, r0
  20c052:	461a      	mov	r2, r3
  20c054:	f107 0310 	add.w	r3, r7, #16
  20c058:	4413      	add	r3, r2
  20c05a:	4a36      	ldr	r2, [pc, #216]	; (20c134 <LCD_LoadFont+0xc18>)
  20c05c:	461d      	mov	r5, r3
  20c05e:	4614      	mov	r4, r2
  20c060:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c062:	6028      	str	r0, [r5, #0]
  20c064:	6069      	str	r1, [r5, #4]
  20c066:	60aa      	str	r2, [r5, #8]
  20c068:	60eb      	str	r3, [r5, #12]
  20c06a:	6820      	ldr	r0, [r4, #0]
  20c06c:	6128      	str	r0, [r5, #16]
		break;
  20c06e:	e0ff      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_18_italics:
		strncat(fileOpenName,"font_18_italics.bmp",19);
  20c070:	f107 0310 	add.w	r3, r7, #16
  20c074:	4618      	mov	r0, r3
  20c076:	f7f4 f8e3 	bl	200240 <strlen>
  20c07a:	4603      	mov	r3, r0
  20c07c:	461a      	mov	r2, r3
  20c07e:	f107 0310 	add.w	r3, r7, #16
  20c082:	4413      	add	r3, r2
  20c084:	4a2c      	ldr	r2, [pc, #176]	; (20c138 <LCD_LoadFont+0xc1c>)
  20c086:	461d      	mov	r5, r3
  20c088:	4614      	mov	r4, r2
  20c08a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c08c:	6028      	str	r0, [r5, #0]
  20c08e:	6069      	str	r1, [r5, #4]
  20c090:	60aa      	str	r2, [r5, #8]
  20c092:	60eb      	str	r3, [r5, #12]
  20c094:	6820      	ldr	r0, [r4, #0]
  20c096:	6128      	str	r0, [r5, #16]
		break;
  20c098:	e0ea      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_20_italics:
		strncat(fileOpenName,"font_20_italics.bmp",19);
  20c09a:	f107 0310 	add.w	r3, r7, #16
  20c09e:	4618      	mov	r0, r3
  20c0a0:	f7f4 f8ce 	bl	200240 <strlen>
  20c0a4:	4603      	mov	r3, r0
  20c0a6:	461a      	mov	r2, r3
  20c0a8:	f107 0310 	add.w	r3, r7, #16
  20c0ac:	4413      	add	r3, r2
  20c0ae:	4a23      	ldr	r2, [pc, #140]	; (20c13c <LCD_LoadFont+0xc20>)
  20c0b0:	461d      	mov	r5, r3
  20c0b2:	4614      	mov	r4, r2
  20c0b4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c0b6:	6028      	str	r0, [r5, #0]
  20c0b8:	6069      	str	r1, [r5, #4]
  20c0ba:	60aa      	str	r2, [r5, #8]
  20c0bc:	60eb      	str	r3, [r5, #12]
  20c0be:	6820      	ldr	r0, [r4, #0]
  20c0c0:	6128      	str	r0, [r5, #16]
		break;
  20c0c2:	e0d5      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_22_italics:
		strncat(fileOpenName,"font_22_italics.bmp",19);
  20c0c4:	f107 0310 	add.w	r3, r7, #16
  20c0c8:	4618      	mov	r0, r3
  20c0ca:	f7f4 f8b9 	bl	200240 <strlen>
  20c0ce:	4603      	mov	r3, r0
  20c0d0:	461a      	mov	r2, r3
  20c0d2:	f107 0310 	add.w	r3, r7, #16
  20c0d6:	4413      	add	r3, r2
  20c0d8:	4a19      	ldr	r2, [pc, #100]	; (20c140 <LCD_LoadFont+0xc24>)
  20c0da:	461d      	mov	r5, r3
  20c0dc:	4614      	mov	r4, r2
  20c0de:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c0e0:	6028      	str	r0, [r5, #0]
  20c0e2:	6069      	str	r1, [r5, #4]
  20c0e4:	60aa      	str	r2, [r5, #8]
  20c0e6:	60eb      	str	r3, [r5, #12]
  20c0e8:	6820      	ldr	r0, [r4, #0]
  20c0ea:	6128      	str	r0, [r5, #16]
		break;
  20c0ec:	e0c0      	b.n	20c270 <LCD_LoadFont+0xd54>
  20c0ee:	bf00      	nop
  20c0f0:	00228b2c 	.word	0x00228b2c
  20c0f4:	00228b40 	.word	0x00228b40
  20c0f8:	00228b54 	.word	0x00228b54
  20c0fc:	00228b68 	.word	0x00228b68
  20c100:	00228b7c 	.word	0x00228b7c
  20c104:	00228b90 	.word	0x00228b90
  20c108:	00228ba4 	.word	0x00228ba4
  20c10c:	00228bb8 	.word	0x00228bb8
  20c110:	00228bcc 	.word	0x00228bcc
  20c114:	00228be0 	.word	0x00228be0
  20c118:	00228bf4 	.word	0x00228bf4
  20c11c:	00228c08 	.word	0x00228c08
  20c120:	00228c1c 	.word	0x00228c1c
  20c124:	00228c30 	.word	0x00228c30
  20c128:	00228c44 	.word	0x00228c44
  20c12c:	00228c58 	.word	0x00228c58
  20c130:	00228c6c 	.word	0x00228c6c
  20c134:	00228c80 	.word	0x00228c80
  20c138:	00228c94 	.word	0x00228c94
  20c13c:	00228ca8 	.word	0x00228ca8
  20c140:	00228cbc 	.word	0x00228cbc
	case FONT_24_italics:
		strncat(fileOpenName,"font_24_italics.bmp",19);
  20c144:	f107 0310 	add.w	r3, r7, #16
  20c148:	4618      	mov	r0, r3
  20c14a:	f7f4 f879 	bl	200240 <strlen>
  20c14e:	4603      	mov	r3, r0
  20c150:	461a      	mov	r2, r3
  20c152:	f107 0310 	add.w	r3, r7, #16
  20c156:	4413      	add	r3, r2
  20c158:	4a89      	ldr	r2, [pc, #548]	; (20c380 <LCD_LoadFont+0xe64>)
  20c15a:	461d      	mov	r5, r3
  20c15c:	4614      	mov	r4, r2
  20c15e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c160:	6028      	str	r0, [r5, #0]
  20c162:	6069      	str	r1, [r5, #4]
  20c164:	60aa      	str	r2, [r5, #8]
  20c166:	60eb      	str	r3, [r5, #12]
  20c168:	6820      	ldr	r0, [r4, #0]
  20c16a:	6128      	str	r0, [r5, #16]
		break;
  20c16c:	e080      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_26_italics:
		strncat(fileOpenName,"font_26_italics.bmp",19);
  20c16e:	f107 0310 	add.w	r3, r7, #16
  20c172:	4618      	mov	r0, r3
  20c174:	f7f4 f864 	bl	200240 <strlen>
  20c178:	4603      	mov	r3, r0
  20c17a:	461a      	mov	r2, r3
  20c17c:	f107 0310 	add.w	r3, r7, #16
  20c180:	4413      	add	r3, r2
  20c182:	4a80      	ldr	r2, [pc, #512]	; (20c384 <LCD_LoadFont+0xe68>)
  20c184:	461d      	mov	r5, r3
  20c186:	4614      	mov	r4, r2
  20c188:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c18a:	6028      	str	r0, [r5, #0]
  20c18c:	6069      	str	r1, [r5, #4]
  20c18e:	60aa      	str	r2, [r5, #8]
  20c190:	60eb      	str	r3, [r5, #12]
  20c192:	6820      	ldr	r0, [r4, #0]
  20c194:	6128      	str	r0, [r5, #16]
		break;
  20c196:	e06b      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_28_italics:
		strncat(fileOpenName,"font_28_italics.bmp",19);
  20c198:	f107 0310 	add.w	r3, r7, #16
  20c19c:	4618      	mov	r0, r3
  20c19e:	f7f4 f84f 	bl	200240 <strlen>
  20c1a2:	4603      	mov	r3, r0
  20c1a4:	461a      	mov	r2, r3
  20c1a6:	f107 0310 	add.w	r3, r7, #16
  20c1aa:	4413      	add	r3, r2
  20c1ac:	4a76      	ldr	r2, [pc, #472]	; (20c388 <LCD_LoadFont+0xe6c>)
  20c1ae:	461d      	mov	r5, r3
  20c1b0:	4614      	mov	r4, r2
  20c1b2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c1b4:	6028      	str	r0, [r5, #0]
  20c1b6:	6069      	str	r1, [r5, #4]
  20c1b8:	60aa      	str	r2, [r5, #8]
  20c1ba:	60eb      	str	r3, [r5, #12]
  20c1bc:	6820      	ldr	r0, [r4, #0]
  20c1be:	6128      	str	r0, [r5, #16]
		break;
  20c1c0:	e056      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_36_italics:
		strncat(fileOpenName,"font_36_italics.bmp",19);
  20c1c2:	f107 0310 	add.w	r3, r7, #16
  20c1c6:	4618      	mov	r0, r3
  20c1c8:	f7f4 f83a 	bl	200240 <strlen>
  20c1cc:	4603      	mov	r3, r0
  20c1ce:	461a      	mov	r2, r3
  20c1d0:	f107 0310 	add.w	r3, r7, #16
  20c1d4:	4413      	add	r3, r2
  20c1d6:	4a6d      	ldr	r2, [pc, #436]	; (20c38c <LCD_LoadFont+0xe70>)
  20c1d8:	461d      	mov	r5, r3
  20c1da:	4614      	mov	r4, r2
  20c1dc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c1de:	6028      	str	r0, [r5, #0]
  20c1e0:	6069      	str	r1, [r5, #4]
  20c1e2:	60aa      	str	r2, [r5, #8]
  20c1e4:	60eb      	str	r3, [r5, #12]
  20c1e6:	6820      	ldr	r0, [r4, #0]
  20c1e8:	6128      	str	r0, [r5, #16]
		break;
  20c1ea:	e041      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_48_italics:
		strncat(fileOpenName,"font_48_italics.bmp",19);
  20c1ec:	f107 0310 	add.w	r3, r7, #16
  20c1f0:	4618      	mov	r0, r3
  20c1f2:	f7f4 f825 	bl	200240 <strlen>
  20c1f6:	4603      	mov	r3, r0
  20c1f8:	461a      	mov	r2, r3
  20c1fa:	f107 0310 	add.w	r3, r7, #16
  20c1fe:	4413      	add	r3, r2
  20c200:	4a63      	ldr	r2, [pc, #396]	; (20c390 <LCD_LoadFont+0xe74>)
  20c202:	461d      	mov	r5, r3
  20c204:	4614      	mov	r4, r2
  20c206:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c208:	6028      	str	r0, [r5, #0]
  20c20a:	6069      	str	r1, [r5, #4]
  20c20c:	60aa      	str	r2, [r5, #8]
  20c20e:	60eb      	str	r3, [r5, #12]
  20c210:	6820      	ldr	r0, [r4, #0]
  20c212:	6128      	str	r0, [r5, #16]
		break;
  20c214:	e02c      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_72_italics:
		strncat(fileOpenName,"font_72_italics.bmp",19);
  20c216:	f107 0310 	add.w	r3, r7, #16
  20c21a:	4618      	mov	r0, r3
  20c21c:	f7f4 f810 	bl	200240 <strlen>
  20c220:	4603      	mov	r3, r0
  20c222:	461a      	mov	r2, r3
  20c224:	f107 0310 	add.w	r3, r7, #16
  20c228:	4413      	add	r3, r2
  20c22a:	4a5a      	ldr	r2, [pc, #360]	; (20c394 <LCD_LoadFont+0xe78>)
  20c22c:	461d      	mov	r5, r3
  20c22e:	4614      	mov	r4, r2
  20c230:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c232:	6028      	str	r0, [r5, #0]
  20c234:	6069      	str	r1, [r5, #4]
  20c236:	60aa      	str	r2, [r5, #8]
  20c238:	60eb      	str	r3, [r5, #12]
  20c23a:	6820      	ldr	r0, [r4, #0]
  20c23c:	6128      	str	r0, [r5, #16]
		break;
  20c23e:	e017      	b.n	20c270 <LCD_LoadFont+0xd54>
	case FONT_130_italics:
		strncat(fileOpenName,"font_130_italics.bmp",20);
  20c240:	f107 0310 	add.w	r3, r7, #16
  20c244:	4618      	mov	r0, r3
  20c246:	f7f3 fffb 	bl	200240 <strlen>
  20c24a:	4603      	mov	r3, r0
  20c24c:	461a      	mov	r2, r3
  20c24e:	f107 0310 	add.w	r3, r7, #16
  20c252:	4413      	add	r3, r2
  20c254:	4a50      	ldr	r2, [pc, #320]	; (20c398 <LCD_LoadFont+0xe7c>)
  20c256:	461d      	mov	r5, r3
  20c258:	4614      	mov	r4, r2
  20c25a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
  20c25c:	6028      	str	r0, [r5, #0]
  20c25e:	6069      	str	r1, [r5, #4]
  20c260:	60aa      	str	r2, [r5, #8]
  20c262:	60eb      	str	r3, [r5, #12]
  20c264:	6820      	ldr	r0, [r4, #0]
  20c266:	6128      	str	r0, [r5, #16]
  20c268:	7923      	ldrb	r3, [r4, #4]
  20c26a:	752b      	strb	r3, [r5, #20]
		break;
  20c26c:	e000      	b.n	20c270 <LCD_LoadFont+0xd54>
	default:
		break;
  20c26e:	bf00      	nop
	}

	if(FR_OK!=SDCardFileInfo(fileOpenName,&fontFileSize))
  20c270:	f107 0274 	add.w	r2, r7, #116	; 0x74
  20c274:	f107 0310 	add.w	r3, r7, #16
  20c278:	4611      	mov	r1, r2
  20c27a:	4618      	mov	r0, r3
  20c27c:	f7f5 f9da 	bl	201634 <SDCardFileInfo>
  20c280:	4603      	mov	r3, r0
  20c282:	2b00      	cmp	r3, #0
  20c284:	d005      	beq.n	20c292 <LCD_LoadFont+0xd76>
		return -3;
  20c286:	f06f 0302 	mvn.w	r3, #2
  20c28a:	e075      	b.n	20c378 <LCD_LoadFont+0xe5c>

	while((fontFileSize%4)!=0)
		fontFileSize++;
  20c28c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  20c28e:	3301      	adds	r3, #1
  20c290:	677b      	str	r3, [r7, #116]	; 0x74
	while((fontFileSize%4)!=0)
  20c292:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  20c294:	f003 0303 	and.w	r3, r3, #3
  20c298:	2b00      	cmp	r3, #0
  20c29a:	d1f7      	bne.n	20c28c <LCD_LoadFont+0xd70>

	if(true==DynamicFontMemoryAllocation( fontFileSize, fontIndex) )
  20c29c:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  20c29e:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  20c2a0:	4618      	mov	r0, r3
  20c2a2:	f7fc fbad 	bl	208a00 <DynamicFontMemoryAllocation>
  20c2a6:	4603      	mov	r3, r0
  20c2a8:	2b00      	cmp	r3, #0
  20c2aa:	d03e      	beq.n	20c32a <LCD_LoadFont+0xe0e>
	{
		if(FR_OK!=SDCardFileOpen(1,fileOpenName,FA_READ))
  20c2ac:	f107 0310 	add.w	r3, r7, #16
  20c2b0:	2201      	movs	r2, #1
  20c2b2:	4619      	mov	r1, r3
  20c2b4:	2001      	movs	r0, #1
  20c2b6:	f7f5 f925 	bl	201504 <SDCardFileOpen>
  20c2ba:	4603      	mov	r3, r0
  20c2bc:	2b00      	cmp	r3, #0
  20c2be:	d002      	beq.n	20c2c6 <LCD_LoadFont+0xdaa>
			return -4;
  20c2c0:	f06f 0303 	mvn.w	r3, #3
  20c2c4:	e058      	b.n	20c378 <LCD_LoadFont+0xe5c>
		if(0 > SDCardFileRead(1,Font[fontIndex].pointerToMemoryFont,MAX_FONTS_AND_IMAGES_MEMORY_SIZE))
  20c2c6:	4935      	ldr	r1, [pc, #212]	; (20c39c <LCD_LoadFont+0xe80>)
  20c2c8:	6fba      	ldr	r2, [r7, #120]	; 0x78
  20c2ca:	4613      	mov	r3, r2
  20c2cc:	019b      	lsls	r3, r3, #6
  20c2ce:	4413      	add	r3, r2
  20c2d0:	015b      	lsls	r3, r3, #5
  20c2d2:	440b      	add	r3, r1
  20c2d4:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20c2d8:	681b      	ldr	r3, [r3, #0]
  20c2da:	f44f 02c0 	mov.w	r2, #6291456	; 0x600000
  20c2de:	4619      	mov	r1, r3
  20c2e0:	2001      	movs	r0, #1
  20c2e2:	f7f5 f933 	bl	20154c <SDCardFileRead>
  20c2e6:	4603      	mov	r3, r0
  20c2e8:	2b00      	cmp	r3, #0
  20c2ea:	da02      	bge.n	20c2f2 <LCD_LoadFont+0xdd6>
			return -5;
  20c2ec:	f06f 0304 	mvn.w	r3, #4
  20c2f0:	e042      	b.n	20c378 <LCD_LoadFont+0xe5c>
		if(FR_OK!=SDCardFileClose(1))
  20c2f2:	2001      	movs	r0, #1
  20c2f4:	f7f5 f97e 	bl	2015f4 <SDCardFileClose>
  20c2f8:	4603      	mov	r3, r0
  20c2fa:	2b00      	cmp	r3, #0
  20c2fc:	d002      	beq.n	20c304 <LCD_LoadFont+0xde8>
			return -6;
  20c2fe:	f06f 0305 	mvn.w	r3, #5
  20c302:	e039      	b.n	20c378 <LCD_LoadFont+0xe5c>
		SearchCurrentFont_TablePos(Font[fontIndex].pointerToMemoryFont, fontIndex);
  20c304:	4925      	ldr	r1, [pc, #148]	; (20c39c <LCD_LoadFont+0xe80>)
  20c306:	6fba      	ldr	r2, [r7, #120]	; 0x78
  20c308:	4613      	mov	r3, r2
  20c30a:	019b      	lsls	r3, r3, #6
  20c30c:	4413      	add	r3, r2
  20c30e:	015b      	lsls	r3, r3, #5
  20c310:	440b      	add	r3, r1
  20c312:	f603 0318 	addw	r3, r3, #2072	; 0x818
  20c316:	681b      	ldr	r3, [r3, #0]
  20c318:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  20c31a:	4618      	mov	r0, r3
  20c31c:	f7fc fca6 	bl	208c6c <SearchCurrentFont_TablePos>
	}
	else
		return -7;

	if(fontID < MAX_OPEN_FONTS_SIMULTANEOUSLY)
  20c320:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20c324:	2b10      	cmp	r3, #16
  20c326:	d825      	bhi.n	20c374 <LCD_LoadFont+0xe58>
  20c328:	e002      	b.n	20c330 <LCD_LoadFont+0xe14>
		return -7;
  20c32a:	f06f 0306 	mvn.w	r3, #6
  20c32e:	e023      	b.n	20c378 <LCD_LoadFont+0xe5c>
	{
		FontID[fontID].size = fontSize;
  20c330:	68fa      	ldr	r2, [r7, #12]
  20c332:	491b      	ldr	r1, [pc, #108]	; (20c3a0 <LCD_LoadFont+0xe84>)
  20c334:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20c338:	011b      	lsls	r3, r3, #4
  20c33a:	440b      	add	r3, r1
  20c33c:	601a      	str	r2, [r3, #0]
		FontID[fontID].style = fontStyle;
  20c33e:	68ba      	ldr	r2, [r7, #8]
  20c340:	4917      	ldr	r1, [pc, #92]	; (20c3a0 <LCD_LoadFont+0xe84>)
  20c342:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20c346:	011b      	lsls	r3, r3, #4
  20c348:	440b      	add	r3, r1
  20c34a:	3304      	adds	r3, #4
  20c34c:	601a      	str	r2, [r3, #0]
		FontID[fontID].bkColor = backgroundColor;
  20c34e:	4a14      	ldr	r2, [pc, #80]	; (20c3a0 <LCD_LoadFont+0xe84>)
  20c350:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20c354:	011b      	lsls	r3, r3, #4
  20c356:	4413      	add	r3, r2
  20c358:	3308      	adds	r3, #8
  20c35a:	687a      	ldr	r2, [r7, #4]
  20c35c:	601a      	str	r2, [r3, #0]
		FontID[fontID].color = fontColor;
  20c35e:	4a10      	ldr	r2, [pc, #64]	; (20c3a0 <LCD_LoadFont+0xe84>)
  20c360:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20c364:	011b      	lsls	r3, r3, #4
  20c366:	4413      	add	r3, r2
  20c368:	330c      	adds	r3, #12
  20c36a:	683a      	ldr	r2, [r7, #0]
  20c36c:	601a      	str	r2, [r3, #0]
		return fontID;
  20c36e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20c372:	e001      	b.n	20c378 <LCD_LoadFont+0xe5c>
	}
	else
		return -8;
  20c374:	f06f 0307 	mvn.w	r3, #7
}
  20c378:	4618      	mov	r0, r3
  20c37a:	3780      	adds	r7, #128	; 0x80
  20c37c:	46bd      	mov	sp, r7
  20c37e:	bdb0      	pop	{r4, r5, r7, pc}
  20c380:	00228cd0 	.word	0x00228cd0
  20c384:	00228ce4 	.word	0x00228ce4
  20c388:	00228cf8 	.word	0x00228cf8
  20c38c:	00228d0c 	.word	0x00228d0c
  20c390:	00228d20 	.word	0x00228d20
  20c394:	00228d34 	.word	0x00228d34
  20c398:	00228d48 	.word	0x00228d48
  20c39c:	20003590 	.word	0x20003590
  20c3a0:	20003480 	.word	0x20003480

0020c3a4 <LCD_LoadFont_WhiteBlack>:

int LCD_LoadFont_WhiteBlack(int fontSize, int fontStyle, uint32_t fontID){
  20c3a4:	b580      	push	{r7, lr}
  20c3a6:	b086      	sub	sp, #24
  20c3a8:	af02      	add	r7, sp, #8
  20c3aa:	60f8      	str	r0, [r7, #12]
  20c3ac:	60b9      	str	r1, [r7, #8]
  20c3ae:	607a      	str	r2, [r7, #4]
	return LCD_LoadFont(fontSize,fontStyle,WHITE,BLACK,fontID);
  20c3b0:	687b      	ldr	r3, [r7, #4]
  20c3b2:	9300      	str	r3, [sp, #0]
  20c3b4:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
  20c3b8:	f04f 32ff 	mov.w	r2, #4294967295
  20c3bc:	68b9      	ldr	r1, [r7, #8]
  20c3be:	68f8      	ldr	r0, [r7, #12]
  20c3c0:	f7ff f8ac 	bl	20b51c <LCD_LoadFont>
  20c3c4:	4603      	mov	r3, r0
}
  20c3c6:	4618      	mov	r0, r3
  20c3c8:	3710      	adds	r7, #16
  20c3ca:	46bd      	mov	sp, r7
  20c3cc:	bd80      	pop	{r7, pc}
	...

0020c3d0 <LCD_LoadFont_DarkgrayGreen>:
int LCD_LoadFont_DarkgrayGreen(int fontSize, int fontStyle, uint32_t fontID){
  20c3d0:	b580      	push	{r7, lr}
  20c3d2:	b086      	sub	sp, #24
  20c3d4:	af02      	add	r7, sp, #8
  20c3d6:	60f8      	str	r0, [r7, #12]
  20c3d8:	60b9      	str	r1, [r7, #8]
  20c3da:	607a      	str	r2, [r7, #4]
	return LCD_LoadFont(fontSize,fontStyle,DARKGRAY,MYGREEN,fontID);
  20c3dc:	687b      	ldr	r3, [r7, #4]
  20c3de:	9300      	str	r3, [sp, #0]
  20c3e0:	f06f 13af 	mvn.w	r3, #11468975	; 0xaf00af
  20c3e4:	4a04      	ldr	r2, [pc, #16]	; (20c3f8 <LCD_LoadFont_DarkgrayGreen+0x28>)
  20c3e6:	68b9      	ldr	r1, [r7, #8]
  20c3e8:	68f8      	ldr	r0, [r7, #12]
  20c3ea:	f7ff f897 	bl	20b51c <LCD_LoadFont>
  20c3ee:	4603      	mov	r3, r0
}
  20c3f0:	4618      	mov	r0, r3
  20c3f2:	3710      	adds	r7, #16
  20c3f4:	46bd      	mov	sp, r7
  20c3f6:	bd80      	pop	{r7, pc}
  20c3f8:	ff404040 	.word	0xff404040

0020c3fc <LCD_LoadFont_DarkgrayWhite>:
	return LCD_LoadFont(fontSize,fontStyle,DARKGRAY,MYBLUE,fontID);
}
int LCD_LoadFont_BrownWhite(int fontSize, int fontStyle, uint32_t fontID){
	return LCD_LoadFont(fontSize,fontStyle,BROWN,WHITE,fontID);
}
int LCD_LoadFont_DarkgrayWhite(int fontSize, int fontStyle, uint32_t fontID){
  20c3fc:	b580      	push	{r7, lr}
  20c3fe:	b086      	sub	sp, #24
  20c400:	af02      	add	r7, sp, #8
  20c402:	60f8      	str	r0, [r7, #12]
  20c404:	60b9      	str	r1, [r7, #8]
  20c406:	607a      	str	r2, [r7, #4]
	return LCD_LoadFont(fontSize,fontStyle,DARKGRAY,WHITE,fontID);
  20c408:	687b      	ldr	r3, [r7, #4]
  20c40a:	9300      	str	r3, [sp, #0]
  20c40c:	f04f 33ff 	mov.w	r3, #4294967295
  20c410:	4a04      	ldr	r2, [pc, #16]	; (20c424 <LCD_LoadFont_DarkgrayWhite+0x28>)
  20c412:	68b9      	ldr	r1, [r7, #8]
  20c414:	68f8      	ldr	r0, [r7, #12]
  20c416:	f7ff f881 	bl	20b51c <LCD_LoadFont>
  20c41a:	4603      	mov	r3, r0
}
  20c41c:	4618      	mov	r0, r3
  20c41e:	3710      	adds	r7, #16
  20c420:	46bd      	mov	sp, r7
  20c422:	bd80      	pop	{r7, pc}
  20c424:	ff404040 	.word	0xff404040

0020c428 <LCD_Str>:
int LCD_LoadFont_ChangeColor(int fontSize, int fontStyle, uint32_t fontID){
	return LCD_LoadFont_DarkgrayGreen(fontSize,fontStyle,fontID);
}

StructTxtPxlLen LCD_Str(int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space,uint32_t bkColor, int coeff, int constWidth){
  20c428:	b590      	push	{r4, r7, lr}
  20c42a:	b08f      	sub	sp, #60	; 0x3c
  20c42c:	af0a      	add	r7, sp, #40	; 0x28
  20c42e:	60f8      	str	r0, [r7, #12]
  20c430:	60b9      	str	r1, [r7, #8]
  20c432:	607a      	str	r2, [r7, #4]
  20c434:	603b      	str	r3, [r7, #0]
	return LCD_DrawStr(0,LCD_GetXSize(),LCD_GetYSize(),fontID,Xpos,Ypos,txt, pLcd,OnlyDigits,space,bkColor,coeff,constWidth);
  20c436:	f7fb fab7 	bl	2079a8 <LCD_GetXSize>
  20c43a:	4604      	mov	r4, r0
  20c43c:	f7fb fac8 	bl	2079d0 <LCD_GetYSize>
  20c440:	4602      	mov	r2, r0
  20c442:	68f8      	ldr	r0, [r7, #12]
  20c444:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20c446:	9309      	str	r3, [sp, #36]	; 0x24
  20c448:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c44a:	9308      	str	r3, [sp, #32]
  20c44c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c44e:	9307      	str	r3, [sp, #28]
  20c450:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c452:	9306      	str	r3, [sp, #24]
  20c454:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20c456:	9305      	str	r3, [sp, #20]
  20c458:	4b09      	ldr	r3, [pc, #36]	; (20c480 <LCD_Str+0x58>)
  20c45a:	9304      	str	r3, [sp, #16]
  20c45c:	6a3b      	ldr	r3, [r7, #32]
  20c45e:	9303      	str	r3, [sp, #12]
  20c460:	683b      	ldr	r3, [r7, #0]
  20c462:	9302      	str	r3, [sp, #8]
  20c464:	687b      	ldr	r3, [r7, #4]
  20c466:	9301      	str	r3, [sp, #4]
  20c468:	68bb      	ldr	r3, [r7, #8]
  20c46a:	9300      	str	r3, [sp, #0]
  20c46c:	4613      	mov	r3, r2
  20c46e:	4622      	mov	r2, r4
  20c470:	2100      	movs	r1, #0
  20c472:	f7fe f8d3 	bl	20a61c <LCD_DrawStr>
}
  20c476:	68f8      	ldr	r0, [r7, #12]
  20c478:	3714      	adds	r7, #20
  20c47a:	46bd      	mov	sp, r7
  20c47c:	bd90      	pop	{r4, r7, pc}
  20c47e:	bf00      	nop
  20c480:	c0000000 	.word	0xc0000000

0020c484 <LCD_StrIndirect>:
StructTxtPxlLen LCD_StrWindow(uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space,uint32_t bkColor, int coeff, int constWidth){
	return LCD_DrawStr(posBuff,BkpSizeX,BkpSizeY,fontID, Xpos,Ypos, txt, pLcd,OnlyDigits, space,bkColor,coeff,constWidth);
}
StructTxtPxlLen LCD_StrIndirect(int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth){
  20c484:	b590      	push	{r4, r7, lr}
  20c486:	b091      	sub	sp, #68	; 0x44
  20c488:	af0c      	add	r7, sp, #48	; 0x30
  20c48a:	60f8      	str	r0, [r7, #12]
  20c48c:	60b9      	str	r1, [r7, #8]
  20c48e:	607a      	str	r2, [r7, #4]
  20c490:	603b      	str	r3, [r7, #0]
	return LCD_DrawStrIndirect(0,1,LCD_GetXSize(),LCD_GetYSize(),fontID, Xpos,Ypos, txt, pLcd,OnlyDigits, space,bkColor,coeff,constWidth);
  20c492:	f7fb fa89 	bl	2079a8 <LCD_GetXSize>
  20c496:	4604      	mov	r4, r0
  20c498:	f7fb fa9a 	bl	2079d0 <LCD_GetYSize>
  20c49c:	4602      	mov	r2, r0
  20c49e:	68f8      	ldr	r0, [r7, #12]
  20c4a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20c4a2:	930a      	str	r3, [sp, #40]	; 0x28
  20c4a4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c4a6:	9309      	str	r3, [sp, #36]	; 0x24
  20c4a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c4aa:	9308      	str	r3, [sp, #32]
  20c4ac:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c4ae:	9307      	str	r3, [sp, #28]
  20c4b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20c4b2:	9306      	str	r3, [sp, #24]
  20c4b4:	4b09      	ldr	r3, [pc, #36]	; (20c4dc <LCD_StrIndirect+0x58>)
  20c4b6:	9305      	str	r3, [sp, #20]
  20c4b8:	6a3b      	ldr	r3, [r7, #32]
  20c4ba:	9304      	str	r3, [sp, #16]
  20c4bc:	683b      	ldr	r3, [r7, #0]
  20c4be:	9303      	str	r3, [sp, #12]
  20c4c0:	687b      	ldr	r3, [r7, #4]
  20c4c2:	9302      	str	r3, [sp, #8]
  20c4c4:	68bb      	ldr	r3, [r7, #8]
  20c4c6:	9301      	str	r3, [sp, #4]
  20c4c8:	9200      	str	r2, [sp, #0]
  20c4ca:	4623      	mov	r3, r4
  20c4cc:	2201      	movs	r2, #1
  20c4ce:	2100      	movs	r1, #0
  20c4d0:	f7fe f8d6 	bl	20a680 <LCD_DrawStrIndirect>
}
  20c4d4:	68f8      	ldr	r0, [r7, #12]
  20c4d6:	3714      	adds	r7, #20
  20c4d8:	46bd      	mov	sp, r7
  20c4da:	bd90      	pop	{r4, r7, pc}
  20c4dc:	c0000000 	.word	0xc0000000

0020c4e0 <LCD_StrChangeColor>:
StructTxtPxlLen LCD_StrWindowIndirect(uint32_t posBuff, int Xwin, int Ywin, uint32_t BkpSizeX, uint32_t BkpSizeY, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space,uint32_t bkColor, int coeff, int constWidth){
	StructTxtPxlLen out= LCD_DrawStr(posBuff,BkpSizeX,BkpSizeY,fontID,Xpos,Ypos,txt,pLcd,OnlyDigits,space,bkColor,coeff,constWidth);
	if(out.inChar>0) LCD_DisplayBuff((uint32_t)Xwin,(uint32_t)Ywin,BkpSizeX,BkpSizeY,pLcd+posBuff);
	return out;
}
StructTxtPxlLen LCD_StrChangeColor(int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor,uint8_t maxVal, int constWidth){
  20c4e0:	b590      	push	{r4, r7, lr}
  20c4e2:	b091      	sub	sp, #68	; 0x44
  20c4e4:	af0c      	add	r7, sp, #48	; 0x30
  20c4e6:	60f8      	str	r0, [r7, #12]
  20c4e8:	60b9      	str	r1, [r7, #8]
  20c4ea:	607a      	str	r2, [r7, #4]
  20c4ec:	603b      	str	r3, [r7, #0]
	return LCD_DrawStrChangeColor(0,LCD_GetXSize(),LCD_GetYSize(),fontID,Xpos,Ypos,txt,pLcd,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20c4ee:	f7fb fa5b 	bl	2079a8 <LCD_GetXSize>
  20c4f2:	4604      	mov	r4, r0
  20c4f4:	f7fb fa6c 	bl	2079d0 <LCD_GetYSize>
  20c4f8:	4602      	mov	r2, r0
  20c4fa:	68f8      	ldr	r0, [r7, #12]
  20c4fc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20c4fe:	930a      	str	r3, [sp, #40]	; 0x28
  20c500:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
  20c504:	9309      	str	r3, [sp, #36]	; 0x24
  20c506:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c508:	9308      	str	r3, [sp, #32]
  20c50a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c50c:	9307      	str	r3, [sp, #28]
  20c50e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c510:	9306      	str	r3, [sp, #24]
  20c512:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20c514:	9305      	str	r3, [sp, #20]
  20c516:	4b09      	ldr	r3, [pc, #36]	; (20c53c <LCD_StrChangeColor+0x5c>)
  20c518:	9304      	str	r3, [sp, #16]
  20c51a:	6a3b      	ldr	r3, [r7, #32]
  20c51c:	9303      	str	r3, [sp, #12]
  20c51e:	683b      	ldr	r3, [r7, #0]
  20c520:	9302      	str	r3, [sp, #8]
  20c522:	687b      	ldr	r3, [r7, #4]
  20c524:	9301      	str	r3, [sp, #4]
  20c526:	68bb      	ldr	r3, [r7, #8]
  20c528:	9300      	str	r3, [sp, #0]
  20c52a:	4613      	mov	r3, r2
  20c52c:	4622      	mov	r2, r4
  20c52e:	2100      	movs	r1, #0
  20c530:	f7fe f8da 	bl	20a6e8 <LCD_DrawStrChangeColor>
}
  20c534:	68f8      	ldr	r0, [r7, #12]
  20c536:	3714      	adds	r7, #20
  20c538:	46bd      	mov	sp, r7
  20c53a:	bd90      	pop	{r4, r7, pc}
  20c53c:	c0000000 	.word	0xc0000000

0020c540 <LCD_StrChangeColorIndirect>:
StructTxtPxlLen LCD_StrChangeColorWindow(uint32_t posBuff,uint32_t BkpSizeX,uint32_t BkpSizeY,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor,uint8_t maxVal, int constWidth){
	return LCD_DrawStrChangeColor(posBuff,BkpSizeX,BkpSizeY,fontID,Xpos,Ypos,txt,pLcd,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
}
StructTxtPxlLen LCD_StrChangeColorIndirect(int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor,uint8_t maxVal, int constWidth){
  20c540:	b590      	push	{r4, r7, lr}
  20c542:	b091      	sub	sp, #68	; 0x44
  20c544:	af0c      	add	r7, sp, #48	; 0x30
  20c546:	60f8      	str	r0, [r7, #12]
  20c548:	60b9      	str	r1, [r7, #8]
  20c54a:	607a      	str	r2, [r7, #4]
  20c54c:	603b      	str	r3, [r7, #0]
	return LCD_DrawStrChangeColorIndirect(0,1,LCD_GetXSize(),LCD_GetYSize(),fontID,Xpos,Ypos,txt,pLcd,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20c54e:	f7fb fa2b 	bl	2079a8 <LCD_GetXSize>
  20c552:	4604      	mov	r4, r0
  20c554:	f7fb fa3c 	bl	2079d0 <LCD_GetYSize>
  20c558:	4602      	mov	r2, r0
  20c55a:	68f8      	ldr	r0, [r7, #12]
  20c55c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20c55e:	930b      	str	r3, [sp, #44]	; 0x2c
  20c560:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
  20c564:	930a      	str	r3, [sp, #40]	; 0x28
  20c566:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c568:	9309      	str	r3, [sp, #36]	; 0x24
  20c56a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c56c:	9308      	str	r3, [sp, #32]
  20c56e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c570:	9307      	str	r3, [sp, #28]
  20c572:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20c574:	9306      	str	r3, [sp, #24]
  20c576:	4b0a      	ldr	r3, [pc, #40]	; (20c5a0 <LCD_StrChangeColorIndirect+0x60>)
  20c578:	9305      	str	r3, [sp, #20]
  20c57a:	6a3b      	ldr	r3, [r7, #32]
  20c57c:	9304      	str	r3, [sp, #16]
  20c57e:	683b      	ldr	r3, [r7, #0]
  20c580:	9303      	str	r3, [sp, #12]
  20c582:	687b      	ldr	r3, [r7, #4]
  20c584:	9302      	str	r3, [sp, #8]
  20c586:	68bb      	ldr	r3, [r7, #8]
  20c588:	9301      	str	r3, [sp, #4]
  20c58a:	9200      	str	r2, [sp, #0]
  20c58c:	4623      	mov	r3, r4
  20c58e:	2201      	movs	r2, #1
  20c590:	2100      	movs	r1, #0
  20c592:	f7fe f8ef 	bl	20a774 <LCD_DrawStrChangeColorIndirect>
}
  20c596:	68f8      	ldr	r0, [r7, #12]
  20c598:	3714      	adds	r7, #20
  20c59a:	46bd      	mov	sp, r7
  20c59c:	bd90      	pop	{r4, r7, pc}
  20c59e:	bf00      	nop
  20c5a0:	c0000000 	.word	0xc0000000

0020c5a4 <LCD_StrVar>:
StructTxtPxlLen LCD_StrChangeColorWindowIndirect(uint32_t posBuff, int Xwin, int Ywin,uint32_t BkpSizeX,uint32_t BkpSizeY,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor,uint8_t maxVal, int constWidth){
	StructTxtPxlLen out= LCD_DrawStrChangeColor(posBuff,BkpSizeX,BkpSizeY,fontID,Xpos,Ypos,txt,pLcd,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
	if(out.inChar>0) LCD_DisplayBuff((uint32_t)Xwin,(uint32_t)Ywin,BkpSizeX,BkpSizeY,pLcd+posBuff);
	return out;
}
StructTxtPxlLen LCD_StrVar(int idVar,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth, uint32_t bkScreenColor){
  20c5a4:	b580      	push	{r7, lr}
  20c5a6:	b08c      	sub	sp, #48	; 0x30
  20c5a8:	af06      	add	r7, sp, #24
  20c5aa:	60f8      	str	r0, [r7, #12]
  20c5ac:	60b9      	str	r1, [r7, #8]
  20c5ae:	607a      	str	r2, [r7, #4]
  20c5b0:	603b      	str	r3, [r7, #0]
	StructTxtPxlLen temp;
	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  20c5b2:	68bb      	ldr	r3, [r7, #8]
  20c5b4:	2b27      	cmp	r3, #39	; 0x27
  20c5b6:	f300 80cf 	bgt.w	20c758 <LCD_StrVar+0x1b4>
	{
		temp = LCD_Str(fontID,Xpos,Ypos,txt,OnlyDigits,space,bkColor,coeff,constWidth);
  20c5ba:	f107 0010 	add.w	r0, r7, #16
  20c5be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20c5c0:	9305      	str	r3, [sp, #20]
  20c5c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20c5c4:	9304      	str	r3, [sp, #16]
  20c5c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c5c8:	9303      	str	r3, [sp, #12]
  20c5ca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c5cc:	9302      	str	r3, [sp, #8]
  20c5ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c5d0:	9301      	str	r3, [sp, #4]
  20c5d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20c5d4:	9300      	str	r3, [sp, #0]
  20c5d6:	6a3b      	ldr	r3, [r7, #32]
  20c5d8:	683a      	ldr	r2, [r7, #0]
  20c5da:	6879      	ldr	r1, [r7, #4]
  20c5dc:	f7ff ff24 	bl	20c428 <LCD_Str>
		if((temp.height==0)&&(temp.inChar==0)&&(temp.inPixel==0))
  20c5e0:	8abb      	ldrh	r3, [r7, #20]
  20c5e2:	2b00      	cmp	r3, #0
  20c5e4:	d10e      	bne.n	20c604 <LCD_StrVar+0x60>
  20c5e6:	8a3b      	ldrh	r3, [r7, #16]
  20c5e8:	2b00      	cmp	r3, #0
  20c5ea:	d10b      	bne.n	20c604 <LCD_StrVar+0x60>
  20c5ec:	8a7b      	ldrh	r3, [r7, #18]
  20c5ee:	2b00      	cmp	r3, #0
  20c5f0:	d108      	bne.n	20c604 <LCD_StrVar+0x60>
			return temp;
  20c5f2:	68fb      	ldr	r3, [r7, #12]
  20c5f4:	461a      	mov	r2, r3
  20c5f6:	f107 0310 	add.w	r3, r7, #16
  20c5fa:	6818      	ldr	r0, [r3, #0]
  20c5fc:	6010      	str	r0, [r2, #0]
  20c5fe:	889b      	ldrh	r3, [r3, #4]
  20c600:	8093      	strh	r3, [r2, #4]
  20c602:	e0af      	b.n	20c764 <LCD_StrVar+0x1c0>
		FontVar[idVar].id=fontID;
  20c604:	687b      	ldr	r3, [r7, #4]
  20c606:	b298      	uxth	r0, r3
  20c608:	4958      	ldr	r1, [pc, #352]	; (20c76c <LCD_StrVar+0x1c8>)
  20c60a:	68ba      	ldr	r2, [r7, #8]
  20c60c:	4613      	mov	r3, r2
  20c60e:	011b      	lsls	r3, r3, #4
  20c610:	1a9b      	subs	r3, r3, r2
  20c612:	009b      	lsls	r3, r3, #2
  20c614:	440b      	add	r3, r1
  20c616:	4602      	mov	r2, r0
  20c618:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].xPos=Xpos;
  20c61a:	683b      	ldr	r3, [r7, #0]
  20c61c:	b298      	uxth	r0, r3
  20c61e:	4953      	ldr	r1, [pc, #332]	; (20c76c <LCD_StrVar+0x1c8>)
  20c620:	68ba      	ldr	r2, [r7, #8]
  20c622:	4613      	mov	r3, r2
  20c624:	011b      	lsls	r3, r3, #4
  20c626:	1a9b      	subs	r3, r3, r2
  20c628:	009b      	lsls	r3, r3, #2
  20c62a:	440b      	add	r3, r1
  20c62c:	3302      	adds	r3, #2
  20c62e:	4602      	mov	r2, r0
  20c630:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos=Ypos;
  20c632:	6a3b      	ldr	r3, [r7, #32]
  20c634:	b298      	uxth	r0, r3
  20c636:	494d      	ldr	r1, [pc, #308]	; (20c76c <LCD_StrVar+0x1c8>)
  20c638:	68ba      	ldr	r2, [r7, #8]
  20c63a:	4613      	mov	r3, r2
  20c63c:	011b      	lsls	r3, r3, #4
  20c63e:	1a9b      	subs	r3, r3, r2
  20c640:	009b      	lsls	r3, r3, #2
  20c642:	440b      	add	r3, r1
  20c644:	3304      	adds	r3, #4
  20c646:	4602      	mov	r2, r0
  20c648:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightType=OnlyDigits;
  20c64a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c64c:	b258      	sxtb	r0, r3
  20c64e:	4947      	ldr	r1, [pc, #284]	; (20c76c <LCD_StrVar+0x1c8>)
  20c650:	68ba      	ldr	r2, [r7, #8]
  20c652:	4613      	mov	r3, r2
  20c654:	011b      	lsls	r3, r3, #4
  20c656:	1a9b      	subs	r3, r3, r2
  20c658:	009b      	lsls	r3, r3, #2
  20c65a:	440b      	add	r3, r1
  20c65c:	3306      	adds	r3, #6
  20c65e:	4602      	mov	r2, r0
  20c660:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].space=space;
  20c662:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c664:	b2d8      	uxtb	r0, r3
  20c666:	4941      	ldr	r1, [pc, #260]	; (20c76c <LCD_StrVar+0x1c8>)
  20c668:	68ba      	ldr	r2, [r7, #8]
  20c66a:	4613      	mov	r3, r2
  20c66c:	011b      	lsls	r3, r3, #4
  20c66e:	1a9b      	subs	r3, r3, r2
  20c670:	009b      	lsls	r3, r3, #2
  20c672:	440b      	add	r3, r1
  20c674:	3307      	adds	r3, #7
  20c676:	4602      	mov	r2, r0
  20c678:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].bkColor=bkColor;
  20c67a:	493c      	ldr	r1, [pc, #240]	; (20c76c <LCD_StrVar+0x1c8>)
  20c67c:	68ba      	ldr	r2, [r7, #8]
  20c67e:	4613      	mov	r3, r2
  20c680:	011b      	lsls	r3, r3, #4
  20c682:	1a9b      	subs	r3, r3, r2
  20c684:	009b      	lsls	r3, r3, #2
  20c686:	440b      	add	r3, r1
  20c688:	3308      	adds	r3, #8
  20c68a:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  20c68c:	601a      	str	r2, [r3, #0]
		FontVar[idVar].bkScreenColor=bkScreenColor;
  20c68e:	4937      	ldr	r1, [pc, #220]	; (20c76c <LCD_StrVar+0x1c8>)
  20c690:	68ba      	ldr	r2, [r7, #8]
  20c692:	4613      	mov	r3, r2
  20c694:	011b      	lsls	r3, r3, #4
  20c696:	1a9b      	subs	r3, r3, r2
  20c698:	009b      	lsls	r3, r3, #2
  20c69a:	440b      	add	r3, r1
  20c69c:	330c      	adds	r3, #12
  20c69e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20c6a0:	601a      	str	r2, [r3, #0]
		FontVar[idVar].coeff=coeff;
  20c6a2:	4932      	ldr	r1, [pc, #200]	; (20c76c <LCD_StrVar+0x1c8>)
  20c6a4:	68ba      	ldr	r2, [r7, #8]
  20c6a6:	4613      	mov	r3, r2
  20c6a8:	011b      	lsls	r3, r3, #4
  20c6aa:	1a9b      	subs	r3, r3, r2
  20c6ac:	009b      	lsls	r3, r3, #2
  20c6ae:	440b      	add	r3, r1
  20c6b0:	3318      	adds	r3, #24
  20c6b2:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20c6b4:	601a      	str	r2, [r3, #0]
		FontVar[idVar].widthType=constWidth;
  20c6b6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20c6b8:	b2d8      	uxtb	r0, r3
  20c6ba:	492c      	ldr	r1, [pc, #176]	; (20c76c <LCD_StrVar+0x1c8>)
  20c6bc:	68ba      	ldr	r2, [r7, #8]
  20c6be:	4613      	mov	r3, r2
  20c6c0:	011b      	lsls	r3, r3, #4
  20c6c2:	1a9b      	subs	r3, r3, r2
  20c6c4:	009b      	lsls	r3, r3, #2
  20c6c6:	440b      	add	r3, r1
  20c6c8:	331c      	adds	r3, #28
  20c6ca:	4602      	mov	r2, r0
  20c6cc:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].xPos_prev = FontVar[idVar].xPos;
  20c6ce:	4927      	ldr	r1, [pc, #156]	; (20c76c <LCD_StrVar+0x1c8>)
  20c6d0:	68ba      	ldr	r2, [r7, #8]
  20c6d2:	4613      	mov	r3, r2
  20c6d4:	011b      	lsls	r3, r3, #4
  20c6d6:	1a9b      	subs	r3, r3, r2
  20c6d8:	009b      	lsls	r3, r3, #2
  20c6da:	440b      	add	r3, r1
  20c6dc:	3302      	adds	r3, #2
  20c6de:	8818      	ldrh	r0, [r3, #0]
  20c6e0:	4922      	ldr	r1, [pc, #136]	; (20c76c <LCD_StrVar+0x1c8>)
  20c6e2:	68ba      	ldr	r2, [r7, #8]
  20c6e4:	4613      	mov	r3, r2
  20c6e6:	011b      	lsls	r3, r3, #4
  20c6e8:	1a9b      	subs	r3, r3, r2
  20c6ea:	009b      	lsls	r3, r3, #2
  20c6ec:	440b      	add	r3, r1
  20c6ee:	331e      	adds	r3, #30
  20c6f0:	4602      	mov	r2, r0
  20c6f2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos_prev = FontVar[idVar].yPos;
  20c6f4:	491d      	ldr	r1, [pc, #116]	; (20c76c <LCD_StrVar+0x1c8>)
  20c6f6:	68ba      	ldr	r2, [r7, #8]
  20c6f8:	4613      	mov	r3, r2
  20c6fa:	011b      	lsls	r3, r3, #4
  20c6fc:	1a9b      	subs	r3, r3, r2
  20c6fe:	009b      	lsls	r3, r3, #2
  20c700:	440b      	add	r3, r1
  20c702:	3304      	adds	r3, #4
  20c704:	8818      	ldrh	r0, [r3, #0]
  20c706:	4919      	ldr	r1, [pc, #100]	; (20c76c <LCD_StrVar+0x1c8>)
  20c708:	68ba      	ldr	r2, [r7, #8]
  20c70a:	4613      	mov	r3, r2
  20c70c:	011b      	lsls	r3, r3, #4
  20c70e:	1a9b      	subs	r3, r3, r2
  20c710:	009b      	lsls	r3, r3, #2
  20c712:	440b      	add	r3, r1
  20c714:	3320      	adds	r3, #32
  20c716:	4602      	mov	r2, r0
  20c718:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].widthPxl_prev = temp.inPixel;
  20c71a:	8a78      	ldrh	r0, [r7, #18]
  20c71c:	4913      	ldr	r1, [pc, #76]	; (20c76c <LCD_StrVar+0x1c8>)
  20c71e:	68ba      	ldr	r2, [r7, #8]
  20c720:	4613      	mov	r3, r2
  20c722:	011b      	lsls	r3, r3, #4
  20c724:	1a9b      	subs	r3, r3, r2
  20c726:	009b      	lsls	r3, r3, #2
  20c728:	440b      	add	r3, r1
  20c72a:	3322      	adds	r3, #34	; 0x22
  20c72c:	4602      	mov	r2, r0
  20c72e:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightPxl_prev = temp.height;
  20c730:	8ab8      	ldrh	r0, [r7, #20]
  20c732:	490e      	ldr	r1, [pc, #56]	; (20c76c <LCD_StrVar+0x1c8>)
  20c734:	68ba      	ldr	r2, [r7, #8]
  20c736:	4613      	mov	r3, r2
  20c738:	011b      	lsls	r3, r3, #4
  20c73a:	1a9b      	subs	r3, r3, r2
  20c73c:	009b      	lsls	r3, r3, #2
  20c73e:	440b      	add	r3, r1
  20c740:	3324      	adds	r3, #36	; 0x24
  20c742:	4602      	mov	r2, r0
  20c744:	801a      	strh	r2, [r3, #0]
		return temp;
  20c746:	68fb      	ldr	r3, [r7, #12]
  20c748:	461a      	mov	r2, r3
  20c74a:	f107 0310 	add.w	r3, r7, #16
  20c74e:	6818      	ldr	r0, [r3, #0]
  20c750:	6010      	str	r0, [r2, #0]
  20c752:	889b      	ldrh	r3, [r3, #4]
  20c754:	8093      	strh	r3, [r2, #4]
  20c756:	e005      	b.n	20c764 <LCD_StrVar+0x1c0>
	}
	else return StructTxtPxlLen_ZeroValue;
  20c758:	68fb      	ldr	r3, [r7, #12]
  20c75a:	4a05      	ldr	r2, [pc, #20]	; (20c770 <LCD_StrVar+0x1cc>)
  20c75c:	6810      	ldr	r0, [r2, #0]
  20c75e:	6018      	str	r0, [r3, #0]
  20c760:	8892      	ldrh	r2, [r2, #4]
  20c762:	809a      	strh	r2, [r3, #4]
}
  20c764:	68f8      	ldr	r0, [r7, #12]
  20c766:	3718      	adds	r7, #24
  20c768:	46bd      	mov	sp, r7
  20c76a:	bd80      	pop	{r7, pc}
  20c76c:	2000f818 	.word	0x2000f818
  20c770:	20003474 	.word	0x20003474

0020c774 <LCD_StrDescrVar>:
StructTxtPxlLen LCD_StrDescrVar(int idVar,int fontID, int Xpos, int Ypos, char *txtDescr, char *txtVar, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth, uint32_t bkScreenColor){
  20c774:	b580      	push	{r7, lr}
  20c776:	b08e      	sub	sp, #56	; 0x38
  20c778:	af08      	add	r7, sp, #32
  20c77a:	60f8      	str	r0, [r7, #12]
  20c77c:	60b9      	str	r1, [r7, #8]
  20c77e:	607a      	str	r2, [r7, #4]
  20c780:	603b      	str	r3, [r7, #0]
	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  20c782:	68bb      	ldr	r3, [r7, #8]
  20c784:	2b27      	cmp	r3, #39	; 0x27
  20c786:	dc2d      	bgt.n	20c7e4 <LCD_StrDescrVar+0x70>
		return LCD_StrVar(idVar,fontID, Xpos+LCD_Str(fontID,Xpos,Ypos,txtDescr,OnlyDigits,space,bkColor,coeff,0).inPixel, Ypos,txtVar,OnlyDigits,space,bkColor,coeff,constWidth,bkScreenColor);
  20c788:	f107 0010 	add.w	r0, r7, #16
  20c78c:	2300      	movs	r3, #0
  20c78e:	9305      	str	r3, [sp, #20]
  20c790:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20c792:	9304      	str	r3, [sp, #16]
  20c794:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20c796:	9303      	str	r3, [sp, #12]
  20c798:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c79a:	9302      	str	r3, [sp, #8]
  20c79c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c79e:	9301      	str	r3, [sp, #4]
  20c7a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20c7a2:	9300      	str	r3, [sp, #0]
  20c7a4:	6a3b      	ldr	r3, [r7, #32]
  20c7a6:	683a      	ldr	r2, [r7, #0]
  20c7a8:	6879      	ldr	r1, [r7, #4]
  20c7aa:	f7ff fe3d 	bl	20c428 <LCD_Str>
  20c7ae:	8a7b      	ldrh	r3, [r7, #18]
  20c7b0:	461a      	mov	r2, r3
  20c7b2:	683b      	ldr	r3, [r7, #0]
  20c7b4:	441a      	add	r2, r3
  20c7b6:	68f8      	ldr	r0, [r7, #12]
  20c7b8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20c7ba:	9307      	str	r3, [sp, #28]
  20c7bc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20c7be:	9306      	str	r3, [sp, #24]
  20c7c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20c7c2:	9305      	str	r3, [sp, #20]
  20c7c4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20c7c6:	9304      	str	r3, [sp, #16]
  20c7c8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c7ca:	9303      	str	r3, [sp, #12]
  20c7cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20c7ce:	9302      	str	r3, [sp, #8]
  20c7d0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20c7d2:	9301      	str	r3, [sp, #4]
  20c7d4:	6a3b      	ldr	r3, [r7, #32]
  20c7d6:	9300      	str	r3, [sp, #0]
  20c7d8:	4613      	mov	r3, r2
  20c7da:	687a      	ldr	r2, [r7, #4]
  20c7dc:	68b9      	ldr	r1, [r7, #8]
  20c7de:	f7ff fee1 	bl	20c5a4 <LCD_StrVar>
  20c7e2:	e005      	b.n	20c7f0 <LCD_StrDescrVar+0x7c>
	else return StructTxtPxlLen_ZeroValue;
  20c7e4:	68fb      	ldr	r3, [r7, #12]
  20c7e6:	4a04      	ldr	r2, [pc, #16]	; (20c7f8 <LCD_StrDescrVar+0x84>)
  20c7e8:	6810      	ldr	r0, [r2, #0]
  20c7ea:	6018      	str	r0, [r3, #0]
  20c7ec:	8892      	ldrh	r2, [r2, #4]
  20c7ee:	809a      	strh	r2, [r3, #4]
}
  20c7f0:	68f8      	ldr	r0, [r7, #12]
  20c7f2:	3718      	adds	r7, #24
  20c7f4:	46bd      	mov	sp, r7
  20c7f6:	bd80      	pop	{r7, pc}
  20c7f8:	20003474 	.word	0x20003474

0020c7fc <LCD_DimensionBkCorrect>:

static void LCD_DimensionBkCorrect(int idVar, StructTxtPxlLen temp, uint32_t *LcdBuffer)
{
  20c7fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  20c7fe:	b097      	sub	sp, #92	; 0x5c
  20c800:	af08      	add	r7, sp, #32
  20c802:	6178      	str	r0, [r7, #20]
  20c804:	f107 000c 	add.w	r0, r7, #12
  20c808:	e880 0006 	stmia.w	r0, {r1, r2}
  20c80c:	60bb      	str	r3, [r7, #8]
	int xEnd_prev = FontVar[idVar].xPos_prev + FontVar[idVar].widthPxl_prev;
  20c80e:	49b8      	ldr	r1, [pc, #736]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c810:	697a      	ldr	r2, [r7, #20]
  20c812:	4613      	mov	r3, r2
  20c814:	011b      	lsls	r3, r3, #4
  20c816:	1a9b      	subs	r3, r3, r2
  20c818:	009b      	lsls	r3, r3, #2
  20c81a:	440b      	add	r3, r1
  20c81c:	331e      	adds	r3, #30
  20c81e:	881b      	ldrh	r3, [r3, #0]
  20c820:	4618      	mov	r0, r3
  20c822:	49b3      	ldr	r1, [pc, #716]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c824:	697a      	ldr	r2, [r7, #20]
  20c826:	4613      	mov	r3, r2
  20c828:	011b      	lsls	r3, r3, #4
  20c82a:	1a9b      	subs	r3, r3, r2
  20c82c:	009b      	lsls	r3, r3, #2
  20c82e:	440b      	add	r3, r1
  20c830:	3322      	adds	r3, #34	; 0x22
  20c832:	881b      	ldrh	r3, [r3, #0]
  20c834:	4403      	add	r3, r0
  20c836:	637b      	str	r3, [r7, #52]	; 0x34
	int xEnd		  = FontVar[idVar].xPos 	  + temp.inPixel;
  20c838:	49ad      	ldr	r1, [pc, #692]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c83a:	697a      	ldr	r2, [r7, #20]
  20c83c:	4613      	mov	r3, r2
  20c83e:	011b      	lsls	r3, r3, #4
  20c840:	1a9b      	subs	r3, r3, r2
  20c842:	009b      	lsls	r3, r3, #2
  20c844:	440b      	add	r3, r1
  20c846:	3302      	adds	r3, #2
  20c848:	881b      	ldrh	r3, [r3, #0]
  20c84a:	461a      	mov	r2, r3
  20c84c:	89fb      	ldrh	r3, [r7, #14]
  20c84e:	4413      	add	r3, r2
  20c850:	633b      	str	r3, [r7, #48]	; 0x30
	int yEnd_prev = FontVar[idVar].yPos_prev + FontVar[idVar].heightPxl_prev;
  20c852:	49a7      	ldr	r1, [pc, #668]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c854:	697a      	ldr	r2, [r7, #20]
  20c856:	4613      	mov	r3, r2
  20c858:	011b      	lsls	r3, r3, #4
  20c85a:	1a9b      	subs	r3, r3, r2
  20c85c:	009b      	lsls	r3, r3, #2
  20c85e:	440b      	add	r3, r1
  20c860:	3320      	adds	r3, #32
  20c862:	881b      	ldrh	r3, [r3, #0]
  20c864:	4618      	mov	r0, r3
  20c866:	49a2      	ldr	r1, [pc, #648]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c868:	697a      	ldr	r2, [r7, #20]
  20c86a:	4613      	mov	r3, r2
  20c86c:	011b      	lsls	r3, r3, #4
  20c86e:	1a9b      	subs	r3, r3, r2
  20c870:	009b      	lsls	r3, r3, #2
  20c872:	440b      	add	r3, r1
  20c874:	3324      	adds	r3, #36	; 0x24
  20c876:	881b      	ldrh	r3, [r3, #0]
  20c878:	4403      	add	r3, r0
  20c87a:	62fb      	str	r3, [r7, #44]	; 0x2c
	int yEnd		  = FontVar[idVar].yPos 	  + temp.height;
  20c87c:	499c      	ldr	r1, [pc, #624]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c87e:	697a      	ldr	r2, [r7, #20]
  20c880:	4613      	mov	r3, r2
  20c882:	011b      	lsls	r3, r3, #4
  20c884:	1a9b      	subs	r3, r3, r2
  20c886:	009b      	lsls	r3, r3, #2
  20c888:	440b      	add	r3, r1
  20c88a:	3304      	adds	r3, #4
  20c88c:	881b      	ldrh	r3, [r3, #0]
  20c88e:	461a      	mov	r2, r3
  20c890:	8a3b      	ldrh	r3, [r7, #16]
  20c892:	4413      	add	r3, r2
  20c894:	62bb      	str	r3, [r7, #40]	; 0x28

	if(FontVar[idVar].xPos > FontVar[idVar].xPos_prev){
  20c896:	4996      	ldr	r1, [pc, #600]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c898:	697a      	ldr	r2, [r7, #20]
  20c89a:	4613      	mov	r3, r2
  20c89c:	011b      	lsls	r3, r3, #4
  20c89e:	1a9b      	subs	r3, r3, r2
  20c8a0:	009b      	lsls	r3, r3, #2
  20c8a2:	440b      	add	r3, r1
  20c8a4:	3302      	adds	r3, #2
  20c8a6:	8819      	ldrh	r1, [r3, #0]
  20c8a8:	4891      	ldr	r0, [pc, #580]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c8aa:	697a      	ldr	r2, [r7, #20]
  20c8ac:	4613      	mov	r3, r2
  20c8ae:	011b      	lsls	r3, r3, #4
  20c8b0:	1a9b      	subs	r3, r3, r2
  20c8b2:	009b      	lsls	r3, r3, #2
  20c8b4:	4403      	add	r3, r0
  20c8b6:	331e      	adds	r3, #30
  20c8b8:	881b      	ldrh	r3, [r3, #0]
  20c8ba:	4299      	cmp	r1, r3
  20c8bc:	d97c      	bls.n	20c9b8 <LCD_DimensionBkCorrect+0x1bc>
		int width=FontVar[idVar].xPos-FontVar[idVar].xPos_prev;
  20c8be:	498c      	ldr	r1, [pc, #560]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c8c0:	697a      	ldr	r2, [r7, #20]
  20c8c2:	4613      	mov	r3, r2
  20c8c4:	011b      	lsls	r3, r3, #4
  20c8c6:	1a9b      	subs	r3, r3, r2
  20c8c8:	009b      	lsls	r3, r3, #2
  20c8ca:	440b      	add	r3, r1
  20c8cc:	3302      	adds	r3, #2
  20c8ce:	881b      	ldrh	r3, [r3, #0]
  20c8d0:	4618      	mov	r0, r3
  20c8d2:	4987      	ldr	r1, [pc, #540]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c8d4:	697a      	ldr	r2, [r7, #20]
  20c8d6:	4613      	mov	r3, r2
  20c8d8:	011b      	lsls	r3, r3, #4
  20c8da:	1a9b      	subs	r3, r3, r2
  20c8dc:	009b      	lsls	r3, r3, #2
  20c8de:	440b      	add	r3, r1
  20c8e0:	331e      	adds	r3, #30
  20c8e2:	881b      	ldrh	r3, [r3, #0]
  20c8e4:	1ac3      	subs	r3, r0, r3
  20c8e6:	627b      	str	r3, [r7, #36]	; 0x24
		LCD_RectangleBuff(LcdBuffer,0,width,FontVar[idVar].heightPxl_prev,0,0,width,FontVar[idVar].heightPxl_prev,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor);
  20c8e8:	6a7e      	ldr	r6, [r7, #36]	; 0x24
  20c8ea:	4981      	ldr	r1, [pc, #516]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c8ec:	697a      	ldr	r2, [r7, #20]
  20c8ee:	4613      	mov	r3, r2
  20c8f0:	011b      	lsls	r3, r3, #4
  20c8f2:	1a9b      	subs	r3, r3, r2
  20c8f4:	009b      	lsls	r3, r3, #2
  20c8f6:	440b      	add	r3, r1
  20c8f8:	3324      	adds	r3, #36	; 0x24
  20c8fa:	881b      	ldrh	r3, [r3, #0]
  20c8fc:	469e      	mov	lr, r3
  20c8fe:	6a79      	ldr	r1, [r7, #36]	; 0x24
  20c900:	487b      	ldr	r0, [pc, #492]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c902:	697a      	ldr	r2, [r7, #20]
  20c904:	4613      	mov	r3, r2
  20c906:	011b      	lsls	r3, r3, #4
  20c908:	1a9b      	subs	r3, r3, r2
  20c90a:	009b      	lsls	r3, r3, #2
  20c90c:	4403      	add	r3, r0
  20c90e:	3324      	adds	r3, #36	; 0x24
  20c910:	881b      	ldrh	r3, [r3, #0]
  20c912:	607b      	str	r3, [r7, #4]
  20c914:	4876      	ldr	r0, [pc, #472]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c916:	697a      	ldr	r2, [r7, #20]
  20c918:	4613      	mov	r3, r2
  20c91a:	011b      	lsls	r3, r3, #4
  20c91c:	1a9b      	subs	r3, r3, r2
  20c91e:	009b      	lsls	r3, r3, #2
  20c920:	4403      	add	r3, r0
  20c922:	330c      	adds	r3, #12
  20c924:	6818      	ldr	r0, [r3, #0]
  20c926:	4c72      	ldr	r4, [pc, #456]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c928:	697a      	ldr	r2, [r7, #20]
  20c92a:	4613      	mov	r3, r2
  20c92c:	011b      	lsls	r3, r3, #4
  20c92e:	1a9b      	subs	r3, r3, r2
  20c930:	009b      	lsls	r3, r3, #2
  20c932:	4423      	add	r3, r4
  20c934:	330c      	adds	r3, #12
  20c936:	681c      	ldr	r4, [r3, #0]
  20c938:	4d6d      	ldr	r5, [pc, #436]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c93a:	697a      	ldr	r2, [r7, #20]
  20c93c:	4613      	mov	r3, r2
  20c93e:	011b      	lsls	r3, r3, #4
  20c940:	1a9b      	subs	r3, r3, r2
  20c942:	009b      	lsls	r3, r3, #2
  20c944:	442b      	add	r3, r5
  20c946:	330c      	adds	r3, #12
  20c948:	681b      	ldr	r3, [r3, #0]
  20c94a:	9306      	str	r3, [sp, #24]
  20c94c:	9405      	str	r4, [sp, #20]
  20c94e:	9004      	str	r0, [sp, #16]
  20c950:	687b      	ldr	r3, [r7, #4]
  20c952:	9303      	str	r3, [sp, #12]
  20c954:	9102      	str	r1, [sp, #8]
  20c956:	2300      	movs	r3, #0
  20c958:	9301      	str	r3, [sp, #4]
  20c95a:	2300      	movs	r3, #0
  20c95c:	9300      	str	r3, [sp, #0]
  20c95e:	4673      	mov	r3, lr
  20c960:	4632      	mov	r2, r6
  20c962:	2100      	movs	r1, #0
  20c964:	68b8      	ldr	r0, [r7, #8]
  20c966:	f7fb fb29 	bl	207fbc <LCD_RectangleBuff>
		LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos_prev,(uint32_t)FontVar[idVar].yPos_prev,width,FontVar[idVar].heightPxl_prev,pLcd+0);
  20c96a:	4961      	ldr	r1, [pc, #388]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c96c:	697a      	ldr	r2, [r7, #20]
  20c96e:	4613      	mov	r3, r2
  20c970:	011b      	lsls	r3, r3, #4
  20c972:	1a9b      	subs	r3, r3, r2
  20c974:	009b      	lsls	r3, r3, #2
  20c976:	440b      	add	r3, r1
  20c978:	331e      	adds	r3, #30
  20c97a:	881b      	ldrh	r3, [r3, #0]
  20c97c:	461c      	mov	r4, r3
  20c97e:	495c      	ldr	r1, [pc, #368]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c980:	697a      	ldr	r2, [r7, #20]
  20c982:	4613      	mov	r3, r2
  20c984:	011b      	lsls	r3, r3, #4
  20c986:	1a9b      	subs	r3, r3, r2
  20c988:	009b      	lsls	r3, r3, #2
  20c98a:	440b      	add	r3, r1
  20c98c:	3320      	adds	r3, #32
  20c98e:	881b      	ldrh	r3, [r3, #0]
  20c990:	461d      	mov	r5, r3
  20c992:	6a78      	ldr	r0, [r7, #36]	; 0x24
  20c994:	4956      	ldr	r1, [pc, #344]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c996:	697a      	ldr	r2, [r7, #20]
  20c998:	4613      	mov	r3, r2
  20c99a:	011b      	lsls	r3, r3, #4
  20c99c:	1a9b      	subs	r3, r3, r2
  20c99e:	009b      	lsls	r3, r3, #2
  20c9a0:	440b      	add	r3, r1
  20c9a2:	3324      	adds	r3, #36	; 0x24
  20c9a4:	881b      	ldrh	r3, [r3, #0]
  20c9a6:	461a      	mov	r2, r3
  20c9a8:	4b52      	ldr	r3, [pc, #328]	; (20caf4 <LCD_DimensionBkCorrect+0x2f8>)
  20c9aa:	9300      	str	r3, [sp, #0]
  20c9ac:	4613      	mov	r3, r2
  20c9ae:	4602      	mov	r2, r0
  20c9b0:	4629      	mov	r1, r5
  20c9b2:	4620      	mov	r0, r4
  20c9b4:	f7fb f86e 	bl	207a94 <LCD_DisplayBuff>
	}
	if(xEnd_prev > xEnd){
  20c9b8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20c9ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c9bc:	429a      	cmp	r2, r3
  20c9be:	dd61      	ble.n	20ca84 <LCD_DimensionBkCorrect+0x288>
		int width=xEnd_prev-xEnd;
  20c9c0:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20c9c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20c9c4:	1ad3      	subs	r3, r2, r3
  20c9c6:	623b      	str	r3, [r7, #32]
		LCD_RectangleBuff(LcdBuffer,0,width,FontVar[idVar].heightPxl_prev,0,0,width,FontVar[idVar].heightPxl_prev,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor);
  20c9c8:	6a3e      	ldr	r6, [r7, #32]
  20c9ca:	4949      	ldr	r1, [pc, #292]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c9cc:	697a      	ldr	r2, [r7, #20]
  20c9ce:	4613      	mov	r3, r2
  20c9d0:	011b      	lsls	r3, r3, #4
  20c9d2:	1a9b      	subs	r3, r3, r2
  20c9d4:	009b      	lsls	r3, r3, #2
  20c9d6:	440b      	add	r3, r1
  20c9d8:	3324      	adds	r3, #36	; 0x24
  20c9da:	881b      	ldrh	r3, [r3, #0]
  20c9dc:	469e      	mov	lr, r3
  20c9de:	6a39      	ldr	r1, [r7, #32]
  20c9e0:	4843      	ldr	r0, [pc, #268]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c9e2:	697a      	ldr	r2, [r7, #20]
  20c9e4:	4613      	mov	r3, r2
  20c9e6:	011b      	lsls	r3, r3, #4
  20c9e8:	1a9b      	subs	r3, r3, r2
  20c9ea:	009b      	lsls	r3, r3, #2
  20c9ec:	4403      	add	r3, r0
  20c9ee:	3324      	adds	r3, #36	; 0x24
  20c9f0:	881b      	ldrh	r3, [r3, #0]
  20c9f2:	607b      	str	r3, [r7, #4]
  20c9f4:	483e      	ldr	r0, [pc, #248]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20c9f6:	697a      	ldr	r2, [r7, #20]
  20c9f8:	4613      	mov	r3, r2
  20c9fa:	011b      	lsls	r3, r3, #4
  20c9fc:	1a9b      	subs	r3, r3, r2
  20c9fe:	009b      	lsls	r3, r3, #2
  20ca00:	4403      	add	r3, r0
  20ca02:	330c      	adds	r3, #12
  20ca04:	6818      	ldr	r0, [r3, #0]
  20ca06:	4c3a      	ldr	r4, [pc, #232]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20ca08:	697a      	ldr	r2, [r7, #20]
  20ca0a:	4613      	mov	r3, r2
  20ca0c:	011b      	lsls	r3, r3, #4
  20ca0e:	1a9b      	subs	r3, r3, r2
  20ca10:	009b      	lsls	r3, r3, #2
  20ca12:	4423      	add	r3, r4
  20ca14:	330c      	adds	r3, #12
  20ca16:	681c      	ldr	r4, [r3, #0]
  20ca18:	4d35      	ldr	r5, [pc, #212]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20ca1a:	697a      	ldr	r2, [r7, #20]
  20ca1c:	4613      	mov	r3, r2
  20ca1e:	011b      	lsls	r3, r3, #4
  20ca20:	1a9b      	subs	r3, r3, r2
  20ca22:	009b      	lsls	r3, r3, #2
  20ca24:	442b      	add	r3, r5
  20ca26:	330c      	adds	r3, #12
  20ca28:	681b      	ldr	r3, [r3, #0]
  20ca2a:	9306      	str	r3, [sp, #24]
  20ca2c:	9405      	str	r4, [sp, #20]
  20ca2e:	9004      	str	r0, [sp, #16]
  20ca30:	687b      	ldr	r3, [r7, #4]
  20ca32:	9303      	str	r3, [sp, #12]
  20ca34:	9102      	str	r1, [sp, #8]
  20ca36:	2300      	movs	r3, #0
  20ca38:	9301      	str	r3, [sp, #4]
  20ca3a:	2300      	movs	r3, #0
  20ca3c:	9300      	str	r3, [sp, #0]
  20ca3e:	4673      	mov	r3, lr
  20ca40:	4632      	mov	r2, r6
  20ca42:	2100      	movs	r1, #0
  20ca44:	68b8      	ldr	r0, [r7, #8]
  20ca46:	f7fb fab9 	bl	207fbc <LCD_RectangleBuff>
		LCD_DisplayBuff((uint32_t)xEnd,(uint32_t)FontVar[idVar].yPos_prev,width,FontVar[idVar].heightPxl_prev,pLcd+0);
  20ca4a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  20ca4c:	4928      	ldr	r1, [pc, #160]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20ca4e:	697a      	ldr	r2, [r7, #20]
  20ca50:	4613      	mov	r3, r2
  20ca52:	011b      	lsls	r3, r3, #4
  20ca54:	1a9b      	subs	r3, r3, r2
  20ca56:	009b      	lsls	r3, r3, #2
  20ca58:	440b      	add	r3, r1
  20ca5a:	3320      	adds	r3, #32
  20ca5c:	881b      	ldrh	r3, [r3, #0]
  20ca5e:	461d      	mov	r5, r3
  20ca60:	6a3c      	ldr	r4, [r7, #32]
  20ca62:	4923      	ldr	r1, [pc, #140]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20ca64:	697a      	ldr	r2, [r7, #20]
  20ca66:	4613      	mov	r3, r2
  20ca68:	011b      	lsls	r3, r3, #4
  20ca6a:	1a9b      	subs	r3, r3, r2
  20ca6c:	009b      	lsls	r3, r3, #2
  20ca6e:	440b      	add	r3, r1
  20ca70:	3324      	adds	r3, #36	; 0x24
  20ca72:	881b      	ldrh	r3, [r3, #0]
  20ca74:	461a      	mov	r2, r3
  20ca76:	4b1f      	ldr	r3, [pc, #124]	; (20caf4 <LCD_DimensionBkCorrect+0x2f8>)
  20ca78:	9300      	str	r3, [sp, #0]
  20ca7a:	4613      	mov	r3, r2
  20ca7c:	4622      	mov	r2, r4
  20ca7e:	4629      	mov	r1, r5
  20ca80:	f7fb f808 	bl	207a94 <LCD_DisplayBuff>
	}
	if(FontVar[idVar].yPos > FontVar[idVar].yPos_prev){
  20ca84:	491a      	ldr	r1, [pc, #104]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20ca86:	697a      	ldr	r2, [r7, #20]
  20ca88:	4613      	mov	r3, r2
  20ca8a:	011b      	lsls	r3, r3, #4
  20ca8c:	1a9b      	subs	r3, r3, r2
  20ca8e:	009b      	lsls	r3, r3, #2
  20ca90:	440b      	add	r3, r1
  20ca92:	3304      	adds	r3, #4
  20ca94:	8819      	ldrh	r1, [r3, #0]
  20ca96:	4816      	ldr	r0, [pc, #88]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20ca98:	697a      	ldr	r2, [r7, #20]
  20ca9a:	4613      	mov	r3, r2
  20ca9c:	011b      	lsls	r3, r3, #4
  20ca9e:	1a9b      	subs	r3, r3, r2
  20caa0:	009b      	lsls	r3, r3, #2
  20caa2:	4403      	add	r3, r0
  20caa4:	3320      	adds	r3, #32
  20caa6:	881b      	ldrh	r3, [r3, #0]
  20caa8:	4299      	cmp	r1, r3
  20caaa:	f240 8081 	bls.w	20cbb0 <LCD_DimensionBkCorrect+0x3b4>
		int height=FontVar[idVar].yPos-FontVar[idVar].yPos_prev;
  20caae:	4910      	ldr	r1, [pc, #64]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20cab0:	697a      	ldr	r2, [r7, #20]
  20cab2:	4613      	mov	r3, r2
  20cab4:	011b      	lsls	r3, r3, #4
  20cab6:	1a9b      	subs	r3, r3, r2
  20cab8:	009b      	lsls	r3, r3, #2
  20caba:	440b      	add	r3, r1
  20cabc:	3304      	adds	r3, #4
  20cabe:	881b      	ldrh	r3, [r3, #0]
  20cac0:	4618      	mov	r0, r3
  20cac2:	490b      	ldr	r1, [pc, #44]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20cac4:	697a      	ldr	r2, [r7, #20]
  20cac6:	4613      	mov	r3, r2
  20cac8:	011b      	lsls	r3, r3, #4
  20caca:	1a9b      	subs	r3, r3, r2
  20cacc:	009b      	lsls	r3, r3, #2
  20cace:	440b      	add	r3, r1
  20cad0:	3320      	adds	r3, #32
  20cad2:	881b      	ldrh	r3, [r3, #0]
  20cad4:	1ac3      	subs	r3, r0, r3
  20cad6:	61fb      	str	r3, [r7, #28]
		LCD_RectangleBuff(LcdBuffer,0,FontVar[idVar].widthPxl_prev,height,0,0,FontVar[idVar].widthPxl_prev,height,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor);
  20cad8:	4905      	ldr	r1, [pc, #20]	; (20caf0 <LCD_DimensionBkCorrect+0x2f4>)
  20cada:	697a      	ldr	r2, [r7, #20]
  20cadc:	4613      	mov	r3, r2
  20cade:	011b      	lsls	r3, r3, #4
  20cae0:	1a9b      	subs	r3, r3, r2
  20cae2:	009b      	lsls	r3, r3, #2
  20cae4:	440b      	add	r3, r1
  20cae6:	3322      	adds	r3, #34	; 0x22
  20cae8:	881b      	ldrh	r3, [r3, #0]
  20caea:	469e      	mov	lr, r3
  20caec:	69fe      	ldr	r6, [r7, #28]
  20caee:	e003      	b.n	20caf8 <LCD_DimensionBkCorrect+0x2fc>
  20caf0:	2000f818 	.word	0x2000f818
  20caf4:	c0000000 	.word	0xc0000000
  20caf8:	4981      	ldr	r1, [pc, #516]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cafa:	697a      	ldr	r2, [r7, #20]
  20cafc:	4613      	mov	r3, r2
  20cafe:	011b      	lsls	r3, r3, #4
  20cb00:	1a9b      	subs	r3, r3, r2
  20cb02:	009b      	lsls	r3, r3, #2
  20cb04:	440b      	add	r3, r1
  20cb06:	3322      	adds	r3, #34	; 0x22
  20cb08:	881b      	ldrh	r3, [r3, #0]
  20cb0a:	607b      	str	r3, [r7, #4]
  20cb0c:	69f9      	ldr	r1, [r7, #28]
  20cb0e:	487c      	ldr	r0, [pc, #496]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cb10:	697a      	ldr	r2, [r7, #20]
  20cb12:	4613      	mov	r3, r2
  20cb14:	011b      	lsls	r3, r3, #4
  20cb16:	1a9b      	subs	r3, r3, r2
  20cb18:	009b      	lsls	r3, r3, #2
  20cb1a:	4403      	add	r3, r0
  20cb1c:	330c      	adds	r3, #12
  20cb1e:	6818      	ldr	r0, [r3, #0]
  20cb20:	4c77      	ldr	r4, [pc, #476]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cb22:	697a      	ldr	r2, [r7, #20]
  20cb24:	4613      	mov	r3, r2
  20cb26:	011b      	lsls	r3, r3, #4
  20cb28:	1a9b      	subs	r3, r3, r2
  20cb2a:	009b      	lsls	r3, r3, #2
  20cb2c:	4423      	add	r3, r4
  20cb2e:	330c      	adds	r3, #12
  20cb30:	681c      	ldr	r4, [r3, #0]
  20cb32:	4d73      	ldr	r5, [pc, #460]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cb34:	697a      	ldr	r2, [r7, #20]
  20cb36:	4613      	mov	r3, r2
  20cb38:	011b      	lsls	r3, r3, #4
  20cb3a:	1a9b      	subs	r3, r3, r2
  20cb3c:	009b      	lsls	r3, r3, #2
  20cb3e:	442b      	add	r3, r5
  20cb40:	330c      	adds	r3, #12
  20cb42:	681b      	ldr	r3, [r3, #0]
  20cb44:	9306      	str	r3, [sp, #24]
  20cb46:	9405      	str	r4, [sp, #20]
  20cb48:	9004      	str	r0, [sp, #16]
  20cb4a:	9103      	str	r1, [sp, #12]
  20cb4c:	687b      	ldr	r3, [r7, #4]
  20cb4e:	9302      	str	r3, [sp, #8]
  20cb50:	2300      	movs	r3, #0
  20cb52:	9301      	str	r3, [sp, #4]
  20cb54:	2300      	movs	r3, #0
  20cb56:	9300      	str	r3, [sp, #0]
  20cb58:	4633      	mov	r3, r6
  20cb5a:	4672      	mov	r2, lr
  20cb5c:	2100      	movs	r1, #0
  20cb5e:	68b8      	ldr	r0, [r7, #8]
  20cb60:	f7fb fa2c 	bl	207fbc <LCD_RectangleBuff>
		LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos_prev,(uint32_t)FontVar[idVar].yPos_prev,FontVar[idVar].widthPxl_prev,height,pLcd+0);
  20cb64:	4966      	ldr	r1, [pc, #408]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cb66:	697a      	ldr	r2, [r7, #20]
  20cb68:	4613      	mov	r3, r2
  20cb6a:	011b      	lsls	r3, r3, #4
  20cb6c:	1a9b      	subs	r3, r3, r2
  20cb6e:	009b      	lsls	r3, r3, #2
  20cb70:	440b      	add	r3, r1
  20cb72:	331e      	adds	r3, #30
  20cb74:	881b      	ldrh	r3, [r3, #0]
  20cb76:	4618      	mov	r0, r3
  20cb78:	4961      	ldr	r1, [pc, #388]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cb7a:	697a      	ldr	r2, [r7, #20]
  20cb7c:	4613      	mov	r3, r2
  20cb7e:	011b      	lsls	r3, r3, #4
  20cb80:	1a9b      	subs	r3, r3, r2
  20cb82:	009b      	lsls	r3, r3, #2
  20cb84:	440b      	add	r3, r1
  20cb86:	3320      	adds	r3, #32
  20cb88:	881b      	ldrh	r3, [r3, #0]
  20cb8a:	461c      	mov	r4, r3
  20cb8c:	495c      	ldr	r1, [pc, #368]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cb8e:	697a      	ldr	r2, [r7, #20]
  20cb90:	4613      	mov	r3, r2
  20cb92:	011b      	lsls	r3, r3, #4
  20cb94:	1a9b      	subs	r3, r3, r2
  20cb96:	009b      	lsls	r3, r3, #2
  20cb98:	440b      	add	r3, r1
  20cb9a:	3322      	adds	r3, #34	; 0x22
  20cb9c:	881b      	ldrh	r3, [r3, #0]
  20cb9e:	4619      	mov	r1, r3
  20cba0:	69fa      	ldr	r2, [r7, #28]
  20cba2:	4b58      	ldr	r3, [pc, #352]	; (20cd04 <LCD_DimensionBkCorrect+0x508>)
  20cba4:	9300      	str	r3, [sp, #0]
  20cba6:	4613      	mov	r3, r2
  20cba8:	460a      	mov	r2, r1
  20cbaa:	4621      	mov	r1, r4
  20cbac:	f7fa ff72 	bl	207a94 <LCD_DisplayBuff>
	}
	if(yEnd_prev > yEnd){
  20cbb0:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  20cbb2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20cbb4:	429a      	cmp	r2, r3
  20cbb6:	dd62      	ble.n	20cc7e <LCD_DimensionBkCorrect+0x482>
		int height=yEnd_prev-yEnd;
  20cbb8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  20cbba:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20cbbc:	1ad3      	subs	r3, r2, r3
  20cbbe:	61bb      	str	r3, [r7, #24]
		LCD_RectangleBuff(LcdBuffer,0,FontVar[idVar].widthPxl_prev,height,0,0,FontVar[idVar].widthPxl_prev,height,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor,FontVar[idVar].bkScreenColor);
  20cbc0:	494f      	ldr	r1, [pc, #316]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cbc2:	697a      	ldr	r2, [r7, #20]
  20cbc4:	4613      	mov	r3, r2
  20cbc6:	011b      	lsls	r3, r3, #4
  20cbc8:	1a9b      	subs	r3, r3, r2
  20cbca:	009b      	lsls	r3, r3, #2
  20cbcc:	440b      	add	r3, r1
  20cbce:	3322      	adds	r3, #34	; 0x22
  20cbd0:	881b      	ldrh	r3, [r3, #0]
  20cbd2:	469e      	mov	lr, r3
  20cbd4:	69be      	ldr	r6, [r7, #24]
  20cbd6:	494a      	ldr	r1, [pc, #296]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cbd8:	697a      	ldr	r2, [r7, #20]
  20cbda:	4613      	mov	r3, r2
  20cbdc:	011b      	lsls	r3, r3, #4
  20cbde:	1a9b      	subs	r3, r3, r2
  20cbe0:	009b      	lsls	r3, r3, #2
  20cbe2:	440b      	add	r3, r1
  20cbe4:	3322      	adds	r3, #34	; 0x22
  20cbe6:	881b      	ldrh	r3, [r3, #0]
  20cbe8:	607b      	str	r3, [r7, #4]
  20cbea:	69b9      	ldr	r1, [r7, #24]
  20cbec:	4844      	ldr	r0, [pc, #272]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cbee:	697a      	ldr	r2, [r7, #20]
  20cbf0:	4613      	mov	r3, r2
  20cbf2:	011b      	lsls	r3, r3, #4
  20cbf4:	1a9b      	subs	r3, r3, r2
  20cbf6:	009b      	lsls	r3, r3, #2
  20cbf8:	4403      	add	r3, r0
  20cbfa:	330c      	adds	r3, #12
  20cbfc:	6818      	ldr	r0, [r3, #0]
  20cbfe:	4c40      	ldr	r4, [pc, #256]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cc00:	697a      	ldr	r2, [r7, #20]
  20cc02:	4613      	mov	r3, r2
  20cc04:	011b      	lsls	r3, r3, #4
  20cc06:	1a9b      	subs	r3, r3, r2
  20cc08:	009b      	lsls	r3, r3, #2
  20cc0a:	4423      	add	r3, r4
  20cc0c:	330c      	adds	r3, #12
  20cc0e:	681c      	ldr	r4, [r3, #0]
  20cc10:	4d3b      	ldr	r5, [pc, #236]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cc12:	697a      	ldr	r2, [r7, #20]
  20cc14:	4613      	mov	r3, r2
  20cc16:	011b      	lsls	r3, r3, #4
  20cc18:	1a9b      	subs	r3, r3, r2
  20cc1a:	009b      	lsls	r3, r3, #2
  20cc1c:	442b      	add	r3, r5
  20cc1e:	330c      	adds	r3, #12
  20cc20:	681b      	ldr	r3, [r3, #0]
  20cc22:	9306      	str	r3, [sp, #24]
  20cc24:	9405      	str	r4, [sp, #20]
  20cc26:	9004      	str	r0, [sp, #16]
  20cc28:	9103      	str	r1, [sp, #12]
  20cc2a:	687b      	ldr	r3, [r7, #4]
  20cc2c:	9302      	str	r3, [sp, #8]
  20cc2e:	2300      	movs	r3, #0
  20cc30:	9301      	str	r3, [sp, #4]
  20cc32:	2300      	movs	r3, #0
  20cc34:	9300      	str	r3, [sp, #0]
  20cc36:	4633      	mov	r3, r6
  20cc38:	4672      	mov	r2, lr
  20cc3a:	2100      	movs	r1, #0
  20cc3c:	68b8      	ldr	r0, [r7, #8]
  20cc3e:	f7fb f9bd 	bl	207fbc <LCD_RectangleBuff>
		LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos_prev,yEnd,FontVar[idVar].widthPxl_prev,height,pLcd+0);
  20cc42:	492f      	ldr	r1, [pc, #188]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cc44:	697a      	ldr	r2, [r7, #20]
  20cc46:	4613      	mov	r3, r2
  20cc48:	011b      	lsls	r3, r3, #4
  20cc4a:	1a9b      	subs	r3, r3, r2
  20cc4c:	009b      	lsls	r3, r3, #2
  20cc4e:	440b      	add	r3, r1
  20cc50:	331e      	adds	r3, #30
  20cc52:	881b      	ldrh	r3, [r3, #0]
  20cc54:	461c      	mov	r4, r3
  20cc56:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  20cc58:	4929      	ldr	r1, [pc, #164]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cc5a:	697a      	ldr	r2, [r7, #20]
  20cc5c:	4613      	mov	r3, r2
  20cc5e:	011b      	lsls	r3, r3, #4
  20cc60:	1a9b      	subs	r3, r3, r2
  20cc62:	009b      	lsls	r3, r3, #2
  20cc64:	440b      	add	r3, r1
  20cc66:	3322      	adds	r3, #34	; 0x22
  20cc68:	881b      	ldrh	r3, [r3, #0]
  20cc6a:	4619      	mov	r1, r3
  20cc6c:	69ba      	ldr	r2, [r7, #24]
  20cc6e:	4b25      	ldr	r3, [pc, #148]	; (20cd04 <LCD_DimensionBkCorrect+0x508>)
  20cc70:	9300      	str	r3, [sp, #0]
  20cc72:	4613      	mov	r3, r2
  20cc74:	460a      	mov	r2, r1
  20cc76:	4601      	mov	r1, r0
  20cc78:	4620      	mov	r0, r4
  20cc7a:	f7fa ff0b 	bl	207a94 <LCD_DisplayBuff>
	}
	FontVar[idVar].xPos_prev=FontVar[idVar].xPos;
  20cc7e:	4920      	ldr	r1, [pc, #128]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cc80:	697a      	ldr	r2, [r7, #20]
  20cc82:	4613      	mov	r3, r2
  20cc84:	011b      	lsls	r3, r3, #4
  20cc86:	1a9b      	subs	r3, r3, r2
  20cc88:	009b      	lsls	r3, r3, #2
  20cc8a:	440b      	add	r3, r1
  20cc8c:	3302      	adds	r3, #2
  20cc8e:	8818      	ldrh	r0, [r3, #0]
  20cc90:	491b      	ldr	r1, [pc, #108]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cc92:	697a      	ldr	r2, [r7, #20]
  20cc94:	4613      	mov	r3, r2
  20cc96:	011b      	lsls	r3, r3, #4
  20cc98:	1a9b      	subs	r3, r3, r2
  20cc9a:	009b      	lsls	r3, r3, #2
  20cc9c:	440b      	add	r3, r1
  20cc9e:	331e      	adds	r3, #30
  20cca0:	4602      	mov	r2, r0
  20cca2:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].yPos_prev=FontVar[idVar].yPos;
  20cca4:	4916      	ldr	r1, [pc, #88]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cca6:	697a      	ldr	r2, [r7, #20]
  20cca8:	4613      	mov	r3, r2
  20ccaa:	011b      	lsls	r3, r3, #4
  20ccac:	1a9b      	subs	r3, r3, r2
  20ccae:	009b      	lsls	r3, r3, #2
  20ccb0:	440b      	add	r3, r1
  20ccb2:	3304      	adds	r3, #4
  20ccb4:	8818      	ldrh	r0, [r3, #0]
  20ccb6:	4912      	ldr	r1, [pc, #72]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20ccb8:	697a      	ldr	r2, [r7, #20]
  20ccba:	4613      	mov	r3, r2
  20ccbc:	011b      	lsls	r3, r3, #4
  20ccbe:	1a9b      	subs	r3, r3, r2
  20ccc0:	009b      	lsls	r3, r3, #2
  20ccc2:	440b      	add	r3, r1
  20ccc4:	3320      	adds	r3, #32
  20ccc6:	4602      	mov	r2, r0
  20ccc8:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].widthPxl_prev=temp.inPixel;
  20ccca:	89f8      	ldrh	r0, [r7, #14]
  20cccc:	490c      	ldr	r1, [pc, #48]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20ccce:	697a      	ldr	r2, [r7, #20]
  20ccd0:	4613      	mov	r3, r2
  20ccd2:	011b      	lsls	r3, r3, #4
  20ccd4:	1a9b      	subs	r3, r3, r2
  20ccd6:	009b      	lsls	r3, r3, #2
  20ccd8:	440b      	add	r3, r1
  20ccda:	3322      	adds	r3, #34	; 0x22
  20ccdc:	4602      	mov	r2, r0
  20ccde:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].heightPxl_prev=temp.height;
  20cce0:	8a38      	ldrh	r0, [r7, #16]
  20cce2:	4907      	ldr	r1, [pc, #28]	; (20cd00 <LCD_DimensionBkCorrect+0x504>)
  20cce4:	697a      	ldr	r2, [r7, #20]
  20cce6:	4613      	mov	r3, r2
  20cce8:	011b      	lsls	r3, r3, #4
  20ccea:	1a9b      	subs	r3, r3, r2
  20ccec:	009b      	lsls	r3, r3, #2
  20ccee:	440b      	add	r3, r1
  20ccf0:	3324      	adds	r3, #36	; 0x24
  20ccf2:	4602      	mov	r2, r0
  20ccf4:	801a      	strh	r2, [r3, #0]
}
  20ccf6:	bf00      	nop
  20ccf8:	373c      	adds	r7, #60	; 0x3c
  20ccfa:	46bd      	mov	sp, r7
  20ccfc:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20ccfe:	bf00      	nop
  20cd00:	2000f818 	.word	0x2000f818
  20cd04:	c0000000 	.word	0xc0000000

0020cd08 <LCD_StrVarIndirect>:

StructTxtPxlLen LCD_StrVarIndirect(int idVar, char *txt){
  20cd08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  20cd0c:	b08c      	sub	sp, #48	; 0x30
  20cd0e:	af06      	add	r7, sp, #24
  20cd10:	60f8      	str	r0, [r7, #12]
  20cd12:	60b9      	str	r1, [r7, #8]
  20cd14:	607a      	str	r2, [r7, #4]
	StructTxtPxlLen temp;
	temp = LCD_StrIndirect(FontVar[idVar].id,FontVar[idVar].xPos,FontVar[idVar].yPos,txt,FontVar[idVar].heightType,FontVar[idVar].space,FontVar[idVar].bkColor,FontVar[idVar].coeff,FontVar[idVar].widthType);
  20cd16:	4941      	ldr	r1, [pc, #260]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd18:	68ba      	ldr	r2, [r7, #8]
  20cd1a:	4613      	mov	r3, r2
  20cd1c:	011b      	lsls	r3, r3, #4
  20cd1e:	1a9b      	subs	r3, r3, r2
  20cd20:	009b      	lsls	r3, r3, #2
  20cd22:	440b      	add	r3, r1
  20cd24:	881b      	ldrh	r3, [r3, #0]
  20cd26:	469e      	mov	lr, r3
  20cd28:	493c      	ldr	r1, [pc, #240]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd2a:	68ba      	ldr	r2, [r7, #8]
  20cd2c:	4613      	mov	r3, r2
  20cd2e:	011b      	lsls	r3, r3, #4
  20cd30:	1a9b      	subs	r3, r3, r2
  20cd32:	009b      	lsls	r3, r3, #2
  20cd34:	440b      	add	r3, r1
  20cd36:	3302      	adds	r3, #2
  20cd38:	881b      	ldrh	r3, [r3, #0]
  20cd3a:	469c      	mov	ip, r3
  20cd3c:	4937      	ldr	r1, [pc, #220]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd3e:	68ba      	ldr	r2, [r7, #8]
  20cd40:	4613      	mov	r3, r2
  20cd42:	011b      	lsls	r3, r3, #4
  20cd44:	1a9b      	subs	r3, r3, r2
  20cd46:	009b      	lsls	r3, r3, #2
  20cd48:	440b      	add	r3, r1
  20cd4a:	3304      	adds	r3, #4
  20cd4c:	881b      	ldrh	r3, [r3, #0]
  20cd4e:	4698      	mov	r8, r3
  20cd50:	4932      	ldr	r1, [pc, #200]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd52:	68ba      	ldr	r2, [r7, #8]
  20cd54:	4613      	mov	r3, r2
  20cd56:	011b      	lsls	r3, r3, #4
  20cd58:	1a9b      	subs	r3, r3, r2
  20cd5a:	009b      	lsls	r3, r3, #2
  20cd5c:	440b      	add	r3, r1
  20cd5e:	3306      	adds	r3, #6
  20cd60:	f993 3000 	ldrsb.w	r3, [r3]
  20cd64:	461d      	mov	r5, r3
  20cd66:	492d      	ldr	r1, [pc, #180]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd68:	68ba      	ldr	r2, [r7, #8]
  20cd6a:	4613      	mov	r3, r2
  20cd6c:	011b      	lsls	r3, r3, #4
  20cd6e:	1a9b      	subs	r3, r3, r2
  20cd70:	009b      	lsls	r3, r3, #2
  20cd72:	440b      	add	r3, r1
  20cd74:	3307      	adds	r3, #7
  20cd76:	781b      	ldrb	r3, [r3, #0]
  20cd78:	461e      	mov	r6, r3
  20cd7a:	4928      	ldr	r1, [pc, #160]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd7c:	68ba      	ldr	r2, [r7, #8]
  20cd7e:	4613      	mov	r3, r2
  20cd80:	011b      	lsls	r3, r3, #4
  20cd82:	1a9b      	subs	r3, r3, r2
  20cd84:	009b      	lsls	r3, r3, #2
  20cd86:	440b      	add	r3, r1
  20cd88:	3308      	adds	r3, #8
  20cd8a:	6819      	ldr	r1, [r3, #0]
  20cd8c:	4823      	ldr	r0, [pc, #140]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cd8e:	68ba      	ldr	r2, [r7, #8]
  20cd90:	4613      	mov	r3, r2
  20cd92:	011b      	lsls	r3, r3, #4
  20cd94:	1a9b      	subs	r3, r3, r2
  20cd96:	009b      	lsls	r3, r3, #2
  20cd98:	4403      	add	r3, r0
  20cd9a:	3318      	adds	r3, #24
  20cd9c:	6818      	ldr	r0, [r3, #0]
  20cd9e:	4c1f      	ldr	r4, [pc, #124]	; (20ce1c <LCD_StrVarIndirect+0x114>)
  20cda0:	68ba      	ldr	r2, [r7, #8]
  20cda2:	4613      	mov	r3, r2
  20cda4:	011b      	lsls	r3, r3, #4
  20cda6:	1a9b      	subs	r3, r3, r2
  20cda8:	009b      	lsls	r3, r3, #2
  20cdaa:	4423      	add	r3, r4
  20cdac:	331c      	adds	r3, #28
  20cdae:	781b      	ldrb	r3, [r3, #0]
  20cdb0:	f107 0410 	add.w	r4, r7, #16
  20cdb4:	9305      	str	r3, [sp, #20]
  20cdb6:	9004      	str	r0, [sp, #16]
  20cdb8:	9103      	str	r1, [sp, #12]
  20cdba:	9602      	str	r6, [sp, #8]
  20cdbc:	9501      	str	r5, [sp, #4]
  20cdbe:	687b      	ldr	r3, [r7, #4]
  20cdc0:	9300      	str	r3, [sp, #0]
  20cdc2:	4643      	mov	r3, r8
  20cdc4:	4662      	mov	r2, ip
  20cdc6:	4671      	mov	r1, lr
  20cdc8:	4620      	mov	r0, r4
  20cdca:	f7ff fb5b 	bl	20c484 <LCD_StrIndirect>
	if((temp.height==0)&&(temp.inChar==0)&&(temp.inPixel==0))
  20cdce:	8abb      	ldrh	r3, [r7, #20]
  20cdd0:	2b00      	cmp	r3, #0
  20cdd2:	d10e      	bne.n	20cdf2 <LCD_StrVarIndirect+0xea>
  20cdd4:	8a3b      	ldrh	r3, [r7, #16]
  20cdd6:	2b00      	cmp	r3, #0
  20cdd8:	d10b      	bne.n	20cdf2 <LCD_StrVarIndirect+0xea>
  20cdda:	8a7b      	ldrh	r3, [r7, #18]
  20cddc:	2b00      	cmp	r3, #0
  20cdde:	d108      	bne.n	20cdf2 <LCD_StrVarIndirect+0xea>
		return temp;
  20cde0:	68fb      	ldr	r3, [r7, #12]
  20cde2:	461a      	mov	r2, r3
  20cde4:	f107 0310 	add.w	r3, r7, #16
  20cde8:	6818      	ldr	r0, [r3, #0]
  20cdea:	6010      	str	r0, [r2, #0]
  20cdec:	889b      	ldrh	r3, [r3, #4]
  20cdee:	8093      	strh	r3, [r2, #4]
  20cdf0:	e00e      	b.n	20ce10 <LCD_StrVarIndirect+0x108>
	LCD_DimensionBkCorrect(idVar,temp,pLcd);
  20cdf2:	4b0b      	ldr	r3, [pc, #44]	; (20ce20 <LCD_StrVarIndirect+0x118>)
  20cdf4:	f107 0210 	add.w	r2, r7, #16
  20cdf8:	ca06      	ldmia	r2, {r1, r2}
  20cdfa:	68b8      	ldr	r0, [r7, #8]
  20cdfc:	f7ff fcfe 	bl	20c7fc <LCD_DimensionBkCorrect>
	return temp;
  20ce00:	68fb      	ldr	r3, [r7, #12]
  20ce02:	461a      	mov	r2, r3
  20ce04:	f107 0310 	add.w	r3, r7, #16
  20ce08:	6818      	ldr	r0, [r3, #0]
  20ce0a:	6010      	str	r0, [r2, #0]
  20ce0c:	889b      	ldrh	r3, [r3, #4]
  20ce0e:	8093      	strh	r3, [r2, #4]
}
  20ce10:	68f8      	ldr	r0, [r7, #12]
  20ce12:	3718      	adds	r7, #24
  20ce14:	46bd      	mov	sp, r7
  20ce16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  20ce1a:	bf00      	nop
  20ce1c:	2000f818 	.word	0x2000f818
  20ce20:	c0000000 	.word	0xc0000000

0020ce24 <LCD_StrChangeColorVar>:

StructTxtPxlLen LCD_StrChangeColorVar(int idVar,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor,uint8_t maxVal, int constWidth, uint32_t bkScreenColor){
  20ce24:	b580      	push	{r7, lr}
  20ce26:	b08e      	sub	sp, #56	; 0x38
  20ce28:	af08      	add	r7, sp, #32
  20ce2a:	60f8      	str	r0, [r7, #12]
  20ce2c:	60b9      	str	r1, [r7, #8]
  20ce2e:	607a      	str	r2, [r7, #4]
  20ce30:	603b      	str	r3, [r7, #0]
	StructTxtPxlLen temp;
	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  20ce32:	68bb      	ldr	r3, [r7, #8]
  20ce34:	2b27      	cmp	r3, #39	; 0x27
  20ce36:	f300 80dd 	bgt.w	20cff4 <LCD_StrChangeColorVar+0x1d0>
	{
		temp = LCD_StrChangeColor(fontID,Xpos,Ypos,txt,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20ce3a:	f107 0010 	add.w	r0, r7, #16
  20ce3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20ce40:	9306      	str	r3, [sp, #24]
  20ce42:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
  20ce46:	9305      	str	r3, [sp, #20]
  20ce48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20ce4a:	9304      	str	r3, [sp, #16]
  20ce4c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  20ce4e:	9303      	str	r3, [sp, #12]
  20ce50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20ce52:	9302      	str	r3, [sp, #8]
  20ce54:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20ce56:	9301      	str	r3, [sp, #4]
  20ce58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20ce5a:	9300      	str	r3, [sp, #0]
  20ce5c:	6a3b      	ldr	r3, [r7, #32]
  20ce5e:	683a      	ldr	r2, [r7, #0]
  20ce60:	6879      	ldr	r1, [r7, #4]
  20ce62:	f7ff fb3d 	bl	20c4e0 <LCD_StrChangeColor>
		if((temp.height==0)&&(temp.inChar==0)&&(temp.inPixel==0))
  20ce66:	8abb      	ldrh	r3, [r7, #20]
  20ce68:	2b00      	cmp	r3, #0
  20ce6a:	d10e      	bne.n	20ce8a <LCD_StrChangeColorVar+0x66>
  20ce6c:	8a3b      	ldrh	r3, [r7, #16]
  20ce6e:	2b00      	cmp	r3, #0
  20ce70:	d10b      	bne.n	20ce8a <LCD_StrChangeColorVar+0x66>
  20ce72:	8a7b      	ldrh	r3, [r7, #18]
  20ce74:	2b00      	cmp	r3, #0
  20ce76:	d108      	bne.n	20ce8a <LCD_StrChangeColorVar+0x66>
			return temp;
  20ce78:	68fb      	ldr	r3, [r7, #12]
  20ce7a:	461a      	mov	r2, r3
  20ce7c:	f107 0310 	add.w	r3, r7, #16
  20ce80:	6818      	ldr	r0, [r3, #0]
  20ce82:	6010      	str	r0, [r2, #0]
  20ce84:	889b      	ldrh	r3, [r3, #4]
  20ce86:	8093      	strh	r3, [r2, #4]
  20ce88:	e0ba      	b.n	20d000 <LCD_StrChangeColorVar+0x1dc>
		FontVar[idVar].id=fontID;
  20ce8a:	687b      	ldr	r3, [r7, #4]
  20ce8c:	b298      	uxth	r0, r3
  20ce8e:	495e      	ldr	r1, [pc, #376]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20ce90:	68ba      	ldr	r2, [r7, #8]
  20ce92:	4613      	mov	r3, r2
  20ce94:	011b      	lsls	r3, r3, #4
  20ce96:	1a9b      	subs	r3, r3, r2
  20ce98:	009b      	lsls	r3, r3, #2
  20ce9a:	440b      	add	r3, r1
  20ce9c:	4602      	mov	r2, r0
  20ce9e:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].xPos=Xpos;
  20cea0:	683b      	ldr	r3, [r7, #0]
  20cea2:	b298      	uxth	r0, r3
  20cea4:	4958      	ldr	r1, [pc, #352]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cea6:	68ba      	ldr	r2, [r7, #8]
  20cea8:	4613      	mov	r3, r2
  20ceaa:	011b      	lsls	r3, r3, #4
  20ceac:	1a9b      	subs	r3, r3, r2
  20ceae:	009b      	lsls	r3, r3, #2
  20ceb0:	440b      	add	r3, r1
  20ceb2:	3302      	adds	r3, #2
  20ceb4:	4602      	mov	r2, r0
  20ceb6:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos=Ypos;
  20ceb8:	6a3b      	ldr	r3, [r7, #32]
  20ceba:	b298      	uxth	r0, r3
  20cebc:	4952      	ldr	r1, [pc, #328]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cebe:	68ba      	ldr	r2, [r7, #8]
  20cec0:	4613      	mov	r3, r2
  20cec2:	011b      	lsls	r3, r3, #4
  20cec4:	1a9b      	subs	r3, r3, r2
  20cec6:	009b      	lsls	r3, r3, #2
  20cec8:	440b      	add	r3, r1
  20ceca:	3304      	adds	r3, #4
  20cecc:	4602      	mov	r2, r0
  20cece:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightType=OnlyDigits;
  20ced0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20ced2:	b258      	sxtb	r0, r3
  20ced4:	494c      	ldr	r1, [pc, #304]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20ced6:	68ba      	ldr	r2, [r7, #8]
  20ced8:	4613      	mov	r3, r2
  20ceda:	011b      	lsls	r3, r3, #4
  20cedc:	1a9b      	subs	r3, r3, r2
  20cede:	009b      	lsls	r3, r3, #2
  20cee0:	440b      	add	r3, r1
  20cee2:	3306      	adds	r3, #6
  20cee4:	4602      	mov	r2, r0
  20cee6:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].space=space;
  20cee8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20ceea:	b2d8      	uxtb	r0, r3
  20ceec:	4946      	ldr	r1, [pc, #280]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20ceee:	68ba      	ldr	r2, [r7, #8]
  20cef0:	4613      	mov	r3, r2
  20cef2:	011b      	lsls	r3, r3, #4
  20cef4:	1a9b      	subs	r3, r3, r2
  20cef6:	009b      	lsls	r3, r3, #2
  20cef8:	440b      	add	r3, r1
  20cefa:	3307      	adds	r3, #7
  20cefc:	4602      	mov	r2, r0
  20cefe:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].bkColor=bkColor;
  20cf00:	4941      	ldr	r1, [pc, #260]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf02:	68ba      	ldr	r2, [r7, #8]
  20cf04:	4613      	mov	r3, r2
  20cf06:	011b      	lsls	r3, r3, #4
  20cf08:	1a9b      	subs	r3, r3, r2
  20cf0a:	009b      	lsls	r3, r3, #2
  20cf0c:	440b      	add	r3, r1
  20cf0e:	3308      	adds	r3, #8
  20cf10:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  20cf12:	601a      	str	r2, [r3, #0]
		FontVar[idVar].bkScreenColor=bkScreenColor;
  20cf14:	493c      	ldr	r1, [pc, #240]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf16:	68ba      	ldr	r2, [r7, #8]
  20cf18:	4613      	mov	r3, r2
  20cf1a:	011b      	lsls	r3, r3, #4
  20cf1c:	1a9b      	subs	r3, r3, r2
  20cf1e:	009b      	lsls	r3, r3, #2
  20cf20:	440b      	add	r3, r1
  20cf22:	330c      	adds	r3, #12
  20cf24:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20cf26:	601a      	str	r2, [r3, #0]
		FontVar[idVar].fontColor=fontColor;
  20cf28:	4937      	ldr	r1, [pc, #220]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf2a:	68ba      	ldr	r2, [r7, #8]
  20cf2c:	4613      	mov	r3, r2
  20cf2e:	011b      	lsls	r3, r3, #4
  20cf30:	1a9b      	subs	r3, r3, r2
  20cf32:	009b      	lsls	r3, r3, #2
  20cf34:	440b      	add	r3, r1
  20cf36:	3310      	adds	r3, #16
  20cf38:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  20cf3a:	601a      	str	r2, [r3, #0]
		FontVar[idVar].coeff=maxVal;
  20cf3c:	f897 1038 	ldrb.w	r1, [r7, #56]	; 0x38
  20cf40:	4831      	ldr	r0, [pc, #196]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf42:	68ba      	ldr	r2, [r7, #8]
  20cf44:	4613      	mov	r3, r2
  20cf46:	011b      	lsls	r3, r3, #4
  20cf48:	1a9b      	subs	r3, r3, r2
  20cf4a:	009b      	lsls	r3, r3, #2
  20cf4c:	4403      	add	r3, r0
  20cf4e:	3318      	adds	r3, #24
  20cf50:	6019      	str	r1, [r3, #0]
		FontVar[idVar].widthType=constWidth;
  20cf52:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20cf54:	b2d8      	uxtb	r0, r3
  20cf56:	492c      	ldr	r1, [pc, #176]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf58:	68ba      	ldr	r2, [r7, #8]
  20cf5a:	4613      	mov	r3, r2
  20cf5c:	011b      	lsls	r3, r3, #4
  20cf5e:	1a9b      	subs	r3, r3, r2
  20cf60:	009b      	lsls	r3, r3, #2
  20cf62:	440b      	add	r3, r1
  20cf64:	331c      	adds	r3, #28
  20cf66:	4602      	mov	r2, r0
  20cf68:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].xPos_prev = FontVar[idVar].xPos;
  20cf6a:	4927      	ldr	r1, [pc, #156]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf6c:	68ba      	ldr	r2, [r7, #8]
  20cf6e:	4613      	mov	r3, r2
  20cf70:	011b      	lsls	r3, r3, #4
  20cf72:	1a9b      	subs	r3, r3, r2
  20cf74:	009b      	lsls	r3, r3, #2
  20cf76:	440b      	add	r3, r1
  20cf78:	3302      	adds	r3, #2
  20cf7a:	8818      	ldrh	r0, [r3, #0]
  20cf7c:	4922      	ldr	r1, [pc, #136]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf7e:	68ba      	ldr	r2, [r7, #8]
  20cf80:	4613      	mov	r3, r2
  20cf82:	011b      	lsls	r3, r3, #4
  20cf84:	1a9b      	subs	r3, r3, r2
  20cf86:	009b      	lsls	r3, r3, #2
  20cf88:	440b      	add	r3, r1
  20cf8a:	331e      	adds	r3, #30
  20cf8c:	4602      	mov	r2, r0
  20cf8e:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos_prev = FontVar[idVar].yPos;
  20cf90:	491d      	ldr	r1, [pc, #116]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cf92:	68ba      	ldr	r2, [r7, #8]
  20cf94:	4613      	mov	r3, r2
  20cf96:	011b      	lsls	r3, r3, #4
  20cf98:	1a9b      	subs	r3, r3, r2
  20cf9a:	009b      	lsls	r3, r3, #2
  20cf9c:	440b      	add	r3, r1
  20cf9e:	3304      	adds	r3, #4
  20cfa0:	8818      	ldrh	r0, [r3, #0]
  20cfa2:	4919      	ldr	r1, [pc, #100]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cfa4:	68ba      	ldr	r2, [r7, #8]
  20cfa6:	4613      	mov	r3, r2
  20cfa8:	011b      	lsls	r3, r3, #4
  20cfaa:	1a9b      	subs	r3, r3, r2
  20cfac:	009b      	lsls	r3, r3, #2
  20cfae:	440b      	add	r3, r1
  20cfb0:	3320      	adds	r3, #32
  20cfb2:	4602      	mov	r2, r0
  20cfb4:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].widthPxl_prev = temp.inPixel;
  20cfb6:	8a78      	ldrh	r0, [r7, #18]
  20cfb8:	4913      	ldr	r1, [pc, #76]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cfba:	68ba      	ldr	r2, [r7, #8]
  20cfbc:	4613      	mov	r3, r2
  20cfbe:	011b      	lsls	r3, r3, #4
  20cfc0:	1a9b      	subs	r3, r3, r2
  20cfc2:	009b      	lsls	r3, r3, #2
  20cfc4:	440b      	add	r3, r1
  20cfc6:	3322      	adds	r3, #34	; 0x22
  20cfc8:	4602      	mov	r2, r0
  20cfca:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightPxl_prev = temp.height;
  20cfcc:	8ab8      	ldrh	r0, [r7, #20]
  20cfce:	490e      	ldr	r1, [pc, #56]	; (20d008 <LCD_StrChangeColorVar+0x1e4>)
  20cfd0:	68ba      	ldr	r2, [r7, #8]
  20cfd2:	4613      	mov	r3, r2
  20cfd4:	011b      	lsls	r3, r3, #4
  20cfd6:	1a9b      	subs	r3, r3, r2
  20cfd8:	009b      	lsls	r3, r3, #2
  20cfda:	440b      	add	r3, r1
  20cfdc:	3324      	adds	r3, #36	; 0x24
  20cfde:	4602      	mov	r2, r0
  20cfe0:	801a      	strh	r2, [r3, #0]
		return temp;
  20cfe2:	68fb      	ldr	r3, [r7, #12]
  20cfe4:	461a      	mov	r2, r3
  20cfe6:	f107 0310 	add.w	r3, r7, #16
  20cfea:	6818      	ldr	r0, [r3, #0]
  20cfec:	6010      	str	r0, [r2, #0]
  20cfee:	889b      	ldrh	r3, [r3, #4]
  20cff0:	8093      	strh	r3, [r2, #4]
  20cff2:	e005      	b.n	20d000 <LCD_StrChangeColorVar+0x1dc>
	}
	else return StructTxtPxlLen_ZeroValue;
  20cff4:	68fb      	ldr	r3, [r7, #12]
  20cff6:	4a05      	ldr	r2, [pc, #20]	; (20d00c <LCD_StrChangeColorVar+0x1e8>)
  20cff8:	6810      	ldr	r0, [r2, #0]
  20cffa:	6018      	str	r0, [r3, #0]
  20cffc:	8892      	ldrh	r2, [r2, #4]
  20cffe:	809a      	strh	r2, [r3, #4]
}
  20d000:	68f8      	ldr	r0, [r7, #12]
  20d002:	3718      	adds	r7, #24
  20d004:	46bd      	mov	sp, r7
  20d006:	bd80      	pop	{r7, pc}
  20d008:	2000f818 	.word	0x2000f818
  20d00c:	20003474 	.word	0x20003474

0020d010 <LCD_StrChangeColorVarIndirect>:
StructTxtPxlLen LCD_StrChangeColorVarIndirect(int idVar, char *txt){
  20d010:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  20d014:	b08e      	sub	sp, #56	; 0x38
  20d016:	af08      	add	r7, sp, #32
  20d018:	60f8      	str	r0, [r7, #12]
  20d01a:	60b9      	str	r1, [r7, #8]
  20d01c:	607a      	str	r2, [r7, #4]
	StructTxtPxlLen temp;
	temp = LCD_StrChangeColorIndirect(FontVar[idVar].id,FontVar[idVar].xPos,FontVar[idVar].yPos,txt,FontVar[idVar].heightType,FontVar[idVar].space,FontVar[idVar].bkColor,FontVar[idVar].fontColor,FontVar[idVar].coeff,FontVar[idVar].widthType);
  20d01e:	4947      	ldr	r1, [pc, #284]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d020:	68ba      	ldr	r2, [r7, #8]
  20d022:	4613      	mov	r3, r2
  20d024:	011b      	lsls	r3, r3, #4
  20d026:	1a9b      	subs	r3, r3, r2
  20d028:	009b      	lsls	r3, r3, #2
  20d02a:	440b      	add	r3, r1
  20d02c:	881b      	ldrh	r3, [r3, #0]
  20d02e:	469e      	mov	lr, r3
  20d030:	4942      	ldr	r1, [pc, #264]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d032:	68ba      	ldr	r2, [r7, #8]
  20d034:	4613      	mov	r3, r2
  20d036:	011b      	lsls	r3, r3, #4
  20d038:	1a9b      	subs	r3, r3, r2
  20d03a:	009b      	lsls	r3, r3, #2
  20d03c:	440b      	add	r3, r1
  20d03e:	3302      	adds	r3, #2
  20d040:	881b      	ldrh	r3, [r3, #0]
  20d042:	469c      	mov	ip, r3
  20d044:	493d      	ldr	r1, [pc, #244]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d046:	68ba      	ldr	r2, [r7, #8]
  20d048:	4613      	mov	r3, r2
  20d04a:	011b      	lsls	r3, r3, #4
  20d04c:	1a9b      	subs	r3, r3, r2
  20d04e:	009b      	lsls	r3, r3, #2
  20d050:	440b      	add	r3, r1
  20d052:	3304      	adds	r3, #4
  20d054:	881b      	ldrh	r3, [r3, #0]
  20d056:	4698      	mov	r8, r3
  20d058:	4938      	ldr	r1, [pc, #224]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d05a:	68ba      	ldr	r2, [r7, #8]
  20d05c:	4613      	mov	r3, r2
  20d05e:	011b      	lsls	r3, r3, #4
  20d060:	1a9b      	subs	r3, r3, r2
  20d062:	009b      	lsls	r3, r3, #2
  20d064:	440b      	add	r3, r1
  20d066:	3306      	adds	r3, #6
  20d068:	f993 3000 	ldrsb.w	r3, [r3]
  20d06c:	461e      	mov	r6, r3
  20d06e:	4933      	ldr	r1, [pc, #204]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d070:	68ba      	ldr	r2, [r7, #8]
  20d072:	4613      	mov	r3, r2
  20d074:	011b      	lsls	r3, r3, #4
  20d076:	1a9b      	subs	r3, r3, r2
  20d078:	009b      	lsls	r3, r3, #2
  20d07a:	440b      	add	r3, r1
  20d07c:	3307      	adds	r3, #7
  20d07e:	781b      	ldrb	r3, [r3, #0]
  20d080:	603b      	str	r3, [r7, #0]
  20d082:	492e      	ldr	r1, [pc, #184]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d084:	68ba      	ldr	r2, [r7, #8]
  20d086:	4613      	mov	r3, r2
  20d088:	011b      	lsls	r3, r3, #4
  20d08a:	1a9b      	subs	r3, r3, r2
  20d08c:	009b      	lsls	r3, r3, #2
  20d08e:	440b      	add	r3, r1
  20d090:	3308      	adds	r3, #8
  20d092:	6819      	ldr	r1, [r3, #0]
  20d094:	4829      	ldr	r0, [pc, #164]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d096:	68ba      	ldr	r2, [r7, #8]
  20d098:	4613      	mov	r3, r2
  20d09a:	011b      	lsls	r3, r3, #4
  20d09c:	1a9b      	subs	r3, r3, r2
  20d09e:	009b      	lsls	r3, r3, #2
  20d0a0:	4403      	add	r3, r0
  20d0a2:	3310      	adds	r3, #16
  20d0a4:	6818      	ldr	r0, [r3, #0]
  20d0a6:	4c25      	ldr	r4, [pc, #148]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d0a8:	68ba      	ldr	r2, [r7, #8]
  20d0aa:	4613      	mov	r3, r2
  20d0ac:	011b      	lsls	r3, r3, #4
  20d0ae:	1a9b      	subs	r3, r3, r2
  20d0b0:	009b      	lsls	r3, r3, #2
  20d0b2:	4423      	add	r3, r4
  20d0b4:	3318      	adds	r3, #24
  20d0b6:	681b      	ldr	r3, [r3, #0]
  20d0b8:	b2dc      	uxtb	r4, r3
  20d0ba:	4d20      	ldr	r5, [pc, #128]	; (20d13c <LCD_StrChangeColorVarIndirect+0x12c>)
  20d0bc:	68ba      	ldr	r2, [r7, #8]
  20d0be:	4613      	mov	r3, r2
  20d0c0:	011b      	lsls	r3, r3, #4
  20d0c2:	1a9b      	subs	r3, r3, r2
  20d0c4:	009b      	lsls	r3, r3, #2
  20d0c6:	442b      	add	r3, r5
  20d0c8:	331c      	adds	r3, #28
  20d0ca:	781b      	ldrb	r3, [r3, #0]
  20d0cc:	f107 0510 	add.w	r5, r7, #16
  20d0d0:	9306      	str	r3, [sp, #24]
  20d0d2:	9405      	str	r4, [sp, #20]
  20d0d4:	9004      	str	r0, [sp, #16]
  20d0d6:	9103      	str	r1, [sp, #12]
  20d0d8:	683b      	ldr	r3, [r7, #0]
  20d0da:	9302      	str	r3, [sp, #8]
  20d0dc:	9601      	str	r6, [sp, #4]
  20d0de:	687b      	ldr	r3, [r7, #4]
  20d0e0:	9300      	str	r3, [sp, #0]
  20d0e2:	4643      	mov	r3, r8
  20d0e4:	4662      	mov	r2, ip
  20d0e6:	4671      	mov	r1, lr
  20d0e8:	4628      	mov	r0, r5
  20d0ea:	f7ff fa29 	bl	20c540 <LCD_StrChangeColorIndirect>
	if((temp.height==0)&&(temp.inChar==0)&&(temp.inPixel==0))
  20d0ee:	8abb      	ldrh	r3, [r7, #20]
  20d0f0:	2b00      	cmp	r3, #0
  20d0f2:	d10e      	bne.n	20d112 <LCD_StrChangeColorVarIndirect+0x102>
  20d0f4:	8a3b      	ldrh	r3, [r7, #16]
  20d0f6:	2b00      	cmp	r3, #0
  20d0f8:	d10b      	bne.n	20d112 <LCD_StrChangeColorVarIndirect+0x102>
  20d0fa:	8a7b      	ldrh	r3, [r7, #18]
  20d0fc:	2b00      	cmp	r3, #0
  20d0fe:	d108      	bne.n	20d112 <LCD_StrChangeColorVarIndirect+0x102>
		return temp;
  20d100:	68fb      	ldr	r3, [r7, #12]
  20d102:	461a      	mov	r2, r3
  20d104:	f107 0310 	add.w	r3, r7, #16
  20d108:	6818      	ldr	r0, [r3, #0]
  20d10a:	6010      	str	r0, [r2, #0]
  20d10c:	889b      	ldrh	r3, [r3, #4]
  20d10e:	8093      	strh	r3, [r2, #4]
  20d110:	e00e      	b.n	20d130 <LCD_StrChangeColorVarIndirect+0x120>
	LCD_DimensionBkCorrect(idVar,temp,pLcd);
  20d112:	4b0b      	ldr	r3, [pc, #44]	; (20d140 <LCD_StrChangeColorVarIndirect+0x130>)
  20d114:	f107 0210 	add.w	r2, r7, #16
  20d118:	ca06      	ldmia	r2, {r1, r2}
  20d11a:	68b8      	ldr	r0, [r7, #8]
  20d11c:	f7ff fb6e 	bl	20c7fc <LCD_DimensionBkCorrect>
	return temp;
  20d120:	68fb      	ldr	r3, [r7, #12]
  20d122:	461a      	mov	r2, r3
  20d124:	f107 0310 	add.w	r3, r7, #16
  20d128:	6818      	ldr	r0, [r3, #0]
  20d12a:	6010      	str	r0, [r2, #0]
  20d12c:	889b      	ldrh	r3, [r3, #4]
  20d12e:	8093      	strh	r3, [r2, #4]
}
  20d130:	68f8      	ldr	r0, [r7, #12]
  20d132:	3718      	adds	r7, #24
  20d134:	46bd      	mov	sp, r7
  20d136:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  20d13a:	bf00      	nop
  20d13c:	2000f818 	.word	0x2000f818
  20d140:	c0000000 	.word	0xc0000000

0020d144 <LCD_ResetStrMovBuffPos>:

void LCD_ResetStrMovBuffPos(void){
  20d144:	b480      	push	{r7}
  20d146:	af00      	add	r7, sp, #0
	movableFontsBuffer_pos=0;
  20d148:	4b03      	ldr	r3, [pc, #12]	; (20d158 <LCD_ResetStrMovBuffPos+0x14>)
  20d14a:	2200      	movs	r2, #0
  20d14c:	601a      	str	r2, [r3, #0]
}
  20d14e:	bf00      	nop
  20d150:	46bd      	mov	sp, r7
  20d152:	f85d 7b04 	ldr.w	r7, [sp], #4
  20d156:	4770      	bx	lr
  20d158:	2000347c 	.word	0x2000347c

0020d15c <LCD_DisplayStrMovBuffState>:
void LCD_DisplayStrMovBuffState(void){
  20d15c:	b580      	push	{r7, lr}
  20d15e:	b082      	sub	sp, #8
  20d160:	af02      	add	r7, sp, #8
	DbgVar(1,250,"\r\nMovBuff -> MaxSize: %d   LoadedSize: %d   ",LCD_MOVABLE_FONTS_BUFF_SIZE, movableFontsBuffer_pos);
  20d162:	4b06      	ldr	r3, [pc, #24]	; (20d17c <LCD_DisplayStrMovBuffState+0x20>)
  20d164:	681b      	ldr	r3, [r3, #0]
  20d166:	9300      	str	r3, [sp, #0]
  20d168:	f44f 33ff 	mov.w	r3, #130560	; 0x1fe00
  20d16c:	4a04      	ldr	r2, [pc, #16]	; (20d180 <LCD_DisplayStrMovBuffState+0x24>)
  20d16e:	21fa      	movs	r1, #250	; 0xfa
  20d170:	2001      	movs	r0, #1
  20d172:	f7f3 fbaa 	bl	2008ca <DbgVar>
}
  20d176:	bf00      	nop
  20d178:	46bd      	mov	sp, r7
  20d17a:	bd80      	pop	{r7, pc}
  20d17c:	2000347c 	.word	0x2000347c
  20d180:	00228dc4 	.word	0x00228dc4

0020d184 <LCD_StrRot>:

extern void SwapUint16(uint16_t *a, uint16_t *b);

StructTxtPxlLen LCD_StrRot(int rot, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth){
  20d184:	b5f0      	push	{r4, r5, r6, r7, lr}
  20d186:	b097      	sub	sp, #92	; 0x5c
  20d188:	af0a      	add	r7, sp, #40	; 0x28
  20d18a:	6178      	str	r0, [r7, #20]
  20d18c:	6139      	str	r1, [r7, #16]
  20d18e:	60fa      	str	r2, [r7, #12]
  20d190:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;
	int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20d192:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20d194:	f113 0f03 	cmn.w	r3, #3
  20d198:	d104      	bne.n	20d1a4 <LCD_StrRot+0x20>
  20d19a:	68f8      	ldr	r0, [r7, #12]
  20d19c:	f005 f92a 	bl	2123f4 <LCD_GetFontHeight>
  20d1a0:	4603      	mov	r3, r0
  20d1a2:	e003      	b.n	20d1ac <LCD_StrRot+0x28>
  20d1a4:	68f8      	ldr	r0, [r7, #12]
  20d1a6:	f005 f961 	bl	21246c <LCD_GetFontHalfHeight>
  20d1aa:	4603      	mov	r3, r0
  20d1ac:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(fontHeight<0)
  20d1ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d1b0:	2b00      	cmp	r3, #0
  20d1b2:	da06      	bge.n	20d1c2 <LCD_StrRot+0x3e>
		return StructTxtPxlLen_ZeroValue;
  20d1b4:	697b      	ldr	r3, [r7, #20]
  20d1b6:	4a3b      	ldr	r2, [pc, #236]	; (20d2a4 <LCD_StrRot+0x120>)
  20d1b8:	6810      	ldr	r0, [r2, #0]
  20d1ba:	6018      	str	r0, [r3, #0]
  20d1bc:	8892      	ldrh	r2, [r2, #4]
  20d1be:	809a      	strh	r2, [r3, #4]
  20d1c0:	e06b      	b.n	20d29a <LCD_StrRot+0x116>
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20d1c2:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20d1c4:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  20d1c6:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
  20d1c8:	68f8      	ldr	r0, [r7, #12]
  20d1ca:	f004 ff7f 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20d1ce:	62b8      	str	r0, [r7, #40]	; 0x28

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20d1d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d1d2:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20d1d4:	fb02 f203 	mul.w	r2, r2, r3
  20d1d8:	4b33      	ldr	r3, [pc, #204]	; (20d2a8 <LCD_StrRot+0x124>)
  20d1da:	681b      	ldr	r3, [r3, #0]
  20d1dc:	4413      	add	r3, r2
  20d1de:	627b      	str	r3, [r7, #36]	; 0x24
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20d1e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20d1e2:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20d1e6:	db06      	blt.n	20d1f6 <LCD_StrRot+0x72>
		return StructTxtPxlLen_ZeroValue;
  20d1e8:	697b      	ldr	r3, [r7, #20]
  20d1ea:	4a2e      	ldr	r2, [pc, #184]	; (20d2a4 <LCD_StrRot+0x120>)
  20d1ec:	6810      	ldr	r0, [r2, #0]
  20d1ee:	6018      	str	r0, [r3, #0]
  20d1f0:	8892      	ldrh	r2, [r2, #4]
  20d1f2:	809a      	strh	r2, [r3, #4]
  20d1f4:	e051      	b.n	20d29a <LCD_StrRot+0x116>

	temp=LCD_DrawStr(movableFontsBuffer_pos, pxlTxtLen,fontHeight, fontID,0,0,txt,movableFontsBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  20d1f6:	4b2c      	ldr	r3, [pc, #176]	; (20d2a8 <LCD_StrRot+0x124>)
  20d1f8:	681b      	ldr	r3, [r3, #0]
  20d1fa:	461c      	mov	r4, r3
  20d1fc:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20d1fe:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  20d200:	4638      	mov	r0, r7
  20d202:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20d204:	9309      	str	r3, [sp, #36]	; 0x24
  20d206:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20d208:	9308      	str	r3, [sp, #32]
  20d20a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20d20c:	9307      	str	r3, [sp, #28]
  20d20e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d210:	9306      	str	r3, [sp, #24]
  20d212:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20d214:	9305      	str	r3, [sp, #20]
  20d216:	4b25      	ldr	r3, [pc, #148]	; (20d2ac <LCD_StrRot+0x128>)
  20d218:	9304      	str	r3, [sp, #16]
  20d21a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20d21c:	9303      	str	r3, [sp, #12]
  20d21e:	2300      	movs	r3, #0
  20d220:	9302      	str	r3, [sp, #8]
  20d222:	2300      	movs	r3, #0
  20d224:	9301      	str	r3, [sp, #4]
  20d226:	68fb      	ldr	r3, [r7, #12]
  20d228:	9300      	str	r3, [sp, #0]
  20d22a:	460b      	mov	r3, r1
  20d22c:	4621      	mov	r1, r4
  20d22e:	f7fd f9f5 	bl	20a61c <LCD_DrawStr>
  20d232:	f107 031c 	add.w	r3, r7, #28
  20d236:	463a      	mov	r2, r7
  20d238:	6810      	ldr	r0, [r2, #0]
  20d23a:	6018      	str	r0, [r3, #0]
  20d23c:	8892      	ldrh	r2, [r2, #4]
  20d23e:	809a      	strh	r2, [r3, #4]
	LCD_CopyBuff2pLcd(rot,movableFontsBuffer_pos, movableFontsBuffer, pxlTxtLen,fontHeight,0, temp.inPixel, Xpos,Ypos,0);
  20d240:	4b19      	ldr	r3, [pc, #100]	; (20d2a8 <LCD_StrRot+0x124>)
  20d242:	681b      	ldr	r3, [r3, #0]
  20d244:	461e      	mov	r6, r3
  20d246:	6abd      	ldr	r5, [r7, #40]	; 0x28
  20d248:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d24a:	8bfa      	ldrh	r2, [r7, #30]
  20d24c:	68b9      	ldr	r1, [r7, #8]
  20d24e:	b289      	uxth	r1, r1
  20d250:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  20d252:	b280      	uxth	r0, r0
  20d254:	2400      	movs	r4, #0
  20d256:	9405      	str	r4, [sp, #20]
  20d258:	9004      	str	r0, [sp, #16]
  20d25a:	9103      	str	r1, [sp, #12]
  20d25c:	9202      	str	r2, [sp, #8]
  20d25e:	2200      	movs	r2, #0
  20d260:	9201      	str	r2, [sp, #4]
  20d262:	9300      	str	r3, [sp, #0]
  20d264:	462b      	mov	r3, r5
  20d266:	4a11      	ldr	r2, [pc, #68]	; (20d2ac <LCD_StrRot+0x128>)
  20d268:	4631      	mov	r1, r6
  20d26a:	6938      	ldr	r0, [r7, #16]
  20d26c:	f7fa fc6c 	bl	207b48 <LCD_CopyBuff2pLcd>
	if(rot>Rotate_0)
  20d270:	693b      	ldr	r3, [r7, #16]
  20d272:	2b00      	cmp	r3, #0
  20d274:	dd09      	ble.n	20d28a <LCD_StrRot+0x106>
		SwapUint16(&temp.inPixel,&temp.height);
  20d276:	f107 031c 	add.w	r3, r7, #28
  20d27a:	1d1a      	adds	r2, r3, #4
  20d27c:	f107 031c 	add.w	r3, r7, #28
  20d280:	3302      	adds	r3, #2
  20d282:	4611      	mov	r1, r2
  20d284:	4618      	mov	r0, r3
  20d286:	f7f4 fc53 	bl	201b30 <SwapUint16>
	return temp;
  20d28a:	697b      	ldr	r3, [r7, #20]
  20d28c:	461a      	mov	r2, r3
  20d28e:	f107 031c 	add.w	r3, r7, #28
  20d292:	6818      	ldr	r0, [r3, #0]
  20d294:	6010      	str	r0, [r2, #0]
  20d296:	889b      	ldrh	r3, [r3, #4]
  20d298:	8093      	strh	r3, [r2, #4]
}
  20d29a:	6978      	ldr	r0, [r7, #20]
  20d29c:	3734      	adds	r7, #52	; 0x34
  20d29e:	46bd      	mov	sp, r7
  20d2a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20d2a2:	bf00      	nop
  20d2a4:	20003474 	.word	0x20003474
  20d2a8:	2000347c 	.word	0x2000347c
  20d2ac:	c067f800 	.word	0xc067f800

0020d2b0 <LCD_StrChangeColorRot>:
StructTxtPxlLen LCD_StrChangeColorRot(int rot, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, int maxVal, int constWidth){
  20d2b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  20d2b2:	b099      	sub	sp, #100	; 0x64
  20d2b4:	af0c      	add	r7, sp, #48	; 0x30
  20d2b6:	6178      	str	r0, [r7, #20]
  20d2b8:	6139      	str	r1, [r7, #16]
  20d2ba:	60fa      	str	r2, [r7, #12]
  20d2bc:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;
	int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20d2be:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20d2c0:	f113 0f03 	cmn.w	r3, #3
  20d2c4:	d104      	bne.n	20d2d0 <LCD_StrChangeColorRot+0x20>
  20d2c6:	68f8      	ldr	r0, [r7, #12]
  20d2c8:	f005 f894 	bl	2123f4 <LCD_GetFontHeight>
  20d2cc:	4603      	mov	r3, r0
  20d2ce:	e003      	b.n	20d2d8 <LCD_StrChangeColorRot+0x28>
  20d2d0:	68f8      	ldr	r0, [r7, #12]
  20d2d2:	f005 f8cb 	bl	21246c <LCD_GetFontHalfHeight>
  20d2d6:	4603      	mov	r3, r0
  20d2d8:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(fontHeight<0)
  20d2da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d2dc:	2b00      	cmp	r3, #0
  20d2de:	da06      	bge.n	20d2ee <LCD_StrChangeColorRot+0x3e>
		return StructTxtPxlLen_ZeroValue;
  20d2e0:	697b      	ldr	r3, [r7, #20]
  20d2e2:	4a3d      	ldr	r2, [pc, #244]	; (20d3d8 <LCD_StrChangeColorRot+0x128>)
  20d2e4:	6810      	ldr	r0, [r2, #0]
  20d2e6:	6018      	str	r0, [r3, #0]
  20d2e8:	8892      	ldrh	r2, [r2, #4]
  20d2ea:	809a      	strh	r2, [r3, #4]
  20d2ec:	e06f      	b.n	20d3ce <LCD_StrChangeColorRot+0x11e>
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20d2ee:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20d2f0:	6d7a      	ldr	r2, [r7, #84]	; 0x54
  20d2f2:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
  20d2f4:	68f8      	ldr	r0, [r7, #12]
  20d2f6:	f004 fee9 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20d2fa:	62b8      	str	r0, [r7, #40]	; 0x28

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20d2fc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d2fe:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20d300:	fb02 f203 	mul.w	r2, r2, r3
  20d304:	4b35      	ldr	r3, [pc, #212]	; (20d3dc <LCD_StrChangeColorRot+0x12c>)
  20d306:	681b      	ldr	r3, [r3, #0]
  20d308:	4413      	add	r3, r2
  20d30a:	627b      	str	r3, [r7, #36]	; 0x24
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20d30c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20d30e:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20d312:	db06      	blt.n	20d322 <LCD_StrChangeColorRot+0x72>
		return StructTxtPxlLen_ZeroValue;
  20d314:	697b      	ldr	r3, [r7, #20]
  20d316:	4a30      	ldr	r2, [pc, #192]	; (20d3d8 <LCD_StrChangeColorRot+0x128>)
  20d318:	6810      	ldr	r0, [r2, #0]
  20d31a:	6018      	str	r0, [r3, #0]
  20d31c:	8892      	ldrh	r2, [r2, #4]
  20d31e:	809a      	strh	r2, [r3, #4]
  20d320:	e055      	b.n	20d3ce <LCD_StrChangeColorRot+0x11e>

	temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, pxlTxtLen,fontHeight, fontID,0,0,txt,movableFontsBuffer,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20d322:	4b2e      	ldr	r3, [pc, #184]	; (20d3dc <LCD_StrChangeColorRot+0x12c>)
  20d324:	681b      	ldr	r3, [r3, #0]
  20d326:	461d      	mov	r5, r3
  20d328:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  20d32a:	6afc      	ldr	r4, [r7, #44]	; 0x2c
  20d32c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20d32e:	b2db      	uxtb	r3, r3
  20d330:	4638      	mov	r0, r7
  20d332:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20d334:	920a      	str	r2, [sp, #40]	; 0x28
  20d336:	9309      	str	r3, [sp, #36]	; 0x24
  20d338:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20d33a:	9308      	str	r3, [sp, #32]
  20d33c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20d33e:	9307      	str	r3, [sp, #28]
  20d340:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d342:	9306      	str	r3, [sp, #24]
  20d344:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20d346:	9305      	str	r3, [sp, #20]
  20d348:	4b25      	ldr	r3, [pc, #148]	; (20d3e0 <LCD_StrChangeColorRot+0x130>)
  20d34a:	9304      	str	r3, [sp, #16]
  20d34c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20d34e:	9303      	str	r3, [sp, #12]
  20d350:	2300      	movs	r3, #0
  20d352:	9302      	str	r3, [sp, #8]
  20d354:	2300      	movs	r3, #0
  20d356:	9301      	str	r3, [sp, #4]
  20d358:	68fb      	ldr	r3, [r7, #12]
  20d35a:	9300      	str	r3, [sp, #0]
  20d35c:	4623      	mov	r3, r4
  20d35e:	460a      	mov	r2, r1
  20d360:	4629      	mov	r1, r5
  20d362:	f7fd f9c1 	bl	20a6e8 <LCD_DrawStrChangeColor>
  20d366:	f107 031c 	add.w	r3, r7, #28
  20d36a:	463a      	mov	r2, r7
  20d36c:	6810      	ldr	r0, [r2, #0]
  20d36e:	6018      	str	r0, [r3, #0]
  20d370:	8892      	ldrh	r2, [r2, #4]
  20d372:	809a      	strh	r2, [r3, #4]
	LCD_CopyBuff2pLcd(rot,movableFontsBuffer_pos, movableFontsBuffer, pxlTxtLen,fontHeight,0, temp.inPixel, Xpos,Ypos,0);
  20d374:	4b19      	ldr	r3, [pc, #100]	; (20d3dc <LCD_StrChangeColorRot+0x12c>)
  20d376:	681b      	ldr	r3, [r3, #0]
  20d378:	461e      	mov	r6, r3
  20d37a:	6abd      	ldr	r5, [r7, #40]	; 0x28
  20d37c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d37e:	8bfa      	ldrh	r2, [r7, #30]
  20d380:	68b9      	ldr	r1, [r7, #8]
  20d382:	b289      	uxth	r1, r1
  20d384:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  20d386:	b280      	uxth	r0, r0
  20d388:	2400      	movs	r4, #0
  20d38a:	9405      	str	r4, [sp, #20]
  20d38c:	9004      	str	r0, [sp, #16]
  20d38e:	9103      	str	r1, [sp, #12]
  20d390:	9202      	str	r2, [sp, #8]
  20d392:	2200      	movs	r2, #0
  20d394:	9201      	str	r2, [sp, #4]
  20d396:	9300      	str	r3, [sp, #0]
  20d398:	462b      	mov	r3, r5
  20d39a:	4a11      	ldr	r2, [pc, #68]	; (20d3e0 <LCD_StrChangeColorRot+0x130>)
  20d39c:	4631      	mov	r1, r6
  20d39e:	6938      	ldr	r0, [r7, #16]
  20d3a0:	f7fa fbd2 	bl	207b48 <LCD_CopyBuff2pLcd>
	if(rot>Rotate_0)
  20d3a4:	693b      	ldr	r3, [r7, #16]
  20d3a6:	2b00      	cmp	r3, #0
  20d3a8:	dd09      	ble.n	20d3be <LCD_StrChangeColorRot+0x10e>
		SwapUint16(&temp.inPixel,&temp.height);
  20d3aa:	f107 031c 	add.w	r3, r7, #28
  20d3ae:	1d1a      	adds	r2, r3, #4
  20d3b0:	f107 031c 	add.w	r3, r7, #28
  20d3b4:	3302      	adds	r3, #2
  20d3b6:	4611      	mov	r1, r2
  20d3b8:	4618      	mov	r0, r3
  20d3ba:	f7f4 fbb9 	bl	201b30 <SwapUint16>
	return temp;
  20d3be:	697b      	ldr	r3, [r7, #20]
  20d3c0:	461a      	mov	r2, r3
  20d3c2:	f107 031c 	add.w	r3, r7, #28
  20d3c6:	6818      	ldr	r0, [r3, #0]
  20d3c8:	6010      	str	r0, [r2, #0]
  20d3ca:	889b      	ldrh	r3, [r3, #4]
  20d3cc:	8093      	strh	r3, [r2, #4]
}
  20d3ce:	6978      	ldr	r0, [r7, #20]
  20d3d0:	3734      	adds	r7, #52	; 0x34
  20d3d2:	46bd      	mov	sp, r7
  20d3d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20d3d6:	bf00      	nop
  20d3d8:	20003474 	.word	0x20003474
  20d3dc:	2000347c 	.word	0x2000347c
  20d3e0:	c067f800 	.word	0xc067f800

0020d3e4 <LCD_StrRotVar>:
StructTxtPxlLen LCD_StrRotVar(int idVar, int rot ,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth, uint32_t bkScreenColor){
  20d3e4:	b5f0      	push	{r4, r5, r6, r7, lr}
  20d3e6:	b097      	sub	sp, #92	; 0x5c
  20d3e8:	af0a      	add	r7, sp, #40	; 0x28
  20d3ea:	6178      	str	r0, [r7, #20]
  20d3ec:	6139      	str	r1, [r7, #16]
  20d3ee:	60fa      	str	r2, [r7, #12]
  20d3f0:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;
	int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20d3f2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d3f4:	f113 0f03 	cmn.w	r3, #3
  20d3f8:	d104      	bne.n	20d404 <LCD_StrRotVar+0x20>
  20d3fa:	68b8      	ldr	r0, [r7, #8]
  20d3fc:	f004 fffa 	bl	2123f4 <LCD_GetFontHeight>
  20d400:	4603      	mov	r3, r0
  20d402:	e003      	b.n	20d40c <LCD_StrRotVar+0x28>
  20d404:	68b8      	ldr	r0, [r7, #8]
  20d406:	f005 f831 	bl	21246c <LCD_GetFontHalfHeight>
  20d40a:	4603      	mov	r3, r0
  20d40c:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(fontHeight<0)
  20d40e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d410:	2b00      	cmp	r3, #0
  20d412:	da06      	bge.n	20d422 <LCD_StrRotVar+0x3e>
		return StructTxtPxlLen_ZeroValue;
  20d414:	697b      	ldr	r3, [r7, #20]
  20d416:	4a91      	ldr	r2, [pc, #580]	; (20d65c <LCD_StrRotVar+0x278>)
  20d418:	6810      	ldr	r0, [r2, #0]
  20d41a:	6018      	str	r0, [r3, #0]
  20d41c:	8892      	ldrh	r2, [r2, #4]
  20d41e:	809a      	strh	r2, [r3, #4]
  20d420:	e118      	b.n	20d654 <LCD_StrRotVar+0x270>
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20d422:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20d424:	6dba      	ldr	r2, [r7, #88]	; 0x58
  20d426:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20d428:	68b8      	ldr	r0, [r7, #8]
  20d42a:	f004 fe4f 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20d42e:	62b8      	str	r0, [r7, #40]	; 0x28

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20d430:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d432:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20d434:	fb02 f203 	mul.w	r2, r2, r3
  20d438:	4b89      	ldr	r3, [pc, #548]	; (20d660 <LCD_StrRotVar+0x27c>)
  20d43a:	681b      	ldr	r3, [r3, #0]
  20d43c:	4413      	add	r3, r2
  20d43e:	627b      	str	r3, [r7, #36]	; 0x24
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20d440:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20d442:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20d446:	db06      	blt.n	20d456 <LCD_StrRotVar+0x72>
		return StructTxtPxlLen_ZeroValue;
  20d448:	697b      	ldr	r3, [r7, #20]
  20d44a:	4a84      	ldr	r2, [pc, #528]	; (20d65c <LCD_StrRotVar+0x278>)
  20d44c:	6810      	ldr	r0, [r2, #0]
  20d44e:	6018      	str	r0, [r3, #0]
  20d450:	8892      	ldrh	r2, [r2, #4]
  20d452:	809a      	strh	r2, [r3, #4]
  20d454:	e0fe      	b.n	20d654 <LCD_StrRotVar+0x270>

	FontVar[idVar].id=fontID;
  20d456:	68bb      	ldr	r3, [r7, #8]
  20d458:	b298      	uxth	r0, r3
  20d45a:	4982      	ldr	r1, [pc, #520]	; (20d664 <LCD_StrRotVar+0x280>)
  20d45c:	693a      	ldr	r2, [r7, #16]
  20d45e:	4613      	mov	r3, r2
  20d460:	011b      	lsls	r3, r3, #4
  20d462:	1a9b      	subs	r3, r3, r2
  20d464:	009b      	lsls	r3, r3, #2
  20d466:	440b      	add	r3, r1
  20d468:	4602      	mov	r2, r0
  20d46a:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].xPos=Xpos;
  20d46c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20d46e:	b298      	uxth	r0, r3
  20d470:	497c      	ldr	r1, [pc, #496]	; (20d664 <LCD_StrRotVar+0x280>)
  20d472:	693a      	ldr	r2, [r7, #16]
  20d474:	4613      	mov	r3, r2
  20d476:	011b      	lsls	r3, r3, #4
  20d478:	1a9b      	subs	r3, r3, r2
  20d47a:	009b      	lsls	r3, r3, #2
  20d47c:	440b      	add	r3, r1
  20d47e:	3302      	adds	r3, #2
  20d480:	4602      	mov	r2, r0
  20d482:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].yPos=Ypos;
  20d484:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20d486:	b298      	uxth	r0, r3
  20d488:	4976      	ldr	r1, [pc, #472]	; (20d664 <LCD_StrRotVar+0x280>)
  20d48a:	693a      	ldr	r2, [r7, #16]
  20d48c:	4613      	mov	r3, r2
  20d48e:	011b      	lsls	r3, r3, #4
  20d490:	1a9b      	subs	r3, r3, r2
  20d492:	009b      	lsls	r3, r3, #2
  20d494:	440b      	add	r3, r1
  20d496:	3304      	adds	r3, #4
  20d498:	4602      	mov	r2, r0
  20d49a:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].heightType=OnlyDigits;
  20d49c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d49e:	b258      	sxtb	r0, r3
  20d4a0:	4970      	ldr	r1, [pc, #448]	; (20d664 <LCD_StrRotVar+0x280>)
  20d4a2:	693a      	ldr	r2, [r7, #16]
  20d4a4:	4613      	mov	r3, r2
  20d4a6:	011b      	lsls	r3, r3, #4
  20d4a8:	1a9b      	subs	r3, r3, r2
  20d4aa:	009b      	lsls	r3, r3, #2
  20d4ac:	440b      	add	r3, r1
  20d4ae:	3306      	adds	r3, #6
  20d4b0:	4602      	mov	r2, r0
  20d4b2:	701a      	strb	r2, [r3, #0]
	FontVar[idVar].space=space;
  20d4b4:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20d4b6:	b2d8      	uxtb	r0, r3
  20d4b8:	496a      	ldr	r1, [pc, #424]	; (20d664 <LCD_StrRotVar+0x280>)
  20d4ba:	693a      	ldr	r2, [r7, #16]
  20d4bc:	4613      	mov	r3, r2
  20d4be:	011b      	lsls	r3, r3, #4
  20d4c0:	1a9b      	subs	r3, r3, r2
  20d4c2:	009b      	lsls	r3, r3, #2
  20d4c4:	440b      	add	r3, r1
  20d4c6:	3307      	adds	r3, #7
  20d4c8:	4602      	mov	r2, r0
  20d4ca:	701a      	strb	r2, [r3, #0]
	FontVar[idVar].bkColor=bkColor;
  20d4cc:	4965      	ldr	r1, [pc, #404]	; (20d664 <LCD_StrRotVar+0x280>)
  20d4ce:	693a      	ldr	r2, [r7, #16]
  20d4d0:	4613      	mov	r3, r2
  20d4d2:	011b      	lsls	r3, r3, #4
  20d4d4:	1a9b      	subs	r3, r3, r2
  20d4d6:	009b      	lsls	r3, r3, #2
  20d4d8:	440b      	add	r3, r1
  20d4da:	3308      	adds	r3, #8
  20d4dc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  20d4de:	601a      	str	r2, [r3, #0]
	FontVar[idVar].bkScreenColor=bkScreenColor;
  20d4e0:	4960      	ldr	r1, [pc, #384]	; (20d664 <LCD_StrRotVar+0x280>)
  20d4e2:	693a      	ldr	r2, [r7, #16]
  20d4e4:	4613      	mov	r3, r2
  20d4e6:	011b      	lsls	r3, r3, #4
  20d4e8:	1a9b      	subs	r3, r3, r2
  20d4ea:	009b      	lsls	r3, r3, #2
  20d4ec:	440b      	add	r3, r1
  20d4ee:	330c      	adds	r3, #12
  20d4f0:	6eba      	ldr	r2, [r7, #104]	; 0x68
  20d4f2:	601a      	str	r2, [r3, #0]
	FontVar[idVar].coeff=coeff;
  20d4f4:	495b      	ldr	r1, [pc, #364]	; (20d664 <LCD_StrRotVar+0x280>)
  20d4f6:	693a      	ldr	r2, [r7, #16]
  20d4f8:	4613      	mov	r3, r2
  20d4fa:	011b      	lsls	r3, r3, #4
  20d4fc:	1a9b      	subs	r3, r3, r2
  20d4fe:	009b      	lsls	r3, r3, #2
  20d500:	440b      	add	r3, r1
  20d502:	3318      	adds	r3, #24
  20d504:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20d506:	601a      	str	r2, [r3, #0]
	FontVar[idVar].widthType=constWidth;
  20d508:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20d50a:	b2d8      	uxtb	r0, r3
  20d50c:	4955      	ldr	r1, [pc, #340]	; (20d664 <LCD_StrRotVar+0x280>)
  20d50e:	693a      	ldr	r2, [r7, #16]
  20d510:	4613      	mov	r3, r2
  20d512:	011b      	lsls	r3, r3, #4
  20d514:	1a9b      	subs	r3, r3, r2
  20d516:	009b      	lsls	r3, r3, #2
  20d518:	440b      	add	r3, r1
  20d51a:	331c      	adds	r3, #28
  20d51c:	4602      	mov	r2, r0
  20d51e:	701a      	strb	r2, [r3, #0]
	FontVar[idVar].rotate=rot;
  20d520:	68fb      	ldr	r3, [r7, #12]
  20d522:	b2d8      	uxtb	r0, r3
  20d524:	494f      	ldr	r1, [pc, #316]	; (20d664 <LCD_StrRotVar+0x280>)
  20d526:	693a      	ldr	r2, [r7, #16]
  20d528:	4613      	mov	r3, r2
  20d52a:	011b      	lsls	r3, r3, #4
  20d52c:	1a9b      	subs	r3, r3, r2
  20d52e:	009b      	lsls	r3, r3, #2
  20d530:	440b      	add	r3, r1
  20d532:	3314      	adds	r3, #20
  20d534:	4602      	mov	r2, r0
  20d536:	701a      	strb	r2, [r3, #0]

	temp=LCD_DrawStr(movableFontsBuffer_pos, pxlTxtLen,fontHeight, fontID,0,0,txt,movableFontsBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  20d538:	4b49      	ldr	r3, [pc, #292]	; (20d660 <LCD_StrRotVar+0x27c>)
  20d53a:	681b      	ldr	r3, [r3, #0]
  20d53c:	461c      	mov	r4, r3
  20d53e:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20d540:	6af9      	ldr	r1, [r7, #44]	; 0x2c
  20d542:	4638      	mov	r0, r7
  20d544:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20d546:	9309      	str	r3, [sp, #36]	; 0x24
  20d548:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20d54a:	9308      	str	r3, [sp, #32]
  20d54c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20d54e:	9307      	str	r3, [sp, #28]
  20d550:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20d552:	9306      	str	r3, [sp, #24]
  20d554:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d556:	9305      	str	r3, [sp, #20]
  20d558:	4b43      	ldr	r3, [pc, #268]	; (20d668 <LCD_StrRotVar+0x284>)
  20d55a:	9304      	str	r3, [sp, #16]
  20d55c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20d55e:	9303      	str	r3, [sp, #12]
  20d560:	2300      	movs	r3, #0
  20d562:	9302      	str	r3, [sp, #8]
  20d564:	2300      	movs	r3, #0
  20d566:	9301      	str	r3, [sp, #4]
  20d568:	68bb      	ldr	r3, [r7, #8]
  20d56a:	9300      	str	r3, [sp, #0]
  20d56c:	460b      	mov	r3, r1
  20d56e:	4621      	mov	r1, r4
  20d570:	f7fd f854 	bl	20a61c <LCD_DrawStr>
  20d574:	f107 031c 	add.w	r3, r7, #28
  20d578:	463a      	mov	r2, r7
  20d57a:	6810      	ldr	r0, [r2, #0]
  20d57c:	6018      	str	r0, [r3, #0]
  20d57e:	8892      	ldrh	r2, [r2, #4]
  20d580:	809a      	strh	r2, [r3, #4]
	LCD_CopyBuff2pLcd(rot,movableFontsBuffer_pos, movableFontsBuffer, pxlTxtLen,fontHeight,0, temp.inPixel, Xpos,Ypos,0);
  20d582:	4b37      	ldr	r3, [pc, #220]	; (20d660 <LCD_StrRotVar+0x27c>)
  20d584:	681b      	ldr	r3, [r3, #0]
  20d586:	461e      	mov	r6, r3
  20d588:	6abd      	ldr	r5, [r7, #40]	; 0x28
  20d58a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d58c:	8bfa      	ldrh	r2, [r7, #30]
  20d58e:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20d590:	b289      	uxth	r1, r1
  20d592:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20d594:	b280      	uxth	r0, r0
  20d596:	2400      	movs	r4, #0
  20d598:	9405      	str	r4, [sp, #20]
  20d59a:	9004      	str	r0, [sp, #16]
  20d59c:	9103      	str	r1, [sp, #12]
  20d59e:	9202      	str	r2, [sp, #8]
  20d5a0:	2200      	movs	r2, #0
  20d5a2:	9201      	str	r2, [sp, #4]
  20d5a4:	9300      	str	r3, [sp, #0]
  20d5a6:	462b      	mov	r3, r5
  20d5a8:	4a2f      	ldr	r2, [pc, #188]	; (20d668 <LCD_StrRotVar+0x284>)
  20d5aa:	4631      	mov	r1, r6
  20d5ac:	68f8      	ldr	r0, [r7, #12]
  20d5ae:	f7fa facb 	bl	207b48 <LCD_CopyBuff2pLcd>

	if(rot>Rotate_0)
  20d5b2:	68fb      	ldr	r3, [r7, #12]
  20d5b4:	2b00      	cmp	r3, #0
  20d5b6:	dd09      	ble.n	20d5cc <LCD_StrRotVar+0x1e8>
		SwapUint16(&temp.inPixel,&temp.height);
  20d5b8:	f107 031c 	add.w	r3, r7, #28
  20d5bc:	1d1a      	adds	r2, r3, #4
  20d5be:	f107 031c 	add.w	r3, r7, #28
  20d5c2:	3302      	adds	r3, #2
  20d5c4:	4611      	mov	r1, r2
  20d5c6:	4618      	mov	r0, r3
  20d5c8:	f7f4 fab2 	bl	201b30 <SwapUint16>

	FontVar[idVar].xPos_prev = FontVar[idVar].xPos;
  20d5cc:	4925      	ldr	r1, [pc, #148]	; (20d664 <LCD_StrRotVar+0x280>)
  20d5ce:	693a      	ldr	r2, [r7, #16]
  20d5d0:	4613      	mov	r3, r2
  20d5d2:	011b      	lsls	r3, r3, #4
  20d5d4:	1a9b      	subs	r3, r3, r2
  20d5d6:	009b      	lsls	r3, r3, #2
  20d5d8:	440b      	add	r3, r1
  20d5da:	3302      	adds	r3, #2
  20d5dc:	8818      	ldrh	r0, [r3, #0]
  20d5de:	4921      	ldr	r1, [pc, #132]	; (20d664 <LCD_StrRotVar+0x280>)
  20d5e0:	693a      	ldr	r2, [r7, #16]
  20d5e2:	4613      	mov	r3, r2
  20d5e4:	011b      	lsls	r3, r3, #4
  20d5e6:	1a9b      	subs	r3, r3, r2
  20d5e8:	009b      	lsls	r3, r3, #2
  20d5ea:	440b      	add	r3, r1
  20d5ec:	331e      	adds	r3, #30
  20d5ee:	4602      	mov	r2, r0
  20d5f0:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].yPos_prev = FontVar[idVar].yPos;
  20d5f2:	491c      	ldr	r1, [pc, #112]	; (20d664 <LCD_StrRotVar+0x280>)
  20d5f4:	693a      	ldr	r2, [r7, #16]
  20d5f6:	4613      	mov	r3, r2
  20d5f8:	011b      	lsls	r3, r3, #4
  20d5fa:	1a9b      	subs	r3, r3, r2
  20d5fc:	009b      	lsls	r3, r3, #2
  20d5fe:	440b      	add	r3, r1
  20d600:	3304      	adds	r3, #4
  20d602:	8818      	ldrh	r0, [r3, #0]
  20d604:	4917      	ldr	r1, [pc, #92]	; (20d664 <LCD_StrRotVar+0x280>)
  20d606:	693a      	ldr	r2, [r7, #16]
  20d608:	4613      	mov	r3, r2
  20d60a:	011b      	lsls	r3, r3, #4
  20d60c:	1a9b      	subs	r3, r3, r2
  20d60e:	009b      	lsls	r3, r3, #2
  20d610:	440b      	add	r3, r1
  20d612:	3320      	adds	r3, #32
  20d614:	4602      	mov	r2, r0
  20d616:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].widthPxl_prev = temp.inPixel;
  20d618:	8bf8      	ldrh	r0, [r7, #30]
  20d61a:	4912      	ldr	r1, [pc, #72]	; (20d664 <LCD_StrRotVar+0x280>)
  20d61c:	693a      	ldr	r2, [r7, #16]
  20d61e:	4613      	mov	r3, r2
  20d620:	011b      	lsls	r3, r3, #4
  20d622:	1a9b      	subs	r3, r3, r2
  20d624:	009b      	lsls	r3, r3, #2
  20d626:	440b      	add	r3, r1
  20d628:	3322      	adds	r3, #34	; 0x22
  20d62a:	4602      	mov	r2, r0
  20d62c:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].heightPxl_prev = temp.height;
  20d62e:	8c38      	ldrh	r0, [r7, #32]
  20d630:	490c      	ldr	r1, [pc, #48]	; (20d664 <LCD_StrRotVar+0x280>)
  20d632:	693a      	ldr	r2, [r7, #16]
  20d634:	4613      	mov	r3, r2
  20d636:	011b      	lsls	r3, r3, #4
  20d638:	1a9b      	subs	r3, r3, r2
  20d63a:	009b      	lsls	r3, r3, #2
  20d63c:	440b      	add	r3, r1
  20d63e:	3324      	adds	r3, #36	; 0x24
  20d640:	4602      	mov	r2, r0
  20d642:	801a      	strh	r2, [r3, #0]

	return temp;
  20d644:	697b      	ldr	r3, [r7, #20]
  20d646:	461a      	mov	r2, r3
  20d648:	f107 031c 	add.w	r3, r7, #28
  20d64c:	6818      	ldr	r0, [r3, #0]
  20d64e:	6010      	str	r0, [r2, #0]
  20d650:	889b      	ldrh	r3, [r3, #4]
  20d652:	8093      	strh	r3, [r2, #4]
}
  20d654:	6978      	ldr	r0, [r7, #20]
  20d656:	3734      	adds	r7, #52	; 0x34
  20d658:	46bd      	mov	sp, r7
  20d65a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20d65c:	20003474 	.word	0x20003474
  20d660:	2000347c 	.word	0x2000347c
  20d664:	2000f818 	.word	0x2000f818
  20d668:	c067f800 	.word	0xc067f800

0020d66c <LCD_StrChangeColorRotVar>:

StructTxtPxlLen LCD_StrChangeColorRotVar(int idVar, int rot ,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, int maxVal, int constWidth, uint32_t bkScreenColor){
  20d66c:	b5f0      	push	{r4, r5, r6, r7, lr}
  20d66e:	b099      	sub	sp, #100	; 0x64
  20d670:	af0c      	add	r7, sp, #48	; 0x30
  20d672:	6178      	str	r0, [r7, #20]
  20d674:	6139      	str	r1, [r7, #16]
  20d676:	60fa      	str	r2, [r7, #12]
  20d678:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;
	int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20d67a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d67c:	f113 0f03 	cmn.w	r3, #3
  20d680:	d104      	bne.n	20d68c <LCD_StrChangeColorRotVar+0x20>
  20d682:	68b8      	ldr	r0, [r7, #8]
  20d684:	f004 feb6 	bl	2123f4 <LCD_GetFontHeight>
  20d688:	4603      	mov	r3, r0
  20d68a:	e003      	b.n	20d694 <LCD_StrChangeColorRotVar+0x28>
  20d68c:	68b8      	ldr	r0, [r7, #8]
  20d68e:	f004 feed 	bl	21246c <LCD_GetFontHalfHeight>
  20d692:	4603      	mov	r3, r0
  20d694:	62fb      	str	r3, [r7, #44]	; 0x2c
	if(fontHeight<0)
  20d696:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d698:	2b00      	cmp	r3, #0
  20d69a:	da06      	bge.n	20d6aa <LCD_StrChangeColorRotVar+0x3e>
		return StructTxtPxlLen_ZeroValue;
  20d69c:	697b      	ldr	r3, [r7, #20]
  20d69e:	4a98      	ldr	r2, [pc, #608]	; (20d900 <LCD_StrChangeColorRotVar+0x294>)
  20d6a0:	6810      	ldr	r0, [r2, #0]
  20d6a2:	6018      	str	r0, [r3, #0]
  20d6a4:	8892      	ldrh	r2, [r2, #4]
  20d6a6:	809a      	strh	r2, [r3, #4]
  20d6a8:	e126      	b.n	20d8f8 <LCD_StrChangeColorRotVar+0x28c>
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20d6aa:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20d6ac:	6dba      	ldr	r2, [r7, #88]	; 0x58
  20d6ae:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20d6b0:	68b8      	ldr	r0, [r7, #8]
  20d6b2:	f004 fd0b 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20d6b6:	62b8      	str	r0, [r7, #40]	; 0x28

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20d6b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d6ba:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20d6bc:	fb02 f203 	mul.w	r2, r2, r3
  20d6c0:	4b90      	ldr	r3, [pc, #576]	; (20d904 <LCD_StrChangeColorRotVar+0x298>)
  20d6c2:	681b      	ldr	r3, [r3, #0]
  20d6c4:	4413      	add	r3, r2
  20d6c6:	627b      	str	r3, [r7, #36]	; 0x24
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20d6c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20d6ca:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20d6ce:	db06      	blt.n	20d6de <LCD_StrChangeColorRotVar+0x72>
		return StructTxtPxlLen_ZeroValue;
  20d6d0:	697b      	ldr	r3, [r7, #20]
  20d6d2:	4a8b      	ldr	r2, [pc, #556]	; (20d900 <LCD_StrChangeColorRotVar+0x294>)
  20d6d4:	6810      	ldr	r0, [r2, #0]
  20d6d6:	6018      	str	r0, [r3, #0]
  20d6d8:	8892      	ldrh	r2, [r2, #4]
  20d6da:	809a      	strh	r2, [r3, #4]
  20d6dc:	e10c      	b.n	20d8f8 <LCD_StrChangeColorRotVar+0x28c>

	FontVar[idVar].id=fontID;
  20d6de:	68bb      	ldr	r3, [r7, #8]
  20d6e0:	b298      	uxth	r0, r3
  20d6e2:	4989      	ldr	r1, [pc, #548]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d6e4:	693a      	ldr	r2, [r7, #16]
  20d6e6:	4613      	mov	r3, r2
  20d6e8:	011b      	lsls	r3, r3, #4
  20d6ea:	1a9b      	subs	r3, r3, r2
  20d6ec:	009b      	lsls	r3, r3, #2
  20d6ee:	440b      	add	r3, r1
  20d6f0:	4602      	mov	r2, r0
  20d6f2:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].xPos=Xpos;
  20d6f4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20d6f6:	b298      	uxth	r0, r3
  20d6f8:	4983      	ldr	r1, [pc, #524]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d6fa:	693a      	ldr	r2, [r7, #16]
  20d6fc:	4613      	mov	r3, r2
  20d6fe:	011b      	lsls	r3, r3, #4
  20d700:	1a9b      	subs	r3, r3, r2
  20d702:	009b      	lsls	r3, r3, #2
  20d704:	440b      	add	r3, r1
  20d706:	3302      	adds	r3, #2
  20d708:	4602      	mov	r2, r0
  20d70a:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].yPos=Ypos;
  20d70c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20d70e:	b298      	uxth	r0, r3
  20d710:	497d      	ldr	r1, [pc, #500]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d712:	693a      	ldr	r2, [r7, #16]
  20d714:	4613      	mov	r3, r2
  20d716:	011b      	lsls	r3, r3, #4
  20d718:	1a9b      	subs	r3, r3, r2
  20d71a:	009b      	lsls	r3, r3, #2
  20d71c:	440b      	add	r3, r1
  20d71e:	3304      	adds	r3, #4
  20d720:	4602      	mov	r2, r0
  20d722:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].heightType=OnlyDigits;
  20d724:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d726:	b258      	sxtb	r0, r3
  20d728:	4977      	ldr	r1, [pc, #476]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d72a:	693a      	ldr	r2, [r7, #16]
  20d72c:	4613      	mov	r3, r2
  20d72e:	011b      	lsls	r3, r3, #4
  20d730:	1a9b      	subs	r3, r3, r2
  20d732:	009b      	lsls	r3, r3, #2
  20d734:	440b      	add	r3, r1
  20d736:	3306      	adds	r3, #6
  20d738:	4602      	mov	r2, r0
  20d73a:	701a      	strb	r2, [r3, #0]
	FontVar[idVar].space=space;
  20d73c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20d73e:	b2d8      	uxtb	r0, r3
  20d740:	4971      	ldr	r1, [pc, #452]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d742:	693a      	ldr	r2, [r7, #16]
  20d744:	4613      	mov	r3, r2
  20d746:	011b      	lsls	r3, r3, #4
  20d748:	1a9b      	subs	r3, r3, r2
  20d74a:	009b      	lsls	r3, r3, #2
  20d74c:	440b      	add	r3, r1
  20d74e:	3307      	adds	r3, #7
  20d750:	4602      	mov	r2, r0
  20d752:	701a      	strb	r2, [r3, #0]
	FontVar[idVar].bkColor=bkColor;
  20d754:	496c      	ldr	r1, [pc, #432]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d756:	693a      	ldr	r2, [r7, #16]
  20d758:	4613      	mov	r3, r2
  20d75a:	011b      	lsls	r3, r3, #4
  20d75c:	1a9b      	subs	r3, r3, r2
  20d75e:	009b      	lsls	r3, r3, #2
  20d760:	440b      	add	r3, r1
  20d762:	3308      	adds	r3, #8
  20d764:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
  20d766:	601a      	str	r2, [r3, #0]
	FontVar[idVar].fontColor=fontColor;
  20d768:	4967      	ldr	r1, [pc, #412]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d76a:	693a      	ldr	r2, [r7, #16]
  20d76c:	4613      	mov	r3, r2
  20d76e:	011b      	lsls	r3, r3, #4
  20d770:	1a9b      	subs	r3, r3, r2
  20d772:	009b      	lsls	r3, r3, #2
  20d774:	440b      	add	r3, r1
  20d776:	3310      	adds	r3, #16
  20d778:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20d77a:	601a      	str	r2, [r3, #0]
	FontVar[idVar].bkScreenColor=bkScreenColor;
  20d77c:	4962      	ldr	r1, [pc, #392]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d77e:	693a      	ldr	r2, [r7, #16]
  20d780:	4613      	mov	r3, r2
  20d782:	011b      	lsls	r3, r3, #4
  20d784:	1a9b      	subs	r3, r3, r2
  20d786:	009b      	lsls	r3, r3, #2
  20d788:	440b      	add	r3, r1
  20d78a:	330c      	adds	r3, #12
  20d78c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  20d78e:	601a      	str	r2, [r3, #0]
	FontVar[idVar].coeff=maxVal;
  20d790:	495d      	ldr	r1, [pc, #372]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d792:	693a      	ldr	r2, [r7, #16]
  20d794:	4613      	mov	r3, r2
  20d796:	011b      	lsls	r3, r3, #4
  20d798:	1a9b      	subs	r3, r3, r2
  20d79a:	009b      	lsls	r3, r3, #2
  20d79c:	440b      	add	r3, r1
  20d79e:	3318      	adds	r3, #24
  20d7a0:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20d7a2:	601a      	str	r2, [r3, #0]
	FontVar[idVar].widthType=constWidth;
  20d7a4:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20d7a6:	b2d8      	uxtb	r0, r3
  20d7a8:	4957      	ldr	r1, [pc, #348]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d7aa:	693a      	ldr	r2, [r7, #16]
  20d7ac:	4613      	mov	r3, r2
  20d7ae:	011b      	lsls	r3, r3, #4
  20d7b0:	1a9b      	subs	r3, r3, r2
  20d7b2:	009b      	lsls	r3, r3, #2
  20d7b4:	440b      	add	r3, r1
  20d7b6:	331c      	adds	r3, #28
  20d7b8:	4602      	mov	r2, r0
  20d7ba:	701a      	strb	r2, [r3, #0]
	FontVar[idVar].rotate=rot;
  20d7bc:	68fb      	ldr	r3, [r7, #12]
  20d7be:	b2d8      	uxtb	r0, r3
  20d7c0:	4951      	ldr	r1, [pc, #324]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d7c2:	693a      	ldr	r2, [r7, #16]
  20d7c4:	4613      	mov	r3, r2
  20d7c6:	011b      	lsls	r3, r3, #4
  20d7c8:	1a9b      	subs	r3, r3, r2
  20d7ca:	009b      	lsls	r3, r3, #2
  20d7cc:	440b      	add	r3, r1
  20d7ce:	3314      	adds	r3, #20
  20d7d0:	4602      	mov	r2, r0
  20d7d2:	701a      	strb	r2, [r3, #0]

	temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, pxlTxtLen,fontHeight, fontID,0,0,txt,movableFontsBuffer,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20d7d4:	4b4b      	ldr	r3, [pc, #300]	; (20d904 <LCD_StrChangeColorRotVar+0x298>)
  20d7d6:	681b      	ldr	r3, [r3, #0]
  20d7d8:	461d      	mov	r5, r3
  20d7da:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  20d7dc:	6afc      	ldr	r4, [r7, #44]	; 0x2c
  20d7de:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20d7e0:	b2db      	uxtb	r3, r3
  20d7e2:	4638      	mov	r0, r7
  20d7e4:	6eba      	ldr	r2, [r7, #104]	; 0x68
  20d7e6:	920a      	str	r2, [sp, #40]	; 0x28
  20d7e8:	9309      	str	r3, [sp, #36]	; 0x24
  20d7ea:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20d7ec:	9308      	str	r3, [sp, #32]
  20d7ee:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20d7f0:	9307      	str	r3, [sp, #28]
  20d7f2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20d7f4:	9306      	str	r3, [sp, #24]
  20d7f6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20d7f8:	9305      	str	r3, [sp, #20]
  20d7fa:	4b44      	ldr	r3, [pc, #272]	; (20d90c <LCD_StrChangeColorRotVar+0x2a0>)
  20d7fc:	9304      	str	r3, [sp, #16]
  20d7fe:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20d800:	9303      	str	r3, [sp, #12]
  20d802:	2300      	movs	r3, #0
  20d804:	9302      	str	r3, [sp, #8]
  20d806:	2300      	movs	r3, #0
  20d808:	9301      	str	r3, [sp, #4]
  20d80a:	68bb      	ldr	r3, [r7, #8]
  20d80c:	9300      	str	r3, [sp, #0]
  20d80e:	4623      	mov	r3, r4
  20d810:	460a      	mov	r2, r1
  20d812:	4629      	mov	r1, r5
  20d814:	f7fc ff68 	bl	20a6e8 <LCD_DrawStrChangeColor>
  20d818:	f107 031c 	add.w	r3, r7, #28
  20d81c:	463a      	mov	r2, r7
  20d81e:	6810      	ldr	r0, [r2, #0]
  20d820:	6018      	str	r0, [r3, #0]
  20d822:	8892      	ldrh	r2, [r2, #4]
  20d824:	809a      	strh	r2, [r3, #4]
	LCD_CopyBuff2pLcd(rot,movableFontsBuffer_pos, movableFontsBuffer, pxlTxtLen,fontHeight,0, temp.inPixel, Xpos,Ypos,0);
  20d826:	4b37      	ldr	r3, [pc, #220]	; (20d904 <LCD_StrChangeColorRotVar+0x298>)
  20d828:	681b      	ldr	r3, [r3, #0]
  20d82a:	461e      	mov	r6, r3
  20d82c:	6abd      	ldr	r5, [r7, #40]	; 0x28
  20d82e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20d830:	8bfa      	ldrh	r2, [r7, #30]
  20d832:	6cb9      	ldr	r1, [r7, #72]	; 0x48
  20d834:	b289      	uxth	r1, r1
  20d836:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20d838:	b280      	uxth	r0, r0
  20d83a:	2400      	movs	r4, #0
  20d83c:	9405      	str	r4, [sp, #20]
  20d83e:	9004      	str	r0, [sp, #16]
  20d840:	9103      	str	r1, [sp, #12]
  20d842:	9202      	str	r2, [sp, #8]
  20d844:	2200      	movs	r2, #0
  20d846:	9201      	str	r2, [sp, #4]
  20d848:	9300      	str	r3, [sp, #0]
  20d84a:	462b      	mov	r3, r5
  20d84c:	4a2f      	ldr	r2, [pc, #188]	; (20d90c <LCD_StrChangeColorRotVar+0x2a0>)
  20d84e:	4631      	mov	r1, r6
  20d850:	68f8      	ldr	r0, [r7, #12]
  20d852:	f7fa f979 	bl	207b48 <LCD_CopyBuff2pLcd>

	if(rot>Rotate_0)
  20d856:	68fb      	ldr	r3, [r7, #12]
  20d858:	2b00      	cmp	r3, #0
  20d85a:	dd09      	ble.n	20d870 <LCD_StrChangeColorRotVar+0x204>
		SwapUint16(&temp.inPixel,&temp.height);
  20d85c:	f107 031c 	add.w	r3, r7, #28
  20d860:	1d1a      	adds	r2, r3, #4
  20d862:	f107 031c 	add.w	r3, r7, #28
  20d866:	3302      	adds	r3, #2
  20d868:	4611      	mov	r1, r2
  20d86a:	4618      	mov	r0, r3
  20d86c:	f7f4 f960 	bl	201b30 <SwapUint16>

	FontVar[idVar].xPos_prev = FontVar[idVar].xPos;
  20d870:	4925      	ldr	r1, [pc, #148]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d872:	693a      	ldr	r2, [r7, #16]
  20d874:	4613      	mov	r3, r2
  20d876:	011b      	lsls	r3, r3, #4
  20d878:	1a9b      	subs	r3, r3, r2
  20d87a:	009b      	lsls	r3, r3, #2
  20d87c:	440b      	add	r3, r1
  20d87e:	3302      	adds	r3, #2
  20d880:	8818      	ldrh	r0, [r3, #0]
  20d882:	4921      	ldr	r1, [pc, #132]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d884:	693a      	ldr	r2, [r7, #16]
  20d886:	4613      	mov	r3, r2
  20d888:	011b      	lsls	r3, r3, #4
  20d88a:	1a9b      	subs	r3, r3, r2
  20d88c:	009b      	lsls	r3, r3, #2
  20d88e:	440b      	add	r3, r1
  20d890:	331e      	adds	r3, #30
  20d892:	4602      	mov	r2, r0
  20d894:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].yPos_prev = FontVar[idVar].yPos;
  20d896:	491c      	ldr	r1, [pc, #112]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d898:	693a      	ldr	r2, [r7, #16]
  20d89a:	4613      	mov	r3, r2
  20d89c:	011b      	lsls	r3, r3, #4
  20d89e:	1a9b      	subs	r3, r3, r2
  20d8a0:	009b      	lsls	r3, r3, #2
  20d8a2:	440b      	add	r3, r1
  20d8a4:	3304      	adds	r3, #4
  20d8a6:	8818      	ldrh	r0, [r3, #0]
  20d8a8:	4917      	ldr	r1, [pc, #92]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d8aa:	693a      	ldr	r2, [r7, #16]
  20d8ac:	4613      	mov	r3, r2
  20d8ae:	011b      	lsls	r3, r3, #4
  20d8b0:	1a9b      	subs	r3, r3, r2
  20d8b2:	009b      	lsls	r3, r3, #2
  20d8b4:	440b      	add	r3, r1
  20d8b6:	3320      	adds	r3, #32
  20d8b8:	4602      	mov	r2, r0
  20d8ba:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].widthPxl_prev = temp.inPixel;
  20d8bc:	8bf8      	ldrh	r0, [r7, #30]
  20d8be:	4912      	ldr	r1, [pc, #72]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d8c0:	693a      	ldr	r2, [r7, #16]
  20d8c2:	4613      	mov	r3, r2
  20d8c4:	011b      	lsls	r3, r3, #4
  20d8c6:	1a9b      	subs	r3, r3, r2
  20d8c8:	009b      	lsls	r3, r3, #2
  20d8ca:	440b      	add	r3, r1
  20d8cc:	3322      	adds	r3, #34	; 0x22
  20d8ce:	4602      	mov	r2, r0
  20d8d0:	801a      	strh	r2, [r3, #0]
	FontVar[idVar].heightPxl_prev = temp.height;
  20d8d2:	8c38      	ldrh	r0, [r7, #32]
  20d8d4:	490c      	ldr	r1, [pc, #48]	; (20d908 <LCD_StrChangeColorRotVar+0x29c>)
  20d8d6:	693a      	ldr	r2, [r7, #16]
  20d8d8:	4613      	mov	r3, r2
  20d8da:	011b      	lsls	r3, r3, #4
  20d8dc:	1a9b      	subs	r3, r3, r2
  20d8de:	009b      	lsls	r3, r3, #2
  20d8e0:	440b      	add	r3, r1
  20d8e2:	3324      	adds	r3, #36	; 0x24
  20d8e4:	4602      	mov	r2, r0
  20d8e6:	801a      	strh	r2, [r3, #0]

	return temp;
  20d8e8:	697b      	ldr	r3, [r7, #20]
  20d8ea:	461a      	mov	r2, r3
  20d8ec:	f107 031c 	add.w	r3, r7, #28
  20d8f0:	6818      	ldr	r0, [r3, #0]
  20d8f2:	6010      	str	r0, [r2, #0]
  20d8f4:	889b      	ldrh	r3, [r3, #4]
  20d8f6:	8093      	strh	r3, [r2, #4]
}
  20d8f8:	6978      	ldr	r0, [r7, #20]
  20d8fa:	3734      	adds	r7, #52	; 0x34
  20d8fc:	46bd      	mov	sp, r7
  20d8fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20d900:	20003474 	.word	0x20003474
  20d904:	2000347c 	.word	0x2000347c
  20d908:	2000f818 	.word	0x2000f818
  20d90c:	c067f800 	.word	0xc067f800

0020d910 <LCD_StrRotVarIndirect>:
StructTxtPxlLen LCD_StrRotVarIndirect(int idVar, char *txt){
  20d910:	b5f0      	push	{r4, r5, r6, r7, lr}
  20d912:	b09b      	sub	sp, #108	; 0x6c
  20d914:	af0a      	add	r7, sp, #40	; 0x28
  20d916:	6278      	str	r0, [r7, #36]	; 0x24
  20d918:	6239      	str	r1, [r7, #32]
  20d91a:	61fa      	str	r2, [r7, #28]
	StructTxtPxlLen temp;
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(FontVar[idVar].id,txt,FontVar[idVar].space,FontVar[idVar].widthType);
  20d91c:	49a6      	ldr	r1, [pc, #664]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d91e:	6a3a      	ldr	r2, [r7, #32]
  20d920:	4613      	mov	r3, r2
  20d922:	011b      	lsls	r3, r3, #4
  20d924:	1a9b      	subs	r3, r3, r2
  20d926:	009b      	lsls	r3, r3, #2
  20d928:	440b      	add	r3, r1
  20d92a:	881b      	ldrh	r3, [r3, #0]
  20d92c:	4618      	mov	r0, r3
  20d92e:	49a2      	ldr	r1, [pc, #648]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d930:	6a3a      	ldr	r2, [r7, #32]
  20d932:	4613      	mov	r3, r2
  20d934:	011b      	lsls	r3, r3, #4
  20d936:	1a9b      	subs	r3, r3, r2
  20d938:	009b      	lsls	r3, r3, #2
  20d93a:	440b      	add	r3, r1
  20d93c:	3307      	adds	r3, #7
  20d93e:	781b      	ldrb	r3, [r3, #0]
  20d940:	461c      	mov	r4, r3
  20d942:	499d      	ldr	r1, [pc, #628]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d944:	6a3a      	ldr	r2, [r7, #32]
  20d946:	4613      	mov	r3, r2
  20d948:	011b      	lsls	r3, r3, #4
  20d94a:	1a9b      	subs	r3, r3, r2
  20d94c:	009b      	lsls	r3, r3, #2
  20d94e:	440b      	add	r3, r1
  20d950:	331c      	adds	r3, #28
  20d952:	781b      	ldrb	r3, [r3, #0]
  20d954:	4622      	mov	r2, r4
  20d956:	69f9      	ldr	r1, [r7, #28]
  20d958:	f004 fbb8 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20d95c:	63f8      	str	r0, [r7, #60]	; 0x3c
	if(pxlTxtLen<0)
  20d95e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20d960:	2b00      	cmp	r3, #0
  20d962:	da06      	bge.n	20d972 <LCD_StrRotVarIndirect+0x62>
		return StructTxtPxlLen_ZeroValue;
  20d964:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20d966:	4a95      	ldr	r2, [pc, #596]	; (20dbbc <LCD_StrRotVarIndirect+0x2ac>)
  20d968:	6810      	ldr	r0, [r2, #0]
  20d96a:	6018      	str	r0, [r3, #0]
  20d96c:	8892      	ldrh	r2, [r2, #4]
  20d96e:	809a      	strh	r2, [r3, #4]
  20d970:	e11d      	b.n	20dbae <LCD_StrRotVarIndirect+0x29e>
	int fontHeight= FontVar[idVar].heightType==fullHight?LCD_GetFontHeight(FontVar[idVar].id):LCD_GetFontHalfHeight(FontVar[idVar].id);
  20d972:	4991      	ldr	r1, [pc, #580]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d974:	6a3a      	ldr	r2, [r7, #32]
  20d976:	4613      	mov	r3, r2
  20d978:	011b      	lsls	r3, r3, #4
  20d97a:	1a9b      	subs	r3, r3, r2
  20d97c:	009b      	lsls	r3, r3, #2
  20d97e:	440b      	add	r3, r1
  20d980:	3306      	adds	r3, #6
  20d982:	f993 3000 	ldrsb.w	r3, [r3]
  20d986:	f113 0f03 	cmn.w	r3, #3
  20d98a:	d10c      	bne.n	20d9a6 <LCD_StrRotVarIndirect+0x96>
  20d98c:	498a      	ldr	r1, [pc, #552]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d98e:	6a3a      	ldr	r2, [r7, #32]
  20d990:	4613      	mov	r3, r2
  20d992:	011b      	lsls	r3, r3, #4
  20d994:	1a9b      	subs	r3, r3, r2
  20d996:	009b      	lsls	r3, r3, #2
  20d998:	440b      	add	r3, r1
  20d99a:	881b      	ldrh	r3, [r3, #0]
  20d99c:	4618      	mov	r0, r3
  20d99e:	f004 fd29 	bl	2123f4 <LCD_GetFontHeight>
  20d9a2:	4603      	mov	r3, r0
  20d9a4:	e00b      	b.n	20d9be <LCD_StrRotVarIndirect+0xae>
  20d9a6:	4984      	ldr	r1, [pc, #528]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d9a8:	6a3a      	ldr	r2, [r7, #32]
  20d9aa:	4613      	mov	r3, r2
  20d9ac:	011b      	lsls	r3, r3, #4
  20d9ae:	1a9b      	subs	r3, r3, r2
  20d9b0:	009b      	lsls	r3, r3, #2
  20d9b2:	440b      	add	r3, r1
  20d9b4:	881b      	ldrh	r3, [r3, #0]
  20d9b6:	4618      	mov	r0, r3
  20d9b8:	f004 fd58 	bl	21246c <LCD_GetFontHalfHeight>
  20d9bc:	4603      	mov	r3, r0
  20d9be:	63bb      	str	r3, [r7, #56]	; 0x38

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20d9c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20d9c2:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20d9c4:	fb02 f203 	mul.w	r2, r2, r3
  20d9c8:	4b7d      	ldr	r3, [pc, #500]	; (20dbc0 <LCD_StrRotVarIndirect+0x2b0>)
  20d9ca:	681b      	ldr	r3, [r3, #0]
  20d9cc:	4413      	add	r3, r2
  20d9ce:	637b      	str	r3, [r7, #52]	; 0x34
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20d9d0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20d9d2:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20d9d6:	db06      	blt.n	20d9e6 <LCD_StrRotVarIndirect+0xd6>
		return StructTxtPxlLen_ZeroValue;
  20d9d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20d9da:	4a78      	ldr	r2, [pc, #480]	; (20dbbc <LCD_StrRotVarIndirect+0x2ac>)
  20d9dc:	6810      	ldr	r0, [r2, #0]
  20d9de:	6018      	str	r0, [r3, #0]
  20d9e0:	8892      	ldrh	r2, [r2, #4]
  20d9e2:	809a      	strh	r2, [r3, #4]
  20d9e4:	e0e3      	b.n	20dbae <LCD_StrRotVarIndirect+0x29e>

	temp=LCD_DrawStr(movableFontsBuffer_pos, pxlTxtLen,fontHeight, FontVar[idVar].id,0,0,txt,movableFontsBuffer,FontVar[idVar].heightType,FontVar[idVar].space,FontVar[idVar].bkColor,FontVar[idVar].coeff,FontVar[idVar].widthType);
  20d9e6:	4b76      	ldr	r3, [pc, #472]	; (20dbc0 <LCD_StrRotVarIndirect+0x2b0>)
  20d9e8:	681b      	ldr	r3, [r3, #0]
  20d9ea:	469e      	mov	lr, r3
  20d9ec:	6bfd      	ldr	r5, [r7, #60]	; 0x3c
  20d9ee:	6bbe      	ldr	r6, [r7, #56]	; 0x38
  20d9f0:	4971      	ldr	r1, [pc, #452]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20d9f2:	6a3a      	ldr	r2, [r7, #32]
  20d9f4:	4613      	mov	r3, r2
  20d9f6:	011b      	lsls	r3, r3, #4
  20d9f8:	1a9b      	subs	r3, r3, r2
  20d9fa:	009b      	lsls	r3, r3, #2
  20d9fc:	440b      	add	r3, r1
  20d9fe:	881b      	ldrh	r3, [r3, #0]
  20da00:	60fb      	str	r3, [r7, #12]
  20da02:	496d      	ldr	r1, [pc, #436]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20da04:	6a3a      	ldr	r2, [r7, #32]
  20da06:	4613      	mov	r3, r2
  20da08:	011b      	lsls	r3, r3, #4
  20da0a:	1a9b      	subs	r3, r3, r2
  20da0c:	009b      	lsls	r3, r3, #2
  20da0e:	440b      	add	r3, r1
  20da10:	3306      	adds	r3, #6
  20da12:	f993 3000 	ldrsb.w	r3, [r3]
  20da16:	60bb      	str	r3, [r7, #8]
  20da18:	4967      	ldr	r1, [pc, #412]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20da1a:	6a3a      	ldr	r2, [r7, #32]
  20da1c:	4613      	mov	r3, r2
  20da1e:	011b      	lsls	r3, r3, #4
  20da20:	1a9b      	subs	r3, r3, r2
  20da22:	009b      	lsls	r3, r3, #2
  20da24:	440b      	add	r3, r1
  20da26:	3307      	adds	r3, #7
  20da28:	781b      	ldrb	r3, [r3, #0]
  20da2a:	607b      	str	r3, [r7, #4]
  20da2c:	4962      	ldr	r1, [pc, #392]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20da2e:	6a3a      	ldr	r2, [r7, #32]
  20da30:	4613      	mov	r3, r2
  20da32:	011b      	lsls	r3, r3, #4
  20da34:	1a9b      	subs	r3, r3, r2
  20da36:	009b      	lsls	r3, r3, #2
  20da38:	440b      	add	r3, r1
  20da3a:	3308      	adds	r3, #8
  20da3c:	6819      	ldr	r1, [r3, #0]
  20da3e:	485e      	ldr	r0, [pc, #376]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20da40:	6a3a      	ldr	r2, [r7, #32]
  20da42:	4613      	mov	r3, r2
  20da44:	011b      	lsls	r3, r3, #4
  20da46:	1a9b      	subs	r3, r3, r2
  20da48:	009b      	lsls	r3, r3, #2
  20da4a:	4403      	add	r3, r0
  20da4c:	3318      	adds	r3, #24
  20da4e:	6818      	ldr	r0, [r3, #0]
  20da50:	4c59      	ldr	r4, [pc, #356]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20da52:	6a3a      	ldr	r2, [r7, #32]
  20da54:	4613      	mov	r3, r2
  20da56:	011b      	lsls	r3, r3, #4
  20da58:	1a9b      	subs	r3, r3, r2
  20da5a:	009b      	lsls	r3, r3, #2
  20da5c:	4423      	add	r3, r4
  20da5e:	331c      	adds	r3, #28
  20da60:	781b      	ldrb	r3, [r3, #0]
  20da62:	f107 0410 	add.w	r4, r7, #16
  20da66:	9309      	str	r3, [sp, #36]	; 0x24
  20da68:	9008      	str	r0, [sp, #32]
  20da6a:	9107      	str	r1, [sp, #28]
  20da6c:	687a      	ldr	r2, [r7, #4]
  20da6e:	9206      	str	r2, [sp, #24]
  20da70:	68ba      	ldr	r2, [r7, #8]
  20da72:	9205      	str	r2, [sp, #20]
  20da74:	4b53      	ldr	r3, [pc, #332]	; (20dbc4 <LCD_StrRotVarIndirect+0x2b4>)
  20da76:	9304      	str	r3, [sp, #16]
  20da78:	69fb      	ldr	r3, [r7, #28]
  20da7a:	9303      	str	r3, [sp, #12]
  20da7c:	2300      	movs	r3, #0
  20da7e:	9302      	str	r3, [sp, #8]
  20da80:	2300      	movs	r3, #0
  20da82:	9301      	str	r3, [sp, #4]
  20da84:	68fb      	ldr	r3, [r7, #12]
  20da86:	9300      	str	r3, [sp, #0]
  20da88:	4633      	mov	r3, r6
  20da8a:	462a      	mov	r2, r5
  20da8c:	4671      	mov	r1, lr
  20da8e:	4620      	mov	r0, r4
  20da90:	f7fc fdc4 	bl	20a61c <LCD_DrawStr>
  20da94:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20da98:	f107 0210 	add.w	r2, r7, #16
  20da9c:	6810      	ldr	r0, [r2, #0]
  20da9e:	6018      	str	r0, [r3, #0]
  20daa0:	8892      	ldrh	r2, [r2, #4]
  20daa2:	809a      	strh	r2, [r3, #4]
	LCD_CopyBuff2pLcdIndirect(FontVar[idVar].rotate,movableFontsBuffer_pos, movableFontsBuffer, pxlTxtLen,fontHeight,0, temp.inPixel,0);
  20daa4:	4944      	ldr	r1, [pc, #272]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20daa6:	6a3a      	ldr	r2, [r7, #32]
  20daa8:	4613      	mov	r3, r2
  20daaa:	011b      	lsls	r3, r3, #4
  20daac:	1a9b      	subs	r3, r3, r2
  20daae:	009b      	lsls	r3, r3, #2
  20dab0:	440b      	add	r3, r1
  20dab2:	3314      	adds	r3, #20
  20dab4:	781b      	ldrb	r3, [r3, #0]
  20dab6:	461c      	mov	r4, r3
  20dab8:	4b41      	ldr	r3, [pc, #260]	; (20dbc0 <LCD_StrRotVarIndirect+0x2b0>)
  20daba:	681b      	ldr	r3, [r3, #0]
  20dabc:	461d      	mov	r5, r3
  20dabe:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
  20dac0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20dac2:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
  20dac4:	2100      	movs	r1, #0
  20dac6:	9103      	str	r1, [sp, #12]
  20dac8:	9202      	str	r2, [sp, #8]
  20daca:	2200      	movs	r2, #0
  20dacc:	9201      	str	r2, [sp, #4]
  20dace:	9300      	str	r3, [sp, #0]
  20dad0:	4603      	mov	r3, r0
  20dad2:	4a3c      	ldr	r2, [pc, #240]	; (20dbc4 <LCD_StrRotVarIndirect+0x2b4>)
  20dad4:	4629      	mov	r1, r5
  20dad6:	4620      	mov	r0, r4
  20dad8:	f7fa f908 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
	switch(FontVar[idVar].rotate)
  20dadc:	4936      	ldr	r1, [pc, #216]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20dade:	6a3a      	ldr	r2, [r7, #32]
  20dae0:	4613      	mov	r3, r2
  20dae2:	011b      	lsls	r3, r3, #4
  20dae4:	1a9b      	subs	r3, r3, r2
  20dae6:	009b      	lsls	r3, r3, #2
  20dae8:	440b      	add	r3, r1
  20daea:	3314      	adds	r3, #20
  20daec:	781b      	ldrb	r3, [r3, #0]
  20daee:	2b00      	cmp	r3, #0
  20daf0:	d11c      	bne.n	20db2c <LCD_StrRotVarIndirect+0x21c>
	{	case Rotate_0:
			LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos,(uint32_t)FontVar[idVar].yPos, pxlTxtLen,fontHeight, pLcd);
  20daf2:	4931      	ldr	r1, [pc, #196]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20daf4:	6a3a      	ldr	r2, [r7, #32]
  20daf6:	4613      	mov	r3, r2
  20daf8:	011b      	lsls	r3, r3, #4
  20dafa:	1a9b      	subs	r3, r3, r2
  20dafc:	009b      	lsls	r3, r3, #2
  20dafe:	440b      	add	r3, r1
  20db00:	3302      	adds	r3, #2
  20db02:	881b      	ldrh	r3, [r3, #0]
  20db04:	4618      	mov	r0, r3
  20db06:	492c      	ldr	r1, [pc, #176]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20db08:	6a3a      	ldr	r2, [r7, #32]
  20db0a:	4613      	mov	r3, r2
  20db0c:	011b      	lsls	r3, r3, #4
  20db0e:	1a9b      	subs	r3, r3, r2
  20db10:	009b      	lsls	r3, r3, #2
  20db12:	440b      	add	r3, r1
  20db14:	3304      	adds	r3, #4
  20db16:	881b      	ldrh	r3, [r3, #0]
  20db18:	461c      	mov	r4, r3
  20db1a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20db1c:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  20db1e:	4b2a      	ldr	r3, [pc, #168]	; (20dbc8 <LCD_StrRotVarIndirect+0x2b8>)
  20db20:	9300      	str	r3, [sp, #0]
  20db22:	460b      	mov	r3, r1
  20db24:	4621      	mov	r1, r4
  20db26:	f7f9 ffb5 	bl	207a94 <LCD_DisplayBuff>
			break;
  20db2a:	e01c      	b.n	20db66 <LCD_StrRotVarIndirect+0x256>
		case Rotate_90:
		case Rotate_180:
		default:
			LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos,(uint32_t)FontVar[idVar].yPos, fontHeight,pxlTxtLen, pLcd);
  20db2c:	4922      	ldr	r1, [pc, #136]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20db2e:	6a3a      	ldr	r2, [r7, #32]
  20db30:	4613      	mov	r3, r2
  20db32:	011b      	lsls	r3, r3, #4
  20db34:	1a9b      	subs	r3, r3, r2
  20db36:	009b      	lsls	r3, r3, #2
  20db38:	440b      	add	r3, r1
  20db3a:	3302      	adds	r3, #2
  20db3c:	881b      	ldrh	r3, [r3, #0]
  20db3e:	4618      	mov	r0, r3
  20db40:	491d      	ldr	r1, [pc, #116]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20db42:	6a3a      	ldr	r2, [r7, #32]
  20db44:	4613      	mov	r3, r2
  20db46:	011b      	lsls	r3, r3, #4
  20db48:	1a9b      	subs	r3, r3, r2
  20db4a:	009b      	lsls	r3, r3, #2
  20db4c:	440b      	add	r3, r1
  20db4e:	3304      	adds	r3, #4
  20db50:	881b      	ldrh	r3, [r3, #0]
  20db52:	461c      	mov	r4, r3
  20db54:	6bba      	ldr	r2, [r7, #56]	; 0x38
  20db56:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  20db58:	4b1b      	ldr	r3, [pc, #108]	; (20dbc8 <LCD_StrRotVarIndirect+0x2b8>)
  20db5a:	9300      	str	r3, [sp, #0]
  20db5c:	460b      	mov	r3, r1
  20db5e:	4621      	mov	r1, r4
  20db60:	f7f9 ff98 	bl	207a94 <LCD_DisplayBuff>
			break;
  20db64:	bf00      	nop
	}
	if(FontVar[idVar].rotate>Rotate_0)
  20db66:	4914      	ldr	r1, [pc, #80]	; (20dbb8 <LCD_StrRotVarIndirect+0x2a8>)
  20db68:	6a3a      	ldr	r2, [r7, #32]
  20db6a:	4613      	mov	r3, r2
  20db6c:	011b      	lsls	r3, r3, #4
  20db6e:	1a9b      	subs	r3, r3, r2
  20db70:	009b      	lsls	r3, r3, #2
  20db72:	440b      	add	r3, r1
  20db74:	3314      	adds	r3, #20
  20db76:	781b      	ldrb	r3, [r3, #0]
  20db78:	2b00      	cmp	r3, #0
  20db7a:	d009      	beq.n	20db90 <LCD_StrRotVarIndirect+0x280>
		SwapUint16(&temp.inPixel,&temp.height);
  20db7c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20db80:	1d1a      	adds	r2, r3, #4
  20db82:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20db86:	3302      	adds	r3, #2
  20db88:	4611      	mov	r1, r2
  20db8a:	4618      	mov	r0, r3
  20db8c:	f7f3 ffd0 	bl	201b30 <SwapUint16>
	LCD_DimensionBkCorrect(idVar,temp,pLcd);
  20db90:	4b0d      	ldr	r3, [pc, #52]	; (20dbc8 <LCD_StrRotVarIndirect+0x2b8>)
  20db92:	f107 022c 	add.w	r2, r7, #44	; 0x2c
  20db96:	ca06      	ldmia	r2, {r1, r2}
  20db98:	6a38      	ldr	r0, [r7, #32]
  20db9a:	f7fe fe2f 	bl	20c7fc <LCD_DimensionBkCorrect>
	return temp;
  20db9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20dba0:	461a      	mov	r2, r3
  20dba2:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20dba6:	6818      	ldr	r0, [r3, #0]
  20dba8:	6010      	str	r0, [r2, #0]
  20dbaa:	889b      	ldrh	r3, [r3, #4]
  20dbac:	8093      	strh	r3, [r2, #4]
}
  20dbae:	6a78      	ldr	r0, [r7, #36]	; 0x24
  20dbb0:	3744      	adds	r7, #68	; 0x44
  20dbb2:	46bd      	mov	sp, r7
  20dbb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20dbb6:	bf00      	nop
  20dbb8:	2000f818 	.word	0x2000f818
  20dbbc:	20003474 	.word	0x20003474
  20dbc0:	2000347c 	.word	0x2000347c
  20dbc4:	c067f800 	.word	0xc067f800
  20dbc8:	c0000000 	.word	0xc0000000

0020dbcc <LCD_StrChangeColorRotVarIndirect>:
StructTxtPxlLen LCD_StrChangeColorRotVarIndirect(int idVar, char *txt){
  20dbcc:	b5f0      	push	{r4, r5, r6, r7, lr}
  20dbce:	b09d      	sub	sp, #116	; 0x74
  20dbd0:	af0c      	add	r7, sp, #48	; 0x30
  20dbd2:	6278      	str	r0, [r7, #36]	; 0x24
  20dbd4:	6239      	str	r1, [r7, #32]
  20dbd6:	61fa      	str	r2, [r7, #28]
	StructTxtPxlLen temp;
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(FontVar[idVar].id,txt,FontVar[idVar].space,FontVar[idVar].widthType);
  20dbd8:	49ac      	ldr	r1, [pc, #688]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dbda:	6a3a      	ldr	r2, [r7, #32]
  20dbdc:	4613      	mov	r3, r2
  20dbde:	011b      	lsls	r3, r3, #4
  20dbe0:	1a9b      	subs	r3, r3, r2
  20dbe2:	009b      	lsls	r3, r3, #2
  20dbe4:	440b      	add	r3, r1
  20dbe6:	881b      	ldrh	r3, [r3, #0]
  20dbe8:	4618      	mov	r0, r3
  20dbea:	49a8      	ldr	r1, [pc, #672]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dbec:	6a3a      	ldr	r2, [r7, #32]
  20dbee:	4613      	mov	r3, r2
  20dbf0:	011b      	lsls	r3, r3, #4
  20dbf2:	1a9b      	subs	r3, r3, r2
  20dbf4:	009b      	lsls	r3, r3, #2
  20dbf6:	440b      	add	r3, r1
  20dbf8:	3307      	adds	r3, #7
  20dbfa:	781b      	ldrb	r3, [r3, #0]
  20dbfc:	461c      	mov	r4, r3
  20dbfe:	49a3      	ldr	r1, [pc, #652]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dc00:	6a3a      	ldr	r2, [r7, #32]
  20dc02:	4613      	mov	r3, r2
  20dc04:	011b      	lsls	r3, r3, #4
  20dc06:	1a9b      	subs	r3, r3, r2
  20dc08:	009b      	lsls	r3, r3, #2
  20dc0a:	440b      	add	r3, r1
  20dc0c:	331c      	adds	r3, #28
  20dc0e:	781b      	ldrb	r3, [r3, #0]
  20dc10:	4622      	mov	r2, r4
  20dc12:	69f9      	ldr	r1, [r7, #28]
  20dc14:	f004 fa5a 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20dc18:	63f8      	str	r0, [r7, #60]	; 0x3c
	if(pxlTxtLen<0)
  20dc1a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  20dc1c:	2b00      	cmp	r3, #0
  20dc1e:	da06      	bge.n	20dc2e <LCD_StrChangeColorRotVarIndirect+0x62>
		return StructTxtPxlLen_ZeroValue;
  20dc20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20dc22:	4a9b      	ldr	r2, [pc, #620]	; (20de90 <LCD_StrChangeColorRotVarIndirect+0x2c4>)
  20dc24:	6810      	ldr	r0, [r2, #0]
  20dc26:	6018      	str	r0, [r3, #0]
  20dc28:	8892      	ldrh	r2, [r2, #4]
  20dc2a:	809a      	strh	r2, [r3, #4]
  20dc2c:	e129      	b.n	20de82 <LCD_StrChangeColorRotVarIndirect+0x2b6>
	int fontHeight= FontVar[idVar].heightType==fullHight?LCD_GetFontHeight(FontVar[idVar].id):LCD_GetFontHalfHeight(FontVar[idVar].id);
  20dc2e:	4997      	ldr	r1, [pc, #604]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dc30:	6a3a      	ldr	r2, [r7, #32]
  20dc32:	4613      	mov	r3, r2
  20dc34:	011b      	lsls	r3, r3, #4
  20dc36:	1a9b      	subs	r3, r3, r2
  20dc38:	009b      	lsls	r3, r3, #2
  20dc3a:	440b      	add	r3, r1
  20dc3c:	3306      	adds	r3, #6
  20dc3e:	f993 3000 	ldrsb.w	r3, [r3]
  20dc42:	f113 0f03 	cmn.w	r3, #3
  20dc46:	d10c      	bne.n	20dc62 <LCD_StrChangeColorRotVarIndirect+0x96>
  20dc48:	4990      	ldr	r1, [pc, #576]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dc4a:	6a3a      	ldr	r2, [r7, #32]
  20dc4c:	4613      	mov	r3, r2
  20dc4e:	011b      	lsls	r3, r3, #4
  20dc50:	1a9b      	subs	r3, r3, r2
  20dc52:	009b      	lsls	r3, r3, #2
  20dc54:	440b      	add	r3, r1
  20dc56:	881b      	ldrh	r3, [r3, #0]
  20dc58:	4618      	mov	r0, r3
  20dc5a:	f004 fbcb 	bl	2123f4 <LCD_GetFontHeight>
  20dc5e:	4603      	mov	r3, r0
  20dc60:	e00b      	b.n	20dc7a <LCD_StrChangeColorRotVarIndirect+0xae>
  20dc62:	498a      	ldr	r1, [pc, #552]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dc64:	6a3a      	ldr	r2, [r7, #32]
  20dc66:	4613      	mov	r3, r2
  20dc68:	011b      	lsls	r3, r3, #4
  20dc6a:	1a9b      	subs	r3, r3, r2
  20dc6c:	009b      	lsls	r3, r3, #2
  20dc6e:	440b      	add	r3, r1
  20dc70:	881b      	ldrh	r3, [r3, #0]
  20dc72:	4618      	mov	r0, r3
  20dc74:	f004 fbfa 	bl	21246c <LCD_GetFontHalfHeight>
  20dc78:	4603      	mov	r3, r0
  20dc7a:	63bb      	str	r3, [r7, #56]	; 0x38

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20dc7c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20dc7e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20dc80:	fb02 f203 	mul.w	r2, r2, r3
  20dc84:	4b83      	ldr	r3, [pc, #524]	; (20de94 <LCD_StrChangeColorRotVarIndirect+0x2c8>)
  20dc86:	681b      	ldr	r3, [r3, #0]
  20dc88:	4413      	add	r3, r2
  20dc8a:	637b      	str	r3, [r7, #52]	; 0x34
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20dc8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20dc8e:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20dc92:	db06      	blt.n	20dca2 <LCD_StrChangeColorRotVarIndirect+0xd6>
		return StructTxtPxlLen_ZeroValue;
  20dc94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20dc96:	4a7e      	ldr	r2, [pc, #504]	; (20de90 <LCD_StrChangeColorRotVarIndirect+0x2c4>)
  20dc98:	6810      	ldr	r0, [r2, #0]
  20dc9a:	6018      	str	r0, [r3, #0]
  20dc9c:	8892      	ldrh	r2, [r2, #4]
  20dc9e:	809a      	strh	r2, [r3, #4]
  20dca0:	e0ef      	b.n	20de82 <LCD_StrChangeColorRotVarIndirect+0x2b6>

	temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, pxlTxtLen,fontHeight, FontVar[idVar].id,0,0,txt,movableFontsBuffer,FontVar[idVar].heightType,FontVar[idVar].space,FontVar[idVar].bkColor,FontVar[idVar].fontColor,FontVar[idVar].coeff,FontVar[idVar].widthType);
  20dca2:	4b7c      	ldr	r3, [pc, #496]	; (20de94 <LCD_StrChangeColorRotVarIndirect+0x2c8>)
  20dca4:	681b      	ldr	r3, [r3, #0]
  20dca6:	469e      	mov	lr, r3
  20dca8:	6bfe      	ldr	r6, [r7, #60]	; 0x3c
  20dcaa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20dcac:	60fb      	str	r3, [r7, #12]
  20dcae:	4977      	ldr	r1, [pc, #476]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dcb0:	6a3a      	ldr	r2, [r7, #32]
  20dcb2:	4613      	mov	r3, r2
  20dcb4:	011b      	lsls	r3, r3, #4
  20dcb6:	1a9b      	subs	r3, r3, r2
  20dcb8:	009b      	lsls	r3, r3, #2
  20dcba:	440b      	add	r3, r1
  20dcbc:	881b      	ldrh	r3, [r3, #0]
  20dcbe:	60bb      	str	r3, [r7, #8]
  20dcc0:	4972      	ldr	r1, [pc, #456]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dcc2:	6a3a      	ldr	r2, [r7, #32]
  20dcc4:	4613      	mov	r3, r2
  20dcc6:	011b      	lsls	r3, r3, #4
  20dcc8:	1a9b      	subs	r3, r3, r2
  20dcca:	009b      	lsls	r3, r3, #2
  20dccc:	440b      	add	r3, r1
  20dcce:	3306      	adds	r3, #6
  20dcd0:	f993 3000 	ldrsb.w	r3, [r3]
  20dcd4:	607b      	str	r3, [r7, #4]
  20dcd6:	496d      	ldr	r1, [pc, #436]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dcd8:	6a3a      	ldr	r2, [r7, #32]
  20dcda:	4613      	mov	r3, r2
  20dcdc:	011b      	lsls	r3, r3, #4
  20dcde:	1a9b      	subs	r3, r3, r2
  20dce0:	009b      	lsls	r3, r3, #2
  20dce2:	440b      	add	r3, r1
  20dce4:	3307      	adds	r3, #7
  20dce6:	781b      	ldrb	r3, [r3, #0]
  20dce8:	603b      	str	r3, [r7, #0]
  20dcea:	4968      	ldr	r1, [pc, #416]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dcec:	6a3a      	ldr	r2, [r7, #32]
  20dcee:	4613      	mov	r3, r2
  20dcf0:	011b      	lsls	r3, r3, #4
  20dcf2:	1a9b      	subs	r3, r3, r2
  20dcf4:	009b      	lsls	r3, r3, #2
  20dcf6:	440b      	add	r3, r1
  20dcf8:	3308      	adds	r3, #8
  20dcfa:	6819      	ldr	r1, [r3, #0]
  20dcfc:	4863      	ldr	r0, [pc, #396]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dcfe:	6a3a      	ldr	r2, [r7, #32]
  20dd00:	4613      	mov	r3, r2
  20dd02:	011b      	lsls	r3, r3, #4
  20dd04:	1a9b      	subs	r3, r3, r2
  20dd06:	009b      	lsls	r3, r3, #2
  20dd08:	4403      	add	r3, r0
  20dd0a:	3310      	adds	r3, #16
  20dd0c:	6818      	ldr	r0, [r3, #0]
  20dd0e:	4c5f      	ldr	r4, [pc, #380]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dd10:	6a3a      	ldr	r2, [r7, #32]
  20dd12:	4613      	mov	r3, r2
  20dd14:	011b      	lsls	r3, r3, #4
  20dd16:	1a9b      	subs	r3, r3, r2
  20dd18:	009b      	lsls	r3, r3, #2
  20dd1a:	4423      	add	r3, r4
  20dd1c:	3318      	adds	r3, #24
  20dd1e:	681b      	ldr	r3, [r3, #0]
  20dd20:	b2dc      	uxtb	r4, r3
  20dd22:	4d5a      	ldr	r5, [pc, #360]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dd24:	6a3a      	ldr	r2, [r7, #32]
  20dd26:	4613      	mov	r3, r2
  20dd28:	011b      	lsls	r3, r3, #4
  20dd2a:	1a9b      	subs	r3, r3, r2
  20dd2c:	009b      	lsls	r3, r3, #2
  20dd2e:	442b      	add	r3, r5
  20dd30:	331c      	adds	r3, #28
  20dd32:	781b      	ldrb	r3, [r3, #0]
  20dd34:	f107 0510 	add.w	r5, r7, #16
  20dd38:	930a      	str	r3, [sp, #40]	; 0x28
  20dd3a:	9409      	str	r4, [sp, #36]	; 0x24
  20dd3c:	9008      	str	r0, [sp, #32]
  20dd3e:	9107      	str	r1, [sp, #28]
  20dd40:	683a      	ldr	r2, [r7, #0]
  20dd42:	9206      	str	r2, [sp, #24]
  20dd44:	687a      	ldr	r2, [r7, #4]
  20dd46:	9205      	str	r2, [sp, #20]
  20dd48:	4b53      	ldr	r3, [pc, #332]	; (20de98 <LCD_StrChangeColorRotVarIndirect+0x2cc>)
  20dd4a:	9304      	str	r3, [sp, #16]
  20dd4c:	69fb      	ldr	r3, [r7, #28]
  20dd4e:	9303      	str	r3, [sp, #12]
  20dd50:	2300      	movs	r3, #0
  20dd52:	9302      	str	r3, [sp, #8]
  20dd54:	2300      	movs	r3, #0
  20dd56:	9301      	str	r3, [sp, #4]
  20dd58:	68ba      	ldr	r2, [r7, #8]
  20dd5a:	9200      	str	r2, [sp, #0]
  20dd5c:	68fb      	ldr	r3, [r7, #12]
  20dd5e:	4632      	mov	r2, r6
  20dd60:	4671      	mov	r1, lr
  20dd62:	4628      	mov	r0, r5
  20dd64:	f7fc fcc0 	bl	20a6e8 <LCD_DrawStrChangeColor>
  20dd68:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20dd6c:	f107 0210 	add.w	r2, r7, #16
  20dd70:	6810      	ldr	r0, [r2, #0]
  20dd72:	6018      	str	r0, [r3, #0]
  20dd74:	8892      	ldrh	r2, [r2, #4]
  20dd76:	809a      	strh	r2, [r3, #4]
	LCD_CopyBuff2pLcdIndirect(FontVar[idVar].rotate,movableFontsBuffer_pos, movableFontsBuffer, pxlTxtLen,fontHeight,0, temp.inPixel,0);
  20dd78:	4944      	ldr	r1, [pc, #272]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dd7a:	6a3a      	ldr	r2, [r7, #32]
  20dd7c:	4613      	mov	r3, r2
  20dd7e:	011b      	lsls	r3, r3, #4
  20dd80:	1a9b      	subs	r3, r3, r2
  20dd82:	009b      	lsls	r3, r3, #2
  20dd84:	440b      	add	r3, r1
  20dd86:	3314      	adds	r3, #20
  20dd88:	781b      	ldrb	r3, [r3, #0]
  20dd8a:	461c      	mov	r4, r3
  20dd8c:	4b41      	ldr	r3, [pc, #260]	; (20de94 <LCD_StrChangeColorRotVarIndirect+0x2c8>)
  20dd8e:	681b      	ldr	r3, [r3, #0]
  20dd90:	461d      	mov	r5, r3
  20dd92:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
  20dd94:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20dd96:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
  20dd98:	2100      	movs	r1, #0
  20dd9a:	9103      	str	r1, [sp, #12]
  20dd9c:	9202      	str	r2, [sp, #8]
  20dd9e:	2200      	movs	r2, #0
  20dda0:	9201      	str	r2, [sp, #4]
  20dda2:	9300      	str	r3, [sp, #0]
  20dda4:	4603      	mov	r3, r0
  20dda6:	4a3c      	ldr	r2, [pc, #240]	; (20de98 <LCD_StrChangeColorRotVarIndirect+0x2cc>)
  20dda8:	4629      	mov	r1, r5
  20ddaa:	4620      	mov	r0, r4
  20ddac:	f7f9 ff9e 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
	switch(FontVar[idVar].rotate)
  20ddb0:	4936      	ldr	r1, [pc, #216]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20ddb2:	6a3a      	ldr	r2, [r7, #32]
  20ddb4:	4613      	mov	r3, r2
  20ddb6:	011b      	lsls	r3, r3, #4
  20ddb8:	1a9b      	subs	r3, r3, r2
  20ddba:	009b      	lsls	r3, r3, #2
  20ddbc:	440b      	add	r3, r1
  20ddbe:	3314      	adds	r3, #20
  20ddc0:	781b      	ldrb	r3, [r3, #0]
  20ddc2:	2b00      	cmp	r3, #0
  20ddc4:	d11c      	bne.n	20de00 <LCD_StrChangeColorRotVarIndirect+0x234>
	{	case Rotate_0:
			LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos,(uint32_t)FontVar[idVar].yPos, pxlTxtLen,fontHeight, pLcd);
  20ddc6:	4931      	ldr	r1, [pc, #196]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20ddc8:	6a3a      	ldr	r2, [r7, #32]
  20ddca:	4613      	mov	r3, r2
  20ddcc:	011b      	lsls	r3, r3, #4
  20ddce:	1a9b      	subs	r3, r3, r2
  20ddd0:	009b      	lsls	r3, r3, #2
  20ddd2:	440b      	add	r3, r1
  20ddd4:	3302      	adds	r3, #2
  20ddd6:	881b      	ldrh	r3, [r3, #0]
  20ddd8:	4618      	mov	r0, r3
  20ddda:	492c      	ldr	r1, [pc, #176]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20dddc:	6a3a      	ldr	r2, [r7, #32]
  20ddde:	4613      	mov	r3, r2
  20dde0:	011b      	lsls	r3, r3, #4
  20dde2:	1a9b      	subs	r3, r3, r2
  20dde4:	009b      	lsls	r3, r3, #2
  20dde6:	440b      	add	r3, r1
  20dde8:	3304      	adds	r3, #4
  20ddea:	881b      	ldrh	r3, [r3, #0]
  20ddec:	461c      	mov	r4, r3
  20ddee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20ddf0:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  20ddf2:	4b2a      	ldr	r3, [pc, #168]	; (20de9c <LCD_StrChangeColorRotVarIndirect+0x2d0>)
  20ddf4:	9300      	str	r3, [sp, #0]
  20ddf6:	460b      	mov	r3, r1
  20ddf8:	4621      	mov	r1, r4
  20ddfa:	f7f9 fe4b 	bl	207a94 <LCD_DisplayBuff>
			break;
  20ddfe:	e01c      	b.n	20de3a <LCD_StrChangeColorRotVarIndirect+0x26e>
		case Rotate_90:
		case Rotate_180:
		default:
			LCD_DisplayBuff((uint32_t)FontVar[idVar].xPos,(uint32_t)FontVar[idVar].yPos, fontHeight,pxlTxtLen, pLcd);
  20de00:	4922      	ldr	r1, [pc, #136]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20de02:	6a3a      	ldr	r2, [r7, #32]
  20de04:	4613      	mov	r3, r2
  20de06:	011b      	lsls	r3, r3, #4
  20de08:	1a9b      	subs	r3, r3, r2
  20de0a:	009b      	lsls	r3, r3, #2
  20de0c:	440b      	add	r3, r1
  20de0e:	3302      	adds	r3, #2
  20de10:	881b      	ldrh	r3, [r3, #0]
  20de12:	4618      	mov	r0, r3
  20de14:	491d      	ldr	r1, [pc, #116]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20de16:	6a3a      	ldr	r2, [r7, #32]
  20de18:	4613      	mov	r3, r2
  20de1a:	011b      	lsls	r3, r3, #4
  20de1c:	1a9b      	subs	r3, r3, r2
  20de1e:	009b      	lsls	r3, r3, #2
  20de20:	440b      	add	r3, r1
  20de22:	3304      	adds	r3, #4
  20de24:	881b      	ldrh	r3, [r3, #0]
  20de26:	461c      	mov	r4, r3
  20de28:	6bba      	ldr	r2, [r7, #56]	; 0x38
  20de2a:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  20de2c:	4b1b      	ldr	r3, [pc, #108]	; (20de9c <LCD_StrChangeColorRotVarIndirect+0x2d0>)
  20de2e:	9300      	str	r3, [sp, #0]
  20de30:	460b      	mov	r3, r1
  20de32:	4621      	mov	r1, r4
  20de34:	f7f9 fe2e 	bl	207a94 <LCD_DisplayBuff>
			break;
  20de38:	bf00      	nop
	}
	if(FontVar[idVar].rotate>Rotate_0)
  20de3a:	4914      	ldr	r1, [pc, #80]	; (20de8c <LCD_StrChangeColorRotVarIndirect+0x2c0>)
  20de3c:	6a3a      	ldr	r2, [r7, #32]
  20de3e:	4613      	mov	r3, r2
  20de40:	011b      	lsls	r3, r3, #4
  20de42:	1a9b      	subs	r3, r3, r2
  20de44:	009b      	lsls	r3, r3, #2
  20de46:	440b      	add	r3, r1
  20de48:	3314      	adds	r3, #20
  20de4a:	781b      	ldrb	r3, [r3, #0]
  20de4c:	2b00      	cmp	r3, #0
  20de4e:	d009      	beq.n	20de64 <LCD_StrChangeColorRotVarIndirect+0x298>
		SwapUint16(&temp.inPixel,&temp.height);
  20de50:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20de54:	1d1a      	adds	r2, r3, #4
  20de56:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20de5a:	3302      	adds	r3, #2
  20de5c:	4611      	mov	r1, r2
  20de5e:	4618      	mov	r0, r3
  20de60:	f7f3 fe66 	bl	201b30 <SwapUint16>
	LCD_DimensionBkCorrect(idVar,temp,pLcd);
  20de64:	4b0d      	ldr	r3, [pc, #52]	; (20de9c <LCD_StrChangeColorRotVarIndirect+0x2d0>)
  20de66:	f107 022c 	add.w	r2, r7, #44	; 0x2c
  20de6a:	ca06      	ldmia	r2, {r1, r2}
  20de6c:	6a38      	ldr	r0, [r7, #32]
  20de6e:	f7fe fcc5 	bl	20c7fc <LCD_DimensionBkCorrect>
	return temp;
  20de72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20de74:	461a      	mov	r2, r3
  20de76:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  20de7a:	6818      	ldr	r0, [r3, #0]
  20de7c:	6010      	str	r0, [r2, #0]
  20de7e:	889b      	ldrh	r3, [r3, #4]
  20de80:	8093      	strh	r3, [r2, #4]
}
  20de82:	6a78      	ldr	r0, [r7, #36]	; 0x24
  20de84:	3744      	adds	r7, #68	; 0x44
  20de86:	46bd      	mov	sp, r7
  20de88:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20de8a:	bf00      	nop
  20de8c:	2000f818 	.word	0x2000f818
  20de90:	20003474 	.word	0x20003474
  20de94:	2000347c 	.word	0x2000347c
  20de98:	c067f800 	.word	0xc067f800
  20de9c:	c0000000 	.word	0xc0000000

0020dea0 <LCD_StrRotWin>:

StructTxtPxlLen LCD_StrRotWin(int rot, int winWidth, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth, uint32_t bkScreenColor)
{
  20dea0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  20dea4:	b09e      	sub	sp, #120	; 0x78
  20dea6:	af0a      	add	r7, sp, #40	; 0x28
  20dea8:	6178      	str	r0, [r7, #20]
  20deaa:	6139      	str	r1, [r7, #16]
  20deac:	60fa      	str	r2, [r7, #12]
  20deae:	60bb      	str	r3, [r7, #8]
  20deb0:	466b      	mov	r3, sp
  20deb2:	469a      	mov	sl, r3
	StructTxtPxlLen temp;
	int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20deb4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20deb6:	f113 0f03 	cmn.w	r3, #3
  20deba:	d104      	bne.n	20dec6 <LCD_StrRotWin+0x26>
  20debc:	68b8      	ldr	r0, [r7, #8]
  20debe:	f004 fa99 	bl	2123f4 <LCD_GetFontHeight>
  20dec2:	4603      	mov	r3, r0
  20dec4:	e003      	b.n	20dece <LCD_StrRotWin+0x2e>
  20dec6:	68b8      	ldr	r0, [r7, #8]
  20dec8:	f004 fad0 	bl	21246c <LCD_GetFontHalfHeight>
  20decc:	4603      	mov	r3, r0
  20dece:	643b      	str	r3, [r7, #64]	; 0x40
	if(fontHeight<0)
  20ded0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20ded2:	2b00      	cmp	r3, #0
  20ded4:	da06      	bge.n	20dee4 <LCD_StrRotWin+0x44>
		return StructTxtPxlLen_ZeroValue;
  20ded6:	697b      	ldr	r3, [r7, #20]
  20ded8:	4a9c      	ldr	r2, [pc, #624]	; (20e14c <LCD_StrRotWin+0x2ac>)
  20deda:	6810      	ldr	r0, [r2, #0]
  20dedc:	6018      	str	r0, [r3, #0]
  20dede:	8892      	ldrh	r2, [r2, #4]
  20dee0:	809a      	strh	r2, [r3, #4]
  20dee2:	e12d      	b.n	20e140 <LCD_StrRotWin+0x2a0>
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20dee4:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  20dee8:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20deec:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  20deee:	68b8      	ldr	r0, [r7, #8]
  20def0:	f004 f8ec 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20def4:	63f8      	str	r0, [r7, #60]	; 0x3c

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight*pxlTxtLen;
  20def6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20def8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20defa:	fb02 f203 	mul.w	r2, r2, r3
  20defe:	4b94      	ldr	r3, [pc, #592]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20df00:	681b      	ldr	r3, [r3, #0]
  20df02:	4413      	add	r3, r2
  20df04:	63bb      	str	r3, [r7, #56]	; 0x38
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20df06:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20df08:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20df0c:	db06      	blt.n	20df1c <LCD_StrRotWin+0x7c>
		return StructTxtPxlLen_ZeroValue;
  20df0e:	697b      	ldr	r3, [r7, #20]
  20df10:	4a8e      	ldr	r2, [pc, #568]	; (20e14c <LCD_StrRotWin+0x2ac>)
  20df12:	6810      	ldr	r0, [r2, #0]
  20df14:	6018      	str	r0, [r3, #0]
  20df16:	8892      	ldrh	r2, [r2, #4]
  20df18:	809a      	strh	r2, [r3, #4]
  20df1a:	e111      	b.n	20e140 <LCD_StrRotWin+0x2a0>

	int i=0,it=0,iH=0,j;
  20df1c:	2300      	movs	r3, #0
  20df1e:	637b      	str	r3, [r7, #52]	; 0x34
  20df20:	2300      	movs	r3, #0
  20df22:	64fb      	str	r3, [r7, #76]	; 0x4c
  20df24:	2300      	movs	r3, #0
  20df26:	64bb      	str	r3, [r7, #72]	; 0x48
	int movableFontsBuffer_pos_copy=movableFontsBuffer_pos;
  20df28:	4b89      	ldr	r3, [pc, #548]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20df2a:	681b      	ldr	r3, [r3, #0]
  20df2c:	633b      	str	r3, [r7, #48]	; 0x30
	char bufTxt[winWidth/LCD_GetFontWidth(fontID,'1')];
  20df2e:	2131      	movs	r1, #49	; 0x31
  20df30:	68b8      	ldr	r0, [r7, #8]
  20df32:	f004 fa21 	bl	212378 <LCD_GetFontWidth>
  20df36:	4602      	mov	r2, r0
  20df38:	68fb      	ldr	r3, [r7, #12]
  20df3a:	fb93 f6f2 	sdiv	r6, r3, r2
  20df3e:	1e73      	subs	r3, r6, #1
  20df40:	62fb      	str	r3, [r7, #44]	; 0x2c
  20df42:	4633      	mov	r3, r6
  20df44:	461a      	mov	r2, r3
  20df46:	f04f 0300 	mov.w	r3, #0
  20df4a:	ea4f 09c3 	mov.w	r9, r3, lsl #3
  20df4e:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
  20df52:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  20df56:	4633      	mov	r3, r6
  20df58:	461a      	mov	r2, r3
  20df5a:	f04f 0300 	mov.w	r3, #0
  20df5e:	00dd      	lsls	r5, r3, #3
  20df60:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
  20df64:	00d4      	lsls	r4, r2, #3
  20df66:	4633      	mov	r3, r6
  20df68:	3307      	adds	r3, #7
  20df6a:	08db      	lsrs	r3, r3, #3
  20df6c:	00db      	lsls	r3, r3, #3
  20df6e:	ebad 0d03 	sub.w	sp, sp, r3
  20df72:	ab0a      	add	r3, sp, #40	; 0x28
  20df74:	3300      	adds	r3, #0
  20df76:	62bb      	str	r3, [r7, #40]	; 0x28

		do
		{	if(iH>0){ if(txt[it]==' ') it++; }
  20df78:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20df7a:	2b00      	cmp	r3, #0
  20df7c:	dd08      	ble.n	20df90 <LCD_StrRotWin+0xf0>
  20df7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20df80:	6fba      	ldr	r2, [r7, #120]	; 0x78
  20df82:	4413      	add	r3, r2
  20df84:	781b      	ldrb	r3, [r3, #0]
  20df86:	2b20      	cmp	r3, #32
  20df88:	d102      	bne.n	20df90 <LCD_StrRotWin+0xf0>
  20df8a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20df8c:	3301      	adds	r3, #1
  20df8e:	64fb      	str	r3, [r7, #76]	; 0x4c
			i= LCD_GetStrLenForPxlWidth(fontID,&txt[it],winWidth,space,constWidth);
  20df90:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20df92:	6fba      	ldr	r2, [r7, #120]	; 0x78
  20df94:	18d1      	adds	r1, r2, r3
  20df96:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  20df9a:	9300      	str	r3, [sp, #0]
  20df9c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  20dfa0:	68fa      	ldr	r2, [r7, #12]
  20dfa2:	68b8      	ldr	r0, [r7, #8]
  20dfa4:	f004 f96c 	bl	212280 <LCD_GetStrLenForPxlWidth>
  20dfa8:	6378      	str	r0, [r7, #52]	; 0x34
			if(i==0) break;
  20dfaa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20dfac:	2b00      	cmp	r3, #0
  20dfae:	f000 808d 	beq.w	20e0cc <LCD_StrRotWin+0x22c>
			for(j=0;j<i;++j)
  20dfb2:	2300      	movs	r3, #0
  20dfb4:	647b      	str	r3, [r7, #68]	; 0x44
  20dfb6:	e013      	b.n	20dfe0 <LCD_StrRotWin+0x140>
			{	if(j==sizeof(bufTxt)-1)
  20dfb8:	4633      	mov	r3, r6
  20dfba:	1e5a      	subs	r2, r3, #1
  20dfbc:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20dfbe:	429a      	cmp	r2, r3
  20dfc0:	d013      	beq.n	20dfea <LCD_StrRotWin+0x14a>
					break;
				bufTxt[j]=txt[it+j];
  20dfc2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20dfc4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20dfc6:	4413      	add	r3, r2
  20dfc8:	461a      	mov	r2, r3
  20dfca:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  20dfcc:	4413      	add	r3, r2
  20dfce:	7819      	ldrb	r1, [r3, #0]
  20dfd0:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20dfd2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20dfd4:	4413      	add	r3, r2
  20dfd6:	460a      	mov	r2, r1
  20dfd8:	701a      	strb	r2, [r3, #0]
			for(j=0;j<i;++j)
  20dfda:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20dfdc:	3301      	adds	r3, #1
  20dfde:	647b      	str	r3, [r7, #68]	; 0x44
  20dfe0:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20dfe2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20dfe4:	429a      	cmp	r2, r3
  20dfe6:	dbe7      	blt.n	20dfb8 <LCD_StrRotWin+0x118>
  20dfe8:	e000      	b.n	20dfec <LCD_StrRotWin+0x14c>
					break;
  20dfea:	bf00      	nop
			}
			bufTxt[j]=0;
  20dfec:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20dfee:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20dff0:	4413      	add	r3, r2
  20dff2:	2200      	movs	r2, #0
  20dff4:	701a      	strb	r2, [r3, #0]
			it+=i;
  20dff6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20dff8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20dffa:	4413      	add	r3, r2
  20dffc:	64fb      	str	r3, [r7, #76]	; 0x4c
			temp=LCD_DrawStr(movableFontsBuffer_pos, winWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  20dffe:	4b54      	ldr	r3, [pc, #336]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20e000:	681b      	ldr	r3, [r3, #0]
  20e002:	461d      	mov	r5, r3
  20e004:	68f9      	ldr	r1, [r7, #12]
  20e006:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  20e008:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20e00a:	4638      	mov	r0, r7
  20e00c:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  20e010:	9209      	str	r2, [sp, #36]	; 0x24
  20e012:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20e016:	9208      	str	r2, [sp, #32]
  20e018:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  20e01c:	9207      	str	r2, [sp, #28]
  20e01e:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20e022:	9206      	str	r2, [sp, #24]
  20e024:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  20e026:	9205      	str	r2, [sp, #20]
  20e028:	4a4a      	ldr	r2, [pc, #296]	; (20e154 <LCD_StrRotWin+0x2b4>)
  20e02a:	9204      	str	r2, [sp, #16]
  20e02c:	9303      	str	r3, [sp, #12]
  20e02e:	2300      	movs	r3, #0
  20e030:	9302      	str	r3, [sp, #8]
  20e032:	2300      	movs	r3, #0
  20e034:	9301      	str	r3, [sp, #4]
  20e036:	68bb      	ldr	r3, [r7, #8]
  20e038:	9300      	str	r3, [sp, #0]
  20e03a:	4623      	mov	r3, r4
  20e03c:	460a      	mov	r2, r1
  20e03e:	4629      	mov	r1, r5
  20e040:	f7fc faec 	bl	20a61c <LCD_DrawStr>
  20e044:	f107 0318 	add.w	r3, r7, #24
  20e048:	463a      	mov	r2, r7
  20e04a:	6810      	ldr	r0, [r2, #0]
  20e04c:	6018      	str	r0, [r3, #0]
  20e04e:	8892      	ldrh	r2, [r2, #4]
  20e050:	809a      	strh	r2, [r3, #4]

			int diffWidth=winWidth-temp.inPixel;
  20e052:	8b7b      	ldrh	r3, [r7, #26]
  20e054:	461a      	mov	r2, r3
  20e056:	68fb      	ldr	r3, [r7, #12]
  20e058:	1a9b      	subs	r3, r3, r2
  20e05a:	627b      	str	r3, [r7, #36]	; 0x24
			if(diffWidth>0)
  20e05c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e05e:	2b00      	cmp	r3, #0
  20e060:	dd1c      	ble.n	20e09c <LCD_StrRotWin+0x1fc>
				LCD_RectangleBuff(movableFontsBuffer,movableFontsBuffer_pos, winWidth,fontHeight, temp.inPixel,0, diffWidth,fontHeight, bkColor,bkColor,bkColor);
  20e062:	4b3b      	ldr	r3, [pc, #236]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20e064:	681b      	ldr	r3, [r3, #0]
  20e066:	469e      	mov	lr, r3
  20e068:	68f8      	ldr	r0, [r7, #12]
  20e06a:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  20e06c:	8b7b      	ldrh	r3, [r7, #26]
  20e06e:	461d      	mov	r5, r3
  20e070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e072:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20e074:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20e078:	9106      	str	r1, [sp, #24]
  20e07a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20e07e:	9105      	str	r1, [sp, #20]
  20e080:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20e084:	9104      	str	r1, [sp, #16]
  20e086:	9203      	str	r2, [sp, #12]
  20e088:	9302      	str	r3, [sp, #8]
  20e08a:	2300      	movs	r3, #0
  20e08c:	9301      	str	r3, [sp, #4]
  20e08e:	9500      	str	r5, [sp, #0]
  20e090:	4623      	mov	r3, r4
  20e092:	4602      	mov	r2, r0
  20e094:	4671      	mov	r1, lr
  20e096:	482f      	ldr	r0, [pc, #188]	; (20e154 <LCD_StrRotWin+0x2b4>)
  20e098:	f7f9 ff90 	bl	207fbc <LCD_RectangleBuff>

			movableFontsBuffer_pos += fontHeight*winWidth;
  20e09c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e09e:	68fa      	ldr	r2, [r7, #12]
  20e0a0:	fb02 f203 	mul.w	r2, r2, r3
  20e0a4:	4b2a      	ldr	r3, [pc, #168]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20e0a6:	681b      	ldr	r3, [r3, #0]
  20e0a8:	4413      	add	r3, r2
  20e0aa:	4a29      	ldr	r2, [pc, #164]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20e0ac:	6013      	str	r3, [r2, #0]
			iH++;
  20e0ae:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e0b0:	3301      	adds	r3, #1
  20e0b2:	64bb      	str	r3, [r7, #72]	; 0x48
		}while(movableFontsBuffer_pos + fontHeight*winWidth < LCD_MOVABLE_FONTS_BUFF_SIZE);
  20e0b4:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e0b6:	68fa      	ldr	r2, [r7, #12]
  20e0b8:	fb02 f203 	mul.w	r2, r2, r3
  20e0bc:	4b24      	ldr	r3, [pc, #144]	; (20e150 <LCD_StrRotWin+0x2b0>)
  20e0be:	681b      	ldr	r3, [r3, #0]
  20e0c0:	4413      	add	r3, r2
  20e0c2:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20e0c6:	f6ff af57 	blt.w	20df78 <LCD_StrRotWin+0xd8>
  20e0ca:	e000      	b.n	20e0ce <LCD_StrRotWin+0x22e>
			if(i==0) break;
  20e0cc:	bf00      	nop

		int winHeight = fontHeight*iH;
  20e0ce:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e0d0:	6cba      	ldr	r2, [r7, #72]	; 0x48
  20e0d2:	fb02 f303 	mul.w	r3, r2, r3
  20e0d6:	623b      	str	r3, [r7, #32]
		LCD_CopyBuff2pLcd(rot,movableFontsBuffer_pos_copy, movableFontsBuffer, winWidth,winHeight, 0, winWidth, Xpos,Ypos,0);
  20e0d8:	6b3d      	ldr	r5, [r7, #48]	; 0x30
  20e0da:	68fe      	ldr	r6, [r7, #12]
  20e0dc:	6a3b      	ldr	r3, [r7, #32]
  20e0de:	68fa      	ldr	r2, [r7, #12]
  20e0e0:	b292      	uxth	r2, r2
  20e0e2:	6f39      	ldr	r1, [r7, #112]	; 0x70
  20e0e4:	b289      	uxth	r1, r1
  20e0e6:	6f78      	ldr	r0, [r7, #116]	; 0x74
  20e0e8:	b280      	uxth	r0, r0
  20e0ea:	2400      	movs	r4, #0
  20e0ec:	9405      	str	r4, [sp, #20]
  20e0ee:	9004      	str	r0, [sp, #16]
  20e0f0:	9103      	str	r1, [sp, #12]
  20e0f2:	9202      	str	r2, [sp, #8]
  20e0f4:	2200      	movs	r2, #0
  20e0f6:	9201      	str	r2, [sp, #4]
  20e0f8:	9300      	str	r3, [sp, #0]
  20e0fa:	4633      	mov	r3, r6
  20e0fc:	4a15      	ldr	r2, [pc, #84]	; (20e154 <LCD_StrRotWin+0x2b4>)
  20e0fe:	4629      	mov	r1, r5
  20e100:	6938      	ldr	r0, [r7, #16]
  20e102:	f7f9 fd21 	bl	207b48 <LCD_CopyBuff2pLcd>

		temp.inChar=0;
  20e106:	2300      	movs	r3, #0
  20e108:	833b      	strh	r3, [r7, #24]
		temp.inPixel=winWidth;
  20e10a:	68fb      	ldr	r3, [r7, #12]
  20e10c:	b29b      	uxth	r3, r3
  20e10e:	837b      	strh	r3, [r7, #26]
		temp.height=winHeight;
  20e110:	6a3b      	ldr	r3, [r7, #32]
  20e112:	b29b      	uxth	r3, r3
  20e114:	83bb      	strh	r3, [r7, #28]
		if(rot>Rotate_0)
  20e116:	693b      	ldr	r3, [r7, #16]
  20e118:	2b00      	cmp	r3, #0
  20e11a:	dd09      	ble.n	20e130 <LCD_StrRotWin+0x290>
			SwapUint16(&temp.inPixel,&temp.height);
  20e11c:	f107 0318 	add.w	r3, r7, #24
  20e120:	1d1a      	adds	r2, r3, #4
  20e122:	f107 0318 	add.w	r3, r7, #24
  20e126:	3302      	adds	r3, #2
  20e128:	4611      	mov	r1, r2
  20e12a:	4618      	mov	r0, r3
  20e12c:	f7f3 fd00 	bl	201b30 <SwapUint16>
		return temp;
  20e130:	697b      	ldr	r3, [r7, #20]
  20e132:	461a      	mov	r2, r3
  20e134:	f107 0318 	add.w	r3, r7, #24
  20e138:	6818      	ldr	r0, [r3, #0]
  20e13a:	6010      	str	r0, [r2, #0]
  20e13c:	889b      	ldrh	r3, [r3, #4]
  20e13e:	8093      	strh	r3, [r2, #4]
  20e140:	46d5      	mov	sp, sl
}
  20e142:	6978      	ldr	r0, [r7, #20]
  20e144:	3750      	adds	r7, #80	; 0x50
  20e146:	46bd      	mov	sp, r7
  20e148:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20e14c:	20003474 	.word	0x20003474
  20e150:	2000347c 	.word	0x2000347c
  20e154:	c067f800 	.word	0xc067f800

0020e158 <LCD_StrChangeColorRotWin>:

StructTxtPxlLen LCD_StrChangeColorRotWin(int rot, int winWidth, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, int maxVal, int constWidth, uint32_t bkScreenColor)
{
  20e158:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  20e15c:	b0a0      	sub	sp, #128	; 0x80
  20e15e:	af0c      	add	r7, sp, #48	; 0x30
  20e160:	6178      	str	r0, [r7, #20]
  20e162:	6139      	str	r1, [r7, #16]
  20e164:	60fa      	str	r2, [r7, #12]
  20e166:	60bb      	str	r3, [r7, #8]
  20e168:	466b      	mov	r3, sp
  20e16a:	469a      	mov	sl, r3
	StructTxtPxlLen temp;
	int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20e16c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  20e16e:	f113 0f03 	cmn.w	r3, #3
  20e172:	d104      	bne.n	20e17e <LCD_StrChangeColorRotWin+0x26>
  20e174:	68b8      	ldr	r0, [r7, #8]
  20e176:	f004 f93d 	bl	2123f4 <LCD_GetFontHeight>
  20e17a:	4603      	mov	r3, r0
  20e17c:	e003      	b.n	20e186 <LCD_StrChangeColorRotWin+0x2e>
  20e17e:	68b8      	ldr	r0, [r7, #8]
  20e180:	f004 f974 	bl	21246c <LCD_GetFontHalfHeight>
  20e184:	4603      	mov	r3, r0
  20e186:	643b      	str	r3, [r7, #64]	; 0x40
	if(fontHeight<0)
  20e188:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e18a:	2b00      	cmp	r3, #0
  20e18c:	da06      	bge.n	20e19c <LCD_StrChangeColorRotWin+0x44>
		return StructTxtPxlLen_ZeroValue;
  20e18e:	697b      	ldr	r3, [r7, #20]
  20e190:	4a97      	ldr	r2, [pc, #604]	; (20e3f0 <LCD_StrChangeColorRotWin+0x298>)
  20e192:	6810      	ldr	r0, [r2, #0]
  20e194:	6018      	str	r0, [r3, #0]
  20e196:	8892      	ldrh	r2, [r2, #4]
  20e198:	809a      	strh	r2, [r3, #4]
  20e19a:	e16b      	b.n	20e474 <LCD_StrChangeColorRotWin+0x31c>
	int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20e19c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20e1a0:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20e1a4:	6fb9      	ldr	r1, [r7, #120]	; 0x78
  20e1a6:	68b8      	ldr	r0, [r7, #8]
  20e1a8:	f003 ff90 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20e1ac:	63f8      	str	r0, [r7, #60]	; 0x3c

	int posMovBuff_copy = movableFontsBuffer_pos + fontHeight*pxlTxtLen;
  20e1ae:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e1b0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  20e1b2:	fb02 f203 	mul.w	r2, r2, r3
  20e1b6:	4b8f      	ldr	r3, [pc, #572]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e1b8:	681b      	ldr	r3, [r3, #0]
  20e1ba:	4413      	add	r3, r2
  20e1bc:	63bb      	str	r3, [r7, #56]	; 0x38
	if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20e1be:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  20e1c0:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20e1c4:	db06      	blt.n	20e1d4 <LCD_StrChangeColorRotWin+0x7c>
		return StructTxtPxlLen_ZeroValue;
  20e1c6:	697b      	ldr	r3, [r7, #20]
  20e1c8:	4a89      	ldr	r2, [pc, #548]	; (20e3f0 <LCD_StrChangeColorRotWin+0x298>)
  20e1ca:	6810      	ldr	r0, [r2, #0]
  20e1cc:	6018      	str	r0, [r3, #0]
  20e1ce:	8892      	ldrh	r2, [r2, #4]
  20e1d0:	809a      	strh	r2, [r3, #4]
  20e1d2:	e14f      	b.n	20e474 <LCD_StrChangeColorRotWin+0x31c>

	int i=0,it=0,iH=0,j;
  20e1d4:	2300      	movs	r3, #0
  20e1d6:	637b      	str	r3, [r7, #52]	; 0x34
  20e1d8:	2300      	movs	r3, #0
  20e1da:	64fb      	str	r3, [r7, #76]	; 0x4c
  20e1dc:	2300      	movs	r3, #0
  20e1de:	64bb      	str	r3, [r7, #72]	; 0x48
	int movableFontsBuffer_pos_copy=movableFontsBuffer_pos;
  20e1e0:	4b84      	ldr	r3, [pc, #528]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e1e2:	681b      	ldr	r3, [r3, #0]
  20e1e4:	633b      	str	r3, [r7, #48]	; 0x30
	char bufTxt[winWidth/LCD_GetFontWidth(fontID,'1')];
  20e1e6:	2131      	movs	r1, #49	; 0x31
  20e1e8:	68b8      	ldr	r0, [r7, #8]
  20e1ea:	f004 f8c5 	bl	212378 <LCD_GetFontWidth>
  20e1ee:	4602      	mov	r2, r0
  20e1f0:	68fb      	ldr	r3, [r7, #12]
  20e1f2:	fb93 f6f2 	sdiv	r6, r3, r2
  20e1f6:	1e73      	subs	r3, r6, #1
  20e1f8:	62fb      	str	r3, [r7, #44]	; 0x2c
  20e1fa:	4633      	mov	r3, r6
  20e1fc:	461a      	mov	r2, r3
  20e1fe:	f04f 0300 	mov.w	r3, #0
  20e202:	ea4f 09c3 	mov.w	r9, r3, lsl #3
  20e206:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
  20e20a:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  20e20e:	4633      	mov	r3, r6
  20e210:	461a      	mov	r2, r3
  20e212:	f04f 0300 	mov.w	r3, #0
  20e216:	00dd      	lsls	r5, r3, #3
  20e218:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
  20e21c:	00d4      	lsls	r4, r2, #3
  20e21e:	4633      	mov	r3, r6
  20e220:	3307      	adds	r3, #7
  20e222:	08db      	lsrs	r3, r3, #3
  20e224:	00db      	lsls	r3, r3, #3
  20e226:	ebad 0d03 	sub.w	sp, sp, r3
  20e22a:	ab0c      	add	r3, sp, #48	; 0x30
  20e22c:	3300      	adds	r3, #0
  20e22e:	62bb      	str	r3, [r7, #40]	; 0x28

		do
		{	if(iH>0){ if(txt[it]==' ') it++; }
  20e230:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e232:	2b00      	cmp	r3, #0
  20e234:	dd08      	ble.n	20e248 <LCD_StrChangeColorRotWin+0xf0>
  20e236:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20e238:	6fba      	ldr	r2, [r7, #120]	; 0x78
  20e23a:	4413      	add	r3, r2
  20e23c:	781b      	ldrb	r3, [r3, #0]
  20e23e:	2b20      	cmp	r3, #32
  20e240:	d102      	bne.n	20e248 <LCD_StrChangeColorRotWin+0xf0>
  20e242:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20e244:	3301      	adds	r3, #1
  20e246:	64fb      	str	r3, [r7, #76]	; 0x4c
			i= LCD_GetStrLenForPxlWidth(fontID,&txt[it],winWidth,space,constWidth);
  20e248:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20e24a:	6fba      	ldr	r2, [r7, #120]	; 0x78
  20e24c:	18d1      	adds	r1, r2, r3
  20e24e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
  20e252:	9300      	str	r3, [sp, #0]
  20e254:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  20e258:	68fa      	ldr	r2, [r7, #12]
  20e25a:	68b8      	ldr	r0, [r7, #8]
  20e25c:	f004 f810 	bl	212280 <LCD_GetStrLenForPxlWidth>
  20e260:	6378      	str	r0, [r7, #52]	; 0x34
			if(i==0) break;
  20e262:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20e264:	2b00      	cmp	r3, #0
  20e266:	f000 80cb 	beq.w	20e400 <LCD_StrChangeColorRotWin+0x2a8>
			for(j=0;j<i;++j)
  20e26a:	2300      	movs	r3, #0
  20e26c:	647b      	str	r3, [r7, #68]	; 0x44
  20e26e:	e013      	b.n	20e298 <LCD_StrChangeColorRotWin+0x140>
			{	if(j==sizeof(bufTxt)-1)
  20e270:	4633      	mov	r3, r6
  20e272:	1e5a      	subs	r2, r3, #1
  20e274:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20e276:	429a      	cmp	r2, r3
  20e278:	d013      	beq.n	20e2a2 <LCD_StrChangeColorRotWin+0x14a>
					break;
				bufTxt[j]=txt[it+j];
  20e27a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20e27c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20e27e:	4413      	add	r3, r2
  20e280:	461a      	mov	r2, r3
  20e282:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  20e284:	4413      	add	r3, r2
  20e286:	7819      	ldrb	r1, [r3, #0]
  20e288:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20e28a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20e28c:	4413      	add	r3, r2
  20e28e:	460a      	mov	r2, r1
  20e290:	701a      	strb	r2, [r3, #0]
			for(j=0;j<i;++j)
  20e292:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20e294:	3301      	adds	r3, #1
  20e296:	647b      	str	r3, [r7, #68]	; 0x44
  20e298:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  20e29a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20e29c:	429a      	cmp	r2, r3
  20e29e:	dbe7      	blt.n	20e270 <LCD_StrChangeColorRotWin+0x118>
  20e2a0:	e000      	b.n	20e2a4 <LCD_StrChangeColorRotWin+0x14c>
					break;
  20e2a2:	bf00      	nop
			}
			bufTxt[j]=0;
  20e2a4:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20e2a6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  20e2a8:	4413      	add	r3, r2
  20e2aa:	2200      	movs	r2, #0
  20e2ac:	701a      	strb	r2, [r3, #0]
			it+=i;
  20e2ae:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  20e2b0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  20e2b2:	4413      	add	r3, r2
  20e2b4:	64fb      	str	r3, [r7, #76]	; 0x4c
			if(iH==2)
  20e2b6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e2b8:	2b02      	cmp	r3, #2
  20e2ba:	d12d      	bne.n	20e318 <LCD_StrChangeColorRotWin+0x1c0>
				temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, winWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,DARKBLUE,fontColor,maxVal,constWidth);
  20e2bc:	4b4d      	ldr	r3, [pc, #308]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e2be:	681b      	ldr	r3, [r3, #0]
  20e2c0:	469e      	mov	lr, r3
  20e2c2:	68fc      	ldr	r4, [r7, #12]
  20e2c4:	6c3d      	ldr	r5, [r7, #64]	; 0x40
  20e2c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20e2c8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  20e2cc:	b2d2      	uxtb	r2, r2
  20e2ce:	4638      	mov	r0, r7
  20e2d0:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  20e2d4:	910a      	str	r1, [sp, #40]	; 0x28
  20e2d6:	9209      	str	r2, [sp, #36]	; 0x24
  20e2d8:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20e2dc:	9208      	str	r2, [sp, #32]
  20e2de:	4a46      	ldr	r2, [pc, #280]	; (20e3f8 <LCD_StrChangeColorRotWin+0x2a0>)
  20e2e0:	9207      	str	r2, [sp, #28]
  20e2e2:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20e2e6:	9206      	str	r2, [sp, #24]
  20e2e8:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  20e2ea:	9205      	str	r2, [sp, #20]
  20e2ec:	4a43      	ldr	r2, [pc, #268]	; (20e3fc <LCD_StrChangeColorRotWin+0x2a4>)
  20e2ee:	9204      	str	r2, [sp, #16]
  20e2f0:	9303      	str	r3, [sp, #12]
  20e2f2:	2300      	movs	r3, #0
  20e2f4:	9302      	str	r3, [sp, #8]
  20e2f6:	2300      	movs	r3, #0
  20e2f8:	9301      	str	r3, [sp, #4]
  20e2fa:	68bb      	ldr	r3, [r7, #8]
  20e2fc:	9300      	str	r3, [sp, #0]
  20e2fe:	462b      	mov	r3, r5
  20e300:	4622      	mov	r2, r4
  20e302:	4671      	mov	r1, lr
  20e304:	f7fc f9f0 	bl	20a6e8 <LCD_DrawStrChangeColor>
  20e308:	f107 0318 	add.w	r3, r7, #24
  20e30c:	463a      	mov	r2, r7
  20e30e:	6810      	ldr	r0, [r2, #0]
  20e310:	6018      	str	r0, [r3, #0]
  20e312:	8892      	ldrh	r2, [r2, #4]
  20e314:	809a      	strh	r2, [r3, #4]
  20e316:	e02d      	b.n	20e374 <LCD_StrChangeColorRotWin+0x21c>
			else
				temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, winWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20e318:	4b36      	ldr	r3, [pc, #216]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e31a:	681b      	ldr	r3, [r3, #0]
  20e31c:	469e      	mov	lr, r3
  20e31e:	68fc      	ldr	r4, [r7, #12]
  20e320:	6c3d      	ldr	r5, [r7, #64]	; 0x40
  20e322:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20e324:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  20e328:	b2d2      	uxtb	r2, r2
  20e32a:	4638      	mov	r0, r7
  20e32c:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  20e330:	910a      	str	r1, [sp, #40]	; 0x28
  20e332:	9209      	str	r2, [sp, #36]	; 0x24
  20e334:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  20e338:	9208      	str	r2, [sp, #32]
  20e33a:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  20e33e:	9207      	str	r2, [sp, #28]
  20e340:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  20e344:	9206      	str	r2, [sp, #24]
  20e346:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  20e348:	9205      	str	r2, [sp, #20]
  20e34a:	4a2c      	ldr	r2, [pc, #176]	; (20e3fc <LCD_StrChangeColorRotWin+0x2a4>)
  20e34c:	9204      	str	r2, [sp, #16]
  20e34e:	9303      	str	r3, [sp, #12]
  20e350:	2300      	movs	r3, #0
  20e352:	9302      	str	r3, [sp, #8]
  20e354:	2300      	movs	r3, #0
  20e356:	9301      	str	r3, [sp, #4]
  20e358:	68bb      	ldr	r3, [r7, #8]
  20e35a:	9300      	str	r3, [sp, #0]
  20e35c:	462b      	mov	r3, r5
  20e35e:	4622      	mov	r2, r4
  20e360:	4671      	mov	r1, lr
  20e362:	f7fc f9c1 	bl	20a6e8 <LCD_DrawStrChangeColor>
  20e366:	f107 0318 	add.w	r3, r7, #24
  20e36a:	463a      	mov	r2, r7
  20e36c:	6810      	ldr	r0, [r2, #0]
  20e36e:	6018      	str	r0, [r3, #0]
  20e370:	8892      	ldrh	r2, [r2, #4]
  20e372:	809a      	strh	r2, [r3, #4]

			int diffWidth=winWidth-temp.inPixel;
  20e374:	8b7b      	ldrh	r3, [r7, #26]
  20e376:	461a      	mov	r2, r3
  20e378:	68fb      	ldr	r3, [r7, #12]
  20e37a:	1a9b      	subs	r3, r3, r2
  20e37c:	627b      	str	r3, [r7, #36]	; 0x24
			if(diffWidth>0)
  20e37e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e380:	2b00      	cmp	r3, #0
  20e382:	dd1c      	ble.n	20e3be <LCD_StrChangeColorRotWin+0x266>
				LCD_RectangleBuff(movableFontsBuffer,movableFontsBuffer_pos, winWidth,fontHeight, temp.inPixel,0, diffWidth,fontHeight, bkColor,bkColor,bkColor);
  20e384:	4b1b      	ldr	r3, [pc, #108]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e386:	681b      	ldr	r3, [r3, #0]
  20e388:	469e      	mov	lr, r3
  20e38a:	68f8      	ldr	r0, [r7, #12]
  20e38c:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  20e38e:	8b7b      	ldrh	r3, [r7, #26]
  20e390:	461d      	mov	r5, r3
  20e392:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e394:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  20e396:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20e39a:	9106      	str	r1, [sp, #24]
  20e39c:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20e3a0:	9105      	str	r1, [sp, #20]
  20e3a2:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  20e3a6:	9104      	str	r1, [sp, #16]
  20e3a8:	9203      	str	r2, [sp, #12]
  20e3aa:	9302      	str	r3, [sp, #8]
  20e3ac:	2300      	movs	r3, #0
  20e3ae:	9301      	str	r3, [sp, #4]
  20e3b0:	9500      	str	r5, [sp, #0]
  20e3b2:	4623      	mov	r3, r4
  20e3b4:	4602      	mov	r2, r0
  20e3b6:	4671      	mov	r1, lr
  20e3b8:	4810      	ldr	r0, [pc, #64]	; (20e3fc <LCD_StrChangeColorRotWin+0x2a4>)
  20e3ba:	f7f9 fdff 	bl	207fbc <LCD_RectangleBuff>

			movableFontsBuffer_pos += fontHeight*winWidth;
  20e3be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e3c0:	68fa      	ldr	r2, [r7, #12]
  20e3c2:	fb02 f203 	mul.w	r2, r2, r3
  20e3c6:	4b0b      	ldr	r3, [pc, #44]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e3c8:	681b      	ldr	r3, [r3, #0]
  20e3ca:	4413      	add	r3, r2
  20e3cc:	4a09      	ldr	r2, [pc, #36]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e3ce:	6013      	str	r3, [r2, #0]
			iH++;
  20e3d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e3d2:	3301      	adds	r3, #1
  20e3d4:	64bb      	str	r3, [r7, #72]	; 0x48
		}while(movableFontsBuffer_pos + fontHeight*winWidth < LCD_MOVABLE_FONTS_BUFF_SIZE);
  20e3d6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e3d8:	68fa      	ldr	r2, [r7, #12]
  20e3da:	fb02 f203 	mul.w	r2, r2, r3
  20e3de:	4b05      	ldr	r3, [pc, #20]	; (20e3f4 <LCD_StrChangeColorRotWin+0x29c>)
  20e3e0:	681b      	ldr	r3, [r3, #0]
  20e3e2:	4413      	add	r3, r2
  20e3e4:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20e3e8:	f6ff af22 	blt.w	20e230 <LCD_StrChangeColorRotWin+0xd8>
  20e3ec:	e009      	b.n	20e402 <LCD_StrChangeColorRotWin+0x2aa>
  20e3ee:	bf00      	nop
  20e3f0:	20003474 	.word	0x20003474
  20e3f4:	2000347c 	.word	0x2000347c
  20e3f8:	ff000080 	.word	0xff000080
  20e3fc:	c067f800 	.word	0xc067f800
			if(i==0) break;
  20e400:	bf00      	nop

		int winHeight = fontHeight*iH;
  20e402:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  20e404:	6cba      	ldr	r2, [r7, #72]	; 0x48
  20e406:	fb02 f303 	mul.w	r3, r2, r3
  20e40a:	623b      	str	r3, [r7, #32]
		LCD_CopyBuff2pLcd(rot,movableFontsBuffer_pos_copy, movableFontsBuffer, winWidth,winHeight, 0, winWidth, Xpos,Ypos,0);
  20e40c:	6b3d      	ldr	r5, [r7, #48]	; 0x30
  20e40e:	68fe      	ldr	r6, [r7, #12]
  20e410:	6a3b      	ldr	r3, [r7, #32]
  20e412:	68fa      	ldr	r2, [r7, #12]
  20e414:	b292      	uxth	r2, r2
  20e416:	6f39      	ldr	r1, [r7, #112]	; 0x70
  20e418:	b289      	uxth	r1, r1
  20e41a:	6f78      	ldr	r0, [r7, #116]	; 0x74
  20e41c:	b280      	uxth	r0, r0
  20e41e:	2400      	movs	r4, #0
  20e420:	9405      	str	r4, [sp, #20]
  20e422:	9004      	str	r0, [sp, #16]
  20e424:	9103      	str	r1, [sp, #12]
  20e426:	9202      	str	r2, [sp, #8]
  20e428:	2200      	movs	r2, #0
  20e42a:	9201      	str	r2, [sp, #4]
  20e42c:	9300      	str	r3, [sp, #0]
  20e42e:	4633      	mov	r3, r6
  20e430:	4a13      	ldr	r2, [pc, #76]	; (20e480 <LCD_StrChangeColorRotWin+0x328>)
  20e432:	4629      	mov	r1, r5
  20e434:	6938      	ldr	r0, [r7, #16]
  20e436:	f7f9 fb87 	bl	207b48 <LCD_CopyBuff2pLcd>

		temp.inChar=0;
  20e43a:	2300      	movs	r3, #0
  20e43c:	833b      	strh	r3, [r7, #24]
		temp.inPixel=winWidth;
  20e43e:	68fb      	ldr	r3, [r7, #12]
  20e440:	b29b      	uxth	r3, r3
  20e442:	837b      	strh	r3, [r7, #26]
		temp.height=winHeight;
  20e444:	6a3b      	ldr	r3, [r7, #32]
  20e446:	b29b      	uxth	r3, r3
  20e448:	83bb      	strh	r3, [r7, #28]
		if(rot>Rotate_0)
  20e44a:	693b      	ldr	r3, [r7, #16]
  20e44c:	2b00      	cmp	r3, #0
  20e44e:	dd09      	ble.n	20e464 <LCD_StrChangeColorRotWin+0x30c>
			SwapUint16(&temp.inPixel,&temp.height);
  20e450:	f107 0318 	add.w	r3, r7, #24
  20e454:	1d1a      	adds	r2, r3, #4
  20e456:	f107 0318 	add.w	r3, r7, #24
  20e45a:	3302      	adds	r3, #2
  20e45c:	4611      	mov	r1, r2
  20e45e:	4618      	mov	r0, r3
  20e460:	f7f3 fb66 	bl	201b30 <SwapUint16>
		return temp;
  20e464:	697b      	ldr	r3, [r7, #20]
  20e466:	461a      	mov	r2, r3
  20e468:	f107 0318 	add.w	r3, r7, #24
  20e46c:	6818      	ldr	r0, [r3, #0]
  20e46e:	6010      	str	r0, [r2, #0]
  20e470:	889b      	ldrh	r3, [r3, #4]
  20e472:	8093      	strh	r3, [r2, #4]
  20e474:	46d5      	mov	sp, sl
}
  20e476:	6978      	ldr	r0, [r7, #20]
  20e478:	3750      	adds	r7, #80	; 0x50
  20e47a:	46bd      	mov	sp, r7
  20e47c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20e480:	c067f800 	.word	0xc067f800

0020e484 <LCD_StrMovH>:

StructTxtPxlLen LCD_StrMovH(int idVar, int rot, int posWin, int winWidth ,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth)
{
  20e484:	b5f0      	push	{r4, r5, r6, r7, lr}
  20e486:	b097      	sub	sp, #92	; 0x5c
  20e488:	af0a      	add	r7, sp, #40	; 0x28
  20e48a:	6178      	str	r0, [r7, #20]
  20e48c:	6139      	str	r1, [r7, #16]
  20e48e:	60fa      	str	r2, [r7, #12]
  20e490:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;
	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  20e492:	693b      	ldr	r3, [r7, #16]
  20e494:	2b27      	cmp	r3, #39	; 0x27
  20e496:	f300 824a 	bgt.w	20e92e <LCD_StrMovH+0x4aa>
	{
		int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20e49a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20e49c:	f113 0f03 	cmn.w	r3, #3
  20e4a0:	d104      	bne.n	20e4ac <LCD_StrMovH+0x28>
  20e4a2:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20e4a4:	f003 ffa6 	bl	2123f4 <LCD_GetFontHeight>
  20e4a8:	4603      	mov	r3, r0
  20e4aa:	e003      	b.n	20e4b4 <LCD_StrMovH+0x30>
  20e4ac:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20e4ae:	f003 ffdd 	bl	21246c <LCD_GetFontHalfHeight>
  20e4b2:	4603      	mov	r3, r0
  20e4b4:	62fb      	str	r3, [r7, #44]	; 0x2c
		if(fontHeight<0)
  20e4b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20e4b8:	2b00      	cmp	r3, #0
  20e4ba:	da06      	bge.n	20e4ca <LCD_StrMovH+0x46>
			return StructTxtPxlLen_ZeroValue;
  20e4bc:	697b      	ldr	r3, [r7, #20]
  20e4be:	4a9e      	ldr	r2, [pc, #632]	; (20e738 <LCD_StrMovH+0x2b4>)
  20e4c0:	6810      	ldr	r0, [r2, #0]
  20e4c2:	6018      	str	r0, [r3, #0]
  20e4c4:	8892      	ldrh	r2, [r2, #4]
  20e4c6:	809a      	strh	r2, [r3, #4]
  20e4c8:	e237      	b.n	20e93a <LCD_StrMovH+0x4b6>
		int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20e4ca:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20e4cc:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20e4ce:	6db9      	ldr	r1, [r7, #88]	; 0x58
  20e4d0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20e4d2:	f003 fdfb 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20e4d6:	62b8      	str	r0, [r7, #40]	; 0x28

		int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20e4d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20e4da:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20e4dc:	fb02 f203 	mul.w	r2, r2, r3
  20e4e0:	4b96      	ldr	r3, [pc, #600]	; (20e73c <LCD_StrMovH+0x2b8>)
  20e4e2:	681b      	ldr	r3, [r3, #0]
  20e4e4:	4413      	add	r3, r2
  20e4e6:	627b      	str	r3, [r7, #36]	; 0x24
		if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20e4e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e4ea:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20e4ee:	db06      	blt.n	20e4fe <LCD_StrMovH+0x7a>
			return StructTxtPxlLen_ZeroValue;
  20e4f0:	697b      	ldr	r3, [r7, #20]
  20e4f2:	4a91      	ldr	r2, [pc, #580]	; (20e738 <LCD_StrMovH+0x2b4>)
  20e4f4:	6810      	ldr	r0, [r2, #0]
  20e4f6:	6018      	str	r0, [r3, #0]
  20e4f8:	8892      	ldrh	r2, [r2, #4]
  20e4fa:	809a      	strh	r2, [r3, #4]
  20e4fc:	e21d      	b.n	20e93a <LCD_StrMovH+0x4b6>

		FontVar[idVar].id=fontID;
  20e4fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20e500:	b298      	uxth	r0, r3
  20e502:	498f      	ldr	r1, [pc, #572]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e504:	693a      	ldr	r2, [r7, #16]
  20e506:	4613      	mov	r3, r2
  20e508:	011b      	lsls	r3, r3, #4
  20e50a:	1a9b      	subs	r3, r3, r2
  20e50c:	009b      	lsls	r3, r3, #2
  20e50e:	440b      	add	r3, r1
  20e510:	4602      	mov	r2, r0
  20e512:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].xPos=Xpos;
  20e514:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20e516:	b298      	uxth	r0, r3
  20e518:	4989      	ldr	r1, [pc, #548]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e51a:	693a      	ldr	r2, [r7, #16]
  20e51c:	4613      	mov	r3, r2
  20e51e:	011b      	lsls	r3, r3, #4
  20e520:	1a9b      	subs	r3, r3, r2
  20e522:	009b      	lsls	r3, r3, #2
  20e524:	440b      	add	r3, r1
  20e526:	3302      	adds	r3, #2
  20e528:	4602      	mov	r2, r0
  20e52a:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos=Ypos;
  20e52c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20e52e:	b298      	uxth	r0, r3
  20e530:	4983      	ldr	r1, [pc, #524]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e532:	693a      	ldr	r2, [r7, #16]
  20e534:	4613      	mov	r3, r2
  20e536:	011b      	lsls	r3, r3, #4
  20e538:	1a9b      	subs	r3, r3, r2
  20e53a:	009b      	lsls	r3, r3, #2
  20e53c:	440b      	add	r3, r1
  20e53e:	3304      	adds	r3, #4
  20e540:	4602      	mov	r2, r0
  20e542:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightType=OnlyDigits;
  20e544:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20e546:	b258      	sxtb	r0, r3
  20e548:	497d      	ldr	r1, [pc, #500]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e54a:	693a      	ldr	r2, [r7, #16]
  20e54c:	4613      	mov	r3, r2
  20e54e:	011b      	lsls	r3, r3, #4
  20e550:	1a9b      	subs	r3, r3, r2
  20e552:	009b      	lsls	r3, r3, #2
  20e554:	440b      	add	r3, r1
  20e556:	3306      	adds	r3, #6
  20e558:	4602      	mov	r2, r0
  20e55a:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].space=space;
  20e55c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20e55e:	b2d8      	uxtb	r0, r3
  20e560:	4977      	ldr	r1, [pc, #476]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e562:	693a      	ldr	r2, [r7, #16]
  20e564:	4613      	mov	r3, r2
  20e566:	011b      	lsls	r3, r3, #4
  20e568:	1a9b      	subs	r3, r3, r2
  20e56a:	009b      	lsls	r3, r3, #2
  20e56c:	440b      	add	r3, r1
  20e56e:	3307      	adds	r3, #7
  20e570:	4602      	mov	r2, r0
  20e572:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].bkColor=bkColor;
  20e574:	4972      	ldr	r1, [pc, #456]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e576:	693a      	ldr	r2, [r7, #16]
  20e578:	4613      	mov	r3, r2
  20e57a:	011b      	lsls	r3, r3, #4
  20e57c:	1a9b      	subs	r3, r3, r2
  20e57e:	009b      	lsls	r3, r3, #2
  20e580:	440b      	add	r3, r1
  20e582:	3308      	adds	r3, #8
  20e584:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e586:	601a      	str	r2, [r3, #0]
		FontVar[idVar].coeff=coeff;
  20e588:	496d      	ldr	r1, [pc, #436]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e58a:	693a      	ldr	r2, [r7, #16]
  20e58c:	4613      	mov	r3, r2
  20e58e:	011b      	lsls	r3, r3, #4
  20e590:	1a9b      	subs	r3, r3, r2
  20e592:	009b      	lsls	r3, r3, #2
  20e594:	440b      	add	r3, r1
  20e596:	3318      	adds	r3, #24
  20e598:	6eba      	ldr	r2, [r7, #104]	; 0x68
  20e59a:	601a      	str	r2, [r3, #0]
		FontVar[idVar].widthType=constWidth;
  20e59c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20e59e:	b2d8      	uxtb	r0, r3
  20e5a0:	4967      	ldr	r1, [pc, #412]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e5a2:	693a      	ldr	r2, [r7, #16]
  20e5a4:	4613      	mov	r3, r2
  20e5a6:	011b      	lsls	r3, r3, #4
  20e5a8:	1a9b      	subs	r3, r3, r2
  20e5aa:	009b      	lsls	r3, r3, #2
  20e5ac:	440b      	add	r3, r1
  20e5ae:	331c      	adds	r3, #28
  20e5b0:	4602      	mov	r2, r0
  20e5b2:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].rotate=rot;
  20e5b4:	68fb      	ldr	r3, [r7, #12]
  20e5b6:	b2d8      	uxtb	r0, r3
  20e5b8:	4961      	ldr	r1, [pc, #388]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e5ba:	693a      	ldr	r2, [r7, #16]
  20e5bc:	4613      	mov	r3, r2
  20e5be:	011b      	lsls	r3, r3, #4
  20e5c0:	1a9b      	subs	r3, r3, r2
  20e5c2:	009b      	lsls	r3, r3, #2
  20e5c4:	440b      	add	r3, r1
  20e5c6:	3314      	adds	r3, #20
  20e5c8:	4602      	mov	r2, r0
  20e5ca:	701a      	strb	r2, [r3, #0]

		FontVar[idVar].FontMov.xImgWidth=pxlTxtLen;
  20e5cc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20e5ce:	b298      	uxth	r0, r3
  20e5d0:	495b      	ldr	r1, [pc, #364]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e5d2:	693a      	ldr	r2, [r7, #16]
  20e5d4:	4613      	mov	r3, r2
  20e5d6:	011b      	lsls	r3, r3, #4
  20e5d8:	1a9b      	subs	r3, r3, r2
  20e5da:	009b      	lsls	r3, r3, #2
  20e5dc:	440b      	add	r3, r1
  20e5de:	332c      	adds	r3, #44	; 0x2c
  20e5e0:	4602      	mov	r2, r0
  20e5e2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.yImgHeight=fontHeight;
  20e5e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20e5e6:	b298      	uxth	r0, r3
  20e5e8:	4955      	ldr	r1, [pc, #340]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e5ea:	693a      	ldr	r2, [r7, #16]
  20e5ec:	4613      	mov	r3, r2
  20e5ee:	011b      	lsls	r3, r3, #4
  20e5f0:	1a9b      	subs	r3, r3, r2
  20e5f2:	009b      	lsls	r3, r3, #2
  20e5f4:	440b      	add	r3, r1
  20e5f6:	332e      	adds	r3, #46	; 0x2e
  20e5f8:	4602      	mov	r2, r0
  20e5fa:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posWin=posWin;
  20e5fc:	68bb      	ldr	r3, [r7, #8]
  20e5fe:	b298      	uxth	r0, r3
  20e600:	494f      	ldr	r1, [pc, #316]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e602:	693a      	ldr	r2, [r7, #16]
  20e604:	4613      	mov	r3, r2
  20e606:	011b      	lsls	r3, r3, #4
  20e608:	1a9b      	subs	r3, r3, r2
  20e60a:	009b      	lsls	r3, r3, #2
  20e60c:	440b      	add	r3, r1
  20e60e:	3330      	adds	r3, #48	; 0x30
  20e610:	4602      	mov	r2, r0
  20e612:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.windowWidth=winWidth;
  20e614:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e616:	b298      	uxth	r0, r3
  20e618:	4949      	ldr	r1, [pc, #292]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e61a:	693a      	ldr	r2, [r7, #16]
  20e61c:	4613      	mov	r3, r2
  20e61e:	011b      	lsls	r3, r3, #4
  20e620:	1a9b      	subs	r3, r3, r2
  20e622:	009b      	lsls	r3, r3, #2
  20e624:	440b      	add	r3, r1
  20e626:	3332      	adds	r3, #50	; 0x32
  20e628:	4602      	mov	r2, r0
  20e62a:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.spaceEndStart=winWidth/3;
  20e62c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e62e:	4a45      	ldr	r2, [pc, #276]	; (20e744 <LCD_StrMovH+0x2c0>)
  20e630:	fb82 1203 	smull	r1, r2, r2, r3
  20e634:	17db      	asrs	r3, r3, #31
  20e636:	1ad3      	subs	r3, r2, r3
  20e638:	b298      	uxth	r0, r3
  20e63a:	4941      	ldr	r1, [pc, #260]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e63c:	693a      	ldr	r2, [r7, #16]
  20e63e:	4613      	mov	r3, r2
  20e640:	011b      	lsls	r3, r3, #4
  20e642:	1a9b      	subs	r3, r3, r2
  20e644:	009b      	lsls	r3, r3, #2
  20e646:	440b      	add	r3, r1
  20e648:	3338      	adds	r3, #56	; 0x38
  20e64a:	4602      	mov	r2, r0
  20e64c:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posBuff=movableFontsBuffer_pos;
  20e64e:	4b3b      	ldr	r3, [pc, #236]	; (20e73c <LCD_StrMovH+0x2b8>)
  20e650:	681b      	ldr	r3, [r3, #0]
  20e652:	4618      	mov	r0, r3
  20e654:	493a      	ldr	r1, [pc, #232]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e656:	693a      	ldr	r2, [r7, #16]
  20e658:	4613      	mov	r3, r2
  20e65a:	011b      	lsls	r3, r3, #4
  20e65c:	1a9b      	subs	r3, r3, r2
  20e65e:	009b      	lsls	r3, r3, #2
  20e660:	440b      	add	r3, r1
  20e662:	3328      	adds	r3, #40	; 0x28
  20e664:	6018      	str	r0, [r3, #0]
		movableFontsBuffer_pos = posMovBuff_copy;
  20e666:	4a35      	ldr	r2, [pc, #212]	; (20e73c <LCD_StrMovH+0x2b8>)
  20e668:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e66a:	6013      	str	r3, [r2, #0]

		temp=LCD_DrawStr(FontVar[idVar].FontMov.posBuff, FontVar[idVar].FontMov.xImgWidth, FontVar[idVar].FontMov.yImgHeight, fontID,0,0,txt,movableFontsBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  20e66c:	4934      	ldr	r1, [pc, #208]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e66e:	693a      	ldr	r2, [r7, #16]
  20e670:	4613      	mov	r3, r2
  20e672:	011b      	lsls	r3, r3, #4
  20e674:	1a9b      	subs	r3, r3, r2
  20e676:	009b      	lsls	r3, r3, #2
  20e678:	440b      	add	r3, r1
  20e67a:	3328      	adds	r3, #40	; 0x28
  20e67c:	681c      	ldr	r4, [r3, #0]
  20e67e:	4930      	ldr	r1, [pc, #192]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e680:	693a      	ldr	r2, [r7, #16]
  20e682:	4613      	mov	r3, r2
  20e684:	011b      	lsls	r3, r3, #4
  20e686:	1a9b      	subs	r3, r3, r2
  20e688:	009b      	lsls	r3, r3, #2
  20e68a:	440b      	add	r3, r1
  20e68c:	332c      	adds	r3, #44	; 0x2c
  20e68e:	881b      	ldrh	r3, [r3, #0]
  20e690:	461d      	mov	r5, r3
  20e692:	492b      	ldr	r1, [pc, #172]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e694:	693a      	ldr	r2, [r7, #16]
  20e696:	4613      	mov	r3, r2
  20e698:	011b      	lsls	r3, r3, #4
  20e69a:	1a9b      	subs	r3, r3, r2
  20e69c:	009b      	lsls	r3, r3, #2
  20e69e:	440b      	add	r3, r1
  20e6a0:	332e      	adds	r3, #46	; 0x2e
  20e6a2:	881b      	ldrh	r3, [r3, #0]
  20e6a4:	461a      	mov	r2, r3
  20e6a6:	4638      	mov	r0, r7
  20e6a8:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20e6aa:	9309      	str	r3, [sp, #36]	; 0x24
  20e6ac:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20e6ae:	9308      	str	r3, [sp, #32]
  20e6b0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20e6b2:	9307      	str	r3, [sp, #28]
  20e6b4:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20e6b6:	9306      	str	r3, [sp, #24]
  20e6b8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20e6ba:	9305      	str	r3, [sp, #20]
  20e6bc:	4b22      	ldr	r3, [pc, #136]	; (20e748 <LCD_StrMovH+0x2c4>)
  20e6be:	9304      	str	r3, [sp, #16]
  20e6c0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20e6c2:	9303      	str	r3, [sp, #12]
  20e6c4:	2300      	movs	r3, #0
  20e6c6:	9302      	str	r3, [sp, #8]
  20e6c8:	2300      	movs	r3, #0
  20e6ca:	9301      	str	r3, [sp, #4]
  20e6cc:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20e6ce:	9300      	str	r3, [sp, #0]
  20e6d0:	4613      	mov	r3, r2
  20e6d2:	462a      	mov	r2, r5
  20e6d4:	4621      	mov	r1, r4
  20e6d6:	f7fb ffa1 	bl	20a61c <LCD_DrawStr>
  20e6da:	f107 0318 	add.w	r3, r7, #24
  20e6de:	463a      	mov	r2, r7
  20e6e0:	6810      	ldr	r0, [r2, #0]
  20e6e2:	6018      	str	r0, [r3, #0]
  20e6e4:	8892      	ldrh	r2, [r2, #4]
  20e6e6:	809a      	strh	r2, [r3, #4]
		int diffWidth=winWidth-temp.inPixel;
  20e6e8:	8b7b      	ldrh	r3, [r7, #26]
  20e6ea:	461a      	mov	r2, r3
  20e6ec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e6ee:	1a9b      	subs	r3, r3, r2
  20e6f0:	623b      	str	r3, [r7, #32]
		LCD_CopyBuff2pLcd(rot,FontVar[idVar].FontMov.posBuff, movableFontsBuffer, FontVar[idVar].FontMov.xImgWidth, FontVar[idVar].FontMov.yImgHeight, posWin, diffWidth>0?temp.inPixel:winWidth, Xpos,Ypos,diffWidth>0?diffWidth:0);
  20e6f2:	4913      	ldr	r1, [pc, #76]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e6f4:	693a      	ldr	r2, [r7, #16]
  20e6f6:	4613      	mov	r3, r2
  20e6f8:	011b      	lsls	r3, r3, #4
  20e6fa:	1a9b      	subs	r3, r3, r2
  20e6fc:	009b      	lsls	r3, r3, #2
  20e6fe:	440b      	add	r3, r1
  20e700:	3328      	adds	r3, #40	; 0x28
  20e702:	681c      	ldr	r4, [r3, #0]
  20e704:	490e      	ldr	r1, [pc, #56]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e706:	693a      	ldr	r2, [r7, #16]
  20e708:	4613      	mov	r3, r2
  20e70a:	011b      	lsls	r3, r3, #4
  20e70c:	1a9b      	subs	r3, r3, r2
  20e70e:	009b      	lsls	r3, r3, #2
  20e710:	440b      	add	r3, r1
  20e712:	332c      	adds	r3, #44	; 0x2c
  20e714:	881b      	ldrh	r3, [r3, #0]
  20e716:	461e      	mov	r6, r3
  20e718:	4909      	ldr	r1, [pc, #36]	; (20e740 <LCD_StrMovH+0x2bc>)
  20e71a:	693a      	ldr	r2, [r7, #16]
  20e71c:	4613      	mov	r3, r2
  20e71e:	011b      	lsls	r3, r3, #4
  20e720:	1a9b      	subs	r3, r3, r2
  20e722:	009b      	lsls	r3, r3, #2
  20e724:	440b      	add	r3, r1
  20e726:	332e      	adds	r3, #46	; 0x2e
  20e728:	881b      	ldrh	r3, [r3, #0]
  20e72a:	461d      	mov	r5, r3
  20e72c:	6a3b      	ldr	r3, [r7, #32]
  20e72e:	2b00      	cmp	r3, #0
  20e730:	dd0c      	ble.n	20e74c <LCD_StrMovH+0x2c8>
  20e732:	8b7b      	ldrh	r3, [r7, #26]
  20e734:	e00c      	b.n	20e750 <LCD_StrMovH+0x2cc>
  20e736:	bf00      	nop
  20e738:	20003474 	.word	0x20003474
  20e73c:	2000347c 	.word	0x2000347c
  20e740:	2000f818 	.word	0x2000f818
  20e744:	55555556 	.word	0x55555556
  20e748:	c067f800 	.word	0xc067f800
  20e74c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e74e:	b29b      	uxth	r3, r3
  20e750:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20e752:	b292      	uxth	r2, r2
  20e754:	6d79      	ldr	r1, [r7, #84]	; 0x54
  20e756:	b289      	uxth	r1, r1
  20e758:	6a38      	ldr	r0, [r7, #32]
  20e75a:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  20e75e:	9005      	str	r0, [sp, #20]
  20e760:	9104      	str	r1, [sp, #16]
  20e762:	9203      	str	r2, [sp, #12]
  20e764:	9302      	str	r3, [sp, #8]
  20e766:	68bb      	ldr	r3, [r7, #8]
  20e768:	9301      	str	r3, [sp, #4]
  20e76a:	9500      	str	r5, [sp, #0]
  20e76c:	4633      	mov	r3, r6
  20e76e:	4a75      	ldr	r2, [pc, #468]	; (20e944 <LCD_StrMovH+0x4c0>)
  20e770:	4621      	mov	r1, r4
  20e772:	68f8      	ldr	r0, [r7, #12]
  20e774:	f7f9 f9e8 	bl	207b48 <LCD_CopyBuff2pLcd>

		FontVar[idVar].FontMov.pxlTxtLen=temp.inPixel;
  20e778:	8b78      	ldrh	r0, [r7, #26]
  20e77a:	4973      	ldr	r1, [pc, #460]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e77c:	693a      	ldr	r2, [r7, #16]
  20e77e:	4613      	mov	r3, r2
  20e780:	011b      	lsls	r3, r3, #4
  20e782:	1a9b      	subs	r3, r3, r2
  20e784:	009b      	lsls	r3, r3, #2
  20e786:	440b      	add	r3, r1
  20e788:	3336      	adds	r3, #54	; 0x36
  20e78a:	4602      	mov	r2, r0
  20e78c:	801a      	strh	r2, [r3, #0]
		if(diffWidth>0)
  20e78e:	6a3b      	ldr	r3, [r7, #32]
  20e790:	2b00      	cmp	r3, #0
  20e792:	dd7a      	ble.n	20e88a <LCD_StrMovH+0x406>
		{	switch(rot)
  20e794:	68fb      	ldr	r3, [r7, #12]
  20e796:	2b01      	cmp	r3, #1
  20e798:	d02b      	beq.n	20e7f2 <LCD_StrMovH+0x36e>
  20e79a:	2b02      	cmp	r3, #2
  20e79c:	d051      	beq.n	20e842 <LCD_StrMovH+0x3be>
  20e79e:	2b00      	cmp	r3, #0
  20e7a0:	d173      	bne.n	20e88a <LCD_StrMovH+0x406>
			{
			case Rotate_0:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos+temp.inPixel,Ypos, diffWidth, FontVar[idVar].FontMov.yImgHeight, bkColor,bkColor,bkColor);
  20e7a2:	f7f9 f901 	bl	2079a8 <LCD_GetXSize>
  20e7a6:	4606      	mov	r6, r0
  20e7a8:	f7f9 f912 	bl	2079d0 <LCD_GetYSize>
  20e7ac:	4686      	mov	lr, r0
  20e7ae:	8b7b      	ldrh	r3, [r7, #26]
  20e7b0:	461a      	mov	r2, r3
  20e7b2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20e7b4:	4413      	add	r3, r2
  20e7b6:	461d      	mov	r5, r3
  20e7b8:	6d79      	ldr	r1, [r7, #84]	; 0x54
  20e7ba:	6a38      	ldr	r0, [r7, #32]
  20e7bc:	4c62      	ldr	r4, [pc, #392]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e7be:	693a      	ldr	r2, [r7, #16]
  20e7c0:	4613      	mov	r3, r2
  20e7c2:	011b      	lsls	r3, r3, #4
  20e7c4:	1a9b      	subs	r3, r3, r2
  20e7c6:	009b      	lsls	r3, r3, #2
  20e7c8:	4423      	add	r3, r4
  20e7ca:	332e      	adds	r3, #46	; 0x2e
  20e7cc:	881b      	ldrh	r3, [r3, #0]
  20e7ce:	461a      	mov	r2, r3
  20e7d0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20e7d2:	9306      	str	r3, [sp, #24]
  20e7d4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20e7d6:	9305      	str	r3, [sp, #20]
  20e7d8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20e7da:	9304      	str	r3, [sp, #16]
  20e7dc:	9203      	str	r2, [sp, #12]
  20e7de:	9002      	str	r0, [sp, #8]
  20e7e0:	9101      	str	r1, [sp, #4]
  20e7e2:	9500      	str	r5, [sp, #0]
  20e7e4:	4673      	mov	r3, lr
  20e7e6:	4632      	mov	r2, r6
  20e7e8:	2100      	movs	r1, #0
  20e7ea:	4858      	ldr	r0, [pc, #352]	; (20e94c <LCD_StrMovH+0x4c8>)
  20e7ec:	f7f9 fbe6 	bl	207fbc <LCD_RectangleBuff>
				break;
  20e7f0:	e04b      	b.n	20e88a <LCD_StrMovH+0x406>
			case Rotate_90:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos+temp.inPixel, FontVar[idVar].FontMov.yImgHeight,diffWidth, bkColor,bkColor,bkColor);
  20e7f2:	f7f9 f8d9 	bl	2079a8 <LCD_GetXSize>
  20e7f6:	4605      	mov	r5, r0
  20e7f8:	f7f9 f8ea 	bl	2079d0 <LCD_GetYSize>
  20e7fc:	4606      	mov	r6, r0
  20e7fe:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20e800:	8b7b      	ldrh	r3, [r7, #26]
  20e802:	461a      	mov	r2, r3
  20e804:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20e806:	4413      	add	r3, r2
  20e808:	461c      	mov	r4, r3
  20e80a:	484f      	ldr	r0, [pc, #316]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e80c:	693a      	ldr	r2, [r7, #16]
  20e80e:	4613      	mov	r3, r2
  20e810:	011b      	lsls	r3, r3, #4
  20e812:	1a9b      	subs	r3, r3, r2
  20e814:	009b      	lsls	r3, r3, #2
  20e816:	4403      	add	r3, r0
  20e818:	332e      	adds	r3, #46	; 0x2e
  20e81a:	881b      	ldrh	r3, [r3, #0]
  20e81c:	4618      	mov	r0, r3
  20e81e:	6a3b      	ldr	r3, [r7, #32]
  20e820:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e822:	9206      	str	r2, [sp, #24]
  20e824:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e826:	9205      	str	r2, [sp, #20]
  20e828:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e82a:	9204      	str	r2, [sp, #16]
  20e82c:	9303      	str	r3, [sp, #12]
  20e82e:	9002      	str	r0, [sp, #8]
  20e830:	9401      	str	r4, [sp, #4]
  20e832:	9100      	str	r1, [sp, #0]
  20e834:	4633      	mov	r3, r6
  20e836:	462a      	mov	r2, r5
  20e838:	2100      	movs	r1, #0
  20e83a:	4844      	ldr	r0, [pc, #272]	; (20e94c <LCD_StrMovH+0x4c8>)
  20e83c:	f7f9 fbbe 	bl	207fbc <LCD_RectangleBuff>
				break;
  20e840:	e023      	b.n	20e88a <LCD_StrMovH+0x406>
			case Rotate_180:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos, FontVar[idVar].FontMov.yImgHeight,diffWidth, bkColor,bkColor,bkColor);
  20e842:	f7f9 f8b1 	bl	2079a8 <LCD_GetXSize>
  20e846:	4605      	mov	r5, r0
  20e848:	f7f9 f8c2 	bl	2079d0 <LCD_GetYSize>
  20e84c:	4606      	mov	r6, r0
  20e84e:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20e850:	6d78      	ldr	r0, [r7, #84]	; 0x54
  20e852:	4c3d      	ldr	r4, [pc, #244]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e854:	693a      	ldr	r2, [r7, #16]
  20e856:	4613      	mov	r3, r2
  20e858:	011b      	lsls	r3, r3, #4
  20e85a:	1a9b      	subs	r3, r3, r2
  20e85c:	009b      	lsls	r3, r3, #2
  20e85e:	4423      	add	r3, r4
  20e860:	332e      	adds	r3, #46	; 0x2e
  20e862:	881b      	ldrh	r3, [r3, #0]
  20e864:	461c      	mov	r4, r3
  20e866:	6a3b      	ldr	r3, [r7, #32]
  20e868:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e86a:	9206      	str	r2, [sp, #24]
  20e86c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e86e:	9205      	str	r2, [sp, #20]
  20e870:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20e872:	9204      	str	r2, [sp, #16]
  20e874:	9303      	str	r3, [sp, #12]
  20e876:	9402      	str	r4, [sp, #8]
  20e878:	9001      	str	r0, [sp, #4]
  20e87a:	9100      	str	r1, [sp, #0]
  20e87c:	4633      	mov	r3, r6
  20e87e:	462a      	mov	r2, r5
  20e880:	2100      	movs	r1, #0
  20e882:	4832      	ldr	r0, [pc, #200]	; (20e94c <LCD_StrMovH+0x4c8>)
  20e884:	f7f9 fb9a 	bl	207fbc <LCD_RectangleBuff>
				break;
  20e888:	bf00      	nop
			}
		}
		FontVar[idVar].xPos_prev = Xpos;
  20e88a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20e88c:	b298      	uxth	r0, r3
  20e88e:	492e      	ldr	r1, [pc, #184]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e890:	693a      	ldr	r2, [r7, #16]
  20e892:	4613      	mov	r3, r2
  20e894:	011b      	lsls	r3, r3, #4
  20e896:	1a9b      	subs	r3, r3, r2
  20e898:	009b      	lsls	r3, r3, #2
  20e89a:	440b      	add	r3, r1
  20e89c:	331e      	adds	r3, #30
  20e89e:	4602      	mov	r2, r0
  20e8a0:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos_prev = Ypos;
  20e8a2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20e8a4:	b298      	uxth	r0, r3
  20e8a6:	4928      	ldr	r1, [pc, #160]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e8a8:	693a      	ldr	r2, [r7, #16]
  20e8aa:	4613      	mov	r3, r2
  20e8ac:	011b      	lsls	r3, r3, #4
  20e8ae:	1a9b      	subs	r3, r3, r2
  20e8b0:	009b      	lsls	r3, r3, #2
  20e8b2:	440b      	add	r3, r1
  20e8b4:	3320      	adds	r3, #32
  20e8b6:	4602      	mov	r2, r0
  20e8b8:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].widthPxl_prev = winWidth;
  20e8ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e8bc:	b298      	uxth	r0, r3
  20e8be:	4922      	ldr	r1, [pc, #136]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e8c0:	693a      	ldr	r2, [r7, #16]
  20e8c2:	4613      	mov	r3, r2
  20e8c4:	011b      	lsls	r3, r3, #4
  20e8c6:	1a9b      	subs	r3, r3, r2
  20e8c8:	009b      	lsls	r3, r3, #2
  20e8ca:	440b      	add	r3, r1
  20e8cc:	3322      	adds	r3, #34	; 0x22
  20e8ce:	4602      	mov	r2, r0
  20e8d0:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightPxl_prev = FontVar[idVar].FontMov.yImgHeight;
  20e8d2:	491d      	ldr	r1, [pc, #116]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e8d4:	693a      	ldr	r2, [r7, #16]
  20e8d6:	4613      	mov	r3, r2
  20e8d8:	011b      	lsls	r3, r3, #4
  20e8da:	1a9b      	subs	r3, r3, r2
  20e8dc:	009b      	lsls	r3, r3, #2
  20e8de:	440b      	add	r3, r1
  20e8e0:	332e      	adds	r3, #46	; 0x2e
  20e8e2:	8818      	ldrh	r0, [r3, #0]
  20e8e4:	4918      	ldr	r1, [pc, #96]	; (20e948 <LCD_StrMovH+0x4c4>)
  20e8e6:	693a      	ldr	r2, [r7, #16]
  20e8e8:	4613      	mov	r3, r2
  20e8ea:	011b      	lsls	r3, r3, #4
  20e8ec:	1a9b      	subs	r3, r3, r2
  20e8ee:	009b      	lsls	r3, r3, #2
  20e8f0:	440b      	add	r3, r1
  20e8f2:	3324      	adds	r3, #36	; 0x24
  20e8f4:	4602      	mov	r2, r0
  20e8f6:	801a      	strh	r2, [r3, #0]

		temp.inChar=0;
  20e8f8:	2300      	movs	r3, #0
  20e8fa:	833b      	strh	r3, [r7, #24]
		temp.inPixel=winWidth;
  20e8fc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20e8fe:	b29b      	uxth	r3, r3
  20e900:	837b      	strh	r3, [r7, #26]
		if(rot>Rotate_0)
  20e902:	68fb      	ldr	r3, [r7, #12]
  20e904:	2b00      	cmp	r3, #0
  20e906:	dd09      	ble.n	20e91c <LCD_StrMovH+0x498>
			SwapUint16(&temp.inPixel,&temp.height);
  20e908:	f107 0318 	add.w	r3, r7, #24
  20e90c:	1d1a      	adds	r2, r3, #4
  20e90e:	f107 0318 	add.w	r3, r7, #24
  20e912:	3302      	adds	r3, #2
  20e914:	4611      	mov	r1, r2
  20e916:	4618      	mov	r0, r3
  20e918:	f7f3 f90a 	bl	201b30 <SwapUint16>
		return temp;
  20e91c:	697b      	ldr	r3, [r7, #20]
  20e91e:	461a      	mov	r2, r3
  20e920:	f107 0318 	add.w	r3, r7, #24
  20e924:	6818      	ldr	r0, [r3, #0]
  20e926:	6010      	str	r0, [r2, #0]
  20e928:	889b      	ldrh	r3, [r3, #4]
  20e92a:	8093      	strh	r3, [r2, #4]
  20e92c:	e005      	b.n	20e93a <LCD_StrMovH+0x4b6>
	}
	else return StructTxtPxlLen_ZeroValue;
  20e92e:	697b      	ldr	r3, [r7, #20]
  20e930:	4a07      	ldr	r2, [pc, #28]	; (20e950 <LCD_StrMovH+0x4cc>)
  20e932:	6810      	ldr	r0, [r2, #0]
  20e934:	6018      	str	r0, [r3, #0]
  20e936:	8892      	ldrh	r2, [r2, #4]
  20e938:	809a      	strh	r2, [r3, #4]
}
  20e93a:	6978      	ldr	r0, [r7, #20]
  20e93c:	3734      	adds	r7, #52	; 0x34
  20e93e:	46bd      	mov	sp, r7
  20e940:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20e942:	bf00      	nop
  20e944:	c067f800 	.word	0xc067f800
  20e948:	2000f818 	.word	0x2000f818
  20e94c:	c0000000 	.word	0xc0000000
  20e950:	20003474 	.word	0x20003474

0020e954 <LCD_StrChangeColorMovH>:

StructTxtPxlLen LCD_StrChangeColorMovH(int idVar, int rot, int posWin, int winWidth ,int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, int maxVal, int constWidth)
{
  20e954:	b5f0      	push	{r4, r5, r6, r7, lr}
  20e956:	b099      	sub	sp, #100	; 0x64
  20e958:	af0c      	add	r7, sp, #48	; 0x30
  20e95a:	6178      	str	r0, [r7, #20]
  20e95c:	6139      	str	r1, [r7, #16]
  20e95e:	60fa      	str	r2, [r7, #12]
  20e960:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;
	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  20e962:	693b      	ldr	r3, [r7, #16]
  20e964:	2b27      	cmp	r3, #39	; 0x27
  20e966:	f300 824c 	bgt.w	20ee02 <LCD_StrChangeColorMovH+0x4ae>
	{
		int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  20e96a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20e96c:	f113 0f03 	cmn.w	r3, #3
  20e970:	d104      	bne.n	20e97c <LCD_StrChangeColorMovH+0x28>
  20e972:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20e974:	f003 fd3e 	bl	2123f4 <LCD_GetFontHeight>
  20e978:	4603      	mov	r3, r0
  20e97a:	e003      	b.n	20e984 <LCD_StrChangeColorMovH+0x30>
  20e97c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20e97e:	f003 fd75 	bl	21246c <LCD_GetFontHalfHeight>
  20e982:	4603      	mov	r3, r0
  20e984:	62fb      	str	r3, [r7, #44]	; 0x2c
		if(fontHeight<0)
  20e986:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20e988:	2b00      	cmp	r3, #0
  20e98a:	da06      	bge.n	20e99a <LCD_StrChangeColorMovH+0x46>
			return StructTxtPxlLen_ZeroValue;
  20e98c:	697b      	ldr	r3, [r7, #20]
  20e98e:	4a9f      	ldr	r2, [pc, #636]	; (20ec0c <LCD_StrChangeColorMovH+0x2b8>)
  20e990:	6810      	ldr	r0, [r2, #0]
  20e992:	6018      	str	r0, [r3, #0]
  20e994:	8892      	ldrh	r2, [r2, #4]
  20e996:	809a      	strh	r2, [r3, #4]
  20e998:	e239      	b.n	20ee0e <LCD_StrChangeColorMovH+0x4ba>
		int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  20e99a:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  20e99c:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  20e99e:	6db9      	ldr	r1, [r7, #88]	; 0x58
  20e9a0:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
  20e9a2:	f003 fb93 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  20e9a6:	62b8      	str	r0, [r7, #40]	; 0x28

		int posMovBuff_copy = movableFontsBuffer_pos + fontHeight * pxlTxtLen;
  20e9a8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20e9aa:	6aba      	ldr	r2, [r7, #40]	; 0x28
  20e9ac:	fb02 f203 	mul.w	r2, r2, r3
  20e9b0:	4b97      	ldr	r3, [pc, #604]	; (20ec10 <LCD_StrChangeColorMovH+0x2bc>)
  20e9b2:	681b      	ldr	r3, [r3, #0]
  20e9b4:	4413      	add	r3, r2
  20e9b6:	627b      	str	r3, [r7, #36]	; 0x24
		if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  20e9b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20e9ba:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  20e9be:	db06      	blt.n	20e9ce <LCD_StrChangeColorMovH+0x7a>
			return StructTxtPxlLen_ZeroValue;
  20e9c0:	697b      	ldr	r3, [r7, #20]
  20e9c2:	4a92      	ldr	r2, [pc, #584]	; (20ec0c <LCD_StrChangeColorMovH+0x2b8>)
  20e9c4:	6810      	ldr	r0, [r2, #0]
  20e9c6:	6018      	str	r0, [r3, #0]
  20e9c8:	8892      	ldrh	r2, [r2, #4]
  20e9ca:	809a      	strh	r2, [r3, #4]
  20e9cc:	e21f      	b.n	20ee0e <LCD_StrChangeColorMovH+0x4ba>

		FontVar[idVar].id=fontID;
  20e9ce:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20e9d0:	b298      	uxth	r0, r3
  20e9d2:	4990      	ldr	r1, [pc, #576]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20e9d4:	693a      	ldr	r2, [r7, #16]
  20e9d6:	4613      	mov	r3, r2
  20e9d8:	011b      	lsls	r3, r3, #4
  20e9da:	1a9b      	subs	r3, r3, r2
  20e9dc:	009b      	lsls	r3, r3, #2
  20e9de:	440b      	add	r3, r1
  20e9e0:	4602      	mov	r2, r0
  20e9e2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].xPos=Xpos;
  20e9e4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20e9e6:	b298      	uxth	r0, r3
  20e9e8:	498a      	ldr	r1, [pc, #552]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20e9ea:	693a      	ldr	r2, [r7, #16]
  20e9ec:	4613      	mov	r3, r2
  20e9ee:	011b      	lsls	r3, r3, #4
  20e9f0:	1a9b      	subs	r3, r3, r2
  20e9f2:	009b      	lsls	r3, r3, #2
  20e9f4:	440b      	add	r3, r1
  20e9f6:	3302      	adds	r3, #2
  20e9f8:	4602      	mov	r2, r0
  20e9fa:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos=Ypos;
  20e9fc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20e9fe:	b298      	uxth	r0, r3
  20ea00:	4984      	ldr	r1, [pc, #528]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea02:	693a      	ldr	r2, [r7, #16]
  20ea04:	4613      	mov	r3, r2
  20ea06:	011b      	lsls	r3, r3, #4
  20ea08:	1a9b      	subs	r3, r3, r2
  20ea0a:	009b      	lsls	r3, r3, #2
  20ea0c:	440b      	add	r3, r1
  20ea0e:	3304      	adds	r3, #4
  20ea10:	4602      	mov	r2, r0
  20ea12:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightType=OnlyDigits;
  20ea14:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20ea16:	b258      	sxtb	r0, r3
  20ea18:	497e      	ldr	r1, [pc, #504]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea1a:	693a      	ldr	r2, [r7, #16]
  20ea1c:	4613      	mov	r3, r2
  20ea1e:	011b      	lsls	r3, r3, #4
  20ea20:	1a9b      	subs	r3, r3, r2
  20ea22:	009b      	lsls	r3, r3, #2
  20ea24:	440b      	add	r3, r1
  20ea26:	3306      	adds	r3, #6
  20ea28:	4602      	mov	r2, r0
  20ea2a:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].space=space;
  20ea2c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20ea2e:	b2d8      	uxtb	r0, r3
  20ea30:	4978      	ldr	r1, [pc, #480]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea32:	693a      	ldr	r2, [r7, #16]
  20ea34:	4613      	mov	r3, r2
  20ea36:	011b      	lsls	r3, r3, #4
  20ea38:	1a9b      	subs	r3, r3, r2
  20ea3a:	009b      	lsls	r3, r3, #2
  20ea3c:	440b      	add	r3, r1
  20ea3e:	3307      	adds	r3, #7
  20ea40:	4602      	mov	r2, r0
  20ea42:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].bkColor=bkColor;
  20ea44:	4973      	ldr	r1, [pc, #460]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea46:	693a      	ldr	r2, [r7, #16]
  20ea48:	4613      	mov	r3, r2
  20ea4a:	011b      	lsls	r3, r3, #4
  20ea4c:	1a9b      	subs	r3, r3, r2
  20ea4e:	009b      	lsls	r3, r3, #2
  20ea50:	440b      	add	r3, r1
  20ea52:	3308      	adds	r3, #8
  20ea54:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ea56:	601a      	str	r2, [r3, #0]
		FontVar[idVar].coeff=maxVal;
  20ea58:	496e      	ldr	r1, [pc, #440]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea5a:	693a      	ldr	r2, [r7, #16]
  20ea5c:	4613      	mov	r3, r2
  20ea5e:	011b      	lsls	r3, r3, #4
  20ea60:	1a9b      	subs	r3, r3, r2
  20ea62:	009b      	lsls	r3, r3, #2
  20ea64:	440b      	add	r3, r1
  20ea66:	3318      	adds	r3, #24
  20ea68:	6efa      	ldr	r2, [r7, #108]	; 0x6c
  20ea6a:	601a      	str	r2, [r3, #0]
		FontVar[idVar].widthType=constWidth;
  20ea6c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  20ea6e:	b2d8      	uxtb	r0, r3
  20ea70:	4968      	ldr	r1, [pc, #416]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea72:	693a      	ldr	r2, [r7, #16]
  20ea74:	4613      	mov	r3, r2
  20ea76:	011b      	lsls	r3, r3, #4
  20ea78:	1a9b      	subs	r3, r3, r2
  20ea7a:	009b      	lsls	r3, r3, #2
  20ea7c:	440b      	add	r3, r1
  20ea7e:	331c      	adds	r3, #28
  20ea80:	4602      	mov	r2, r0
  20ea82:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].rotate=rot;
  20ea84:	68fb      	ldr	r3, [r7, #12]
  20ea86:	b2d8      	uxtb	r0, r3
  20ea88:	4962      	ldr	r1, [pc, #392]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ea8a:	693a      	ldr	r2, [r7, #16]
  20ea8c:	4613      	mov	r3, r2
  20ea8e:	011b      	lsls	r3, r3, #4
  20ea90:	1a9b      	subs	r3, r3, r2
  20ea92:	009b      	lsls	r3, r3, #2
  20ea94:	440b      	add	r3, r1
  20ea96:	3314      	adds	r3, #20
  20ea98:	4602      	mov	r2, r0
  20ea9a:	701a      	strb	r2, [r3, #0]

		FontVar[idVar].FontMov.xImgWidth=pxlTxtLen;
  20ea9c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  20ea9e:	b298      	uxth	r0, r3
  20eaa0:	495c      	ldr	r1, [pc, #368]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eaa2:	693a      	ldr	r2, [r7, #16]
  20eaa4:	4613      	mov	r3, r2
  20eaa6:	011b      	lsls	r3, r3, #4
  20eaa8:	1a9b      	subs	r3, r3, r2
  20eaaa:	009b      	lsls	r3, r3, #2
  20eaac:	440b      	add	r3, r1
  20eaae:	332c      	adds	r3, #44	; 0x2c
  20eab0:	4602      	mov	r2, r0
  20eab2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.yImgHeight=fontHeight;
  20eab4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  20eab6:	b298      	uxth	r0, r3
  20eab8:	4956      	ldr	r1, [pc, #344]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eaba:	693a      	ldr	r2, [r7, #16]
  20eabc:	4613      	mov	r3, r2
  20eabe:	011b      	lsls	r3, r3, #4
  20eac0:	1a9b      	subs	r3, r3, r2
  20eac2:	009b      	lsls	r3, r3, #2
  20eac4:	440b      	add	r3, r1
  20eac6:	332e      	adds	r3, #46	; 0x2e
  20eac8:	4602      	mov	r2, r0
  20eaca:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posWin=posWin;
  20eacc:	68bb      	ldr	r3, [r7, #8]
  20eace:	b298      	uxth	r0, r3
  20ead0:	4950      	ldr	r1, [pc, #320]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ead2:	693a      	ldr	r2, [r7, #16]
  20ead4:	4613      	mov	r3, r2
  20ead6:	011b      	lsls	r3, r3, #4
  20ead8:	1a9b      	subs	r3, r3, r2
  20eada:	009b      	lsls	r3, r3, #2
  20eadc:	440b      	add	r3, r1
  20eade:	3330      	adds	r3, #48	; 0x30
  20eae0:	4602      	mov	r2, r0
  20eae2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.windowWidth=winWidth;
  20eae4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20eae6:	b298      	uxth	r0, r3
  20eae8:	494a      	ldr	r1, [pc, #296]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eaea:	693a      	ldr	r2, [r7, #16]
  20eaec:	4613      	mov	r3, r2
  20eaee:	011b      	lsls	r3, r3, #4
  20eaf0:	1a9b      	subs	r3, r3, r2
  20eaf2:	009b      	lsls	r3, r3, #2
  20eaf4:	440b      	add	r3, r1
  20eaf6:	3332      	adds	r3, #50	; 0x32
  20eaf8:	4602      	mov	r2, r0
  20eafa:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.spaceEndStart=winWidth/3;
  20eafc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20eafe:	4a46      	ldr	r2, [pc, #280]	; (20ec18 <LCD_StrChangeColorMovH+0x2c4>)
  20eb00:	fb82 1203 	smull	r1, r2, r2, r3
  20eb04:	17db      	asrs	r3, r3, #31
  20eb06:	1ad3      	subs	r3, r2, r3
  20eb08:	b298      	uxth	r0, r3
  20eb0a:	4942      	ldr	r1, [pc, #264]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eb0c:	693a      	ldr	r2, [r7, #16]
  20eb0e:	4613      	mov	r3, r2
  20eb10:	011b      	lsls	r3, r3, #4
  20eb12:	1a9b      	subs	r3, r3, r2
  20eb14:	009b      	lsls	r3, r3, #2
  20eb16:	440b      	add	r3, r1
  20eb18:	3338      	adds	r3, #56	; 0x38
  20eb1a:	4602      	mov	r2, r0
  20eb1c:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posBuff=movableFontsBuffer_pos;
  20eb1e:	4b3c      	ldr	r3, [pc, #240]	; (20ec10 <LCD_StrChangeColorMovH+0x2bc>)
  20eb20:	681b      	ldr	r3, [r3, #0]
  20eb22:	4618      	mov	r0, r3
  20eb24:	493b      	ldr	r1, [pc, #236]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eb26:	693a      	ldr	r2, [r7, #16]
  20eb28:	4613      	mov	r3, r2
  20eb2a:	011b      	lsls	r3, r3, #4
  20eb2c:	1a9b      	subs	r3, r3, r2
  20eb2e:	009b      	lsls	r3, r3, #2
  20eb30:	440b      	add	r3, r1
  20eb32:	3328      	adds	r3, #40	; 0x28
  20eb34:	6018      	str	r0, [r3, #0]
		movableFontsBuffer_pos = posMovBuff_copy;
  20eb36:	4a36      	ldr	r2, [pc, #216]	; (20ec10 <LCD_StrChangeColorMovH+0x2bc>)
  20eb38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20eb3a:	6013      	str	r3, [r2, #0]

		temp=LCD_DrawStrChangeColor(FontVar[idVar].FontMov.posBuff, FontVar[idVar].FontMov.xImgWidth, FontVar[idVar].FontMov.yImgHeight, fontID,0,0,txt,movableFontsBuffer,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  20eb3c:	4935      	ldr	r1, [pc, #212]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eb3e:	693a      	ldr	r2, [r7, #16]
  20eb40:	4613      	mov	r3, r2
  20eb42:	011b      	lsls	r3, r3, #4
  20eb44:	1a9b      	subs	r3, r3, r2
  20eb46:	009b      	lsls	r3, r3, #2
  20eb48:	440b      	add	r3, r1
  20eb4a:	3328      	adds	r3, #40	; 0x28
  20eb4c:	681c      	ldr	r4, [r3, #0]
  20eb4e:	4931      	ldr	r1, [pc, #196]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eb50:	693a      	ldr	r2, [r7, #16]
  20eb52:	4613      	mov	r3, r2
  20eb54:	011b      	lsls	r3, r3, #4
  20eb56:	1a9b      	subs	r3, r3, r2
  20eb58:	009b      	lsls	r3, r3, #2
  20eb5a:	440b      	add	r3, r1
  20eb5c:	332c      	adds	r3, #44	; 0x2c
  20eb5e:	881b      	ldrh	r3, [r3, #0]
  20eb60:	461d      	mov	r5, r3
  20eb62:	492c      	ldr	r1, [pc, #176]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20eb64:	693a      	ldr	r2, [r7, #16]
  20eb66:	4613      	mov	r3, r2
  20eb68:	011b      	lsls	r3, r3, #4
  20eb6a:	1a9b      	subs	r3, r3, r2
  20eb6c:	009b      	lsls	r3, r3, #2
  20eb6e:	440b      	add	r3, r1
  20eb70:	332e      	adds	r3, #46	; 0x2e
  20eb72:	881b      	ldrh	r3, [r3, #0]
  20eb74:	4619      	mov	r1, r3
  20eb76:	6efb      	ldr	r3, [r7, #108]	; 0x6c
  20eb78:	b2db      	uxtb	r3, r3
  20eb7a:	4638      	mov	r0, r7
  20eb7c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
  20eb7e:	920a      	str	r2, [sp, #40]	; 0x28
  20eb80:	9309      	str	r3, [sp, #36]	; 0x24
  20eb82:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  20eb84:	9308      	str	r3, [sp, #32]
  20eb86:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20eb88:	9307      	str	r3, [sp, #28]
  20eb8a:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  20eb8c:	9306      	str	r3, [sp, #24]
  20eb8e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  20eb90:	9305      	str	r3, [sp, #20]
  20eb92:	4b22      	ldr	r3, [pc, #136]	; (20ec1c <LCD_StrChangeColorMovH+0x2c8>)
  20eb94:	9304      	str	r3, [sp, #16]
  20eb96:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  20eb98:	9303      	str	r3, [sp, #12]
  20eb9a:	2300      	movs	r3, #0
  20eb9c:	9302      	str	r3, [sp, #8]
  20eb9e:	2300      	movs	r3, #0
  20eba0:	9301      	str	r3, [sp, #4]
  20eba2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  20eba4:	9300      	str	r3, [sp, #0]
  20eba6:	460b      	mov	r3, r1
  20eba8:	462a      	mov	r2, r5
  20ebaa:	4621      	mov	r1, r4
  20ebac:	f7fb fd9c 	bl	20a6e8 <LCD_DrawStrChangeColor>
  20ebb0:	f107 0318 	add.w	r3, r7, #24
  20ebb4:	463a      	mov	r2, r7
  20ebb6:	6810      	ldr	r0, [r2, #0]
  20ebb8:	6018      	str	r0, [r3, #0]
  20ebba:	8892      	ldrh	r2, [r2, #4]
  20ebbc:	809a      	strh	r2, [r3, #4]
		int diffWidth=winWidth-temp.inPixel;
  20ebbe:	8b7b      	ldrh	r3, [r7, #26]
  20ebc0:	461a      	mov	r2, r3
  20ebc2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20ebc4:	1a9b      	subs	r3, r3, r2
  20ebc6:	623b      	str	r3, [r7, #32]
		LCD_CopyBuff2pLcd(rot,FontVar[idVar].FontMov.posBuff, movableFontsBuffer, FontVar[idVar].FontMov.xImgWidth, FontVar[idVar].FontMov.yImgHeight, posWin, diffWidth>0?temp.inPixel:winWidth, Xpos,Ypos,diffWidth>0?diffWidth:0);
  20ebc8:	4912      	ldr	r1, [pc, #72]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ebca:	693a      	ldr	r2, [r7, #16]
  20ebcc:	4613      	mov	r3, r2
  20ebce:	011b      	lsls	r3, r3, #4
  20ebd0:	1a9b      	subs	r3, r3, r2
  20ebd2:	009b      	lsls	r3, r3, #2
  20ebd4:	440b      	add	r3, r1
  20ebd6:	3328      	adds	r3, #40	; 0x28
  20ebd8:	681c      	ldr	r4, [r3, #0]
  20ebda:	490e      	ldr	r1, [pc, #56]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ebdc:	693a      	ldr	r2, [r7, #16]
  20ebde:	4613      	mov	r3, r2
  20ebe0:	011b      	lsls	r3, r3, #4
  20ebe2:	1a9b      	subs	r3, r3, r2
  20ebe4:	009b      	lsls	r3, r3, #2
  20ebe6:	440b      	add	r3, r1
  20ebe8:	332c      	adds	r3, #44	; 0x2c
  20ebea:	881b      	ldrh	r3, [r3, #0]
  20ebec:	461e      	mov	r6, r3
  20ebee:	4909      	ldr	r1, [pc, #36]	; (20ec14 <LCD_StrChangeColorMovH+0x2c0>)
  20ebf0:	693a      	ldr	r2, [r7, #16]
  20ebf2:	4613      	mov	r3, r2
  20ebf4:	011b      	lsls	r3, r3, #4
  20ebf6:	1a9b      	subs	r3, r3, r2
  20ebf8:	009b      	lsls	r3, r3, #2
  20ebfa:	440b      	add	r3, r1
  20ebfc:	332e      	adds	r3, #46	; 0x2e
  20ebfe:	881b      	ldrh	r3, [r3, #0]
  20ec00:	461d      	mov	r5, r3
  20ec02:	6a3b      	ldr	r3, [r7, #32]
  20ec04:	2b00      	cmp	r3, #0
  20ec06:	dd0b      	ble.n	20ec20 <LCD_StrChangeColorMovH+0x2cc>
  20ec08:	8b7b      	ldrh	r3, [r7, #26]
  20ec0a:	e00b      	b.n	20ec24 <LCD_StrChangeColorMovH+0x2d0>
  20ec0c:	20003474 	.word	0x20003474
  20ec10:	2000347c 	.word	0x2000347c
  20ec14:	2000f818 	.word	0x2000f818
  20ec18:	55555556 	.word	0x55555556
  20ec1c:	c067f800 	.word	0xc067f800
  20ec20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20ec22:	b29b      	uxth	r3, r3
  20ec24:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  20ec26:	b292      	uxth	r2, r2
  20ec28:	6d79      	ldr	r1, [r7, #84]	; 0x54
  20ec2a:	b289      	uxth	r1, r1
  20ec2c:	6a38      	ldr	r0, [r7, #32]
  20ec2e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  20ec32:	9005      	str	r0, [sp, #20]
  20ec34:	9104      	str	r1, [sp, #16]
  20ec36:	9203      	str	r2, [sp, #12]
  20ec38:	9302      	str	r3, [sp, #8]
  20ec3a:	68bb      	ldr	r3, [r7, #8]
  20ec3c:	9301      	str	r3, [sp, #4]
  20ec3e:	9500      	str	r5, [sp, #0]
  20ec40:	4633      	mov	r3, r6
  20ec42:	4a75      	ldr	r2, [pc, #468]	; (20ee18 <LCD_StrChangeColorMovH+0x4c4>)
  20ec44:	4621      	mov	r1, r4
  20ec46:	68f8      	ldr	r0, [r7, #12]
  20ec48:	f7f8 ff7e 	bl	207b48 <LCD_CopyBuff2pLcd>

		FontVar[idVar].FontMov.pxlTxtLen=temp.inPixel;
  20ec4c:	8b78      	ldrh	r0, [r7, #26]
  20ec4e:	4973      	ldr	r1, [pc, #460]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ec50:	693a      	ldr	r2, [r7, #16]
  20ec52:	4613      	mov	r3, r2
  20ec54:	011b      	lsls	r3, r3, #4
  20ec56:	1a9b      	subs	r3, r3, r2
  20ec58:	009b      	lsls	r3, r3, #2
  20ec5a:	440b      	add	r3, r1
  20ec5c:	3336      	adds	r3, #54	; 0x36
  20ec5e:	4602      	mov	r2, r0
  20ec60:	801a      	strh	r2, [r3, #0]
		if(diffWidth>0)
  20ec62:	6a3b      	ldr	r3, [r7, #32]
  20ec64:	2b00      	cmp	r3, #0
  20ec66:	dd7a      	ble.n	20ed5e <LCD_StrChangeColorMovH+0x40a>
		{	switch(rot)
  20ec68:	68fb      	ldr	r3, [r7, #12]
  20ec6a:	2b01      	cmp	r3, #1
  20ec6c:	d02b      	beq.n	20ecc6 <LCD_StrChangeColorMovH+0x372>
  20ec6e:	2b02      	cmp	r3, #2
  20ec70:	d051      	beq.n	20ed16 <LCD_StrChangeColorMovH+0x3c2>
  20ec72:	2b00      	cmp	r3, #0
  20ec74:	d173      	bne.n	20ed5e <LCD_StrChangeColorMovH+0x40a>
			{
			case Rotate_0:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos+temp.inPixel,Ypos, diffWidth, FontVar[idVar].FontMov.yImgHeight, bkColor,bkColor,bkColor);
  20ec76:	f7f8 fe97 	bl	2079a8 <LCD_GetXSize>
  20ec7a:	4606      	mov	r6, r0
  20ec7c:	f7f8 fea8 	bl	2079d0 <LCD_GetYSize>
  20ec80:	4686      	mov	lr, r0
  20ec82:	8b7b      	ldrh	r3, [r7, #26]
  20ec84:	461a      	mov	r2, r3
  20ec86:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20ec88:	4413      	add	r3, r2
  20ec8a:	461d      	mov	r5, r3
  20ec8c:	6d79      	ldr	r1, [r7, #84]	; 0x54
  20ec8e:	6a38      	ldr	r0, [r7, #32]
  20ec90:	4c62      	ldr	r4, [pc, #392]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ec92:	693a      	ldr	r2, [r7, #16]
  20ec94:	4613      	mov	r3, r2
  20ec96:	011b      	lsls	r3, r3, #4
  20ec98:	1a9b      	subs	r3, r3, r2
  20ec9a:	009b      	lsls	r3, r3, #2
  20ec9c:	4423      	add	r3, r4
  20ec9e:	332e      	adds	r3, #46	; 0x2e
  20eca0:	881b      	ldrh	r3, [r3, #0]
  20eca2:	461a      	mov	r2, r3
  20eca4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20eca6:	9306      	str	r3, [sp, #24]
  20eca8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20ecaa:	9305      	str	r3, [sp, #20]
  20ecac:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  20ecae:	9304      	str	r3, [sp, #16]
  20ecb0:	9203      	str	r2, [sp, #12]
  20ecb2:	9002      	str	r0, [sp, #8]
  20ecb4:	9101      	str	r1, [sp, #4]
  20ecb6:	9500      	str	r5, [sp, #0]
  20ecb8:	4673      	mov	r3, lr
  20ecba:	4632      	mov	r2, r6
  20ecbc:	2100      	movs	r1, #0
  20ecbe:	4858      	ldr	r0, [pc, #352]	; (20ee20 <LCD_StrChangeColorMovH+0x4cc>)
  20ecc0:	f7f9 f97c 	bl	207fbc <LCD_RectangleBuff>
				break;
  20ecc4:	e04b      	b.n	20ed5e <LCD_StrChangeColorMovH+0x40a>
			case Rotate_90:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos+temp.inPixel, FontVar[idVar].FontMov.yImgHeight,diffWidth, bkColor,bkColor,bkColor);
  20ecc6:	f7f8 fe6f 	bl	2079a8 <LCD_GetXSize>
  20ecca:	4605      	mov	r5, r0
  20eccc:	f7f8 fe80 	bl	2079d0 <LCD_GetYSize>
  20ecd0:	4606      	mov	r6, r0
  20ecd2:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20ecd4:	8b7b      	ldrh	r3, [r7, #26]
  20ecd6:	461a      	mov	r2, r3
  20ecd8:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20ecda:	4413      	add	r3, r2
  20ecdc:	461c      	mov	r4, r3
  20ecde:	484f      	ldr	r0, [pc, #316]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ece0:	693a      	ldr	r2, [r7, #16]
  20ece2:	4613      	mov	r3, r2
  20ece4:	011b      	lsls	r3, r3, #4
  20ece6:	1a9b      	subs	r3, r3, r2
  20ece8:	009b      	lsls	r3, r3, #2
  20ecea:	4403      	add	r3, r0
  20ecec:	332e      	adds	r3, #46	; 0x2e
  20ecee:	881b      	ldrh	r3, [r3, #0]
  20ecf0:	4618      	mov	r0, r3
  20ecf2:	6a3b      	ldr	r3, [r7, #32]
  20ecf4:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ecf6:	9206      	str	r2, [sp, #24]
  20ecf8:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ecfa:	9205      	str	r2, [sp, #20]
  20ecfc:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ecfe:	9204      	str	r2, [sp, #16]
  20ed00:	9303      	str	r3, [sp, #12]
  20ed02:	9002      	str	r0, [sp, #8]
  20ed04:	9401      	str	r4, [sp, #4]
  20ed06:	9100      	str	r1, [sp, #0]
  20ed08:	4633      	mov	r3, r6
  20ed0a:	462a      	mov	r2, r5
  20ed0c:	2100      	movs	r1, #0
  20ed0e:	4844      	ldr	r0, [pc, #272]	; (20ee20 <LCD_StrChangeColorMovH+0x4cc>)
  20ed10:	f7f9 f954 	bl	207fbc <LCD_RectangleBuff>
				break;
  20ed14:	e023      	b.n	20ed5e <LCD_StrChangeColorMovH+0x40a>
			case Rotate_180:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos, FontVar[idVar].FontMov.yImgHeight,diffWidth, bkColor,bkColor,bkColor);
  20ed16:	f7f8 fe47 	bl	2079a8 <LCD_GetXSize>
  20ed1a:	4605      	mov	r5, r0
  20ed1c:	f7f8 fe58 	bl	2079d0 <LCD_GetYSize>
  20ed20:	4606      	mov	r6, r0
  20ed22:	6d39      	ldr	r1, [r7, #80]	; 0x50
  20ed24:	6d78      	ldr	r0, [r7, #84]	; 0x54
  20ed26:	4c3d      	ldr	r4, [pc, #244]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ed28:	693a      	ldr	r2, [r7, #16]
  20ed2a:	4613      	mov	r3, r2
  20ed2c:	011b      	lsls	r3, r3, #4
  20ed2e:	1a9b      	subs	r3, r3, r2
  20ed30:	009b      	lsls	r3, r3, #2
  20ed32:	4423      	add	r3, r4
  20ed34:	332e      	adds	r3, #46	; 0x2e
  20ed36:	881b      	ldrh	r3, [r3, #0]
  20ed38:	461c      	mov	r4, r3
  20ed3a:	6a3b      	ldr	r3, [r7, #32]
  20ed3c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ed3e:	9206      	str	r2, [sp, #24]
  20ed40:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ed42:	9205      	str	r2, [sp, #20]
  20ed44:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  20ed46:	9204      	str	r2, [sp, #16]
  20ed48:	9303      	str	r3, [sp, #12]
  20ed4a:	9402      	str	r4, [sp, #8]
  20ed4c:	9001      	str	r0, [sp, #4]
  20ed4e:	9100      	str	r1, [sp, #0]
  20ed50:	4633      	mov	r3, r6
  20ed52:	462a      	mov	r2, r5
  20ed54:	2100      	movs	r1, #0
  20ed56:	4832      	ldr	r0, [pc, #200]	; (20ee20 <LCD_StrChangeColorMovH+0x4cc>)
  20ed58:	f7f9 f930 	bl	207fbc <LCD_RectangleBuff>
				break;
  20ed5c:	bf00      	nop
			}
		}
		FontVar[idVar].xPos_prev = Xpos;
  20ed5e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  20ed60:	b298      	uxth	r0, r3
  20ed62:	492e      	ldr	r1, [pc, #184]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ed64:	693a      	ldr	r2, [r7, #16]
  20ed66:	4613      	mov	r3, r2
  20ed68:	011b      	lsls	r3, r3, #4
  20ed6a:	1a9b      	subs	r3, r3, r2
  20ed6c:	009b      	lsls	r3, r3, #2
  20ed6e:	440b      	add	r3, r1
  20ed70:	331e      	adds	r3, #30
  20ed72:	4602      	mov	r2, r0
  20ed74:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos_prev = Ypos;
  20ed76:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  20ed78:	b298      	uxth	r0, r3
  20ed7a:	4928      	ldr	r1, [pc, #160]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ed7c:	693a      	ldr	r2, [r7, #16]
  20ed7e:	4613      	mov	r3, r2
  20ed80:	011b      	lsls	r3, r3, #4
  20ed82:	1a9b      	subs	r3, r3, r2
  20ed84:	009b      	lsls	r3, r3, #2
  20ed86:	440b      	add	r3, r1
  20ed88:	3320      	adds	r3, #32
  20ed8a:	4602      	mov	r2, r0
  20ed8c:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].widthPxl_prev = winWidth;
  20ed8e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20ed90:	b298      	uxth	r0, r3
  20ed92:	4922      	ldr	r1, [pc, #136]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20ed94:	693a      	ldr	r2, [r7, #16]
  20ed96:	4613      	mov	r3, r2
  20ed98:	011b      	lsls	r3, r3, #4
  20ed9a:	1a9b      	subs	r3, r3, r2
  20ed9c:	009b      	lsls	r3, r3, #2
  20ed9e:	440b      	add	r3, r1
  20eda0:	3322      	adds	r3, #34	; 0x22
  20eda2:	4602      	mov	r2, r0
  20eda4:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightPxl_prev = FontVar[idVar].FontMov.yImgHeight;
  20eda6:	491d      	ldr	r1, [pc, #116]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20eda8:	693a      	ldr	r2, [r7, #16]
  20edaa:	4613      	mov	r3, r2
  20edac:	011b      	lsls	r3, r3, #4
  20edae:	1a9b      	subs	r3, r3, r2
  20edb0:	009b      	lsls	r3, r3, #2
  20edb2:	440b      	add	r3, r1
  20edb4:	332e      	adds	r3, #46	; 0x2e
  20edb6:	8818      	ldrh	r0, [r3, #0]
  20edb8:	4918      	ldr	r1, [pc, #96]	; (20ee1c <LCD_StrChangeColorMovH+0x4c8>)
  20edba:	693a      	ldr	r2, [r7, #16]
  20edbc:	4613      	mov	r3, r2
  20edbe:	011b      	lsls	r3, r3, #4
  20edc0:	1a9b      	subs	r3, r3, r2
  20edc2:	009b      	lsls	r3, r3, #2
  20edc4:	440b      	add	r3, r1
  20edc6:	3324      	adds	r3, #36	; 0x24
  20edc8:	4602      	mov	r2, r0
  20edca:	801a      	strh	r2, [r3, #0]

		temp.inChar=0;
  20edcc:	2300      	movs	r3, #0
  20edce:	833b      	strh	r3, [r7, #24]
		temp.inPixel=winWidth;
  20edd0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  20edd2:	b29b      	uxth	r3, r3
  20edd4:	837b      	strh	r3, [r7, #26]
		if(rot>Rotate_0)
  20edd6:	68fb      	ldr	r3, [r7, #12]
  20edd8:	2b00      	cmp	r3, #0
  20edda:	dd09      	ble.n	20edf0 <LCD_StrChangeColorMovH+0x49c>
			SwapUint16(&temp.inPixel,&temp.height);
  20eddc:	f107 0318 	add.w	r3, r7, #24
  20ede0:	1d1a      	adds	r2, r3, #4
  20ede2:	f107 0318 	add.w	r3, r7, #24
  20ede6:	3302      	adds	r3, #2
  20ede8:	4611      	mov	r1, r2
  20edea:	4618      	mov	r0, r3
  20edec:	f7f2 fea0 	bl	201b30 <SwapUint16>
		return temp;
  20edf0:	697b      	ldr	r3, [r7, #20]
  20edf2:	461a      	mov	r2, r3
  20edf4:	f107 0318 	add.w	r3, r7, #24
  20edf8:	6818      	ldr	r0, [r3, #0]
  20edfa:	6010      	str	r0, [r2, #0]
  20edfc:	889b      	ldrh	r3, [r3, #4]
  20edfe:	8093      	strh	r3, [r2, #4]
  20ee00:	e005      	b.n	20ee0e <LCD_StrChangeColorMovH+0x4ba>
	}
	else return StructTxtPxlLen_ZeroValue;
  20ee02:	697b      	ldr	r3, [r7, #20]
  20ee04:	4a07      	ldr	r2, [pc, #28]	; (20ee24 <LCD_StrChangeColorMovH+0x4d0>)
  20ee06:	6810      	ldr	r0, [r2, #0]
  20ee08:	6018      	str	r0, [r3, #0]
  20ee0a:	8892      	ldrh	r2, [r2, #4]
  20ee0c:	809a      	strh	r2, [r3, #4]
}
  20ee0e:	6978      	ldr	r0, [r7, #20]
  20ee10:	3734      	adds	r7, #52	; 0x34
  20ee12:	46bd      	mov	sp, r7
  20ee14:	bdf0      	pop	{r4, r5, r6, r7, pc}
  20ee16:	bf00      	nop
  20ee18:	c067f800 	.word	0xc067f800
  20ee1c:	2000f818 	.word	0x2000f818
  20ee20:	c0000000 	.word	0xc0000000
  20ee24:	20003474 	.word	0x20003474

0020ee28 <LCD_StrMovHIndirect>:

int LCD_StrMovHIndirect(int idVar, int incrDecr)
{
  20ee28:	b5f0      	push	{r4, r5, r6, r7, lr}
  20ee2a:	b093      	sub	sp, #76	; 0x4c
  20ee2c:	af08      	add	r7, sp, #32
  20ee2e:	60f8      	str	r0, [r7, #12]
  20ee30:	60b9      	str	r1, [r7, #8]
	#define M	FontVar[idVar].FontMov
	#define F	FontVar[idVar]

	if(SearchFontIndex(FontID[F.id].size, FontID[F.id].style, FontID[F.id].bkColor, FontID[F.id].color)<0)
  20ee32:	49a8      	ldr	r1, [pc, #672]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ee34:	68fa      	ldr	r2, [r7, #12]
  20ee36:	4613      	mov	r3, r2
  20ee38:	011b      	lsls	r3, r3, #4
  20ee3a:	1a9b      	subs	r3, r3, r2
  20ee3c:	009b      	lsls	r3, r3, #2
  20ee3e:	440b      	add	r3, r1
  20ee40:	881b      	ldrh	r3, [r3, #0]
  20ee42:	4aa5      	ldr	r2, [pc, #660]	; (20f0d8 <LCD_StrMovHIndirect+0x2b0>)
  20ee44:	011b      	lsls	r3, r3, #4
  20ee46:	4413      	add	r3, r2
  20ee48:	681b      	ldr	r3, [r3, #0]
  20ee4a:	461c      	mov	r4, r3
  20ee4c:	49a1      	ldr	r1, [pc, #644]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ee4e:	68fa      	ldr	r2, [r7, #12]
  20ee50:	4613      	mov	r3, r2
  20ee52:	011b      	lsls	r3, r3, #4
  20ee54:	1a9b      	subs	r3, r3, r2
  20ee56:	009b      	lsls	r3, r3, #2
  20ee58:	440b      	add	r3, r1
  20ee5a:	881b      	ldrh	r3, [r3, #0]
  20ee5c:	4a9e      	ldr	r2, [pc, #632]	; (20f0d8 <LCD_StrMovHIndirect+0x2b0>)
  20ee5e:	011b      	lsls	r3, r3, #4
  20ee60:	4413      	add	r3, r2
  20ee62:	3304      	adds	r3, #4
  20ee64:	681b      	ldr	r3, [r3, #0]
  20ee66:	461d      	mov	r5, r3
  20ee68:	499a      	ldr	r1, [pc, #616]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ee6a:	68fa      	ldr	r2, [r7, #12]
  20ee6c:	4613      	mov	r3, r2
  20ee6e:	011b      	lsls	r3, r3, #4
  20ee70:	1a9b      	subs	r3, r3, r2
  20ee72:	009b      	lsls	r3, r3, #2
  20ee74:	440b      	add	r3, r1
  20ee76:	881b      	ldrh	r3, [r3, #0]
  20ee78:	4a97      	ldr	r2, [pc, #604]	; (20f0d8 <LCD_StrMovHIndirect+0x2b0>)
  20ee7a:	011b      	lsls	r3, r3, #4
  20ee7c:	4413      	add	r3, r2
  20ee7e:	3308      	adds	r3, #8
  20ee80:	6818      	ldr	r0, [r3, #0]
  20ee82:	4994      	ldr	r1, [pc, #592]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ee84:	68fa      	ldr	r2, [r7, #12]
  20ee86:	4613      	mov	r3, r2
  20ee88:	011b      	lsls	r3, r3, #4
  20ee8a:	1a9b      	subs	r3, r3, r2
  20ee8c:	009b      	lsls	r3, r3, #2
  20ee8e:	440b      	add	r3, r1
  20ee90:	881b      	ldrh	r3, [r3, #0]
  20ee92:	4a91      	ldr	r2, [pc, #580]	; (20f0d8 <LCD_StrMovHIndirect+0x2b0>)
  20ee94:	011b      	lsls	r3, r3, #4
  20ee96:	4413      	add	r3, r2
  20ee98:	330c      	adds	r3, #12
  20ee9a:	681b      	ldr	r3, [r3, #0]
  20ee9c:	4602      	mov	r2, r0
  20ee9e:	4629      	mov	r1, r5
  20eea0:	4620      	mov	r0, r4
  20eea2:	f7f9 fcef 	bl	208884 <SearchFontIndex>
  20eea6:	4603      	mov	r3, r0
  20eea8:	2b00      	cmp	r3, #0
  20eeaa:	da03      	bge.n	20eeb4 <LCD_StrMovHIndirect+0x8c>
		return -1;
  20eeac:	f04f 33ff 	mov.w	r3, #4294967295
  20eeb0:	f001 b8fd 	b.w	2100ae <LCD_StrMovHIndirect+0x1286>

	if(M.windowWidth>M.pxlTxtLen) return 0;
  20eeb4:	4987      	ldr	r1, [pc, #540]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20eeb6:	68fa      	ldr	r2, [r7, #12]
  20eeb8:	4613      	mov	r3, r2
  20eeba:	011b      	lsls	r3, r3, #4
  20eebc:	1a9b      	subs	r3, r3, r2
  20eebe:	009b      	lsls	r3, r3, #2
  20eec0:	440b      	add	r3, r1
  20eec2:	3332      	adds	r3, #50	; 0x32
  20eec4:	8819      	ldrh	r1, [r3, #0]
  20eec6:	4883      	ldr	r0, [pc, #524]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20eec8:	68fa      	ldr	r2, [r7, #12]
  20eeca:	4613      	mov	r3, r2
  20eecc:	011b      	lsls	r3, r3, #4
  20eece:	1a9b      	subs	r3, r3, r2
  20eed0:	009b      	lsls	r3, r3, #2
  20eed2:	4403      	add	r3, r0
  20eed4:	3336      	adds	r3, #54	; 0x36
  20eed6:	881b      	ldrh	r3, [r3, #0]
  20eed8:	4299      	cmp	r1, r3
  20eeda:	d902      	bls.n	20eee2 <LCD_StrMovHIndirect+0xba>
  20eedc:	2300      	movs	r3, #0
  20eede:	f001 b8e6 	b.w	2100ae <LCD_StrMovHIndirect+0x1286>

	if(M.posWin+incrDecr>=0)
  20eee2:	497c      	ldr	r1, [pc, #496]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20eee4:	68fa      	ldr	r2, [r7, #12]
  20eee6:	4613      	mov	r3, r2
  20eee8:	011b      	lsls	r3, r3, #4
  20eeea:	1a9b      	subs	r3, r3, r2
  20eeec:	009b      	lsls	r3, r3, #2
  20eeee:	440b      	add	r3, r1
  20eef0:	3330      	adds	r3, #48	; 0x30
  20eef2:	881b      	ldrh	r3, [r3, #0]
  20eef4:	461a      	mov	r2, r3
  20eef6:	68bb      	ldr	r3, [r7, #8]
  20eef8:	4413      	add	r3, r2
  20eefa:	2b00      	cmp	r3, #0
  20eefc:	db16      	blt.n	20ef2c <LCD_StrMovHIndirect+0x104>
		M.posWin += incrDecr;
  20eefe:	4975      	ldr	r1, [pc, #468]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef00:	68fa      	ldr	r2, [r7, #12]
  20ef02:	4613      	mov	r3, r2
  20ef04:	011b      	lsls	r3, r3, #4
  20ef06:	1a9b      	subs	r3, r3, r2
  20ef08:	009b      	lsls	r3, r3, #2
  20ef0a:	440b      	add	r3, r1
  20ef0c:	3330      	adds	r3, #48	; 0x30
  20ef0e:	881a      	ldrh	r2, [r3, #0]
  20ef10:	68bb      	ldr	r3, [r7, #8]
  20ef12:	b29b      	uxth	r3, r3
  20ef14:	4413      	add	r3, r2
  20ef16:	b298      	uxth	r0, r3
  20ef18:	496e      	ldr	r1, [pc, #440]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef1a:	68fa      	ldr	r2, [r7, #12]
  20ef1c:	4613      	mov	r3, r2
  20ef1e:	011b      	lsls	r3, r3, #4
  20ef20:	1a9b      	subs	r3, r3, r2
  20ef22:	009b      	lsls	r3, r3, #2
  20ef24:	440b      	add	r3, r1
  20ef26:	3330      	adds	r3, #48	; 0x30
  20ef28:	4602      	mov	r2, r0
  20ef2a:	801a      	strh	r2, [r3, #0]

	if(M.posWin + M.windowWidth <= M.pxlTxtLen)
  20ef2c:	4969      	ldr	r1, [pc, #420]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef2e:	68fa      	ldr	r2, [r7, #12]
  20ef30:	4613      	mov	r3, r2
  20ef32:	011b      	lsls	r3, r3, #4
  20ef34:	1a9b      	subs	r3, r3, r2
  20ef36:	009b      	lsls	r3, r3, #2
  20ef38:	440b      	add	r3, r1
  20ef3a:	3330      	adds	r3, #48	; 0x30
  20ef3c:	881b      	ldrh	r3, [r3, #0]
  20ef3e:	4618      	mov	r0, r3
  20ef40:	4964      	ldr	r1, [pc, #400]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef42:	68fa      	ldr	r2, [r7, #12]
  20ef44:	4613      	mov	r3, r2
  20ef46:	011b      	lsls	r3, r3, #4
  20ef48:	1a9b      	subs	r3, r3, r2
  20ef4a:	009b      	lsls	r3, r3, #2
  20ef4c:	440b      	add	r3, r1
  20ef4e:	3332      	adds	r3, #50	; 0x32
  20ef50:	881b      	ldrh	r3, [r3, #0]
  20ef52:	18c1      	adds	r1, r0, r3
  20ef54:	485f      	ldr	r0, [pc, #380]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef56:	68fa      	ldr	r2, [r7, #12]
  20ef58:	4613      	mov	r3, r2
  20ef5a:	011b      	lsls	r3, r3, #4
  20ef5c:	1a9b      	subs	r3, r3, r2
  20ef5e:	009b      	lsls	r3, r3, #2
  20ef60:	4403      	add	r3, r0
  20ef62:	3336      	adds	r3, #54	; 0x36
  20ef64:	881b      	ldrh	r3, [r3, #0]
  20ef66:	4299      	cmp	r1, r3
  20ef68:	f300 80bc 	bgt.w	20f0e4 <LCD_StrMovHIndirect+0x2bc>
	{	LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth, M.yImgHeight, M.posWin, M.windowWidth,0);
  20ef6c:	4959      	ldr	r1, [pc, #356]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef6e:	68fa      	ldr	r2, [r7, #12]
  20ef70:	4613      	mov	r3, r2
  20ef72:	011b      	lsls	r3, r3, #4
  20ef74:	1a9b      	subs	r3, r3, r2
  20ef76:	009b      	lsls	r3, r3, #2
  20ef78:	440b      	add	r3, r1
  20ef7a:	3314      	adds	r3, #20
  20ef7c:	781b      	ldrb	r3, [r3, #0]
  20ef7e:	461e      	mov	r6, r3
  20ef80:	4954      	ldr	r1, [pc, #336]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef82:	68fa      	ldr	r2, [r7, #12]
  20ef84:	4613      	mov	r3, r2
  20ef86:	011b      	lsls	r3, r3, #4
  20ef88:	1a9b      	subs	r3, r3, r2
  20ef8a:	009b      	lsls	r3, r3, #2
  20ef8c:	440b      	add	r3, r1
  20ef8e:	3328      	adds	r3, #40	; 0x28
  20ef90:	6818      	ldr	r0, [r3, #0]
  20ef92:	4950      	ldr	r1, [pc, #320]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20ef94:	68fa      	ldr	r2, [r7, #12]
  20ef96:	4613      	mov	r3, r2
  20ef98:	011b      	lsls	r3, r3, #4
  20ef9a:	1a9b      	subs	r3, r3, r2
  20ef9c:	009b      	lsls	r3, r3, #2
  20ef9e:	440b      	add	r3, r1
  20efa0:	332c      	adds	r3, #44	; 0x2c
  20efa2:	881b      	ldrh	r3, [r3, #0]
  20efa4:	469e      	mov	lr, r3
  20efa6:	494b      	ldr	r1, [pc, #300]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20efa8:	68fa      	ldr	r2, [r7, #12]
  20efaa:	4613      	mov	r3, r2
  20efac:	011b      	lsls	r3, r3, #4
  20efae:	1a9b      	subs	r3, r3, r2
  20efb0:	009b      	lsls	r3, r3, #2
  20efb2:	440b      	add	r3, r1
  20efb4:	332e      	adds	r3, #46	; 0x2e
  20efb6:	881b      	ldrh	r3, [r3, #0]
  20efb8:	461c      	mov	r4, r3
  20efba:	4946      	ldr	r1, [pc, #280]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20efbc:	68fa      	ldr	r2, [r7, #12]
  20efbe:	4613      	mov	r3, r2
  20efc0:	011b      	lsls	r3, r3, #4
  20efc2:	1a9b      	subs	r3, r3, r2
  20efc4:	009b      	lsls	r3, r3, #2
  20efc6:	440b      	add	r3, r1
  20efc8:	3330      	adds	r3, #48	; 0x30
  20efca:	881b      	ldrh	r3, [r3, #0]
  20efcc:	461d      	mov	r5, r3
  20efce:	4941      	ldr	r1, [pc, #260]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20efd0:	68fa      	ldr	r2, [r7, #12]
  20efd2:	4613      	mov	r3, r2
  20efd4:	011b      	lsls	r3, r3, #4
  20efd6:	1a9b      	subs	r3, r3, r2
  20efd8:	009b      	lsls	r3, r3, #2
  20efda:	440b      	add	r3, r1
  20efdc:	3332      	adds	r3, #50	; 0x32
  20efde:	881b      	ldrh	r3, [r3, #0]
  20efe0:	2200      	movs	r2, #0
  20efe2:	9203      	str	r2, [sp, #12]
  20efe4:	9302      	str	r3, [sp, #8]
  20efe6:	9501      	str	r5, [sp, #4]
  20efe8:	9400      	str	r4, [sp, #0]
  20efea:	4673      	mov	r3, lr
  20efec:	4a3b      	ldr	r2, [pc, #236]	; (20f0dc <LCD_StrMovHIndirect+0x2b4>)
  20efee:	4601      	mov	r1, r0
  20eff0:	4630      	mov	r0, r6
  20eff2:	f7f8 fe7b 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
		switch(F.rotate)
  20eff6:	4937      	ldr	r1, [pc, #220]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20eff8:	68fa      	ldr	r2, [r7, #12]
  20effa:	4613      	mov	r3, r2
  20effc:	011b      	lsls	r3, r3, #4
  20effe:	1a9b      	subs	r3, r3, r2
  20f000:	009b      	lsls	r3, r3, #2
  20f002:	440b      	add	r3, r1
  20f004:	3314      	adds	r3, #20
  20f006:	781b      	ldrb	r3, [r3, #0]
  20f008:	2b00      	cmp	r3, #0
  20f00a:	d130      	bne.n	20f06e <LCD_StrMovHIndirect+0x246>
		{	case Rotate_0:
				LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowWidth,M.yImgHeight, pLcd);
  20f00c:	4931      	ldr	r1, [pc, #196]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f00e:	68fa      	ldr	r2, [r7, #12]
  20f010:	4613      	mov	r3, r2
  20f012:	011b      	lsls	r3, r3, #4
  20f014:	1a9b      	subs	r3, r3, r2
  20f016:	009b      	lsls	r3, r3, #2
  20f018:	440b      	add	r3, r1
  20f01a:	3302      	adds	r3, #2
  20f01c:	881b      	ldrh	r3, [r3, #0]
  20f01e:	4618      	mov	r0, r3
  20f020:	492c      	ldr	r1, [pc, #176]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f022:	68fa      	ldr	r2, [r7, #12]
  20f024:	4613      	mov	r3, r2
  20f026:	011b      	lsls	r3, r3, #4
  20f028:	1a9b      	subs	r3, r3, r2
  20f02a:	009b      	lsls	r3, r3, #2
  20f02c:	440b      	add	r3, r1
  20f02e:	3304      	adds	r3, #4
  20f030:	881b      	ldrh	r3, [r3, #0]
  20f032:	461c      	mov	r4, r3
  20f034:	4927      	ldr	r1, [pc, #156]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f036:	68fa      	ldr	r2, [r7, #12]
  20f038:	4613      	mov	r3, r2
  20f03a:	011b      	lsls	r3, r3, #4
  20f03c:	1a9b      	subs	r3, r3, r2
  20f03e:	009b      	lsls	r3, r3, #2
  20f040:	440b      	add	r3, r1
  20f042:	3332      	adds	r3, #50	; 0x32
  20f044:	881b      	ldrh	r3, [r3, #0]
  20f046:	461d      	mov	r5, r3
  20f048:	4922      	ldr	r1, [pc, #136]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f04a:	68fa      	ldr	r2, [r7, #12]
  20f04c:	4613      	mov	r3, r2
  20f04e:	011b      	lsls	r3, r3, #4
  20f050:	1a9b      	subs	r3, r3, r2
  20f052:	009b      	lsls	r3, r3, #2
  20f054:	440b      	add	r3, r1
  20f056:	332e      	adds	r3, #46	; 0x2e
  20f058:	881b      	ldrh	r3, [r3, #0]
  20f05a:	461a      	mov	r2, r3
  20f05c:	4b20      	ldr	r3, [pc, #128]	; (20f0e0 <LCD_StrMovHIndirect+0x2b8>)
  20f05e:	9300      	str	r3, [sp, #0]
  20f060:	4613      	mov	r3, r2
  20f062:	462a      	mov	r2, r5
  20f064:	4621      	mov	r1, r4
  20f066:	f7f8 fd15 	bl	207a94 <LCD_DisplayBuff>
				break;
  20f06a:	f001 b81f 	b.w	2100ac <LCD_StrMovHIndirect+0x1284>
			case Rotate_90:
			case Rotate_180:
			default:
				LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.yImgHeight,M.windowWidth, pLcd);
  20f06e:	4919      	ldr	r1, [pc, #100]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f070:	68fa      	ldr	r2, [r7, #12]
  20f072:	4613      	mov	r3, r2
  20f074:	011b      	lsls	r3, r3, #4
  20f076:	1a9b      	subs	r3, r3, r2
  20f078:	009b      	lsls	r3, r3, #2
  20f07a:	440b      	add	r3, r1
  20f07c:	3302      	adds	r3, #2
  20f07e:	881b      	ldrh	r3, [r3, #0]
  20f080:	4618      	mov	r0, r3
  20f082:	4914      	ldr	r1, [pc, #80]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f084:	68fa      	ldr	r2, [r7, #12]
  20f086:	4613      	mov	r3, r2
  20f088:	011b      	lsls	r3, r3, #4
  20f08a:	1a9b      	subs	r3, r3, r2
  20f08c:	009b      	lsls	r3, r3, #2
  20f08e:	440b      	add	r3, r1
  20f090:	3304      	adds	r3, #4
  20f092:	881b      	ldrh	r3, [r3, #0]
  20f094:	461c      	mov	r4, r3
  20f096:	490f      	ldr	r1, [pc, #60]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f098:	68fa      	ldr	r2, [r7, #12]
  20f09a:	4613      	mov	r3, r2
  20f09c:	011b      	lsls	r3, r3, #4
  20f09e:	1a9b      	subs	r3, r3, r2
  20f0a0:	009b      	lsls	r3, r3, #2
  20f0a2:	440b      	add	r3, r1
  20f0a4:	332e      	adds	r3, #46	; 0x2e
  20f0a6:	881b      	ldrh	r3, [r3, #0]
  20f0a8:	461d      	mov	r5, r3
  20f0aa:	490a      	ldr	r1, [pc, #40]	; (20f0d4 <LCD_StrMovHIndirect+0x2ac>)
  20f0ac:	68fa      	ldr	r2, [r7, #12]
  20f0ae:	4613      	mov	r3, r2
  20f0b0:	011b      	lsls	r3, r3, #4
  20f0b2:	1a9b      	subs	r3, r3, r2
  20f0b4:	009b      	lsls	r3, r3, #2
  20f0b6:	440b      	add	r3, r1
  20f0b8:	3332      	adds	r3, #50	; 0x32
  20f0ba:	881b      	ldrh	r3, [r3, #0]
  20f0bc:	461a      	mov	r2, r3
  20f0be:	4b08      	ldr	r3, [pc, #32]	; (20f0e0 <LCD_StrMovHIndirect+0x2b8>)
  20f0c0:	9300      	str	r3, [sp, #0]
  20f0c2:	4613      	mov	r3, r2
  20f0c4:	462a      	mov	r2, r5
  20f0c6:	4621      	mov	r1, r4
  20f0c8:	f7f8 fce4 	bl	207a94 <LCD_DisplayBuff>
				break;
  20f0cc:	bf00      	nop
  20f0ce:	f000 bfed 	b.w	2100ac <LCD_StrMovHIndirect+0x1284>
  20f0d2:	bf00      	nop
  20f0d4:	2000f818 	.word	0x2000f818
  20f0d8:	20003480 	.word	0x20003480
  20f0dc:	c067f800 	.word	0xc067f800
  20f0e0:	c0000000 	.word	0xc0000000
		}
	}
	else
	{	int windowWidth_new = M.pxlTxtLen - M.posWin;
  20f0e4:	4998      	ldr	r1, [pc, #608]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f0e6:	68fa      	ldr	r2, [r7, #12]
  20f0e8:	4613      	mov	r3, r2
  20f0ea:	011b      	lsls	r3, r3, #4
  20f0ec:	1a9b      	subs	r3, r3, r2
  20f0ee:	009b      	lsls	r3, r3, #2
  20f0f0:	440b      	add	r3, r1
  20f0f2:	3336      	adds	r3, #54	; 0x36
  20f0f4:	881b      	ldrh	r3, [r3, #0]
  20f0f6:	4618      	mov	r0, r3
  20f0f8:	4993      	ldr	r1, [pc, #588]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f0fa:	68fa      	ldr	r2, [r7, #12]
  20f0fc:	4613      	mov	r3, r2
  20f0fe:	011b      	lsls	r3, r3, #4
  20f100:	1a9b      	subs	r3, r3, r2
  20f102:	009b      	lsls	r3, r3, #2
  20f104:	440b      	add	r3, r1
  20f106:	3330      	adds	r3, #48	; 0x30
  20f108:	881b      	ldrh	r3, [r3, #0]
  20f10a:	1ac3      	subs	r3, r0, r3
  20f10c:	627b      	str	r3, [r7, #36]	; 0x24
		int windowWidth_empty = M.posWin + M.windowWidth - M.pxlTxtLen;
  20f10e:	498e      	ldr	r1, [pc, #568]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f110:	68fa      	ldr	r2, [r7, #12]
  20f112:	4613      	mov	r3, r2
  20f114:	011b      	lsls	r3, r3, #4
  20f116:	1a9b      	subs	r3, r3, r2
  20f118:	009b      	lsls	r3, r3, #2
  20f11a:	440b      	add	r3, r1
  20f11c:	3330      	adds	r3, #48	; 0x30
  20f11e:	881b      	ldrh	r3, [r3, #0]
  20f120:	4618      	mov	r0, r3
  20f122:	4989      	ldr	r1, [pc, #548]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f124:	68fa      	ldr	r2, [r7, #12]
  20f126:	4613      	mov	r3, r2
  20f128:	011b      	lsls	r3, r3, #4
  20f12a:	1a9b      	subs	r3, r3, r2
  20f12c:	009b      	lsls	r3, r3, #2
  20f12e:	440b      	add	r3, r1
  20f130:	3332      	adds	r3, #50	; 0x32
  20f132:	881b      	ldrh	r3, [r3, #0]
  20f134:	18c1      	adds	r1, r0, r3
  20f136:	4884      	ldr	r0, [pc, #528]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f138:	68fa      	ldr	r2, [r7, #12]
  20f13a:	4613      	mov	r3, r2
  20f13c:	011b      	lsls	r3, r3, #4
  20f13e:	1a9b      	subs	r3, r3, r2
  20f140:	009b      	lsls	r3, r3, #2
  20f142:	4403      	add	r3, r0
  20f144:	3336      	adds	r3, #54	; 0x36
  20f146:	881b      	ldrh	r3, [r3, #0]
  20f148:	1acb      	subs	r3, r1, r3
  20f14a:	623b      	str	r3, [r7, #32]

		if(windowWidth_new>0)
  20f14c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f14e:	2b00      	cmp	r3, #0
  20f150:	f340 84ba 	ble.w	20fac8 <LCD_StrMovHIndirect+0xca0>
		{	LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth, M.yImgHeight, M.posWin, windowWidth_new,0);
  20f154:	497c      	ldr	r1, [pc, #496]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f156:	68fa      	ldr	r2, [r7, #12]
  20f158:	4613      	mov	r3, r2
  20f15a:	011b      	lsls	r3, r3, #4
  20f15c:	1a9b      	subs	r3, r3, r2
  20f15e:	009b      	lsls	r3, r3, #2
  20f160:	440b      	add	r3, r1
  20f162:	3314      	adds	r3, #20
  20f164:	781b      	ldrb	r3, [r3, #0]
  20f166:	461d      	mov	r5, r3
  20f168:	4977      	ldr	r1, [pc, #476]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f16a:	68fa      	ldr	r2, [r7, #12]
  20f16c:	4613      	mov	r3, r2
  20f16e:	011b      	lsls	r3, r3, #4
  20f170:	1a9b      	subs	r3, r3, r2
  20f172:	009b      	lsls	r3, r3, #2
  20f174:	440b      	add	r3, r1
  20f176:	3328      	adds	r3, #40	; 0x28
  20f178:	6818      	ldr	r0, [r3, #0]
  20f17a:	4973      	ldr	r1, [pc, #460]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f17c:	68fa      	ldr	r2, [r7, #12]
  20f17e:	4613      	mov	r3, r2
  20f180:	011b      	lsls	r3, r3, #4
  20f182:	1a9b      	subs	r3, r3, r2
  20f184:	009b      	lsls	r3, r3, #2
  20f186:	440b      	add	r3, r1
  20f188:	332c      	adds	r3, #44	; 0x2c
  20f18a:	881b      	ldrh	r3, [r3, #0]
  20f18c:	461e      	mov	r6, r3
  20f18e:	496e      	ldr	r1, [pc, #440]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f190:	68fa      	ldr	r2, [r7, #12]
  20f192:	4613      	mov	r3, r2
  20f194:	011b      	lsls	r3, r3, #4
  20f196:	1a9b      	subs	r3, r3, r2
  20f198:	009b      	lsls	r3, r3, #2
  20f19a:	440b      	add	r3, r1
  20f19c:	332e      	adds	r3, #46	; 0x2e
  20f19e:	881b      	ldrh	r3, [r3, #0]
  20f1a0:	461c      	mov	r4, r3
  20f1a2:	4969      	ldr	r1, [pc, #420]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f1a4:	68fa      	ldr	r2, [r7, #12]
  20f1a6:	4613      	mov	r3, r2
  20f1a8:	011b      	lsls	r3, r3, #4
  20f1aa:	1a9b      	subs	r3, r3, r2
  20f1ac:	009b      	lsls	r3, r3, #2
  20f1ae:	440b      	add	r3, r1
  20f1b0:	3330      	adds	r3, #48	; 0x30
  20f1b2:	881b      	ldrh	r3, [r3, #0]
  20f1b4:	4619      	mov	r1, r3
  20f1b6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f1b8:	b29b      	uxth	r3, r3
  20f1ba:	2200      	movs	r2, #0
  20f1bc:	9203      	str	r2, [sp, #12]
  20f1be:	9302      	str	r3, [sp, #8]
  20f1c0:	9101      	str	r1, [sp, #4]
  20f1c2:	9400      	str	r4, [sp, #0]
  20f1c4:	4633      	mov	r3, r6
  20f1c6:	4a61      	ldr	r2, [pc, #388]	; (20f34c <LCD_StrMovHIndirect+0x524>)
  20f1c8:	4601      	mov	r1, r0
  20f1ca:	4628      	mov	r0, r5
  20f1cc:	f7f8 fd8e 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
			switch(F.rotate)
  20f1d0:	495d      	ldr	r1, [pc, #372]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f1d2:	68fa      	ldr	r2, [r7, #12]
  20f1d4:	4613      	mov	r3, r2
  20f1d6:	011b      	lsls	r3, r3, #4
  20f1d8:	1a9b      	subs	r3, r3, r2
  20f1da:	009b      	lsls	r3, r3, #2
  20f1dc:	440b      	add	r3, r1
  20f1de:	3314      	adds	r3, #20
  20f1e0:	781b      	ldrb	r3, [r3, #0]
  20f1e2:	2b00      	cmp	r3, #0
  20f1e4:	d002      	beq.n	20f1ec <LCD_StrMovHIndirect+0x3c4>
  20f1e6:	2b01      	cmp	r3, #1
  20f1e8:	d028      	beq.n	20f23c <LCD_StrMovHIndirect+0x414>
  20f1ea:	e04e      	b.n	20f28a <LCD_StrMovHIndirect+0x462>
			{	case Rotate_0:
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, windowWidth_new, M.yImgHeight, pLcd);
  20f1ec:	4956      	ldr	r1, [pc, #344]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f1ee:	68fa      	ldr	r2, [r7, #12]
  20f1f0:	4613      	mov	r3, r2
  20f1f2:	011b      	lsls	r3, r3, #4
  20f1f4:	1a9b      	subs	r3, r3, r2
  20f1f6:	009b      	lsls	r3, r3, #2
  20f1f8:	440b      	add	r3, r1
  20f1fa:	3302      	adds	r3, #2
  20f1fc:	881b      	ldrh	r3, [r3, #0]
  20f1fe:	461c      	mov	r4, r3
  20f200:	4951      	ldr	r1, [pc, #324]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f202:	68fa      	ldr	r2, [r7, #12]
  20f204:	4613      	mov	r3, r2
  20f206:	011b      	lsls	r3, r3, #4
  20f208:	1a9b      	subs	r3, r3, r2
  20f20a:	009b      	lsls	r3, r3, #2
  20f20c:	440b      	add	r3, r1
  20f20e:	3304      	adds	r3, #4
  20f210:	881b      	ldrh	r3, [r3, #0]
  20f212:	461d      	mov	r5, r3
  20f214:	6a78      	ldr	r0, [r7, #36]	; 0x24
  20f216:	494c      	ldr	r1, [pc, #304]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f218:	68fa      	ldr	r2, [r7, #12]
  20f21a:	4613      	mov	r3, r2
  20f21c:	011b      	lsls	r3, r3, #4
  20f21e:	1a9b      	subs	r3, r3, r2
  20f220:	009b      	lsls	r3, r3, #2
  20f222:	440b      	add	r3, r1
  20f224:	332e      	adds	r3, #46	; 0x2e
  20f226:	881b      	ldrh	r3, [r3, #0]
  20f228:	461a      	mov	r2, r3
  20f22a:	4b49      	ldr	r3, [pc, #292]	; (20f350 <LCD_StrMovHIndirect+0x528>)
  20f22c:	9300      	str	r3, [sp, #0]
  20f22e:	4613      	mov	r3, r2
  20f230:	4602      	mov	r2, r0
  20f232:	4629      	mov	r1, r5
  20f234:	4620      	mov	r0, r4
  20f236:	f7f8 fc2d 	bl	207a94 <LCD_DisplayBuff>
					break;
  20f23a:	e050      	b.n	20f2de <LCD_StrMovHIndirect+0x4b6>
				case Rotate_90:
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.yImgHeight,windowWidth_new, pLcd);
  20f23c:	4942      	ldr	r1, [pc, #264]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f23e:	68fa      	ldr	r2, [r7, #12]
  20f240:	4613      	mov	r3, r2
  20f242:	011b      	lsls	r3, r3, #4
  20f244:	1a9b      	subs	r3, r3, r2
  20f246:	009b      	lsls	r3, r3, #2
  20f248:	440b      	add	r3, r1
  20f24a:	3302      	adds	r3, #2
  20f24c:	881b      	ldrh	r3, [r3, #0]
  20f24e:	4618      	mov	r0, r3
  20f250:	493d      	ldr	r1, [pc, #244]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f252:	68fa      	ldr	r2, [r7, #12]
  20f254:	4613      	mov	r3, r2
  20f256:	011b      	lsls	r3, r3, #4
  20f258:	1a9b      	subs	r3, r3, r2
  20f25a:	009b      	lsls	r3, r3, #2
  20f25c:	440b      	add	r3, r1
  20f25e:	3304      	adds	r3, #4
  20f260:	881b      	ldrh	r3, [r3, #0]
  20f262:	461c      	mov	r4, r3
  20f264:	4938      	ldr	r1, [pc, #224]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f266:	68fa      	ldr	r2, [r7, #12]
  20f268:	4613      	mov	r3, r2
  20f26a:	011b      	lsls	r3, r3, #4
  20f26c:	1a9b      	subs	r3, r3, r2
  20f26e:	009b      	lsls	r3, r3, #2
  20f270:	440b      	add	r3, r1
  20f272:	332e      	adds	r3, #46	; 0x2e
  20f274:	881b      	ldrh	r3, [r3, #0]
  20f276:	4619      	mov	r1, r3
  20f278:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  20f27a:	4b35      	ldr	r3, [pc, #212]	; (20f350 <LCD_StrMovHIndirect+0x528>)
  20f27c:	9300      	str	r3, [sp, #0]
  20f27e:	4613      	mov	r3, r2
  20f280:	460a      	mov	r2, r1
  20f282:	4621      	mov	r1, r4
  20f284:	f7f8 fc06 	bl	207a94 <LCD_DisplayBuff>
					break;
  20f288:	e029      	b.n	20f2de <LCD_StrMovHIndirect+0x4b6>
				case Rotate_180:
				default:
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos+windowWidth_empty, M.yImgHeight,windowWidth_new, pLcd);
  20f28a:	492f      	ldr	r1, [pc, #188]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f28c:	68fa      	ldr	r2, [r7, #12]
  20f28e:	4613      	mov	r3, r2
  20f290:	011b      	lsls	r3, r3, #4
  20f292:	1a9b      	subs	r3, r3, r2
  20f294:	009b      	lsls	r3, r3, #2
  20f296:	440b      	add	r3, r1
  20f298:	3302      	adds	r3, #2
  20f29a:	881b      	ldrh	r3, [r3, #0]
  20f29c:	461c      	mov	r4, r3
  20f29e:	492a      	ldr	r1, [pc, #168]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f2a0:	68fa      	ldr	r2, [r7, #12]
  20f2a2:	4613      	mov	r3, r2
  20f2a4:	011b      	lsls	r3, r3, #4
  20f2a6:	1a9b      	subs	r3, r3, r2
  20f2a8:	009b      	lsls	r3, r3, #2
  20f2aa:	440b      	add	r3, r1
  20f2ac:	3304      	adds	r3, #4
  20f2ae:	881b      	ldrh	r3, [r3, #0]
  20f2b0:	461a      	mov	r2, r3
  20f2b2:	6a3b      	ldr	r3, [r7, #32]
  20f2b4:	18d0      	adds	r0, r2, r3
  20f2b6:	4924      	ldr	r1, [pc, #144]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f2b8:	68fa      	ldr	r2, [r7, #12]
  20f2ba:	4613      	mov	r3, r2
  20f2bc:	011b      	lsls	r3, r3, #4
  20f2be:	1a9b      	subs	r3, r3, r2
  20f2c0:	009b      	lsls	r3, r3, #2
  20f2c2:	440b      	add	r3, r1
  20f2c4:	332e      	adds	r3, #46	; 0x2e
  20f2c6:	881b      	ldrh	r3, [r3, #0]
  20f2c8:	4619      	mov	r1, r3
  20f2ca:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  20f2cc:	4b20      	ldr	r3, [pc, #128]	; (20f350 <LCD_StrMovHIndirect+0x528>)
  20f2ce:	9300      	str	r3, [sp, #0]
  20f2d0:	4613      	mov	r3, r2
  20f2d2:	460a      	mov	r2, r1
  20f2d4:	4601      	mov	r1, r0
  20f2d6:	4620      	mov	r0, r4
  20f2d8:	f7f8 fbdc 	bl	207a94 <LCD_DisplayBuff>
					break;
  20f2dc:	bf00      	nop
			}

			if(windowWidth_empty>M.spaceEndStart)
  20f2de:	491a      	ldr	r1, [pc, #104]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f2e0:	68fa      	ldr	r2, [r7, #12]
  20f2e2:	4613      	mov	r3, r2
  20f2e4:	011b      	lsls	r3, r3, #4
  20f2e6:	1a9b      	subs	r3, r3, r2
  20f2e8:	009b      	lsls	r3, r3, #2
  20f2ea:	440b      	add	r3, r1
  20f2ec:	3338      	adds	r3, #56	; 0x38
  20f2ee:	881b      	ldrh	r3, [r3, #0]
  20f2f0:	461a      	mov	r2, r3
  20f2f2:	6a3b      	ldr	r3, [r7, #32]
  20f2f4:	429a      	cmp	r2, r3
  20f2f6:	f280 8295 	bge.w	20f824 <LCD_StrMovHIndirect+0x9fc>
			{	int windowWidth_next = M.windowWidth - (windowWidth_new + M.spaceEndStart);
  20f2fa:	4913      	ldr	r1, [pc, #76]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f2fc:	68fa      	ldr	r2, [r7, #12]
  20f2fe:	4613      	mov	r3, r2
  20f300:	011b      	lsls	r3, r3, #4
  20f302:	1a9b      	subs	r3, r3, r2
  20f304:	009b      	lsls	r3, r3, #2
  20f306:	440b      	add	r3, r1
  20f308:	3332      	adds	r3, #50	; 0x32
  20f30a:	881b      	ldrh	r3, [r3, #0]
  20f30c:	4618      	mov	r0, r3
  20f30e:	490e      	ldr	r1, [pc, #56]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f310:	68fa      	ldr	r2, [r7, #12]
  20f312:	4613      	mov	r3, r2
  20f314:	011b      	lsls	r3, r3, #4
  20f316:	1a9b      	subs	r3, r3, r2
  20f318:	009b      	lsls	r3, r3, #2
  20f31a:	440b      	add	r3, r1
  20f31c:	3338      	adds	r3, #56	; 0x38
  20f31e:	881b      	ldrh	r3, [r3, #0]
  20f320:	461a      	mov	r2, r3
  20f322:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f324:	4413      	add	r3, r2
  20f326:	1ac3      	subs	r3, r0, r3
  20f328:	617b      	str	r3, [r7, #20]

				switch(F.rotate)
  20f32a:	4907      	ldr	r1, [pc, #28]	; (20f348 <LCD_StrMovHIndirect+0x520>)
  20f32c:	68fa      	ldr	r2, [r7, #12]
  20f32e:	4613      	mov	r3, r2
  20f330:	011b      	lsls	r3, r3, #4
  20f332:	1a9b      	subs	r3, r3, r2
  20f334:	009b      	lsls	r3, r3, #2
  20f336:	440b      	add	r3, r1
  20f338:	3314      	adds	r3, #20
  20f33a:	781b      	ldrb	r3, [r3, #0]
  20f33c:	2b00      	cmp	r3, #0
  20f33e:	d009      	beq.n	20f354 <LCD_StrMovHIndirect+0x52c>
  20f340:	2b01      	cmp	r3, #1
  20f342:	f000 808b 	beq.w	20f45c <LCD_StrMovHIndirect+0x634>
  20f346:	e113      	b.n	20f570 <LCD_StrMovHIndirect+0x748>
  20f348:	2000f818 	.word	0x2000f818
  20f34c:	c067f800 	.word	0xc067f800
  20f350:	c0000000 	.word	0xc0000000
				{	case Rotate_0:
						LCD_RectangleBuff(pLcd,0,M.spaceEndStart,M.yImgHeight,0,0,M.spaceEndStart,M.yImgHeight,F.bkColor,F.bkColor,F.bkColor);
  20f354:	4984      	ldr	r1, [pc, #528]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f356:	68fa      	ldr	r2, [r7, #12]
  20f358:	4613      	mov	r3, r2
  20f35a:	011b      	lsls	r3, r3, #4
  20f35c:	1a9b      	subs	r3, r3, r2
  20f35e:	009b      	lsls	r3, r3, #2
  20f360:	440b      	add	r3, r1
  20f362:	3338      	adds	r3, #56	; 0x38
  20f364:	881b      	ldrh	r3, [r3, #0]
  20f366:	469e      	mov	lr, r3
  20f368:	497f      	ldr	r1, [pc, #508]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f36a:	68fa      	ldr	r2, [r7, #12]
  20f36c:	4613      	mov	r3, r2
  20f36e:	011b      	lsls	r3, r3, #4
  20f370:	1a9b      	subs	r3, r3, r2
  20f372:	009b      	lsls	r3, r3, #2
  20f374:	440b      	add	r3, r1
  20f376:	332e      	adds	r3, #46	; 0x2e
  20f378:	881b      	ldrh	r3, [r3, #0]
  20f37a:	469c      	mov	ip, r3
  20f37c:	497a      	ldr	r1, [pc, #488]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f37e:	68fa      	ldr	r2, [r7, #12]
  20f380:	4613      	mov	r3, r2
  20f382:	011b      	lsls	r3, r3, #4
  20f384:	1a9b      	subs	r3, r3, r2
  20f386:	009b      	lsls	r3, r3, #2
  20f388:	440b      	add	r3, r1
  20f38a:	3338      	adds	r3, #56	; 0x38
  20f38c:	881b      	ldrh	r3, [r3, #0]
  20f38e:	461d      	mov	r5, r3
  20f390:	4975      	ldr	r1, [pc, #468]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f392:	68fa      	ldr	r2, [r7, #12]
  20f394:	4613      	mov	r3, r2
  20f396:	011b      	lsls	r3, r3, #4
  20f398:	1a9b      	subs	r3, r3, r2
  20f39a:	009b      	lsls	r3, r3, #2
  20f39c:	440b      	add	r3, r1
  20f39e:	332e      	adds	r3, #46	; 0x2e
  20f3a0:	881b      	ldrh	r3, [r3, #0]
  20f3a2:	461e      	mov	r6, r3
  20f3a4:	4970      	ldr	r1, [pc, #448]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f3a6:	68fa      	ldr	r2, [r7, #12]
  20f3a8:	4613      	mov	r3, r2
  20f3aa:	011b      	lsls	r3, r3, #4
  20f3ac:	1a9b      	subs	r3, r3, r2
  20f3ae:	009b      	lsls	r3, r3, #2
  20f3b0:	440b      	add	r3, r1
  20f3b2:	3308      	adds	r3, #8
  20f3b4:	6819      	ldr	r1, [r3, #0]
  20f3b6:	486c      	ldr	r0, [pc, #432]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f3b8:	68fa      	ldr	r2, [r7, #12]
  20f3ba:	4613      	mov	r3, r2
  20f3bc:	011b      	lsls	r3, r3, #4
  20f3be:	1a9b      	subs	r3, r3, r2
  20f3c0:	009b      	lsls	r3, r3, #2
  20f3c2:	4403      	add	r3, r0
  20f3c4:	3308      	adds	r3, #8
  20f3c6:	6818      	ldr	r0, [r3, #0]
  20f3c8:	4c67      	ldr	r4, [pc, #412]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f3ca:	68fa      	ldr	r2, [r7, #12]
  20f3cc:	4613      	mov	r3, r2
  20f3ce:	011b      	lsls	r3, r3, #4
  20f3d0:	1a9b      	subs	r3, r3, r2
  20f3d2:	009b      	lsls	r3, r3, #2
  20f3d4:	4423      	add	r3, r4
  20f3d6:	3308      	adds	r3, #8
  20f3d8:	681b      	ldr	r3, [r3, #0]
  20f3da:	9306      	str	r3, [sp, #24]
  20f3dc:	9005      	str	r0, [sp, #20]
  20f3de:	9104      	str	r1, [sp, #16]
  20f3e0:	9603      	str	r6, [sp, #12]
  20f3e2:	9502      	str	r5, [sp, #8]
  20f3e4:	2300      	movs	r3, #0
  20f3e6:	9301      	str	r3, [sp, #4]
  20f3e8:	2300      	movs	r3, #0
  20f3ea:	9300      	str	r3, [sp, #0]
  20f3ec:	4663      	mov	r3, ip
  20f3ee:	4672      	mov	r2, lr
  20f3f0:	2100      	movs	r1, #0
  20f3f2:	485e      	ldr	r0, [pc, #376]	; (20f56c <LCD_StrMovHIndirect+0x744>)
  20f3f4:	f7f8 fde2 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos+windowWidth_new, (uint32_t)F.yPos, M.spaceEndStart, M.yImgHeight, pLcd);
  20f3f8:	495b      	ldr	r1, [pc, #364]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f3fa:	68fa      	ldr	r2, [r7, #12]
  20f3fc:	4613      	mov	r3, r2
  20f3fe:	011b      	lsls	r3, r3, #4
  20f400:	1a9b      	subs	r3, r3, r2
  20f402:	009b      	lsls	r3, r3, #2
  20f404:	440b      	add	r3, r1
  20f406:	3302      	adds	r3, #2
  20f408:	881b      	ldrh	r3, [r3, #0]
  20f40a:	461a      	mov	r2, r3
  20f40c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f40e:	18d0      	adds	r0, r2, r3
  20f410:	4955      	ldr	r1, [pc, #340]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f412:	68fa      	ldr	r2, [r7, #12]
  20f414:	4613      	mov	r3, r2
  20f416:	011b      	lsls	r3, r3, #4
  20f418:	1a9b      	subs	r3, r3, r2
  20f41a:	009b      	lsls	r3, r3, #2
  20f41c:	440b      	add	r3, r1
  20f41e:	3304      	adds	r3, #4
  20f420:	881b      	ldrh	r3, [r3, #0]
  20f422:	461c      	mov	r4, r3
  20f424:	4950      	ldr	r1, [pc, #320]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f426:	68fa      	ldr	r2, [r7, #12]
  20f428:	4613      	mov	r3, r2
  20f42a:	011b      	lsls	r3, r3, #4
  20f42c:	1a9b      	subs	r3, r3, r2
  20f42e:	009b      	lsls	r3, r3, #2
  20f430:	440b      	add	r3, r1
  20f432:	3338      	adds	r3, #56	; 0x38
  20f434:	881b      	ldrh	r3, [r3, #0]
  20f436:	461d      	mov	r5, r3
  20f438:	494b      	ldr	r1, [pc, #300]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f43a:	68fa      	ldr	r2, [r7, #12]
  20f43c:	4613      	mov	r3, r2
  20f43e:	011b      	lsls	r3, r3, #4
  20f440:	1a9b      	subs	r3, r3, r2
  20f442:	009b      	lsls	r3, r3, #2
  20f444:	440b      	add	r3, r1
  20f446:	332e      	adds	r3, #46	; 0x2e
  20f448:	881b      	ldrh	r3, [r3, #0]
  20f44a:	461a      	mov	r2, r3
  20f44c:	4b47      	ldr	r3, [pc, #284]	; (20f56c <LCD_StrMovHIndirect+0x744>)
  20f44e:	9300      	str	r3, [sp, #0]
  20f450:	4613      	mov	r3, r2
  20f452:	462a      	mov	r2, r5
  20f454:	4621      	mov	r1, r4
  20f456:	f7f8 fb1d 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f45a:	e10e      	b.n	20f67a <LCD_StrMovHIndirect+0x852>
					case Rotate_90:
						LCD_RectangleBuff(pLcd,0,M.yImgHeight,M.spaceEndStart,0,0,M.yImgHeight,M.spaceEndStart,F.bkColor,F.bkColor,F.bkColor);
  20f45c:	4942      	ldr	r1, [pc, #264]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f45e:	68fa      	ldr	r2, [r7, #12]
  20f460:	4613      	mov	r3, r2
  20f462:	011b      	lsls	r3, r3, #4
  20f464:	1a9b      	subs	r3, r3, r2
  20f466:	009b      	lsls	r3, r3, #2
  20f468:	440b      	add	r3, r1
  20f46a:	332e      	adds	r3, #46	; 0x2e
  20f46c:	881b      	ldrh	r3, [r3, #0]
  20f46e:	469e      	mov	lr, r3
  20f470:	493d      	ldr	r1, [pc, #244]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f472:	68fa      	ldr	r2, [r7, #12]
  20f474:	4613      	mov	r3, r2
  20f476:	011b      	lsls	r3, r3, #4
  20f478:	1a9b      	subs	r3, r3, r2
  20f47a:	009b      	lsls	r3, r3, #2
  20f47c:	440b      	add	r3, r1
  20f47e:	3338      	adds	r3, #56	; 0x38
  20f480:	881b      	ldrh	r3, [r3, #0]
  20f482:	469c      	mov	ip, r3
  20f484:	4938      	ldr	r1, [pc, #224]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f486:	68fa      	ldr	r2, [r7, #12]
  20f488:	4613      	mov	r3, r2
  20f48a:	011b      	lsls	r3, r3, #4
  20f48c:	1a9b      	subs	r3, r3, r2
  20f48e:	009b      	lsls	r3, r3, #2
  20f490:	440b      	add	r3, r1
  20f492:	332e      	adds	r3, #46	; 0x2e
  20f494:	881b      	ldrh	r3, [r3, #0]
  20f496:	461d      	mov	r5, r3
  20f498:	4933      	ldr	r1, [pc, #204]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f49a:	68fa      	ldr	r2, [r7, #12]
  20f49c:	4613      	mov	r3, r2
  20f49e:	011b      	lsls	r3, r3, #4
  20f4a0:	1a9b      	subs	r3, r3, r2
  20f4a2:	009b      	lsls	r3, r3, #2
  20f4a4:	440b      	add	r3, r1
  20f4a6:	3338      	adds	r3, #56	; 0x38
  20f4a8:	881b      	ldrh	r3, [r3, #0]
  20f4aa:	461e      	mov	r6, r3
  20f4ac:	492e      	ldr	r1, [pc, #184]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f4ae:	68fa      	ldr	r2, [r7, #12]
  20f4b0:	4613      	mov	r3, r2
  20f4b2:	011b      	lsls	r3, r3, #4
  20f4b4:	1a9b      	subs	r3, r3, r2
  20f4b6:	009b      	lsls	r3, r3, #2
  20f4b8:	440b      	add	r3, r1
  20f4ba:	3308      	adds	r3, #8
  20f4bc:	6819      	ldr	r1, [r3, #0]
  20f4be:	482a      	ldr	r0, [pc, #168]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f4c0:	68fa      	ldr	r2, [r7, #12]
  20f4c2:	4613      	mov	r3, r2
  20f4c4:	011b      	lsls	r3, r3, #4
  20f4c6:	1a9b      	subs	r3, r3, r2
  20f4c8:	009b      	lsls	r3, r3, #2
  20f4ca:	4403      	add	r3, r0
  20f4cc:	3308      	adds	r3, #8
  20f4ce:	6818      	ldr	r0, [r3, #0]
  20f4d0:	4c25      	ldr	r4, [pc, #148]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f4d2:	68fa      	ldr	r2, [r7, #12]
  20f4d4:	4613      	mov	r3, r2
  20f4d6:	011b      	lsls	r3, r3, #4
  20f4d8:	1a9b      	subs	r3, r3, r2
  20f4da:	009b      	lsls	r3, r3, #2
  20f4dc:	4423      	add	r3, r4
  20f4de:	3308      	adds	r3, #8
  20f4e0:	681b      	ldr	r3, [r3, #0]
  20f4e2:	9306      	str	r3, [sp, #24]
  20f4e4:	9005      	str	r0, [sp, #20]
  20f4e6:	9104      	str	r1, [sp, #16]
  20f4e8:	9603      	str	r6, [sp, #12]
  20f4ea:	9502      	str	r5, [sp, #8]
  20f4ec:	2300      	movs	r3, #0
  20f4ee:	9301      	str	r3, [sp, #4]
  20f4f0:	2300      	movs	r3, #0
  20f4f2:	9300      	str	r3, [sp, #0]
  20f4f4:	4663      	mov	r3, ip
  20f4f6:	4672      	mov	r2, lr
  20f4f8:	2100      	movs	r1, #0
  20f4fa:	481c      	ldr	r0, [pc, #112]	; (20f56c <LCD_StrMovHIndirect+0x744>)
  20f4fc:	f7f8 fd5e 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos+windowWidth_new, M.yImgHeight, M.spaceEndStart, pLcd);
  20f500:	4919      	ldr	r1, [pc, #100]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f502:	68fa      	ldr	r2, [r7, #12]
  20f504:	4613      	mov	r3, r2
  20f506:	011b      	lsls	r3, r3, #4
  20f508:	1a9b      	subs	r3, r3, r2
  20f50a:	009b      	lsls	r3, r3, #2
  20f50c:	440b      	add	r3, r1
  20f50e:	3302      	adds	r3, #2
  20f510:	881b      	ldrh	r3, [r3, #0]
  20f512:	461c      	mov	r4, r3
  20f514:	4914      	ldr	r1, [pc, #80]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f516:	68fa      	ldr	r2, [r7, #12]
  20f518:	4613      	mov	r3, r2
  20f51a:	011b      	lsls	r3, r3, #4
  20f51c:	1a9b      	subs	r3, r3, r2
  20f51e:	009b      	lsls	r3, r3, #2
  20f520:	440b      	add	r3, r1
  20f522:	3304      	adds	r3, #4
  20f524:	881b      	ldrh	r3, [r3, #0]
  20f526:	461a      	mov	r2, r3
  20f528:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f52a:	18d0      	adds	r0, r2, r3
  20f52c:	490e      	ldr	r1, [pc, #56]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f52e:	68fa      	ldr	r2, [r7, #12]
  20f530:	4613      	mov	r3, r2
  20f532:	011b      	lsls	r3, r3, #4
  20f534:	1a9b      	subs	r3, r3, r2
  20f536:	009b      	lsls	r3, r3, #2
  20f538:	440b      	add	r3, r1
  20f53a:	332e      	adds	r3, #46	; 0x2e
  20f53c:	881b      	ldrh	r3, [r3, #0]
  20f53e:	461d      	mov	r5, r3
  20f540:	4909      	ldr	r1, [pc, #36]	; (20f568 <LCD_StrMovHIndirect+0x740>)
  20f542:	68fa      	ldr	r2, [r7, #12]
  20f544:	4613      	mov	r3, r2
  20f546:	011b      	lsls	r3, r3, #4
  20f548:	1a9b      	subs	r3, r3, r2
  20f54a:	009b      	lsls	r3, r3, #2
  20f54c:	440b      	add	r3, r1
  20f54e:	3338      	adds	r3, #56	; 0x38
  20f550:	881b      	ldrh	r3, [r3, #0]
  20f552:	461a      	mov	r2, r3
  20f554:	4b05      	ldr	r3, [pc, #20]	; (20f56c <LCD_StrMovHIndirect+0x744>)
  20f556:	9300      	str	r3, [sp, #0]
  20f558:	4613      	mov	r3, r2
  20f55a:	462a      	mov	r2, r5
  20f55c:	4601      	mov	r1, r0
  20f55e:	4620      	mov	r0, r4
  20f560:	f7f8 fa98 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f564:	e089      	b.n	20f67a <LCD_StrMovHIndirect+0x852>
  20f566:	bf00      	nop
  20f568:	2000f818 	.word	0x2000f818
  20f56c:	c0000000 	.word	0xc0000000
					case Rotate_180:
					default:
						LCD_RectangleBuff(pLcd,0,M.yImgHeight,M.spaceEndStart,0,0,M.yImgHeight,M.spaceEndStart,F.bkColor,F.bkColor,F.bkColor);
  20f570:	49b3      	ldr	r1, [pc, #716]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f572:	68fa      	ldr	r2, [r7, #12]
  20f574:	4613      	mov	r3, r2
  20f576:	011b      	lsls	r3, r3, #4
  20f578:	1a9b      	subs	r3, r3, r2
  20f57a:	009b      	lsls	r3, r3, #2
  20f57c:	440b      	add	r3, r1
  20f57e:	332e      	adds	r3, #46	; 0x2e
  20f580:	881b      	ldrh	r3, [r3, #0]
  20f582:	469e      	mov	lr, r3
  20f584:	49ae      	ldr	r1, [pc, #696]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f586:	68fa      	ldr	r2, [r7, #12]
  20f588:	4613      	mov	r3, r2
  20f58a:	011b      	lsls	r3, r3, #4
  20f58c:	1a9b      	subs	r3, r3, r2
  20f58e:	009b      	lsls	r3, r3, #2
  20f590:	440b      	add	r3, r1
  20f592:	3338      	adds	r3, #56	; 0x38
  20f594:	881b      	ldrh	r3, [r3, #0]
  20f596:	469c      	mov	ip, r3
  20f598:	49a9      	ldr	r1, [pc, #676]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f59a:	68fa      	ldr	r2, [r7, #12]
  20f59c:	4613      	mov	r3, r2
  20f59e:	011b      	lsls	r3, r3, #4
  20f5a0:	1a9b      	subs	r3, r3, r2
  20f5a2:	009b      	lsls	r3, r3, #2
  20f5a4:	440b      	add	r3, r1
  20f5a6:	332e      	adds	r3, #46	; 0x2e
  20f5a8:	881b      	ldrh	r3, [r3, #0]
  20f5aa:	461d      	mov	r5, r3
  20f5ac:	49a4      	ldr	r1, [pc, #656]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f5ae:	68fa      	ldr	r2, [r7, #12]
  20f5b0:	4613      	mov	r3, r2
  20f5b2:	011b      	lsls	r3, r3, #4
  20f5b4:	1a9b      	subs	r3, r3, r2
  20f5b6:	009b      	lsls	r3, r3, #2
  20f5b8:	440b      	add	r3, r1
  20f5ba:	3338      	adds	r3, #56	; 0x38
  20f5bc:	881b      	ldrh	r3, [r3, #0]
  20f5be:	461e      	mov	r6, r3
  20f5c0:	499f      	ldr	r1, [pc, #636]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f5c2:	68fa      	ldr	r2, [r7, #12]
  20f5c4:	4613      	mov	r3, r2
  20f5c6:	011b      	lsls	r3, r3, #4
  20f5c8:	1a9b      	subs	r3, r3, r2
  20f5ca:	009b      	lsls	r3, r3, #2
  20f5cc:	440b      	add	r3, r1
  20f5ce:	3308      	adds	r3, #8
  20f5d0:	6819      	ldr	r1, [r3, #0]
  20f5d2:	489b      	ldr	r0, [pc, #620]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f5d4:	68fa      	ldr	r2, [r7, #12]
  20f5d6:	4613      	mov	r3, r2
  20f5d8:	011b      	lsls	r3, r3, #4
  20f5da:	1a9b      	subs	r3, r3, r2
  20f5dc:	009b      	lsls	r3, r3, #2
  20f5de:	4403      	add	r3, r0
  20f5e0:	3308      	adds	r3, #8
  20f5e2:	6818      	ldr	r0, [r3, #0]
  20f5e4:	4c96      	ldr	r4, [pc, #600]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f5e6:	68fa      	ldr	r2, [r7, #12]
  20f5e8:	4613      	mov	r3, r2
  20f5ea:	011b      	lsls	r3, r3, #4
  20f5ec:	1a9b      	subs	r3, r3, r2
  20f5ee:	009b      	lsls	r3, r3, #2
  20f5f0:	4423      	add	r3, r4
  20f5f2:	3308      	adds	r3, #8
  20f5f4:	681b      	ldr	r3, [r3, #0]
  20f5f6:	9306      	str	r3, [sp, #24]
  20f5f8:	9005      	str	r0, [sp, #20]
  20f5fa:	9104      	str	r1, [sp, #16]
  20f5fc:	9603      	str	r6, [sp, #12]
  20f5fe:	9502      	str	r5, [sp, #8]
  20f600:	2300      	movs	r3, #0
  20f602:	9301      	str	r3, [sp, #4]
  20f604:	2300      	movs	r3, #0
  20f606:	9300      	str	r3, [sp, #0]
  20f608:	4663      	mov	r3, ip
  20f60a:	4672      	mov	r2, lr
  20f60c:	2100      	movs	r1, #0
  20f60e:	488d      	ldr	r0, [pc, #564]	; (20f844 <LCD_StrMovHIndirect+0xa1c>)
  20f610:	f7f8 fcd4 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos+windowWidth_next, M.yImgHeight, M.spaceEndStart, pLcd);
  20f614:	498a      	ldr	r1, [pc, #552]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f616:	68fa      	ldr	r2, [r7, #12]
  20f618:	4613      	mov	r3, r2
  20f61a:	011b      	lsls	r3, r3, #4
  20f61c:	1a9b      	subs	r3, r3, r2
  20f61e:	009b      	lsls	r3, r3, #2
  20f620:	440b      	add	r3, r1
  20f622:	3302      	adds	r3, #2
  20f624:	881b      	ldrh	r3, [r3, #0]
  20f626:	461c      	mov	r4, r3
  20f628:	4985      	ldr	r1, [pc, #532]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f62a:	68fa      	ldr	r2, [r7, #12]
  20f62c:	4613      	mov	r3, r2
  20f62e:	011b      	lsls	r3, r3, #4
  20f630:	1a9b      	subs	r3, r3, r2
  20f632:	009b      	lsls	r3, r3, #2
  20f634:	440b      	add	r3, r1
  20f636:	3304      	adds	r3, #4
  20f638:	881b      	ldrh	r3, [r3, #0]
  20f63a:	461a      	mov	r2, r3
  20f63c:	697b      	ldr	r3, [r7, #20]
  20f63e:	18d0      	adds	r0, r2, r3
  20f640:	497f      	ldr	r1, [pc, #508]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f642:	68fa      	ldr	r2, [r7, #12]
  20f644:	4613      	mov	r3, r2
  20f646:	011b      	lsls	r3, r3, #4
  20f648:	1a9b      	subs	r3, r3, r2
  20f64a:	009b      	lsls	r3, r3, #2
  20f64c:	440b      	add	r3, r1
  20f64e:	332e      	adds	r3, #46	; 0x2e
  20f650:	881b      	ldrh	r3, [r3, #0]
  20f652:	461d      	mov	r5, r3
  20f654:	497a      	ldr	r1, [pc, #488]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f656:	68fa      	ldr	r2, [r7, #12]
  20f658:	4613      	mov	r3, r2
  20f65a:	011b      	lsls	r3, r3, #4
  20f65c:	1a9b      	subs	r3, r3, r2
  20f65e:	009b      	lsls	r3, r3, #2
  20f660:	440b      	add	r3, r1
  20f662:	3338      	adds	r3, #56	; 0x38
  20f664:	881b      	ldrh	r3, [r3, #0]
  20f666:	461a      	mov	r2, r3
  20f668:	4b76      	ldr	r3, [pc, #472]	; (20f844 <LCD_StrMovHIndirect+0xa1c>)
  20f66a:	9300      	str	r3, [sp, #0]
  20f66c:	4613      	mov	r3, r2
  20f66e:	462a      	mov	r2, r5
  20f670:	4601      	mov	r1, r0
  20f672:	4620      	mov	r0, r4
  20f674:	f7f8 fa0e 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f678:	bf00      	nop
				}

				LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth, M.yImgHeight, 0, windowWidth_next,0);
  20f67a:	4971      	ldr	r1, [pc, #452]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f67c:	68fa      	ldr	r2, [r7, #12]
  20f67e:	4613      	mov	r3, r2
  20f680:	011b      	lsls	r3, r3, #4
  20f682:	1a9b      	subs	r3, r3, r2
  20f684:	009b      	lsls	r3, r3, #2
  20f686:	440b      	add	r3, r1
  20f688:	3314      	adds	r3, #20
  20f68a:	781b      	ldrb	r3, [r3, #0]
  20f68c:	461c      	mov	r4, r3
  20f68e:	496c      	ldr	r1, [pc, #432]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f690:	68fa      	ldr	r2, [r7, #12]
  20f692:	4613      	mov	r3, r2
  20f694:	011b      	lsls	r3, r3, #4
  20f696:	1a9b      	subs	r3, r3, r2
  20f698:	009b      	lsls	r3, r3, #2
  20f69a:	440b      	add	r3, r1
  20f69c:	3328      	adds	r3, #40	; 0x28
  20f69e:	6818      	ldr	r0, [r3, #0]
  20f6a0:	4967      	ldr	r1, [pc, #412]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f6a2:	68fa      	ldr	r2, [r7, #12]
  20f6a4:	4613      	mov	r3, r2
  20f6a6:	011b      	lsls	r3, r3, #4
  20f6a8:	1a9b      	subs	r3, r3, r2
  20f6aa:	009b      	lsls	r3, r3, #2
  20f6ac:	440b      	add	r3, r1
  20f6ae:	332c      	adds	r3, #44	; 0x2c
  20f6b0:	881b      	ldrh	r3, [r3, #0]
  20f6b2:	461d      	mov	r5, r3
  20f6b4:	4962      	ldr	r1, [pc, #392]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f6b6:	68fa      	ldr	r2, [r7, #12]
  20f6b8:	4613      	mov	r3, r2
  20f6ba:	011b      	lsls	r3, r3, #4
  20f6bc:	1a9b      	subs	r3, r3, r2
  20f6be:	009b      	lsls	r3, r3, #2
  20f6c0:	440b      	add	r3, r1
  20f6c2:	332e      	adds	r3, #46	; 0x2e
  20f6c4:	881b      	ldrh	r3, [r3, #0]
  20f6c6:	4619      	mov	r1, r3
  20f6c8:	697b      	ldr	r3, [r7, #20]
  20f6ca:	b29b      	uxth	r3, r3
  20f6cc:	2200      	movs	r2, #0
  20f6ce:	9203      	str	r2, [sp, #12]
  20f6d0:	9302      	str	r3, [sp, #8]
  20f6d2:	2300      	movs	r3, #0
  20f6d4:	9301      	str	r3, [sp, #4]
  20f6d6:	9100      	str	r1, [sp, #0]
  20f6d8:	462b      	mov	r3, r5
  20f6da:	4a5b      	ldr	r2, [pc, #364]	; (20f848 <LCD_StrMovHIndirect+0xa20>)
  20f6dc:	4601      	mov	r1, r0
  20f6de:	4620      	mov	r0, r4
  20f6e0:	f7f8 fb04 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
				switch(F.rotate)
  20f6e4:	4956      	ldr	r1, [pc, #344]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f6e6:	68fa      	ldr	r2, [r7, #12]
  20f6e8:	4613      	mov	r3, r2
  20f6ea:	011b      	lsls	r3, r3, #4
  20f6ec:	1a9b      	subs	r3, r3, r2
  20f6ee:	009b      	lsls	r3, r3, #2
  20f6f0:	440b      	add	r3, r1
  20f6f2:	3314      	adds	r3, #20
  20f6f4:	781b      	ldrb	r3, [r3, #0]
  20f6f6:	2b00      	cmp	r3, #0
  20f6f8:	d002      	beq.n	20f700 <LCD_StrMovHIndirect+0x8d8>
  20f6fa:	2b01      	cmp	r3, #1
  20f6fc:	d034      	beq.n	20f768 <LCD_StrMovHIndirect+0x940>
  20f6fe:	e068      	b.n	20f7d2 <LCD_StrMovHIndirect+0x9aa>
				{	case Rotate_0:
						LCD_DisplayBuff((uint32_t)F.xPos+windowWidth_new+M.spaceEndStart, (uint32_t)F.yPos, windowWidth_next, M.yImgHeight, pLcd);
  20f700:	494f      	ldr	r1, [pc, #316]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f702:	68fa      	ldr	r2, [r7, #12]
  20f704:	4613      	mov	r3, r2
  20f706:	011b      	lsls	r3, r3, #4
  20f708:	1a9b      	subs	r3, r3, r2
  20f70a:	009b      	lsls	r3, r3, #2
  20f70c:	440b      	add	r3, r1
  20f70e:	3302      	adds	r3, #2
  20f710:	881b      	ldrh	r3, [r3, #0]
  20f712:	461a      	mov	r2, r3
  20f714:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f716:	18d1      	adds	r1, r2, r3
  20f718:	4849      	ldr	r0, [pc, #292]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f71a:	68fa      	ldr	r2, [r7, #12]
  20f71c:	4613      	mov	r3, r2
  20f71e:	011b      	lsls	r3, r3, #4
  20f720:	1a9b      	subs	r3, r3, r2
  20f722:	009b      	lsls	r3, r3, #2
  20f724:	4403      	add	r3, r0
  20f726:	3338      	adds	r3, #56	; 0x38
  20f728:	881b      	ldrh	r3, [r3, #0]
  20f72a:	18c8      	adds	r0, r1, r3
  20f72c:	4944      	ldr	r1, [pc, #272]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f72e:	68fa      	ldr	r2, [r7, #12]
  20f730:	4613      	mov	r3, r2
  20f732:	011b      	lsls	r3, r3, #4
  20f734:	1a9b      	subs	r3, r3, r2
  20f736:	009b      	lsls	r3, r3, #2
  20f738:	440b      	add	r3, r1
  20f73a:	3304      	adds	r3, #4
  20f73c:	881b      	ldrh	r3, [r3, #0]
  20f73e:	461d      	mov	r5, r3
  20f740:	697c      	ldr	r4, [r7, #20]
  20f742:	493f      	ldr	r1, [pc, #252]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f744:	68fa      	ldr	r2, [r7, #12]
  20f746:	4613      	mov	r3, r2
  20f748:	011b      	lsls	r3, r3, #4
  20f74a:	1a9b      	subs	r3, r3, r2
  20f74c:	009b      	lsls	r3, r3, #2
  20f74e:	440b      	add	r3, r1
  20f750:	332e      	adds	r3, #46	; 0x2e
  20f752:	881b      	ldrh	r3, [r3, #0]
  20f754:	461a      	mov	r2, r3
  20f756:	4b3b      	ldr	r3, [pc, #236]	; (20f844 <LCD_StrMovHIndirect+0xa1c>)
  20f758:	9300      	str	r3, [sp, #0]
  20f75a:	4613      	mov	r3, r2
  20f75c:	4622      	mov	r2, r4
  20f75e:	4629      	mov	r1, r5
  20f760:	f7f8 f998 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f764:	f000 bca2 	b.w	2100ac <LCD_StrMovHIndirect+0x1284>
					case Rotate_90:
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos+windowWidth_new+M.spaceEndStart, M.yImgHeight, windowWidth_next, pLcd);
  20f768:	4935      	ldr	r1, [pc, #212]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f76a:	68fa      	ldr	r2, [r7, #12]
  20f76c:	4613      	mov	r3, r2
  20f76e:	011b      	lsls	r3, r3, #4
  20f770:	1a9b      	subs	r3, r3, r2
  20f772:	009b      	lsls	r3, r3, #2
  20f774:	440b      	add	r3, r1
  20f776:	3302      	adds	r3, #2
  20f778:	881b      	ldrh	r3, [r3, #0]
  20f77a:	461c      	mov	r4, r3
  20f77c:	4930      	ldr	r1, [pc, #192]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f77e:	68fa      	ldr	r2, [r7, #12]
  20f780:	4613      	mov	r3, r2
  20f782:	011b      	lsls	r3, r3, #4
  20f784:	1a9b      	subs	r3, r3, r2
  20f786:	009b      	lsls	r3, r3, #2
  20f788:	440b      	add	r3, r1
  20f78a:	3304      	adds	r3, #4
  20f78c:	881b      	ldrh	r3, [r3, #0]
  20f78e:	461a      	mov	r2, r3
  20f790:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f792:	18d1      	adds	r1, r2, r3
  20f794:	482a      	ldr	r0, [pc, #168]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f796:	68fa      	ldr	r2, [r7, #12]
  20f798:	4613      	mov	r3, r2
  20f79a:	011b      	lsls	r3, r3, #4
  20f79c:	1a9b      	subs	r3, r3, r2
  20f79e:	009b      	lsls	r3, r3, #2
  20f7a0:	4403      	add	r3, r0
  20f7a2:	3338      	adds	r3, #56	; 0x38
  20f7a4:	881b      	ldrh	r3, [r3, #0]
  20f7a6:	18c8      	adds	r0, r1, r3
  20f7a8:	4925      	ldr	r1, [pc, #148]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f7aa:	68fa      	ldr	r2, [r7, #12]
  20f7ac:	4613      	mov	r3, r2
  20f7ae:	011b      	lsls	r3, r3, #4
  20f7b0:	1a9b      	subs	r3, r3, r2
  20f7b2:	009b      	lsls	r3, r3, #2
  20f7b4:	440b      	add	r3, r1
  20f7b6:	332e      	adds	r3, #46	; 0x2e
  20f7b8:	881b      	ldrh	r3, [r3, #0]
  20f7ba:	4619      	mov	r1, r3
  20f7bc:	697a      	ldr	r2, [r7, #20]
  20f7be:	4b21      	ldr	r3, [pc, #132]	; (20f844 <LCD_StrMovHIndirect+0xa1c>)
  20f7c0:	9300      	str	r3, [sp, #0]
  20f7c2:	4613      	mov	r3, r2
  20f7c4:	460a      	mov	r2, r1
  20f7c6:	4601      	mov	r1, r0
  20f7c8:	4620      	mov	r0, r4
  20f7ca:	f7f8 f963 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f7ce:	f000 bc6d 	b.w	2100ac <LCD_StrMovHIndirect+0x1284>
					case Rotate_180:
					default:
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, M.yImgHeight, windowWidth_next, pLcd);
  20f7d2:	491b      	ldr	r1, [pc, #108]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f7d4:	68fa      	ldr	r2, [r7, #12]
  20f7d6:	4613      	mov	r3, r2
  20f7d8:	011b      	lsls	r3, r3, #4
  20f7da:	1a9b      	subs	r3, r3, r2
  20f7dc:	009b      	lsls	r3, r3, #2
  20f7de:	440b      	add	r3, r1
  20f7e0:	3302      	adds	r3, #2
  20f7e2:	881b      	ldrh	r3, [r3, #0]
  20f7e4:	4618      	mov	r0, r3
  20f7e6:	4916      	ldr	r1, [pc, #88]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f7e8:	68fa      	ldr	r2, [r7, #12]
  20f7ea:	4613      	mov	r3, r2
  20f7ec:	011b      	lsls	r3, r3, #4
  20f7ee:	1a9b      	subs	r3, r3, r2
  20f7f0:	009b      	lsls	r3, r3, #2
  20f7f2:	440b      	add	r3, r1
  20f7f4:	3304      	adds	r3, #4
  20f7f6:	881b      	ldrh	r3, [r3, #0]
  20f7f8:	461c      	mov	r4, r3
  20f7fa:	4911      	ldr	r1, [pc, #68]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f7fc:	68fa      	ldr	r2, [r7, #12]
  20f7fe:	4613      	mov	r3, r2
  20f800:	011b      	lsls	r3, r3, #4
  20f802:	1a9b      	subs	r3, r3, r2
  20f804:	009b      	lsls	r3, r3, #2
  20f806:	440b      	add	r3, r1
  20f808:	332e      	adds	r3, #46	; 0x2e
  20f80a:	881b      	ldrh	r3, [r3, #0]
  20f80c:	4619      	mov	r1, r3
  20f80e:	697a      	ldr	r2, [r7, #20]
  20f810:	4b0c      	ldr	r3, [pc, #48]	; (20f844 <LCD_StrMovHIndirect+0xa1c>)
  20f812:	9300      	str	r3, [sp, #0]
  20f814:	4613      	mov	r3, r2
  20f816:	460a      	mov	r2, r1
  20f818:	4621      	mov	r1, r4
  20f81a:	f7f8 f93b 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f81e:	bf00      	nop
  20f820:	f000 bc44 	b.w	2100ac <LCD_StrMovHIndirect+0x1284>
				}
			}
			else{
				switch(F.rotate)
  20f824:	4906      	ldr	r1, [pc, #24]	; (20f840 <LCD_StrMovHIndirect+0xa18>)
  20f826:	68fa      	ldr	r2, [r7, #12]
  20f828:	4613      	mov	r3, r2
  20f82a:	011b      	lsls	r3, r3, #4
  20f82c:	1a9b      	subs	r3, r3, r2
  20f82e:	009b      	lsls	r3, r3, #2
  20f830:	440b      	add	r3, r1
  20f832:	3314      	adds	r3, #20
  20f834:	781b      	ldrb	r3, [r3, #0]
  20f836:	2b00      	cmp	r3, #0
  20f838:	d008      	beq.n	20f84c <LCD_StrMovHIndirect+0xa24>
  20f83a:	2b01      	cmp	r3, #1
  20f83c:	d070      	beq.n	20f920 <LCD_StrMovHIndirect+0xaf8>
  20f83e:	e0da      	b.n	20f9f6 <LCD_StrMovHIndirect+0xbce>
  20f840:	2000f818 	.word	0x2000f818
  20f844:	c0000000 	.word	0xc0000000
  20f848:	c067f800 	.word	0xc067f800
				{	case Rotate_0:
						LCD_RectangleBuff(pLcd,0,windowWidth_empty,M.yImgHeight,0,0,windowWidth_empty,M.yImgHeight,F.bkColor,F.bkColor,F.bkColor);
  20f84c:	6a3e      	ldr	r6, [r7, #32]
  20f84e:	49b4      	ldr	r1, [pc, #720]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f850:	68fa      	ldr	r2, [r7, #12]
  20f852:	4613      	mov	r3, r2
  20f854:	011b      	lsls	r3, r3, #4
  20f856:	1a9b      	subs	r3, r3, r2
  20f858:	009b      	lsls	r3, r3, #2
  20f85a:	440b      	add	r3, r1
  20f85c:	332e      	adds	r3, #46	; 0x2e
  20f85e:	881b      	ldrh	r3, [r3, #0]
  20f860:	469e      	mov	lr, r3
  20f862:	6a39      	ldr	r1, [r7, #32]
  20f864:	48ae      	ldr	r0, [pc, #696]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f866:	68fa      	ldr	r2, [r7, #12]
  20f868:	4613      	mov	r3, r2
  20f86a:	011b      	lsls	r3, r3, #4
  20f86c:	1a9b      	subs	r3, r3, r2
  20f86e:	009b      	lsls	r3, r3, #2
  20f870:	4403      	add	r3, r0
  20f872:	332e      	adds	r3, #46	; 0x2e
  20f874:	881b      	ldrh	r3, [r3, #0]
  20f876:	607b      	str	r3, [r7, #4]
  20f878:	48a9      	ldr	r0, [pc, #676]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f87a:	68fa      	ldr	r2, [r7, #12]
  20f87c:	4613      	mov	r3, r2
  20f87e:	011b      	lsls	r3, r3, #4
  20f880:	1a9b      	subs	r3, r3, r2
  20f882:	009b      	lsls	r3, r3, #2
  20f884:	4403      	add	r3, r0
  20f886:	3308      	adds	r3, #8
  20f888:	6818      	ldr	r0, [r3, #0]
  20f88a:	4ca5      	ldr	r4, [pc, #660]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f88c:	68fa      	ldr	r2, [r7, #12]
  20f88e:	4613      	mov	r3, r2
  20f890:	011b      	lsls	r3, r3, #4
  20f892:	1a9b      	subs	r3, r3, r2
  20f894:	009b      	lsls	r3, r3, #2
  20f896:	4423      	add	r3, r4
  20f898:	3308      	adds	r3, #8
  20f89a:	681c      	ldr	r4, [r3, #0]
  20f89c:	4da0      	ldr	r5, [pc, #640]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f89e:	68fa      	ldr	r2, [r7, #12]
  20f8a0:	4613      	mov	r3, r2
  20f8a2:	011b      	lsls	r3, r3, #4
  20f8a4:	1a9b      	subs	r3, r3, r2
  20f8a6:	009b      	lsls	r3, r3, #2
  20f8a8:	442b      	add	r3, r5
  20f8aa:	3308      	adds	r3, #8
  20f8ac:	681b      	ldr	r3, [r3, #0]
  20f8ae:	9306      	str	r3, [sp, #24]
  20f8b0:	9405      	str	r4, [sp, #20]
  20f8b2:	9004      	str	r0, [sp, #16]
  20f8b4:	687b      	ldr	r3, [r7, #4]
  20f8b6:	9303      	str	r3, [sp, #12]
  20f8b8:	9102      	str	r1, [sp, #8]
  20f8ba:	2300      	movs	r3, #0
  20f8bc:	9301      	str	r3, [sp, #4]
  20f8be:	2300      	movs	r3, #0
  20f8c0:	9300      	str	r3, [sp, #0]
  20f8c2:	4673      	mov	r3, lr
  20f8c4:	4632      	mov	r2, r6
  20f8c6:	2100      	movs	r1, #0
  20f8c8:	4896      	ldr	r0, [pc, #600]	; (20fb24 <LCD_StrMovHIndirect+0xcfc>)
  20f8ca:	f7f8 fb77 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos+windowWidth_new, (uint32_t)F.yPos, windowWidth_empty, M.yImgHeight, pLcd);
  20f8ce:	4994      	ldr	r1, [pc, #592]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f8d0:	68fa      	ldr	r2, [r7, #12]
  20f8d2:	4613      	mov	r3, r2
  20f8d4:	011b      	lsls	r3, r3, #4
  20f8d6:	1a9b      	subs	r3, r3, r2
  20f8d8:	009b      	lsls	r3, r3, #2
  20f8da:	440b      	add	r3, r1
  20f8dc:	3302      	adds	r3, #2
  20f8de:	881b      	ldrh	r3, [r3, #0]
  20f8e0:	461a      	mov	r2, r3
  20f8e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f8e4:	18d0      	adds	r0, r2, r3
  20f8e6:	498e      	ldr	r1, [pc, #568]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f8e8:	68fa      	ldr	r2, [r7, #12]
  20f8ea:	4613      	mov	r3, r2
  20f8ec:	011b      	lsls	r3, r3, #4
  20f8ee:	1a9b      	subs	r3, r3, r2
  20f8f0:	009b      	lsls	r3, r3, #2
  20f8f2:	440b      	add	r3, r1
  20f8f4:	3304      	adds	r3, #4
  20f8f6:	881b      	ldrh	r3, [r3, #0]
  20f8f8:	461d      	mov	r5, r3
  20f8fa:	6a3c      	ldr	r4, [r7, #32]
  20f8fc:	4988      	ldr	r1, [pc, #544]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f8fe:	68fa      	ldr	r2, [r7, #12]
  20f900:	4613      	mov	r3, r2
  20f902:	011b      	lsls	r3, r3, #4
  20f904:	1a9b      	subs	r3, r3, r2
  20f906:	009b      	lsls	r3, r3, #2
  20f908:	440b      	add	r3, r1
  20f90a:	332e      	adds	r3, #46	; 0x2e
  20f90c:	881b      	ldrh	r3, [r3, #0]
  20f90e:	461a      	mov	r2, r3
  20f910:	4b84      	ldr	r3, [pc, #528]	; (20fb24 <LCD_StrMovHIndirect+0xcfc>)
  20f912:	9300      	str	r3, [sp, #0]
  20f914:	4613      	mov	r3, r2
  20f916:	4622      	mov	r2, r4
  20f918:	4629      	mov	r1, r5
  20f91a:	f7f8 f8bb 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f91e:	e3c5      	b.n	2100ac <LCD_StrMovHIndirect+0x1284>
					case Rotate_90:
						LCD_RectangleBuff(pLcd,0,M.yImgHeight,windowWidth_empty,0,0,M.yImgHeight,windowWidth_empty,F.bkColor,F.bkColor,F.bkColor);
  20f920:	497f      	ldr	r1, [pc, #508]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f922:	68fa      	ldr	r2, [r7, #12]
  20f924:	4613      	mov	r3, r2
  20f926:	011b      	lsls	r3, r3, #4
  20f928:	1a9b      	subs	r3, r3, r2
  20f92a:	009b      	lsls	r3, r3, #2
  20f92c:	440b      	add	r3, r1
  20f92e:	332e      	adds	r3, #46	; 0x2e
  20f930:	881b      	ldrh	r3, [r3, #0]
  20f932:	469e      	mov	lr, r3
  20f934:	6a3e      	ldr	r6, [r7, #32]
  20f936:	497a      	ldr	r1, [pc, #488]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f938:	68fa      	ldr	r2, [r7, #12]
  20f93a:	4613      	mov	r3, r2
  20f93c:	011b      	lsls	r3, r3, #4
  20f93e:	1a9b      	subs	r3, r3, r2
  20f940:	009b      	lsls	r3, r3, #2
  20f942:	440b      	add	r3, r1
  20f944:	332e      	adds	r3, #46	; 0x2e
  20f946:	881b      	ldrh	r3, [r3, #0]
  20f948:	607b      	str	r3, [r7, #4]
  20f94a:	6a39      	ldr	r1, [r7, #32]
  20f94c:	4874      	ldr	r0, [pc, #464]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f94e:	68fa      	ldr	r2, [r7, #12]
  20f950:	4613      	mov	r3, r2
  20f952:	011b      	lsls	r3, r3, #4
  20f954:	1a9b      	subs	r3, r3, r2
  20f956:	009b      	lsls	r3, r3, #2
  20f958:	4403      	add	r3, r0
  20f95a:	3308      	adds	r3, #8
  20f95c:	6818      	ldr	r0, [r3, #0]
  20f95e:	4c70      	ldr	r4, [pc, #448]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f960:	68fa      	ldr	r2, [r7, #12]
  20f962:	4613      	mov	r3, r2
  20f964:	011b      	lsls	r3, r3, #4
  20f966:	1a9b      	subs	r3, r3, r2
  20f968:	009b      	lsls	r3, r3, #2
  20f96a:	4423      	add	r3, r4
  20f96c:	3308      	adds	r3, #8
  20f96e:	681c      	ldr	r4, [r3, #0]
  20f970:	4d6b      	ldr	r5, [pc, #428]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f972:	68fa      	ldr	r2, [r7, #12]
  20f974:	4613      	mov	r3, r2
  20f976:	011b      	lsls	r3, r3, #4
  20f978:	1a9b      	subs	r3, r3, r2
  20f97a:	009b      	lsls	r3, r3, #2
  20f97c:	442b      	add	r3, r5
  20f97e:	3308      	adds	r3, #8
  20f980:	681b      	ldr	r3, [r3, #0]
  20f982:	9306      	str	r3, [sp, #24]
  20f984:	9405      	str	r4, [sp, #20]
  20f986:	9004      	str	r0, [sp, #16]
  20f988:	9103      	str	r1, [sp, #12]
  20f98a:	687b      	ldr	r3, [r7, #4]
  20f98c:	9302      	str	r3, [sp, #8]
  20f98e:	2300      	movs	r3, #0
  20f990:	9301      	str	r3, [sp, #4]
  20f992:	2300      	movs	r3, #0
  20f994:	9300      	str	r3, [sp, #0]
  20f996:	4633      	mov	r3, r6
  20f998:	4672      	mov	r2, lr
  20f99a:	2100      	movs	r1, #0
  20f99c:	4861      	ldr	r0, [pc, #388]	; (20fb24 <LCD_StrMovHIndirect+0xcfc>)
  20f99e:	f7f8 fb0d 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos+windowWidth_new, M.yImgHeight, windowWidth_empty, pLcd);
  20f9a2:	495f      	ldr	r1, [pc, #380]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f9a4:	68fa      	ldr	r2, [r7, #12]
  20f9a6:	4613      	mov	r3, r2
  20f9a8:	011b      	lsls	r3, r3, #4
  20f9aa:	1a9b      	subs	r3, r3, r2
  20f9ac:	009b      	lsls	r3, r3, #2
  20f9ae:	440b      	add	r3, r1
  20f9b0:	3302      	adds	r3, #2
  20f9b2:	881b      	ldrh	r3, [r3, #0]
  20f9b4:	461c      	mov	r4, r3
  20f9b6:	495a      	ldr	r1, [pc, #360]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f9b8:	68fa      	ldr	r2, [r7, #12]
  20f9ba:	4613      	mov	r3, r2
  20f9bc:	011b      	lsls	r3, r3, #4
  20f9be:	1a9b      	subs	r3, r3, r2
  20f9c0:	009b      	lsls	r3, r3, #2
  20f9c2:	440b      	add	r3, r1
  20f9c4:	3304      	adds	r3, #4
  20f9c6:	881b      	ldrh	r3, [r3, #0]
  20f9c8:	461a      	mov	r2, r3
  20f9ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20f9cc:	18d0      	adds	r0, r2, r3
  20f9ce:	4954      	ldr	r1, [pc, #336]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f9d0:	68fa      	ldr	r2, [r7, #12]
  20f9d2:	4613      	mov	r3, r2
  20f9d4:	011b      	lsls	r3, r3, #4
  20f9d6:	1a9b      	subs	r3, r3, r2
  20f9d8:	009b      	lsls	r3, r3, #2
  20f9da:	440b      	add	r3, r1
  20f9dc:	332e      	adds	r3, #46	; 0x2e
  20f9de:	881b      	ldrh	r3, [r3, #0]
  20f9e0:	4619      	mov	r1, r3
  20f9e2:	6a3a      	ldr	r2, [r7, #32]
  20f9e4:	4b4f      	ldr	r3, [pc, #316]	; (20fb24 <LCD_StrMovHIndirect+0xcfc>)
  20f9e6:	9300      	str	r3, [sp, #0]
  20f9e8:	4613      	mov	r3, r2
  20f9ea:	460a      	mov	r2, r1
  20f9ec:	4601      	mov	r1, r0
  20f9ee:	4620      	mov	r0, r4
  20f9f0:	f7f8 f850 	bl	207a94 <LCD_DisplayBuff>
						break;
  20f9f4:	e35a      	b.n	2100ac <LCD_StrMovHIndirect+0x1284>
					case Rotate_180:
					default:
						LCD_RectangleBuff(pLcd,0,M.yImgHeight,windowWidth_empty,0,0,M.yImgHeight,windowWidth_empty,F.bkColor,F.bkColor,F.bkColor);
  20f9f6:	494a      	ldr	r1, [pc, #296]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20f9f8:	68fa      	ldr	r2, [r7, #12]
  20f9fa:	4613      	mov	r3, r2
  20f9fc:	011b      	lsls	r3, r3, #4
  20f9fe:	1a9b      	subs	r3, r3, r2
  20fa00:	009b      	lsls	r3, r3, #2
  20fa02:	440b      	add	r3, r1
  20fa04:	332e      	adds	r3, #46	; 0x2e
  20fa06:	881b      	ldrh	r3, [r3, #0]
  20fa08:	469e      	mov	lr, r3
  20fa0a:	6a3e      	ldr	r6, [r7, #32]
  20fa0c:	4944      	ldr	r1, [pc, #272]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fa0e:	68fa      	ldr	r2, [r7, #12]
  20fa10:	4613      	mov	r3, r2
  20fa12:	011b      	lsls	r3, r3, #4
  20fa14:	1a9b      	subs	r3, r3, r2
  20fa16:	009b      	lsls	r3, r3, #2
  20fa18:	440b      	add	r3, r1
  20fa1a:	332e      	adds	r3, #46	; 0x2e
  20fa1c:	881b      	ldrh	r3, [r3, #0]
  20fa1e:	607b      	str	r3, [r7, #4]
  20fa20:	6a39      	ldr	r1, [r7, #32]
  20fa22:	483f      	ldr	r0, [pc, #252]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fa24:	68fa      	ldr	r2, [r7, #12]
  20fa26:	4613      	mov	r3, r2
  20fa28:	011b      	lsls	r3, r3, #4
  20fa2a:	1a9b      	subs	r3, r3, r2
  20fa2c:	009b      	lsls	r3, r3, #2
  20fa2e:	4403      	add	r3, r0
  20fa30:	3308      	adds	r3, #8
  20fa32:	6818      	ldr	r0, [r3, #0]
  20fa34:	4c3a      	ldr	r4, [pc, #232]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fa36:	68fa      	ldr	r2, [r7, #12]
  20fa38:	4613      	mov	r3, r2
  20fa3a:	011b      	lsls	r3, r3, #4
  20fa3c:	1a9b      	subs	r3, r3, r2
  20fa3e:	009b      	lsls	r3, r3, #2
  20fa40:	4423      	add	r3, r4
  20fa42:	3308      	adds	r3, #8
  20fa44:	681c      	ldr	r4, [r3, #0]
  20fa46:	4d36      	ldr	r5, [pc, #216]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fa48:	68fa      	ldr	r2, [r7, #12]
  20fa4a:	4613      	mov	r3, r2
  20fa4c:	011b      	lsls	r3, r3, #4
  20fa4e:	1a9b      	subs	r3, r3, r2
  20fa50:	009b      	lsls	r3, r3, #2
  20fa52:	442b      	add	r3, r5
  20fa54:	3308      	adds	r3, #8
  20fa56:	681b      	ldr	r3, [r3, #0]
  20fa58:	9306      	str	r3, [sp, #24]
  20fa5a:	9405      	str	r4, [sp, #20]
  20fa5c:	9004      	str	r0, [sp, #16]
  20fa5e:	9103      	str	r1, [sp, #12]
  20fa60:	687b      	ldr	r3, [r7, #4]
  20fa62:	9302      	str	r3, [sp, #8]
  20fa64:	2300      	movs	r3, #0
  20fa66:	9301      	str	r3, [sp, #4]
  20fa68:	2300      	movs	r3, #0
  20fa6a:	9300      	str	r3, [sp, #0]
  20fa6c:	4633      	mov	r3, r6
  20fa6e:	4672      	mov	r2, lr
  20fa70:	2100      	movs	r1, #0
  20fa72:	482c      	ldr	r0, [pc, #176]	; (20fb24 <LCD_StrMovHIndirect+0xcfc>)
  20fa74:	f7f8 faa2 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, M.yImgHeight, windowWidth_empty, pLcd);
  20fa78:	4929      	ldr	r1, [pc, #164]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fa7a:	68fa      	ldr	r2, [r7, #12]
  20fa7c:	4613      	mov	r3, r2
  20fa7e:	011b      	lsls	r3, r3, #4
  20fa80:	1a9b      	subs	r3, r3, r2
  20fa82:	009b      	lsls	r3, r3, #2
  20fa84:	440b      	add	r3, r1
  20fa86:	3302      	adds	r3, #2
  20fa88:	881b      	ldrh	r3, [r3, #0]
  20fa8a:	4618      	mov	r0, r3
  20fa8c:	4924      	ldr	r1, [pc, #144]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fa8e:	68fa      	ldr	r2, [r7, #12]
  20fa90:	4613      	mov	r3, r2
  20fa92:	011b      	lsls	r3, r3, #4
  20fa94:	1a9b      	subs	r3, r3, r2
  20fa96:	009b      	lsls	r3, r3, #2
  20fa98:	440b      	add	r3, r1
  20fa9a:	3304      	adds	r3, #4
  20fa9c:	881b      	ldrh	r3, [r3, #0]
  20fa9e:	461c      	mov	r4, r3
  20faa0:	491f      	ldr	r1, [pc, #124]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20faa2:	68fa      	ldr	r2, [r7, #12]
  20faa4:	4613      	mov	r3, r2
  20faa6:	011b      	lsls	r3, r3, #4
  20faa8:	1a9b      	subs	r3, r3, r2
  20faaa:	009b      	lsls	r3, r3, #2
  20faac:	440b      	add	r3, r1
  20faae:	332e      	adds	r3, #46	; 0x2e
  20fab0:	881b      	ldrh	r3, [r3, #0]
  20fab2:	4619      	mov	r1, r3
  20fab4:	6a3a      	ldr	r2, [r7, #32]
  20fab6:	4b1b      	ldr	r3, [pc, #108]	; (20fb24 <LCD_StrMovHIndirect+0xcfc>)
  20fab8:	9300      	str	r3, [sp, #0]
  20faba:	4613      	mov	r3, r2
  20fabc:	460a      	mov	r2, r1
  20fabe:	4621      	mov	r1, r4
  20fac0:	f7f7 ffe8 	bl	207a94 <LCD_DisplayBuff>
						break;
  20fac4:	bf00      	nop
  20fac6:	e2f1      	b.n	2100ac <LCD_StrMovHIndirect+0x1284>
				}
			}
		}
		else
		{	int spaceEndStart_new = M.spaceEndStart + windowWidth_new;
  20fac8:	4915      	ldr	r1, [pc, #84]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20faca:	68fa      	ldr	r2, [r7, #12]
  20facc:	4613      	mov	r3, r2
  20face:	011b      	lsls	r3, r3, #4
  20fad0:	1a9b      	subs	r3, r3, r2
  20fad2:	009b      	lsls	r3, r3, #2
  20fad4:	440b      	add	r3, r1
  20fad6:	3338      	adds	r3, #56	; 0x38
  20fad8:	881b      	ldrh	r3, [r3, #0]
  20fada:	461a      	mov	r2, r3
  20fadc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  20fade:	4413      	add	r3, r2
  20fae0:	61fb      	str	r3, [r7, #28]

			if(spaceEndStart_new>0)
  20fae2:	69fb      	ldr	r3, [r7, #28]
  20fae4:	2b00      	cmp	r3, #0
  20fae6:	f340 8225 	ble.w	20ff34 <LCD_StrMovHIndirect+0x110c>
			{	int windowWidth_next = M.windowWidth - spaceEndStart_new;
  20faea:	490d      	ldr	r1, [pc, #52]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20faec:	68fa      	ldr	r2, [r7, #12]
  20faee:	4613      	mov	r3, r2
  20faf0:	011b      	lsls	r3, r3, #4
  20faf2:	1a9b      	subs	r3, r3, r2
  20faf4:	009b      	lsls	r3, r3, #2
  20faf6:	440b      	add	r3, r1
  20faf8:	3332      	adds	r3, #50	; 0x32
  20fafa:	881b      	ldrh	r3, [r3, #0]
  20fafc:	461a      	mov	r2, r3
  20fafe:	69fb      	ldr	r3, [r7, #28]
  20fb00:	1ad3      	subs	r3, r2, r3
  20fb02:	61bb      	str	r3, [r7, #24]

				switch(F.rotate)
  20fb04:	4906      	ldr	r1, [pc, #24]	; (20fb20 <LCD_StrMovHIndirect+0xcf8>)
  20fb06:	68fa      	ldr	r2, [r7, #12]
  20fb08:	4613      	mov	r3, r2
  20fb0a:	011b      	lsls	r3, r3, #4
  20fb0c:	1a9b      	subs	r3, r3, r2
  20fb0e:	009b      	lsls	r3, r3, #2
  20fb10:	440b      	add	r3, r1
  20fb12:	3314      	adds	r3, #20
  20fb14:	781b      	ldrb	r3, [r3, #0]
  20fb16:	2b00      	cmp	r3, #0
  20fb18:	d006      	beq.n	20fb28 <LCD_StrMovHIndirect+0xd00>
  20fb1a:	2b01      	cmp	r3, #1
  20fb1c:	d06d      	beq.n	20fbfa <LCD_StrMovHIndirect+0xdd2>
  20fb1e:	e0d9      	b.n	20fcd4 <LCD_StrMovHIndirect+0xeac>
  20fb20:	2000f818 	.word	0x2000f818
  20fb24:	c0000000 	.word	0xc0000000
				{	case Rotate_0:
						LCD_RectangleBuff(pLcd,0,spaceEndStart_new,M.yImgHeight,0,0,spaceEndStart_new,M.yImgHeight,F.bkColor,F.bkColor,F.bkColor);
  20fb28:	69fe      	ldr	r6, [r7, #28]
  20fb2a:	4968      	ldr	r1, [pc, #416]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fb2c:	68fa      	ldr	r2, [r7, #12]
  20fb2e:	4613      	mov	r3, r2
  20fb30:	011b      	lsls	r3, r3, #4
  20fb32:	1a9b      	subs	r3, r3, r2
  20fb34:	009b      	lsls	r3, r3, #2
  20fb36:	440b      	add	r3, r1
  20fb38:	332e      	adds	r3, #46	; 0x2e
  20fb3a:	881b      	ldrh	r3, [r3, #0]
  20fb3c:	469e      	mov	lr, r3
  20fb3e:	69f9      	ldr	r1, [r7, #28]
  20fb40:	4862      	ldr	r0, [pc, #392]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fb42:	68fa      	ldr	r2, [r7, #12]
  20fb44:	4613      	mov	r3, r2
  20fb46:	011b      	lsls	r3, r3, #4
  20fb48:	1a9b      	subs	r3, r3, r2
  20fb4a:	009b      	lsls	r3, r3, #2
  20fb4c:	4403      	add	r3, r0
  20fb4e:	332e      	adds	r3, #46	; 0x2e
  20fb50:	881b      	ldrh	r3, [r3, #0]
  20fb52:	607b      	str	r3, [r7, #4]
  20fb54:	485d      	ldr	r0, [pc, #372]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fb56:	68fa      	ldr	r2, [r7, #12]
  20fb58:	4613      	mov	r3, r2
  20fb5a:	011b      	lsls	r3, r3, #4
  20fb5c:	1a9b      	subs	r3, r3, r2
  20fb5e:	009b      	lsls	r3, r3, #2
  20fb60:	4403      	add	r3, r0
  20fb62:	3308      	adds	r3, #8
  20fb64:	6818      	ldr	r0, [r3, #0]
  20fb66:	4c59      	ldr	r4, [pc, #356]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fb68:	68fa      	ldr	r2, [r7, #12]
  20fb6a:	4613      	mov	r3, r2
  20fb6c:	011b      	lsls	r3, r3, #4
  20fb6e:	1a9b      	subs	r3, r3, r2
  20fb70:	009b      	lsls	r3, r3, #2
  20fb72:	4423      	add	r3, r4
  20fb74:	3308      	adds	r3, #8
  20fb76:	681c      	ldr	r4, [r3, #0]
  20fb78:	4d54      	ldr	r5, [pc, #336]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fb7a:	68fa      	ldr	r2, [r7, #12]
  20fb7c:	4613      	mov	r3, r2
  20fb7e:	011b      	lsls	r3, r3, #4
  20fb80:	1a9b      	subs	r3, r3, r2
  20fb82:	009b      	lsls	r3, r3, #2
  20fb84:	442b      	add	r3, r5
  20fb86:	3308      	adds	r3, #8
  20fb88:	681b      	ldr	r3, [r3, #0]
  20fb8a:	9306      	str	r3, [sp, #24]
  20fb8c:	9405      	str	r4, [sp, #20]
  20fb8e:	9004      	str	r0, [sp, #16]
  20fb90:	687b      	ldr	r3, [r7, #4]
  20fb92:	9303      	str	r3, [sp, #12]
  20fb94:	9102      	str	r1, [sp, #8]
  20fb96:	2300      	movs	r3, #0
  20fb98:	9301      	str	r3, [sp, #4]
  20fb9a:	2300      	movs	r3, #0
  20fb9c:	9300      	str	r3, [sp, #0]
  20fb9e:	4673      	mov	r3, lr
  20fba0:	4632      	mov	r2, r6
  20fba2:	2100      	movs	r1, #0
  20fba4:	484a      	ldr	r0, [pc, #296]	; (20fcd0 <LCD_StrMovHIndirect+0xea8>)
  20fba6:	f7f8 fa09 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, spaceEndStart_new, M.yImgHeight, pLcd);
  20fbaa:	4948      	ldr	r1, [pc, #288]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fbac:	68fa      	ldr	r2, [r7, #12]
  20fbae:	4613      	mov	r3, r2
  20fbb0:	011b      	lsls	r3, r3, #4
  20fbb2:	1a9b      	subs	r3, r3, r2
  20fbb4:	009b      	lsls	r3, r3, #2
  20fbb6:	440b      	add	r3, r1
  20fbb8:	3302      	adds	r3, #2
  20fbba:	881b      	ldrh	r3, [r3, #0]
  20fbbc:	461c      	mov	r4, r3
  20fbbe:	4943      	ldr	r1, [pc, #268]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fbc0:	68fa      	ldr	r2, [r7, #12]
  20fbc2:	4613      	mov	r3, r2
  20fbc4:	011b      	lsls	r3, r3, #4
  20fbc6:	1a9b      	subs	r3, r3, r2
  20fbc8:	009b      	lsls	r3, r3, #2
  20fbca:	440b      	add	r3, r1
  20fbcc:	3304      	adds	r3, #4
  20fbce:	881b      	ldrh	r3, [r3, #0]
  20fbd0:	461d      	mov	r5, r3
  20fbd2:	69f8      	ldr	r0, [r7, #28]
  20fbd4:	493d      	ldr	r1, [pc, #244]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fbd6:	68fa      	ldr	r2, [r7, #12]
  20fbd8:	4613      	mov	r3, r2
  20fbda:	011b      	lsls	r3, r3, #4
  20fbdc:	1a9b      	subs	r3, r3, r2
  20fbde:	009b      	lsls	r3, r3, #2
  20fbe0:	440b      	add	r3, r1
  20fbe2:	332e      	adds	r3, #46	; 0x2e
  20fbe4:	881b      	ldrh	r3, [r3, #0]
  20fbe6:	461a      	mov	r2, r3
  20fbe8:	4b39      	ldr	r3, [pc, #228]	; (20fcd0 <LCD_StrMovHIndirect+0xea8>)
  20fbea:	9300      	str	r3, [sp, #0]
  20fbec:	4613      	mov	r3, r2
  20fbee:	4602      	mov	r2, r0
  20fbf0:	4629      	mov	r1, r5
  20fbf2:	4620      	mov	r0, r4
  20fbf4:	f7f7 ff4e 	bl	207a94 <LCD_DisplayBuff>
						break;
  20fbf8:	e0d7      	b.n	20fdaa <LCD_StrMovHIndirect+0xf82>
					case Rotate_90:
						LCD_RectangleBuff(pLcd,0,M.yImgHeight,spaceEndStart_new,0,0,M.yImgHeight,spaceEndStart_new,F.bkColor,F.bkColor,F.bkColor);
  20fbfa:	4934      	ldr	r1, [pc, #208]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fbfc:	68fa      	ldr	r2, [r7, #12]
  20fbfe:	4613      	mov	r3, r2
  20fc00:	011b      	lsls	r3, r3, #4
  20fc02:	1a9b      	subs	r3, r3, r2
  20fc04:	009b      	lsls	r3, r3, #2
  20fc06:	440b      	add	r3, r1
  20fc08:	332e      	adds	r3, #46	; 0x2e
  20fc0a:	881b      	ldrh	r3, [r3, #0]
  20fc0c:	469e      	mov	lr, r3
  20fc0e:	69fe      	ldr	r6, [r7, #28]
  20fc10:	492e      	ldr	r1, [pc, #184]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fc12:	68fa      	ldr	r2, [r7, #12]
  20fc14:	4613      	mov	r3, r2
  20fc16:	011b      	lsls	r3, r3, #4
  20fc18:	1a9b      	subs	r3, r3, r2
  20fc1a:	009b      	lsls	r3, r3, #2
  20fc1c:	440b      	add	r3, r1
  20fc1e:	332e      	adds	r3, #46	; 0x2e
  20fc20:	881b      	ldrh	r3, [r3, #0]
  20fc22:	607b      	str	r3, [r7, #4]
  20fc24:	69f9      	ldr	r1, [r7, #28]
  20fc26:	4829      	ldr	r0, [pc, #164]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fc28:	68fa      	ldr	r2, [r7, #12]
  20fc2a:	4613      	mov	r3, r2
  20fc2c:	011b      	lsls	r3, r3, #4
  20fc2e:	1a9b      	subs	r3, r3, r2
  20fc30:	009b      	lsls	r3, r3, #2
  20fc32:	4403      	add	r3, r0
  20fc34:	3308      	adds	r3, #8
  20fc36:	6818      	ldr	r0, [r3, #0]
  20fc38:	4c24      	ldr	r4, [pc, #144]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fc3a:	68fa      	ldr	r2, [r7, #12]
  20fc3c:	4613      	mov	r3, r2
  20fc3e:	011b      	lsls	r3, r3, #4
  20fc40:	1a9b      	subs	r3, r3, r2
  20fc42:	009b      	lsls	r3, r3, #2
  20fc44:	4423      	add	r3, r4
  20fc46:	3308      	adds	r3, #8
  20fc48:	681c      	ldr	r4, [r3, #0]
  20fc4a:	4d20      	ldr	r5, [pc, #128]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fc4c:	68fa      	ldr	r2, [r7, #12]
  20fc4e:	4613      	mov	r3, r2
  20fc50:	011b      	lsls	r3, r3, #4
  20fc52:	1a9b      	subs	r3, r3, r2
  20fc54:	009b      	lsls	r3, r3, #2
  20fc56:	442b      	add	r3, r5
  20fc58:	3308      	adds	r3, #8
  20fc5a:	681b      	ldr	r3, [r3, #0]
  20fc5c:	9306      	str	r3, [sp, #24]
  20fc5e:	9405      	str	r4, [sp, #20]
  20fc60:	9004      	str	r0, [sp, #16]
  20fc62:	9103      	str	r1, [sp, #12]
  20fc64:	687b      	ldr	r3, [r7, #4]
  20fc66:	9302      	str	r3, [sp, #8]
  20fc68:	2300      	movs	r3, #0
  20fc6a:	9301      	str	r3, [sp, #4]
  20fc6c:	2300      	movs	r3, #0
  20fc6e:	9300      	str	r3, [sp, #0]
  20fc70:	4633      	mov	r3, r6
  20fc72:	4672      	mov	r2, lr
  20fc74:	2100      	movs	r1, #0
  20fc76:	4816      	ldr	r0, [pc, #88]	; (20fcd0 <LCD_StrMovHIndirect+0xea8>)
  20fc78:	f7f8 f9a0 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, M.yImgHeight,spaceEndStart_new, pLcd);
  20fc7c:	4913      	ldr	r1, [pc, #76]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fc7e:	68fa      	ldr	r2, [r7, #12]
  20fc80:	4613      	mov	r3, r2
  20fc82:	011b      	lsls	r3, r3, #4
  20fc84:	1a9b      	subs	r3, r3, r2
  20fc86:	009b      	lsls	r3, r3, #2
  20fc88:	440b      	add	r3, r1
  20fc8a:	3302      	adds	r3, #2
  20fc8c:	881b      	ldrh	r3, [r3, #0]
  20fc8e:	4618      	mov	r0, r3
  20fc90:	490e      	ldr	r1, [pc, #56]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fc92:	68fa      	ldr	r2, [r7, #12]
  20fc94:	4613      	mov	r3, r2
  20fc96:	011b      	lsls	r3, r3, #4
  20fc98:	1a9b      	subs	r3, r3, r2
  20fc9a:	009b      	lsls	r3, r3, #2
  20fc9c:	440b      	add	r3, r1
  20fc9e:	3304      	adds	r3, #4
  20fca0:	881b      	ldrh	r3, [r3, #0]
  20fca2:	461c      	mov	r4, r3
  20fca4:	4909      	ldr	r1, [pc, #36]	; (20fccc <LCD_StrMovHIndirect+0xea4>)
  20fca6:	68fa      	ldr	r2, [r7, #12]
  20fca8:	4613      	mov	r3, r2
  20fcaa:	011b      	lsls	r3, r3, #4
  20fcac:	1a9b      	subs	r3, r3, r2
  20fcae:	009b      	lsls	r3, r3, #2
  20fcb0:	440b      	add	r3, r1
  20fcb2:	332e      	adds	r3, #46	; 0x2e
  20fcb4:	881b      	ldrh	r3, [r3, #0]
  20fcb6:	4619      	mov	r1, r3
  20fcb8:	69fa      	ldr	r2, [r7, #28]
  20fcba:	4b05      	ldr	r3, [pc, #20]	; (20fcd0 <LCD_StrMovHIndirect+0xea8>)
  20fcbc:	9300      	str	r3, [sp, #0]
  20fcbe:	4613      	mov	r3, r2
  20fcc0:	460a      	mov	r2, r1
  20fcc2:	4621      	mov	r1, r4
  20fcc4:	f7f7 fee6 	bl	207a94 <LCD_DisplayBuff>
						break;
  20fcc8:	e06f      	b.n	20fdaa <LCD_StrMovHIndirect+0xf82>
  20fcca:	bf00      	nop
  20fccc:	2000f818 	.word	0x2000f818
  20fcd0:	c0000000 	.word	0xc0000000
					case Rotate_180:
					default:
						LCD_RectangleBuff(pLcd,0,M.yImgHeight,spaceEndStart_new,0,0,M.yImgHeight,spaceEndStart_new,F.bkColor,F.bkColor,F.bkColor);
  20fcd4:	4994      	ldr	r1, [pc, #592]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fcd6:	68fa      	ldr	r2, [r7, #12]
  20fcd8:	4613      	mov	r3, r2
  20fcda:	011b      	lsls	r3, r3, #4
  20fcdc:	1a9b      	subs	r3, r3, r2
  20fcde:	009b      	lsls	r3, r3, #2
  20fce0:	440b      	add	r3, r1
  20fce2:	332e      	adds	r3, #46	; 0x2e
  20fce4:	881b      	ldrh	r3, [r3, #0]
  20fce6:	469e      	mov	lr, r3
  20fce8:	69fe      	ldr	r6, [r7, #28]
  20fcea:	498f      	ldr	r1, [pc, #572]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fcec:	68fa      	ldr	r2, [r7, #12]
  20fcee:	4613      	mov	r3, r2
  20fcf0:	011b      	lsls	r3, r3, #4
  20fcf2:	1a9b      	subs	r3, r3, r2
  20fcf4:	009b      	lsls	r3, r3, #2
  20fcf6:	440b      	add	r3, r1
  20fcf8:	332e      	adds	r3, #46	; 0x2e
  20fcfa:	881b      	ldrh	r3, [r3, #0]
  20fcfc:	607b      	str	r3, [r7, #4]
  20fcfe:	69f9      	ldr	r1, [r7, #28]
  20fd00:	4889      	ldr	r0, [pc, #548]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fd02:	68fa      	ldr	r2, [r7, #12]
  20fd04:	4613      	mov	r3, r2
  20fd06:	011b      	lsls	r3, r3, #4
  20fd08:	1a9b      	subs	r3, r3, r2
  20fd0a:	009b      	lsls	r3, r3, #2
  20fd0c:	4403      	add	r3, r0
  20fd0e:	3308      	adds	r3, #8
  20fd10:	6818      	ldr	r0, [r3, #0]
  20fd12:	4c85      	ldr	r4, [pc, #532]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fd14:	68fa      	ldr	r2, [r7, #12]
  20fd16:	4613      	mov	r3, r2
  20fd18:	011b      	lsls	r3, r3, #4
  20fd1a:	1a9b      	subs	r3, r3, r2
  20fd1c:	009b      	lsls	r3, r3, #2
  20fd1e:	4423      	add	r3, r4
  20fd20:	3308      	adds	r3, #8
  20fd22:	681c      	ldr	r4, [r3, #0]
  20fd24:	4d80      	ldr	r5, [pc, #512]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fd26:	68fa      	ldr	r2, [r7, #12]
  20fd28:	4613      	mov	r3, r2
  20fd2a:	011b      	lsls	r3, r3, #4
  20fd2c:	1a9b      	subs	r3, r3, r2
  20fd2e:	009b      	lsls	r3, r3, #2
  20fd30:	442b      	add	r3, r5
  20fd32:	3308      	adds	r3, #8
  20fd34:	681b      	ldr	r3, [r3, #0]
  20fd36:	9306      	str	r3, [sp, #24]
  20fd38:	9405      	str	r4, [sp, #20]
  20fd3a:	9004      	str	r0, [sp, #16]
  20fd3c:	9103      	str	r1, [sp, #12]
  20fd3e:	687b      	ldr	r3, [r7, #4]
  20fd40:	9302      	str	r3, [sp, #8]
  20fd42:	2300      	movs	r3, #0
  20fd44:	9301      	str	r3, [sp, #4]
  20fd46:	2300      	movs	r3, #0
  20fd48:	9300      	str	r3, [sp, #0]
  20fd4a:	4633      	mov	r3, r6
  20fd4c:	4672      	mov	r2, lr
  20fd4e:	2100      	movs	r1, #0
  20fd50:	4876      	ldr	r0, [pc, #472]	; (20ff2c <LCD_StrMovHIndirect+0x1104>)
  20fd52:	f7f8 f933 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos+windowWidth_next, M.yImgHeight,spaceEndStart_new, pLcd);
  20fd56:	4974      	ldr	r1, [pc, #464]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fd58:	68fa      	ldr	r2, [r7, #12]
  20fd5a:	4613      	mov	r3, r2
  20fd5c:	011b      	lsls	r3, r3, #4
  20fd5e:	1a9b      	subs	r3, r3, r2
  20fd60:	009b      	lsls	r3, r3, #2
  20fd62:	440b      	add	r3, r1
  20fd64:	3302      	adds	r3, #2
  20fd66:	881b      	ldrh	r3, [r3, #0]
  20fd68:	461c      	mov	r4, r3
  20fd6a:	496f      	ldr	r1, [pc, #444]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fd6c:	68fa      	ldr	r2, [r7, #12]
  20fd6e:	4613      	mov	r3, r2
  20fd70:	011b      	lsls	r3, r3, #4
  20fd72:	1a9b      	subs	r3, r3, r2
  20fd74:	009b      	lsls	r3, r3, #2
  20fd76:	440b      	add	r3, r1
  20fd78:	3304      	adds	r3, #4
  20fd7a:	881b      	ldrh	r3, [r3, #0]
  20fd7c:	461a      	mov	r2, r3
  20fd7e:	69bb      	ldr	r3, [r7, #24]
  20fd80:	18d0      	adds	r0, r2, r3
  20fd82:	4969      	ldr	r1, [pc, #420]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fd84:	68fa      	ldr	r2, [r7, #12]
  20fd86:	4613      	mov	r3, r2
  20fd88:	011b      	lsls	r3, r3, #4
  20fd8a:	1a9b      	subs	r3, r3, r2
  20fd8c:	009b      	lsls	r3, r3, #2
  20fd8e:	440b      	add	r3, r1
  20fd90:	332e      	adds	r3, #46	; 0x2e
  20fd92:	881b      	ldrh	r3, [r3, #0]
  20fd94:	4619      	mov	r1, r3
  20fd96:	69fa      	ldr	r2, [r7, #28]
  20fd98:	4b64      	ldr	r3, [pc, #400]	; (20ff2c <LCD_StrMovHIndirect+0x1104>)
  20fd9a:	9300      	str	r3, [sp, #0]
  20fd9c:	4613      	mov	r3, r2
  20fd9e:	460a      	mov	r2, r1
  20fda0:	4601      	mov	r1, r0
  20fda2:	4620      	mov	r0, r4
  20fda4:	f7f7 fe76 	bl	207a94 <LCD_DisplayBuff>
						break;
  20fda8:	bf00      	nop
				}

				LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth, M.yImgHeight, 0, windowWidth_next,0);
  20fdaa:	495f      	ldr	r1, [pc, #380]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fdac:	68fa      	ldr	r2, [r7, #12]
  20fdae:	4613      	mov	r3, r2
  20fdb0:	011b      	lsls	r3, r3, #4
  20fdb2:	1a9b      	subs	r3, r3, r2
  20fdb4:	009b      	lsls	r3, r3, #2
  20fdb6:	440b      	add	r3, r1
  20fdb8:	3314      	adds	r3, #20
  20fdba:	781b      	ldrb	r3, [r3, #0]
  20fdbc:	461c      	mov	r4, r3
  20fdbe:	495a      	ldr	r1, [pc, #360]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fdc0:	68fa      	ldr	r2, [r7, #12]
  20fdc2:	4613      	mov	r3, r2
  20fdc4:	011b      	lsls	r3, r3, #4
  20fdc6:	1a9b      	subs	r3, r3, r2
  20fdc8:	009b      	lsls	r3, r3, #2
  20fdca:	440b      	add	r3, r1
  20fdcc:	3328      	adds	r3, #40	; 0x28
  20fdce:	6818      	ldr	r0, [r3, #0]
  20fdd0:	4955      	ldr	r1, [pc, #340]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fdd2:	68fa      	ldr	r2, [r7, #12]
  20fdd4:	4613      	mov	r3, r2
  20fdd6:	011b      	lsls	r3, r3, #4
  20fdd8:	1a9b      	subs	r3, r3, r2
  20fdda:	009b      	lsls	r3, r3, #2
  20fddc:	440b      	add	r3, r1
  20fdde:	332c      	adds	r3, #44	; 0x2c
  20fde0:	881b      	ldrh	r3, [r3, #0]
  20fde2:	461d      	mov	r5, r3
  20fde4:	4950      	ldr	r1, [pc, #320]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fde6:	68fa      	ldr	r2, [r7, #12]
  20fde8:	4613      	mov	r3, r2
  20fdea:	011b      	lsls	r3, r3, #4
  20fdec:	1a9b      	subs	r3, r3, r2
  20fdee:	009b      	lsls	r3, r3, #2
  20fdf0:	440b      	add	r3, r1
  20fdf2:	332e      	adds	r3, #46	; 0x2e
  20fdf4:	881b      	ldrh	r3, [r3, #0]
  20fdf6:	4619      	mov	r1, r3
  20fdf8:	69bb      	ldr	r3, [r7, #24]
  20fdfa:	b29b      	uxth	r3, r3
  20fdfc:	2200      	movs	r2, #0
  20fdfe:	9203      	str	r2, [sp, #12]
  20fe00:	9302      	str	r3, [sp, #8]
  20fe02:	2300      	movs	r3, #0
  20fe04:	9301      	str	r3, [sp, #4]
  20fe06:	9100      	str	r1, [sp, #0]
  20fe08:	462b      	mov	r3, r5
  20fe0a:	4a49      	ldr	r2, [pc, #292]	; (20ff30 <LCD_StrMovHIndirect+0x1108>)
  20fe0c:	4601      	mov	r1, r0
  20fe0e:	4620      	mov	r0, r4
  20fe10:	f7f7 ff6c 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
				switch(F.rotate)
  20fe14:	4944      	ldr	r1, [pc, #272]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fe16:	68fa      	ldr	r2, [r7, #12]
  20fe18:	4613      	mov	r3, r2
  20fe1a:	011b      	lsls	r3, r3, #4
  20fe1c:	1a9b      	subs	r3, r3, r2
  20fe1e:	009b      	lsls	r3, r3, #2
  20fe20:	440b      	add	r3, r1
  20fe22:	3314      	adds	r3, #20
  20fe24:	781b      	ldrb	r3, [r3, #0]
  20fe26:	2b00      	cmp	r3, #0
  20fe28:	d002      	beq.n	20fe30 <LCD_StrMovHIndirect+0x1008>
  20fe2a:	2b01      	cmp	r3, #1
  20fe2c:	d029      	beq.n	20fe82 <LCD_StrMovHIndirect+0x105a>
  20fe2e:	e052      	b.n	20fed6 <LCD_StrMovHIndirect+0x10ae>
				{	case Rotate_0:
						LCD_DisplayBuff((uint32_t)F.xPos+spaceEndStart_new, (uint32_t)F.yPos, windowWidth_next, M.yImgHeight, pLcd);
  20fe30:	493d      	ldr	r1, [pc, #244]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fe32:	68fa      	ldr	r2, [r7, #12]
  20fe34:	4613      	mov	r3, r2
  20fe36:	011b      	lsls	r3, r3, #4
  20fe38:	1a9b      	subs	r3, r3, r2
  20fe3a:	009b      	lsls	r3, r3, #2
  20fe3c:	440b      	add	r3, r1
  20fe3e:	3302      	adds	r3, #2
  20fe40:	881b      	ldrh	r3, [r3, #0]
  20fe42:	461a      	mov	r2, r3
  20fe44:	69fb      	ldr	r3, [r7, #28]
  20fe46:	18d0      	adds	r0, r2, r3
  20fe48:	4937      	ldr	r1, [pc, #220]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fe4a:	68fa      	ldr	r2, [r7, #12]
  20fe4c:	4613      	mov	r3, r2
  20fe4e:	011b      	lsls	r3, r3, #4
  20fe50:	1a9b      	subs	r3, r3, r2
  20fe52:	009b      	lsls	r3, r3, #2
  20fe54:	440b      	add	r3, r1
  20fe56:	3304      	adds	r3, #4
  20fe58:	881b      	ldrh	r3, [r3, #0]
  20fe5a:	461d      	mov	r5, r3
  20fe5c:	69bc      	ldr	r4, [r7, #24]
  20fe5e:	4932      	ldr	r1, [pc, #200]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fe60:	68fa      	ldr	r2, [r7, #12]
  20fe62:	4613      	mov	r3, r2
  20fe64:	011b      	lsls	r3, r3, #4
  20fe66:	1a9b      	subs	r3, r3, r2
  20fe68:	009b      	lsls	r3, r3, #2
  20fe6a:	440b      	add	r3, r1
  20fe6c:	332e      	adds	r3, #46	; 0x2e
  20fe6e:	881b      	ldrh	r3, [r3, #0]
  20fe70:	461a      	mov	r2, r3
  20fe72:	4b2e      	ldr	r3, [pc, #184]	; (20ff2c <LCD_StrMovHIndirect+0x1104>)
  20fe74:	9300      	str	r3, [sp, #0]
  20fe76:	4613      	mov	r3, r2
  20fe78:	4622      	mov	r2, r4
  20fe7a:	4629      	mov	r1, r5
  20fe7c:	f7f7 fe0a 	bl	207a94 <LCD_DisplayBuff>
						break;
  20fe80:	e114      	b.n	2100ac <LCD_StrMovHIndirect+0x1284>
					case Rotate_90:
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos+spaceEndStart_new, M.yImgHeight, windowWidth_next, pLcd);
  20fe82:	4929      	ldr	r1, [pc, #164]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fe84:	68fa      	ldr	r2, [r7, #12]
  20fe86:	4613      	mov	r3, r2
  20fe88:	011b      	lsls	r3, r3, #4
  20fe8a:	1a9b      	subs	r3, r3, r2
  20fe8c:	009b      	lsls	r3, r3, #2
  20fe8e:	440b      	add	r3, r1
  20fe90:	3302      	adds	r3, #2
  20fe92:	881b      	ldrh	r3, [r3, #0]
  20fe94:	461c      	mov	r4, r3
  20fe96:	4924      	ldr	r1, [pc, #144]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fe98:	68fa      	ldr	r2, [r7, #12]
  20fe9a:	4613      	mov	r3, r2
  20fe9c:	011b      	lsls	r3, r3, #4
  20fe9e:	1a9b      	subs	r3, r3, r2
  20fea0:	009b      	lsls	r3, r3, #2
  20fea2:	440b      	add	r3, r1
  20fea4:	3304      	adds	r3, #4
  20fea6:	881b      	ldrh	r3, [r3, #0]
  20fea8:	461a      	mov	r2, r3
  20feaa:	69fb      	ldr	r3, [r7, #28]
  20feac:	18d0      	adds	r0, r2, r3
  20feae:	491e      	ldr	r1, [pc, #120]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20feb0:	68fa      	ldr	r2, [r7, #12]
  20feb2:	4613      	mov	r3, r2
  20feb4:	011b      	lsls	r3, r3, #4
  20feb6:	1a9b      	subs	r3, r3, r2
  20feb8:	009b      	lsls	r3, r3, #2
  20feba:	440b      	add	r3, r1
  20febc:	332e      	adds	r3, #46	; 0x2e
  20febe:	881b      	ldrh	r3, [r3, #0]
  20fec0:	4619      	mov	r1, r3
  20fec2:	69ba      	ldr	r2, [r7, #24]
  20fec4:	4b19      	ldr	r3, [pc, #100]	; (20ff2c <LCD_StrMovHIndirect+0x1104>)
  20fec6:	9300      	str	r3, [sp, #0]
  20fec8:	4613      	mov	r3, r2
  20feca:	460a      	mov	r2, r1
  20fecc:	4601      	mov	r1, r0
  20fece:	4620      	mov	r0, r4
  20fed0:	f7f7 fde0 	bl	207a94 <LCD_DisplayBuff>
						break;
  20fed4:	e0ea      	b.n	2100ac <LCD_StrMovHIndirect+0x1284>
					case Rotate_180:
					default:
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, M.yImgHeight, windowWidth_next, pLcd);
  20fed6:	4914      	ldr	r1, [pc, #80]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20fed8:	68fa      	ldr	r2, [r7, #12]
  20feda:	4613      	mov	r3, r2
  20fedc:	011b      	lsls	r3, r3, #4
  20fede:	1a9b      	subs	r3, r3, r2
  20fee0:	009b      	lsls	r3, r3, #2
  20fee2:	440b      	add	r3, r1
  20fee4:	3302      	adds	r3, #2
  20fee6:	881b      	ldrh	r3, [r3, #0]
  20fee8:	4618      	mov	r0, r3
  20feea:	490f      	ldr	r1, [pc, #60]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20feec:	68fa      	ldr	r2, [r7, #12]
  20feee:	4613      	mov	r3, r2
  20fef0:	011b      	lsls	r3, r3, #4
  20fef2:	1a9b      	subs	r3, r3, r2
  20fef4:	009b      	lsls	r3, r3, #2
  20fef6:	440b      	add	r3, r1
  20fef8:	3304      	adds	r3, #4
  20fefa:	881b      	ldrh	r3, [r3, #0]
  20fefc:	461c      	mov	r4, r3
  20fefe:	490a      	ldr	r1, [pc, #40]	; (20ff28 <LCD_StrMovHIndirect+0x1100>)
  20ff00:	68fa      	ldr	r2, [r7, #12]
  20ff02:	4613      	mov	r3, r2
  20ff04:	011b      	lsls	r3, r3, #4
  20ff06:	1a9b      	subs	r3, r3, r2
  20ff08:	009b      	lsls	r3, r3, #2
  20ff0a:	440b      	add	r3, r1
  20ff0c:	332e      	adds	r3, #46	; 0x2e
  20ff0e:	881b      	ldrh	r3, [r3, #0]
  20ff10:	4619      	mov	r1, r3
  20ff12:	69ba      	ldr	r2, [r7, #24]
  20ff14:	4b05      	ldr	r3, [pc, #20]	; (20ff2c <LCD_StrMovHIndirect+0x1104>)
  20ff16:	9300      	str	r3, [sp, #0]
  20ff18:	4613      	mov	r3, r2
  20ff1a:	460a      	mov	r2, r1
  20ff1c:	4621      	mov	r1, r4
  20ff1e:	f7f7 fdb9 	bl	207a94 <LCD_DisplayBuff>
						break;
  20ff22:	bf00      	nop
  20ff24:	e0c2      	b.n	2100ac <LCD_StrMovHIndirect+0x1284>
  20ff26:	bf00      	nop
  20ff28:	2000f818 	.word	0x2000f818
  20ff2c:	c0000000 	.word	0xc0000000
  20ff30:	c067f800 	.word	0xc067f800
				}
			}
			else{
				M.posWin=0;
  20ff34:	4960      	ldr	r1, [pc, #384]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ff36:	68fa      	ldr	r2, [r7, #12]
  20ff38:	4613      	mov	r3, r2
  20ff3a:	011b      	lsls	r3, r3, #4
  20ff3c:	1a9b      	subs	r3, r3, r2
  20ff3e:	009b      	lsls	r3, r3, #2
  20ff40:	440b      	add	r3, r1
  20ff42:	3330      	adds	r3, #48	; 0x30
  20ff44:	2200      	movs	r2, #0
  20ff46:	801a      	strh	r2, [r3, #0]
				LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth, M.yImgHeight, M.posWin, M.windowWidth,0);
  20ff48:	495b      	ldr	r1, [pc, #364]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ff4a:	68fa      	ldr	r2, [r7, #12]
  20ff4c:	4613      	mov	r3, r2
  20ff4e:	011b      	lsls	r3, r3, #4
  20ff50:	1a9b      	subs	r3, r3, r2
  20ff52:	009b      	lsls	r3, r3, #2
  20ff54:	440b      	add	r3, r1
  20ff56:	3314      	adds	r3, #20
  20ff58:	781b      	ldrb	r3, [r3, #0]
  20ff5a:	461e      	mov	r6, r3
  20ff5c:	4956      	ldr	r1, [pc, #344]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ff5e:	68fa      	ldr	r2, [r7, #12]
  20ff60:	4613      	mov	r3, r2
  20ff62:	011b      	lsls	r3, r3, #4
  20ff64:	1a9b      	subs	r3, r3, r2
  20ff66:	009b      	lsls	r3, r3, #2
  20ff68:	440b      	add	r3, r1
  20ff6a:	3328      	adds	r3, #40	; 0x28
  20ff6c:	6818      	ldr	r0, [r3, #0]
  20ff6e:	4952      	ldr	r1, [pc, #328]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ff70:	68fa      	ldr	r2, [r7, #12]
  20ff72:	4613      	mov	r3, r2
  20ff74:	011b      	lsls	r3, r3, #4
  20ff76:	1a9b      	subs	r3, r3, r2
  20ff78:	009b      	lsls	r3, r3, #2
  20ff7a:	440b      	add	r3, r1
  20ff7c:	332c      	adds	r3, #44	; 0x2c
  20ff7e:	881b      	ldrh	r3, [r3, #0]
  20ff80:	469e      	mov	lr, r3
  20ff82:	494d      	ldr	r1, [pc, #308]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ff84:	68fa      	ldr	r2, [r7, #12]
  20ff86:	4613      	mov	r3, r2
  20ff88:	011b      	lsls	r3, r3, #4
  20ff8a:	1a9b      	subs	r3, r3, r2
  20ff8c:	009b      	lsls	r3, r3, #2
  20ff8e:	440b      	add	r3, r1
  20ff90:	332e      	adds	r3, #46	; 0x2e
  20ff92:	881b      	ldrh	r3, [r3, #0]
  20ff94:	461c      	mov	r4, r3
  20ff96:	4948      	ldr	r1, [pc, #288]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ff98:	68fa      	ldr	r2, [r7, #12]
  20ff9a:	4613      	mov	r3, r2
  20ff9c:	011b      	lsls	r3, r3, #4
  20ff9e:	1a9b      	subs	r3, r3, r2
  20ffa0:	009b      	lsls	r3, r3, #2
  20ffa2:	440b      	add	r3, r1
  20ffa4:	3330      	adds	r3, #48	; 0x30
  20ffa6:	881b      	ldrh	r3, [r3, #0]
  20ffa8:	461d      	mov	r5, r3
  20ffaa:	4943      	ldr	r1, [pc, #268]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ffac:	68fa      	ldr	r2, [r7, #12]
  20ffae:	4613      	mov	r3, r2
  20ffb0:	011b      	lsls	r3, r3, #4
  20ffb2:	1a9b      	subs	r3, r3, r2
  20ffb4:	009b      	lsls	r3, r3, #2
  20ffb6:	440b      	add	r3, r1
  20ffb8:	3332      	adds	r3, #50	; 0x32
  20ffba:	881b      	ldrh	r3, [r3, #0]
  20ffbc:	2200      	movs	r2, #0
  20ffbe:	9203      	str	r2, [sp, #12]
  20ffc0:	9302      	str	r3, [sp, #8]
  20ffc2:	9501      	str	r5, [sp, #4]
  20ffc4:	9400      	str	r4, [sp, #0]
  20ffc6:	4673      	mov	r3, lr
  20ffc8:	4a3c      	ldr	r2, [pc, #240]	; (2100bc <LCD_StrMovHIndirect+0x1294>)
  20ffca:	4601      	mov	r1, r0
  20ffcc:	4630      	mov	r0, r6
  20ffce:	f7f7 fe8d 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
				switch(F.rotate)
  20ffd2:	4939      	ldr	r1, [pc, #228]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ffd4:	68fa      	ldr	r2, [r7, #12]
  20ffd6:	4613      	mov	r3, r2
  20ffd8:	011b      	lsls	r3, r3, #4
  20ffda:	1a9b      	subs	r3, r3, r2
  20ffdc:	009b      	lsls	r3, r3, #2
  20ffde:	440b      	add	r3, r1
  20ffe0:	3314      	adds	r3, #20
  20ffe2:	781b      	ldrb	r3, [r3, #0]
  20ffe4:	2b00      	cmp	r3, #0
  20ffe6:	d12f      	bne.n	210048 <LCD_StrMovHIndirect+0x1220>
				{	case Rotate_0:
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, M.windowWidth, M.yImgHeight, pLcd);
  20ffe8:	4933      	ldr	r1, [pc, #204]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20ffea:	68fa      	ldr	r2, [r7, #12]
  20ffec:	4613      	mov	r3, r2
  20ffee:	011b      	lsls	r3, r3, #4
  20fff0:	1a9b      	subs	r3, r3, r2
  20fff2:	009b      	lsls	r3, r3, #2
  20fff4:	440b      	add	r3, r1
  20fff6:	3302      	adds	r3, #2
  20fff8:	881b      	ldrh	r3, [r3, #0]
  20fffa:	4618      	mov	r0, r3
  20fffc:	492e      	ldr	r1, [pc, #184]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  20fffe:	68fa      	ldr	r2, [r7, #12]
  210000:	4613      	mov	r3, r2
  210002:	011b      	lsls	r3, r3, #4
  210004:	1a9b      	subs	r3, r3, r2
  210006:	009b      	lsls	r3, r3, #2
  210008:	440b      	add	r3, r1
  21000a:	3304      	adds	r3, #4
  21000c:	881b      	ldrh	r3, [r3, #0]
  21000e:	461c      	mov	r4, r3
  210010:	4929      	ldr	r1, [pc, #164]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  210012:	68fa      	ldr	r2, [r7, #12]
  210014:	4613      	mov	r3, r2
  210016:	011b      	lsls	r3, r3, #4
  210018:	1a9b      	subs	r3, r3, r2
  21001a:	009b      	lsls	r3, r3, #2
  21001c:	440b      	add	r3, r1
  21001e:	3332      	adds	r3, #50	; 0x32
  210020:	881b      	ldrh	r3, [r3, #0]
  210022:	461d      	mov	r5, r3
  210024:	4924      	ldr	r1, [pc, #144]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  210026:	68fa      	ldr	r2, [r7, #12]
  210028:	4613      	mov	r3, r2
  21002a:	011b      	lsls	r3, r3, #4
  21002c:	1a9b      	subs	r3, r3, r2
  21002e:	009b      	lsls	r3, r3, #2
  210030:	440b      	add	r3, r1
  210032:	332e      	adds	r3, #46	; 0x2e
  210034:	881b      	ldrh	r3, [r3, #0]
  210036:	461a      	mov	r2, r3
  210038:	4b21      	ldr	r3, [pc, #132]	; (2100c0 <LCD_StrMovHIndirect+0x1298>)
  21003a:	9300      	str	r3, [sp, #0]
  21003c:	4613      	mov	r3, r2
  21003e:	462a      	mov	r2, r5
  210040:	4621      	mov	r1, r4
  210042:	f7f7 fd27 	bl	207a94 <LCD_DisplayBuff>
						break;
  210046:	e02f      	b.n	2100a8 <LCD_StrMovHIndirect+0x1280>
					case Rotate_90:
					case Rotate_180:
					default:
						LCD_DisplayBuff((uint32_t)F.xPos, (uint32_t)F.yPos, M.yImgHeight, M.windowWidth, pLcd);
  210048:	491b      	ldr	r1, [pc, #108]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  21004a:	68fa      	ldr	r2, [r7, #12]
  21004c:	4613      	mov	r3, r2
  21004e:	011b      	lsls	r3, r3, #4
  210050:	1a9b      	subs	r3, r3, r2
  210052:	009b      	lsls	r3, r3, #2
  210054:	440b      	add	r3, r1
  210056:	3302      	adds	r3, #2
  210058:	881b      	ldrh	r3, [r3, #0]
  21005a:	4618      	mov	r0, r3
  21005c:	4916      	ldr	r1, [pc, #88]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  21005e:	68fa      	ldr	r2, [r7, #12]
  210060:	4613      	mov	r3, r2
  210062:	011b      	lsls	r3, r3, #4
  210064:	1a9b      	subs	r3, r3, r2
  210066:	009b      	lsls	r3, r3, #2
  210068:	440b      	add	r3, r1
  21006a:	3304      	adds	r3, #4
  21006c:	881b      	ldrh	r3, [r3, #0]
  21006e:	461c      	mov	r4, r3
  210070:	4911      	ldr	r1, [pc, #68]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  210072:	68fa      	ldr	r2, [r7, #12]
  210074:	4613      	mov	r3, r2
  210076:	011b      	lsls	r3, r3, #4
  210078:	1a9b      	subs	r3, r3, r2
  21007a:	009b      	lsls	r3, r3, #2
  21007c:	440b      	add	r3, r1
  21007e:	332e      	adds	r3, #46	; 0x2e
  210080:	881b      	ldrh	r3, [r3, #0]
  210082:	461d      	mov	r5, r3
  210084:	490c      	ldr	r1, [pc, #48]	; (2100b8 <LCD_StrMovHIndirect+0x1290>)
  210086:	68fa      	ldr	r2, [r7, #12]
  210088:	4613      	mov	r3, r2
  21008a:	011b      	lsls	r3, r3, #4
  21008c:	1a9b      	subs	r3, r3, r2
  21008e:	009b      	lsls	r3, r3, #2
  210090:	440b      	add	r3, r1
  210092:	3332      	adds	r3, #50	; 0x32
  210094:	881b      	ldrh	r3, [r3, #0]
  210096:	461a      	mov	r2, r3
  210098:	4b09      	ldr	r3, [pc, #36]	; (2100c0 <LCD_StrMovHIndirect+0x1298>)
  21009a:	9300      	str	r3, [sp, #0]
  21009c:	4613      	mov	r3, r2
  21009e:	462a      	mov	r2, r5
  2100a0:	4621      	mov	r1, r4
  2100a2:	f7f7 fcf7 	bl	207a94 <LCD_DisplayBuff>
						break;
  2100a6:	bf00      	nop
				}
				return 1;
  2100a8:	2301      	movs	r3, #1
  2100aa:	e000      	b.n	2100ae <LCD_StrMovHIndirect+0x1286>
			}
		}
	}
	return 0;
  2100ac:	2300      	movs	r3, #0
}
  2100ae:	4618      	mov	r0, r3
  2100b0:	372c      	adds	r7, #44	; 0x2c
  2100b2:	46bd      	mov	sp, r7
  2100b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2100b6:	bf00      	nop
  2100b8:	2000f818 	.word	0x2000f818
  2100bc:	c067f800 	.word	0xc067f800
  2100c0:	c0000000 	.word	0xc0000000

002100c4 <LCD_StrMovV>:

StructTxtPxlLen LCD_StrMovV(int idVar, int rot, int posWin, int winWidth,int winHeight, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, int coeff, int constWidth)
{
  2100c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  2100c8:	b09e      	sub	sp, #120	; 0x78
  2100ca:	af0a      	add	r7, sp, #40	; 0x28
  2100cc:	6178      	str	r0, [r7, #20]
  2100ce:	6139      	str	r1, [r7, #16]
  2100d0:	60fa      	str	r2, [r7, #12]
  2100d2:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;

	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  2100d4:	693b      	ldr	r3, [r7, #16]
  2100d6:	2b27      	cmp	r3, #39	; 0x27
  2100d8:	f300 831d 	bgt.w	210716 <LCD_StrMovV+0x652>
	{
  2100dc:	466b      	mov	r3, sp
  2100de:	469a      	mov	sl, r3
		int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  2100e0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  2100e4:	f113 0f03 	cmn.w	r3, #3
  2100e8:	d104      	bne.n	2100f4 <LCD_StrMovV+0x30>
  2100ea:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  2100ec:	f002 f982 	bl	2123f4 <LCD_GetFontHeight>
  2100f0:	4603      	mov	r3, r0
  2100f2:	e003      	b.n	2100fc <LCD_StrMovV+0x38>
  2100f4:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  2100f6:	f002 f9b9 	bl	21246c <LCD_GetFontHalfHeight>
  2100fa:	4603      	mov	r3, r0
  2100fc:	643b      	str	r3, [r7, #64]	; 0x40
		if(fontHeight<0)
  2100fe:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210100:	2b00      	cmp	r3, #0
  210102:	da06      	bge.n	210112 <LCD_StrMovV+0x4e>
			return StructTxtPxlLen_ZeroValue;
  210104:	697b      	ldr	r3, [r7, #20]
  210106:	4a9f      	ldr	r2, [pc, #636]	; (210384 <LCD_StrMovV+0x2c0>)
  210108:	6810      	ldr	r0, [r2, #0]
  21010a:	6018      	str	r0, [r3, #0]
  21010c:	8892      	ldrh	r2, [r2, #4]
  21010e:	809a      	strh	r2, [r3, #4]
  210110:	e2ff      	b.n	210712 <LCD_StrMovV+0x64e>
		int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  210112:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  210116:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  21011a:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  21011e:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  210120:	f001 ffd4 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  210124:	63f8      	str	r0, [r7, #60]	; 0x3c

		int posMovBuff_copy = movableFontsBuffer_pos + fontHeight*pxlTxtLen;
  210126:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210128:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  21012a:	fb02 f203 	mul.w	r2, r2, r3
  21012e:	4b96      	ldr	r3, [pc, #600]	; (210388 <LCD_StrMovV+0x2c4>)
  210130:	681b      	ldr	r3, [r3, #0]
  210132:	4413      	add	r3, r2
  210134:	63bb      	str	r3, [r7, #56]	; 0x38
		if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  210136:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  210138:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  21013c:	db06      	blt.n	21014c <LCD_StrMovV+0x88>
			return StructTxtPxlLen_ZeroValue;
  21013e:	697b      	ldr	r3, [r7, #20]
  210140:	4a90      	ldr	r2, [pc, #576]	; (210384 <LCD_StrMovV+0x2c0>)
  210142:	6810      	ldr	r0, [r2, #0]
  210144:	6018      	str	r0, [r3, #0]
  210146:	8892      	ldrh	r2, [r2, #4]
  210148:	809a      	strh	r2, [r3, #4]
  21014a:	e2e2      	b.n	210712 <LCD_StrMovV+0x64e>

		int i=0,it=0,iH=0,j;
  21014c:	2300      	movs	r3, #0
  21014e:	637b      	str	r3, [r7, #52]	; 0x34
  210150:	2300      	movs	r3, #0
  210152:	64fb      	str	r3, [r7, #76]	; 0x4c
  210154:	2300      	movs	r3, #0
  210156:	64bb      	str	r3, [r7, #72]	; 0x48
		char bufTxt[winWidth/LCD_GetFontWidth(fontID,'1')];
  210158:	2131      	movs	r1, #49	; 0x31
  21015a:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  21015c:	f002 f90c 	bl	212378 <LCD_GetFontWidth>
  210160:	4602      	mov	r2, r0
  210162:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210164:	fb93 f6f2 	sdiv	r6, r3, r2
  210168:	1e73      	subs	r3, r6, #1
  21016a:	633b      	str	r3, [r7, #48]	; 0x30
  21016c:	4633      	mov	r3, r6
  21016e:	461a      	mov	r2, r3
  210170:	f04f 0300 	mov.w	r3, #0
  210174:	ea4f 09c3 	mov.w	r9, r3, lsl #3
  210178:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
  21017c:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  210180:	4633      	mov	r3, r6
  210182:	461a      	mov	r2, r3
  210184:	f04f 0300 	mov.w	r3, #0
  210188:	00dd      	lsls	r5, r3, #3
  21018a:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
  21018e:	00d4      	lsls	r4, r2, #3
  210190:	4633      	mov	r3, r6
  210192:	3307      	adds	r3, #7
  210194:	08db      	lsrs	r3, r3, #3
  210196:	00db      	lsls	r3, r3, #3
  210198:	ebad 0d03 	sub.w	sp, sp, r3
  21019c:	ab0a      	add	r3, sp, #40	; 0x28
  21019e:	3300      	adds	r3, #0
  2101a0:	62fb      	str	r3, [r7, #44]	; 0x2c

		FontVar[idVar].id=fontID;
  2101a2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  2101a4:	b298      	uxth	r0, r3
  2101a6:	4979      	ldr	r1, [pc, #484]	; (21038c <LCD_StrMovV+0x2c8>)
  2101a8:	693a      	ldr	r2, [r7, #16]
  2101aa:	4613      	mov	r3, r2
  2101ac:	011b      	lsls	r3, r3, #4
  2101ae:	1a9b      	subs	r3, r3, r2
  2101b0:	009b      	lsls	r3, r3, #2
  2101b2:	440b      	add	r3, r1
  2101b4:	4602      	mov	r2, r0
  2101b6:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].xPos=Xpos;
  2101b8:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2101ba:	b298      	uxth	r0, r3
  2101bc:	4973      	ldr	r1, [pc, #460]	; (21038c <LCD_StrMovV+0x2c8>)
  2101be:	693a      	ldr	r2, [r7, #16]
  2101c0:	4613      	mov	r3, r2
  2101c2:	011b      	lsls	r3, r3, #4
  2101c4:	1a9b      	subs	r3, r3, r2
  2101c6:	009b      	lsls	r3, r3, #2
  2101c8:	440b      	add	r3, r1
  2101ca:	3302      	adds	r3, #2
  2101cc:	4602      	mov	r2, r0
  2101ce:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos=Ypos;
  2101d0:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  2101d4:	b298      	uxth	r0, r3
  2101d6:	496d      	ldr	r1, [pc, #436]	; (21038c <LCD_StrMovV+0x2c8>)
  2101d8:	693a      	ldr	r2, [r7, #16]
  2101da:	4613      	mov	r3, r2
  2101dc:	011b      	lsls	r3, r3, #4
  2101de:	1a9b      	subs	r3, r3, r2
  2101e0:	009b      	lsls	r3, r3, #2
  2101e2:	440b      	add	r3, r1
  2101e4:	3304      	adds	r3, #4
  2101e6:	4602      	mov	r2, r0
  2101e8:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightType=OnlyDigits;
  2101ea:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  2101ee:	b258      	sxtb	r0, r3
  2101f0:	4966      	ldr	r1, [pc, #408]	; (21038c <LCD_StrMovV+0x2c8>)
  2101f2:	693a      	ldr	r2, [r7, #16]
  2101f4:	4613      	mov	r3, r2
  2101f6:	011b      	lsls	r3, r3, #4
  2101f8:	1a9b      	subs	r3, r3, r2
  2101fa:	009b      	lsls	r3, r3, #2
  2101fc:	440b      	add	r3, r1
  2101fe:	3306      	adds	r3, #6
  210200:	4602      	mov	r2, r0
  210202:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].space=space;
  210204:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  210208:	b2d8      	uxtb	r0, r3
  21020a:	4960      	ldr	r1, [pc, #384]	; (21038c <LCD_StrMovV+0x2c8>)
  21020c:	693a      	ldr	r2, [r7, #16]
  21020e:	4613      	mov	r3, r2
  210210:	011b      	lsls	r3, r3, #4
  210212:	1a9b      	subs	r3, r3, r2
  210214:	009b      	lsls	r3, r3, #2
  210216:	440b      	add	r3, r1
  210218:	3307      	adds	r3, #7
  21021a:	4602      	mov	r2, r0
  21021c:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].bkColor=bkColor;
  21021e:	495b      	ldr	r1, [pc, #364]	; (21038c <LCD_StrMovV+0x2c8>)
  210220:	693a      	ldr	r2, [r7, #16]
  210222:	4613      	mov	r3, r2
  210224:	011b      	lsls	r3, r3, #4
  210226:	1a9b      	subs	r3, r3, r2
  210228:	009b      	lsls	r3, r3, #2
  21022a:	440b      	add	r3, r1
  21022c:	3308      	adds	r3, #8
  21022e:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  210232:	601a      	str	r2, [r3, #0]
		FontVar[idVar].coeff=coeff;
  210234:	4955      	ldr	r1, [pc, #340]	; (21038c <LCD_StrMovV+0x2c8>)
  210236:	693a      	ldr	r2, [r7, #16]
  210238:	4613      	mov	r3, r2
  21023a:	011b      	lsls	r3, r3, #4
  21023c:	1a9b      	subs	r3, r3, r2
  21023e:	009b      	lsls	r3, r3, #2
  210240:	440b      	add	r3, r1
  210242:	3318      	adds	r3, #24
  210244:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
  210248:	601a      	str	r2, [r3, #0]
		FontVar[idVar].widthType=constWidth;
  21024a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  21024e:	b2d8      	uxtb	r0, r3
  210250:	494e      	ldr	r1, [pc, #312]	; (21038c <LCD_StrMovV+0x2c8>)
  210252:	693a      	ldr	r2, [r7, #16]
  210254:	4613      	mov	r3, r2
  210256:	011b      	lsls	r3, r3, #4
  210258:	1a9b      	subs	r3, r3, r2
  21025a:	009b      	lsls	r3, r3, #2
  21025c:	440b      	add	r3, r1
  21025e:	331c      	adds	r3, #28
  210260:	4602      	mov	r2, r0
  210262:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].rotate=rot;
  210264:	68fb      	ldr	r3, [r7, #12]
  210266:	b2d8      	uxtb	r0, r3
  210268:	4948      	ldr	r1, [pc, #288]	; (21038c <LCD_StrMovV+0x2c8>)
  21026a:	693a      	ldr	r2, [r7, #16]
  21026c:	4613      	mov	r3, r2
  21026e:	011b      	lsls	r3, r3, #4
  210270:	1a9b      	subs	r3, r3, r2
  210272:	009b      	lsls	r3, r3, #2
  210274:	440b      	add	r3, r1
  210276:	3314      	adds	r3, #20
  210278:	4602      	mov	r2, r0
  21027a:	701a      	strb	r2, [r3, #0]

		FontVar[idVar].FontMov.xImgWidth=winWidth;
  21027c:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  21027e:	b298      	uxth	r0, r3
  210280:	4942      	ldr	r1, [pc, #264]	; (21038c <LCD_StrMovV+0x2c8>)
  210282:	693a      	ldr	r2, [r7, #16]
  210284:	4613      	mov	r3, r2
  210286:	011b      	lsls	r3, r3, #4
  210288:	1a9b      	subs	r3, r3, r2
  21028a:	009b      	lsls	r3, r3, #2
  21028c:	440b      	add	r3, r1
  21028e:	332c      	adds	r3, #44	; 0x2c
  210290:	4602      	mov	r2, r0
  210292:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posWin=posWin;
  210294:	68bb      	ldr	r3, [r7, #8]
  210296:	b298      	uxth	r0, r3
  210298:	493c      	ldr	r1, [pc, #240]	; (21038c <LCD_StrMovV+0x2c8>)
  21029a:	693a      	ldr	r2, [r7, #16]
  21029c:	4613      	mov	r3, r2
  21029e:	011b      	lsls	r3, r3, #4
  2102a0:	1a9b      	subs	r3, r3, r2
  2102a2:	009b      	lsls	r3, r3, #2
  2102a4:	440b      	add	r3, r1
  2102a6:	3330      	adds	r3, #48	; 0x30
  2102a8:	4602      	mov	r2, r0
  2102aa:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.windowWidth=winWidth;
  2102ac:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2102ae:	b298      	uxth	r0, r3
  2102b0:	4936      	ldr	r1, [pc, #216]	; (21038c <LCD_StrMovV+0x2c8>)
  2102b2:	693a      	ldr	r2, [r7, #16]
  2102b4:	4613      	mov	r3, r2
  2102b6:	011b      	lsls	r3, r3, #4
  2102b8:	1a9b      	subs	r3, r3, r2
  2102ba:	009b      	lsls	r3, r3, #2
  2102bc:	440b      	add	r3, r1
  2102be:	3332      	adds	r3, #50	; 0x32
  2102c0:	4602      	mov	r2, r0
  2102c2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.windowHeight = winHeight;
  2102c4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  2102c6:	b298      	uxth	r0, r3
  2102c8:	4930      	ldr	r1, [pc, #192]	; (21038c <LCD_StrMovV+0x2c8>)
  2102ca:	693a      	ldr	r2, [r7, #16]
  2102cc:	4613      	mov	r3, r2
  2102ce:	011b      	lsls	r3, r3, #4
  2102d0:	1a9b      	subs	r3, r3, r2
  2102d2:	009b      	lsls	r3, r3, #2
  2102d4:	440b      	add	r3, r1
  2102d6:	3334      	adds	r3, #52	; 0x34
  2102d8:	4602      	mov	r2, r0
  2102da:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.spaceEndStart=fontHeight;
  2102dc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2102de:	b298      	uxth	r0, r3
  2102e0:	492a      	ldr	r1, [pc, #168]	; (21038c <LCD_StrMovV+0x2c8>)
  2102e2:	693a      	ldr	r2, [r7, #16]
  2102e4:	4613      	mov	r3, r2
  2102e6:	011b      	lsls	r3, r3, #4
  2102e8:	1a9b      	subs	r3, r3, r2
  2102ea:	009b      	lsls	r3, r3, #2
  2102ec:	440b      	add	r3, r1
  2102ee:	3338      	adds	r3, #56	; 0x38
  2102f0:	4602      	mov	r2, r0
  2102f2:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posBuff=movableFontsBuffer_pos;
  2102f4:	4b24      	ldr	r3, [pc, #144]	; (210388 <LCD_StrMovV+0x2c4>)
  2102f6:	681b      	ldr	r3, [r3, #0]
  2102f8:	4618      	mov	r0, r3
  2102fa:	4924      	ldr	r1, [pc, #144]	; (21038c <LCD_StrMovV+0x2c8>)
  2102fc:	693a      	ldr	r2, [r7, #16]
  2102fe:	4613      	mov	r3, r2
  210300:	011b      	lsls	r3, r3, #4
  210302:	1a9b      	subs	r3, r3, r2
  210304:	009b      	lsls	r3, r3, #2
  210306:	440b      	add	r3, r1
  210308:	3328      	adds	r3, #40	; 0x28
  21030a:	6018      	str	r0, [r3, #0]

		do
		{	if(iH>0){ if(txt[it]==' ') it++; }
  21030c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  21030e:	2b00      	cmp	r3, #0
  210310:	dd09      	ble.n	210326 <LCD_StrMovV+0x262>
  210312:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  210314:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  210318:	4413      	add	r3, r2
  21031a:	781b      	ldrb	r3, [r3, #0]
  21031c:	2b20      	cmp	r3, #32
  21031e:	d102      	bne.n	210326 <LCD_StrMovV+0x262>
  210320:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  210322:	3301      	adds	r3, #1
  210324:	64fb      	str	r3, [r7, #76]	; 0x4c
			i= LCD_GetStrLenForPxlWidth(fontID,&txt[it],winWidth,space,constWidth);
  210326:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  210328:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  21032c:	18d1      	adds	r1, r2, r3
  21032e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
  210332:	9300      	str	r3, [sp, #0]
  210334:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  210338:	6f3a      	ldr	r2, [r7, #112]	; 0x70
  21033a:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  21033c:	f001 ffa0 	bl	212280 <LCD_GetStrLenForPxlWidth>
  210340:	6378      	str	r0, [r7, #52]	; 0x34
			if(i==0) break;
  210342:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  210344:	2b00      	cmp	r3, #0
  210346:	f000 80b9 	beq.w	2104bc <LCD_StrMovV+0x3f8>
			for(j=0;j<i;++j)
  21034a:	2300      	movs	r3, #0
  21034c:	647b      	str	r3, [r7, #68]	; 0x44
  21034e:	e014      	b.n	21037a <LCD_StrMovV+0x2b6>
			{	if(j==sizeof(bufTxt)-1)
  210350:	4633      	mov	r3, r6
  210352:	1e5a      	subs	r2, r3, #1
  210354:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  210356:	429a      	cmp	r2, r3
  210358:	d01a      	beq.n	210390 <LCD_StrMovV+0x2cc>
					break;
				bufTxt[j]=txt[it+j];
  21035a:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  21035c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  21035e:	4413      	add	r3, r2
  210360:	461a      	mov	r2, r3
  210362:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  210366:	4413      	add	r3, r2
  210368:	7819      	ldrb	r1, [r3, #0]
  21036a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  21036c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  21036e:	4413      	add	r3, r2
  210370:	460a      	mov	r2, r1
  210372:	701a      	strb	r2, [r3, #0]
			for(j=0;j<i;++j)
  210374:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  210376:	3301      	adds	r3, #1
  210378:	647b      	str	r3, [r7, #68]	; 0x44
  21037a:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  21037c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  21037e:	429a      	cmp	r2, r3
  210380:	dbe6      	blt.n	210350 <LCD_StrMovV+0x28c>
  210382:	e006      	b.n	210392 <LCD_StrMovV+0x2ce>
  210384:	20003474 	.word	0x20003474
  210388:	2000347c 	.word	0x2000347c
  21038c:	2000f818 	.word	0x2000f818
					break;
  210390:	bf00      	nop
			}
			bufTxt[j]=0;
  210392:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  210394:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  210396:	4413      	add	r3, r2
  210398:	2200      	movs	r2, #0
  21039a:	701a      	strb	r2, [r3, #0]
			it+=i;
  21039c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  21039e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2103a0:	4413      	add	r3, r2
  2103a2:	64fb      	str	r3, [r7, #76]	; 0x4c
			temp=LCD_DrawStr(movableFontsBuffer_pos, FontVar[idVar].FontMov.xImgWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,bkColor,coeff,constWidth);
  2103a4:	4b9a      	ldr	r3, [pc, #616]	; (210610 <LCD_StrMovV+0x54c>)
  2103a6:	681b      	ldr	r3, [r3, #0]
  2103a8:	461c      	mov	r4, r3
  2103aa:	499a      	ldr	r1, [pc, #616]	; (210614 <LCD_StrMovV+0x550>)
  2103ac:	693a      	ldr	r2, [r7, #16]
  2103ae:	4613      	mov	r3, r2
  2103b0:	011b      	lsls	r3, r3, #4
  2103b2:	1a9b      	subs	r3, r3, r2
  2103b4:	009b      	lsls	r3, r3, #2
  2103b6:	440b      	add	r3, r1
  2103b8:	332c      	adds	r3, #44	; 0x2c
  2103ba:	881b      	ldrh	r3, [r3, #0]
  2103bc:	461d      	mov	r5, r3
  2103be:	6c39      	ldr	r1, [r7, #64]	; 0x40
  2103c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2103c2:	4638      	mov	r0, r7
  2103c4:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
  2103c8:	9209      	str	r2, [sp, #36]	; 0x24
  2103ca:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
  2103ce:	9208      	str	r2, [sp, #32]
  2103d0:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  2103d4:	9207      	str	r2, [sp, #28]
  2103d6:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  2103da:	9206      	str	r2, [sp, #24]
  2103dc:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  2103e0:	9205      	str	r2, [sp, #20]
  2103e2:	4a8d      	ldr	r2, [pc, #564]	; (210618 <LCD_StrMovV+0x554>)
  2103e4:	9204      	str	r2, [sp, #16]
  2103e6:	9303      	str	r3, [sp, #12]
  2103e8:	2300      	movs	r3, #0
  2103ea:	9302      	str	r3, [sp, #8]
  2103ec:	2300      	movs	r3, #0
  2103ee:	9301      	str	r3, [sp, #4]
  2103f0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  2103f2:	9300      	str	r3, [sp, #0]
  2103f4:	460b      	mov	r3, r1
  2103f6:	462a      	mov	r2, r5
  2103f8:	4621      	mov	r1, r4
  2103fa:	f7fa f90f 	bl	20a61c <LCD_DrawStr>
  2103fe:	f107 031c 	add.w	r3, r7, #28
  210402:	463a      	mov	r2, r7
  210404:	6810      	ldr	r0, [r2, #0]
  210406:	6018      	str	r0, [r3, #0]
  210408:	8892      	ldrh	r2, [r2, #4]
  21040a:	809a      	strh	r2, [r3, #4]

			int diffWidth=winWidth-temp.inPixel;
  21040c:	8bfb      	ldrh	r3, [r7, #30]
  21040e:	461a      	mov	r2, r3
  210410:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210412:	1a9b      	subs	r3, r3, r2
  210414:	62bb      	str	r3, [r7, #40]	; 0x28
			if(diffWidth>0)
  210416:	6abb      	ldr	r3, [r7, #40]	; 0x28
  210418:	2b00      	cmp	r3, #0
  21041a:	dd25      	ble.n	210468 <LCD_StrMovV+0x3a4>
				LCD_RectangleBuff(movableFontsBuffer,movableFontsBuffer_pos, FontVar[idVar].FontMov.xImgWidth,fontHeight, temp.inPixel,0, diffWidth,fontHeight, bkColor,bkColor,bkColor);
  21041c:	4b7c      	ldr	r3, [pc, #496]	; (210610 <LCD_StrMovV+0x54c>)
  21041e:	681b      	ldr	r3, [r3, #0]
  210420:	461d      	mov	r5, r3
  210422:	497c      	ldr	r1, [pc, #496]	; (210614 <LCD_StrMovV+0x550>)
  210424:	693a      	ldr	r2, [r7, #16]
  210426:	4613      	mov	r3, r2
  210428:	011b      	lsls	r3, r3, #4
  21042a:	1a9b      	subs	r3, r3, r2
  21042c:	009b      	lsls	r3, r3, #2
  21042e:	440b      	add	r3, r1
  210430:	332c      	adds	r3, #44	; 0x2c
  210432:	881b      	ldrh	r3, [r3, #0]
  210434:	469e      	mov	lr, r3
  210436:	6c38      	ldr	r0, [r7, #64]	; 0x40
  210438:	8bfb      	ldrh	r3, [r7, #30]
  21043a:	461c      	mov	r4, r3
  21043c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21043e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  210440:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  210444:	9106      	str	r1, [sp, #24]
  210446:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  21044a:	9105      	str	r1, [sp, #20]
  21044c:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  210450:	9104      	str	r1, [sp, #16]
  210452:	9203      	str	r2, [sp, #12]
  210454:	9302      	str	r3, [sp, #8]
  210456:	2300      	movs	r3, #0
  210458:	9301      	str	r3, [sp, #4]
  21045a:	9400      	str	r4, [sp, #0]
  21045c:	4603      	mov	r3, r0
  21045e:	4672      	mov	r2, lr
  210460:	4629      	mov	r1, r5
  210462:	486d      	ldr	r0, [pc, #436]	; (210618 <LCD_StrMovV+0x554>)
  210464:	f7f7 fdaa 	bl	207fbc <LCD_RectangleBuff>

			movableFontsBuffer_pos += fontHeight*FontVar[idVar].FontMov.xImgWidth;
  210468:	496a      	ldr	r1, [pc, #424]	; (210614 <LCD_StrMovV+0x550>)
  21046a:	693a      	ldr	r2, [r7, #16]
  21046c:	4613      	mov	r3, r2
  21046e:	011b      	lsls	r3, r3, #4
  210470:	1a9b      	subs	r3, r3, r2
  210472:	009b      	lsls	r3, r3, #2
  210474:	440b      	add	r3, r1
  210476:	332c      	adds	r3, #44	; 0x2c
  210478:	881b      	ldrh	r3, [r3, #0]
  21047a:	461a      	mov	r2, r3
  21047c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  21047e:	fb03 f202 	mul.w	r2, r3, r2
  210482:	4b63      	ldr	r3, [pc, #396]	; (210610 <LCD_StrMovV+0x54c>)
  210484:	681b      	ldr	r3, [r3, #0]
  210486:	4413      	add	r3, r2
  210488:	4a61      	ldr	r2, [pc, #388]	; (210610 <LCD_StrMovV+0x54c>)
  21048a:	6013      	str	r3, [r2, #0]
			iH++;
  21048c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  21048e:	3301      	adds	r3, #1
  210490:	64bb      	str	r3, [r7, #72]	; 0x48
		}while(movableFontsBuffer_pos + fontHeight*FontVar[idVar].FontMov.xImgWidth < LCD_MOVABLE_FONTS_BUFF_SIZE);
  210492:	4960      	ldr	r1, [pc, #384]	; (210614 <LCD_StrMovV+0x550>)
  210494:	693a      	ldr	r2, [r7, #16]
  210496:	4613      	mov	r3, r2
  210498:	011b      	lsls	r3, r3, #4
  21049a:	1a9b      	subs	r3, r3, r2
  21049c:	009b      	lsls	r3, r3, #2
  21049e:	440b      	add	r3, r1
  2104a0:	332c      	adds	r3, #44	; 0x2c
  2104a2:	881b      	ldrh	r3, [r3, #0]
  2104a4:	461a      	mov	r2, r3
  2104a6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2104a8:	fb03 f202 	mul.w	r2, r3, r2
  2104ac:	4b58      	ldr	r3, [pc, #352]	; (210610 <LCD_StrMovV+0x54c>)
  2104ae:	681b      	ldr	r3, [r3, #0]
  2104b0:	4413      	add	r3, r2
  2104b2:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  2104b6:	f6ff af29 	blt.w	21030c <LCD_StrMovV+0x248>
  2104ba:	e000      	b.n	2104be <LCD_StrMovV+0x3fa>
			if(i==0) break;
  2104bc:	bf00      	nop

		FontVar[idVar].FontMov.yImgHeight = fontHeight*iH;
  2104be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2104c0:	b29a      	uxth	r2, r3
  2104c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  2104c4:	b29b      	uxth	r3, r3
  2104c6:	fb12 f303 	smulbb	r3, r2, r3
  2104ca:	b298      	uxth	r0, r3
  2104cc:	4951      	ldr	r1, [pc, #324]	; (210614 <LCD_StrMovV+0x550>)
  2104ce:	693a      	ldr	r2, [r7, #16]
  2104d0:	4613      	mov	r3, r2
  2104d2:	011b      	lsls	r3, r3, #4
  2104d4:	1a9b      	subs	r3, r3, r2
  2104d6:	009b      	lsls	r3, r3, #2
  2104d8:	440b      	add	r3, r1
  2104da:	332e      	adds	r3, #46	; 0x2e
  2104dc:	4602      	mov	r2, r0
  2104de:	801a      	strh	r2, [r3, #0]
		int diffHeight = winHeight - FontVar[idVar].FontMov.yImgHeight;
  2104e0:	494c      	ldr	r1, [pc, #304]	; (210614 <LCD_StrMovV+0x550>)
  2104e2:	693a      	ldr	r2, [r7, #16]
  2104e4:	4613      	mov	r3, r2
  2104e6:	011b      	lsls	r3, r3, #4
  2104e8:	1a9b      	subs	r3, r3, r2
  2104ea:	009b      	lsls	r3, r3, #2
  2104ec:	440b      	add	r3, r1
  2104ee:	332e      	adds	r3, #46	; 0x2e
  2104f0:	881b      	ldrh	r3, [r3, #0]
  2104f2:	461a      	mov	r2, r3
  2104f4:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  2104f6:	1a9b      	subs	r3, r3, r2
  2104f8:	627b      	str	r3, [r7, #36]	; 0x24
		LCD_CopyBuff2pLcd(rot,FontVar[idVar].FontMov.posBuff, movableFontsBuffer, FontVar[idVar].FontMov.xImgWidth,winHeight, posWin*FontVar[idVar].FontMov.xImgWidth, winWidth, Xpos,Ypos,0);
  2104fa:	4946      	ldr	r1, [pc, #280]	; (210614 <LCD_StrMovV+0x550>)
  2104fc:	693a      	ldr	r2, [r7, #16]
  2104fe:	4613      	mov	r3, r2
  210500:	011b      	lsls	r3, r3, #4
  210502:	1a9b      	subs	r3, r3, r2
  210504:	009b      	lsls	r3, r3, #2
  210506:	440b      	add	r3, r1
  210508:	3328      	adds	r3, #40	; 0x28
  21050a:	681e      	ldr	r6, [r3, #0]
  21050c:	4941      	ldr	r1, [pc, #260]	; (210614 <LCD_StrMovV+0x550>)
  21050e:	693a      	ldr	r2, [r7, #16]
  210510:	4613      	mov	r3, r2
  210512:	011b      	lsls	r3, r3, #4
  210514:	1a9b      	subs	r3, r3, r2
  210516:	009b      	lsls	r3, r3, #2
  210518:	440b      	add	r3, r1
  21051a:	332c      	adds	r3, #44	; 0x2c
  21051c:	881b      	ldrh	r3, [r3, #0]
  21051e:	469e      	mov	lr, r3
  210520:	6f79      	ldr	r1, [r7, #116]	; 0x74
  210522:	483c      	ldr	r0, [pc, #240]	; (210614 <LCD_StrMovV+0x550>)
  210524:	693a      	ldr	r2, [r7, #16]
  210526:	4613      	mov	r3, r2
  210528:	011b      	lsls	r3, r3, #4
  21052a:	1a9b      	subs	r3, r3, r2
  21052c:	009b      	lsls	r3, r3, #2
  21052e:	4403      	add	r3, r0
  210530:	332c      	adds	r3, #44	; 0x2c
  210532:	881b      	ldrh	r3, [r3, #0]
  210534:	461a      	mov	r2, r3
  210536:	68bb      	ldr	r3, [r7, #8]
  210538:	fb03 f302 	mul.w	r3, r3, r2
  21053c:	6f3a      	ldr	r2, [r7, #112]	; 0x70
  21053e:	b292      	uxth	r2, r2
  210540:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
  210542:	b280      	uxth	r0, r0
  210544:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
  210548:	b2a4      	uxth	r4, r4
  21054a:	2500      	movs	r5, #0
  21054c:	9505      	str	r5, [sp, #20]
  21054e:	9404      	str	r4, [sp, #16]
  210550:	9003      	str	r0, [sp, #12]
  210552:	9202      	str	r2, [sp, #8]
  210554:	9301      	str	r3, [sp, #4]
  210556:	9100      	str	r1, [sp, #0]
  210558:	4673      	mov	r3, lr
  21055a:	4a2f      	ldr	r2, [pc, #188]	; (210618 <LCD_StrMovV+0x554>)
  21055c:	4631      	mov	r1, r6
  21055e:	68f8      	ldr	r0, [r7, #12]
  210560:	f7f7 faf2 	bl	207b48 <LCD_CopyBuff2pLcd>

		if(diffHeight>0)
  210564:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  210566:	2b00      	cmp	r3, #0
  210568:	f340 8085 	ble.w	210676 <LCD_StrMovV+0x5b2>
		{	switch(rot)
  21056c:	68fb      	ldr	r3, [r7, #12]
  21056e:	2b01      	cmp	r3, #1
  210570:	d02e      	beq.n	2105d0 <LCD_StrMovV+0x50c>
  210572:	2b02      	cmp	r3, #2
  210574:	d054      	beq.n	210620 <LCD_StrMovV+0x55c>
  210576:	2b00      	cmp	r3, #0
  210578:	d17d      	bne.n	210676 <LCD_StrMovV+0x5b2>
			{
			case Rotate_0:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos+FontVar[idVar].FontMov.yImgHeight, winWidth,diffHeight, bkColor,bkColor,bkColor);
  21057a:	f7f7 fa15 	bl	2079a8 <LCD_GetXSize>
  21057e:	4605      	mov	r5, r0
  210580:	f7f7 fa26 	bl	2079d0 <LCD_GetYSize>
  210584:	4606      	mov	r6, r0
  210586:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
  210588:	4822      	ldr	r0, [pc, #136]	; (210614 <LCD_StrMovV+0x550>)
  21058a:	693a      	ldr	r2, [r7, #16]
  21058c:	4613      	mov	r3, r2
  21058e:	011b      	lsls	r3, r3, #4
  210590:	1a9b      	subs	r3, r3, r2
  210592:	009b      	lsls	r3, r3, #2
  210594:	4403      	add	r3, r0
  210596:	332e      	adds	r3, #46	; 0x2e
  210598:	881b      	ldrh	r3, [r3, #0]
  21059a:	461a      	mov	r2, r3
  21059c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  2105a0:	4413      	add	r3, r2
  2105a2:	461c      	mov	r4, r3
  2105a4:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2105a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2105a8:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  2105ac:	9006      	str	r0, [sp, #24]
  2105ae:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  2105b2:	9005      	str	r0, [sp, #20]
  2105b4:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  2105b8:	9004      	str	r0, [sp, #16]
  2105ba:	9203      	str	r2, [sp, #12]
  2105bc:	9302      	str	r3, [sp, #8]
  2105be:	9401      	str	r4, [sp, #4]
  2105c0:	9100      	str	r1, [sp, #0]
  2105c2:	4633      	mov	r3, r6
  2105c4:	462a      	mov	r2, r5
  2105c6:	2100      	movs	r1, #0
  2105c8:	4814      	ldr	r0, [pc, #80]	; (21061c <LCD_StrMovV+0x558>)
  2105ca:	f7f7 fcf7 	bl	207fbc <LCD_RectangleBuff>
				break;
  2105ce:	e052      	b.n	210676 <LCD_StrMovV+0x5b2>
			case Rotate_90:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos, diffHeight,winWidth, bkColor,bkColor,bkColor);
  2105d0:	f7f7 f9ea 	bl	2079a8 <LCD_GetXSize>
  2105d4:	4605      	mov	r5, r0
  2105d6:	f7f7 f9fb 	bl	2079d0 <LCD_GetYSize>
  2105da:	4606      	mov	r6, r0
  2105dc:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  2105de:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  2105e2:	6a79      	ldr	r1, [r7, #36]	; 0x24
  2105e4:	6f38      	ldr	r0, [r7, #112]	; 0x70
  2105e6:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
  2105ea:	9406      	str	r4, [sp, #24]
  2105ec:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
  2105f0:	9405      	str	r4, [sp, #20]
  2105f2:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
  2105f6:	9404      	str	r4, [sp, #16]
  2105f8:	9003      	str	r0, [sp, #12]
  2105fa:	9102      	str	r1, [sp, #8]
  2105fc:	9201      	str	r2, [sp, #4]
  2105fe:	9300      	str	r3, [sp, #0]
  210600:	4633      	mov	r3, r6
  210602:	462a      	mov	r2, r5
  210604:	2100      	movs	r1, #0
  210606:	4805      	ldr	r0, [pc, #20]	; (21061c <LCD_StrMovV+0x558>)
  210608:	f7f7 fcd8 	bl	207fbc <LCD_RectangleBuff>
				break;
  21060c:	e033      	b.n	210676 <LCD_StrMovV+0x5b2>
  21060e:	bf00      	nop
  210610:	2000347c 	.word	0x2000347c
  210614:	2000f818 	.word	0x2000f818
  210618:	c067f800 	.word	0xc067f800
  21061c:	c0000000 	.word	0xc0000000
			case Rotate_180:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos+FontVar[idVar].FontMov.yImgHeight,Ypos, diffHeight,winWidth, bkColor,bkColor,bkColor);
  210620:	f7f7 f9c2 	bl	2079a8 <LCD_GetXSize>
  210624:	4605      	mov	r5, r0
  210626:	f7f7 f9d3 	bl	2079d0 <LCD_GetYSize>
  21062a:	4606      	mov	r6, r0
  21062c:	493f      	ldr	r1, [pc, #252]	; (21072c <LCD_StrMovV+0x668>)
  21062e:	693a      	ldr	r2, [r7, #16]
  210630:	4613      	mov	r3, r2
  210632:	011b      	lsls	r3, r3, #4
  210634:	1a9b      	subs	r3, r3, r2
  210636:	009b      	lsls	r3, r3, #2
  210638:	440b      	add	r3, r1
  21063a:	332e      	adds	r3, #46	; 0x2e
  21063c:	881b      	ldrh	r3, [r3, #0]
  21063e:	461a      	mov	r2, r3
  210640:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  210642:	4413      	add	r3, r2
  210644:	461c      	mov	r4, r3
  210646:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  21064a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  21064c:	6f39      	ldr	r1, [r7, #112]	; 0x70
  21064e:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210652:	9006      	str	r0, [sp, #24]
  210654:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210658:	9005      	str	r0, [sp, #20]
  21065a:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  21065e:	9004      	str	r0, [sp, #16]
  210660:	9103      	str	r1, [sp, #12]
  210662:	9202      	str	r2, [sp, #8]
  210664:	9301      	str	r3, [sp, #4]
  210666:	9400      	str	r4, [sp, #0]
  210668:	4633      	mov	r3, r6
  21066a:	462a      	mov	r2, r5
  21066c:	2100      	movs	r1, #0
  21066e:	4830      	ldr	r0, [pc, #192]	; (210730 <LCD_StrMovV+0x66c>)
  210670:	f7f7 fca4 	bl	207fbc <LCD_RectangleBuff>
				break;
  210674:	bf00      	nop
			}
		}
		FontVar[idVar].xPos_prev = Xpos;
  210676:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  210678:	b298      	uxth	r0, r3
  21067a:	492c      	ldr	r1, [pc, #176]	; (21072c <LCD_StrMovV+0x668>)
  21067c:	693a      	ldr	r2, [r7, #16]
  21067e:	4613      	mov	r3, r2
  210680:	011b      	lsls	r3, r3, #4
  210682:	1a9b      	subs	r3, r3, r2
  210684:	009b      	lsls	r3, r3, #2
  210686:	440b      	add	r3, r1
  210688:	331e      	adds	r3, #30
  21068a:	4602      	mov	r2, r0
  21068c:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos_prev = Ypos;
  21068e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  210692:	b298      	uxth	r0, r3
  210694:	4925      	ldr	r1, [pc, #148]	; (21072c <LCD_StrMovV+0x668>)
  210696:	693a      	ldr	r2, [r7, #16]
  210698:	4613      	mov	r3, r2
  21069a:	011b      	lsls	r3, r3, #4
  21069c:	1a9b      	subs	r3, r3, r2
  21069e:	009b      	lsls	r3, r3, #2
  2106a0:	440b      	add	r3, r1
  2106a2:	3320      	adds	r3, #32
  2106a4:	4602      	mov	r2, r0
  2106a6:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].widthPxl_prev = winWidth;
  2106a8:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2106aa:	b298      	uxth	r0, r3
  2106ac:	491f      	ldr	r1, [pc, #124]	; (21072c <LCD_StrMovV+0x668>)
  2106ae:	693a      	ldr	r2, [r7, #16]
  2106b0:	4613      	mov	r3, r2
  2106b2:	011b      	lsls	r3, r3, #4
  2106b4:	1a9b      	subs	r3, r3, r2
  2106b6:	009b      	lsls	r3, r3, #2
  2106b8:	440b      	add	r3, r1
  2106ba:	3322      	adds	r3, #34	; 0x22
  2106bc:	4602      	mov	r2, r0
  2106be:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightPxl_prev = winHeight;
  2106c0:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  2106c2:	b298      	uxth	r0, r3
  2106c4:	4919      	ldr	r1, [pc, #100]	; (21072c <LCD_StrMovV+0x668>)
  2106c6:	693a      	ldr	r2, [r7, #16]
  2106c8:	4613      	mov	r3, r2
  2106ca:	011b      	lsls	r3, r3, #4
  2106cc:	1a9b      	subs	r3, r3, r2
  2106ce:	009b      	lsls	r3, r3, #2
  2106d0:	440b      	add	r3, r1
  2106d2:	3324      	adds	r3, #36	; 0x24
  2106d4:	4602      	mov	r2, r0
  2106d6:	801a      	strh	r2, [r3, #0]

		temp.inChar=0;
  2106d8:	2300      	movs	r3, #0
  2106da:	83bb      	strh	r3, [r7, #28]
		temp.inPixel=winWidth;
  2106dc:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2106de:	b29b      	uxth	r3, r3
  2106e0:	83fb      	strh	r3, [r7, #30]
		temp.height=winHeight;
  2106e2:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  2106e4:	b29b      	uxth	r3, r3
  2106e6:	843b      	strh	r3, [r7, #32]
		if(rot>Rotate_0)
  2106e8:	68fb      	ldr	r3, [r7, #12]
  2106ea:	2b00      	cmp	r3, #0
  2106ec:	dd09      	ble.n	210702 <LCD_StrMovV+0x63e>
			SwapUint16(&temp.inPixel,&temp.height);
  2106ee:	f107 031c 	add.w	r3, r7, #28
  2106f2:	1d1a      	adds	r2, r3, #4
  2106f4:	f107 031c 	add.w	r3, r7, #28
  2106f8:	3302      	adds	r3, #2
  2106fa:	4611      	mov	r1, r2
  2106fc:	4618      	mov	r0, r3
  2106fe:	f7f1 fa17 	bl	201b30 <SwapUint16>
		return temp;
  210702:	697b      	ldr	r3, [r7, #20]
  210704:	461a      	mov	r2, r3
  210706:	f107 031c 	add.w	r3, r7, #28
  21070a:	6818      	ldr	r0, [r3, #0]
  21070c:	6010      	str	r0, [r2, #0]
  21070e:	889b      	ldrh	r3, [r3, #4]
  210710:	8093      	strh	r3, [r2, #4]
  210712:	46d5      	mov	sp, sl
  210714:	e005      	b.n	210722 <LCD_StrMovV+0x65e>
	}
	else return StructTxtPxlLen_ZeroValue;
  210716:	697b      	ldr	r3, [r7, #20]
  210718:	4a06      	ldr	r2, [pc, #24]	; (210734 <LCD_StrMovV+0x670>)
  21071a:	6810      	ldr	r0, [r2, #0]
  21071c:	6018      	str	r0, [r3, #0]
  21071e:	8892      	ldrh	r2, [r2, #4]
  210720:	809a      	strh	r2, [r3, #4]
}
  210722:	6978      	ldr	r0, [r7, #20]
  210724:	3750      	adds	r7, #80	; 0x50
  210726:	46bd      	mov	sp, r7
  210728:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  21072c:	2000f818 	.word	0x2000f818
  210730:	c0000000 	.word	0xc0000000
  210734:	20003474 	.word	0x20003474

00210738 <LCD_StrChangeColorMovV>:

StructTxtPxlLen LCD_StrChangeColorMovV(int idVar, int rot, int posWin, int winWidth,int winHeight, int fontID, int Xpos, int Ypos, char *txt, int OnlyDigits, int space, uint32_t bkColor, uint32_t fontColor, int maxVal, int constWidth)
{
  210738:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  21073c:	b0a0      	sub	sp, #128	; 0x80
  21073e:	af0c      	add	r7, sp, #48	; 0x30
  210740:	6178      	str	r0, [r7, #20]
  210742:	6139      	str	r1, [r7, #16]
  210744:	60fa      	str	r2, [r7, #12]
  210746:	60bb      	str	r3, [r7, #8]
	StructTxtPxlLen temp;

	if(idVar<MAX_OPEN_FONTS_VAR_SIMULTANEOUSLY)
  210748:	693b      	ldr	r3, [r7, #16]
  21074a:	2b27      	cmp	r3, #39	; 0x27
  21074c:	f300 835e 	bgt.w	210e0c <LCD_StrChangeColorMovV+0x6d4>
	{
  210750:	466b      	mov	r3, sp
  210752:	469a      	mov	sl, r3
		int fontHeight= OnlyDigits==fullHight?LCD_GetFontHeight(fontID):LCD_GetFontHalfHeight(fontID);
  210754:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  210758:	f113 0f03 	cmn.w	r3, #3
  21075c:	d104      	bne.n	210768 <LCD_StrChangeColorMovV+0x30>
  21075e:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  210760:	f001 fe48 	bl	2123f4 <LCD_GetFontHeight>
  210764:	4603      	mov	r3, r0
  210766:	e003      	b.n	210770 <LCD_StrChangeColorMovV+0x38>
  210768:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  21076a:	f001 fe7f 	bl	21246c <LCD_GetFontHalfHeight>
  21076e:	4603      	mov	r3, r0
  210770:	643b      	str	r3, [r7, #64]	; 0x40
		if(fontHeight<0)
  210772:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210774:	2b00      	cmp	r3, #0
  210776:	da06      	bge.n	210786 <LCD_StrChangeColorMovV+0x4e>
			return StructTxtPxlLen_ZeroValue;
  210778:	697b      	ldr	r3, [r7, #20]
  21077a:	4a9f      	ldr	r2, [pc, #636]	; (2109f8 <LCD_StrChangeColorMovV+0x2c0>)
  21077c:	6810      	ldr	r0, [r2, #0]
  21077e:	6018      	str	r0, [r3, #0]
  210780:	8892      	ldrh	r2, [r2, #4]
  210782:	809a      	strh	r2, [r3, #4]
  210784:	e340      	b.n	210e08 <LCD_StrChangeColorMovV+0x6d0>
		int pxlTxtLen = LCD_GetWholeStrPxlWidth(fontID,txt,space,constWidth);
  210786:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  21078a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  21078e:	f8d7 1084 	ldr.w	r1, [r7, #132]	; 0x84
  210792:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  210794:	f001 fc9a 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  210798:	63f8      	str	r0, [r7, #60]	; 0x3c

		int posMovBuff_copy = movableFontsBuffer_pos + fontHeight*pxlTxtLen;
  21079a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  21079c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  21079e:	fb02 f203 	mul.w	r2, r2, r3
  2107a2:	4b96      	ldr	r3, [pc, #600]	; (2109fc <LCD_StrChangeColorMovV+0x2c4>)
  2107a4:	681b      	ldr	r3, [r3, #0]
  2107a6:	4413      	add	r3, r2
  2107a8:	63bb      	str	r3, [r7, #56]	; 0x38
		if(posMovBuff_copy >= LCD_MOVABLE_FONTS_BUFF_SIZE)
  2107aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2107ac:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  2107b0:	db06      	blt.n	2107c0 <LCD_StrChangeColorMovV+0x88>
			return StructTxtPxlLen_ZeroValue;
  2107b2:	697b      	ldr	r3, [r7, #20]
  2107b4:	4a90      	ldr	r2, [pc, #576]	; (2109f8 <LCD_StrChangeColorMovV+0x2c0>)
  2107b6:	6810      	ldr	r0, [r2, #0]
  2107b8:	6018      	str	r0, [r3, #0]
  2107ba:	8892      	ldrh	r2, [r2, #4]
  2107bc:	809a      	strh	r2, [r3, #4]
  2107be:	e323      	b.n	210e08 <LCD_StrChangeColorMovV+0x6d0>

		int i=0,it=0,iH=0,j;
  2107c0:	2300      	movs	r3, #0
  2107c2:	637b      	str	r3, [r7, #52]	; 0x34
  2107c4:	2300      	movs	r3, #0
  2107c6:	64fb      	str	r3, [r7, #76]	; 0x4c
  2107c8:	2300      	movs	r3, #0
  2107ca:	64bb      	str	r3, [r7, #72]	; 0x48
		char bufTxt[winWidth/LCD_GetFontWidth(fontID,'1')];
  2107cc:	2131      	movs	r1, #49	; 0x31
  2107ce:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  2107d0:	f001 fdd2 	bl	212378 <LCD_GetFontWidth>
  2107d4:	4602      	mov	r2, r0
  2107d6:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2107d8:	fb93 f6f2 	sdiv	r6, r3, r2
  2107dc:	1e73      	subs	r3, r6, #1
  2107de:	633b      	str	r3, [r7, #48]	; 0x30
  2107e0:	4633      	mov	r3, r6
  2107e2:	461a      	mov	r2, r3
  2107e4:	f04f 0300 	mov.w	r3, #0
  2107e8:	ea4f 09c3 	mov.w	r9, r3, lsl #3
  2107ec:	ea49 7952 	orr.w	r9, r9, r2, lsr #29
  2107f0:	ea4f 08c2 	mov.w	r8, r2, lsl #3
  2107f4:	4633      	mov	r3, r6
  2107f6:	461a      	mov	r2, r3
  2107f8:	f04f 0300 	mov.w	r3, #0
  2107fc:	00dd      	lsls	r5, r3, #3
  2107fe:	ea45 7552 	orr.w	r5, r5, r2, lsr #29
  210802:	00d4      	lsls	r4, r2, #3
  210804:	4633      	mov	r3, r6
  210806:	3307      	adds	r3, #7
  210808:	08db      	lsrs	r3, r3, #3
  21080a:	00db      	lsls	r3, r3, #3
  21080c:	ebad 0d03 	sub.w	sp, sp, r3
  210810:	ab0c      	add	r3, sp, #48	; 0x30
  210812:	3300      	adds	r3, #0
  210814:	62fb      	str	r3, [r7, #44]	; 0x2c

		FontVar[idVar].id=fontID;
  210816:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  210818:	b298      	uxth	r0, r3
  21081a:	4979      	ldr	r1, [pc, #484]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  21081c:	693a      	ldr	r2, [r7, #16]
  21081e:	4613      	mov	r3, r2
  210820:	011b      	lsls	r3, r3, #4
  210822:	1a9b      	subs	r3, r3, r2
  210824:	009b      	lsls	r3, r3, #2
  210826:	440b      	add	r3, r1
  210828:	4602      	mov	r2, r0
  21082a:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].xPos=Xpos;
  21082c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  21082e:	b298      	uxth	r0, r3
  210830:	4973      	ldr	r1, [pc, #460]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210832:	693a      	ldr	r2, [r7, #16]
  210834:	4613      	mov	r3, r2
  210836:	011b      	lsls	r3, r3, #4
  210838:	1a9b      	subs	r3, r3, r2
  21083a:	009b      	lsls	r3, r3, #2
  21083c:	440b      	add	r3, r1
  21083e:	3302      	adds	r3, #2
  210840:	4602      	mov	r2, r0
  210842:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos=Ypos;
  210844:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  210848:	b298      	uxth	r0, r3
  21084a:	496d      	ldr	r1, [pc, #436]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  21084c:	693a      	ldr	r2, [r7, #16]
  21084e:	4613      	mov	r3, r2
  210850:	011b      	lsls	r3, r3, #4
  210852:	1a9b      	subs	r3, r3, r2
  210854:	009b      	lsls	r3, r3, #2
  210856:	440b      	add	r3, r1
  210858:	3304      	adds	r3, #4
  21085a:	4602      	mov	r2, r0
  21085c:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightType=OnlyDigits;
  21085e:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
  210862:	b258      	sxtb	r0, r3
  210864:	4966      	ldr	r1, [pc, #408]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210866:	693a      	ldr	r2, [r7, #16]
  210868:	4613      	mov	r3, r2
  21086a:	011b      	lsls	r3, r3, #4
  21086c:	1a9b      	subs	r3, r3, r2
  21086e:	009b      	lsls	r3, r3, #2
  210870:	440b      	add	r3, r1
  210872:	3306      	adds	r3, #6
  210874:	4602      	mov	r2, r0
  210876:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].space=space;
  210878:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  21087c:	b2d8      	uxtb	r0, r3
  21087e:	4960      	ldr	r1, [pc, #384]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210880:	693a      	ldr	r2, [r7, #16]
  210882:	4613      	mov	r3, r2
  210884:	011b      	lsls	r3, r3, #4
  210886:	1a9b      	subs	r3, r3, r2
  210888:	009b      	lsls	r3, r3, #2
  21088a:	440b      	add	r3, r1
  21088c:	3307      	adds	r3, #7
  21088e:	4602      	mov	r2, r0
  210890:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].bkColor=bkColor;
  210892:	495b      	ldr	r1, [pc, #364]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210894:	693a      	ldr	r2, [r7, #16]
  210896:	4613      	mov	r3, r2
  210898:	011b      	lsls	r3, r3, #4
  21089a:	1a9b      	subs	r3, r3, r2
  21089c:	009b      	lsls	r3, r3, #2
  21089e:	440b      	add	r3, r1
  2108a0:	3308      	adds	r3, #8
  2108a2:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  2108a6:	601a      	str	r2, [r3, #0]
		FontVar[idVar].coeff=maxVal;
  2108a8:	4955      	ldr	r1, [pc, #340]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  2108aa:	693a      	ldr	r2, [r7, #16]
  2108ac:	4613      	mov	r3, r2
  2108ae:	011b      	lsls	r3, r3, #4
  2108b0:	1a9b      	subs	r3, r3, r2
  2108b2:	009b      	lsls	r3, r3, #2
  2108b4:	440b      	add	r3, r1
  2108b6:	3318      	adds	r3, #24
  2108b8:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
  2108bc:	601a      	str	r2, [r3, #0]
		FontVar[idVar].widthType=constWidth;
  2108be:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  2108c2:	b2d8      	uxtb	r0, r3
  2108c4:	494e      	ldr	r1, [pc, #312]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  2108c6:	693a      	ldr	r2, [r7, #16]
  2108c8:	4613      	mov	r3, r2
  2108ca:	011b      	lsls	r3, r3, #4
  2108cc:	1a9b      	subs	r3, r3, r2
  2108ce:	009b      	lsls	r3, r3, #2
  2108d0:	440b      	add	r3, r1
  2108d2:	331c      	adds	r3, #28
  2108d4:	4602      	mov	r2, r0
  2108d6:	701a      	strb	r2, [r3, #0]
		FontVar[idVar].rotate=rot;
  2108d8:	68fb      	ldr	r3, [r7, #12]
  2108da:	b2d8      	uxtb	r0, r3
  2108dc:	4948      	ldr	r1, [pc, #288]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  2108de:	693a      	ldr	r2, [r7, #16]
  2108e0:	4613      	mov	r3, r2
  2108e2:	011b      	lsls	r3, r3, #4
  2108e4:	1a9b      	subs	r3, r3, r2
  2108e6:	009b      	lsls	r3, r3, #2
  2108e8:	440b      	add	r3, r1
  2108ea:	3314      	adds	r3, #20
  2108ec:	4602      	mov	r2, r0
  2108ee:	701a      	strb	r2, [r3, #0]

		FontVar[idVar].FontMov.xImgWidth=winWidth;
  2108f0:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  2108f2:	b298      	uxth	r0, r3
  2108f4:	4942      	ldr	r1, [pc, #264]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  2108f6:	693a      	ldr	r2, [r7, #16]
  2108f8:	4613      	mov	r3, r2
  2108fa:	011b      	lsls	r3, r3, #4
  2108fc:	1a9b      	subs	r3, r3, r2
  2108fe:	009b      	lsls	r3, r3, #2
  210900:	440b      	add	r3, r1
  210902:	332c      	adds	r3, #44	; 0x2c
  210904:	4602      	mov	r2, r0
  210906:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posWin=posWin;
  210908:	68bb      	ldr	r3, [r7, #8]
  21090a:	b298      	uxth	r0, r3
  21090c:	493c      	ldr	r1, [pc, #240]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  21090e:	693a      	ldr	r2, [r7, #16]
  210910:	4613      	mov	r3, r2
  210912:	011b      	lsls	r3, r3, #4
  210914:	1a9b      	subs	r3, r3, r2
  210916:	009b      	lsls	r3, r3, #2
  210918:	440b      	add	r3, r1
  21091a:	3330      	adds	r3, #48	; 0x30
  21091c:	4602      	mov	r2, r0
  21091e:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.windowWidth=winWidth;
  210920:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210922:	b298      	uxth	r0, r3
  210924:	4936      	ldr	r1, [pc, #216]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210926:	693a      	ldr	r2, [r7, #16]
  210928:	4613      	mov	r3, r2
  21092a:	011b      	lsls	r3, r3, #4
  21092c:	1a9b      	subs	r3, r3, r2
  21092e:	009b      	lsls	r3, r3, #2
  210930:	440b      	add	r3, r1
  210932:	3332      	adds	r3, #50	; 0x32
  210934:	4602      	mov	r2, r0
  210936:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.windowHeight = winHeight;
  210938:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  21093a:	b298      	uxth	r0, r3
  21093c:	4930      	ldr	r1, [pc, #192]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  21093e:	693a      	ldr	r2, [r7, #16]
  210940:	4613      	mov	r3, r2
  210942:	011b      	lsls	r3, r3, #4
  210944:	1a9b      	subs	r3, r3, r2
  210946:	009b      	lsls	r3, r3, #2
  210948:	440b      	add	r3, r1
  21094a:	3334      	adds	r3, #52	; 0x34
  21094c:	4602      	mov	r2, r0
  21094e:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.spaceEndStart=fontHeight;
  210950:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210952:	b298      	uxth	r0, r3
  210954:	492a      	ldr	r1, [pc, #168]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210956:	693a      	ldr	r2, [r7, #16]
  210958:	4613      	mov	r3, r2
  21095a:	011b      	lsls	r3, r3, #4
  21095c:	1a9b      	subs	r3, r3, r2
  21095e:	009b      	lsls	r3, r3, #2
  210960:	440b      	add	r3, r1
  210962:	3338      	adds	r3, #56	; 0x38
  210964:	4602      	mov	r2, r0
  210966:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].FontMov.posBuff=movableFontsBuffer_pos;
  210968:	4b24      	ldr	r3, [pc, #144]	; (2109fc <LCD_StrChangeColorMovV+0x2c4>)
  21096a:	681b      	ldr	r3, [r3, #0]
  21096c:	4618      	mov	r0, r3
  21096e:	4924      	ldr	r1, [pc, #144]	; (210a00 <LCD_StrChangeColorMovV+0x2c8>)
  210970:	693a      	ldr	r2, [r7, #16]
  210972:	4613      	mov	r3, r2
  210974:	011b      	lsls	r3, r3, #4
  210976:	1a9b      	subs	r3, r3, r2
  210978:	009b      	lsls	r3, r3, #2
  21097a:	440b      	add	r3, r1
  21097c:	3328      	adds	r3, #40	; 0x28
  21097e:	6018      	str	r0, [r3, #0]

		do
		{	if(iH>0){ if(txt[it]==' ') it++; }
  210980:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  210982:	2b00      	cmp	r3, #0
  210984:	dd09      	ble.n	21099a <LCD_StrChangeColorMovV+0x262>
  210986:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  210988:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  21098c:	4413      	add	r3, r2
  21098e:	781b      	ldrb	r3, [r3, #0]
  210990:	2b20      	cmp	r3, #32
  210992:	d102      	bne.n	21099a <LCD_StrChangeColorMovV+0x262>
  210994:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  210996:	3301      	adds	r3, #1
  210998:	64fb      	str	r3, [r7, #76]	; 0x4c
			i= LCD_GetStrLenForPxlWidth(fontID,&txt[it],winWidth,space,constWidth);
  21099a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  21099c:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  2109a0:	18d1      	adds	r1, r2, r3
  2109a2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
  2109a6:	9300      	str	r3, [sp, #0]
  2109a8:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
  2109ac:	6f3a      	ldr	r2, [r7, #112]	; 0x70
  2109ae:	6fb8      	ldr	r0, [r7, #120]	; 0x78
  2109b0:	f001 fc66 	bl	212280 <LCD_GetStrLenForPxlWidth>
  2109b4:	6378      	str	r0, [r7, #52]	; 0x34
			if(i==0) break;
  2109b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2109b8:	2b00      	cmp	r3, #0
  2109ba:	f000 80f8 	beq.w	210bae <LCD_StrChangeColorMovV+0x476>
			for(j=0;j<i;++j)
  2109be:	2300      	movs	r3, #0
  2109c0:	647b      	str	r3, [r7, #68]	; 0x44
  2109c2:	e014      	b.n	2109ee <LCD_StrChangeColorMovV+0x2b6>
			{	if(j==sizeof(bufTxt)-1)
  2109c4:	4633      	mov	r3, r6
  2109c6:	1e5a      	subs	r2, r3, #1
  2109c8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2109ca:	429a      	cmp	r2, r3
  2109cc:	d01a      	beq.n	210a04 <LCD_StrChangeColorMovV+0x2cc>
					break;
				bufTxt[j]=txt[it+j];
  2109ce:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  2109d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2109d2:	4413      	add	r3, r2
  2109d4:	461a      	mov	r2, r3
  2109d6:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
  2109da:	4413      	add	r3, r2
  2109dc:	7819      	ldrb	r1, [r3, #0]
  2109de:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  2109e0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2109e2:	4413      	add	r3, r2
  2109e4:	460a      	mov	r2, r1
  2109e6:	701a      	strb	r2, [r3, #0]
			for(j=0;j<i;++j)
  2109e8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  2109ea:	3301      	adds	r3, #1
  2109ec:	647b      	str	r3, [r7, #68]	; 0x44
  2109ee:	6c7a      	ldr	r2, [r7, #68]	; 0x44
  2109f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2109f2:	429a      	cmp	r2, r3
  2109f4:	dbe6      	blt.n	2109c4 <LCD_StrChangeColorMovV+0x28c>
  2109f6:	e006      	b.n	210a06 <LCD_StrChangeColorMovV+0x2ce>
  2109f8:	20003474 	.word	0x20003474
  2109fc:	2000347c 	.word	0x2000347c
  210a00:	2000f818 	.word	0x2000f818
					break;
  210a04:	bf00      	nop
			}
			bufTxt[j]=0;
  210a06:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  210a08:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  210a0a:	4413      	add	r3, r2
  210a0c:	2200      	movs	r2, #0
  210a0e:	701a      	strb	r2, [r3, #0]
			it+=i;
  210a10:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  210a12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  210a14:	4413      	add	r3, r2
  210a16:	64fb      	str	r3, [r7, #76]	; 0x4c
			if(iH==2)
  210a18:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  210a1a:	2b02      	cmp	r3, #2
  210a1c:	d137      	bne.n	210a8e <LCD_StrChangeColorMovV+0x356>
				temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, FontVar[idVar].FontMov.xImgWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,GRAY,fontColor,maxVal,constWidth);
  210a1e:	4ba9      	ldr	r3, [pc, #676]	; (210cc4 <LCD_StrChangeColorMovV+0x58c>)
  210a20:	681b      	ldr	r3, [r3, #0]
  210a22:	461d      	mov	r5, r3
  210a24:	49a8      	ldr	r1, [pc, #672]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210a26:	693a      	ldr	r2, [r7, #16]
  210a28:	4613      	mov	r3, r2
  210a2a:	011b      	lsls	r3, r3, #4
  210a2c:	1a9b      	subs	r3, r3, r2
  210a2e:	009b      	lsls	r3, r3, #2
  210a30:	440b      	add	r3, r1
  210a32:	332c      	adds	r3, #44	; 0x2c
  210a34:	881b      	ldrh	r3, [r3, #0]
  210a36:	469e      	mov	lr, r3
  210a38:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  210a3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  210a3c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
  210a40:	b2d2      	uxtb	r2, r2
  210a42:	4638      	mov	r0, r7
  210a44:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
  210a48:	910a      	str	r1, [sp, #40]	; 0x28
  210a4a:	9209      	str	r2, [sp, #36]	; 0x24
  210a4c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
  210a50:	9208      	str	r2, [sp, #32]
  210a52:	4a9e      	ldr	r2, [pc, #632]	; (210ccc <LCD_StrChangeColorMovV+0x594>)
  210a54:	9207      	str	r2, [sp, #28]
  210a56:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  210a5a:	9206      	str	r2, [sp, #24]
  210a5c:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  210a60:	9205      	str	r2, [sp, #20]
  210a62:	4a9b      	ldr	r2, [pc, #620]	; (210cd0 <LCD_StrChangeColorMovV+0x598>)
  210a64:	9204      	str	r2, [sp, #16]
  210a66:	9303      	str	r3, [sp, #12]
  210a68:	2300      	movs	r3, #0
  210a6a:	9302      	str	r3, [sp, #8]
  210a6c:	2300      	movs	r3, #0
  210a6e:	9301      	str	r3, [sp, #4]
  210a70:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  210a72:	9300      	str	r3, [sp, #0]
  210a74:	4623      	mov	r3, r4
  210a76:	4672      	mov	r2, lr
  210a78:	4629      	mov	r1, r5
  210a7a:	f7f9 fe35 	bl	20a6e8 <LCD_DrawStrChangeColor>
  210a7e:	f107 031c 	add.w	r3, r7, #28
  210a82:	463a      	mov	r2, r7
  210a84:	6810      	ldr	r0, [r2, #0]
  210a86:	6018      	str	r0, [r3, #0]
  210a88:	8892      	ldrh	r2, [r2, #4]
  210a8a:	809a      	strh	r2, [r3, #4]
  210a8c:	e037      	b.n	210afe <LCD_StrChangeColorMovV+0x3c6>
			else
				temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, FontVar[idVar].FontMov.xImgWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);
  210a8e:	4b8d      	ldr	r3, [pc, #564]	; (210cc4 <LCD_StrChangeColorMovV+0x58c>)
  210a90:	681b      	ldr	r3, [r3, #0]
  210a92:	461d      	mov	r5, r3
  210a94:	498c      	ldr	r1, [pc, #560]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210a96:	693a      	ldr	r2, [r7, #16]
  210a98:	4613      	mov	r3, r2
  210a9a:	011b      	lsls	r3, r3, #4
  210a9c:	1a9b      	subs	r3, r3, r2
  210a9e:	009b      	lsls	r3, r3, #2
  210aa0:	440b      	add	r3, r1
  210aa2:	332c      	adds	r3, #44	; 0x2c
  210aa4:	881b      	ldrh	r3, [r3, #0]
  210aa6:	469e      	mov	lr, r3
  210aa8:	6c3c      	ldr	r4, [r7, #64]	; 0x40
  210aaa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  210aac:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
  210ab0:	b2d2      	uxtb	r2, r2
  210ab2:	4638      	mov	r0, r7
  210ab4:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
  210ab8:	910a      	str	r1, [sp, #40]	; 0x28
  210aba:	9209      	str	r2, [sp, #36]	; 0x24
  210abc:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
  210ac0:	9208      	str	r2, [sp, #32]
  210ac2:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  210ac6:	9207      	str	r2, [sp, #28]
  210ac8:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  210acc:	9206      	str	r2, [sp, #24]
  210ace:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  210ad2:	9205      	str	r2, [sp, #20]
  210ad4:	4a7e      	ldr	r2, [pc, #504]	; (210cd0 <LCD_StrChangeColorMovV+0x598>)
  210ad6:	9204      	str	r2, [sp, #16]
  210ad8:	9303      	str	r3, [sp, #12]
  210ada:	2300      	movs	r3, #0
  210adc:	9302      	str	r3, [sp, #8]
  210ade:	2300      	movs	r3, #0
  210ae0:	9301      	str	r3, [sp, #4]
  210ae2:	6fbb      	ldr	r3, [r7, #120]	; 0x78
  210ae4:	9300      	str	r3, [sp, #0]
  210ae6:	4623      	mov	r3, r4
  210ae8:	4672      	mov	r2, lr
  210aea:	4629      	mov	r1, r5
  210aec:	f7f9 fdfc 	bl	20a6e8 <LCD_DrawStrChangeColor>
  210af0:	f107 031c 	add.w	r3, r7, #28
  210af4:	463a      	mov	r2, r7
  210af6:	6810      	ldr	r0, [r2, #0]
  210af8:	6018      	str	r0, [r3, #0]
  210afa:	8892      	ldrh	r2, [r2, #4]
  210afc:	809a      	strh	r2, [r3, #4]
			//temp=LCD_DrawStrChangeColor(movableFontsBuffer_pos, FontVar[idVar].FontMov.xImgWidth, fontHeight, fontID,0,0,bufTxt,movableFontsBuffer,OnlyDigits,space,bkColor,fontColor,maxVal,constWidth);

			int diffWidth=winWidth-temp.inPixel;
  210afe:	8bfb      	ldrh	r3, [r7, #30]
  210b00:	461a      	mov	r2, r3
  210b02:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210b04:	1a9b      	subs	r3, r3, r2
  210b06:	62bb      	str	r3, [r7, #40]	; 0x28
			if(diffWidth>0)
  210b08:	6abb      	ldr	r3, [r7, #40]	; 0x28
  210b0a:	2b00      	cmp	r3, #0
  210b0c:	dd25      	ble.n	210b5a <LCD_StrChangeColorMovV+0x422>
				LCD_RectangleBuff(movableFontsBuffer,movableFontsBuffer_pos, FontVar[idVar].FontMov.xImgWidth,fontHeight, temp.inPixel,0, diffWidth,fontHeight, bkColor,bkColor,bkColor);
  210b0e:	4b6d      	ldr	r3, [pc, #436]	; (210cc4 <LCD_StrChangeColorMovV+0x58c>)
  210b10:	681b      	ldr	r3, [r3, #0]
  210b12:	461d      	mov	r5, r3
  210b14:	496c      	ldr	r1, [pc, #432]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210b16:	693a      	ldr	r2, [r7, #16]
  210b18:	4613      	mov	r3, r2
  210b1a:	011b      	lsls	r3, r3, #4
  210b1c:	1a9b      	subs	r3, r3, r2
  210b1e:	009b      	lsls	r3, r3, #2
  210b20:	440b      	add	r3, r1
  210b22:	332c      	adds	r3, #44	; 0x2c
  210b24:	881b      	ldrh	r3, [r3, #0]
  210b26:	469e      	mov	lr, r3
  210b28:	6c38      	ldr	r0, [r7, #64]	; 0x40
  210b2a:	8bfb      	ldrh	r3, [r7, #30]
  210b2c:	461c      	mov	r4, r3
  210b2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  210b30:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  210b32:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  210b36:	9106      	str	r1, [sp, #24]
  210b38:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  210b3c:	9105      	str	r1, [sp, #20]
  210b3e:	f8d7 1090 	ldr.w	r1, [r7, #144]	; 0x90
  210b42:	9104      	str	r1, [sp, #16]
  210b44:	9203      	str	r2, [sp, #12]
  210b46:	9302      	str	r3, [sp, #8]
  210b48:	2300      	movs	r3, #0
  210b4a:	9301      	str	r3, [sp, #4]
  210b4c:	9400      	str	r4, [sp, #0]
  210b4e:	4603      	mov	r3, r0
  210b50:	4672      	mov	r2, lr
  210b52:	4629      	mov	r1, r5
  210b54:	485e      	ldr	r0, [pc, #376]	; (210cd0 <LCD_StrChangeColorMovV+0x598>)
  210b56:	f7f7 fa31 	bl	207fbc <LCD_RectangleBuff>

			movableFontsBuffer_pos += fontHeight*FontVar[idVar].FontMov.xImgWidth;
  210b5a:	495b      	ldr	r1, [pc, #364]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210b5c:	693a      	ldr	r2, [r7, #16]
  210b5e:	4613      	mov	r3, r2
  210b60:	011b      	lsls	r3, r3, #4
  210b62:	1a9b      	subs	r3, r3, r2
  210b64:	009b      	lsls	r3, r3, #2
  210b66:	440b      	add	r3, r1
  210b68:	332c      	adds	r3, #44	; 0x2c
  210b6a:	881b      	ldrh	r3, [r3, #0]
  210b6c:	461a      	mov	r2, r3
  210b6e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210b70:	fb03 f202 	mul.w	r2, r3, r2
  210b74:	4b53      	ldr	r3, [pc, #332]	; (210cc4 <LCD_StrChangeColorMovV+0x58c>)
  210b76:	681b      	ldr	r3, [r3, #0]
  210b78:	4413      	add	r3, r2
  210b7a:	4a52      	ldr	r2, [pc, #328]	; (210cc4 <LCD_StrChangeColorMovV+0x58c>)
  210b7c:	6013      	str	r3, [r2, #0]
			iH++;
  210b7e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  210b80:	3301      	adds	r3, #1
  210b82:	64bb      	str	r3, [r7, #72]	; 0x48
		}while(movableFontsBuffer_pos + fontHeight*FontVar[idVar].FontMov.xImgWidth < LCD_MOVABLE_FONTS_BUFF_SIZE);
  210b84:	4950      	ldr	r1, [pc, #320]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210b86:	693a      	ldr	r2, [r7, #16]
  210b88:	4613      	mov	r3, r2
  210b8a:	011b      	lsls	r3, r3, #4
  210b8c:	1a9b      	subs	r3, r3, r2
  210b8e:	009b      	lsls	r3, r3, #2
  210b90:	440b      	add	r3, r1
  210b92:	332c      	adds	r3, #44	; 0x2c
  210b94:	881b      	ldrh	r3, [r3, #0]
  210b96:	461a      	mov	r2, r3
  210b98:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210b9a:	fb03 f202 	mul.w	r2, r3, r2
  210b9e:	4b49      	ldr	r3, [pc, #292]	; (210cc4 <LCD_StrChangeColorMovV+0x58c>)
  210ba0:	681b      	ldr	r3, [r3, #0]
  210ba2:	4413      	add	r3, r2
  210ba4:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
  210ba8:	f6ff aeea 	blt.w	210980 <LCD_StrChangeColorMovV+0x248>
  210bac:	e000      	b.n	210bb0 <LCD_StrChangeColorMovV+0x478>
			if(i==0) break;
  210bae:	bf00      	nop

		FontVar[idVar].FontMov.yImgHeight = fontHeight*iH;
  210bb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  210bb2:	b29a      	uxth	r2, r3
  210bb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  210bb6:	b29b      	uxth	r3, r3
  210bb8:	fb12 f303 	smulbb	r3, r2, r3
  210bbc:	b298      	uxth	r0, r3
  210bbe:	4942      	ldr	r1, [pc, #264]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210bc0:	693a      	ldr	r2, [r7, #16]
  210bc2:	4613      	mov	r3, r2
  210bc4:	011b      	lsls	r3, r3, #4
  210bc6:	1a9b      	subs	r3, r3, r2
  210bc8:	009b      	lsls	r3, r3, #2
  210bca:	440b      	add	r3, r1
  210bcc:	332e      	adds	r3, #46	; 0x2e
  210bce:	4602      	mov	r2, r0
  210bd0:	801a      	strh	r2, [r3, #0]
		int diffHeight = winHeight - FontVar[idVar].FontMov.yImgHeight;
  210bd2:	493d      	ldr	r1, [pc, #244]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210bd4:	693a      	ldr	r2, [r7, #16]
  210bd6:	4613      	mov	r3, r2
  210bd8:	011b      	lsls	r3, r3, #4
  210bda:	1a9b      	subs	r3, r3, r2
  210bdc:	009b      	lsls	r3, r3, #2
  210bde:	440b      	add	r3, r1
  210be0:	332e      	adds	r3, #46	; 0x2e
  210be2:	881b      	ldrh	r3, [r3, #0]
  210be4:	461a      	mov	r2, r3
  210be6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  210be8:	1a9b      	subs	r3, r3, r2
  210bea:	627b      	str	r3, [r7, #36]	; 0x24
		LCD_CopyBuff2pLcd(rot,FontVar[idVar].FontMov.posBuff, movableFontsBuffer, FontVar[idVar].FontMov.xImgWidth,winHeight, posWin*FontVar[idVar].FontMov.xImgWidth, winWidth, Xpos,Ypos,0);
  210bec:	4936      	ldr	r1, [pc, #216]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210bee:	693a      	ldr	r2, [r7, #16]
  210bf0:	4613      	mov	r3, r2
  210bf2:	011b      	lsls	r3, r3, #4
  210bf4:	1a9b      	subs	r3, r3, r2
  210bf6:	009b      	lsls	r3, r3, #2
  210bf8:	440b      	add	r3, r1
  210bfa:	3328      	adds	r3, #40	; 0x28
  210bfc:	681e      	ldr	r6, [r3, #0]
  210bfe:	4932      	ldr	r1, [pc, #200]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210c00:	693a      	ldr	r2, [r7, #16]
  210c02:	4613      	mov	r3, r2
  210c04:	011b      	lsls	r3, r3, #4
  210c06:	1a9b      	subs	r3, r3, r2
  210c08:	009b      	lsls	r3, r3, #2
  210c0a:	440b      	add	r3, r1
  210c0c:	332c      	adds	r3, #44	; 0x2c
  210c0e:	881b      	ldrh	r3, [r3, #0]
  210c10:	469e      	mov	lr, r3
  210c12:	6f79      	ldr	r1, [r7, #116]	; 0x74
  210c14:	482c      	ldr	r0, [pc, #176]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210c16:	693a      	ldr	r2, [r7, #16]
  210c18:	4613      	mov	r3, r2
  210c1a:	011b      	lsls	r3, r3, #4
  210c1c:	1a9b      	subs	r3, r3, r2
  210c1e:	009b      	lsls	r3, r3, #2
  210c20:	4403      	add	r3, r0
  210c22:	332c      	adds	r3, #44	; 0x2c
  210c24:	881b      	ldrh	r3, [r3, #0]
  210c26:	461a      	mov	r2, r3
  210c28:	68bb      	ldr	r3, [r7, #8]
  210c2a:	fb03 f302 	mul.w	r3, r3, r2
  210c2e:	6f3a      	ldr	r2, [r7, #112]	; 0x70
  210c30:	b292      	uxth	r2, r2
  210c32:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
  210c34:	b280      	uxth	r0, r0
  210c36:	f8d7 4080 	ldr.w	r4, [r7, #128]	; 0x80
  210c3a:	b2a4      	uxth	r4, r4
  210c3c:	2500      	movs	r5, #0
  210c3e:	9505      	str	r5, [sp, #20]
  210c40:	9404      	str	r4, [sp, #16]
  210c42:	9003      	str	r0, [sp, #12]
  210c44:	9202      	str	r2, [sp, #8]
  210c46:	9301      	str	r3, [sp, #4]
  210c48:	9100      	str	r1, [sp, #0]
  210c4a:	4673      	mov	r3, lr
  210c4c:	4a20      	ldr	r2, [pc, #128]	; (210cd0 <LCD_StrChangeColorMovV+0x598>)
  210c4e:	4631      	mov	r1, r6
  210c50:	68f8      	ldr	r0, [r7, #12]
  210c52:	f7f6 ff79 	bl	207b48 <LCD_CopyBuff2pLcd>

		if(diffHeight>0)
  210c56:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  210c58:	2b00      	cmp	r3, #0
  210c5a:	f340 8087 	ble.w	210d6c <LCD_StrChangeColorMovV+0x634>
		{	switch(rot)
  210c5e:	68fb      	ldr	r3, [r7, #12]
  210c60:	2b01      	cmp	r3, #1
  210c62:	d039      	beq.n	210cd8 <LCD_StrChangeColorMovV+0x5a0>
  210c64:	2b02      	cmp	r3, #2
  210c66:	d056      	beq.n	210d16 <LCD_StrChangeColorMovV+0x5de>
  210c68:	2b00      	cmp	r3, #0
  210c6a:	d17f      	bne.n	210d6c <LCD_StrChangeColorMovV+0x634>
			{
			case Rotate_0:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos+FontVar[idVar].FontMov.yImgHeight, winWidth,diffHeight, bkColor,bkColor,bkColor);
  210c6c:	f7f6 fe9c 	bl	2079a8 <LCD_GetXSize>
  210c70:	4605      	mov	r5, r0
  210c72:	f7f6 fead 	bl	2079d0 <LCD_GetYSize>
  210c76:	4606      	mov	r6, r0
  210c78:	6ff9      	ldr	r1, [r7, #124]	; 0x7c
  210c7a:	4813      	ldr	r0, [pc, #76]	; (210cc8 <LCD_StrChangeColorMovV+0x590>)
  210c7c:	693a      	ldr	r2, [r7, #16]
  210c7e:	4613      	mov	r3, r2
  210c80:	011b      	lsls	r3, r3, #4
  210c82:	1a9b      	subs	r3, r3, r2
  210c84:	009b      	lsls	r3, r3, #2
  210c86:	4403      	add	r3, r0
  210c88:	332e      	adds	r3, #46	; 0x2e
  210c8a:	881b      	ldrh	r3, [r3, #0]
  210c8c:	461a      	mov	r2, r3
  210c8e:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  210c92:	4413      	add	r3, r2
  210c94:	461c      	mov	r4, r3
  210c96:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210c98:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  210c9a:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210c9e:	9006      	str	r0, [sp, #24]
  210ca0:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210ca4:	9005      	str	r0, [sp, #20]
  210ca6:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210caa:	9004      	str	r0, [sp, #16]
  210cac:	9203      	str	r2, [sp, #12]
  210cae:	9302      	str	r3, [sp, #8]
  210cb0:	9401      	str	r4, [sp, #4]
  210cb2:	9100      	str	r1, [sp, #0]
  210cb4:	4633      	mov	r3, r6
  210cb6:	462a      	mov	r2, r5
  210cb8:	2100      	movs	r1, #0
  210cba:	4806      	ldr	r0, [pc, #24]	; (210cd4 <LCD_StrChangeColorMovV+0x59c>)
  210cbc:	f7f7 f97e 	bl	207fbc <LCD_RectangleBuff>
				break;
  210cc0:	e054      	b.n	210d6c <LCD_StrChangeColorMovV+0x634>
  210cc2:	bf00      	nop
  210cc4:	2000347c 	.word	0x2000347c
  210cc8:	2000f818 	.word	0x2000f818
  210ccc:	ff808080 	.word	0xff808080
  210cd0:	c067f800 	.word	0xc067f800
  210cd4:	c0000000 	.word	0xc0000000
			case Rotate_90:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos,Ypos, diffHeight,winWidth, bkColor,bkColor,bkColor);
  210cd8:	f7f6 fe66 	bl	2079a8 <LCD_GetXSize>
  210cdc:	4605      	mov	r5, r0
  210cde:	f7f6 fe77 	bl	2079d0 <LCD_GetYSize>
  210ce2:	4606      	mov	r6, r0
  210ce4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  210ce6:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  210cea:	6a79      	ldr	r1, [r7, #36]	; 0x24
  210cec:	6f38      	ldr	r0, [r7, #112]	; 0x70
  210cee:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
  210cf2:	9406      	str	r4, [sp, #24]
  210cf4:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
  210cf8:	9405      	str	r4, [sp, #20]
  210cfa:	f8d7 4090 	ldr.w	r4, [r7, #144]	; 0x90
  210cfe:	9404      	str	r4, [sp, #16]
  210d00:	9003      	str	r0, [sp, #12]
  210d02:	9102      	str	r1, [sp, #8]
  210d04:	9201      	str	r2, [sp, #4]
  210d06:	9300      	str	r3, [sp, #0]
  210d08:	4633      	mov	r3, r6
  210d0a:	462a      	mov	r2, r5
  210d0c:	2100      	movs	r1, #0
  210d0e:	4845      	ldr	r0, [pc, #276]	; (210e24 <LCD_StrChangeColorMovV+0x6ec>)
  210d10:	f7f7 f954 	bl	207fbc <LCD_RectangleBuff>
				break;
  210d14:	e02a      	b.n	210d6c <LCD_StrChangeColorMovV+0x634>
			case Rotate_180:
				LCD_RectangleBuff(pLcd,0, LCD_GetXSize(),LCD_GetYSize(), Xpos+FontVar[idVar].FontMov.yImgHeight,Ypos, diffHeight,winWidth, bkColor,bkColor,bkColor);
  210d16:	f7f6 fe47 	bl	2079a8 <LCD_GetXSize>
  210d1a:	4605      	mov	r5, r0
  210d1c:	f7f6 fe58 	bl	2079d0 <LCD_GetYSize>
  210d20:	4606      	mov	r6, r0
  210d22:	4941      	ldr	r1, [pc, #260]	; (210e28 <LCD_StrChangeColorMovV+0x6f0>)
  210d24:	693a      	ldr	r2, [r7, #16]
  210d26:	4613      	mov	r3, r2
  210d28:	011b      	lsls	r3, r3, #4
  210d2a:	1a9b      	subs	r3, r3, r2
  210d2c:	009b      	lsls	r3, r3, #2
  210d2e:	440b      	add	r3, r1
  210d30:	332e      	adds	r3, #46	; 0x2e
  210d32:	881b      	ldrh	r3, [r3, #0]
  210d34:	461a      	mov	r2, r3
  210d36:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  210d38:	4413      	add	r3, r2
  210d3a:	461c      	mov	r4, r3
  210d3c:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  210d40:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  210d42:	6f39      	ldr	r1, [r7, #112]	; 0x70
  210d44:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210d48:	9006      	str	r0, [sp, #24]
  210d4a:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210d4e:	9005      	str	r0, [sp, #20]
  210d50:	f8d7 0090 	ldr.w	r0, [r7, #144]	; 0x90
  210d54:	9004      	str	r0, [sp, #16]
  210d56:	9103      	str	r1, [sp, #12]
  210d58:	9202      	str	r2, [sp, #8]
  210d5a:	9301      	str	r3, [sp, #4]
  210d5c:	9400      	str	r4, [sp, #0]
  210d5e:	4633      	mov	r3, r6
  210d60:	462a      	mov	r2, r5
  210d62:	2100      	movs	r1, #0
  210d64:	482f      	ldr	r0, [pc, #188]	; (210e24 <LCD_StrChangeColorMovV+0x6ec>)
  210d66:	f7f7 f929 	bl	207fbc <LCD_RectangleBuff>
				break;
  210d6a:	bf00      	nop
			}
		}
		FontVar[idVar].xPos_prev = Xpos;
  210d6c:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
  210d6e:	b298      	uxth	r0, r3
  210d70:	492d      	ldr	r1, [pc, #180]	; (210e28 <LCD_StrChangeColorMovV+0x6f0>)
  210d72:	693a      	ldr	r2, [r7, #16]
  210d74:	4613      	mov	r3, r2
  210d76:	011b      	lsls	r3, r3, #4
  210d78:	1a9b      	subs	r3, r3, r2
  210d7a:	009b      	lsls	r3, r3, #2
  210d7c:	440b      	add	r3, r1
  210d7e:	331e      	adds	r3, #30
  210d80:	4602      	mov	r2, r0
  210d82:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].yPos_prev = Ypos;
  210d84:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
  210d88:	b298      	uxth	r0, r3
  210d8a:	4927      	ldr	r1, [pc, #156]	; (210e28 <LCD_StrChangeColorMovV+0x6f0>)
  210d8c:	693a      	ldr	r2, [r7, #16]
  210d8e:	4613      	mov	r3, r2
  210d90:	011b      	lsls	r3, r3, #4
  210d92:	1a9b      	subs	r3, r3, r2
  210d94:	009b      	lsls	r3, r3, #2
  210d96:	440b      	add	r3, r1
  210d98:	3320      	adds	r3, #32
  210d9a:	4602      	mov	r2, r0
  210d9c:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].widthPxl_prev = winWidth;
  210d9e:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210da0:	b298      	uxth	r0, r3
  210da2:	4921      	ldr	r1, [pc, #132]	; (210e28 <LCD_StrChangeColorMovV+0x6f0>)
  210da4:	693a      	ldr	r2, [r7, #16]
  210da6:	4613      	mov	r3, r2
  210da8:	011b      	lsls	r3, r3, #4
  210daa:	1a9b      	subs	r3, r3, r2
  210dac:	009b      	lsls	r3, r3, #2
  210dae:	440b      	add	r3, r1
  210db0:	3322      	adds	r3, #34	; 0x22
  210db2:	4602      	mov	r2, r0
  210db4:	801a      	strh	r2, [r3, #0]
		FontVar[idVar].heightPxl_prev = winHeight;
  210db6:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  210db8:	b298      	uxth	r0, r3
  210dba:	491b      	ldr	r1, [pc, #108]	; (210e28 <LCD_StrChangeColorMovV+0x6f0>)
  210dbc:	693a      	ldr	r2, [r7, #16]
  210dbe:	4613      	mov	r3, r2
  210dc0:	011b      	lsls	r3, r3, #4
  210dc2:	1a9b      	subs	r3, r3, r2
  210dc4:	009b      	lsls	r3, r3, #2
  210dc6:	440b      	add	r3, r1
  210dc8:	3324      	adds	r3, #36	; 0x24
  210dca:	4602      	mov	r2, r0
  210dcc:	801a      	strh	r2, [r3, #0]

		temp.inChar=0;
  210dce:	2300      	movs	r3, #0
  210dd0:	83bb      	strh	r3, [r7, #28]
		temp.inPixel=winWidth;
  210dd2:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  210dd4:	b29b      	uxth	r3, r3
  210dd6:	83fb      	strh	r3, [r7, #30]
		temp.height=winHeight;
  210dd8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
  210dda:	b29b      	uxth	r3, r3
  210ddc:	843b      	strh	r3, [r7, #32]
		if(rot>Rotate_0)
  210dde:	68fb      	ldr	r3, [r7, #12]
  210de0:	2b00      	cmp	r3, #0
  210de2:	dd09      	ble.n	210df8 <LCD_StrChangeColorMovV+0x6c0>
			SwapUint16(&temp.inPixel,&temp.height);
  210de4:	f107 031c 	add.w	r3, r7, #28
  210de8:	1d1a      	adds	r2, r3, #4
  210dea:	f107 031c 	add.w	r3, r7, #28
  210dee:	3302      	adds	r3, #2
  210df0:	4611      	mov	r1, r2
  210df2:	4618      	mov	r0, r3
  210df4:	f7f0 fe9c 	bl	201b30 <SwapUint16>
		return temp;
  210df8:	697b      	ldr	r3, [r7, #20]
  210dfa:	461a      	mov	r2, r3
  210dfc:	f107 031c 	add.w	r3, r7, #28
  210e00:	6818      	ldr	r0, [r3, #0]
  210e02:	6010      	str	r0, [r2, #0]
  210e04:	889b      	ldrh	r3, [r3, #4]
  210e06:	8093      	strh	r3, [r2, #4]
  210e08:	46d5      	mov	sp, sl
  210e0a:	e005      	b.n	210e18 <LCD_StrChangeColorMovV+0x6e0>
	}
	else return StructTxtPxlLen_ZeroValue;
  210e0c:	697b      	ldr	r3, [r7, #20]
  210e0e:	4a07      	ldr	r2, [pc, #28]	; (210e2c <LCD_StrChangeColorMovV+0x6f4>)
  210e10:	6810      	ldr	r0, [r2, #0]
  210e12:	6018      	str	r0, [r3, #0]
  210e14:	8892      	ldrh	r2, [r2, #4]
  210e16:	809a      	strh	r2, [r3, #4]
}
  210e18:	6978      	ldr	r0, [r7, #20]
  210e1a:	3750      	adds	r7, #80	; 0x50
  210e1c:	46bd      	mov	sp, r7
  210e1e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  210e22:	bf00      	nop
  210e24:	c0000000 	.word	0xc0000000
  210e28:	2000f818 	.word	0x2000f818
  210e2c:	20003474 	.word	0x20003474

00210e30 <LCD_StrMovVIndirect>:

int LCD_StrMovVIndirect(int idVar, int incrDecr)
{
  210e30:	b5f0      	push	{r4, r5, r6, r7, lr}
  210e32:	b093      	sub	sp, #76	; 0x4c
  210e34:	af08      	add	r7, sp, #32
  210e36:	60f8      	str	r0, [r7, #12]
  210e38:	60b9      	str	r1, [r7, #8]
	#define M	FontVar[idVar].FontMov
	#define F	FontVar[idVar]

	if(SearchFontIndex(FontID[F.id].size, FontID[F.id].style, FontID[F.id].bkColor, FontID[F.id].color)<0)
  210e3a:	49ad      	ldr	r1, [pc, #692]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210e3c:	68fa      	ldr	r2, [r7, #12]
  210e3e:	4613      	mov	r3, r2
  210e40:	011b      	lsls	r3, r3, #4
  210e42:	1a9b      	subs	r3, r3, r2
  210e44:	009b      	lsls	r3, r3, #2
  210e46:	440b      	add	r3, r1
  210e48:	881b      	ldrh	r3, [r3, #0]
  210e4a:	4aaa      	ldr	r2, [pc, #680]	; (2110f4 <LCD_StrMovVIndirect+0x2c4>)
  210e4c:	011b      	lsls	r3, r3, #4
  210e4e:	4413      	add	r3, r2
  210e50:	681b      	ldr	r3, [r3, #0]
  210e52:	461c      	mov	r4, r3
  210e54:	49a6      	ldr	r1, [pc, #664]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210e56:	68fa      	ldr	r2, [r7, #12]
  210e58:	4613      	mov	r3, r2
  210e5a:	011b      	lsls	r3, r3, #4
  210e5c:	1a9b      	subs	r3, r3, r2
  210e5e:	009b      	lsls	r3, r3, #2
  210e60:	440b      	add	r3, r1
  210e62:	881b      	ldrh	r3, [r3, #0]
  210e64:	4aa3      	ldr	r2, [pc, #652]	; (2110f4 <LCD_StrMovVIndirect+0x2c4>)
  210e66:	011b      	lsls	r3, r3, #4
  210e68:	4413      	add	r3, r2
  210e6a:	3304      	adds	r3, #4
  210e6c:	681b      	ldr	r3, [r3, #0]
  210e6e:	461d      	mov	r5, r3
  210e70:	499f      	ldr	r1, [pc, #636]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210e72:	68fa      	ldr	r2, [r7, #12]
  210e74:	4613      	mov	r3, r2
  210e76:	011b      	lsls	r3, r3, #4
  210e78:	1a9b      	subs	r3, r3, r2
  210e7a:	009b      	lsls	r3, r3, #2
  210e7c:	440b      	add	r3, r1
  210e7e:	881b      	ldrh	r3, [r3, #0]
  210e80:	4a9c      	ldr	r2, [pc, #624]	; (2110f4 <LCD_StrMovVIndirect+0x2c4>)
  210e82:	011b      	lsls	r3, r3, #4
  210e84:	4413      	add	r3, r2
  210e86:	3308      	adds	r3, #8
  210e88:	6818      	ldr	r0, [r3, #0]
  210e8a:	4999      	ldr	r1, [pc, #612]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210e8c:	68fa      	ldr	r2, [r7, #12]
  210e8e:	4613      	mov	r3, r2
  210e90:	011b      	lsls	r3, r3, #4
  210e92:	1a9b      	subs	r3, r3, r2
  210e94:	009b      	lsls	r3, r3, #2
  210e96:	440b      	add	r3, r1
  210e98:	881b      	ldrh	r3, [r3, #0]
  210e9a:	4a96      	ldr	r2, [pc, #600]	; (2110f4 <LCD_StrMovVIndirect+0x2c4>)
  210e9c:	011b      	lsls	r3, r3, #4
  210e9e:	4413      	add	r3, r2
  210ea0:	330c      	adds	r3, #12
  210ea2:	681b      	ldr	r3, [r3, #0]
  210ea4:	4602      	mov	r2, r0
  210ea6:	4629      	mov	r1, r5
  210ea8:	4620      	mov	r0, r4
  210eaa:	f7f7 fceb 	bl	208884 <SearchFontIndex>
  210eae:	4603      	mov	r3, r0
  210eb0:	2b00      	cmp	r3, #0
  210eb2:	da03      	bge.n	210ebc <LCD_StrMovVIndirect+0x8c>
		return -1;
  210eb4:	f04f 33ff 	mov.w	r3, #4294967295
  210eb8:	f001 b8fe 	b.w	2120b8 <LCD_StrMovVIndirect+0x1288>

	if(M.windowHeight>M.yImgHeight) return 0;
  210ebc:	498c      	ldr	r1, [pc, #560]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210ebe:	68fa      	ldr	r2, [r7, #12]
  210ec0:	4613      	mov	r3, r2
  210ec2:	011b      	lsls	r3, r3, #4
  210ec4:	1a9b      	subs	r3, r3, r2
  210ec6:	009b      	lsls	r3, r3, #2
  210ec8:	440b      	add	r3, r1
  210eca:	3334      	adds	r3, #52	; 0x34
  210ecc:	8819      	ldrh	r1, [r3, #0]
  210ece:	4888      	ldr	r0, [pc, #544]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210ed0:	68fa      	ldr	r2, [r7, #12]
  210ed2:	4613      	mov	r3, r2
  210ed4:	011b      	lsls	r3, r3, #4
  210ed6:	1a9b      	subs	r3, r3, r2
  210ed8:	009b      	lsls	r3, r3, #2
  210eda:	4403      	add	r3, r0
  210edc:	332e      	adds	r3, #46	; 0x2e
  210ede:	881b      	ldrh	r3, [r3, #0]
  210ee0:	4299      	cmp	r1, r3
  210ee2:	d902      	bls.n	210eea <LCD_StrMovVIndirect+0xba>
  210ee4:	2300      	movs	r3, #0
  210ee6:	f001 b8e7 	b.w	2120b8 <LCD_StrMovVIndirect+0x1288>

	if(M.posWin+incrDecr>=0)
  210eea:	4981      	ldr	r1, [pc, #516]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210eec:	68fa      	ldr	r2, [r7, #12]
  210eee:	4613      	mov	r3, r2
  210ef0:	011b      	lsls	r3, r3, #4
  210ef2:	1a9b      	subs	r3, r3, r2
  210ef4:	009b      	lsls	r3, r3, #2
  210ef6:	440b      	add	r3, r1
  210ef8:	3330      	adds	r3, #48	; 0x30
  210efa:	881b      	ldrh	r3, [r3, #0]
  210efc:	461a      	mov	r2, r3
  210efe:	68bb      	ldr	r3, [r7, #8]
  210f00:	4413      	add	r3, r2
  210f02:	2b00      	cmp	r3, #0
  210f04:	db16      	blt.n	210f34 <LCD_StrMovVIndirect+0x104>
		M.posWin += incrDecr;
  210f06:	497a      	ldr	r1, [pc, #488]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f08:	68fa      	ldr	r2, [r7, #12]
  210f0a:	4613      	mov	r3, r2
  210f0c:	011b      	lsls	r3, r3, #4
  210f0e:	1a9b      	subs	r3, r3, r2
  210f10:	009b      	lsls	r3, r3, #2
  210f12:	440b      	add	r3, r1
  210f14:	3330      	adds	r3, #48	; 0x30
  210f16:	881a      	ldrh	r2, [r3, #0]
  210f18:	68bb      	ldr	r3, [r7, #8]
  210f1a:	b29b      	uxth	r3, r3
  210f1c:	4413      	add	r3, r2
  210f1e:	b298      	uxth	r0, r3
  210f20:	4973      	ldr	r1, [pc, #460]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f22:	68fa      	ldr	r2, [r7, #12]
  210f24:	4613      	mov	r3, r2
  210f26:	011b      	lsls	r3, r3, #4
  210f28:	1a9b      	subs	r3, r3, r2
  210f2a:	009b      	lsls	r3, r3, #2
  210f2c:	440b      	add	r3, r1
  210f2e:	3330      	adds	r3, #48	; 0x30
  210f30:	4602      	mov	r2, r0
  210f32:	801a      	strh	r2, [r3, #0]

	if(M.posWin+M.windowHeight <= M.yImgHeight)
  210f34:	496e      	ldr	r1, [pc, #440]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f36:	68fa      	ldr	r2, [r7, #12]
  210f38:	4613      	mov	r3, r2
  210f3a:	011b      	lsls	r3, r3, #4
  210f3c:	1a9b      	subs	r3, r3, r2
  210f3e:	009b      	lsls	r3, r3, #2
  210f40:	440b      	add	r3, r1
  210f42:	3330      	adds	r3, #48	; 0x30
  210f44:	881b      	ldrh	r3, [r3, #0]
  210f46:	4618      	mov	r0, r3
  210f48:	4969      	ldr	r1, [pc, #420]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f4a:	68fa      	ldr	r2, [r7, #12]
  210f4c:	4613      	mov	r3, r2
  210f4e:	011b      	lsls	r3, r3, #4
  210f50:	1a9b      	subs	r3, r3, r2
  210f52:	009b      	lsls	r3, r3, #2
  210f54:	440b      	add	r3, r1
  210f56:	3334      	adds	r3, #52	; 0x34
  210f58:	881b      	ldrh	r3, [r3, #0]
  210f5a:	18c1      	adds	r1, r0, r3
  210f5c:	4864      	ldr	r0, [pc, #400]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f5e:	68fa      	ldr	r2, [r7, #12]
  210f60:	4613      	mov	r3, r2
  210f62:	011b      	lsls	r3, r3, #4
  210f64:	1a9b      	subs	r3, r3, r2
  210f66:	009b      	lsls	r3, r3, #2
  210f68:	4403      	add	r3, r0
  210f6a:	332e      	adds	r3, #46	; 0x2e
  210f6c:	881b      	ldrh	r3, [r3, #0]
  210f6e:	4299      	cmp	r1, r3
  210f70:	f300 80c6 	bgt.w	211100 <LCD_StrMovVIndirect+0x2d0>
	{
		LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth,M.windowHeight, M.posWin*M.xImgWidth, M.windowWidth,0);
  210f74:	495e      	ldr	r1, [pc, #376]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f76:	68fa      	ldr	r2, [r7, #12]
  210f78:	4613      	mov	r3, r2
  210f7a:	011b      	lsls	r3, r3, #4
  210f7c:	1a9b      	subs	r3, r3, r2
  210f7e:	009b      	lsls	r3, r3, #2
  210f80:	440b      	add	r3, r1
  210f82:	3314      	adds	r3, #20
  210f84:	781b      	ldrb	r3, [r3, #0]
  210f86:	461e      	mov	r6, r3
  210f88:	4959      	ldr	r1, [pc, #356]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f8a:	68fa      	ldr	r2, [r7, #12]
  210f8c:	4613      	mov	r3, r2
  210f8e:	011b      	lsls	r3, r3, #4
  210f90:	1a9b      	subs	r3, r3, r2
  210f92:	009b      	lsls	r3, r3, #2
  210f94:	440b      	add	r3, r1
  210f96:	3328      	adds	r3, #40	; 0x28
  210f98:	681c      	ldr	r4, [r3, #0]
  210f9a:	4955      	ldr	r1, [pc, #340]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210f9c:	68fa      	ldr	r2, [r7, #12]
  210f9e:	4613      	mov	r3, r2
  210fa0:	011b      	lsls	r3, r3, #4
  210fa2:	1a9b      	subs	r3, r3, r2
  210fa4:	009b      	lsls	r3, r3, #2
  210fa6:	440b      	add	r3, r1
  210fa8:	332c      	adds	r3, #44	; 0x2c
  210faa:	881b      	ldrh	r3, [r3, #0]
  210fac:	469e      	mov	lr, r3
  210fae:	4950      	ldr	r1, [pc, #320]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210fb0:	68fa      	ldr	r2, [r7, #12]
  210fb2:	4613      	mov	r3, r2
  210fb4:	011b      	lsls	r3, r3, #4
  210fb6:	1a9b      	subs	r3, r3, r2
  210fb8:	009b      	lsls	r3, r3, #2
  210fba:	440b      	add	r3, r1
  210fbc:	3334      	adds	r3, #52	; 0x34
  210fbe:	881b      	ldrh	r3, [r3, #0]
  210fc0:	461d      	mov	r5, r3
  210fc2:	494b      	ldr	r1, [pc, #300]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210fc4:	68fa      	ldr	r2, [r7, #12]
  210fc6:	4613      	mov	r3, r2
  210fc8:	011b      	lsls	r3, r3, #4
  210fca:	1a9b      	subs	r3, r3, r2
  210fcc:	009b      	lsls	r3, r3, #2
  210fce:	440b      	add	r3, r1
  210fd0:	3330      	adds	r3, #48	; 0x30
  210fd2:	881b      	ldrh	r3, [r3, #0]
  210fd4:	4618      	mov	r0, r3
  210fd6:	4946      	ldr	r1, [pc, #280]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210fd8:	68fa      	ldr	r2, [r7, #12]
  210fda:	4613      	mov	r3, r2
  210fdc:	011b      	lsls	r3, r3, #4
  210fde:	1a9b      	subs	r3, r3, r2
  210fe0:	009b      	lsls	r3, r3, #2
  210fe2:	440b      	add	r3, r1
  210fe4:	332c      	adds	r3, #44	; 0x2c
  210fe6:	881b      	ldrh	r3, [r3, #0]
  210fe8:	fb03 f100 	mul.w	r1, r3, r0
  210fec:	4840      	ldr	r0, [pc, #256]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  210fee:	68fa      	ldr	r2, [r7, #12]
  210ff0:	4613      	mov	r3, r2
  210ff2:	011b      	lsls	r3, r3, #4
  210ff4:	1a9b      	subs	r3, r3, r2
  210ff6:	009b      	lsls	r3, r3, #2
  210ff8:	4403      	add	r3, r0
  210ffa:	3332      	adds	r3, #50	; 0x32
  210ffc:	881b      	ldrh	r3, [r3, #0]
  210ffe:	2200      	movs	r2, #0
  211000:	9203      	str	r2, [sp, #12]
  211002:	9302      	str	r3, [sp, #8]
  211004:	9101      	str	r1, [sp, #4]
  211006:	9500      	str	r5, [sp, #0]
  211008:	4673      	mov	r3, lr
  21100a:	4a3b      	ldr	r2, [pc, #236]	; (2110f8 <LCD_StrMovVIndirect+0x2c8>)
  21100c:	4621      	mov	r1, r4
  21100e:	4630      	mov	r0, r6
  211010:	f7f6 fe6c 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
		switch(F.rotate)
  211014:	4936      	ldr	r1, [pc, #216]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  211016:	68fa      	ldr	r2, [r7, #12]
  211018:	4613      	mov	r3, r2
  21101a:	011b      	lsls	r3, r3, #4
  21101c:	1a9b      	subs	r3, r3, r2
  21101e:	009b      	lsls	r3, r3, #2
  211020:	440b      	add	r3, r1
  211022:	3314      	adds	r3, #20
  211024:	781b      	ldrb	r3, [r3, #0]
  211026:	2b00      	cmp	r3, #0
  211028:	d130      	bne.n	21108c <LCD_StrMovVIndirect+0x25c>
		{	case Rotate_0:
				LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowWidth, M.windowHeight, pLcd);
  21102a:	4931      	ldr	r1, [pc, #196]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  21102c:	68fa      	ldr	r2, [r7, #12]
  21102e:	4613      	mov	r3, r2
  211030:	011b      	lsls	r3, r3, #4
  211032:	1a9b      	subs	r3, r3, r2
  211034:	009b      	lsls	r3, r3, #2
  211036:	440b      	add	r3, r1
  211038:	3302      	adds	r3, #2
  21103a:	881b      	ldrh	r3, [r3, #0]
  21103c:	4618      	mov	r0, r3
  21103e:	492c      	ldr	r1, [pc, #176]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  211040:	68fa      	ldr	r2, [r7, #12]
  211042:	4613      	mov	r3, r2
  211044:	011b      	lsls	r3, r3, #4
  211046:	1a9b      	subs	r3, r3, r2
  211048:	009b      	lsls	r3, r3, #2
  21104a:	440b      	add	r3, r1
  21104c:	3304      	adds	r3, #4
  21104e:	881b      	ldrh	r3, [r3, #0]
  211050:	461c      	mov	r4, r3
  211052:	4927      	ldr	r1, [pc, #156]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  211054:	68fa      	ldr	r2, [r7, #12]
  211056:	4613      	mov	r3, r2
  211058:	011b      	lsls	r3, r3, #4
  21105a:	1a9b      	subs	r3, r3, r2
  21105c:	009b      	lsls	r3, r3, #2
  21105e:	440b      	add	r3, r1
  211060:	3332      	adds	r3, #50	; 0x32
  211062:	881b      	ldrh	r3, [r3, #0]
  211064:	461d      	mov	r5, r3
  211066:	4922      	ldr	r1, [pc, #136]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  211068:	68fa      	ldr	r2, [r7, #12]
  21106a:	4613      	mov	r3, r2
  21106c:	011b      	lsls	r3, r3, #4
  21106e:	1a9b      	subs	r3, r3, r2
  211070:	009b      	lsls	r3, r3, #2
  211072:	440b      	add	r3, r1
  211074:	3334      	adds	r3, #52	; 0x34
  211076:	881b      	ldrh	r3, [r3, #0]
  211078:	461a      	mov	r2, r3
  21107a:	4b20      	ldr	r3, [pc, #128]	; (2110fc <LCD_StrMovVIndirect+0x2cc>)
  21107c:	9300      	str	r3, [sp, #0]
  21107e:	4613      	mov	r3, r2
  211080:	462a      	mov	r2, r5
  211082:	4621      	mov	r1, r4
  211084:	f7f6 fd06 	bl	207a94 <LCD_DisplayBuff>
				break;
  211088:	f001 b815 	b.w	2120b6 <LCD_StrMovVIndirect+0x1286>
			case Rotate_90:
			case Rotate_180:
			default:
				LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowHeight, M.windowWidth, pLcd);
  21108c:	4918      	ldr	r1, [pc, #96]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  21108e:	68fa      	ldr	r2, [r7, #12]
  211090:	4613      	mov	r3, r2
  211092:	011b      	lsls	r3, r3, #4
  211094:	1a9b      	subs	r3, r3, r2
  211096:	009b      	lsls	r3, r3, #2
  211098:	440b      	add	r3, r1
  21109a:	3302      	adds	r3, #2
  21109c:	881b      	ldrh	r3, [r3, #0]
  21109e:	4618      	mov	r0, r3
  2110a0:	4913      	ldr	r1, [pc, #76]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  2110a2:	68fa      	ldr	r2, [r7, #12]
  2110a4:	4613      	mov	r3, r2
  2110a6:	011b      	lsls	r3, r3, #4
  2110a8:	1a9b      	subs	r3, r3, r2
  2110aa:	009b      	lsls	r3, r3, #2
  2110ac:	440b      	add	r3, r1
  2110ae:	3304      	adds	r3, #4
  2110b0:	881b      	ldrh	r3, [r3, #0]
  2110b2:	461c      	mov	r4, r3
  2110b4:	490e      	ldr	r1, [pc, #56]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  2110b6:	68fa      	ldr	r2, [r7, #12]
  2110b8:	4613      	mov	r3, r2
  2110ba:	011b      	lsls	r3, r3, #4
  2110bc:	1a9b      	subs	r3, r3, r2
  2110be:	009b      	lsls	r3, r3, #2
  2110c0:	440b      	add	r3, r1
  2110c2:	3334      	adds	r3, #52	; 0x34
  2110c4:	881b      	ldrh	r3, [r3, #0]
  2110c6:	461d      	mov	r5, r3
  2110c8:	4909      	ldr	r1, [pc, #36]	; (2110f0 <LCD_StrMovVIndirect+0x2c0>)
  2110ca:	68fa      	ldr	r2, [r7, #12]
  2110cc:	4613      	mov	r3, r2
  2110ce:	011b      	lsls	r3, r3, #4
  2110d0:	1a9b      	subs	r3, r3, r2
  2110d2:	009b      	lsls	r3, r3, #2
  2110d4:	440b      	add	r3, r1
  2110d6:	3332      	adds	r3, #50	; 0x32
  2110d8:	881b      	ldrh	r3, [r3, #0]
  2110da:	461a      	mov	r2, r3
  2110dc:	4b07      	ldr	r3, [pc, #28]	; (2110fc <LCD_StrMovVIndirect+0x2cc>)
  2110de:	9300      	str	r3, [sp, #0]
  2110e0:	4613      	mov	r3, r2
  2110e2:	462a      	mov	r2, r5
  2110e4:	4621      	mov	r1, r4
  2110e6:	f7f6 fcd5 	bl	207a94 <LCD_DisplayBuff>
				break;
  2110ea:	bf00      	nop
  2110ec:	f000 bfe3 	b.w	2120b6 <LCD_StrMovVIndirect+0x1286>
  2110f0:	2000f818 	.word	0x2000f818
  2110f4:	20003480 	.word	0x20003480
  2110f8:	c067f800 	.word	0xc067f800
  2110fc:	c0000000 	.word	0xc0000000
		}
	}
	else
	{	int height_empty = M.posWin + M.windowHeight - M.yImgHeight;
  211100:	498c      	ldr	r1, [pc, #560]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211102:	68fa      	ldr	r2, [r7, #12]
  211104:	4613      	mov	r3, r2
  211106:	011b      	lsls	r3, r3, #4
  211108:	1a9b      	subs	r3, r3, r2
  21110a:	009b      	lsls	r3, r3, #2
  21110c:	440b      	add	r3, r1
  21110e:	3330      	adds	r3, #48	; 0x30
  211110:	881b      	ldrh	r3, [r3, #0]
  211112:	4618      	mov	r0, r3
  211114:	4987      	ldr	r1, [pc, #540]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211116:	68fa      	ldr	r2, [r7, #12]
  211118:	4613      	mov	r3, r2
  21111a:	011b      	lsls	r3, r3, #4
  21111c:	1a9b      	subs	r3, r3, r2
  21111e:	009b      	lsls	r3, r3, #2
  211120:	440b      	add	r3, r1
  211122:	3334      	adds	r3, #52	; 0x34
  211124:	881b      	ldrh	r3, [r3, #0]
  211126:	18c1      	adds	r1, r0, r3
  211128:	4882      	ldr	r0, [pc, #520]	; (211334 <LCD_StrMovVIndirect+0x504>)
  21112a:	68fa      	ldr	r2, [r7, #12]
  21112c:	4613      	mov	r3, r2
  21112e:	011b      	lsls	r3, r3, #4
  211130:	1a9b      	subs	r3, r3, r2
  211132:	009b      	lsls	r3, r3, #2
  211134:	4403      	add	r3, r0
  211136:	332e      	adds	r3, #46	; 0x2e
  211138:	881b      	ldrh	r3, [r3, #0]
  21113a:	1acb      	subs	r3, r1, r3
  21113c:	627b      	str	r3, [r7, #36]	; 0x24
		int height_old = M.windowHeight-height_empty;
  21113e:	497d      	ldr	r1, [pc, #500]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211140:	68fa      	ldr	r2, [r7, #12]
  211142:	4613      	mov	r3, r2
  211144:	011b      	lsls	r3, r3, #4
  211146:	1a9b      	subs	r3, r3, r2
  211148:	009b      	lsls	r3, r3, #2
  21114a:	440b      	add	r3, r1
  21114c:	3334      	adds	r3, #52	; 0x34
  21114e:	881b      	ldrh	r3, [r3, #0]
  211150:	461a      	mov	r2, r3
  211152:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  211154:	1ad3      	subs	r3, r2, r3
  211156:	623b      	str	r3, [r7, #32]

		if(height_old>0)
  211158:	6a3b      	ldr	r3, [r7, #32]
  21115a:	2b00      	cmp	r3, #0
  21115c:	f340 84c4 	ble.w	211ae8 <LCD_StrMovVIndirect+0xcb8>
		{
			LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth,height_old, M.posWin*M.xImgWidth, M.windowWidth,0);
  211160:	4974      	ldr	r1, [pc, #464]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211162:	68fa      	ldr	r2, [r7, #12]
  211164:	4613      	mov	r3, r2
  211166:	011b      	lsls	r3, r3, #4
  211168:	1a9b      	subs	r3, r3, r2
  21116a:	009b      	lsls	r3, r3, #2
  21116c:	440b      	add	r3, r1
  21116e:	3314      	adds	r3, #20
  211170:	781b      	ldrb	r3, [r3, #0]
  211172:	461e      	mov	r6, r3
  211174:	496f      	ldr	r1, [pc, #444]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211176:	68fa      	ldr	r2, [r7, #12]
  211178:	4613      	mov	r3, r2
  21117a:	011b      	lsls	r3, r3, #4
  21117c:	1a9b      	subs	r3, r3, r2
  21117e:	009b      	lsls	r3, r3, #2
  211180:	440b      	add	r3, r1
  211182:	3328      	adds	r3, #40	; 0x28
  211184:	681d      	ldr	r5, [r3, #0]
  211186:	496b      	ldr	r1, [pc, #428]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211188:	68fa      	ldr	r2, [r7, #12]
  21118a:	4613      	mov	r3, r2
  21118c:	011b      	lsls	r3, r3, #4
  21118e:	1a9b      	subs	r3, r3, r2
  211190:	009b      	lsls	r3, r3, #2
  211192:	440b      	add	r3, r1
  211194:	332c      	adds	r3, #44	; 0x2c
  211196:	881b      	ldrh	r3, [r3, #0]
  211198:	469e      	mov	lr, r3
  21119a:	6a39      	ldr	r1, [r7, #32]
  21119c:	4865      	ldr	r0, [pc, #404]	; (211334 <LCD_StrMovVIndirect+0x504>)
  21119e:	68fa      	ldr	r2, [r7, #12]
  2111a0:	4613      	mov	r3, r2
  2111a2:	011b      	lsls	r3, r3, #4
  2111a4:	1a9b      	subs	r3, r3, r2
  2111a6:	009b      	lsls	r3, r3, #2
  2111a8:	4403      	add	r3, r0
  2111aa:	3330      	adds	r3, #48	; 0x30
  2111ac:	881b      	ldrh	r3, [r3, #0]
  2111ae:	461c      	mov	r4, r3
  2111b0:	4860      	ldr	r0, [pc, #384]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2111b2:	68fa      	ldr	r2, [r7, #12]
  2111b4:	4613      	mov	r3, r2
  2111b6:	011b      	lsls	r3, r3, #4
  2111b8:	1a9b      	subs	r3, r3, r2
  2111ba:	009b      	lsls	r3, r3, #2
  2111bc:	4403      	add	r3, r0
  2111be:	332c      	adds	r3, #44	; 0x2c
  2111c0:	881b      	ldrh	r3, [r3, #0]
  2111c2:	fb03 f004 	mul.w	r0, r3, r4
  2111c6:	4c5b      	ldr	r4, [pc, #364]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2111c8:	68fa      	ldr	r2, [r7, #12]
  2111ca:	4613      	mov	r3, r2
  2111cc:	011b      	lsls	r3, r3, #4
  2111ce:	1a9b      	subs	r3, r3, r2
  2111d0:	009b      	lsls	r3, r3, #2
  2111d2:	4423      	add	r3, r4
  2111d4:	3332      	adds	r3, #50	; 0x32
  2111d6:	881b      	ldrh	r3, [r3, #0]
  2111d8:	2200      	movs	r2, #0
  2111da:	9203      	str	r2, [sp, #12]
  2111dc:	9302      	str	r3, [sp, #8]
  2111de:	9001      	str	r0, [sp, #4]
  2111e0:	9100      	str	r1, [sp, #0]
  2111e2:	4673      	mov	r3, lr
  2111e4:	4a54      	ldr	r2, [pc, #336]	; (211338 <LCD_StrMovVIndirect+0x508>)
  2111e6:	4629      	mov	r1, r5
  2111e8:	4630      	mov	r0, r6
  2111ea:	f7f6 fd7f 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
			switch(F.rotate)
  2111ee:	4951      	ldr	r1, [pc, #324]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2111f0:	68fa      	ldr	r2, [r7, #12]
  2111f2:	4613      	mov	r3, r2
  2111f4:	011b      	lsls	r3, r3, #4
  2111f6:	1a9b      	subs	r3, r3, r2
  2111f8:	009b      	lsls	r3, r3, #2
  2111fa:	440b      	add	r3, r1
  2111fc:	3314      	adds	r3, #20
  2111fe:	781b      	ldrb	r3, [r3, #0]
  211200:	2b00      	cmp	r3, #0
  211202:	d002      	beq.n	21120a <LCD_StrMovVIndirect+0x3da>
  211204:	2b01      	cmp	r3, #1
  211206:	d027      	beq.n	211258 <LCD_StrMovVIndirect+0x428>
  211208:	e04f      	b.n	2112aa <LCD_StrMovVIndirect+0x47a>
			{	case Rotate_0:
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowWidth, height_old, pLcd);
  21120a:	494a      	ldr	r1, [pc, #296]	; (211334 <LCD_StrMovVIndirect+0x504>)
  21120c:	68fa      	ldr	r2, [r7, #12]
  21120e:	4613      	mov	r3, r2
  211210:	011b      	lsls	r3, r3, #4
  211212:	1a9b      	subs	r3, r3, r2
  211214:	009b      	lsls	r3, r3, #2
  211216:	440b      	add	r3, r1
  211218:	3302      	adds	r3, #2
  21121a:	881b      	ldrh	r3, [r3, #0]
  21121c:	4618      	mov	r0, r3
  21121e:	4945      	ldr	r1, [pc, #276]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211220:	68fa      	ldr	r2, [r7, #12]
  211222:	4613      	mov	r3, r2
  211224:	011b      	lsls	r3, r3, #4
  211226:	1a9b      	subs	r3, r3, r2
  211228:	009b      	lsls	r3, r3, #2
  21122a:	440b      	add	r3, r1
  21122c:	3304      	adds	r3, #4
  21122e:	881b      	ldrh	r3, [r3, #0]
  211230:	461c      	mov	r4, r3
  211232:	4940      	ldr	r1, [pc, #256]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211234:	68fa      	ldr	r2, [r7, #12]
  211236:	4613      	mov	r3, r2
  211238:	011b      	lsls	r3, r3, #4
  21123a:	1a9b      	subs	r3, r3, r2
  21123c:	009b      	lsls	r3, r3, #2
  21123e:	440b      	add	r3, r1
  211240:	3332      	adds	r3, #50	; 0x32
  211242:	881b      	ldrh	r3, [r3, #0]
  211244:	4619      	mov	r1, r3
  211246:	6a3a      	ldr	r2, [r7, #32]
  211248:	4b3c      	ldr	r3, [pc, #240]	; (21133c <LCD_StrMovVIndirect+0x50c>)
  21124a:	9300      	str	r3, [sp, #0]
  21124c:	4613      	mov	r3, r2
  21124e:	460a      	mov	r2, r1
  211250:	4621      	mov	r1, r4
  211252:	f7f6 fc1f 	bl	207a94 <LCD_DisplayBuff>
					break;
  211256:	e050      	b.n	2112fa <LCD_StrMovVIndirect+0x4ca>
				case Rotate_90:
					LCD_DisplayBuff((uint32_t)F.xPos+height_empty,(uint32_t)F.yPos, height_old, M.windowWidth, pLcd);
  211258:	4936      	ldr	r1, [pc, #216]	; (211334 <LCD_StrMovVIndirect+0x504>)
  21125a:	68fa      	ldr	r2, [r7, #12]
  21125c:	4613      	mov	r3, r2
  21125e:	011b      	lsls	r3, r3, #4
  211260:	1a9b      	subs	r3, r3, r2
  211262:	009b      	lsls	r3, r3, #2
  211264:	440b      	add	r3, r1
  211266:	3302      	adds	r3, #2
  211268:	881b      	ldrh	r3, [r3, #0]
  21126a:	461a      	mov	r2, r3
  21126c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  21126e:	18d0      	adds	r0, r2, r3
  211270:	4930      	ldr	r1, [pc, #192]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211272:	68fa      	ldr	r2, [r7, #12]
  211274:	4613      	mov	r3, r2
  211276:	011b      	lsls	r3, r3, #4
  211278:	1a9b      	subs	r3, r3, r2
  21127a:	009b      	lsls	r3, r3, #2
  21127c:	440b      	add	r3, r1
  21127e:	3304      	adds	r3, #4
  211280:	881b      	ldrh	r3, [r3, #0]
  211282:	461d      	mov	r5, r3
  211284:	6a3c      	ldr	r4, [r7, #32]
  211286:	492b      	ldr	r1, [pc, #172]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211288:	68fa      	ldr	r2, [r7, #12]
  21128a:	4613      	mov	r3, r2
  21128c:	011b      	lsls	r3, r3, #4
  21128e:	1a9b      	subs	r3, r3, r2
  211290:	009b      	lsls	r3, r3, #2
  211292:	440b      	add	r3, r1
  211294:	3332      	adds	r3, #50	; 0x32
  211296:	881b      	ldrh	r3, [r3, #0]
  211298:	461a      	mov	r2, r3
  21129a:	4b28      	ldr	r3, [pc, #160]	; (21133c <LCD_StrMovVIndirect+0x50c>)
  21129c:	9300      	str	r3, [sp, #0]
  21129e:	4613      	mov	r3, r2
  2112a0:	4622      	mov	r2, r4
  2112a2:	4629      	mov	r1, r5
  2112a4:	f7f6 fbf6 	bl	207a94 <LCD_DisplayBuff>
					break;
  2112a8:	e027      	b.n	2112fa <LCD_StrMovVIndirect+0x4ca>
				case Rotate_180:
				default:
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, height_old, M.windowWidth, pLcd);
  2112aa:	4922      	ldr	r1, [pc, #136]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2112ac:	68fa      	ldr	r2, [r7, #12]
  2112ae:	4613      	mov	r3, r2
  2112b0:	011b      	lsls	r3, r3, #4
  2112b2:	1a9b      	subs	r3, r3, r2
  2112b4:	009b      	lsls	r3, r3, #2
  2112b6:	440b      	add	r3, r1
  2112b8:	3302      	adds	r3, #2
  2112ba:	881b      	ldrh	r3, [r3, #0]
  2112bc:	461c      	mov	r4, r3
  2112be:	491d      	ldr	r1, [pc, #116]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2112c0:	68fa      	ldr	r2, [r7, #12]
  2112c2:	4613      	mov	r3, r2
  2112c4:	011b      	lsls	r3, r3, #4
  2112c6:	1a9b      	subs	r3, r3, r2
  2112c8:	009b      	lsls	r3, r3, #2
  2112ca:	440b      	add	r3, r1
  2112cc:	3304      	adds	r3, #4
  2112ce:	881b      	ldrh	r3, [r3, #0]
  2112d0:	461d      	mov	r5, r3
  2112d2:	6a38      	ldr	r0, [r7, #32]
  2112d4:	4917      	ldr	r1, [pc, #92]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2112d6:	68fa      	ldr	r2, [r7, #12]
  2112d8:	4613      	mov	r3, r2
  2112da:	011b      	lsls	r3, r3, #4
  2112dc:	1a9b      	subs	r3, r3, r2
  2112de:	009b      	lsls	r3, r3, #2
  2112e0:	440b      	add	r3, r1
  2112e2:	3332      	adds	r3, #50	; 0x32
  2112e4:	881b      	ldrh	r3, [r3, #0]
  2112e6:	461a      	mov	r2, r3
  2112e8:	4b14      	ldr	r3, [pc, #80]	; (21133c <LCD_StrMovVIndirect+0x50c>)
  2112ea:	9300      	str	r3, [sp, #0]
  2112ec:	4613      	mov	r3, r2
  2112ee:	4602      	mov	r2, r0
  2112f0:	4629      	mov	r1, r5
  2112f2:	4620      	mov	r0, r4
  2112f4:	f7f6 fbce 	bl	207a94 <LCD_DisplayBuff>
					break;
  2112f8:	bf00      	nop
			}

			if(height_empty <= M.spaceEndStart)
  2112fa:	490e      	ldr	r1, [pc, #56]	; (211334 <LCD_StrMovVIndirect+0x504>)
  2112fc:	68fa      	ldr	r2, [r7, #12]
  2112fe:	4613      	mov	r3, r2
  211300:	011b      	lsls	r3, r3, #4
  211302:	1a9b      	subs	r3, r3, r2
  211304:	009b      	lsls	r3, r3, #2
  211306:	440b      	add	r3, r1
  211308:	3338      	adds	r3, #56	; 0x38
  21130a:	881b      	ldrh	r3, [r3, #0]
  21130c:	461a      	mov	r2, r3
  21130e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  211310:	429a      	cmp	r2, r3
  211312:	f2c0 8157 	blt.w	2115c4 <LCD_StrMovVIndirect+0x794>
			{
				switch(F.rotate)
  211316:	4907      	ldr	r1, [pc, #28]	; (211334 <LCD_StrMovVIndirect+0x504>)
  211318:	68fa      	ldr	r2, [r7, #12]
  21131a:	4613      	mov	r3, r2
  21131c:	011b      	lsls	r3, r3, #4
  21131e:	1a9b      	subs	r3, r3, r2
  211320:	009b      	lsls	r3, r3, #2
  211322:	440b      	add	r3, r1
  211324:	3314      	adds	r3, #20
  211326:	781b      	ldrb	r3, [r3, #0]
  211328:	2b00      	cmp	r3, #0
  21132a:	d009      	beq.n	211340 <LCD_StrMovVIndirect+0x510>
  21132c:	2b01      	cmp	r3, #1
  21132e:	d073      	beq.n	211418 <LCD_StrMovVIndirect+0x5e8>
  211330:	e0dc      	b.n	2114ec <LCD_StrMovVIndirect+0x6bc>
  211332:	bf00      	nop
  211334:	2000f818 	.word	0x2000f818
  211338:	c067f800 	.word	0xc067f800
  21133c:	c0000000 	.word	0xc0000000
				{	case Rotate_0:
					LCD_RectangleBuff(pLcd,0, M.windowWidth,height_empty ,0,0, M.windowWidth,height_empty, F.bkColor,F.bkColor,F.bkColor);
  211340:	49b0      	ldr	r1, [pc, #704]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211342:	68fa      	ldr	r2, [r7, #12]
  211344:	4613      	mov	r3, r2
  211346:	011b      	lsls	r3, r3, #4
  211348:	1a9b      	subs	r3, r3, r2
  21134a:	009b      	lsls	r3, r3, #2
  21134c:	440b      	add	r3, r1
  21134e:	3332      	adds	r3, #50	; 0x32
  211350:	881b      	ldrh	r3, [r3, #0]
  211352:	469e      	mov	lr, r3
  211354:	6a7e      	ldr	r6, [r7, #36]	; 0x24
  211356:	49ab      	ldr	r1, [pc, #684]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211358:	68fa      	ldr	r2, [r7, #12]
  21135a:	4613      	mov	r3, r2
  21135c:	011b      	lsls	r3, r3, #4
  21135e:	1a9b      	subs	r3, r3, r2
  211360:	009b      	lsls	r3, r3, #2
  211362:	440b      	add	r3, r1
  211364:	3332      	adds	r3, #50	; 0x32
  211366:	881b      	ldrh	r3, [r3, #0]
  211368:	607b      	str	r3, [r7, #4]
  21136a:	6a79      	ldr	r1, [r7, #36]	; 0x24
  21136c:	48a5      	ldr	r0, [pc, #660]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21136e:	68fa      	ldr	r2, [r7, #12]
  211370:	4613      	mov	r3, r2
  211372:	011b      	lsls	r3, r3, #4
  211374:	1a9b      	subs	r3, r3, r2
  211376:	009b      	lsls	r3, r3, #2
  211378:	4403      	add	r3, r0
  21137a:	3308      	adds	r3, #8
  21137c:	6818      	ldr	r0, [r3, #0]
  21137e:	4ca1      	ldr	r4, [pc, #644]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211380:	68fa      	ldr	r2, [r7, #12]
  211382:	4613      	mov	r3, r2
  211384:	011b      	lsls	r3, r3, #4
  211386:	1a9b      	subs	r3, r3, r2
  211388:	009b      	lsls	r3, r3, #2
  21138a:	4423      	add	r3, r4
  21138c:	3308      	adds	r3, #8
  21138e:	681c      	ldr	r4, [r3, #0]
  211390:	4d9c      	ldr	r5, [pc, #624]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211392:	68fa      	ldr	r2, [r7, #12]
  211394:	4613      	mov	r3, r2
  211396:	011b      	lsls	r3, r3, #4
  211398:	1a9b      	subs	r3, r3, r2
  21139a:	009b      	lsls	r3, r3, #2
  21139c:	442b      	add	r3, r5
  21139e:	3308      	adds	r3, #8
  2113a0:	681b      	ldr	r3, [r3, #0]
  2113a2:	9306      	str	r3, [sp, #24]
  2113a4:	9405      	str	r4, [sp, #20]
  2113a6:	9004      	str	r0, [sp, #16]
  2113a8:	9103      	str	r1, [sp, #12]
  2113aa:	687b      	ldr	r3, [r7, #4]
  2113ac:	9302      	str	r3, [sp, #8]
  2113ae:	2300      	movs	r3, #0
  2113b0:	9301      	str	r3, [sp, #4]
  2113b2:	2300      	movs	r3, #0
  2113b4:	9300      	str	r3, [sp, #0]
  2113b6:	4633      	mov	r3, r6
  2113b8:	4672      	mov	r2, lr
  2113ba:	2100      	movs	r1, #0
  2113bc:	4892      	ldr	r0, [pc, #584]	; (211608 <LCD_StrMovVIndirect+0x7d8>)
  2113be:	f7f6 fdfd 	bl	207fbc <LCD_RectangleBuff>
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos+height_old, M.windowWidth,height_empty, pLcd);
  2113c2:	4990      	ldr	r1, [pc, #576]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2113c4:	68fa      	ldr	r2, [r7, #12]
  2113c6:	4613      	mov	r3, r2
  2113c8:	011b      	lsls	r3, r3, #4
  2113ca:	1a9b      	subs	r3, r3, r2
  2113cc:	009b      	lsls	r3, r3, #2
  2113ce:	440b      	add	r3, r1
  2113d0:	3302      	adds	r3, #2
  2113d2:	881b      	ldrh	r3, [r3, #0]
  2113d4:	461c      	mov	r4, r3
  2113d6:	498b      	ldr	r1, [pc, #556]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2113d8:	68fa      	ldr	r2, [r7, #12]
  2113da:	4613      	mov	r3, r2
  2113dc:	011b      	lsls	r3, r3, #4
  2113de:	1a9b      	subs	r3, r3, r2
  2113e0:	009b      	lsls	r3, r3, #2
  2113e2:	440b      	add	r3, r1
  2113e4:	3304      	adds	r3, #4
  2113e6:	881b      	ldrh	r3, [r3, #0]
  2113e8:	461a      	mov	r2, r3
  2113ea:	6a3b      	ldr	r3, [r7, #32]
  2113ec:	18d0      	adds	r0, r2, r3
  2113ee:	4985      	ldr	r1, [pc, #532]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2113f0:	68fa      	ldr	r2, [r7, #12]
  2113f2:	4613      	mov	r3, r2
  2113f4:	011b      	lsls	r3, r3, #4
  2113f6:	1a9b      	subs	r3, r3, r2
  2113f8:	009b      	lsls	r3, r3, #2
  2113fa:	440b      	add	r3, r1
  2113fc:	3332      	adds	r3, #50	; 0x32
  2113fe:	881b      	ldrh	r3, [r3, #0]
  211400:	4619      	mov	r1, r3
  211402:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  211404:	4b80      	ldr	r3, [pc, #512]	; (211608 <LCD_StrMovVIndirect+0x7d8>)
  211406:	9300      	str	r3, [sp, #0]
  211408:	4613      	mov	r3, r2
  21140a:	460a      	mov	r2, r1
  21140c:	4601      	mov	r1, r0
  21140e:	4620      	mov	r0, r4
  211410:	f7f6 fb40 	bl	207a94 <LCD_DisplayBuff>
						break;
  211414:	f000 be4f 	b.w	2120b6 <LCD_StrMovVIndirect+0x1286>
					case Rotate_90:
						LCD_RectangleBuff(pLcd,0, height_empty,M.windowWidth ,0,0, height_empty,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
  211418:	6a7e      	ldr	r6, [r7, #36]	; 0x24
  21141a:	497a      	ldr	r1, [pc, #488]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21141c:	68fa      	ldr	r2, [r7, #12]
  21141e:	4613      	mov	r3, r2
  211420:	011b      	lsls	r3, r3, #4
  211422:	1a9b      	subs	r3, r3, r2
  211424:	009b      	lsls	r3, r3, #2
  211426:	440b      	add	r3, r1
  211428:	3332      	adds	r3, #50	; 0x32
  21142a:	881b      	ldrh	r3, [r3, #0]
  21142c:	469e      	mov	lr, r3
  21142e:	6a79      	ldr	r1, [r7, #36]	; 0x24
  211430:	4874      	ldr	r0, [pc, #464]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211432:	68fa      	ldr	r2, [r7, #12]
  211434:	4613      	mov	r3, r2
  211436:	011b      	lsls	r3, r3, #4
  211438:	1a9b      	subs	r3, r3, r2
  21143a:	009b      	lsls	r3, r3, #2
  21143c:	4403      	add	r3, r0
  21143e:	3332      	adds	r3, #50	; 0x32
  211440:	881b      	ldrh	r3, [r3, #0]
  211442:	607b      	str	r3, [r7, #4]
  211444:	486f      	ldr	r0, [pc, #444]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211446:	68fa      	ldr	r2, [r7, #12]
  211448:	4613      	mov	r3, r2
  21144a:	011b      	lsls	r3, r3, #4
  21144c:	1a9b      	subs	r3, r3, r2
  21144e:	009b      	lsls	r3, r3, #2
  211450:	4403      	add	r3, r0
  211452:	3308      	adds	r3, #8
  211454:	6818      	ldr	r0, [r3, #0]
  211456:	4c6b      	ldr	r4, [pc, #428]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211458:	68fa      	ldr	r2, [r7, #12]
  21145a:	4613      	mov	r3, r2
  21145c:	011b      	lsls	r3, r3, #4
  21145e:	1a9b      	subs	r3, r3, r2
  211460:	009b      	lsls	r3, r3, #2
  211462:	4423      	add	r3, r4
  211464:	3308      	adds	r3, #8
  211466:	681c      	ldr	r4, [r3, #0]
  211468:	4d66      	ldr	r5, [pc, #408]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21146a:	68fa      	ldr	r2, [r7, #12]
  21146c:	4613      	mov	r3, r2
  21146e:	011b      	lsls	r3, r3, #4
  211470:	1a9b      	subs	r3, r3, r2
  211472:	009b      	lsls	r3, r3, #2
  211474:	442b      	add	r3, r5
  211476:	3308      	adds	r3, #8
  211478:	681b      	ldr	r3, [r3, #0]
  21147a:	9306      	str	r3, [sp, #24]
  21147c:	9405      	str	r4, [sp, #20]
  21147e:	9004      	str	r0, [sp, #16]
  211480:	687b      	ldr	r3, [r7, #4]
  211482:	9303      	str	r3, [sp, #12]
  211484:	9102      	str	r1, [sp, #8]
  211486:	2300      	movs	r3, #0
  211488:	9301      	str	r3, [sp, #4]
  21148a:	2300      	movs	r3, #0
  21148c:	9300      	str	r3, [sp, #0]
  21148e:	4673      	mov	r3, lr
  211490:	4632      	mov	r2, r6
  211492:	2100      	movs	r1, #0
  211494:	485c      	ldr	r0, [pc, #368]	; (211608 <LCD_StrMovVIndirect+0x7d8>)
  211496:	f7f6 fd91 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, height_empty,M.windowWidth, pLcd);
  21149a:	495a      	ldr	r1, [pc, #360]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21149c:	68fa      	ldr	r2, [r7, #12]
  21149e:	4613      	mov	r3, r2
  2114a0:	011b      	lsls	r3, r3, #4
  2114a2:	1a9b      	subs	r3, r3, r2
  2114a4:	009b      	lsls	r3, r3, #2
  2114a6:	440b      	add	r3, r1
  2114a8:	3302      	adds	r3, #2
  2114aa:	881b      	ldrh	r3, [r3, #0]
  2114ac:	461c      	mov	r4, r3
  2114ae:	4955      	ldr	r1, [pc, #340]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2114b0:	68fa      	ldr	r2, [r7, #12]
  2114b2:	4613      	mov	r3, r2
  2114b4:	011b      	lsls	r3, r3, #4
  2114b6:	1a9b      	subs	r3, r3, r2
  2114b8:	009b      	lsls	r3, r3, #2
  2114ba:	440b      	add	r3, r1
  2114bc:	3304      	adds	r3, #4
  2114be:	881b      	ldrh	r3, [r3, #0]
  2114c0:	461d      	mov	r5, r3
  2114c2:	6a78      	ldr	r0, [r7, #36]	; 0x24
  2114c4:	494f      	ldr	r1, [pc, #316]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2114c6:	68fa      	ldr	r2, [r7, #12]
  2114c8:	4613      	mov	r3, r2
  2114ca:	011b      	lsls	r3, r3, #4
  2114cc:	1a9b      	subs	r3, r3, r2
  2114ce:	009b      	lsls	r3, r3, #2
  2114d0:	440b      	add	r3, r1
  2114d2:	3332      	adds	r3, #50	; 0x32
  2114d4:	881b      	ldrh	r3, [r3, #0]
  2114d6:	461a      	mov	r2, r3
  2114d8:	4b4b      	ldr	r3, [pc, #300]	; (211608 <LCD_StrMovVIndirect+0x7d8>)
  2114da:	9300      	str	r3, [sp, #0]
  2114dc:	4613      	mov	r3, r2
  2114de:	4602      	mov	r2, r0
  2114e0:	4629      	mov	r1, r5
  2114e2:	4620      	mov	r0, r4
  2114e4:	f7f6 fad6 	bl	207a94 <LCD_DisplayBuff>
						break;
  2114e8:	f000 bde5 	b.w	2120b6 <LCD_StrMovVIndirect+0x1286>
					case Rotate_180:
					default:
						LCD_RectangleBuff(pLcd,0, height_empty,M.windowWidth ,0,0, height_empty,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
  2114ec:	6a7e      	ldr	r6, [r7, #36]	; 0x24
  2114ee:	4945      	ldr	r1, [pc, #276]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2114f0:	68fa      	ldr	r2, [r7, #12]
  2114f2:	4613      	mov	r3, r2
  2114f4:	011b      	lsls	r3, r3, #4
  2114f6:	1a9b      	subs	r3, r3, r2
  2114f8:	009b      	lsls	r3, r3, #2
  2114fa:	440b      	add	r3, r1
  2114fc:	3332      	adds	r3, #50	; 0x32
  2114fe:	881b      	ldrh	r3, [r3, #0]
  211500:	469e      	mov	lr, r3
  211502:	6a79      	ldr	r1, [r7, #36]	; 0x24
  211504:	483f      	ldr	r0, [pc, #252]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211506:	68fa      	ldr	r2, [r7, #12]
  211508:	4613      	mov	r3, r2
  21150a:	011b      	lsls	r3, r3, #4
  21150c:	1a9b      	subs	r3, r3, r2
  21150e:	009b      	lsls	r3, r3, #2
  211510:	4403      	add	r3, r0
  211512:	3332      	adds	r3, #50	; 0x32
  211514:	881b      	ldrh	r3, [r3, #0]
  211516:	607b      	str	r3, [r7, #4]
  211518:	483a      	ldr	r0, [pc, #232]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21151a:	68fa      	ldr	r2, [r7, #12]
  21151c:	4613      	mov	r3, r2
  21151e:	011b      	lsls	r3, r3, #4
  211520:	1a9b      	subs	r3, r3, r2
  211522:	009b      	lsls	r3, r3, #2
  211524:	4403      	add	r3, r0
  211526:	3308      	adds	r3, #8
  211528:	6818      	ldr	r0, [r3, #0]
  21152a:	4c36      	ldr	r4, [pc, #216]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21152c:	68fa      	ldr	r2, [r7, #12]
  21152e:	4613      	mov	r3, r2
  211530:	011b      	lsls	r3, r3, #4
  211532:	1a9b      	subs	r3, r3, r2
  211534:	009b      	lsls	r3, r3, #2
  211536:	4423      	add	r3, r4
  211538:	3308      	adds	r3, #8
  21153a:	681c      	ldr	r4, [r3, #0]
  21153c:	4d31      	ldr	r5, [pc, #196]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21153e:	68fa      	ldr	r2, [r7, #12]
  211540:	4613      	mov	r3, r2
  211542:	011b      	lsls	r3, r3, #4
  211544:	1a9b      	subs	r3, r3, r2
  211546:	009b      	lsls	r3, r3, #2
  211548:	442b      	add	r3, r5
  21154a:	3308      	adds	r3, #8
  21154c:	681b      	ldr	r3, [r3, #0]
  21154e:	9306      	str	r3, [sp, #24]
  211550:	9405      	str	r4, [sp, #20]
  211552:	9004      	str	r0, [sp, #16]
  211554:	687b      	ldr	r3, [r7, #4]
  211556:	9303      	str	r3, [sp, #12]
  211558:	9102      	str	r1, [sp, #8]
  21155a:	2300      	movs	r3, #0
  21155c:	9301      	str	r3, [sp, #4]
  21155e:	2300      	movs	r3, #0
  211560:	9300      	str	r3, [sp, #0]
  211562:	4673      	mov	r3, lr
  211564:	4632      	mov	r2, r6
  211566:	2100      	movs	r1, #0
  211568:	4827      	ldr	r0, [pc, #156]	; (211608 <LCD_StrMovVIndirect+0x7d8>)
  21156a:	f7f6 fd27 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos+height_old,(uint32_t)F.yPos, height_empty,M.windowWidth, pLcd);
  21156e:	4925      	ldr	r1, [pc, #148]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211570:	68fa      	ldr	r2, [r7, #12]
  211572:	4613      	mov	r3, r2
  211574:	011b      	lsls	r3, r3, #4
  211576:	1a9b      	subs	r3, r3, r2
  211578:	009b      	lsls	r3, r3, #2
  21157a:	440b      	add	r3, r1
  21157c:	3302      	adds	r3, #2
  21157e:	881b      	ldrh	r3, [r3, #0]
  211580:	461a      	mov	r2, r3
  211582:	6a3b      	ldr	r3, [r7, #32]
  211584:	18d0      	adds	r0, r2, r3
  211586:	491f      	ldr	r1, [pc, #124]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  211588:	68fa      	ldr	r2, [r7, #12]
  21158a:	4613      	mov	r3, r2
  21158c:	011b      	lsls	r3, r3, #4
  21158e:	1a9b      	subs	r3, r3, r2
  211590:	009b      	lsls	r3, r3, #2
  211592:	440b      	add	r3, r1
  211594:	3304      	adds	r3, #4
  211596:	881b      	ldrh	r3, [r3, #0]
  211598:	461d      	mov	r5, r3
  21159a:	6a7c      	ldr	r4, [r7, #36]	; 0x24
  21159c:	4919      	ldr	r1, [pc, #100]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  21159e:	68fa      	ldr	r2, [r7, #12]
  2115a0:	4613      	mov	r3, r2
  2115a2:	011b      	lsls	r3, r3, #4
  2115a4:	1a9b      	subs	r3, r3, r2
  2115a6:	009b      	lsls	r3, r3, #2
  2115a8:	440b      	add	r3, r1
  2115aa:	3332      	adds	r3, #50	; 0x32
  2115ac:	881b      	ldrh	r3, [r3, #0]
  2115ae:	461a      	mov	r2, r3
  2115b0:	4b15      	ldr	r3, [pc, #84]	; (211608 <LCD_StrMovVIndirect+0x7d8>)
  2115b2:	9300      	str	r3, [sp, #0]
  2115b4:	4613      	mov	r3, r2
  2115b6:	4622      	mov	r2, r4
  2115b8:	4629      	mov	r1, r5
  2115ba:	f7f6 fa6b 	bl	207a94 <LCD_DisplayBuff>
						break;
  2115be:	bf00      	nop
  2115c0:	f000 bd79 	b.w	2120b6 <LCD_StrMovVIndirect+0x1286>
				}
			}
			else
			{	int height_new = height_empty - M.spaceEndStart;
  2115c4:	490f      	ldr	r1, [pc, #60]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2115c6:	68fa      	ldr	r2, [r7, #12]
  2115c8:	4613      	mov	r3, r2
  2115ca:	011b      	lsls	r3, r3, #4
  2115cc:	1a9b      	subs	r3, r3, r2
  2115ce:	009b      	lsls	r3, r3, #2
  2115d0:	440b      	add	r3, r1
  2115d2:	3338      	adds	r3, #56	; 0x38
  2115d4:	881b      	ldrh	r3, [r3, #0]
  2115d6:	461a      	mov	r2, r3
  2115d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2115da:	1a9b      	subs	r3, r3, r2
  2115dc:	617b      	str	r3, [r7, #20]
				switch(F.rotate)
  2115de:	4909      	ldr	r1, [pc, #36]	; (211604 <LCD_StrMovVIndirect+0x7d4>)
  2115e0:	68fa      	ldr	r2, [r7, #12]
  2115e2:	4613      	mov	r3, r2
  2115e4:	011b      	lsls	r3, r3, #4
  2115e6:	1a9b      	subs	r3, r3, r2
  2115e8:	009b      	lsls	r3, r3, #2
  2115ea:	440b      	add	r3, r1
  2115ec:	3314      	adds	r3, #20
  2115ee:	781b      	ldrb	r3, [r3, #0]
  2115f0:	2b01      	cmp	r3, #1
  2115f2:	f000 8090 	beq.w	211716 <LCD_StrMovVIndirect+0x8e6>
  2115f6:	2b02      	cmp	r3, #2
  2115f8:	f000 8116 	beq.w	211828 <LCD_StrMovVIndirect+0x9f8>
  2115fc:	2b00      	cmp	r3, #0
  2115fe:	d005      	beq.n	21160c <LCD_StrMovVIndirect+0x7dc>
						break;
					case Rotate_180:
						LCD_RectangleBuff(pLcd,0, M.spaceEndStart,M.windowWidth, 0,0, M.spaceEndStart,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
						LCD_DisplayBuff((uint32_t)F.xPos+height_old,(uint32_t)F.yPos, M.spaceEndStart,M.windowWidth, pLcd);
					default:
						break;
  211600:	e195      	b.n	21192e <LCD_StrMovVIndirect+0xafe>
  211602:	bf00      	nop
  211604:	2000f818 	.word	0x2000f818
  211608:	c0000000 	.word	0xc0000000
						LCD_RectangleBuff(pLcd,0, M.windowWidth,M.spaceEndStart, 0,0, M.windowWidth,M.spaceEndStart, F.bkColor,F.bkColor,F.bkColor);
  21160c:	4984      	ldr	r1, [pc, #528]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  21160e:	68fa      	ldr	r2, [r7, #12]
  211610:	4613      	mov	r3, r2
  211612:	011b      	lsls	r3, r3, #4
  211614:	1a9b      	subs	r3, r3, r2
  211616:	009b      	lsls	r3, r3, #2
  211618:	440b      	add	r3, r1
  21161a:	3332      	adds	r3, #50	; 0x32
  21161c:	881b      	ldrh	r3, [r3, #0]
  21161e:	469e      	mov	lr, r3
  211620:	497f      	ldr	r1, [pc, #508]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211622:	68fa      	ldr	r2, [r7, #12]
  211624:	4613      	mov	r3, r2
  211626:	011b      	lsls	r3, r3, #4
  211628:	1a9b      	subs	r3, r3, r2
  21162a:	009b      	lsls	r3, r3, #2
  21162c:	440b      	add	r3, r1
  21162e:	3338      	adds	r3, #56	; 0x38
  211630:	881b      	ldrh	r3, [r3, #0]
  211632:	469c      	mov	ip, r3
  211634:	497a      	ldr	r1, [pc, #488]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211636:	68fa      	ldr	r2, [r7, #12]
  211638:	4613      	mov	r3, r2
  21163a:	011b      	lsls	r3, r3, #4
  21163c:	1a9b      	subs	r3, r3, r2
  21163e:	009b      	lsls	r3, r3, #2
  211640:	440b      	add	r3, r1
  211642:	3332      	adds	r3, #50	; 0x32
  211644:	881b      	ldrh	r3, [r3, #0]
  211646:	461d      	mov	r5, r3
  211648:	4975      	ldr	r1, [pc, #468]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  21164a:	68fa      	ldr	r2, [r7, #12]
  21164c:	4613      	mov	r3, r2
  21164e:	011b      	lsls	r3, r3, #4
  211650:	1a9b      	subs	r3, r3, r2
  211652:	009b      	lsls	r3, r3, #2
  211654:	440b      	add	r3, r1
  211656:	3338      	adds	r3, #56	; 0x38
  211658:	881b      	ldrh	r3, [r3, #0]
  21165a:	461e      	mov	r6, r3
  21165c:	4970      	ldr	r1, [pc, #448]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  21165e:	68fa      	ldr	r2, [r7, #12]
  211660:	4613      	mov	r3, r2
  211662:	011b      	lsls	r3, r3, #4
  211664:	1a9b      	subs	r3, r3, r2
  211666:	009b      	lsls	r3, r3, #2
  211668:	440b      	add	r3, r1
  21166a:	3308      	adds	r3, #8
  21166c:	6819      	ldr	r1, [r3, #0]
  21166e:	486c      	ldr	r0, [pc, #432]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211670:	68fa      	ldr	r2, [r7, #12]
  211672:	4613      	mov	r3, r2
  211674:	011b      	lsls	r3, r3, #4
  211676:	1a9b      	subs	r3, r3, r2
  211678:	009b      	lsls	r3, r3, #2
  21167a:	4403      	add	r3, r0
  21167c:	3308      	adds	r3, #8
  21167e:	6818      	ldr	r0, [r3, #0]
  211680:	4c67      	ldr	r4, [pc, #412]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211682:	68fa      	ldr	r2, [r7, #12]
  211684:	4613      	mov	r3, r2
  211686:	011b      	lsls	r3, r3, #4
  211688:	1a9b      	subs	r3, r3, r2
  21168a:	009b      	lsls	r3, r3, #2
  21168c:	4423      	add	r3, r4
  21168e:	3308      	adds	r3, #8
  211690:	681b      	ldr	r3, [r3, #0]
  211692:	9306      	str	r3, [sp, #24]
  211694:	9005      	str	r0, [sp, #20]
  211696:	9104      	str	r1, [sp, #16]
  211698:	9603      	str	r6, [sp, #12]
  21169a:	9502      	str	r5, [sp, #8]
  21169c:	2300      	movs	r3, #0
  21169e:	9301      	str	r3, [sp, #4]
  2116a0:	2300      	movs	r3, #0
  2116a2:	9300      	str	r3, [sp, #0]
  2116a4:	4663      	mov	r3, ip
  2116a6:	4672      	mov	r2, lr
  2116a8:	2100      	movs	r1, #0
  2116aa:	485e      	ldr	r0, [pc, #376]	; (211824 <LCD_StrMovVIndirect+0x9f4>)
  2116ac:	f7f6 fc86 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)(F.yPos+height_old), M.windowWidth,M.spaceEndStart, pLcd);
  2116b0:	495b      	ldr	r1, [pc, #364]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2116b2:	68fa      	ldr	r2, [r7, #12]
  2116b4:	4613      	mov	r3, r2
  2116b6:	011b      	lsls	r3, r3, #4
  2116b8:	1a9b      	subs	r3, r3, r2
  2116ba:	009b      	lsls	r3, r3, #2
  2116bc:	440b      	add	r3, r1
  2116be:	3302      	adds	r3, #2
  2116c0:	881b      	ldrh	r3, [r3, #0]
  2116c2:	4618      	mov	r0, r3
  2116c4:	4956      	ldr	r1, [pc, #344]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2116c6:	68fa      	ldr	r2, [r7, #12]
  2116c8:	4613      	mov	r3, r2
  2116ca:	011b      	lsls	r3, r3, #4
  2116cc:	1a9b      	subs	r3, r3, r2
  2116ce:	009b      	lsls	r3, r3, #2
  2116d0:	440b      	add	r3, r1
  2116d2:	3304      	adds	r3, #4
  2116d4:	881b      	ldrh	r3, [r3, #0]
  2116d6:	461a      	mov	r2, r3
  2116d8:	6a3b      	ldr	r3, [r7, #32]
  2116da:	4413      	add	r3, r2
  2116dc:	461c      	mov	r4, r3
  2116de:	4950      	ldr	r1, [pc, #320]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2116e0:	68fa      	ldr	r2, [r7, #12]
  2116e2:	4613      	mov	r3, r2
  2116e4:	011b      	lsls	r3, r3, #4
  2116e6:	1a9b      	subs	r3, r3, r2
  2116e8:	009b      	lsls	r3, r3, #2
  2116ea:	440b      	add	r3, r1
  2116ec:	3332      	adds	r3, #50	; 0x32
  2116ee:	881b      	ldrh	r3, [r3, #0]
  2116f0:	461d      	mov	r5, r3
  2116f2:	494b      	ldr	r1, [pc, #300]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2116f4:	68fa      	ldr	r2, [r7, #12]
  2116f6:	4613      	mov	r3, r2
  2116f8:	011b      	lsls	r3, r3, #4
  2116fa:	1a9b      	subs	r3, r3, r2
  2116fc:	009b      	lsls	r3, r3, #2
  2116fe:	440b      	add	r3, r1
  211700:	3338      	adds	r3, #56	; 0x38
  211702:	881b      	ldrh	r3, [r3, #0]
  211704:	461a      	mov	r2, r3
  211706:	4b47      	ldr	r3, [pc, #284]	; (211824 <LCD_StrMovVIndirect+0x9f4>)
  211708:	9300      	str	r3, [sp, #0]
  21170a:	4613      	mov	r3, r2
  21170c:	462a      	mov	r2, r5
  21170e:	4621      	mov	r1, r4
  211710:	f7f6 f9c0 	bl	207a94 <LCD_DisplayBuff>
						break;
  211714:	e10c      	b.n	211930 <LCD_StrMovVIndirect+0xb00>
						LCD_RectangleBuff(pLcd,0, M.spaceEndStart,M.windowWidth, 0,0, M.spaceEndStart,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
  211716:	4942      	ldr	r1, [pc, #264]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211718:	68fa      	ldr	r2, [r7, #12]
  21171a:	4613      	mov	r3, r2
  21171c:	011b      	lsls	r3, r3, #4
  21171e:	1a9b      	subs	r3, r3, r2
  211720:	009b      	lsls	r3, r3, #2
  211722:	440b      	add	r3, r1
  211724:	3338      	adds	r3, #56	; 0x38
  211726:	881b      	ldrh	r3, [r3, #0]
  211728:	469e      	mov	lr, r3
  21172a:	493d      	ldr	r1, [pc, #244]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  21172c:	68fa      	ldr	r2, [r7, #12]
  21172e:	4613      	mov	r3, r2
  211730:	011b      	lsls	r3, r3, #4
  211732:	1a9b      	subs	r3, r3, r2
  211734:	009b      	lsls	r3, r3, #2
  211736:	440b      	add	r3, r1
  211738:	3332      	adds	r3, #50	; 0x32
  21173a:	881b      	ldrh	r3, [r3, #0]
  21173c:	469c      	mov	ip, r3
  21173e:	4938      	ldr	r1, [pc, #224]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211740:	68fa      	ldr	r2, [r7, #12]
  211742:	4613      	mov	r3, r2
  211744:	011b      	lsls	r3, r3, #4
  211746:	1a9b      	subs	r3, r3, r2
  211748:	009b      	lsls	r3, r3, #2
  21174a:	440b      	add	r3, r1
  21174c:	3338      	adds	r3, #56	; 0x38
  21174e:	881b      	ldrh	r3, [r3, #0]
  211750:	461d      	mov	r5, r3
  211752:	4933      	ldr	r1, [pc, #204]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211754:	68fa      	ldr	r2, [r7, #12]
  211756:	4613      	mov	r3, r2
  211758:	011b      	lsls	r3, r3, #4
  21175a:	1a9b      	subs	r3, r3, r2
  21175c:	009b      	lsls	r3, r3, #2
  21175e:	440b      	add	r3, r1
  211760:	3332      	adds	r3, #50	; 0x32
  211762:	881b      	ldrh	r3, [r3, #0]
  211764:	461e      	mov	r6, r3
  211766:	492e      	ldr	r1, [pc, #184]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  211768:	68fa      	ldr	r2, [r7, #12]
  21176a:	4613      	mov	r3, r2
  21176c:	011b      	lsls	r3, r3, #4
  21176e:	1a9b      	subs	r3, r3, r2
  211770:	009b      	lsls	r3, r3, #2
  211772:	440b      	add	r3, r1
  211774:	3308      	adds	r3, #8
  211776:	6819      	ldr	r1, [r3, #0]
  211778:	4829      	ldr	r0, [pc, #164]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  21177a:	68fa      	ldr	r2, [r7, #12]
  21177c:	4613      	mov	r3, r2
  21177e:	011b      	lsls	r3, r3, #4
  211780:	1a9b      	subs	r3, r3, r2
  211782:	009b      	lsls	r3, r3, #2
  211784:	4403      	add	r3, r0
  211786:	3308      	adds	r3, #8
  211788:	6818      	ldr	r0, [r3, #0]
  21178a:	4c25      	ldr	r4, [pc, #148]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  21178c:	68fa      	ldr	r2, [r7, #12]
  21178e:	4613      	mov	r3, r2
  211790:	011b      	lsls	r3, r3, #4
  211792:	1a9b      	subs	r3, r3, r2
  211794:	009b      	lsls	r3, r3, #2
  211796:	4423      	add	r3, r4
  211798:	3308      	adds	r3, #8
  21179a:	681b      	ldr	r3, [r3, #0]
  21179c:	9306      	str	r3, [sp, #24]
  21179e:	9005      	str	r0, [sp, #20]
  2117a0:	9104      	str	r1, [sp, #16]
  2117a2:	9603      	str	r6, [sp, #12]
  2117a4:	9502      	str	r5, [sp, #8]
  2117a6:	2300      	movs	r3, #0
  2117a8:	9301      	str	r3, [sp, #4]
  2117aa:	2300      	movs	r3, #0
  2117ac:	9300      	str	r3, [sp, #0]
  2117ae:	4663      	mov	r3, ip
  2117b0:	4672      	mov	r2, lr
  2117b2:	2100      	movs	r1, #0
  2117b4:	481b      	ldr	r0, [pc, #108]	; (211824 <LCD_StrMovVIndirect+0x9f4>)
  2117b6:	f7f6 fc01 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos+height_new,(uint32_t)F.yPos, M.spaceEndStart,M.windowWidth, pLcd);
  2117ba:	4919      	ldr	r1, [pc, #100]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2117bc:	68fa      	ldr	r2, [r7, #12]
  2117be:	4613      	mov	r3, r2
  2117c0:	011b      	lsls	r3, r3, #4
  2117c2:	1a9b      	subs	r3, r3, r2
  2117c4:	009b      	lsls	r3, r3, #2
  2117c6:	440b      	add	r3, r1
  2117c8:	3302      	adds	r3, #2
  2117ca:	881b      	ldrh	r3, [r3, #0]
  2117cc:	461a      	mov	r2, r3
  2117ce:	697b      	ldr	r3, [r7, #20]
  2117d0:	18d0      	adds	r0, r2, r3
  2117d2:	4913      	ldr	r1, [pc, #76]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2117d4:	68fa      	ldr	r2, [r7, #12]
  2117d6:	4613      	mov	r3, r2
  2117d8:	011b      	lsls	r3, r3, #4
  2117da:	1a9b      	subs	r3, r3, r2
  2117dc:	009b      	lsls	r3, r3, #2
  2117de:	440b      	add	r3, r1
  2117e0:	3304      	adds	r3, #4
  2117e2:	881b      	ldrh	r3, [r3, #0]
  2117e4:	461c      	mov	r4, r3
  2117e6:	490e      	ldr	r1, [pc, #56]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2117e8:	68fa      	ldr	r2, [r7, #12]
  2117ea:	4613      	mov	r3, r2
  2117ec:	011b      	lsls	r3, r3, #4
  2117ee:	1a9b      	subs	r3, r3, r2
  2117f0:	009b      	lsls	r3, r3, #2
  2117f2:	440b      	add	r3, r1
  2117f4:	3338      	adds	r3, #56	; 0x38
  2117f6:	881b      	ldrh	r3, [r3, #0]
  2117f8:	461d      	mov	r5, r3
  2117fa:	4909      	ldr	r1, [pc, #36]	; (211820 <LCD_StrMovVIndirect+0x9f0>)
  2117fc:	68fa      	ldr	r2, [r7, #12]
  2117fe:	4613      	mov	r3, r2
  211800:	011b      	lsls	r3, r3, #4
  211802:	1a9b      	subs	r3, r3, r2
  211804:	009b      	lsls	r3, r3, #2
  211806:	440b      	add	r3, r1
  211808:	3332      	adds	r3, #50	; 0x32
  21180a:	881b      	ldrh	r3, [r3, #0]
  21180c:	461a      	mov	r2, r3
  21180e:	4b05      	ldr	r3, [pc, #20]	; (211824 <LCD_StrMovVIndirect+0x9f4>)
  211810:	9300      	str	r3, [sp, #0]
  211812:	4613      	mov	r3, r2
  211814:	462a      	mov	r2, r5
  211816:	4621      	mov	r1, r4
  211818:	f7f6 f93c 	bl	207a94 <LCD_DisplayBuff>
						break;
  21181c:	e088      	b.n	211930 <LCD_StrMovVIndirect+0xb00>
  21181e:	bf00      	nop
  211820:	2000f818 	.word	0x2000f818
  211824:	c0000000 	.word	0xc0000000
						LCD_RectangleBuff(pLcd,0, M.spaceEndStart,M.windowWidth, 0,0, M.spaceEndStart,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
  211828:	49ac      	ldr	r1, [pc, #688]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21182a:	68fa      	ldr	r2, [r7, #12]
  21182c:	4613      	mov	r3, r2
  21182e:	011b      	lsls	r3, r3, #4
  211830:	1a9b      	subs	r3, r3, r2
  211832:	009b      	lsls	r3, r3, #2
  211834:	440b      	add	r3, r1
  211836:	3338      	adds	r3, #56	; 0x38
  211838:	881b      	ldrh	r3, [r3, #0]
  21183a:	469e      	mov	lr, r3
  21183c:	49a7      	ldr	r1, [pc, #668]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21183e:	68fa      	ldr	r2, [r7, #12]
  211840:	4613      	mov	r3, r2
  211842:	011b      	lsls	r3, r3, #4
  211844:	1a9b      	subs	r3, r3, r2
  211846:	009b      	lsls	r3, r3, #2
  211848:	440b      	add	r3, r1
  21184a:	3332      	adds	r3, #50	; 0x32
  21184c:	881b      	ldrh	r3, [r3, #0]
  21184e:	469c      	mov	ip, r3
  211850:	49a2      	ldr	r1, [pc, #648]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211852:	68fa      	ldr	r2, [r7, #12]
  211854:	4613      	mov	r3, r2
  211856:	011b      	lsls	r3, r3, #4
  211858:	1a9b      	subs	r3, r3, r2
  21185a:	009b      	lsls	r3, r3, #2
  21185c:	440b      	add	r3, r1
  21185e:	3338      	adds	r3, #56	; 0x38
  211860:	881b      	ldrh	r3, [r3, #0]
  211862:	461d      	mov	r5, r3
  211864:	499d      	ldr	r1, [pc, #628]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211866:	68fa      	ldr	r2, [r7, #12]
  211868:	4613      	mov	r3, r2
  21186a:	011b      	lsls	r3, r3, #4
  21186c:	1a9b      	subs	r3, r3, r2
  21186e:	009b      	lsls	r3, r3, #2
  211870:	440b      	add	r3, r1
  211872:	3332      	adds	r3, #50	; 0x32
  211874:	881b      	ldrh	r3, [r3, #0]
  211876:	461e      	mov	r6, r3
  211878:	4998      	ldr	r1, [pc, #608]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21187a:	68fa      	ldr	r2, [r7, #12]
  21187c:	4613      	mov	r3, r2
  21187e:	011b      	lsls	r3, r3, #4
  211880:	1a9b      	subs	r3, r3, r2
  211882:	009b      	lsls	r3, r3, #2
  211884:	440b      	add	r3, r1
  211886:	3308      	adds	r3, #8
  211888:	6819      	ldr	r1, [r3, #0]
  21188a:	4894      	ldr	r0, [pc, #592]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21188c:	68fa      	ldr	r2, [r7, #12]
  21188e:	4613      	mov	r3, r2
  211890:	011b      	lsls	r3, r3, #4
  211892:	1a9b      	subs	r3, r3, r2
  211894:	009b      	lsls	r3, r3, #2
  211896:	4403      	add	r3, r0
  211898:	3308      	adds	r3, #8
  21189a:	6818      	ldr	r0, [r3, #0]
  21189c:	4c8f      	ldr	r4, [pc, #572]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21189e:	68fa      	ldr	r2, [r7, #12]
  2118a0:	4613      	mov	r3, r2
  2118a2:	011b      	lsls	r3, r3, #4
  2118a4:	1a9b      	subs	r3, r3, r2
  2118a6:	009b      	lsls	r3, r3, #2
  2118a8:	4423      	add	r3, r4
  2118aa:	3308      	adds	r3, #8
  2118ac:	681b      	ldr	r3, [r3, #0]
  2118ae:	9306      	str	r3, [sp, #24]
  2118b0:	9005      	str	r0, [sp, #20]
  2118b2:	9104      	str	r1, [sp, #16]
  2118b4:	9603      	str	r6, [sp, #12]
  2118b6:	9502      	str	r5, [sp, #8]
  2118b8:	2300      	movs	r3, #0
  2118ba:	9301      	str	r3, [sp, #4]
  2118bc:	2300      	movs	r3, #0
  2118be:	9300      	str	r3, [sp, #0]
  2118c0:	4663      	mov	r3, ip
  2118c2:	4672      	mov	r2, lr
  2118c4:	2100      	movs	r1, #0
  2118c6:	4886      	ldr	r0, [pc, #536]	; (211ae0 <LCD_StrMovVIndirect+0xcb0>)
  2118c8:	f7f6 fb78 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos+height_old,(uint32_t)F.yPos, M.spaceEndStart,M.windowWidth, pLcd);
  2118cc:	4983      	ldr	r1, [pc, #524]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2118ce:	68fa      	ldr	r2, [r7, #12]
  2118d0:	4613      	mov	r3, r2
  2118d2:	011b      	lsls	r3, r3, #4
  2118d4:	1a9b      	subs	r3, r3, r2
  2118d6:	009b      	lsls	r3, r3, #2
  2118d8:	440b      	add	r3, r1
  2118da:	3302      	adds	r3, #2
  2118dc:	881b      	ldrh	r3, [r3, #0]
  2118de:	461a      	mov	r2, r3
  2118e0:	6a3b      	ldr	r3, [r7, #32]
  2118e2:	18d0      	adds	r0, r2, r3
  2118e4:	497d      	ldr	r1, [pc, #500]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2118e6:	68fa      	ldr	r2, [r7, #12]
  2118e8:	4613      	mov	r3, r2
  2118ea:	011b      	lsls	r3, r3, #4
  2118ec:	1a9b      	subs	r3, r3, r2
  2118ee:	009b      	lsls	r3, r3, #2
  2118f0:	440b      	add	r3, r1
  2118f2:	3304      	adds	r3, #4
  2118f4:	881b      	ldrh	r3, [r3, #0]
  2118f6:	461c      	mov	r4, r3
  2118f8:	4978      	ldr	r1, [pc, #480]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2118fa:	68fa      	ldr	r2, [r7, #12]
  2118fc:	4613      	mov	r3, r2
  2118fe:	011b      	lsls	r3, r3, #4
  211900:	1a9b      	subs	r3, r3, r2
  211902:	009b      	lsls	r3, r3, #2
  211904:	440b      	add	r3, r1
  211906:	3338      	adds	r3, #56	; 0x38
  211908:	881b      	ldrh	r3, [r3, #0]
  21190a:	461d      	mov	r5, r3
  21190c:	4973      	ldr	r1, [pc, #460]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21190e:	68fa      	ldr	r2, [r7, #12]
  211910:	4613      	mov	r3, r2
  211912:	011b      	lsls	r3, r3, #4
  211914:	1a9b      	subs	r3, r3, r2
  211916:	009b      	lsls	r3, r3, #2
  211918:	440b      	add	r3, r1
  21191a:	3332      	adds	r3, #50	; 0x32
  21191c:	881b      	ldrh	r3, [r3, #0]
  21191e:	461a      	mov	r2, r3
  211920:	4b6f      	ldr	r3, [pc, #444]	; (211ae0 <LCD_StrMovVIndirect+0xcb0>)
  211922:	9300      	str	r3, [sp, #0]
  211924:	4613      	mov	r3, r2
  211926:	462a      	mov	r2, r5
  211928:	4621      	mov	r1, r4
  21192a:	f7f6 f8b3 	bl	207a94 <LCD_DisplayBuff>
						break;
  21192e:	bf00      	nop
				}

				LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth,height_new, 0, M.windowWidth,0);
  211930:	496a      	ldr	r1, [pc, #424]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211932:	68fa      	ldr	r2, [r7, #12]
  211934:	4613      	mov	r3, r2
  211936:	011b      	lsls	r3, r3, #4
  211938:	1a9b      	subs	r3, r3, r2
  21193a:	009b      	lsls	r3, r3, #2
  21193c:	440b      	add	r3, r1
  21193e:	3314      	adds	r3, #20
  211940:	781b      	ldrb	r3, [r3, #0]
  211942:	461d      	mov	r5, r3
  211944:	4965      	ldr	r1, [pc, #404]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211946:	68fa      	ldr	r2, [r7, #12]
  211948:	4613      	mov	r3, r2
  21194a:	011b      	lsls	r3, r3, #4
  21194c:	1a9b      	subs	r3, r3, r2
  21194e:	009b      	lsls	r3, r3, #2
  211950:	440b      	add	r3, r1
  211952:	3328      	adds	r3, #40	; 0x28
  211954:	681c      	ldr	r4, [r3, #0]
  211956:	4961      	ldr	r1, [pc, #388]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211958:	68fa      	ldr	r2, [r7, #12]
  21195a:	4613      	mov	r3, r2
  21195c:	011b      	lsls	r3, r3, #4
  21195e:	1a9b      	subs	r3, r3, r2
  211960:	009b      	lsls	r3, r3, #2
  211962:	440b      	add	r3, r1
  211964:	332c      	adds	r3, #44	; 0x2c
  211966:	881b      	ldrh	r3, [r3, #0]
  211968:	461e      	mov	r6, r3
  21196a:	6979      	ldr	r1, [r7, #20]
  21196c:	485b      	ldr	r0, [pc, #364]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  21196e:	68fa      	ldr	r2, [r7, #12]
  211970:	4613      	mov	r3, r2
  211972:	011b      	lsls	r3, r3, #4
  211974:	1a9b      	subs	r3, r3, r2
  211976:	009b      	lsls	r3, r3, #2
  211978:	4403      	add	r3, r0
  21197a:	3332      	adds	r3, #50	; 0x32
  21197c:	881b      	ldrh	r3, [r3, #0]
  21197e:	2200      	movs	r2, #0
  211980:	9203      	str	r2, [sp, #12]
  211982:	9302      	str	r3, [sp, #8]
  211984:	2300      	movs	r3, #0
  211986:	9301      	str	r3, [sp, #4]
  211988:	9100      	str	r1, [sp, #0]
  21198a:	4633      	mov	r3, r6
  21198c:	4a55      	ldr	r2, [pc, #340]	; (211ae4 <LCD_StrMovVIndirect+0xcb4>)
  21198e:	4621      	mov	r1, r4
  211990:	4628      	mov	r0, r5
  211992:	f7f6 f9ab 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
				switch(F.rotate)
  211996:	4951      	ldr	r1, [pc, #324]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211998:	68fa      	ldr	r2, [r7, #12]
  21199a:	4613      	mov	r3, r2
  21199c:	011b      	lsls	r3, r3, #4
  21199e:	1a9b      	subs	r3, r3, r2
  2119a0:	009b      	lsls	r3, r3, #2
  2119a2:	440b      	add	r3, r1
  2119a4:	3314      	adds	r3, #20
  2119a6:	781b      	ldrb	r3, [r3, #0]
  2119a8:	2b01      	cmp	r3, #1
  2119aa:	d039      	beq.n	211a20 <LCD_StrMovVIndirect+0xbf0>
  2119ac:	2b02      	cmp	r3, #2
  2119ae:	d05f      	beq.n	211a70 <LCD_StrMovVIndirect+0xc40>
  2119b0:	2b00      	cmp	r3, #0
  2119b2:	d000      	beq.n	2119b6 <LCD_StrMovVIndirect+0xb86>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
						break;
					case Rotate_180:
						LCD_DisplayBuff((uint32_t)(F.xPos+height_old+M.spaceEndStart),(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
					default:
						break;
  2119b4:	e37f      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
					LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)(F.yPos+height_old+M.spaceEndStart), M.windowWidth,height_new, pLcd);
  2119b6:	4949      	ldr	r1, [pc, #292]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2119b8:	68fa      	ldr	r2, [r7, #12]
  2119ba:	4613      	mov	r3, r2
  2119bc:	011b      	lsls	r3, r3, #4
  2119be:	1a9b      	subs	r3, r3, r2
  2119c0:	009b      	lsls	r3, r3, #2
  2119c2:	440b      	add	r3, r1
  2119c4:	3302      	adds	r3, #2
  2119c6:	881b      	ldrh	r3, [r3, #0]
  2119c8:	461c      	mov	r4, r3
  2119ca:	4944      	ldr	r1, [pc, #272]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2119cc:	68fa      	ldr	r2, [r7, #12]
  2119ce:	4613      	mov	r3, r2
  2119d0:	011b      	lsls	r3, r3, #4
  2119d2:	1a9b      	subs	r3, r3, r2
  2119d4:	009b      	lsls	r3, r3, #2
  2119d6:	440b      	add	r3, r1
  2119d8:	3304      	adds	r3, #4
  2119da:	881b      	ldrh	r3, [r3, #0]
  2119dc:	461a      	mov	r2, r3
  2119de:	6a3b      	ldr	r3, [r7, #32]
  2119e0:	18d1      	adds	r1, r2, r3
  2119e2:	483e      	ldr	r0, [pc, #248]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2119e4:	68fa      	ldr	r2, [r7, #12]
  2119e6:	4613      	mov	r3, r2
  2119e8:	011b      	lsls	r3, r3, #4
  2119ea:	1a9b      	subs	r3, r3, r2
  2119ec:	009b      	lsls	r3, r3, #2
  2119ee:	4403      	add	r3, r0
  2119f0:	3338      	adds	r3, #56	; 0x38
  2119f2:	881b      	ldrh	r3, [r3, #0]
  2119f4:	440b      	add	r3, r1
  2119f6:	4618      	mov	r0, r3
  2119f8:	4938      	ldr	r1, [pc, #224]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  2119fa:	68fa      	ldr	r2, [r7, #12]
  2119fc:	4613      	mov	r3, r2
  2119fe:	011b      	lsls	r3, r3, #4
  211a00:	1a9b      	subs	r3, r3, r2
  211a02:	009b      	lsls	r3, r3, #2
  211a04:	440b      	add	r3, r1
  211a06:	3332      	adds	r3, #50	; 0x32
  211a08:	881b      	ldrh	r3, [r3, #0]
  211a0a:	4619      	mov	r1, r3
  211a0c:	697a      	ldr	r2, [r7, #20]
  211a0e:	4b34      	ldr	r3, [pc, #208]	; (211ae0 <LCD_StrMovVIndirect+0xcb0>)
  211a10:	9300      	str	r3, [sp, #0]
  211a12:	4613      	mov	r3, r2
  211a14:	460a      	mov	r2, r1
  211a16:	4601      	mov	r1, r0
  211a18:	4620      	mov	r0, r4
  211a1a:	f7f6 f83b 	bl	207a94 <LCD_DisplayBuff>
						break;
  211a1e:	e34a      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
  211a20:	492e      	ldr	r1, [pc, #184]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211a22:	68fa      	ldr	r2, [r7, #12]
  211a24:	4613      	mov	r3, r2
  211a26:	011b      	lsls	r3, r3, #4
  211a28:	1a9b      	subs	r3, r3, r2
  211a2a:	009b      	lsls	r3, r3, #2
  211a2c:	440b      	add	r3, r1
  211a2e:	3302      	adds	r3, #2
  211a30:	881b      	ldrh	r3, [r3, #0]
  211a32:	461c      	mov	r4, r3
  211a34:	4929      	ldr	r1, [pc, #164]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211a36:	68fa      	ldr	r2, [r7, #12]
  211a38:	4613      	mov	r3, r2
  211a3a:	011b      	lsls	r3, r3, #4
  211a3c:	1a9b      	subs	r3, r3, r2
  211a3e:	009b      	lsls	r3, r3, #2
  211a40:	440b      	add	r3, r1
  211a42:	3304      	adds	r3, #4
  211a44:	881b      	ldrh	r3, [r3, #0]
  211a46:	461d      	mov	r5, r3
  211a48:	6978      	ldr	r0, [r7, #20]
  211a4a:	4924      	ldr	r1, [pc, #144]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211a4c:	68fa      	ldr	r2, [r7, #12]
  211a4e:	4613      	mov	r3, r2
  211a50:	011b      	lsls	r3, r3, #4
  211a52:	1a9b      	subs	r3, r3, r2
  211a54:	009b      	lsls	r3, r3, #2
  211a56:	440b      	add	r3, r1
  211a58:	3332      	adds	r3, #50	; 0x32
  211a5a:	881b      	ldrh	r3, [r3, #0]
  211a5c:	461a      	mov	r2, r3
  211a5e:	4b20      	ldr	r3, [pc, #128]	; (211ae0 <LCD_StrMovVIndirect+0xcb0>)
  211a60:	9300      	str	r3, [sp, #0]
  211a62:	4613      	mov	r3, r2
  211a64:	4602      	mov	r2, r0
  211a66:	4629      	mov	r1, r5
  211a68:	4620      	mov	r0, r4
  211a6a:	f7f6 f813 	bl	207a94 <LCD_DisplayBuff>
						break;
  211a6e:	e322      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
						LCD_DisplayBuff((uint32_t)(F.xPos+height_old+M.spaceEndStart),(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
  211a70:	491a      	ldr	r1, [pc, #104]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211a72:	68fa      	ldr	r2, [r7, #12]
  211a74:	4613      	mov	r3, r2
  211a76:	011b      	lsls	r3, r3, #4
  211a78:	1a9b      	subs	r3, r3, r2
  211a7a:	009b      	lsls	r3, r3, #2
  211a7c:	440b      	add	r3, r1
  211a7e:	3302      	adds	r3, #2
  211a80:	881b      	ldrh	r3, [r3, #0]
  211a82:	461a      	mov	r2, r3
  211a84:	6a3b      	ldr	r3, [r7, #32]
  211a86:	18d1      	adds	r1, r2, r3
  211a88:	4814      	ldr	r0, [pc, #80]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211a8a:	68fa      	ldr	r2, [r7, #12]
  211a8c:	4613      	mov	r3, r2
  211a8e:	011b      	lsls	r3, r3, #4
  211a90:	1a9b      	subs	r3, r3, r2
  211a92:	009b      	lsls	r3, r3, #2
  211a94:	4403      	add	r3, r0
  211a96:	3338      	adds	r3, #56	; 0x38
  211a98:	881b      	ldrh	r3, [r3, #0]
  211a9a:	440b      	add	r3, r1
  211a9c:	461c      	mov	r4, r3
  211a9e:	490f      	ldr	r1, [pc, #60]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211aa0:	68fa      	ldr	r2, [r7, #12]
  211aa2:	4613      	mov	r3, r2
  211aa4:	011b      	lsls	r3, r3, #4
  211aa6:	1a9b      	subs	r3, r3, r2
  211aa8:	009b      	lsls	r3, r3, #2
  211aaa:	440b      	add	r3, r1
  211aac:	3304      	adds	r3, #4
  211aae:	881b      	ldrh	r3, [r3, #0]
  211ab0:	461d      	mov	r5, r3
  211ab2:	6978      	ldr	r0, [r7, #20]
  211ab4:	4909      	ldr	r1, [pc, #36]	; (211adc <LCD_StrMovVIndirect+0xcac>)
  211ab6:	68fa      	ldr	r2, [r7, #12]
  211ab8:	4613      	mov	r3, r2
  211aba:	011b      	lsls	r3, r3, #4
  211abc:	1a9b      	subs	r3, r3, r2
  211abe:	009b      	lsls	r3, r3, #2
  211ac0:	440b      	add	r3, r1
  211ac2:	3332      	adds	r3, #50	; 0x32
  211ac4:	881b      	ldrh	r3, [r3, #0]
  211ac6:	461a      	mov	r2, r3
  211ac8:	4b05      	ldr	r3, [pc, #20]	; (211ae0 <LCD_StrMovVIndirect+0xcb0>)
  211aca:	9300      	str	r3, [sp, #0]
  211acc:	4613      	mov	r3, r2
  211ace:	4602      	mov	r2, r0
  211ad0:	4629      	mov	r1, r5
  211ad2:	4620      	mov	r0, r4
  211ad4:	f7f5 ffde 	bl	207a94 <LCD_DisplayBuff>
						break;
  211ad8:	bf00      	nop
  211ada:	e2ec      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
  211adc:	2000f818 	.word	0x2000f818
  211ae0:	c0000000 	.word	0xc0000000
  211ae4:	c067f800 	.word	0xc067f800
				}
			}
		}
		else
		{	int spaceEndStart_new = M.spaceEndStart + height_old;
  211ae8:	4980      	ldr	r1, [pc, #512]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211aea:	68fa      	ldr	r2, [r7, #12]
  211aec:	4613      	mov	r3, r2
  211aee:	011b      	lsls	r3, r3, #4
  211af0:	1a9b      	subs	r3, r3, r2
  211af2:	009b      	lsls	r3, r3, #2
  211af4:	440b      	add	r3, r1
  211af6:	3338      	adds	r3, #56	; 0x38
  211af8:	881b      	ldrh	r3, [r3, #0]
  211afa:	461a      	mov	r2, r3
  211afc:	6a3b      	ldr	r3, [r7, #32]
  211afe:	4413      	add	r3, r2
  211b00:	61fb      	str	r3, [r7, #28]
			if(spaceEndStart_new>0)
  211b02:	69fb      	ldr	r3, [r7, #28]
  211b04:	2b00      	cmp	r3, #0
  211b06:	f340 8223 	ble.w	211f50 <LCD_StrMovVIndirect+0x1120>
			{
				int height_new = M.windowHeight - spaceEndStart_new;
  211b0a:	4978      	ldr	r1, [pc, #480]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b0c:	68fa      	ldr	r2, [r7, #12]
  211b0e:	4613      	mov	r3, r2
  211b10:	011b      	lsls	r3, r3, #4
  211b12:	1a9b      	subs	r3, r3, r2
  211b14:	009b      	lsls	r3, r3, #2
  211b16:	440b      	add	r3, r1
  211b18:	3334      	adds	r3, #52	; 0x34
  211b1a:	881b      	ldrh	r3, [r3, #0]
  211b1c:	461a      	mov	r2, r3
  211b1e:	69fb      	ldr	r3, [r7, #28]
  211b20:	1ad3      	subs	r3, r2, r3
  211b22:	61bb      	str	r3, [r7, #24]
				switch(F.rotate)
  211b24:	4971      	ldr	r1, [pc, #452]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b26:	68fa      	ldr	r2, [r7, #12]
  211b28:	4613      	mov	r3, r2
  211b2a:	011b      	lsls	r3, r3, #4
  211b2c:	1a9b      	subs	r3, r3, r2
  211b2e:	009b      	lsls	r3, r3, #2
  211b30:	440b      	add	r3, r1
  211b32:	3314      	adds	r3, #20
  211b34:	781b      	ldrb	r3, [r3, #0]
  211b36:	2b01      	cmp	r3, #1
  211b38:	d06d      	beq.n	211c16 <LCD_StrMovVIndirect+0xde6>
  211b3a:	2b02      	cmp	r3, #2
  211b3c:	f000 80da 	beq.w	211cf4 <LCD_StrMovVIndirect+0xec4>
  211b40:	2b00      	cmp	r3, #0
  211b42:	d000      	beq.n	211b46 <LCD_StrMovVIndirect+0xd16>
						break;
					case Rotate_180:
						LCD_RectangleBuff(pLcd,0, spaceEndStart_new,M.windowWidth ,0,0,spaceEndStart_new,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, spaceEndStart_new,M.windowWidth, pLcd);
					default:
						break;
  211b44:	e13e      	b.n	211dc4 <LCD_StrMovVIndirect+0xf94>
						LCD_RectangleBuff(pLcd,0, M.windowWidth,spaceEndStart_new ,0,0, M.windowWidth,spaceEndStart_new, F.bkColor,F.bkColor,F.bkColor);
  211b46:	4969      	ldr	r1, [pc, #420]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b48:	68fa      	ldr	r2, [r7, #12]
  211b4a:	4613      	mov	r3, r2
  211b4c:	011b      	lsls	r3, r3, #4
  211b4e:	1a9b      	subs	r3, r3, r2
  211b50:	009b      	lsls	r3, r3, #2
  211b52:	440b      	add	r3, r1
  211b54:	3332      	adds	r3, #50	; 0x32
  211b56:	881b      	ldrh	r3, [r3, #0]
  211b58:	469e      	mov	lr, r3
  211b5a:	69fe      	ldr	r6, [r7, #28]
  211b5c:	4963      	ldr	r1, [pc, #396]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b5e:	68fa      	ldr	r2, [r7, #12]
  211b60:	4613      	mov	r3, r2
  211b62:	011b      	lsls	r3, r3, #4
  211b64:	1a9b      	subs	r3, r3, r2
  211b66:	009b      	lsls	r3, r3, #2
  211b68:	440b      	add	r3, r1
  211b6a:	3332      	adds	r3, #50	; 0x32
  211b6c:	881b      	ldrh	r3, [r3, #0]
  211b6e:	607b      	str	r3, [r7, #4]
  211b70:	69f9      	ldr	r1, [r7, #28]
  211b72:	485e      	ldr	r0, [pc, #376]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b74:	68fa      	ldr	r2, [r7, #12]
  211b76:	4613      	mov	r3, r2
  211b78:	011b      	lsls	r3, r3, #4
  211b7a:	1a9b      	subs	r3, r3, r2
  211b7c:	009b      	lsls	r3, r3, #2
  211b7e:	4403      	add	r3, r0
  211b80:	3308      	adds	r3, #8
  211b82:	6818      	ldr	r0, [r3, #0]
  211b84:	4c59      	ldr	r4, [pc, #356]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b86:	68fa      	ldr	r2, [r7, #12]
  211b88:	4613      	mov	r3, r2
  211b8a:	011b      	lsls	r3, r3, #4
  211b8c:	1a9b      	subs	r3, r3, r2
  211b8e:	009b      	lsls	r3, r3, #2
  211b90:	4423      	add	r3, r4
  211b92:	3308      	adds	r3, #8
  211b94:	681c      	ldr	r4, [r3, #0]
  211b96:	4d55      	ldr	r5, [pc, #340]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211b98:	68fa      	ldr	r2, [r7, #12]
  211b9a:	4613      	mov	r3, r2
  211b9c:	011b      	lsls	r3, r3, #4
  211b9e:	1a9b      	subs	r3, r3, r2
  211ba0:	009b      	lsls	r3, r3, #2
  211ba2:	442b      	add	r3, r5
  211ba4:	3308      	adds	r3, #8
  211ba6:	681b      	ldr	r3, [r3, #0]
  211ba8:	9306      	str	r3, [sp, #24]
  211baa:	9405      	str	r4, [sp, #20]
  211bac:	9004      	str	r0, [sp, #16]
  211bae:	9103      	str	r1, [sp, #12]
  211bb0:	687b      	ldr	r3, [r7, #4]
  211bb2:	9302      	str	r3, [sp, #8]
  211bb4:	2300      	movs	r3, #0
  211bb6:	9301      	str	r3, [sp, #4]
  211bb8:	2300      	movs	r3, #0
  211bba:	9300      	str	r3, [sp, #0]
  211bbc:	4633      	mov	r3, r6
  211bbe:	4672      	mov	r2, lr
  211bc0:	2100      	movs	r1, #0
  211bc2:	484b      	ldr	r0, [pc, #300]	; (211cf0 <LCD_StrMovVIndirect+0xec0>)
  211bc4:	f7f6 f9fa 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowWidth,spaceEndStart_new, pLcd);
  211bc8:	4948      	ldr	r1, [pc, #288]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211bca:	68fa      	ldr	r2, [r7, #12]
  211bcc:	4613      	mov	r3, r2
  211bce:	011b      	lsls	r3, r3, #4
  211bd0:	1a9b      	subs	r3, r3, r2
  211bd2:	009b      	lsls	r3, r3, #2
  211bd4:	440b      	add	r3, r1
  211bd6:	3302      	adds	r3, #2
  211bd8:	881b      	ldrh	r3, [r3, #0]
  211bda:	4618      	mov	r0, r3
  211bdc:	4943      	ldr	r1, [pc, #268]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211bde:	68fa      	ldr	r2, [r7, #12]
  211be0:	4613      	mov	r3, r2
  211be2:	011b      	lsls	r3, r3, #4
  211be4:	1a9b      	subs	r3, r3, r2
  211be6:	009b      	lsls	r3, r3, #2
  211be8:	440b      	add	r3, r1
  211bea:	3304      	adds	r3, #4
  211bec:	881b      	ldrh	r3, [r3, #0]
  211bee:	461c      	mov	r4, r3
  211bf0:	493e      	ldr	r1, [pc, #248]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211bf2:	68fa      	ldr	r2, [r7, #12]
  211bf4:	4613      	mov	r3, r2
  211bf6:	011b      	lsls	r3, r3, #4
  211bf8:	1a9b      	subs	r3, r3, r2
  211bfa:	009b      	lsls	r3, r3, #2
  211bfc:	440b      	add	r3, r1
  211bfe:	3332      	adds	r3, #50	; 0x32
  211c00:	881b      	ldrh	r3, [r3, #0]
  211c02:	4619      	mov	r1, r3
  211c04:	69fa      	ldr	r2, [r7, #28]
  211c06:	4b3a      	ldr	r3, [pc, #232]	; (211cf0 <LCD_StrMovVIndirect+0xec0>)
  211c08:	9300      	str	r3, [sp, #0]
  211c0a:	4613      	mov	r3, r2
  211c0c:	460a      	mov	r2, r1
  211c0e:	4621      	mov	r1, r4
  211c10:	f7f5 ff40 	bl	207a94 <LCD_DisplayBuff>
						break;
  211c14:	e0d7      	b.n	211dc6 <LCD_StrMovVIndirect+0xf96>
						LCD_RectangleBuff(pLcd,0, spaceEndStart_new,M.windowWidth ,0,0, spaceEndStart_new,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
  211c16:	69fe      	ldr	r6, [r7, #28]
  211c18:	4934      	ldr	r1, [pc, #208]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211c1a:	68fa      	ldr	r2, [r7, #12]
  211c1c:	4613      	mov	r3, r2
  211c1e:	011b      	lsls	r3, r3, #4
  211c20:	1a9b      	subs	r3, r3, r2
  211c22:	009b      	lsls	r3, r3, #2
  211c24:	440b      	add	r3, r1
  211c26:	3332      	adds	r3, #50	; 0x32
  211c28:	881b      	ldrh	r3, [r3, #0]
  211c2a:	469e      	mov	lr, r3
  211c2c:	69f9      	ldr	r1, [r7, #28]
  211c2e:	482f      	ldr	r0, [pc, #188]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211c30:	68fa      	ldr	r2, [r7, #12]
  211c32:	4613      	mov	r3, r2
  211c34:	011b      	lsls	r3, r3, #4
  211c36:	1a9b      	subs	r3, r3, r2
  211c38:	009b      	lsls	r3, r3, #2
  211c3a:	4403      	add	r3, r0
  211c3c:	3332      	adds	r3, #50	; 0x32
  211c3e:	881b      	ldrh	r3, [r3, #0]
  211c40:	607b      	str	r3, [r7, #4]
  211c42:	482a      	ldr	r0, [pc, #168]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211c44:	68fa      	ldr	r2, [r7, #12]
  211c46:	4613      	mov	r3, r2
  211c48:	011b      	lsls	r3, r3, #4
  211c4a:	1a9b      	subs	r3, r3, r2
  211c4c:	009b      	lsls	r3, r3, #2
  211c4e:	4403      	add	r3, r0
  211c50:	3308      	adds	r3, #8
  211c52:	6818      	ldr	r0, [r3, #0]
  211c54:	4c25      	ldr	r4, [pc, #148]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211c56:	68fa      	ldr	r2, [r7, #12]
  211c58:	4613      	mov	r3, r2
  211c5a:	011b      	lsls	r3, r3, #4
  211c5c:	1a9b      	subs	r3, r3, r2
  211c5e:	009b      	lsls	r3, r3, #2
  211c60:	4423      	add	r3, r4
  211c62:	3308      	adds	r3, #8
  211c64:	681c      	ldr	r4, [r3, #0]
  211c66:	4d21      	ldr	r5, [pc, #132]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211c68:	68fa      	ldr	r2, [r7, #12]
  211c6a:	4613      	mov	r3, r2
  211c6c:	011b      	lsls	r3, r3, #4
  211c6e:	1a9b      	subs	r3, r3, r2
  211c70:	009b      	lsls	r3, r3, #2
  211c72:	442b      	add	r3, r5
  211c74:	3308      	adds	r3, #8
  211c76:	681b      	ldr	r3, [r3, #0]
  211c78:	9306      	str	r3, [sp, #24]
  211c7a:	9405      	str	r4, [sp, #20]
  211c7c:	9004      	str	r0, [sp, #16]
  211c7e:	687b      	ldr	r3, [r7, #4]
  211c80:	9303      	str	r3, [sp, #12]
  211c82:	9102      	str	r1, [sp, #8]
  211c84:	2300      	movs	r3, #0
  211c86:	9301      	str	r3, [sp, #4]
  211c88:	2300      	movs	r3, #0
  211c8a:	9300      	str	r3, [sp, #0]
  211c8c:	4673      	mov	r3, lr
  211c8e:	4632      	mov	r2, r6
  211c90:	2100      	movs	r1, #0
  211c92:	4817      	ldr	r0, [pc, #92]	; (211cf0 <LCD_StrMovVIndirect+0xec0>)
  211c94:	f7f6 f992 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos+height_new,(uint32_t)F.yPos, spaceEndStart_new,M.windowWidth, pLcd);
  211c98:	4914      	ldr	r1, [pc, #80]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211c9a:	68fa      	ldr	r2, [r7, #12]
  211c9c:	4613      	mov	r3, r2
  211c9e:	011b      	lsls	r3, r3, #4
  211ca0:	1a9b      	subs	r3, r3, r2
  211ca2:	009b      	lsls	r3, r3, #2
  211ca4:	440b      	add	r3, r1
  211ca6:	3302      	adds	r3, #2
  211ca8:	881b      	ldrh	r3, [r3, #0]
  211caa:	461a      	mov	r2, r3
  211cac:	69bb      	ldr	r3, [r7, #24]
  211cae:	18d0      	adds	r0, r2, r3
  211cb0:	490e      	ldr	r1, [pc, #56]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211cb2:	68fa      	ldr	r2, [r7, #12]
  211cb4:	4613      	mov	r3, r2
  211cb6:	011b      	lsls	r3, r3, #4
  211cb8:	1a9b      	subs	r3, r3, r2
  211cba:	009b      	lsls	r3, r3, #2
  211cbc:	440b      	add	r3, r1
  211cbe:	3304      	adds	r3, #4
  211cc0:	881b      	ldrh	r3, [r3, #0]
  211cc2:	461d      	mov	r5, r3
  211cc4:	69fc      	ldr	r4, [r7, #28]
  211cc6:	4909      	ldr	r1, [pc, #36]	; (211cec <LCD_StrMovVIndirect+0xebc>)
  211cc8:	68fa      	ldr	r2, [r7, #12]
  211cca:	4613      	mov	r3, r2
  211ccc:	011b      	lsls	r3, r3, #4
  211cce:	1a9b      	subs	r3, r3, r2
  211cd0:	009b      	lsls	r3, r3, #2
  211cd2:	440b      	add	r3, r1
  211cd4:	3332      	adds	r3, #50	; 0x32
  211cd6:	881b      	ldrh	r3, [r3, #0]
  211cd8:	461a      	mov	r2, r3
  211cda:	4b05      	ldr	r3, [pc, #20]	; (211cf0 <LCD_StrMovVIndirect+0xec0>)
  211cdc:	9300      	str	r3, [sp, #0]
  211cde:	4613      	mov	r3, r2
  211ce0:	4622      	mov	r2, r4
  211ce2:	4629      	mov	r1, r5
  211ce4:	f7f5 fed6 	bl	207a94 <LCD_DisplayBuff>
						break;
  211ce8:	e06d      	b.n	211dc6 <LCD_StrMovVIndirect+0xf96>
  211cea:	bf00      	nop
  211cec:	2000f818 	.word	0x2000f818
  211cf0:	c0000000 	.word	0xc0000000
						LCD_RectangleBuff(pLcd,0, spaceEndStart_new,M.windowWidth ,0,0,spaceEndStart_new,M.windowWidth, F.bkColor,F.bkColor,F.bkColor);
  211cf4:	69fe      	ldr	r6, [r7, #28]
  211cf6:	4993      	ldr	r1, [pc, #588]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211cf8:	68fa      	ldr	r2, [r7, #12]
  211cfa:	4613      	mov	r3, r2
  211cfc:	011b      	lsls	r3, r3, #4
  211cfe:	1a9b      	subs	r3, r3, r2
  211d00:	009b      	lsls	r3, r3, #2
  211d02:	440b      	add	r3, r1
  211d04:	3332      	adds	r3, #50	; 0x32
  211d06:	881b      	ldrh	r3, [r3, #0]
  211d08:	469e      	mov	lr, r3
  211d0a:	69f9      	ldr	r1, [r7, #28]
  211d0c:	488d      	ldr	r0, [pc, #564]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211d0e:	68fa      	ldr	r2, [r7, #12]
  211d10:	4613      	mov	r3, r2
  211d12:	011b      	lsls	r3, r3, #4
  211d14:	1a9b      	subs	r3, r3, r2
  211d16:	009b      	lsls	r3, r3, #2
  211d18:	4403      	add	r3, r0
  211d1a:	3332      	adds	r3, #50	; 0x32
  211d1c:	881b      	ldrh	r3, [r3, #0]
  211d1e:	607b      	str	r3, [r7, #4]
  211d20:	4888      	ldr	r0, [pc, #544]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211d22:	68fa      	ldr	r2, [r7, #12]
  211d24:	4613      	mov	r3, r2
  211d26:	011b      	lsls	r3, r3, #4
  211d28:	1a9b      	subs	r3, r3, r2
  211d2a:	009b      	lsls	r3, r3, #2
  211d2c:	4403      	add	r3, r0
  211d2e:	3308      	adds	r3, #8
  211d30:	6818      	ldr	r0, [r3, #0]
  211d32:	4c84      	ldr	r4, [pc, #528]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211d34:	68fa      	ldr	r2, [r7, #12]
  211d36:	4613      	mov	r3, r2
  211d38:	011b      	lsls	r3, r3, #4
  211d3a:	1a9b      	subs	r3, r3, r2
  211d3c:	009b      	lsls	r3, r3, #2
  211d3e:	4423      	add	r3, r4
  211d40:	3308      	adds	r3, #8
  211d42:	681c      	ldr	r4, [r3, #0]
  211d44:	4d7f      	ldr	r5, [pc, #508]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211d46:	68fa      	ldr	r2, [r7, #12]
  211d48:	4613      	mov	r3, r2
  211d4a:	011b      	lsls	r3, r3, #4
  211d4c:	1a9b      	subs	r3, r3, r2
  211d4e:	009b      	lsls	r3, r3, #2
  211d50:	442b      	add	r3, r5
  211d52:	3308      	adds	r3, #8
  211d54:	681b      	ldr	r3, [r3, #0]
  211d56:	9306      	str	r3, [sp, #24]
  211d58:	9405      	str	r4, [sp, #20]
  211d5a:	9004      	str	r0, [sp, #16]
  211d5c:	687b      	ldr	r3, [r7, #4]
  211d5e:	9303      	str	r3, [sp, #12]
  211d60:	9102      	str	r1, [sp, #8]
  211d62:	2300      	movs	r3, #0
  211d64:	9301      	str	r3, [sp, #4]
  211d66:	2300      	movs	r3, #0
  211d68:	9300      	str	r3, [sp, #0]
  211d6a:	4673      	mov	r3, lr
  211d6c:	4632      	mov	r2, r6
  211d6e:	2100      	movs	r1, #0
  211d70:	4875      	ldr	r0, [pc, #468]	; (211f48 <LCD_StrMovVIndirect+0x1118>)
  211d72:	f7f6 f923 	bl	207fbc <LCD_RectangleBuff>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, spaceEndStart_new,M.windowWidth, pLcd);
  211d76:	4973      	ldr	r1, [pc, #460]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211d78:	68fa      	ldr	r2, [r7, #12]
  211d7a:	4613      	mov	r3, r2
  211d7c:	011b      	lsls	r3, r3, #4
  211d7e:	1a9b      	subs	r3, r3, r2
  211d80:	009b      	lsls	r3, r3, #2
  211d82:	440b      	add	r3, r1
  211d84:	3302      	adds	r3, #2
  211d86:	881b      	ldrh	r3, [r3, #0]
  211d88:	461c      	mov	r4, r3
  211d8a:	496e      	ldr	r1, [pc, #440]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211d8c:	68fa      	ldr	r2, [r7, #12]
  211d8e:	4613      	mov	r3, r2
  211d90:	011b      	lsls	r3, r3, #4
  211d92:	1a9b      	subs	r3, r3, r2
  211d94:	009b      	lsls	r3, r3, #2
  211d96:	440b      	add	r3, r1
  211d98:	3304      	adds	r3, #4
  211d9a:	881b      	ldrh	r3, [r3, #0]
  211d9c:	461d      	mov	r5, r3
  211d9e:	69f8      	ldr	r0, [r7, #28]
  211da0:	4968      	ldr	r1, [pc, #416]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211da2:	68fa      	ldr	r2, [r7, #12]
  211da4:	4613      	mov	r3, r2
  211da6:	011b      	lsls	r3, r3, #4
  211da8:	1a9b      	subs	r3, r3, r2
  211daa:	009b      	lsls	r3, r3, #2
  211dac:	440b      	add	r3, r1
  211dae:	3332      	adds	r3, #50	; 0x32
  211db0:	881b      	ldrh	r3, [r3, #0]
  211db2:	461a      	mov	r2, r3
  211db4:	4b64      	ldr	r3, [pc, #400]	; (211f48 <LCD_StrMovVIndirect+0x1118>)
  211db6:	9300      	str	r3, [sp, #0]
  211db8:	4613      	mov	r3, r2
  211dba:	4602      	mov	r2, r0
  211dbc:	4629      	mov	r1, r5
  211dbe:	4620      	mov	r0, r4
  211dc0:	f7f5 fe68 	bl	207a94 <LCD_DisplayBuff>
						break;
  211dc4:	bf00      	nop
				}

				LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth,height_new, 0, M.windowWidth,0);
  211dc6:	495f      	ldr	r1, [pc, #380]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211dc8:	68fa      	ldr	r2, [r7, #12]
  211dca:	4613      	mov	r3, r2
  211dcc:	011b      	lsls	r3, r3, #4
  211dce:	1a9b      	subs	r3, r3, r2
  211dd0:	009b      	lsls	r3, r3, #2
  211dd2:	440b      	add	r3, r1
  211dd4:	3314      	adds	r3, #20
  211dd6:	781b      	ldrb	r3, [r3, #0]
  211dd8:	461d      	mov	r5, r3
  211dda:	495a      	ldr	r1, [pc, #360]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211ddc:	68fa      	ldr	r2, [r7, #12]
  211dde:	4613      	mov	r3, r2
  211de0:	011b      	lsls	r3, r3, #4
  211de2:	1a9b      	subs	r3, r3, r2
  211de4:	009b      	lsls	r3, r3, #2
  211de6:	440b      	add	r3, r1
  211de8:	3328      	adds	r3, #40	; 0x28
  211dea:	681c      	ldr	r4, [r3, #0]
  211dec:	4955      	ldr	r1, [pc, #340]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211dee:	68fa      	ldr	r2, [r7, #12]
  211df0:	4613      	mov	r3, r2
  211df2:	011b      	lsls	r3, r3, #4
  211df4:	1a9b      	subs	r3, r3, r2
  211df6:	009b      	lsls	r3, r3, #2
  211df8:	440b      	add	r3, r1
  211dfa:	332c      	adds	r3, #44	; 0x2c
  211dfc:	881b      	ldrh	r3, [r3, #0]
  211dfe:	461e      	mov	r6, r3
  211e00:	69b9      	ldr	r1, [r7, #24]
  211e02:	4850      	ldr	r0, [pc, #320]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211e04:	68fa      	ldr	r2, [r7, #12]
  211e06:	4613      	mov	r3, r2
  211e08:	011b      	lsls	r3, r3, #4
  211e0a:	1a9b      	subs	r3, r3, r2
  211e0c:	009b      	lsls	r3, r3, #2
  211e0e:	4403      	add	r3, r0
  211e10:	3332      	adds	r3, #50	; 0x32
  211e12:	881b      	ldrh	r3, [r3, #0]
  211e14:	2200      	movs	r2, #0
  211e16:	9203      	str	r2, [sp, #12]
  211e18:	9302      	str	r3, [sp, #8]
  211e1a:	2300      	movs	r3, #0
  211e1c:	9301      	str	r3, [sp, #4]
  211e1e:	9100      	str	r1, [sp, #0]
  211e20:	4633      	mov	r3, r6
  211e22:	4a4a      	ldr	r2, [pc, #296]	; (211f4c <LCD_StrMovVIndirect+0x111c>)
  211e24:	4621      	mov	r1, r4
  211e26:	4628      	mov	r0, r5
  211e28:	f7f5 ff60 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
				switch(F.rotate)
  211e2c:	4945      	ldr	r1, [pc, #276]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211e2e:	68fa      	ldr	r2, [r7, #12]
  211e30:	4613      	mov	r3, r2
  211e32:	011b      	lsls	r3, r3, #4
  211e34:	1a9b      	subs	r3, r3, r2
  211e36:	009b      	lsls	r3, r3, #2
  211e38:	440b      	add	r3, r1
  211e3a:	3314      	adds	r3, #20
  211e3c:	781b      	ldrb	r3, [r3, #0]
  211e3e:	2b01      	cmp	r3, #1
  211e40:	d02e      	beq.n	211ea0 <LCD_StrMovVIndirect+0x1070>
  211e42:	2b02      	cmp	r3, #2
  211e44:	d054      	beq.n	211ef0 <LCD_StrMovVIndirect+0x10c0>
  211e46:	2b00      	cmp	r3, #0
  211e48:	d000      	beq.n	211e4c <LCD_StrMovVIndirect+0x101c>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
						break;
					case Rotate_180:
						LCD_DisplayBuff((uint32_t)F.xPos+spaceEndStart_new,(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
					default:
						break;
  211e4a:	e134      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)(F.yPos+spaceEndStart_new), M.windowWidth,height_new, pLcd);
  211e4c:	493d      	ldr	r1, [pc, #244]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211e4e:	68fa      	ldr	r2, [r7, #12]
  211e50:	4613      	mov	r3, r2
  211e52:	011b      	lsls	r3, r3, #4
  211e54:	1a9b      	subs	r3, r3, r2
  211e56:	009b      	lsls	r3, r3, #2
  211e58:	440b      	add	r3, r1
  211e5a:	3302      	adds	r3, #2
  211e5c:	881b      	ldrh	r3, [r3, #0]
  211e5e:	4618      	mov	r0, r3
  211e60:	4938      	ldr	r1, [pc, #224]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211e62:	68fa      	ldr	r2, [r7, #12]
  211e64:	4613      	mov	r3, r2
  211e66:	011b      	lsls	r3, r3, #4
  211e68:	1a9b      	subs	r3, r3, r2
  211e6a:	009b      	lsls	r3, r3, #2
  211e6c:	440b      	add	r3, r1
  211e6e:	3304      	adds	r3, #4
  211e70:	881b      	ldrh	r3, [r3, #0]
  211e72:	461a      	mov	r2, r3
  211e74:	69fb      	ldr	r3, [r7, #28]
  211e76:	4413      	add	r3, r2
  211e78:	461c      	mov	r4, r3
  211e7a:	4932      	ldr	r1, [pc, #200]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211e7c:	68fa      	ldr	r2, [r7, #12]
  211e7e:	4613      	mov	r3, r2
  211e80:	011b      	lsls	r3, r3, #4
  211e82:	1a9b      	subs	r3, r3, r2
  211e84:	009b      	lsls	r3, r3, #2
  211e86:	440b      	add	r3, r1
  211e88:	3332      	adds	r3, #50	; 0x32
  211e8a:	881b      	ldrh	r3, [r3, #0]
  211e8c:	4619      	mov	r1, r3
  211e8e:	69ba      	ldr	r2, [r7, #24]
  211e90:	4b2d      	ldr	r3, [pc, #180]	; (211f48 <LCD_StrMovVIndirect+0x1118>)
  211e92:	9300      	str	r3, [sp, #0]
  211e94:	4613      	mov	r3, r2
  211e96:	460a      	mov	r2, r1
  211e98:	4621      	mov	r1, r4
  211e9a:	f7f5 fdfb 	bl	207a94 <LCD_DisplayBuff>
						break;
  211e9e:	e10a      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
  211ea0:	4928      	ldr	r1, [pc, #160]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211ea2:	68fa      	ldr	r2, [r7, #12]
  211ea4:	4613      	mov	r3, r2
  211ea6:	011b      	lsls	r3, r3, #4
  211ea8:	1a9b      	subs	r3, r3, r2
  211eaa:	009b      	lsls	r3, r3, #2
  211eac:	440b      	add	r3, r1
  211eae:	3302      	adds	r3, #2
  211eb0:	881b      	ldrh	r3, [r3, #0]
  211eb2:	461c      	mov	r4, r3
  211eb4:	4923      	ldr	r1, [pc, #140]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211eb6:	68fa      	ldr	r2, [r7, #12]
  211eb8:	4613      	mov	r3, r2
  211eba:	011b      	lsls	r3, r3, #4
  211ebc:	1a9b      	subs	r3, r3, r2
  211ebe:	009b      	lsls	r3, r3, #2
  211ec0:	440b      	add	r3, r1
  211ec2:	3304      	adds	r3, #4
  211ec4:	881b      	ldrh	r3, [r3, #0]
  211ec6:	461d      	mov	r5, r3
  211ec8:	69b8      	ldr	r0, [r7, #24]
  211eca:	491e      	ldr	r1, [pc, #120]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211ecc:	68fa      	ldr	r2, [r7, #12]
  211ece:	4613      	mov	r3, r2
  211ed0:	011b      	lsls	r3, r3, #4
  211ed2:	1a9b      	subs	r3, r3, r2
  211ed4:	009b      	lsls	r3, r3, #2
  211ed6:	440b      	add	r3, r1
  211ed8:	3332      	adds	r3, #50	; 0x32
  211eda:	881b      	ldrh	r3, [r3, #0]
  211edc:	461a      	mov	r2, r3
  211ede:	4b1a      	ldr	r3, [pc, #104]	; (211f48 <LCD_StrMovVIndirect+0x1118>)
  211ee0:	9300      	str	r3, [sp, #0]
  211ee2:	4613      	mov	r3, r2
  211ee4:	4602      	mov	r2, r0
  211ee6:	4629      	mov	r1, r5
  211ee8:	4620      	mov	r0, r4
  211eea:	f7f5 fdd3 	bl	207a94 <LCD_DisplayBuff>
						break;
  211eee:	e0e2      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
						LCD_DisplayBuff((uint32_t)F.xPos+spaceEndStart_new,(uint32_t)F.yPos, height_new,M.windowWidth, pLcd);
  211ef0:	4914      	ldr	r1, [pc, #80]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211ef2:	68fa      	ldr	r2, [r7, #12]
  211ef4:	4613      	mov	r3, r2
  211ef6:	011b      	lsls	r3, r3, #4
  211ef8:	1a9b      	subs	r3, r3, r2
  211efa:	009b      	lsls	r3, r3, #2
  211efc:	440b      	add	r3, r1
  211efe:	3302      	adds	r3, #2
  211f00:	881b      	ldrh	r3, [r3, #0]
  211f02:	461a      	mov	r2, r3
  211f04:	69fb      	ldr	r3, [r7, #28]
  211f06:	18d0      	adds	r0, r2, r3
  211f08:	490e      	ldr	r1, [pc, #56]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211f0a:	68fa      	ldr	r2, [r7, #12]
  211f0c:	4613      	mov	r3, r2
  211f0e:	011b      	lsls	r3, r3, #4
  211f10:	1a9b      	subs	r3, r3, r2
  211f12:	009b      	lsls	r3, r3, #2
  211f14:	440b      	add	r3, r1
  211f16:	3304      	adds	r3, #4
  211f18:	881b      	ldrh	r3, [r3, #0]
  211f1a:	461d      	mov	r5, r3
  211f1c:	69bc      	ldr	r4, [r7, #24]
  211f1e:	4909      	ldr	r1, [pc, #36]	; (211f44 <LCD_StrMovVIndirect+0x1114>)
  211f20:	68fa      	ldr	r2, [r7, #12]
  211f22:	4613      	mov	r3, r2
  211f24:	011b      	lsls	r3, r3, #4
  211f26:	1a9b      	subs	r3, r3, r2
  211f28:	009b      	lsls	r3, r3, #2
  211f2a:	440b      	add	r3, r1
  211f2c:	3332      	adds	r3, #50	; 0x32
  211f2e:	881b      	ldrh	r3, [r3, #0]
  211f30:	461a      	mov	r2, r3
  211f32:	4b05      	ldr	r3, [pc, #20]	; (211f48 <LCD_StrMovVIndirect+0x1118>)
  211f34:	9300      	str	r3, [sp, #0]
  211f36:	4613      	mov	r3, r2
  211f38:	4622      	mov	r2, r4
  211f3a:	4629      	mov	r1, r5
  211f3c:	f7f5 fdaa 	bl	207a94 <LCD_DisplayBuff>
						break;
  211f40:	bf00      	nop
  211f42:	e0b8      	b.n	2120b6 <LCD_StrMovVIndirect+0x1286>
  211f44:	2000f818 	.word	0x2000f818
  211f48:	c0000000 	.word	0xc0000000
  211f4c:	c067f800 	.word	0xc067f800
				}
			}
			else
			{	M.posWin=0;
  211f50:	495b      	ldr	r1, [pc, #364]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211f52:	68fa      	ldr	r2, [r7, #12]
  211f54:	4613      	mov	r3, r2
  211f56:	011b      	lsls	r3, r3, #4
  211f58:	1a9b      	subs	r3, r3, r2
  211f5a:	009b      	lsls	r3, r3, #2
  211f5c:	440b      	add	r3, r1
  211f5e:	3330      	adds	r3, #48	; 0x30
  211f60:	2200      	movs	r2, #0
  211f62:	801a      	strh	r2, [r3, #0]
				LCD_CopyBuff2pLcdIndirect(F.rotate,M.posBuff, movableFontsBuffer, M.xImgWidth,M.windowHeight, 0, M.windowWidth,0);
  211f64:	4956      	ldr	r1, [pc, #344]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211f66:	68fa      	ldr	r2, [r7, #12]
  211f68:	4613      	mov	r3, r2
  211f6a:	011b      	lsls	r3, r3, #4
  211f6c:	1a9b      	subs	r3, r3, r2
  211f6e:	009b      	lsls	r3, r3, #2
  211f70:	440b      	add	r3, r1
  211f72:	3314      	adds	r3, #20
  211f74:	781b      	ldrb	r3, [r3, #0]
  211f76:	461d      	mov	r5, r3
  211f78:	4951      	ldr	r1, [pc, #324]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211f7a:	68fa      	ldr	r2, [r7, #12]
  211f7c:	4613      	mov	r3, r2
  211f7e:	011b      	lsls	r3, r3, #4
  211f80:	1a9b      	subs	r3, r3, r2
  211f82:	009b      	lsls	r3, r3, #2
  211f84:	440b      	add	r3, r1
  211f86:	3328      	adds	r3, #40	; 0x28
  211f88:	6818      	ldr	r0, [r3, #0]
  211f8a:	494d      	ldr	r1, [pc, #308]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211f8c:	68fa      	ldr	r2, [r7, #12]
  211f8e:	4613      	mov	r3, r2
  211f90:	011b      	lsls	r3, r3, #4
  211f92:	1a9b      	subs	r3, r3, r2
  211f94:	009b      	lsls	r3, r3, #2
  211f96:	440b      	add	r3, r1
  211f98:	332c      	adds	r3, #44	; 0x2c
  211f9a:	881b      	ldrh	r3, [r3, #0]
  211f9c:	461e      	mov	r6, r3
  211f9e:	4948      	ldr	r1, [pc, #288]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211fa0:	68fa      	ldr	r2, [r7, #12]
  211fa2:	4613      	mov	r3, r2
  211fa4:	011b      	lsls	r3, r3, #4
  211fa6:	1a9b      	subs	r3, r3, r2
  211fa8:	009b      	lsls	r3, r3, #2
  211faa:	440b      	add	r3, r1
  211fac:	3334      	adds	r3, #52	; 0x34
  211fae:	881b      	ldrh	r3, [r3, #0]
  211fb0:	461c      	mov	r4, r3
  211fb2:	4943      	ldr	r1, [pc, #268]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211fb4:	68fa      	ldr	r2, [r7, #12]
  211fb6:	4613      	mov	r3, r2
  211fb8:	011b      	lsls	r3, r3, #4
  211fba:	1a9b      	subs	r3, r3, r2
  211fbc:	009b      	lsls	r3, r3, #2
  211fbe:	440b      	add	r3, r1
  211fc0:	3332      	adds	r3, #50	; 0x32
  211fc2:	881b      	ldrh	r3, [r3, #0]
  211fc4:	2200      	movs	r2, #0
  211fc6:	9203      	str	r2, [sp, #12]
  211fc8:	9302      	str	r3, [sp, #8]
  211fca:	2300      	movs	r3, #0
  211fcc:	9301      	str	r3, [sp, #4]
  211fce:	9400      	str	r4, [sp, #0]
  211fd0:	4633      	mov	r3, r6
  211fd2:	4a3c      	ldr	r2, [pc, #240]	; (2120c4 <LCD_StrMovVIndirect+0x1294>)
  211fd4:	4601      	mov	r1, r0
  211fd6:	4628      	mov	r0, r5
  211fd8:	f7f5 fe88 	bl	207cec <LCD_CopyBuff2pLcdIndirect>
				switch(F.rotate)
  211fdc:	4938      	ldr	r1, [pc, #224]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211fde:	68fa      	ldr	r2, [r7, #12]
  211fe0:	4613      	mov	r3, r2
  211fe2:	011b      	lsls	r3, r3, #4
  211fe4:	1a9b      	subs	r3, r3, r2
  211fe6:	009b      	lsls	r3, r3, #2
  211fe8:	440b      	add	r3, r1
  211fea:	3314      	adds	r3, #20
  211fec:	781b      	ldrb	r3, [r3, #0]
  211fee:	2b00      	cmp	r3, #0
  211ff0:	d12f      	bne.n	212052 <LCD_StrMovVIndirect+0x1222>
				{	case Rotate_0:
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowWidth, M.windowHeight, pLcd);
  211ff2:	4933      	ldr	r1, [pc, #204]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  211ff4:	68fa      	ldr	r2, [r7, #12]
  211ff6:	4613      	mov	r3, r2
  211ff8:	011b      	lsls	r3, r3, #4
  211ffa:	1a9b      	subs	r3, r3, r2
  211ffc:	009b      	lsls	r3, r3, #2
  211ffe:	440b      	add	r3, r1
  212000:	3302      	adds	r3, #2
  212002:	881b      	ldrh	r3, [r3, #0]
  212004:	4618      	mov	r0, r3
  212006:	492e      	ldr	r1, [pc, #184]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  212008:	68fa      	ldr	r2, [r7, #12]
  21200a:	4613      	mov	r3, r2
  21200c:	011b      	lsls	r3, r3, #4
  21200e:	1a9b      	subs	r3, r3, r2
  212010:	009b      	lsls	r3, r3, #2
  212012:	440b      	add	r3, r1
  212014:	3304      	adds	r3, #4
  212016:	881b      	ldrh	r3, [r3, #0]
  212018:	461c      	mov	r4, r3
  21201a:	4929      	ldr	r1, [pc, #164]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  21201c:	68fa      	ldr	r2, [r7, #12]
  21201e:	4613      	mov	r3, r2
  212020:	011b      	lsls	r3, r3, #4
  212022:	1a9b      	subs	r3, r3, r2
  212024:	009b      	lsls	r3, r3, #2
  212026:	440b      	add	r3, r1
  212028:	3332      	adds	r3, #50	; 0x32
  21202a:	881b      	ldrh	r3, [r3, #0]
  21202c:	461d      	mov	r5, r3
  21202e:	4924      	ldr	r1, [pc, #144]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  212030:	68fa      	ldr	r2, [r7, #12]
  212032:	4613      	mov	r3, r2
  212034:	011b      	lsls	r3, r3, #4
  212036:	1a9b      	subs	r3, r3, r2
  212038:	009b      	lsls	r3, r3, #2
  21203a:	440b      	add	r3, r1
  21203c:	3334      	adds	r3, #52	; 0x34
  21203e:	881b      	ldrh	r3, [r3, #0]
  212040:	461a      	mov	r2, r3
  212042:	4b21      	ldr	r3, [pc, #132]	; (2120c8 <LCD_StrMovVIndirect+0x1298>)
  212044:	9300      	str	r3, [sp, #0]
  212046:	4613      	mov	r3, r2
  212048:	462a      	mov	r2, r5
  21204a:	4621      	mov	r1, r4
  21204c:	f7f5 fd22 	bl	207a94 <LCD_DisplayBuff>
						break;
  212050:	e02f      	b.n	2120b2 <LCD_StrMovVIndirect+0x1282>
					case Rotate_90:
					case Rotate_180:
					default:
						LCD_DisplayBuff((uint32_t)F.xPos,(uint32_t)F.yPos, M.windowHeight, M.windowWidth, pLcd);
  212052:	491b      	ldr	r1, [pc, #108]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  212054:	68fa      	ldr	r2, [r7, #12]
  212056:	4613      	mov	r3, r2
  212058:	011b      	lsls	r3, r3, #4
  21205a:	1a9b      	subs	r3, r3, r2
  21205c:	009b      	lsls	r3, r3, #2
  21205e:	440b      	add	r3, r1
  212060:	3302      	adds	r3, #2
  212062:	881b      	ldrh	r3, [r3, #0]
  212064:	4618      	mov	r0, r3
  212066:	4916      	ldr	r1, [pc, #88]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  212068:	68fa      	ldr	r2, [r7, #12]
  21206a:	4613      	mov	r3, r2
  21206c:	011b      	lsls	r3, r3, #4
  21206e:	1a9b      	subs	r3, r3, r2
  212070:	009b      	lsls	r3, r3, #2
  212072:	440b      	add	r3, r1
  212074:	3304      	adds	r3, #4
  212076:	881b      	ldrh	r3, [r3, #0]
  212078:	461c      	mov	r4, r3
  21207a:	4911      	ldr	r1, [pc, #68]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  21207c:	68fa      	ldr	r2, [r7, #12]
  21207e:	4613      	mov	r3, r2
  212080:	011b      	lsls	r3, r3, #4
  212082:	1a9b      	subs	r3, r3, r2
  212084:	009b      	lsls	r3, r3, #2
  212086:	440b      	add	r3, r1
  212088:	3334      	adds	r3, #52	; 0x34
  21208a:	881b      	ldrh	r3, [r3, #0]
  21208c:	461d      	mov	r5, r3
  21208e:	490c      	ldr	r1, [pc, #48]	; (2120c0 <LCD_StrMovVIndirect+0x1290>)
  212090:	68fa      	ldr	r2, [r7, #12]
  212092:	4613      	mov	r3, r2
  212094:	011b      	lsls	r3, r3, #4
  212096:	1a9b      	subs	r3, r3, r2
  212098:	009b      	lsls	r3, r3, #2
  21209a:	440b      	add	r3, r1
  21209c:	3332      	adds	r3, #50	; 0x32
  21209e:	881b      	ldrh	r3, [r3, #0]
  2120a0:	461a      	mov	r2, r3
  2120a2:	4b09      	ldr	r3, [pc, #36]	; (2120c8 <LCD_StrMovVIndirect+0x1298>)
  2120a4:	9300      	str	r3, [sp, #0]
  2120a6:	4613      	mov	r3, r2
  2120a8:	462a      	mov	r2, r5
  2120aa:	4621      	mov	r1, r4
  2120ac:	f7f5 fcf2 	bl	207a94 <LCD_DisplayBuff>
						break;
  2120b0:	bf00      	nop
				}
				return 1;
  2120b2:	2301      	movs	r3, #1
  2120b4:	e000      	b.n	2120b8 <LCD_StrMovVIndirect+0x1288>
			}
		}
	}
	return 0;
  2120b6:	2300      	movs	r3, #0
}
  2120b8:	4618      	mov	r0, r3
  2120ba:	372c      	adds	r7, #44	; 0x2c
  2120bc:	46bd      	mov	sp, r7
  2120be:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2120c0:	2000f818 	.word	0x2000f818
  2120c4:	c067f800 	.word	0xc067f800
  2120c8:	c0000000 	.word	0xc0000000

002120cc <LCD_GetWholeStrPxlWidth>:

int LCD_GetWholeStrPxlWidth(int fontID, char *txt, int space, int constWidth){
  2120cc:	b590      	push	{r4, r7, lr}
  2120ce:	b089      	sub	sp, #36	; 0x24
  2120d0:	af00      	add	r7, sp, #0
  2120d2:	60f8      	str	r0, [r7, #12]
  2120d4:	60b9      	str	r1, [r7, #8]
  2120d6:	607a      	str	r2, [r7, #4]
  2120d8:	603b      	str	r3, [r7, #0]
	int lenTxtInPixel=0;
  2120da:	2300      	movs	r3, #0
  2120dc:	61fb      	str	r3, [r7, #28]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  2120de:	4a31      	ldr	r2, [pc, #196]	; (2121a4 <LCD_GetWholeStrPxlWidth+0xd8>)
  2120e0:	68fb      	ldr	r3, [r7, #12]
  2120e2:	011b      	lsls	r3, r3, #4
  2120e4:	4413      	add	r3, r2
  2120e6:	681b      	ldr	r3, [r3, #0]
  2120e8:	4618      	mov	r0, r3
  2120ea:	4a2e      	ldr	r2, [pc, #184]	; (2121a4 <LCD_GetWholeStrPxlWidth+0xd8>)
  2120ec:	68fb      	ldr	r3, [r7, #12]
  2120ee:	011b      	lsls	r3, r3, #4
  2120f0:	4413      	add	r3, r2
  2120f2:	3304      	adds	r3, #4
  2120f4:	681b      	ldr	r3, [r3, #0]
  2120f6:	461c      	mov	r4, r3
  2120f8:	4a2a      	ldr	r2, [pc, #168]	; (2121a4 <LCD_GetWholeStrPxlWidth+0xd8>)
  2120fa:	68fb      	ldr	r3, [r7, #12]
  2120fc:	011b      	lsls	r3, r3, #4
  2120fe:	4413      	add	r3, r2
  212100:	3308      	adds	r3, #8
  212102:	6819      	ldr	r1, [r3, #0]
  212104:	4a27      	ldr	r2, [pc, #156]	; (2121a4 <LCD_GetWholeStrPxlWidth+0xd8>)
  212106:	68fb      	ldr	r3, [r7, #12]
  212108:	011b      	lsls	r3, r3, #4
  21210a:	4413      	add	r3, r2
  21210c:	330c      	adds	r3, #12
  21210e:	681b      	ldr	r3, [r3, #0]
  212110:	460a      	mov	r2, r1
  212112:	4621      	mov	r1, r4
  212114:	f7f6 fbb6 	bl	208884 <SearchFontIndex>
  212118:	6178      	str	r0, [r7, #20]
	if(fontIndex==-1)
  21211a:	697b      	ldr	r3, [r7, #20]
  21211c:	f1b3 3fff 	cmp.w	r3, #4294967295
  212120:	d102      	bne.n	212128 <LCD_GetWholeStrPxlWidth+0x5c>
		return -1;
  212122:	f04f 33ff 	mov.w	r3, #4294967295
  212126:	e038      	b.n	21219a <LCD_GetWholeStrPxlWidth+0xce>
	else
	{
		int len=strlen(txt);
  212128:	68b8      	ldr	r0, [r7, #8]
  21212a:	f7ee f889 	bl	200240 <strlen>
  21212e:	4603      	mov	r3, r0
  212130:	613b      	str	r3, [r7, #16]
		if(constWidth)
  212132:	683b      	ldr	r3, [r7, #0]
  212134:	2b00      	cmp	r3, #0
  212136:	d002      	beq.n	21213e <LCD_GetWholeStrPxlWidth+0x72>
			LCD_Set_ConstWidthFonts(fontIndex);
  212138:	6978      	ldr	r0, [r7, #20]
  21213a:	f7f6 fed9 	bl	208ef0 <LCD_Set_ConstWidthFonts>
		for(int i=0;i<len;i++)
  21213e:	2300      	movs	r3, #0
  212140:	61bb      	str	r3, [r7, #24]
  212142:	e01f      	b.n	212184 <LCD_GetWholeStrPxlWidth+0xb8>
			lenTxtInPixel += Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,fontID);
  212144:	69bb      	ldr	r3, [r7, #24]
  212146:	68ba      	ldr	r2, [r7, #8]
  212148:	4413      	add	r3, r2
  21214a:	781b      	ldrb	r3, [r3, #0]
  21214c:	4618      	mov	r0, r3
  21214e:	4916      	ldr	r1, [pc, #88]	; (2121a8 <LCD_GetWholeStrPxlWidth+0xdc>)
  212150:	697a      	ldr	r2, [r7, #20]
  212152:	4613      	mov	r3, r2
  212154:	019b      	lsls	r3, r3, #6
  212156:	4413      	add	r3, r2
  212158:	009b      	lsls	r3, r3, #2
  21215a:	4403      	add	r3, r0
  21215c:	00db      	lsls	r3, r3, #3
  21215e:	440b      	add	r3, r1
  212160:	695a      	ldr	r2, [r3, #20]
  212162:	687b      	ldr	r3, [r7, #4]
  212164:	18d4      	adds	r4, r2, r3
  212166:	69bb      	ldr	r3, [r7, #24]
  212168:	68ba      	ldr	r2, [r7, #8]
  21216a:	4413      	add	r3, r2
  21216c:	68f9      	ldr	r1, [r7, #12]
  21216e:	4618      	mov	r0, r3
  212170:	f7f5 ff76 	bl	208060 <RealizeSpaceCorrect>
  212174:	4603      	mov	r3, r0
  212176:	4423      	add	r3, r4
  212178:	69fa      	ldr	r2, [r7, #28]
  21217a:	4413      	add	r3, r2
  21217c:	61fb      	str	r3, [r7, #28]
		for(int i=0;i<len;i++)
  21217e:	69bb      	ldr	r3, [r7, #24]
  212180:	3301      	adds	r3, #1
  212182:	61bb      	str	r3, [r7, #24]
  212184:	69ba      	ldr	r2, [r7, #24]
  212186:	693b      	ldr	r3, [r7, #16]
  212188:	429a      	cmp	r2, r3
  21218a:	dbdb      	blt.n	212144 <LCD_GetWholeStrPxlWidth+0x78>
		if(constWidth)
  21218c:	683b      	ldr	r3, [r7, #0]
  21218e:	2b00      	cmp	r3, #0
  212190:	d002      	beq.n	212198 <LCD_GetWholeStrPxlWidth+0xcc>
			LCD_Reset_ConstWidthFonts(fontIndex);
  212192:	6978      	ldr	r0, [r7, #20]
  212194:	f7f6 ffaa 	bl	2090ec <LCD_Reset_ConstWidthFonts>
		return lenTxtInPixel;
  212198:	69fb      	ldr	r3, [r7, #28]
	}
}
  21219a:	4618      	mov	r0, r3
  21219c:	3724      	adds	r7, #36	; 0x24
  21219e:	46bd      	mov	sp, r7
  2121a0:	bd90      	pop	{r4, r7, pc}
  2121a2:	bf00      	nop
  2121a4:	20003480 	.word	0x20003480
  2121a8:	20003590 	.word	0x20003590

002121ac <LCD_GetStrPxlWidth>:
int LCD_GetStrPxlWidth(int fontID, char *txt, int len, int space, int constWidth){
  2121ac:	b590      	push	{r4, r7, lr}
  2121ae:	b089      	sub	sp, #36	; 0x24
  2121b0:	af00      	add	r7, sp, #0
  2121b2:	60f8      	str	r0, [r7, #12]
  2121b4:	60b9      	str	r1, [r7, #8]
  2121b6:	607a      	str	r2, [r7, #4]
  2121b8:	603b      	str	r3, [r7, #0]
	int lenTxtInPixel=0;
  2121ba:	2300      	movs	r3, #0
  2121bc:	61fb      	str	r3, [r7, #28]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  2121be:	4a2e      	ldr	r2, [pc, #184]	; (212278 <LCD_GetStrPxlWidth+0xcc>)
  2121c0:	68fb      	ldr	r3, [r7, #12]
  2121c2:	011b      	lsls	r3, r3, #4
  2121c4:	4413      	add	r3, r2
  2121c6:	681b      	ldr	r3, [r3, #0]
  2121c8:	4618      	mov	r0, r3
  2121ca:	4a2b      	ldr	r2, [pc, #172]	; (212278 <LCD_GetStrPxlWidth+0xcc>)
  2121cc:	68fb      	ldr	r3, [r7, #12]
  2121ce:	011b      	lsls	r3, r3, #4
  2121d0:	4413      	add	r3, r2
  2121d2:	3304      	adds	r3, #4
  2121d4:	681b      	ldr	r3, [r3, #0]
  2121d6:	461c      	mov	r4, r3
  2121d8:	4a27      	ldr	r2, [pc, #156]	; (212278 <LCD_GetStrPxlWidth+0xcc>)
  2121da:	68fb      	ldr	r3, [r7, #12]
  2121dc:	011b      	lsls	r3, r3, #4
  2121de:	4413      	add	r3, r2
  2121e0:	3308      	adds	r3, #8
  2121e2:	6819      	ldr	r1, [r3, #0]
  2121e4:	4a24      	ldr	r2, [pc, #144]	; (212278 <LCD_GetStrPxlWidth+0xcc>)
  2121e6:	68fb      	ldr	r3, [r7, #12]
  2121e8:	011b      	lsls	r3, r3, #4
  2121ea:	4413      	add	r3, r2
  2121ec:	330c      	adds	r3, #12
  2121ee:	681b      	ldr	r3, [r3, #0]
  2121f0:	460a      	mov	r2, r1
  2121f2:	4621      	mov	r1, r4
  2121f4:	f7f6 fb46 	bl	208884 <SearchFontIndex>
  2121f8:	6178      	str	r0, [r7, #20]
	if(fontIndex==-1)
  2121fa:	697b      	ldr	r3, [r7, #20]
  2121fc:	f1b3 3fff 	cmp.w	r3, #4294967295
  212200:	d102      	bne.n	212208 <LCD_GetStrPxlWidth+0x5c>
		return -1;
  212202:	f04f 33ff 	mov.w	r3, #4294967295
  212206:	e033      	b.n	212270 <LCD_GetStrPxlWidth+0xc4>
	else
	{
		if(constWidth)
  212208:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  21220a:	2b00      	cmp	r3, #0
  21220c:	d002      	beq.n	212214 <LCD_GetStrPxlWidth+0x68>
			LCD_Set_ConstWidthFonts(fontIndex);
  21220e:	6978      	ldr	r0, [r7, #20]
  212210:	f7f6 fe6e 	bl	208ef0 <LCD_Set_ConstWidthFonts>
		for(int i=0;i<len;i++)
  212214:	2300      	movs	r3, #0
  212216:	61bb      	str	r3, [r7, #24]
  212218:	e01f      	b.n	21225a <LCD_GetStrPxlWidth+0xae>
			lenTxtInPixel += Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,fontID);
  21221a:	69bb      	ldr	r3, [r7, #24]
  21221c:	68ba      	ldr	r2, [r7, #8]
  21221e:	4413      	add	r3, r2
  212220:	781b      	ldrb	r3, [r3, #0]
  212222:	4618      	mov	r0, r3
  212224:	4915      	ldr	r1, [pc, #84]	; (21227c <LCD_GetStrPxlWidth+0xd0>)
  212226:	697a      	ldr	r2, [r7, #20]
  212228:	4613      	mov	r3, r2
  21222a:	019b      	lsls	r3, r3, #6
  21222c:	4413      	add	r3, r2
  21222e:	009b      	lsls	r3, r3, #2
  212230:	4403      	add	r3, r0
  212232:	00db      	lsls	r3, r3, #3
  212234:	440b      	add	r3, r1
  212236:	695a      	ldr	r2, [r3, #20]
  212238:	683b      	ldr	r3, [r7, #0]
  21223a:	18d4      	adds	r4, r2, r3
  21223c:	69bb      	ldr	r3, [r7, #24]
  21223e:	68ba      	ldr	r2, [r7, #8]
  212240:	4413      	add	r3, r2
  212242:	68f9      	ldr	r1, [r7, #12]
  212244:	4618      	mov	r0, r3
  212246:	f7f5 ff0b 	bl	208060 <RealizeSpaceCorrect>
  21224a:	4603      	mov	r3, r0
  21224c:	4423      	add	r3, r4
  21224e:	69fa      	ldr	r2, [r7, #28]
  212250:	4413      	add	r3, r2
  212252:	61fb      	str	r3, [r7, #28]
		for(int i=0;i<len;i++)
  212254:	69bb      	ldr	r3, [r7, #24]
  212256:	3301      	adds	r3, #1
  212258:	61bb      	str	r3, [r7, #24]
  21225a:	69ba      	ldr	r2, [r7, #24]
  21225c:	687b      	ldr	r3, [r7, #4]
  21225e:	429a      	cmp	r2, r3
  212260:	dbdb      	blt.n	21221a <LCD_GetStrPxlWidth+0x6e>
		if(constWidth)
  212262:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  212264:	2b00      	cmp	r3, #0
  212266:	d002      	beq.n	21226e <LCD_GetStrPxlWidth+0xc2>
			LCD_Reset_ConstWidthFonts(fontIndex);
  212268:	6978      	ldr	r0, [r7, #20]
  21226a:	f7f6 ff3f 	bl	2090ec <LCD_Reset_ConstWidthFonts>
		return lenTxtInPixel;
  21226e:	69fb      	ldr	r3, [r7, #28]
	}
}
  212270:	4618      	mov	r0, r3
  212272:	3724      	adds	r7, #36	; 0x24
  212274:	46bd      	mov	sp, r7
  212276:	bd90      	pop	{r4, r7, pc}
  212278:	20003480 	.word	0x20003480
  21227c:	20003590 	.word	0x20003590

00212280 <LCD_GetStrLenForPxlWidth>:
int LCD_GetStrLenForPxlWidth(int fontID, char *txt, int lenInPxl, int space, int constWidth){
  212280:	b590      	push	{r4, r7, lr}
  212282:	b08b      	sub	sp, #44	; 0x2c
  212284:	af00      	add	r7, sp, #0
  212286:	60f8      	str	r0, [r7, #12]
  212288:	60b9      	str	r1, [r7, #8]
  21228a:	607a      	str	r2, [r7, #4]
  21228c:	603b      	str	r3, [r7, #0]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  21228e:	4a38      	ldr	r2, [pc, #224]	; (212370 <LCD_GetStrLenForPxlWidth+0xf0>)
  212290:	68fb      	ldr	r3, [r7, #12]
  212292:	011b      	lsls	r3, r3, #4
  212294:	4413      	add	r3, r2
  212296:	681b      	ldr	r3, [r3, #0]
  212298:	4618      	mov	r0, r3
  21229a:	4a35      	ldr	r2, [pc, #212]	; (212370 <LCD_GetStrLenForPxlWidth+0xf0>)
  21229c:	68fb      	ldr	r3, [r7, #12]
  21229e:	011b      	lsls	r3, r3, #4
  2122a0:	4413      	add	r3, r2
  2122a2:	3304      	adds	r3, #4
  2122a4:	681b      	ldr	r3, [r3, #0]
  2122a6:	461c      	mov	r4, r3
  2122a8:	4a31      	ldr	r2, [pc, #196]	; (212370 <LCD_GetStrLenForPxlWidth+0xf0>)
  2122aa:	68fb      	ldr	r3, [r7, #12]
  2122ac:	011b      	lsls	r3, r3, #4
  2122ae:	4413      	add	r3, r2
  2122b0:	3308      	adds	r3, #8
  2122b2:	6819      	ldr	r1, [r3, #0]
  2122b4:	4a2e      	ldr	r2, [pc, #184]	; (212370 <LCD_GetStrLenForPxlWidth+0xf0>)
  2122b6:	68fb      	ldr	r3, [r7, #12]
  2122b8:	011b      	lsls	r3, r3, #4
  2122ba:	4413      	add	r3, r2
  2122bc:	330c      	adds	r3, #12
  2122be:	681b      	ldr	r3, [r3, #0]
  2122c0:	460a      	mov	r2, r1
  2122c2:	4621      	mov	r1, r4
  2122c4:	f7f6 fade 	bl	208884 <SearchFontIndex>
  2122c8:	61f8      	str	r0, [r7, #28]
	if(fontIndex==-1)
  2122ca:	69fb      	ldr	r3, [r7, #28]
  2122cc:	f1b3 3fff 	cmp.w	r3, #4294967295
  2122d0:	d102      	bne.n	2122d8 <LCD_GetStrLenForPxlWidth+0x58>
		return -1;
  2122d2:	f04f 33ff 	mov.w	r3, #4294967295
  2122d6:	e046      	b.n	212366 <LCD_GetStrLenForPxlWidth+0xe6>
	else
	{
		int i,lenTxtInPixel=0;
  2122d8:	2300      	movs	r3, #0
  2122da:	623b      	str	r3, [r7, #32]
		int len=0,m=strlen(txt);
  2122dc:	2300      	movs	r3, #0
  2122de:	61bb      	str	r3, [r7, #24]
  2122e0:	68b8      	ldr	r0, [r7, #8]
  2122e2:	f7ed ffad 	bl	200240 <strlen>
  2122e6:	4603      	mov	r3, r0
  2122e8:	617b      	str	r3, [r7, #20]

		if(constWidth)
  2122ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2122ec:	2b00      	cmp	r3, #0
  2122ee:	d002      	beq.n	2122f6 <LCD_GetStrLenForPxlWidth+0x76>
			LCD_Set_ConstWidthFonts(fontIndex);
  2122f0:	69f8      	ldr	r0, [r7, #28]
  2122f2:	f7f6 fdfd 	bl	208ef0 <LCD_Set_ConstWidthFonts>
		for(i=0;i<m;i++)
  2122f6:	2300      	movs	r3, #0
  2122f8:	627b      	str	r3, [r7, #36]	; 0x24
  2122fa:	e027      	b.n	21234c <LCD_GetStrLenForPxlWidth+0xcc>
		{	len=Font[fontIndex].fontsTabPos[ (int)txt[i] ][1] + space + RealizeSpaceCorrect(txt+i,fontID);
  2122fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2122fe:	68ba      	ldr	r2, [r7, #8]
  212300:	4413      	add	r3, r2
  212302:	781b      	ldrb	r3, [r3, #0]
  212304:	4618      	mov	r0, r3
  212306:	491b      	ldr	r1, [pc, #108]	; (212374 <LCD_GetStrLenForPxlWidth+0xf4>)
  212308:	69fa      	ldr	r2, [r7, #28]
  21230a:	4613      	mov	r3, r2
  21230c:	019b      	lsls	r3, r3, #6
  21230e:	4413      	add	r3, r2
  212310:	009b      	lsls	r3, r3, #2
  212312:	4403      	add	r3, r0
  212314:	00db      	lsls	r3, r3, #3
  212316:	440b      	add	r3, r1
  212318:	695a      	ldr	r2, [r3, #20]
  21231a:	683b      	ldr	r3, [r7, #0]
  21231c:	18d4      	adds	r4, r2, r3
  21231e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  212320:	68ba      	ldr	r2, [r7, #8]
  212322:	4413      	add	r3, r2
  212324:	68f9      	ldr	r1, [r7, #12]
  212326:	4618      	mov	r0, r3
  212328:	f7f5 fe9a 	bl	208060 <RealizeSpaceCorrect>
  21232c:	4603      	mov	r3, r0
  21232e:	4423      	add	r3, r4
  212330:	61bb      	str	r3, [r7, #24]
			if(lenTxtInPixel+len>lenInPxl) break;
  212332:	6a3a      	ldr	r2, [r7, #32]
  212334:	69bb      	ldr	r3, [r7, #24]
  212336:	441a      	add	r2, r3
  212338:	687b      	ldr	r3, [r7, #4]
  21233a:	429a      	cmp	r2, r3
  21233c:	dc0b      	bgt.n	212356 <LCD_GetStrLenForPxlWidth+0xd6>
			lenTxtInPixel += len;
  21233e:	6a3a      	ldr	r2, [r7, #32]
  212340:	69bb      	ldr	r3, [r7, #24]
  212342:	4413      	add	r3, r2
  212344:	623b      	str	r3, [r7, #32]
		for(i=0;i<m;i++)
  212346:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  212348:	3301      	adds	r3, #1
  21234a:	627b      	str	r3, [r7, #36]	; 0x24
  21234c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  21234e:	697b      	ldr	r3, [r7, #20]
  212350:	429a      	cmp	r2, r3
  212352:	dbd3      	blt.n	2122fc <LCD_GetStrLenForPxlWidth+0x7c>
  212354:	e000      	b.n	212358 <LCD_GetStrLenForPxlWidth+0xd8>
			if(lenTxtInPixel+len>lenInPxl) break;
  212356:	bf00      	nop
		}
		if(constWidth)
  212358:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  21235a:	2b00      	cmp	r3, #0
  21235c:	d002      	beq.n	212364 <LCD_GetStrLenForPxlWidth+0xe4>
			LCD_Reset_ConstWidthFonts(fontIndex);
  21235e:	69f8      	ldr	r0, [r7, #28]
  212360:	f7f6 fec4 	bl	2090ec <LCD_Reset_ConstWidthFonts>

		return i;
  212364:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
}
  212366:	4618      	mov	r0, r3
  212368:	372c      	adds	r7, #44	; 0x2c
  21236a:	46bd      	mov	sp, r7
  21236c:	bd90      	pop	{r4, r7, pc}
  21236e:	bf00      	nop
  212370:	20003480 	.word	0x20003480
  212374:	20003590 	.word	0x20003590

00212378 <LCD_GetFontWidth>:

int LCD_GetFontWidth(int fontID, char font){
  212378:	b590      	push	{r4, r7, lr}
  21237a:	b085      	sub	sp, #20
  21237c:	af00      	add	r7, sp, #0
  21237e:	6078      	str	r0, [r7, #4]
  212380:	460b      	mov	r3, r1
  212382:	70fb      	strb	r3, [r7, #3]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  212384:	4a19      	ldr	r2, [pc, #100]	; (2123ec <LCD_GetFontWidth+0x74>)
  212386:	687b      	ldr	r3, [r7, #4]
  212388:	011b      	lsls	r3, r3, #4
  21238a:	4413      	add	r3, r2
  21238c:	681b      	ldr	r3, [r3, #0]
  21238e:	4618      	mov	r0, r3
  212390:	4a16      	ldr	r2, [pc, #88]	; (2123ec <LCD_GetFontWidth+0x74>)
  212392:	687b      	ldr	r3, [r7, #4]
  212394:	011b      	lsls	r3, r3, #4
  212396:	4413      	add	r3, r2
  212398:	3304      	adds	r3, #4
  21239a:	681b      	ldr	r3, [r3, #0]
  21239c:	461c      	mov	r4, r3
  21239e:	4a13      	ldr	r2, [pc, #76]	; (2123ec <LCD_GetFontWidth+0x74>)
  2123a0:	687b      	ldr	r3, [r7, #4]
  2123a2:	011b      	lsls	r3, r3, #4
  2123a4:	4413      	add	r3, r2
  2123a6:	3308      	adds	r3, #8
  2123a8:	6819      	ldr	r1, [r3, #0]
  2123aa:	4a10      	ldr	r2, [pc, #64]	; (2123ec <LCD_GetFontWidth+0x74>)
  2123ac:	687b      	ldr	r3, [r7, #4]
  2123ae:	011b      	lsls	r3, r3, #4
  2123b0:	4413      	add	r3, r2
  2123b2:	330c      	adds	r3, #12
  2123b4:	681b      	ldr	r3, [r3, #0]
  2123b6:	460a      	mov	r2, r1
  2123b8:	4621      	mov	r1, r4
  2123ba:	f7f6 fa63 	bl	208884 <SearchFontIndex>
  2123be:	60f8      	str	r0, [r7, #12]
	if(fontIndex==-1)
  2123c0:	68fb      	ldr	r3, [r7, #12]
  2123c2:	f1b3 3fff 	cmp.w	r3, #4294967295
  2123c6:	d102      	bne.n	2123ce <LCD_GetFontWidth+0x56>
		return -1;
  2123c8:	f04f 33ff 	mov.w	r3, #4294967295
  2123cc:	e00a      	b.n	2123e4 <LCD_GetFontWidth+0x6c>
	else
		return Font[fontIndex].fontsTabPos[ (int)font ][1];
  2123ce:	78f9      	ldrb	r1, [r7, #3]
  2123d0:	4807      	ldr	r0, [pc, #28]	; (2123f0 <LCD_GetFontWidth+0x78>)
  2123d2:	68fa      	ldr	r2, [r7, #12]
  2123d4:	4613      	mov	r3, r2
  2123d6:	019b      	lsls	r3, r3, #6
  2123d8:	4413      	add	r3, r2
  2123da:	009b      	lsls	r3, r3, #2
  2123dc:	440b      	add	r3, r1
  2123de:	00db      	lsls	r3, r3, #3
  2123e0:	4403      	add	r3, r0
  2123e2:	695b      	ldr	r3, [r3, #20]
}
  2123e4:	4618      	mov	r0, r3
  2123e6:	3714      	adds	r7, #20
  2123e8:	46bd      	mov	sp, r7
  2123ea:	bd90      	pop	{r4, r7, pc}
  2123ec:	20003480 	.word	0x20003480
  2123f0:	20003590 	.word	0x20003590

002123f4 <LCD_GetFontHeight>:

int LCD_GetFontHeight(int fontID)
{
  2123f4:	b590      	push	{r4, r7, lr}
  2123f6:	b085      	sub	sp, #20
  2123f8:	af00      	add	r7, sp, #0
  2123fa:	6078      	str	r0, [r7, #4]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  2123fc:	4a19      	ldr	r2, [pc, #100]	; (212464 <LCD_GetFontHeight+0x70>)
  2123fe:	687b      	ldr	r3, [r7, #4]
  212400:	011b      	lsls	r3, r3, #4
  212402:	4413      	add	r3, r2
  212404:	681b      	ldr	r3, [r3, #0]
  212406:	4618      	mov	r0, r3
  212408:	4a16      	ldr	r2, [pc, #88]	; (212464 <LCD_GetFontHeight+0x70>)
  21240a:	687b      	ldr	r3, [r7, #4]
  21240c:	011b      	lsls	r3, r3, #4
  21240e:	4413      	add	r3, r2
  212410:	3304      	adds	r3, #4
  212412:	681b      	ldr	r3, [r3, #0]
  212414:	461c      	mov	r4, r3
  212416:	4a13      	ldr	r2, [pc, #76]	; (212464 <LCD_GetFontHeight+0x70>)
  212418:	687b      	ldr	r3, [r7, #4]
  21241a:	011b      	lsls	r3, r3, #4
  21241c:	4413      	add	r3, r2
  21241e:	3308      	adds	r3, #8
  212420:	6819      	ldr	r1, [r3, #0]
  212422:	4a10      	ldr	r2, [pc, #64]	; (212464 <LCD_GetFontHeight+0x70>)
  212424:	687b      	ldr	r3, [r7, #4]
  212426:	011b      	lsls	r3, r3, #4
  212428:	4413      	add	r3, r2
  21242a:	330c      	adds	r3, #12
  21242c:	681b      	ldr	r3, [r3, #0]
  21242e:	460a      	mov	r2, r1
  212430:	4621      	mov	r1, r4
  212432:	f7f6 fa27 	bl	208884 <SearchFontIndex>
  212436:	60f8      	str	r0, [r7, #12]
	if(fontIndex==-1)
  212438:	68fb      	ldr	r3, [r7, #12]
  21243a:	f1b3 3fff 	cmp.w	r3, #4294967295
  21243e:	d102      	bne.n	212446 <LCD_GetFontHeight+0x52>
		return -1;
  212440:	f04f 33ff 	mov.w	r3, #4294967295
  212444:	e009      	b.n	21245a <LCD_GetFontHeight+0x66>
	else
		return Font[fontIndex].height;
  212446:	4908      	ldr	r1, [pc, #32]	; (212468 <LCD_GetFontHeight+0x74>)
  212448:	68fa      	ldr	r2, [r7, #12]
  21244a:	4613      	mov	r3, r2
  21244c:	019b      	lsls	r3, r3, #6
  21244e:	4413      	add	r3, r2
  212450:	015b      	lsls	r3, r3, #5
  212452:	440b      	add	r3, r1
  212454:	f503 6301 	add.w	r3, r3, #2064	; 0x810
  212458:	681b      	ldr	r3, [r3, #0]
}
  21245a:	4618      	mov	r0, r3
  21245c:	3714      	adds	r7, #20
  21245e:	46bd      	mov	sp, r7
  212460:	bd90      	pop	{r4, r7, pc}
  212462:	bf00      	nop
  212464:	20003480 	.word	0x20003480
  212468:	20003590 	.word	0x20003590

0021246c <LCD_GetFontHalfHeight>:

int LCD_GetFontHalfHeight(int fontID)
{
  21246c:	b590      	push	{r4, r7, lr}
  21246e:	b085      	sub	sp, #20
  212470:	af00      	add	r7, sp, #0
  212472:	6078      	str	r0, [r7, #4]
	int fontIndex=SearchFontIndex(FontID[fontID].size, FontID[fontID].style, FontID[fontID].bkColor, FontID[fontID].color);
  212474:	4a19      	ldr	r2, [pc, #100]	; (2124dc <LCD_GetFontHalfHeight+0x70>)
  212476:	687b      	ldr	r3, [r7, #4]
  212478:	011b      	lsls	r3, r3, #4
  21247a:	4413      	add	r3, r2
  21247c:	681b      	ldr	r3, [r3, #0]
  21247e:	4618      	mov	r0, r3
  212480:	4a16      	ldr	r2, [pc, #88]	; (2124dc <LCD_GetFontHalfHeight+0x70>)
  212482:	687b      	ldr	r3, [r7, #4]
  212484:	011b      	lsls	r3, r3, #4
  212486:	4413      	add	r3, r2
  212488:	3304      	adds	r3, #4
  21248a:	681b      	ldr	r3, [r3, #0]
  21248c:	461c      	mov	r4, r3
  21248e:	4a13      	ldr	r2, [pc, #76]	; (2124dc <LCD_GetFontHalfHeight+0x70>)
  212490:	687b      	ldr	r3, [r7, #4]
  212492:	011b      	lsls	r3, r3, #4
  212494:	4413      	add	r3, r2
  212496:	3308      	adds	r3, #8
  212498:	6819      	ldr	r1, [r3, #0]
  21249a:	4a10      	ldr	r2, [pc, #64]	; (2124dc <LCD_GetFontHalfHeight+0x70>)
  21249c:	687b      	ldr	r3, [r7, #4]
  21249e:	011b      	lsls	r3, r3, #4
  2124a0:	4413      	add	r3, r2
  2124a2:	330c      	adds	r3, #12
  2124a4:	681b      	ldr	r3, [r3, #0]
  2124a6:	460a      	mov	r2, r1
  2124a8:	4621      	mov	r1, r4
  2124aa:	f7f6 f9eb 	bl	208884 <SearchFontIndex>
  2124ae:	60f8      	str	r0, [r7, #12]
	if(fontIndex==-1)
  2124b0:	68fb      	ldr	r3, [r7, #12]
  2124b2:	f1b3 3fff 	cmp.w	r3, #4294967295
  2124b6:	d102      	bne.n	2124be <LCD_GetFontHalfHeight+0x52>
		return -1;
  2124b8:	f04f 33ff 	mov.w	r3, #4294967295
  2124bc:	e009      	b.n	2124d2 <LCD_GetFontHalfHeight+0x66>
	else
		return Font[fontIndex].heightHalf;
  2124be:	4908      	ldr	r1, [pc, #32]	; (2124e0 <LCD_GetFontHalfHeight+0x74>)
  2124c0:	68fa      	ldr	r2, [r7, #12]
  2124c2:	4613      	mov	r3, r2
  2124c4:	019b      	lsls	r3, r3, #6
  2124c6:	4413      	add	r3, r2
  2124c8:	015b      	lsls	r3, r3, #5
  2124ca:	440b      	add	r3, r1
  2124cc:	f603 0314 	addw	r3, r3, #2068	; 0x814
  2124d0:	681b      	ldr	r3, [r3, #0]
}
  2124d2:	4618      	mov	r0, r3
  2124d4:	3714      	adds	r7, #20
  2124d6:	46bd      	mov	sp, r7
  2124d8:	bd90      	pop	{r4, r7, pc}
  2124da:	bf00      	nop
  2124dc:	20003480 	.word	0x20003480
  2124e0:	20003590 	.word	0x20003590

002124e4 <CopyCharsTab>:

int CopyCharsTab(char *buf, int len, int offset, int fontSize)
{
  2124e4:	b580      	push	{r7, lr}
  2124e6:	b088      	sub	sp, #32
  2124e8:	af00      	add	r7, sp, #0
  2124ea:	60f8      	str	r0, [r7, #12]
  2124ec:	60b9      	str	r1, [r7, #8]
  2124ee:	607a      	str	r2, [r7, #4]
  2124f0:	603b      	str	r3, [r7, #0]
	const char *pChar;
	int i,j, lenChars;

	switch(fontSize)
  2124f2:	683b      	ldr	r3, [r7, #0]
  2124f4:	3b2d      	subs	r3, #45	; 0x2d
  2124f6:	2b05      	cmp	r3, #5
  2124f8:	d802      	bhi.n	212500 <CopyCharsTab+0x1c>
	case FONT_72_bold:
	case FONT_72_italics:
	case FONT_130:
	case FONT_130_bold:
	case FONT_130_italics:
		pChar=CharsTab_digits;
  2124fa:	4b1b      	ldr	r3, [pc, #108]	; (212568 <CopyCharsTab+0x84>)
  2124fc:	61fb      	str	r3, [r7, #28]
		break;
  2124fe:	e002      	b.n	212506 <CopyCharsTab+0x22>
	default:
		pChar=CharsTab_full;
  212500:	4b1a      	ldr	r3, [pc, #104]	; (21256c <CopyCharsTab+0x88>)
  212502:	61fb      	str	r3, [r7, #28]
		break;
  212504:	bf00      	nop
	}

	lenChars=strlen(pChar);
  212506:	69f8      	ldr	r0, [r7, #28]
  212508:	f7ed fe9a 	bl	200240 <strlen>
  21250c:	4603      	mov	r3, r0
  21250e:	617b      	str	r3, [r7, #20]
	for(i=0;i<len;++i)
  212510:	2300      	movs	r3, #0
  212512:	61bb      	str	r3, [r7, #24]
  212514:	e012      	b.n	21253c <CopyCharsTab+0x58>
	{
		j=offset+i;
  212516:	687a      	ldr	r2, [r7, #4]
  212518:	69bb      	ldr	r3, [r7, #24]
  21251a:	4413      	add	r3, r2
  21251c:	613b      	str	r3, [r7, #16]
		if(j<lenChars)
  21251e:	693a      	ldr	r2, [r7, #16]
  212520:	697b      	ldr	r3, [r7, #20]
  212522:	429a      	cmp	r2, r3
  212524:	da0f      	bge.n	212546 <CopyCharsTab+0x62>
			buf[i]=pChar[j];
  212526:	69bb      	ldr	r3, [r7, #24]
  212528:	68fa      	ldr	r2, [r7, #12]
  21252a:	4413      	add	r3, r2
  21252c:	693a      	ldr	r2, [r7, #16]
  21252e:	69f9      	ldr	r1, [r7, #28]
  212530:	440a      	add	r2, r1
  212532:	7812      	ldrb	r2, [r2, #0]
  212534:	701a      	strb	r2, [r3, #0]
	for(i=0;i<len;++i)
  212536:	69bb      	ldr	r3, [r7, #24]
  212538:	3301      	adds	r3, #1
  21253a:	61bb      	str	r3, [r7, #24]
  21253c:	69ba      	ldr	r2, [r7, #24]
  21253e:	68bb      	ldr	r3, [r7, #8]
  212540:	429a      	cmp	r2, r3
  212542:	dbe8      	blt.n	212516 <CopyCharsTab+0x32>
  212544:	e000      	b.n	212548 <CopyCharsTab+0x64>
		else
			break;
  212546:	bf00      	nop
	}
	buf[i]=0;
  212548:	69bb      	ldr	r3, [r7, #24]
  21254a:	68fa      	ldr	r2, [r7, #12]
  21254c:	4413      	add	r3, r2
  21254e:	2200      	movs	r2, #0
  212550:	701a      	strb	r2, [r3, #0]

	if(i==len)
  212552:	69ba      	ldr	r2, [r7, #24]
  212554:	68bb      	ldr	r3, [r7, #8]
  212556:	429a      	cmp	r2, r3
  212558:	d101      	bne.n	21255e <CopyCharsTab+0x7a>
		return 0;
  21255a:	2300      	movs	r3, #0
  21255c:	e000      	b.n	212560 <CopyCharsTab+0x7c>
	else
		return 1;
  21255e:	2301      	movs	r3, #1
}
  212560:	4618      	mov	r0, r3
  212562:	3720      	adds	r7, #32
  212564:	46bd      	mov	sp, r7
  212566:	bd80      	pop	{r7, pc}
  212568:	00229310 	.word	0x00229310
  21256c:	002292a0 	.word	0x002292a0

00212570 <LCD_SelectedSpaceBetweenFontsIncrDecr>:

int LCD_SelectedSpaceBetweenFontsIncrDecr(uint8_t incrDecr, uint8_t fontStyle, uint8_t fontSize, char char1, char char2)
{
  212570:	b490      	push	{r4, r7}
  212572:	b084      	sub	sp, #16
  212574:	af00      	add	r7, sp, #0
  212576:	4604      	mov	r4, r0
  212578:	4608      	mov	r0, r1
  21257a:	4611      	mov	r1, r2
  21257c:	461a      	mov	r2, r3
  21257e:	4623      	mov	r3, r4
  212580:	71fb      	strb	r3, [r7, #7]
  212582:	4603      	mov	r3, r0
  212584:	71bb      	strb	r3, [r7, #6]
  212586:	460b      	mov	r3, r1
  212588:	717b      	strb	r3, [r7, #5]
  21258a:	4613      	mov	r3, r2
  21258c:	713b      	strb	r3, [r7, #4]
	for(int i=0;i<StructSpaceCount;i++)
  21258e:	2300      	movs	r3, #0
  212590:	60fb      	str	r3, [r7, #12]
  212592:	e07e      	b.n	212692 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x122>
	{
		if((fontStyle==space[i].fontStyle)&&(fontSize==space[i].fontSize)&&(char1==space[i].char1)&&(char2==space[i].char2))
  212594:	498d      	ldr	r1, [pc, #564]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212596:	68fa      	ldr	r2, [r7, #12]
  212598:	4613      	mov	r3, r2
  21259a:	009b      	lsls	r3, r3, #2
  21259c:	4413      	add	r3, r2
  21259e:	440b      	add	r3, r1
  2125a0:	781b      	ldrb	r3, [r3, #0]
  2125a2:	79ba      	ldrb	r2, [r7, #6]
  2125a4:	429a      	cmp	r2, r3
  2125a6:	d171      	bne.n	21268c <LCD_SelectedSpaceBetweenFontsIncrDecr+0x11c>
  2125a8:	4988      	ldr	r1, [pc, #544]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2125aa:	68fa      	ldr	r2, [r7, #12]
  2125ac:	4613      	mov	r3, r2
  2125ae:	009b      	lsls	r3, r3, #2
  2125b0:	4413      	add	r3, r2
  2125b2:	440b      	add	r3, r1
  2125b4:	3301      	adds	r3, #1
  2125b6:	781b      	ldrb	r3, [r3, #0]
  2125b8:	797a      	ldrb	r2, [r7, #5]
  2125ba:	429a      	cmp	r2, r3
  2125bc:	d166      	bne.n	21268c <LCD_SelectedSpaceBetweenFontsIncrDecr+0x11c>
  2125be:	4983      	ldr	r1, [pc, #524]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2125c0:	68fa      	ldr	r2, [r7, #12]
  2125c2:	4613      	mov	r3, r2
  2125c4:	009b      	lsls	r3, r3, #2
  2125c6:	4413      	add	r3, r2
  2125c8:	440b      	add	r3, r1
  2125ca:	3302      	adds	r3, #2
  2125cc:	781b      	ldrb	r3, [r3, #0]
  2125ce:	793a      	ldrb	r2, [r7, #4]
  2125d0:	429a      	cmp	r2, r3
  2125d2:	d15b      	bne.n	21268c <LCD_SelectedSpaceBetweenFontsIncrDecr+0x11c>
  2125d4:	497d      	ldr	r1, [pc, #500]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2125d6:	68fa      	ldr	r2, [r7, #12]
  2125d8:	4613      	mov	r3, r2
  2125da:	009b      	lsls	r3, r3, #2
  2125dc:	4413      	add	r3, r2
  2125de:	440b      	add	r3, r1
  2125e0:	3303      	adds	r3, #3
  2125e2:	781b      	ldrb	r3, [r3, #0]
  2125e4:	7e3a      	ldrb	r2, [r7, #24]
  2125e6:	429a      	cmp	r2, r3
  2125e8:	d150      	bne.n	21268c <LCD_SelectedSpaceBetweenFontsIncrDecr+0x11c>
		{
			if(incrDecr){
  2125ea:	79fb      	ldrb	r3, [r7, #7]
  2125ec:	2b00      	cmp	r3, #0
  2125ee:	d021      	beq.n	212634 <LCD_SelectedSpaceBetweenFontsIncrDecr+0xc4>
				if(space[i].val<127)
  2125f0:	4976      	ldr	r1, [pc, #472]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2125f2:	68fa      	ldr	r2, [r7, #12]
  2125f4:	4613      	mov	r3, r2
  2125f6:	009b      	lsls	r3, r3, #2
  2125f8:	4413      	add	r3, r2
  2125fa:	440b      	add	r3, r1
  2125fc:	3304      	adds	r3, #4
  2125fe:	f993 3000 	ldrsb.w	r3, [r3]
  212602:	2b7f      	cmp	r3, #127	; 0x7f
  212604:	d038      	beq.n	212678 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x108>
					space[i].val++;
  212606:	4971      	ldr	r1, [pc, #452]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212608:	68fa      	ldr	r2, [r7, #12]
  21260a:	4613      	mov	r3, r2
  21260c:	009b      	lsls	r3, r3, #2
  21260e:	4413      	add	r3, r2
  212610:	440b      	add	r3, r1
  212612:	3304      	adds	r3, #4
  212614:	f993 3000 	ldrsb.w	r3, [r3]
  212618:	b2db      	uxtb	r3, r3
  21261a:	3301      	adds	r3, #1
  21261c:	b2db      	uxtb	r3, r3
  21261e:	b258      	sxtb	r0, r3
  212620:	496a      	ldr	r1, [pc, #424]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212622:	68fa      	ldr	r2, [r7, #12]
  212624:	4613      	mov	r3, r2
  212626:	009b      	lsls	r3, r3, #2
  212628:	4413      	add	r3, r2
  21262a:	440b      	add	r3, r1
  21262c:	3304      	adds	r3, #4
  21262e:	4602      	mov	r2, r0
  212630:	701a      	strb	r2, [r3, #0]
  212632:	e021      	b.n	212678 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x108>
			}
			else{
				if(space[i].val>-127)
  212634:	4965      	ldr	r1, [pc, #404]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212636:	68fa      	ldr	r2, [r7, #12]
  212638:	4613      	mov	r3, r2
  21263a:	009b      	lsls	r3, r3, #2
  21263c:	4413      	add	r3, r2
  21263e:	440b      	add	r3, r1
  212640:	3304      	adds	r3, #4
  212642:	f993 3000 	ldrsb.w	r3, [r3]
  212646:	f113 0f7e 	cmn.w	r3, #126	; 0x7e
  21264a:	db15      	blt.n	212678 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x108>
					space[i].val--;
  21264c:	495f      	ldr	r1, [pc, #380]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  21264e:	68fa      	ldr	r2, [r7, #12]
  212650:	4613      	mov	r3, r2
  212652:	009b      	lsls	r3, r3, #2
  212654:	4413      	add	r3, r2
  212656:	440b      	add	r3, r1
  212658:	3304      	adds	r3, #4
  21265a:	f993 3000 	ldrsb.w	r3, [r3]
  21265e:	b2db      	uxtb	r3, r3
  212660:	3b01      	subs	r3, #1
  212662:	b2db      	uxtb	r3, r3
  212664:	b258      	sxtb	r0, r3
  212666:	4959      	ldr	r1, [pc, #356]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212668:	68fa      	ldr	r2, [r7, #12]
  21266a:	4613      	mov	r3, r2
  21266c:	009b      	lsls	r3, r3, #2
  21266e:	4413      	add	r3, r2
  212670:	440b      	add	r3, r1
  212672:	3304      	adds	r3, #4
  212674:	4602      	mov	r2, r0
  212676:	701a      	strb	r2, [r3, #0]
			}
			return space[i].val;
  212678:	4954      	ldr	r1, [pc, #336]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  21267a:	68fa      	ldr	r2, [r7, #12]
  21267c:	4613      	mov	r3, r2
  21267e:	009b      	lsls	r3, r3, #2
  212680:	4413      	add	r3, r2
  212682:	440b      	add	r3, r1
  212684:	3304      	adds	r3, #4
  212686:	f993 3000 	ldrsb.w	r3, [r3]
  21268a:	e09a      	b.n	2127c2 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x252>
	for(int i=0;i<StructSpaceCount;i++)
  21268c:	68fb      	ldr	r3, [r7, #12]
  21268e:	3301      	adds	r3, #1
  212690:	60fb      	str	r3, [r7, #12]
  212692:	4b4f      	ldr	r3, [pc, #316]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  212694:	781b      	ldrb	r3, [r3, #0]
  212696:	461a      	mov	r2, r3
  212698:	68fb      	ldr	r3, [r7, #12]
  21269a:	429a      	cmp	r2, r3
  21269c:	f73f af7a 	bgt.w	212594 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x24>
		}
	}

	if(StructSpaceCount<MAX_SPACE_CORRECT)
  2126a0:	4b4b      	ldr	r3, [pc, #300]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2126a2:	781b      	ldrb	r3, [r3, #0]
  2126a4:	2b63      	cmp	r3, #99	; 0x63
  2126a6:	f200 808a 	bhi.w	2127be <LCD_SelectedSpaceBetweenFontsIncrDecr+0x24e>
	{
		space[StructSpaceCount].fontStyle=fontStyle;
  2126aa:	4b49      	ldr	r3, [pc, #292]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2126ac:	781b      	ldrb	r3, [r3, #0]
  2126ae:	4619      	mov	r1, r3
  2126b0:	4a46      	ldr	r2, [pc, #280]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2126b2:	460b      	mov	r3, r1
  2126b4:	009b      	lsls	r3, r3, #2
  2126b6:	440b      	add	r3, r1
  2126b8:	4413      	add	r3, r2
  2126ba:	79ba      	ldrb	r2, [r7, #6]
  2126bc:	701a      	strb	r2, [r3, #0]
		space[StructSpaceCount].fontSize=fontSize;
  2126be:	4b44      	ldr	r3, [pc, #272]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2126c0:	781b      	ldrb	r3, [r3, #0]
  2126c2:	4619      	mov	r1, r3
  2126c4:	4a41      	ldr	r2, [pc, #260]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2126c6:	460b      	mov	r3, r1
  2126c8:	009b      	lsls	r3, r3, #2
  2126ca:	440b      	add	r3, r1
  2126cc:	4413      	add	r3, r2
  2126ce:	3301      	adds	r3, #1
  2126d0:	797a      	ldrb	r2, [r7, #5]
  2126d2:	701a      	strb	r2, [r3, #0]
		space[StructSpaceCount].char1=char1;
  2126d4:	4b3e      	ldr	r3, [pc, #248]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2126d6:	781b      	ldrb	r3, [r3, #0]
  2126d8:	4619      	mov	r1, r3
  2126da:	4a3c      	ldr	r2, [pc, #240]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2126dc:	460b      	mov	r3, r1
  2126de:	009b      	lsls	r3, r3, #2
  2126e0:	440b      	add	r3, r1
  2126e2:	4413      	add	r3, r2
  2126e4:	3302      	adds	r3, #2
  2126e6:	793a      	ldrb	r2, [r7, #4]
  2126e8:	701a      	strb	r2, [r3, #0]
		space[StructSpaceCount].char2=char2;
  2126ea:	4b39      	ldr	r3, [pc, #228]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2126ec:	781b      	ldrb	r3, [r3, #0]
  2126ee:	4619      	mov	r1, r3
  2126f0:	4a36      	ldr	r2, [pc, #216]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2126f2:	460b      	mov	r3, r1
  2126f4:	009b      	lsls	r3, r3, #2
  2126f6:	440b      	add	r3, r1
  2126f8:	4413      	add	r3, r2
  2126fa:	3303      	adds	r3, #3
  2126fc:	7e3a      	ldrb	r2, [r7, #24]
  2126fe:	701a      	strb	r2, [r3, #0]

		if(incrDecr){
  212700:	79fb      	ldrb	r3, [r7, #7]
  212702:	2b00      	cmp	r3, #0
  212704:	d024      	beq.n	212750 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x1e0>
			if(space[StructSpaceCount].val<127)
  212706:	4b32      	ldr	r3, [pc, #200]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  212708:	781b      	ldrb	r3, [r3, #0]
  21270a:	4619      	mov	r1, r3
  21270c:	4a2f      	ldr	r2, [pc, #188]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  21270e:	460b      	mov	r3, r1
  212710:	009b      	lsls	r3, r3, #2
  212712:	440b      	add	r3, r1
  212714:	4413      	add	r3, r2
  212716:	3304      	adds	r3, #4
  212718:	f993 3000 	ldrsb.w	r3, [r3]
  21271c:	2b7f      	cmp	r3, #127	; 0x7f
  21271e:	d03c      	beq.n	21279a <LCD_SelectedSpaceBetweenFontsIncrDecr+0x22a>
				space[StructSpaceCount].val++;
  212720:	4b2b      	ldr	r3, [pc, #172]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  212722:	781b      	ldrb	r3, [r3, #0]
  212724:	461a      	mov	r2, r3
  212726:	4929      	ldr	r1, [pc, #164]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212728:	4613      	mov	r3, r2
  21272a:	009b      	lsls	r3, r3, #2
  21272c:	4413      	add	r3, r2
  21272e:	440b      	add	r3, r1
  212730:	3304      	adds	r3, #4
  212732:	f993 3000 	ldrsb.w	r3, [r3]
  212736:	b2db      	uxtb	r3, r3
  212738:	3301      	adds	r3, #1
  21273a:	b2db      	uxtb	r3, r3
  21273c:	b258      	sxtb	r0, r3
  21273e:	4923      	ldr	r1, [pc, #140]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212740:	4613      	mov	r3, r2
  212742:	009b      	lsls	r3, r3, #2
  212744:	4413      	add	r3, r2
  212746:	440b      	add	r3, r1
  212748:	3304      	adds	r3, #4
  21274a:	4602      	mov	r2, r0
  21274c:	701a      	strb	r2, [r3, #0]
  21274e:	e024      	b.n	21279a <LCD_SelectedSpaceBetweenFontsIncrDecr+0x22a>
		}
		else{
			if(space[StructSpaceCount].val>-127)
  212750:	4b1f      	ldr	r3, [pc, #124]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  212752:	781b      	ldrb	r3, [r3, #0]
  212754:	4619      	mov	r1, r3
  212756:	4a1d      	ldr	r2, [pc, #116]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212758:	460b      	mov	r3, r1
  21275a:	009b      	lsls	r3, r3, #2
  21275c:	440b      	add	r3, r1
  21275e:	4413      	add	r3, r2
  212760:	3304      	adds	r3, #4
  212762:	f993 3000 	ldrsb.w	r3, [r3]
  212766:	f113 0f7e 	cmn.w	r3, #126	; 0x7e
  21276a:	db16      	blt.n	21279a <LCD_SelectedSpaceBetweenFontsIncrDecr+0x22a>
				space[StructSpaceCount].val--;
  21276c:	4b18      	ldr	r3, [pc, #96]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  21276e:	781b      	ldrb	r3, [r3, #0]
  212770:	461a      	mov	r2, r3
  212772:	4916      	ldr	r1, [pc, #88]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  212774:	4613      	mov	r3, r2
  212776:	009b      	lsls	r3, r3, #2
  212778:	4413      	add	r3, r2
  21277a:	440b      	add	r3, r1
  21277c:	3304      	adds	r3, #4
  21277e:	f993 3000 	ldrsb.w	r3, [r3]
  212782:	b2db      	uxtb	r3, r3
  212784:	3b01      	subs	r3, #1
  212786:	b2db      	uxtb	r3, r3
  212788:	b258      	sxtb	r0, r3
  21278a:	4910      	ldr	r1, [pc, #64]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  21278c:	4613      	mov	r3, r2
  21278e:	009b      	lsls	r3, r3, #2
  212790:	4413      	add	r3, r2
  212792:	440b      	add	r3, r1
  212794:	3304      	adds	r3, #4
  212796:	4602      	mov	r2, r0
  212798:	701a      	strb	r2, [r3, #0]
		}
		StructSpaceCount++;
  21279a:	4b0d      	ldr	r3, [pc, #52]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  21279c:	781b      	ldrb	r3, [r3, #0]
  21279e:	3301      	adds	r3, #1
  2127a0:	b2da      	uxtb	r2, r3
  2127a2:	4b0b      	ldr	r3, [pc, #44]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2127a4:	701a      	strb	r2, [r3, #0]
		return space[StructSpaceCount-1].val;
  2127a6:	4b0a      	ldr	r3, [pc, #40]	; (2127d0 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x260>)
  2127a8:	781b      	ldrb	r3, [r3, #0]
  2127aa:	1e5a      	subs	r2, r3, #1
  2127ac:	4907      	ldr	r1, [pc, #28]	; (2127cc <LCD_SelectedSpaceBetweenFontsIncrDecr+0x25c>)
  2127ae:	4613      	mov	r3, r2
  2127b0:	009b      	lsls	r3, r3, #2
  2127b2:	4413      	add	r3, r2
  2127b4:	440b      	add	r3, r1
  2127b6:	3304      	adds	r3, #4
  2127b8:	f993 3000 	ldrsb.w	r3, [r3]
  2127bc:	e001      	b.n	2127c2 <LCD_SelectedSpaceBetweenFontsIncrDecr+0x252>
	}

	return 0xFFFF;
  2127be:	f64f 73ff 	movw	r3, #65535	; 0xffff
}
  2127c2:	4618      	mov	r0, r3
  2127c4:	3710      	adds	r7, #16
  2127c6:	46bd      	mov	sp, r7
  2127c8:	bc90      	pop	{r4, r7}
  2127ca:	4770      	bx	lr
  2127cc:	20010178 	.word	0x20010178
  2127d0:	2001036c 	.word	0x2001036c

002127d4 <LCD_DisplayRemeberedSpacesBetweenFonts>:

void LCD_DisplayRemeberedSpacesBetweenFonts(void){
  2127d4:	b5f0      	push	{r4, r5, r6, r7, lr}
  2127d6:	b097      	sub	sp, #92	; 0x5c
  2127d8:	af06      	add	r7, sp, #24
	char bufTemp[50];
	Dbg(1,"\r\nSpacesBetweenFonts:");
  2127da:	492f      	ldr	r1, [pc, #188]	; (212898 <LCD_DisplayRemeberedSpacesBetweenFonts+0xc4>)
  2127dc:	2001      	movs	r0, #1
  2127de:	f7ee f865 	bl	2008ac <Dbg>
	for(int i=0; i<StructSpaceCount; i++)
  2127e2:	2300      	movs	r3, #0
  2127e4:	63fb      	str	r3, [r7, #60]	; 0x3c
  2127e6:	e049      	b.n	21287c <LCD_DisplayRemeberedSpacesBetweenFonts+0xa8>
		DbgVar(1,50,"\r\n%d: %s %s %c %c  %d ",i+1,LCD_FontStyle2Str(bufTemp,space[i].fontStyle),LCD_FontSize2Str(bufTemp+20,space[i].fontSize),space[i].char1,space[i].char2,space[i].val);
  2127e8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2127ea:	1c5c      	adds	r4, r3, #1
  2127ec:	492b      	ldr	r1, [pc, #172]	; (21289c <LCD_DisplayRemeberedSpacesBetweenFonts+0xc8>)
  2127ee:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  2127f0:	4613      	mov	r3, r2
  2127f2:	009b      	lsls	r3, r3, #2
  2127f4:	4413      	add	r3, r2
  2127f6:	440b      	add	r3, r1
  2127f8:	781b      	ldrb	r3, [r3, #0]
  2127fa:	461a      	mov	r2, r3
  2127fc:	f107 0308 	add.w	r3, r7, #8
  212800:	4611      	mov	r1, r2
  212802:	4618      	mov	r0, r3
  212804:	f7f8 fddc 	bl	20b3c0 <LCD_FontStyle2Str>
  212808:	4605      	mov	r5, r0
  21280a:	f107 0208 	add.w	r2, r7, #8
  21280e:	3214      	adds	r2, #20
  212810:	4822      	ldr	r0, [pc, #136]	; (21289c <LCD_DisplayRemeberedSpacesBetweenFonts+0xc8>)
  212812:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
  212814:	460b      	mov	r3, r1
  212816:	009b      	lsls	r3, r3, #2
  212818:	440b      	add	r3, r1
  21281a:	4403      	add	r3, r0
  21281c:	3301      	adds	r3, #1
  21281e:	781b      	ldrb	r3, [r3, #0]
  212820:	4619      	mov	r1, r3
  212822:	4610      	mov	r0, r2
  212824:	f7f8 faf4 	bl	20ae10 <LCD_FontSize2Str>
  212828:	491c      	ldr	r1, [pc, #112]	; (21289c <LCD_DisplayRemeberedSpacesBetweenFonts+0xc8>)
  21282a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  21282c:	4613      	mov	r3, r2
  21282e:	009b      	lsls	r3, r3, #2
  212830:	4413      	add	r3, r2
  212832:	440b      	add	r3, r1
  212834:	3302      	adds	r3, #2
  212836:	781b      	ldrb	r3, [r3, #0]
  212838:	461e      	mov	r6, r3
  21283a:	4918      	ldr	r1, [pc, #96]	; (21289c <LCD_DisplayRemeberedSpacesBetweenFonts+0xc8>)
  21283c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  21283e:	4613      	mov	r3, r2
  212840:	009b      	lsls	r3, r3, #2
  212842:	4413      	add	r3, r2
  212844:	440b      	add	r3, r1
  212846:	3303      	adds	r3, #3
  212848:	781b      	ldrb	r3, [r3, #0]
  21284a:	607b      	str	r3, [r7, #4]
  21284c:	4913      	ldr	r1, [pc, #76]	; (21289c <LCD_DisplayRemeberedSpacesBetweenFonts+0xc8>)
  21284e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
  212850:	4613      	mov	r3, r2
  212852:	009b      	lsls	r3, r3, #2
  212854:	4413      	add	r3, r2
  212856:	440b      	add	r3, r1
  212858:	3304      	adds	r3, #4
  21285a:	f993 3000 	ldrsb.w	r3, [r3]
  21285e:	9304      	str	r3, [sp, #16]
  212860:	687b      	ldr	r3, [r7, #4]
  212862:	9303      	str	r3, [sp, #12]
  212864:	9602      	str	r6, [sp, #8]
  212866:	9001      	str	r0, [sp, #4]
  212868:	9500      	str	r5, [sp, #0]
  21286a:	4623      	mov	r3, r4
  21286c:	4a0c      	ldr	r2, [pc, #48]	; (2128a0 <LCD_DisplayRemeberedSpacesBetweenFonts+0xcc>)
  21286e:	2132      	movs	r1, #50	; 0x32
  212870:	2001      	movs	r0, #1
  212872:	f7ee f82a 	bl	2008ca <DbgVar>
	for(int i=0; i<StructSpaceCount; i++)
  212876:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  212878:	3301      	adds	r3, #1
  21287a:	63fb      	str	r3, [r7, #60]	; 0x3c
  21287c:	4b09      	ldr	r3, [pc, #36]	; (2128a4 <LCD_DisplayRemeberedSpacesBetweenFonts+0xd0>)
  21287e:	781b      	ldrb	r3, [r3, #0]
  212880:	461a      	mov	r2, r3
  212882:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  212884:	429a      	cmp	r2, r3
  212886:	dcaf      	bgt.n	2127e8 <LCD_DisplayRemeberedSpacesBetweenFonts+0x14>
	Dbg(1,"\r\n");
  212888:	4907      	ldr	r1, [pc, #28]	; (2128a8 <LCD_DisplayRemeberedSpacesBetweenFonts+0xd4>)
  21288a:	2001      	movs	r0, #1
  21288c:	f7ee f80e 	bl	2008ac <Dbg>
}
  212890:	bf00      	nop
  212892:	3744      	adds	r7, #68	; 0x44
  212894:	46bd      	mov	sp, r7
  212896:	bdf0      	pop	{r4, r5, r6, r7, pc}
  212898:	00228df4 	.word	0x00228df4
  21289c:	20010178 	.word	0x20010178
  2128a0:	00228e0c 	.word	0x00228e0c
  2128a4:	2001036c 	.word	0x2001036c
  2128a8:	00228e24 	.word	0x00228e24

002128ac <LCD_WriteSpacesBetweenFontsOnSDcard>:
void LCD_WriteSpacesBetweenFontsOnSDcard(void){
  2128ac:	b598      	push	{r3, r4, r7, lr}
  2128ae:	af00      	add	r7, sp, #0
	SDCardFileOpen(0,"Spaces_Between_Font.bin",FA_CREATE_ALWAYS|FA_WRITE);
  2128b0:	220a      	movs	r2, #10
  2128b2:	490e      	ldr	r1, [pc, #56]	; (2128ec <LCD_WriteSpacesBetweenFontsOnSDcard+0x40>)
  2128b4:	2000      	movs	r0, #0
  2128b6:	f7ee fe25 	bl	201504 <SDCardFileOpen>
	SDCardFileWrite(0,(char*)LCD_GetStructSpaceCount(),1);
  2128ba:	f7f7 fffd 	bl	20a8b8 <LCD_GetStructSpaceCount>
  2128be:	4603      	mov	r3, r0
  2128c0:	2201      	movs	r2, #1
  2128c2:	4619      	mov	r1, r3
  2128c4:	2000      	movs	r0, #0
  2128c6:	f7ee fe6b 	bl	2015a0 <SDCardFileWrite>
	SDCardFileWrite(0,(char*)LCD_GetPtr2SpacesBetweenFontsStruct(),LCD_GetSpacesBetweenFontsStructSize());
  2128ca:	f7f7 ffe1 	bl	20a890 <LCD_GetPtr2SpacesBetweenFontsStruct>
  2128ce:	4604      	mov	r4, r0
  2128d0:	f7f7 ffe8 	bl	20a8a4 <LCD_GetSpacesBetweenFontsStructSize>
  2128d4:	4603      	mov	r3, r0
  2128d6:	461a      	mov	r2, r3
  2128d8:	4621      	mov	r1, r4
  2128da:	2000      	movs	r0, #0
  2128dc:	f7ee fe60 	bl	2015a0 <SDCardFileWrite>
	SDCardFileClose(0);
  2128e0:	2000      	movs	r0, #0
  2128e2:	f7ee fe87 	bl	2015f4 <SDCardFileClose>
}
  2128e6:	bf00      	nop
  2128e8:	bd98      	pop	{r3, r4, r7, pc}
  2128ea:	bf00      	nop
  2128ec:	00228528 	.word	0x00228528

002128f0 <LCD_ResetSpacesBetweenFonts>:
void LCD_ResetSpacesBetweenFonts(void){
  2128f0:	b580      	push	{r7, lr}
  2128f2:	af00      	add	r7, sp, #0
	LCD_StartInsertingSpacesBetweenFonts();
  2128f4:	f7f7 ff86 	bl	20a804 <LCD_StartInsertingSpacesBetweenFonts>
	LCD_WriteSpacesBetweenFontsOnSDcard();
  2128f8:	f7ff ffd8 	bl	2128ac <LCD_WriteSpacesBetweenFontsOnSDcard>
}
  2128fc:	bf00      	nop
  2128fe:	bd80      	pop	{r7, pc}

00212900 <LCD_SetSpacesBetweenFonts>:
void LCD_SetSpacesBetweenFonts(void){
  212900:	b580      	push	{r7, lr}
  212902:	af00      	add	r7, sp, #0
	if(ReadSpacesBetweenFontsFromSDcard())
  212904:	f7f7 ffe2 	bl	20a8cc <ReadSpacesBetweenFontsFromSDcard>
  212908:	4603      	mov	r3, r0
  21290a:	2b00      	cmp	r3, #0
  21290c:	d001      	beq.n	212912 <LCD_SetSpacesBetweenFonts+0x12>
		LCD_StartInsertingSpacesBetweenFonts();
  21290e:	f7f7 ff79 	bl	20a804 <LCD_StartInsertingSpacesBetweenFonts>
}
  212912:	bf00      	nop
  212914:	bd80      	pop	{r7, pc}
	...

00212918 <LCD_Ypos>:

uint16_t LCD_Ypos(StructTxtPxlLen structTemp, int cmd, int offs)
{
  212918:	b490      	push	{r4, r7}
  21291a:	b084      	sub	sp, #16
  21291c:	af00      	add	r7, sp, #0
  21291e:	f107 0408 	add.w	r4, r7, #8
  212922:	e884 0003 	stmia.w	r4, {r0, r1}
  212926:	607a      	str	r2, [r7, #4]
  212928:	603b      	str	r3, [r7, #0]
	static uint16_t yPos=0;
	switch(cmd)
  21292a:	687b      	ldr	r3, [r7, #4]
  21292c:	2b00      	cmp	r3, #0
  21292e:	d002      	beq.n	212936 <LCD_Ypos+0x1e>
  212930:	2b01      	cmp	r3, #1
  212932:	d007      	beq.n	212944 <LCD_Ypos+0x2c>
  212934:	e00d      	b.n	212952 <LCD_Ypos+0x3a>
	{
	case SetPos:
		yPos=offs;
  212936:	683b      	ldr	r3, [r7, #0]
  212938:	b29a      	uxth	r2, r3
  21293a:	4b0f      	ldr	r3, [pc, #60]	; (212978 <LCD_Ypos+0x60>)
  21293c:	801a      	strh	r2, [r3, #0]
		return yPos;
  21293e:	4b0e      	ldr	r3, [pc, #56]	; (212978 <LCD_Ypos+0x60>)
  212940:	881b      	ldrh	r3, [r3, #0]
  212942:	e013      	b.n	21296c <LCD_Ypos+0x54>
	case GetPos:
		return yPos+offs;
  212944:	683b      	ldr	r3, [r7, #0]
  212946:	b29a      	uxth	r2, r3
  212948:	4b0b      	ldr	r3, [pc, #44]	; (212978 <LCD_Ypos+0x60>)
  21294a:	881b      	ldrh	r3, [r3, #0]
  21294c:	4413      	add	r3, r2
  21294e:	b29b      	uxth	r3, r3
  212950:	e00c      	b.n	21296c <LCD_Ypos+0x54>
	default:
		return yPos+=structTemp.height+offs;
  212952:	89ba      	ldrh	r2, [r7, #12]
  212954:	683b      	ldr	r3, [r7, #0]
  212956:	b29b      	uxth	r3, r3
  212958:	4413      	add	r3, r2
  21295a:	b29a      	uxth	r2, r3
  21295c:	4b06      	ldr	r3, [pc, #24]	; (212978 <LCD_Ypos+0x60>)
  21295e:	881b      	ldrh	r3, [r3, #0]
  212960:	4413      	add	r3, r2
  212962:	b29a      	uxth	r2, r3
  212964:	4b04      	ldr	r3, [pc, #16]	; (212978 <LCD_Ypos+0x60>)
  212966:	801a      	strh	r2, [r3, #0]
  212968:	4b03      	ldr	r3, [pc, #12]	; (212978 <LCD_Ypos+0x60>)
  21296a:	881b      	ldrh	r3, [r3, #0]
	}
}
  21296c:	4618      	mov	r0, r3
  21296e:	3710      	adds	r7, #16
  212970:	46bd      	mov	sp, r7
  212972:	bc90      	pop	{r4, r7}
  212974:	4770      	bx	lr
  212976:	bf00      	nop
  212978:	20010378 	.word	0x20010378

0021297c <LCD_Xpos>:
uint16_t LCD_Xpos(StructTxtPxlLen structTemp, int cmd, int offs)
{
  21297c:	b490      	push	{r4, r7}
  21297e:	b084      	sub	sp, #16
  212980:	af00      	add	r7, sp, #0
  212982:	f107 0408 	add.w	r4, r7, #8
  212986:	e884 0003 	stmia.w	r4, {r0, r1}
  21298a:	607a      	str	r2, [r7, #4]
  21298c:	603b      	str	r3, [r7, #0]
	static uint16_t xPos=0;
	switch(cmd)
  21298e:	687b      	ldr	r3, [r7, #4]
  212990:	2b00      	cmp	r3, #0
  212992:	d002      	beq.n	21299a <LCD_Xpos+0x1e>
  212994:	2b01      	cmp	r3, #1
  212996:	d007      	beq.n	2129a8 <LCD_Xpos+0x2c>
  212998:	e00d      	b.n	2129b6 <LCD_Xpos+0x3a>
	{
	case SetPos:
		xPos=offs;
  21299a:	683b      	ldr	r3, [r7, #0]
  21299c:	b29a      	uxth	r2, r3
  21299e:	4b0f      	ldr	r3, [pc, #60]	; (2129dc <LCD_Xpos+0x60>)
  2129a0:	801a      	strh	r2, [r3, #0]
		return xPos;
  2129a2:	4b0e      	ldr	r3, [pc, #56]	; (2129dc <LCD_Xpos+0x60>)
  2129a4:	881b      	ldrh	r3, [r3, #0]
  2129a6:	e013      	b.n	2129d0 <LCD_Xpos+0x54>
	case GetPos:
		return xPos+offs;
  2129a8:	683b      	ldr	r3, [r7, #0]
  2129aa:	b29a      	uxth	r2, r3
  2129ac:	4b0b      	ldr	r3, [pc, #44]	; (2129dc <LCD_Xpos+0x60>)
  2129ae:	881b      	ldrh	r3, [r3, #0]
  2129b0:	4413      	add	r3, r2
  2129b2:	b29b      	uxth	r3, r3
  2129b4:	e00c      	b.n	2129d0 <LCD_Xpos+0x54>
	case IncPos:
	default:
		return xPos+=structTemp.inPixel+offs;
  2129b6:	897a      	ldrh	r2, [r7, #10]
  2129b8:	683b      	ldr	r3, [r7, #0]
  2129ba:	b29b      	uxth	r3, r3
  2129bc:	4413      	add	r3, r2
  2129be:	b29a      	uxth	r2, r3
  2129c0:	4b06      	ldr	r3, [pc, #24]	; (2129dc <LCD_Xpos+0x60>)
  2129c2:	881b      	ldrh	r3, [r3, #0]
  2129c4:	4413      	add	r3, r2
  2129c6:	b29a      	uxth	r2, r3
  2129c8:	4b04      	ldr	r3, [pc, #16]	; (2129dc <LCD_Xpos+0x60>)
  2129ca:	801a      	strh	r2, [r3, #0]
  2129cc:	4b03      	ldr	r3, [pc, #12]	; (2129dc <LCD_Xpos+0x60>)
  2129ce:	881b      	ldrh	r3, [r3, #0]
	}
}
  2129d0:	4618      	mov	r0, r3
  2129d2:	3710      	adds	r7, #16
  2129d4:	46bd      	mov	sp, r7
  2129d6:	bc90      	pop	{r4, r7}
  2129d8:	4770      	bx	lr
  2129da:	bf00      	nop
  2129dc:	2001037a 	.word	0x2001037a

002129e0 <LCD_Ymiddle>:

uint16_t LCD_Ymiddle(int cmd, uint32_t val)
{
  2129e0:	b590      	push	{r4, r7, lr}
  2129e2:	b083      	sub	sp, #12
  2129e4:	af00      	add	r7, sp, #0
  2129e6:	6078      	str	r0, [r7, #4]
  2129e8:	6039      	str	r1, [r7, #0]
	static uint16_t startPosY=0, heightY=0;
	switch(cmd)
  2129ea:	687b      	ldr	r3, [r7, #4]
  2129ec:	2b00      	cmp	r3, #0
  2129ee:	d10f      	bne.n	212a10 <LCD_Ymiddle+0x30>
	{
	case SetPos:
		startPosY= val;
  2129f0:	683b      	ldr	r3, [r7, #0]
  2129f2:	b29a      	uxth	r2, r3
  2129f4:	4b11      	ldr	r3, [pc, #68]	; (212a3c <LCD_Ymiddle+0x5c>)
  2129f6:	801a      	strh	r2, [r3, #0]
		heightY= (val>>16)-startPosY;
  2129f8:	683b      	ldr	r3, [r7, #0]
  2129fa:	0c1b      	lsrs	r3, r3, #16
  2129fc:	b29a      	uxth	r2, r3
  2129fe:	4b0f      	ldr	r3, [pc, #60]	; (212a3c <LCD_Ymiddle+0x5c>)
  212a00:	881b      	ldrh	r3, [r3, #0]
  212a02:	1ad3      	subs	r3, r2, r3
  212a04:	b29a      	uxth	r2, r3
  212a06:	4b0e      	ldr	r3, [pc, #56]	; (212a40 <LCD_Ymiddle+0x60>)
  212a08:	801a      	strh	r2, [r3, #0]
		return startPosY;
  212a0a:	4b0c      	ldr	r3, [pc, #48]	; (212a3c <LCD_Ymiddle+0x5c>)
  212a0c:	881b      	ldrh	r3, [r3, #0]
  212a0e:	e011      	b.n	212a34 <LCD_Ymiddle+0x54>
	case GetPos:
	default:
		return MIDDLE(startPosY,heightY,LCD_GetFontHeight(val));
  212a10:	4b0b      	ldr	r3, [pc, #44]	; (212a40 <LCD_Ymiddle+0x60>)
  212a12:	881b      	ldrh	r3, [r3, #0]
  212a14:	461c      	mov	r4, r3
  212a16:	683b      	ldr	r3, [r7, #0]
  212a18:	4618      	mov	r0, r3
  212a1a:	f7ff fceb 	bl	2123f4 <LCD_GetFontHeight>
  212a1e:	4603      	mov	r3, r0
  212a20:	1ae3      	subs	r3, r4, r3
  212a22:	2b00      	cmp	r3, #0
  212a24:	da00      	bge.n	212a28 <LCD_Ymiddle+0x48>
  212a26:	3301      	adds	r3, #1
  212a28:	105b      	asrs	r3, r3, #1
  212a2a:	b29a      	uxth	r2, r3
  212a2c:	4b03      	ldr	r3, [pc, #12]	; (212a3c <LCD_Ymiddle+0x5c>)
  212a2e:	881b      	ldrh	r3, [r3, #0]
  212a30:	4413      	add	r3, r2
  212a32:	b29b      	uxth	r3, r3
	}
}
  212a34:	4618      	mov	r0, r3
  212a36:	370c      	adds	r7, #12
  212a38:	46bd      	mov	sp, r7
  212a3a:	bd90      	pop	{r4, r7, pc}
  212a3c:	2001037c 	.word	0x2001037c
  212a40:	2001037e 	.word	0x2001037e

00212a44 <LCD_Xmiddle>:
uint16_t LCD_Xmiddle(int cmd, uint32_t val, char *txt, int space, int constWidth)
{
  212a44:	b580      	push	{r7, lr}
  212a46:	b086      	sub	sp, #24
  212a48:	af00      	add	r7, sp, #0
  212a4a:	60f8      	str	r0, [r7, #12]
  212a4c:	60b9      	str	r1, [r7, #8]
  212a4e:	607a      	str	r2, [r7, #4]
  212a50:	603b      	str	r3, [r7, #0]
	static uint16_t startPosX=0, widthX=0;
	int len;
	switch(cmd)
  212a52:	68fb      	ldr	r3, [r7, #12]
  212a54:	2b00      	cmp	r3, #0
  212a56:	d10f      	bne.n	212a78 <LCD_Xmiddle+0x34>
	{
	case SetPos:
		startPosX= val;
  212a58:	68bb      	ldr	r3, [r7, #8]
  212a5a:	b29a      	uxth	r2, r3
  212a5c:	4b16      	ldr	r3, [pc, #88]	; (212ab8 <LCD_Xmiddle+0x74>)
  212a5e:	801a      	strh	r2, [r3, #0]
		widthX= (val>>16)-startPosX;
  212a60:	68bb      	ldr	r3, [r7, #8]
  212a62:	0c1b      	lsrs	r3, r3, #16
  212a64:	b29a      	uxth	r2, r3
  212a66:	4b14      	ldr	r3, [pc, #80]	; (212ab8 <LCD_Xmiddle+0x74>)
  212a68:	881b      	ldrh	r3, [r3, #0]
  212a6a:	1ad3      	subs	r3, r2, r3
  212a6c:	b29a      	uxth	r2, r3
  212a6e:	4b13      	ldr	r3, [pc, #76]	; (212abc <LCD_Xmiddle+0x78>)
  212a70:	801a      	strh	r2, [r3, #0]
		return startPosX;
  212a72:	4b11      	ldr	r3, [pc, #68]	; (212ab8 <LCD_Xmiddle+0x74>)
  212a74:	881b      	ldrh	r3, [r3, #0]
  212a76:	e01a      	b.n	212aae <LCD_Xmiddle+0x6a>
	case GetPos:
	default:
		len=LCD_GetWholeStrPxlWidth(val,txt,space,constWidth);
  212a78:	68b8      	ldr	r0, [r7, #8]
  212a7a:	6a3b      	ldr	r3, [r7, #32]
  212a7c:	683a      	ldr	r2, [r7, #0]
  212a7e:	6879      	ldr	r1, [r7, #4]
  212a80:	f7ff fb24 	bl	2120cc <LCD_GetWholeStrPxlWidth>
  212a84:	6178      	str	r0, [r7, #20]
		return MIDDLE(startPosX,widthX,(len>widthX?widthX:len));
  212a86:	4b0d      	ldr	r3, [pc, #52]	; (212abc <LCD_Xmiddle+0x78>)
  212a88:	881b      	ldrh	r3, [r3, #0]
  212a8a:	461a      	mov	r2, r3
  212a8c:	4b0b      	ldr	r3, [pc, #44]	; (212abc <LCD_Xmiddle+0x78>)
  212a8e:	881b      	ldrh	r3, [r3, #0]
  212a90:	4619      	mov	r1, r3
  212a92:	697b      	ldr	r3, [r7, #20]
  212a94:	428b      	cmp	r3, r1
  212a96:	bfa8      	it	ge
  212a98:	460b      	movge	r3, r1
  212a9a:	1ad3      	subs	r3, r2, r3
  212a9c:	2b00      	cmp	r3, #0
  212a9e:	da00      	bge.n	212aa2 <LCD_Xmiddle+0x5e>
  212aa0:	3301      	adds	r3, #1
  212aa2:	105b      	asrs	r3, r3, #1
  212aa4:	b29a      	uxth	r2, r3
  212aa6:	4b04      	ldr	r3, [pc, #16]	; (212ab8 <LCD_Xmiddle+0x74>)
  212aa8:	881b      	ldrh	r3, [r3, #0]
  212aaa:	4413      	add	r3, r2
  212aac:	b29b      	uxth	r3, r3
	}
}
  212aae:	4618      	mov	r0, r3
  212ab0:	3718      	adds	r7, #24
  212ab2:	46bd      	mov	sp, r7
  212ab4:	bd80      	pop	{r7, pc}
  212ab6:	bf00      	nop
  212ab8:	20010380 	.word	0x20010380
  212abc:	20010382 	.word	0x20010382

00212ac0 <TXT_PosCursor>:



static int startScreen=0;

static char* TXT_PosCursor(void){
  212ac0:	b580      	push	{r7, lr}
  212ac2:	af00      	add	r7, sp, #0
	return Test.posCursor>0 ? Int2Str(Test.posCursor-1,' ',3,Sign_none) : StrAll(1,"off");
  212ac4:	4b0b      	ldr	r3, [pc, #44]	; (212af4 <TXT_PosCursor+0x34>)
  212ac6:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  212aca:	2b00      	cmp	r3, #0
  212acc:	d00a      	beq.n	212ae4 <TXT_PosCursor+0x24>
  212ace:	4b09      	ldr	r3, [pc, #36]	; (212af4 <TXT_PosCursor+0x34>)
  212ad0:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  212ad4:	1e58      	subs	r0, r3, #1
  212ad6:	2303      	movs	r3, #3
  212ad8:	2203      	movs	r2, #3
  212ada:	2120      	movs	r1, #32
  212adc:	f7ee fdf2 	bl	2016c4 <Int2Str>
  212ae0:	4603      	mov	r3, r0
  212ae2:	e004      	b.n	212aee <TXT_PosCursor+0x2e>
  212ae4:	4904      	ldr	r1, [pc, #16]	; (212af8 <TXT_PosCursor+0x38>)
  212ae6:	2001      	movs	r0, #1
  212ae8:	f7ee ffe0 	bl	201aac <StrAll>
  212aec:	4603      	mov	r3, r0
}
  212aee:	4618      	mov	r0, r3
  212af0:	bd80      	pop	{r7, pc}
  212af2:	bf00      	nop
  212af4:	200103c0 	.word	0x200103c0
  212af8:	00228e28 	.word	0x00228e28

00212afc <ClearCursorField>:

static void ClearCursorField(void){
  212afc:	b5b0      	push	{r4, r5, r7, lr}
  212afe:	b084      	sub	sp, #16
  212b00:	af04      	add	r7, sp, #16
	LCD_ShapeIndirect(LCD_GetStrVar_x(STR_ID_Fonts),LCD_GetStrVar_y(STR_ID_Fonts)+LCD_GetFontHeight(fontIDVar)+Test.spaceCoursorY,LCD_Rectangle, lenStr.inPixel,Test.heightCursor, MYGRAY,MYGRAY,MYGRAY);
  212b02:	200a      	movs	r0, #10
  212b04:	f7f7 ffe6 	bl	20aad4 <LCD_GetStrVar_x>
  212b08:	4603      	mov	r3, r0
  212b0a:	461d      	mov	r5, r3
  212b0c:	200a      	movs	r0, #10
  212b0e:	f7f7 fff7 	bl	20ab00 <LCD_GetStrVar_y>
  212b12:	4604      	mov	r4, r0
  212b14:	4b10      	ldr	r3, [pc, #64]	; (212b58 <ClearCursorField+0x5c>)
  212b16:	681b      	ldr	r3, [r3, #0]
  212b18:	4618      	mov	r0, r3
  212b1a:	f7ff fc6b 	bl	2123f4 <LCD_GetFontHeight>
  212b1e:	4603      	mov	r3, r0
  212b20:	4423      	add	r3, r4
  212b22:	4a0e      	ldr	r2, [pc, #56]	; (212b5c <ClearCursorField+0x60>)
  212b24:	f892 2105 	ldrb.w	r2, [r2, #261]	; 0x105
  212b28:	4413      	add	r3, r2
  212b2a:	4619      	mov	r1, r3
  212b2c:	4b0c      	ldr	r3, [pc, #48]	; (212b60 <ClearCursorField+0x64>)
  212b2e:	885b      	ldrh	r3, [r3, #2]
  212b30:	4618      	mov	r0, r3
  212b32:	4b0a      	ldr	r3, [pc, #40]	; (212b5c <ClearCursorField+0x60>)
  212b34:	f893 3106 	ldrb.w	r3, [r3, #262]	; 0x106
  212b38:	461a      	mov	r2, r3
  212b3a:	4b0a      	ldr	r3, [pc, #40]	; (212b64 <ClearCursorField+0x68>)
  212b3c:	9303      	str	r3, [sp, #12]
  212b3e:	4b09      	ldr	r3, [pc, #36]	; (212b64 <ClearCursorField+0x68>)
  212b40:	9302      	str	r3, [sp, #8]
  212b42:	4b08      	ldr	r3, [pc, #32]	; (212b64 <ClearCursorField+0x68>)
  212b44:	9301      	str	r3, [sp, #4]
  212b46:	9200      	str	r2, [sp, #0]
  212b48:	4603      	mov	r3, r0
  212b4a:	4a07      	ldr	r2, [pc, #28]	; (212b68 <ClearCursorField+0x6c>)
  212b4c:	4628      	mov	r0, r5
  212b4e:	f7f2 fe95 	bl	20587c <LCD_ShapeIndirect>
}
  212b52:	bf00      	nop
  212b54:	46bd      	mov	sp, r7
  212b56:	bdb0      	pop	{r4, r5, r7, pc}
  212b58:	200103b8 	.word	0x200103b8
  212b5c:	200103c0 	.word	0x200103c0
  212b60:	20014a44 	.word	0x20014a44
  212b64:	ff404040 	.word	0xff404040
  212b68:	0020593d 	.word	0x0020593d

00212b6c <SetCursor>:
static void SetCursor(void)  //KURSOR DLA BIG FONT DAC PODWOJNY !!!!!
{
  212b6c:	b5b0      	push	{r4, r5, r7, lr}
  212b6e:	b086      	sub	sp, #24
  212b70:	af04      	add	r7, sp, #16
	ClearCursorField();
  212b72:	f7ff ffc3 	bl	212afc <ClearCursorField>
	if(Test.posCursor)
  212b76:	4b44      	ldr	r3, [pc, #272]	; (212c88 <SetCursor+0x11c>)
  212b78:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  212b7c:	2b00      	cmp	r3, #0
  212b7e:	d07f      	beq.n	212c80 <SetCursor+0x114>
	{
		uint32_t color;
		switch(Test.type)
  212b80:	4b41      	ldr	r3, [pc, #260]	; (212c88 <SetCursor+0x11c>)
  212b82:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  212b86:	2b00      	cmp	r3, #0
  212b88:	d002      	beq.n	212b90 <SetCursor+0x24>
  212b8a:	2b01      	cmp	r3, #1
  212b8c:	d017      	beq.n	212bbe <SetCursor+0x52>
  212b8e:	e01a      	b.n	212bc6 <SetCursor+0x5a>
		{
		case 0:
			if(Test.dispChangeColorOrNot)
  212b90:	4b3d      	ldr	r3, [pc, #244]	; (212c88 <SetCursor+0x11c>)
  212b92:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
  212b96:	2b00      	cmp	r3, #0
  212b98:	d003      	beq.n	212ba2 <SetCursor+0x36>
				color=MYGREEN;
  212b9a:	f06f 13af 	mvn.w	r3, #11468975	; 0xaf00af
  212b9e:	607b      	str	r3, [r7, #4]
			else
				color=RGB_FONT;
			break;
  212ba0:	e015      	b.n	212bce <SetCursor+0x62>
				color=RGB_FONT;
  212ba2:	4b39      	ldr	r3, [pc, #228]	; (212c88 <SetCursor+0x11c>)
  212ba4:	68db      	ldr	r3, [r3, #12]
  212ba6:	041a      	lsls	r2, r3, #16
  212ba8:	4b37      	ldr	r3, [pc, #220]	; (212c88 <SetCursor+0x11c>)
  212baa:	691b      	ldr	r3, [r3, #16]
  212bac:	021b      	lsls	r3, r3, #8
  212bae:	431a      	orrs	r2, r3
  212bb0:	4b35      	ldr	r3, [pc, #212]	; (212c88 <SetCursor+0x11c>)
  212bb2:	695b      	ldr	r3, [r3, #20]
  212bb4:	4313      	orrs	r3, r2
  212bb6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  212bba:	607b      	str	r3, [r7, #4]
			break;
  212bbc:	e007      	b.n	212bce <SetCursor+0x62>
		case 1:
			color=WHITE;
  212bbe:	f04f 33ff 	mov.w	r3, #4294967295
  212bc2:	607b      	str	r3, [r7, #4]
			break;
  212bc4:	e003      	b.n	212bce <SetCursor+0x62>
		case 2:
		default:
			color=BLACK;
  212bc6:	f04f 437f 	mov.w	r3, #4278190080	; 0xff000000
  212bca:	607b      	str	r3, [r7, #4]
			break;
  212bcc:	bf00      	nop
		}
		if(Test.posCursor>Test.lenWin)
  212bce:	4b2e      	ldr	r3, [pc, #184]	; (212c88 <SetCursor+0x11c>)
  212bd0:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  212bd4:	461a      	mov	r2, r3
  212bd6:	4b2c      	ldr	r3, [pc, #176]	; (212c88 <SetCursor+0x11c>)
  212bd8:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  212bdc:	429a      	cmp	r2, r3
  212bde:	dd06      	ble.n	212bee <SetCursor+0x82>
			Test.posCursor=Test.lenWin;
  212be0:	4b29      	ldr	r3, [pc, #164]	; (212c88 <SetCursor+0x11c>)
  212be2:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  212be6:	b2da      	uxtb	r2, r3
  212be8:	4b27      	ldr	r3, [pc, #156]	; (212c88 <SetCursor+0x11c>)
  212bea:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
		LCD_ShapeIndirect(LCD_GetStrVar_x(STR_ID_Fonts)+LCD_GetStrPxlWidth(fontIDVar,Test.txt,Test.posCursor-1,Test.spaceBetweenFonts,Test.constWidth),LCD_GetStrVar_y(STR_ID_Fonts)+LCD_GetFontHeight(fontIDVar)+Test.spaceCoursorY,LCD_Rectangle, LCD_GetFontWidth(fontIDVar,Test.txt[Test.posCursor-1]),Test.heightCursor, color,color,color);
  212bee:	200a      	movs	r0, #10
  212bf0:	f7f7 ff70 	bl	20aad4 <LCD_GetStrVar_x>
  212bf4:	4604      	mov	r4, r0
  212bf6:	4b25      	ldr	r3, [pc, #148]	; (212c8c <SetCursor+0x120>)
  212bf8:	6818      	ldr	r0, [r3, #0]
  212bfa:	4b23      	ldr	r3, [pc, #140]	; (212c88 <SetCursor+0x11c>)
  212bfc:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  212c00:	1e5a      	subs	r2, r3, #1
  212c02:	4b21      	ldr	r3, [pc, #132]	; (212c88 <SetCursor+0x11c>)
  212c04:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  212c08:	4619      	mov	r1, r3
  212c0a:	4b1f      	ldr	r3, [pc, #124]	; (212c88 <SetCursor+0x11c>)
  212c0c:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
  212c10:	9300      	str	r3, [sp, #0]
  212c12:	460b      	mov	r3, r1
  212c14:	491e      	ldr	r1, [pc, #120]	; (212c90 <SetCursor+0x124>)
  212c16:	f7ff fac9 	bl	2121ac <LCD_GetStrPxlWidth>
  212c1a:	4603      	mov	r3, r0
  212c1c:	4423      	add	r3, r4
  212c1e:	461d      	mov	r5, r3
  212c20:	200a      	movs	r0, #10
  212c22:	f7f7 ff6d 	bl	20ab00 <LCD_GetStrVar_y>
  212c26:	4604      	mov	r4, r0
  212c28:	4b18      	ldr	r3, [pc, #96]	; (212c8c <SetCursor+0x120>)
  212c2a:	681b      	ldr	r3, [r3, #0]
  212c2c:	4618      	mov	r0, r3
  212c2e:	f7ff fbe1 	bl	2123f4 <LCD_GetFontHeight>
  212c32:	4603      	mov	r3, r0
  212c34:	4423      	add	r3, r4
  212c36:	4a14      	ldr	r2, [pc, #80]	; (212c88 <SetCursor+0x11c>)
  212c38:	f892 2105 	ldrb.w	r2, [r2, #261]	; 0x105
  212c3c:	4413      	add	r3, r2
  212c3e:	461c      	mov	r4, r3
  212c40:	4b12      	ldr	r3, [pc, #72]	; (212c8c <SetCursor+0x120>)
  212c42:	6818      	ldr	r0, [r3, #0]
  212c44:	4b10      	ldr	r3, [pc, #64]	; (212c88 <SetCursor+0x11c>)
  212c46:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  212c4a:	3b01      	subs	r3, #1
  212c4c:	4a0e      	ldr	r2, [pc, #56]	; (212c88 <SetCursor+0x11c>)
  212c4e:	4413      	add	r3, r2
  212c50:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
  212c54:	4619      	mov	r1, r3
  212c56:	f7ff fb8f 	bl	212378 <LCD_GetFontWidth>
  212c5a:	4603      	mov	r3, r0
  212c5c:	4619      	mov	r1, r3
  212c5e:	4b0a      	ldr	r3, [pc, #40]	; (212c88 <SetCursor+0x11c>)
  212c60:	f893 3106 	ldrb.w	r3, [r3, #262]	; 0x106
  212c64:	461a      	mov	r2, r3
  212c66:	687b      	ldr	r3, [r7, #4]
  212c68:	9303      	str	r3, [sp, #12]
  212c6a:	687b      	ldr	r3, [r7, #4]
  212c6c:	9302      	str	r3, [sp, #8]
  212c6e:	687b      	ldr	r3, [r7, #4]
  212c70:	9301      	str	r3, [sp, #4]
  212c72:	9200      	str	r2, [sp, #0]
  212c74:	460b      	mov	r3, r1
  212c76:	4a07      	ldr	r2, [pc, #28]	; (212c94 <SetCursor+0x128>)
  212c78:	4621      	mov	r1, r4
  212c7a:	4628      	mov	r0, r5
  212c7c:	f7f2 fdfe 	bl	20587c <LCD_ShapeIndirect>
	}
}
  212c80:	bf00      	nop
  212c82:	3708      	adds	r7, #8
  212c84:	46bd      	mov	sp, r7
  212c86:	bdb0      	pop	{r4, r5, r7, pc}
  212c88:	200103c0 	.word	0x200103c0
  212c8c:	200103b8 	.word	0x200103b8
  212c90:	200103e9 	.word	0x200103e9
  212c94:	0020593d 	.word	0x0020593d

00212c98 <Data2Refresh>:

void Data2Refresh(int nr)
{
  212c98:	b5b0      	push	{r4, r5, r7, lr}
  212c9a:	b086      	sub	sp, #24
  212c9c:	af02      	add	r7, sp, #8
  212c9e:	60f8      	str	r0, [r7, #12]
	switch(nr)
  212ca0:	68fb      	ldr	r3, [r7, #12]
  212ca2:	2b0c      	cmp	r3, #12
  212ca4:	f200 8202 	bhi.w	2130ac <Data2Refresh+0x414>
  212ca8:	a201      	add	r2, pc, #4	; (adr r2, 212cb0 <Data2Refresh+0x18>)
  212caa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  212cae:	bf00      	nop
  212cb0:	00212ce5 	.word	0x00212ce5
  212cb4:	00212ecd 	.word	0x00212ecd
  212cb8:	00212f1d 	.word	0x00212f1d
  212cbc:	00212f6d 	.word	0x00212f6d
  212cc0:	00212f8d 	.word	0x00212f8d
  212cc4:	00212fad 	.word	0x00212fad
  212cc8:	00212fc9 	.word	0x00212fc9
  212ccc:	00212fe9 	.word	0x00212fe9
  212cd0:	00213041 	.word	0x00213041
  212cd4:	0021306d 	.word	0x0021306d
  212cd8:	0021307f 	.word	0x0021307f
  212cdc:	002130ab 	.word	0x002130ab
  212ce0:	00212d1f 	.word	0x00212d1f
	{
	case PARAM_SIZE:
		LCD_StrVarIndirect(STR_ID_FontSize,TXT_FONT_SIZE);
  212ce4:	4bcb      	ldr	r3, [pc, #812]	; (213014 <Data2Refresh+0x37c>)
  212ce6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  212cea:	461a      	mov	r2, r3
  212cec:	49ca      	ldr	r1, [pc, #808]	; (213018 <Data2Refresh+0x380>)
  212cee:	2000      	movs	r0, #0
  212cf0:	f004 fbd6 	bl	2174a0 <GetSelTxt>
  212cf4:	4604      	mov	r4, r0
  212cf6:	4bc7      	ldr	r3, [pc, #796]	; (213014 <Data2Refresh+0x37c>)
  212cf8:	f993 3020 	ldrsb.w	r3, [r3, #32]
  212cfc:	4619      	mov	r1, r3
  212cfe:	48c7      	ldr	r0, [pc, #796]	; (21301c <Data2Refresh+0x384>)
  212d00:	f7f8 f886 	bl	20ae10 <LCD_FontSize2Str>
  212d04:	4603      	mov	r3, r0
  212d06:	4ac6      	ldr	r2, [pc, #792]	; (213020 <Data2Refresh+0x388>)
  212d08:	4621      	mov	r1, r4
  212d0a:	2003      	movs	r0, #3
  212d0c:	f7ee fece 	bl	201aac <StrAll>
  212d10:	4602      	mov	r2, r0
  212d12:	463b      	mov	r3, r7
  212d14:	2105      	movs	r1, #5
  212d16:	4618      	mov	r0, r3
  212d18:	f7f9 fff6 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212d1c:	e1c6      	b.n	2130ac <Data2Refresh+0x414>
	case FONTS:

		switch(Test.type)
  212d1e:	4bbd      	ldr	r3, [pc, #756]	; (213014 <Data2Refresh+0x37c>)
  212d20:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  212d24:	2b01      	cmp	r3, #1
  212d26:	d073      	beq.n	212e10 <Data2Refresh+0x178>
  212d28:	2b02      	cmp	r3, #2
  212d2a:	f000 80a5 	beq.w	212e78 <Data2Refresh+0x1e0>
  212d2e:	2b00      	cmp	r3, #0
  212d30:	d000      	beq.n	212d34 <Data2Refresh+0x9c>
			StartMeasureTime_us();
			lenStr=LCD_StrVarIndirect(STR_ID_Fonts,Test.txt);
		   Test.speed=StopMeasureTime_us("");
			break;
		}
		break;
  212d32:	e1bb      	b.n	2130ac <Data2Refresh+0x414>
			if(Test.dispChangeColorOrNot==0){
  212d34:	4bb7      	ldr	r3, [pc, #732]	; (213014 <Data2Refresh+0x37c>)
  212d36:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
  212d3a:	2b00      	cmp	r3, #0
  212d3c:	d143      	bne.n	212dc6 <Data2Refresh+0x12e>
				LCD_SetStrVar_fontID(STR_ID_Fonts,fontIDVar);
  212d3e:	4bb9      	ldr	r3, [pc, #740]	; (213024 <Data2Refresh+0x38c>)
  212d40:	681b      	ldr	r3, [r3, #0]
  212d42:	4619      	mov	r1, r3
  212d44:	200a      	movs	r0, #10
  212d46:	f7f7 fead 	bl	20aaa4 <LCD_SetStrVar_fontID>
				LCD_SetStrVar_fontColor(STR_ID_Fonts,RGB_FONT);
  212d4a:	4bb2      	ldr	r3, [pc, #712]	; (213014 <Data2Refresh+0x37c>)
  212d4c:	68db      	ldr	r3, [r3, #12]
  212d4e:	041a      	lsls	r2, r3, #16
  212d50:	4bb0      	ldr	r3, [pc, #704]	; (213014 <Data2Refresh+0x37c>)
  212d52:	691b      	ldr	r3, [r3, #16]
  212d54:	021b      	lsls	r3, r3, #8
  212d56:	431a      	orrs	r2, r3
  212d58:	4bae      	ldr	r3, [pc, #696]	; (213014 <Data2Refresh+0x37c>)
  212d5a:	695b      	ldr	r3, [r3, #20]
  212d5c:	4313      	orrs	r3, r2
  212d5e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  212d62:	4619      	mov	r1, r3
  212d64:	200a      	movs	r0, #10
  212d66:	f7f7 fdf1 	bl	20a94c <LCD_SetStrVar_fontColor>
				LCD_SetStrVar_bkColor(STR_ID_Fonts,RGB_BK);
  212d6a:	4baa      	ldr	r3, [pc, #680]	; (213014 <Data2Refresh+0x37c>)
  212d6c:	681b      	ldr	r3, [r3, #0]
  212d6e:	041a      	lsls	r2, r3, #16
  212d70:	4ba8      	ldr	r3, [pc, #672]	; (213014 <Data2Refresh+0x37c>)
  212d72:	685b      	ldr	r3, [r3, #4]
  212d74:	021b      	lsls	r3, r3, #8
  212d76:	431a      	orrs	r2, r3
  212d78:	4ba6      	ldr	r3, [pc, #664]	; (213014 <Data2Refresh+0x37c>)
  212d7a:	689b      	ldr	r3, [r3, #8]
  212d7c:	4313      	orrs	r3, r2
  212d7e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  212d82:	4619      	mov	r1, r3
  212d84:	200a      	movs	r0, #10
  212d86:	f7f7 fdc9 	bl	20a91c <LCD_SetStrVar_bkColor>
				LCD_SetStrVar_coeff(STR_ID_Fonts,Test.coeff);
  212d8a:	4ba2      	ldr	r3, [pc, #648]	; (213014 <Data2Refresh+0x37c>)
  212d8c:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  212d90:	4619      	mov	r1, r3
  212d92:	200a      	movs	r0, #10
  212d94:	f7f7 fe6e 	bl	20aa74 <LCD_SetStrVar_coeff>
				StartMeasureTime_us();
  212d98:	f005 fe4e 	bl	218a38 <StartMeasureTime_us>
				 lenStr=LCD_StrChangeColorVarIndirect(STR_ID_Fonts,Test.txt);
  212d9c:	4ca2      	ldr	r4, [pc, #648]	; (213028 <Data2Refresh+0x390>)
  212d9e:	463b      	mov	r3, r7
  212da0:	4aa2      	ldr	r2, [pc, #648]	; (21302c <Data2Refresh+0x394>)
  212da2:	210a      	movs	r1, #10
  212da4:	4618      	mov	r0, r3
  212da6:	f7fa f933 	bl	20d010 <LCD_StrChangeColorVarIndirect>
  212daa:	4622      	mov	r2, r4
  212dac:	463b      	mov	r3, r7
  212dae:	6819      	ldr	r1, [r3, #0]
  212db0:	6011      	str	r1, [r2, #0]
  212db2:	889b      	ldrh	r3, [r3, #4]
  212db4:	8093      	strh	r3, [r2, #4]
				Test.speed=StopMeasureTime_us("");
  212db6:	489e      	ldr	r0, [pc, #632]	; (213030 <Data2Refresh+0x398>)
  212db8:	f005 fe4e 	bl	218a58 <StopMeasureTime_us>
  212dbc:	4602      	mov	r2, r0
  212dbe:	4b95      	ldr	r3, [pc, #596]	; (213014 <Data2Refresh+0x37c>)
  212dc0:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
			break;
  212dc4:	e081      	b.n	212eca <Data2Refresh+0x232>
				LCD_SetStrVar_fontID(STR_ID_Fonts,fontIDVar);
  212dc6:	4b97      	ldr	r3, [pc, #604]	; (213024 <Data2Refresh+0x38c>)
  212dc8:	681b      	ldr	r3, [r3, #0]
  212dca:	4619      	mov	r1, r3
  212dcc:	200a      	movs	r0, #10
  212dce:	f7f7 fe69 	bl	20aaa4 <LCD_SetStrVar_fontID>
				LCD_SetStrVar_bkColor(STR_ID_Fonts,MYGRAY);
  212dd2:	4998      	ldr	r1, [pc, #608]	; (213034 <Data2Refresh+0x39c>)
  212dd4:	200a      	movs	r0, #10
  212dd6:	f7f7 fda1 	bl	20a91c <LCD_SetStrVar_bkColor>
				LCD_SetStrVar_coeff(STR_ID_Fonts,0);
  212dda:	2100      	movs	r1, #0
  212ddc:	200a      	movs	r0, #10
  212dde:	f7f7 fe49 	bl	20aa74 <LCD_SetStrVar_coeff>
				StartMeasureTime_us();
  212de2:	f005 fe29 	bl	218a38 <StartMeasureTime_us>
				lenStr=LCD_StrVarIndirect(STR_ID_Fonts,Test.txt);
  212de6:	4c90      	ldr	r4, [pc, #576]	; (213028 <Data2Refresh+0x390>)
  212de8:	463b      	mov	r3, r7
  212dea:	4a90      	ldr	r2, [pc, #576]	; (21302c <Data2Refresh+0x394>)
  212dec:	210a      	movs	r1, #10
  212dee:	4618      	mov	r0, r3
  212df0:	f7f9 ff8a 	bl	20cd08 <LCD_StrVarIndirect>
  212df4:	4622      	mov	r2, r4
  212df6:	463b      	mov	r3, r7
  212df8:	6819      	ldr	r1, [r3, #0]
  212dfa:	6011      	str	r1, [r2, #0]
  212dfc:	889b      	ldrh	r3, [r3, #4]
  212dfe:	8093      	strh	r3, [r2, #4]
				Test.speed=StopMeasureTime_us("");
  212e00:	488b      	ldr	r0, [pc, #556]	; (213030 <Data2Refresh+0x398>)
  212e02:	f005 fe29 	bl	218a58 <StopMeasureTime_us>
  212e06:	4602      	mov	r2, r0
  212e08:	4b82      	ldr	r3, [pc, #520]	; (213014 <Data2Refresh+0x37c>)
  212e0a:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
			break;
  212e0e:	e05c      	b.n	212eca <Data2Refresh+0x232>
			LCD_SetStrVar_fontID(STR_ID_Fonts,fontIDVar);
  212e10:	4b84      	ldr	r3, [pc, #528]	; (213024 <Data2Refresh+0x38c>)
  212e12:	681b      	ldr	r3, [r3, #0]
  212e14:	4619      	mov	r1, r3
  212e16:	200a      	movs	r0, #10
  212e18:	f7f7 fe44 	bl	20aaa4 <LCD_SetStrVar_fontID>
			LCD_SetStrVar_bkColor(STR_ID_Fonts,RGB_BK);
  212e1c:	4b7d      	ldr	r3, [pc, #500]	; (213014 <Data2Refresh+0x37c>)
  212e1e:	681b      	ldr	r3, [r3, #0]
  212e20:	041a      	lsls	r2, r3, #16
  212e22:	4b7c      	ldr	r3, [pc, #496]	; (213014 <Data2Refresh+0x37c>)
  212e24:	685b      	ldr	r3, [r3, #4]
  212e26:	021b      	lsls	r3, r3, #8
  212e28:	431a      	orrs	r2, r3
  212e2a:	4b7a      	ldr	r3, [pc, #488]	; (213014 <Data2Refresh+0x37c>)
  212e2c:	689b      	ldr	r3, [r3, #8]
  212e2e:	4313      	orrs	r3, r2
  212e30:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  212e34:	4619      	mov	r1, r3
  212e36:	200a      	movs	r0, #10
  212e38:	f7f7 fd70 	bl	20a91c <LCD_SetStrVar_bkColor>
			LCD_SetStrVar_coeff(STR_ID_Fonts,Test.coeff);
  212e3c:	4b75      	ldr	r3, [pc, #468]	; (213014 <Data2Refresh+0x37c>)
  212e3e:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  212e42:	4619      	mov	r1, r3
  212e44:	200a      	movs	r0, #10
  212e46:	f7f7 fe15 	bl	20aa74 <LCD_SetStrVar_coeff>
			StartMeasureTime_us();
  212e4a:	f005 fdf5 	bl	218a38 <StartMeasureTime_us>
			lenStr=LCD_StrVarIndirect(STR_ID_Fonts,Test.txt);
  212e4e:	4c76      	ldr	r4, [pc, #472]	; (213028 <Data2Refresh+0x390>)
  212e50:	463b      	mov	r3, r7
  212e52:	4a76      	ldr	r2, [pc, #472]	; (21302c <Data2Refresh+0x394>)
  212e54:	210a      	movs	r1, #10
  212e56:	4618      	mov	r0, r3
  212e58:	f7f9 ff56 	bl	20cd08 <LCD_StrVarIndirect>
  212e5c:	4622      	mov	r2, r4
  212e5e:	463b      	mov	r3, r7
  212e60:	6819      	ldr	r1, [r3, #0]
  212e62:	6011      	str	r1, [r2, #0]
  212e64:	889b      	ldrh	r3, [r3, #4]
  212e66:	8093      	strh	r3, [r2, #4]
		   Test.speed=StopMeasureTime_us("");
  212e68:	4871      	ldr	r0, [pc, #452]	; (213030 <Data2Refresh+0x398>)
  212e6a:	f005 fdf5 	bl	218a58 <StopMeasureTime_us>
  212e6e:	4602      	mov	r2, r0
  212e70:	4b68      	ldr	r3, [pc, #416]	; (213014 <Data2Refresh+0x37c>)
  212e72:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
		   break;
  212e76:	e028      	b.n	212eca <Data2Refresh+0x232>
			LCD_SetStrVar_fontID(STR_ID_Fonts,fontIDVar);
  212e78:	4b6a      	ldr	r3, [pc, #424]	; (213024 <Data2Refresh+0x38c>)
  212e7a:	681b      	ldr	r3, [r3, #0]
  212e7c:	4619      	mov	r1, r3
  212e7e:	200a      	movs	r0, #10
  212e80:	f7f7 fe10 	bl	20aaa4 <LCD_SetStrVar_fontID>
			LCD_SetStrVar_bkColor(STR_ID_Fonts,WHITE);
  212e84:	f04f 31ff 	mov.w	r1, #4294967295
  212e88:	200a      	movs	r0, #10
  212e8a:	f7f7 fd47 	bl	20a91c <LCD_SetStrVar_bkColor>
			Test.coeff=0; LCD_SetStrVar_coeff(STR_ID_Fonts,0);
  212e8e:	4b61      	ldr	r3, [pc, #388]	; (213014 <Data2Refresh+0x37c>)
  212e90:	2200      	movs	r2, #0
  212e92:	839a      	strh	r2, [r3, #28]
  212e94:	2100      	movs	r1, #0
  212e96:	200a      	movs	r0, #10
  212e98:	f7f7 fdec 	bl	20aa74 <LCD_SetStrVar_coeff>
			StartMeasureTime_us();
  212e9c:	f005 fdcc 	bl	218a38 <StartMeasureTime_us>
			lenStr=LCD_StrVarIndirect(STR_ID_Fonts,Test.txt);
  212ea0:	4c61      	ldr	r4, [pc, #388]	; (213028 <Data2Refresh+0x390>)
  212ea2:	463b      	mov	r3, r7
  212ea4:	4a61      	ldr	r2, [pc, #388]	; (21302c <Data2Refresh+0x394>)
  212ea6:	210a      	movs	r1, #10
  212ea8:	4618      	mov	r0, r3
  212eaa:	f7f9 ff2d 	bl	20cd08 <LCD_StrVarIndirect>
  212eae:	4622      	mov	r2, r4
  212eb0:	463b      	mov	r3, r7
  212eb2:	6819      	ldr	r1, [r3, #0]
  212eb4:	6011      	str	r1, [r2, #0]
  212eb6:	889b      	ldrh	r3, [r3, #4]
  212eb8:	8093      	strh	r3, [r2, #4]
		   Test.speed=StopMeasureTime_us("");
  212eba:	485d      	ldr	r0, [pc, #372]	; (213030 <Data2Refresh+0x398>)
  212ebc:	f005 fdcc 	bl	218a58 <StopMeasureTime_us>
  212ec0:	4602      	mov	r2, r0
  212ec2:	4b54      	ldr	r3, [pc, #336]	; (213014 <Data2Refresh+0x37c>)
  212ec4:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
			break;
  212ec8:	bf00      	nop
		break;
  212eca:	e0ef      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_COLOR_BK:
		LCD_StrVarIndirect(STR_ID_BkColor,TXT_BK_COLOR);
  212ecc:	4b51      	ldr	r3, [pc, #324]	; (213014 <Data2Refresh+0x37c>)
  212ece:	6818      	ldr	r0, [r3, #0]
  212ed0:	2303      	movs	r3, #3
  212ed2:	2203      	movs	r2, #3
  212ed4:	2130      	movs	r1, #48	; 0x30
  212ed6:	f7ee fbf5 	bl	2016c4 <Int2Str>
  212eda:	4604      	mov	r4, r0
  212edc:	4b4d      	ldr	r3, [pc, #308]	; (213014 <Data2Refresh+0x37c>)
  212ede:	6858      	ldr	r0, [r3, #4]
  212ee0:	2303      	movs	r3, #3
  212ee2:	2203      	movs	r2, #3
  212ee4:	2130      	movs	r1, #48	; 0x30
  212ee6:	f7ee fbed 	bl	2016c4 <Int2Str>
  212eea:	4605      	mov	r5, r0
  212eec:	4b49      	ldr	r3, [pc, #292]	; (213014 <Data2Refresh+0x37c>)
  212eee:	6898      	ldr	r0, [r3, #8]
  212ef0:	2303      	movs	r3, #3
  212ef2:	2203      	movs	r2, #3
  212ef4:	2130      	movs	r1, #48	; 0x30
  212ef6:	f7ee fbe5 	bl	2016c4 <Int2Str>
  212efa:	4603      	mov	r3, r0
  212efc:	9301      	str	r3, [sp, #4]
  212efe:	4b4e      	ldr	r3, [pc, #312]	; (213038 <Data2Refresh+0x3a0>)
  212f00:	9300      	str	r3, [sp, #0]
  212f02:	462b      	mov	r3, r5
  212f04:	4a4c      	ldr	r2, [pc, #304]	; (213038 <Data2Refresh+0x3a0>)
  212f06:	4621      	mov	r1, r4
  212f08:	2005      	movs	r0, #5
  212f0a:	f7ee fdcf 	bl	201aac <StrAll>
  212f0e:	4602      	mov	r2, r0
  212f10:	463b      	mov	r3, r7
  212f12:	2103      	movs	r1, #3
  212f14:	4618      	mov	r0, r3
  212f16:	f7f9 fef7 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212f1a:	e0c7      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_COLOR_FONT:
		LCD_StrVarIndirect(STR_ID_FontColor,TXT_FONT_COLOR);
  212f1c:	4b3d      	ldr	r3, [pc, #244]	; (213014 <Data2Refresh+0x37c>)
  212f1e:	68d8      	ldr	r0, [r3, #12]
  212f20:	2303      	movs	r3, #3
  212f22:	2203      	movs	r2, #3
  212f24:	2130      	movs	r1, #48	; 0x30
  212f26:	f7ee fbcd 	bl	2016c4 <Int2Str>
  212f2a:	4604      	mov	r4, r0
  212f2c:	4b39      	ldr	r3, [pc, #228]	; (213014 <Data2Refresh+0x37c>)
  212f2e:	6918      	ldr	r0, [r3, #16]
  212f30:	2303      	movs	r3, #3
  212f32:	2203      	movs	r2, #3
  212f34:	2130      	movs	r1, #48	; 0x30
  212f36:	f7ee fbc5 	bl	2016c4 <Int2Str>
  212f3a:	4605      	mov	r5, r0
  212f3c:	4b35      	ldr	r3, [pc, #212]	; (213014 <Data2Refresh+0x37c>)
  212f3e:	6958      	ldr	r0, [r3, #20]
  212f40:	2303      	movs	r3, #3
  212f42:	2203      	movs	r2, #3
  212f44:	2130      	movs	r1, #48	; 0x30
  212f46:	f7ee fbbd 	bl	2016c4 <Int2Str>
  212f4a:	4603      	mov	r3, r0
  212f4c:	9301      	str	r3, [sp, #4]
  212f4e:	4b3a      	ldr	r3, [pc, #232]	; (213038 <Data2Refresh+0x3a0>)
  212f50:	9300      	str	r3, [sp, #0]
  212f52:	462b      	mov	r3, r5
  212f54:	4a38      	ldr	r2, [pc, #224]	; (213038 <Data2Refresh+0x3a0>)
  212f56:	4621      	mov	r1, r4
  212f58:	2005      	movs	r0, #5
  212f5a:	f7ee fda7 	bl	201aac <StrAll>
  212f5e:	4602      	mov	r2, r0
  212f60:	463b      	mov	r3, r7
  212f62:	2104      	movs	r1, #4
  212f64:	4618      	mov	r0, r3
  212f66:	f7f9 fecf 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212f6a:	e09f      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_LEN_WINDOW:
		LCD_StrVarIndirect(STR_ID_LenWin, TXT_LEN_WIN);
  212f6c:	4b29      	ldr	r3, [pc, #164]	; (213014 <Data2Refresh+0x37c>)
  212f6e:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  212f72:	4618      	mov	r0, r3
  212f74:	2303      	movs	r3, #3
  212f76:	2203      	movs	r2, #3
  212f78:	2120      	movs	r1, #32
  212f7a:	f7ee fba3 	bl	2016c4 <Int2Str>
  212f7e:	4602      	mov	r2, r0
  212f80:	463b      	mov	r3, r7
  212f82:	2100      	movs	r1, #0
  212f84:	4618      	mov	r0, r3
  212f86:	f7f9 febf 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212f8a:	e08f      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_OFFS_WINDOW:
		LCD_StrVarIndirect(STR_ID_OffsWin, TXT_OFFS_WIN);
  212f8c:	4b21      	ldr	r3, [pc, #132]	; (213014 <Data2Refresh+0x37c>)
  212f8e:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  212f92:	4618      	mov	r0, r3
  212f94:	2303      	movs	r3, #3
  212f96:	2203      	movs	r2, #3
  212f98:	2120      	movs	r1, #32
  212f9a:	f7ee fb93 	bl	2016c4 <Int2Str>
  212f9e:	4602      	mov	r2, r0
  212fa0:	463b      	mov	r3, r7
  212fa2:	2101      	movs	r1, #1
  212fa4:	4618      	mov	r0, r3
  212fa6:	f7f9 feaf 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212faa:	e07f      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_STYLE:
		LCD_StrVarIndirect(STR_ID_FontStyle,TXT_FONT_STYLE);
  212fac:	4b19      	ldr	r3, [pc, #100]	; (213014 <Data2Refresh+0x37c>)
  212fae:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  212fb2:	4619      	mov	r1, r3
  212fb4:	4819      	ldr	r0, [pc, #100]	; (21301c <Data2Refresh+0x384>)
  212fb6:	f7f8 fa03 	bl	20b3c0 <LCD_FontStyle2Str>
  212fba:	4602      	mov	r2, r0
  212fbc:	463b      	mov	r3, r7
  212fbe:	2106      	movs	r1, #6
  212fc0:	4618      	mov	r0, r3
  212fc2:	f7f9 fea1 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212fc6:	e071      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_COEFF:
		LCD_StrVarIndirect(STR_ID_Coeff,TXT_COEFF);
  212fc8:	4b12      	ldr	r3, [pc, #72]	; (213014 <Data2Refresh+0x37c>)
  212fca:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  212fce:	4618      	mov	r0, r3
  212fd0:	2300      	movs	r3, #0
  212fd2:	2203      	movs	r2, #3
  212fd4:	2120      	movs	r1, #32
  212fd6:	f7ee fb75 	bl	2016c4 <Int2Str>
  212fda:	4602      	mov	r2, r0
  212fdc:	463b      	mov	r3, r7
  212fde:	2107      	movs	r1, #7
  212fe0:	4618      	mov	r0, r3
  212fe2:	f7f9 fe91 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  212fe6:	e061      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_SPEED:
		LCD_StrVarIndirect(STR_ID_Speed,TXT_SPEED);
  212fe8:	4b0a      	ldr	r3, [pc, #40]	; (213014 <Data2Refresh+0x37c>)
  212fea:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  212fee:	4618      	mov	r0, r3
  212ff0:	2303      	movs	r3, #3
  212ff2:	2206      	movs	r2, #6
  212ff4:	2120      	movs	r1, #32
  212ff6:	f7ee fb65 	bl	2016c4 <Int2Str>
  212ffa:	4603      	mov	r3, r0
  212ffc:	4a0f      	ldr	r2, [pc, #60]	; (21303c <Data2Refresh+0x3a4>)
  212ffe:	4619      	mov	r1, r3
  213000:	2002      	movs	r0, #2
  213002:	f7ee fd53 	bl	201aac <StrAll>
  213006:	4602      	mov	r2, r0
  213008:	463b      	mov	r3, r7
  21300a:	2108      	movs	r1, #8
  21300c:	4618      	mov	r0, r3
  21300e:	f7f9 fe7b 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  213012:	e04b      	b.n	2130ac <Data2Refresh+0x414>
  213014:	200103c0 	.word	0x200103c0
  213018:	00229320 	.word	0x00229320
  21301c:	20010384 	.word	0x20010384
  213020:	00228e2c 	.word	0x00228e2c
  213024:	200103b8 	.word	0x200103b8
  213028:	20014a44 	.word	0x20014a44
  21302c:	200103e9 	.word	0x200103e9
  213030:	00228e30 	.word	0x00228e30
  213034:	ff404040 	.word	0xff404040
  213038:	00228e34 	.word	0x00228e34
  21303c:	00228e38 	.word	0x00228e38
	case PARAM_LOAD_FONT_TIME:
		LCD_StrVarIndirect(STR_ID_LoadFontTime, TXT_LOAD_FONT_TIME);
  213040:	4b1c      	ldr	r3, [pc, #112]	; (2130b4 <Data2Refresh+0x41c>)
  213042:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
  213046:	4618      	mov	r0, r3
  213048:	2303      	movs	r3, #3
  21304a:	2206      	movs	r2, #6
  21304c:	2120      	movs	r1, #32
  21304e:	f7ee fb39 	bl	2016c4 <Int2Str>
  213052:	4603      	mov	r3, r0
  213054:	4a18      	ldr	r2, [pc, #96]	; (2130b8 <Data2Refresh+0x420>)
  213056:	4619      	mov	r1, r3
  213058:	2002      	movs	r0, #2
  21305a:	f7ee fd27 	bl	201aac <StrAll>
  21305e:	4602      	mov	r2, r0
  213060:	463b      	mov	r3, r7
  213062:	2102      	movs	r1, #2
  213064:	4618      	mov	r0, r3
  213066:	f7f9 fe4f 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  21306a:	e01f      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_POS_CURSOR:
		LCD_StrVarIndirect(STR_ID_PosCursor,TXT_PosCursor());
  21306c:	f7ff fd28 	bl	212ac0 <TXT_PosCursor>
  213070:	4602      	mov	r2, r0
  213072:	463b      	mov	r3, r7
  213074:	2109      	movs	r1, #9
  213076:	4618      	mov	r0, r3
  213078:	f7f9 fe46 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  21307c:	e016      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_CPU_USAGE:
		LCD_StrVarIndirect(STR_ID_CPU_usage,TXT_CPU_USAGE);
  21307e:	f004 fab9 	bl	2175f4 <osGetCPUUsage>
  213082:	4603      	mov	r3, r0
  213084:	4618      	mov	r0, r3
  213086:	2303      	movs	r3, #3
  213088:	2203      	movs	r2, #3
  21308a:	2130      	movs	r1, #48	; 0x30
  21308c:	f7ee fb1a 	bl	2016c4 <Int2Str>
  213090:	4603      	mov	r3, r0
  213092:	4a0a      	ldr	r2, [pc, #40]	; (2130bc <Data2Refresh+0x424>)
  213094:	4619      	mov	r1, r3
  213096:	2002      	movs	r0, #2
  213098:	f7ee fd08 	bl	201aac <StrAll>
  21309c:	4602      	mov	r2, r0
  21309e:	463b      	mov	r3, r7
  2130a0:	2114      	movs	r1, #20
  2130a2:	4618      	mov	r0, r3
  2130a4:	f7f9 fe30 	bl	20cd08 <LCD_StrVarIndirect>
		break;
  2130a8:	e000      	b.n	2130ac <Data2Refresh+0x414>
	case PARAM_MOV_TXT:
//		if(IsRefreshScreenTimeout(refresh_1,20)){ LCD_StrMovHIndirect(STR_ID_MovFonts_1,1); Data2Refresh(PARAM_CPU_USAGE);  }
//		if(IsRefreshScreenTimeout(refresh_2,20)) LCD_StrMovHIndirect(STR_ID_MovFonts_2,1);
	//	if(IsRefreshScreenTimeout(refresh_3,20)) LCD_StrMovHIndirect(STR_ID_MovFonts_3,1);
		//if(IsRefreshScreenTimeout(refresh_4,20)) LCD_StrMovHIndirect(STR_ID_MovFonts_4,1);
		break;
  2130aa:	bf00      	nop
	}
}
  2130ac:	bf00      	nop
  2130ae:	3710      	adds	r7, #16
  2130b0:	46bd      	mov	sp, r7
  2130b2:	bdb0      	pop	{r4, r5, r7, pc}
  2130b4:	200103c0 	.word	0x200103c0
  2130b8:	00228e3c 	.word	0x00228e3c
  2130bc:	00228e40 	.word	0x00228e40

002130c0 <RefreshAllParam>:

static void RefreshAllParam(void)
{
  2130c0:	b580      	push	{r7, lr}
  2130c2:	af00      	add	r7, sp, #0
	Data2Refresh(FONTS);
  2130c4:	200c      	movs	r0, #12
  2130c6:	f7ff fde7 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COLOR_FONT);
  2130ca:	2002      	movs	r0, #2
  2130cc:	f7ff fde4 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COLOR_BK);
  2130d0:	2001      	movs	r0, #1
  2130d2:	f7ff fde1 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SIZE);
  2130d6:	2000      	movs	r0, #0
  2130d8:	f7ff fdde 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_STYLE);
  2130dc:	2005      	movs	r0, #5
  2130de:	f7ff fddb 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COEFF);
  2130e2:	2006      	movs	r0, #6
  2130e4:	f7ff fdd8 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_LEN_WINDOW);
  2130e8:	2003      	movs	r0, #3
  2130ea:	f7ff fdd5 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_OFFS_WINDOW);
  2130ee:	2004      	movs	r0, #4
  2130f0:	f7ff fdd2 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_LOAD_FONT_TIME);
  2130f4:	2008      	movs	r0, #8
  2130f6:	f7ff fdcf 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  2130fa:	2007      	movs	r0, #7
  2130fc:	f7ff fdcc 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_POS_CURSOR);
  213100:	2009      	movs	r0, #9
  213102:	f7ff fdc9 	bl	212c98 <Data2Refresh>
}
  213106:	bf00      	nop
  213108:	bd80      	pop	{r7, pc}
	...

0021310c <ChangeValRGB>:


void ChangeValRGB(char font_bk, char rgb, int32_t sign)
{
  21310c:	b580      	push	{r7, lr}
  21310e:	b084      	sub	sp, #16
  213110:	af00      	add	r7, sp, #0
  213112:	4603      	mov	r3, r0
  213114:	603a      	str	r2, [r7, #0]
  213116:	71fb      	strb	r3, [r7, #7]
  213118:	460b      	mov	r3, r1
  21311a:	71bb      	strb	r3, [r7, #6]
	int32_t *color;
	int idx;

	switch(font_bk)
  21311c:	79fb      	ldrb	r3, [r7, #7]
  21311e:	2b62      	cmp	r3, #98	; 0x62
  213120:	d002      	beq.n	213128 <ChangeValRGB+0x1c>
  213122:	2b66      	cmp	r3, #102	; 0x66
  213124:	d003      	beq.n	21312e <ChangeValRGB+0x22>
  213126:	e005      	b.n	213134 <ChangeValRGB+0x28>
	{
	case 'b': color=&Test.bk[0];	break;
  213128:	4b31      	ldr	r3, [pc, #196]	; (2131f0 <ChangeValRGB+0xe4>)
  21312a:	60fb      	str	r3, [r7, #12]
  21312c:	e002      	b.n	213134 <ChangeValRGB+0x28>
	case 'f': color=&Test.font[0];	break;
  21312e:	4b31      	ldr	r3, [pc, #196]	; (2131f4 <ChangeValRGB+0xe8>)
  213130:	60fb      	str	r3, [r7, #12]
  213132:	bf00      	nop
	}

	switch (rgb)
  213134:	79bb      	ldrb	r3, [r7, #6]
  213136:	2b47      	cmp	r3, #71	; 0x47
  213138:	d007      	beq.n	21314a <ChangeValRGB+0x3e>
  21313a:	2b52      	cmp	r3, #82	; 0x52
  21313c:	d002      	beq.n	213144 <ChangeValRGB+0x38>
  21313e:	2b42      	cmp	r3, #66	; 0x42
  213140:	d006      	beq.n	213150 <ChangeValRGB+0x44>
  213142:	e008      	b.n	213156 <ChangeValRGB+0x4a>
	{
	case 'R': idx=0; break;
  213144:	2300      	movs	r3, #0
  213146:	60bb      	str	r3, [r7, #8]
  213148:	e005      	b.n	213156 <ChangeValRGB+0x4a>
	case 'G': idx=1; break;
  21314a:	2301      	movs	r3, #1
  21314c:	60bb      	str	r3, [r7, #8]
  21314e:	e002      	b.n	213156 <ChangeValRGB+0x4a>
	case 'B': idx=2; break;
  213150:	2302      	movs	r3, #2
  213152:	60bb      	str	r3, [r7, #8]
  213154:	bf00      	nop
	}

	switch (sign)
  213156:	683b      	ldr	r3, [r7, #0]
  213158:	f1b3 3fff 	cmp.w	r3, #4294967295
  21315c:	d01c      	beq.n	213198 <ChangeValRGB+0x8c>
  21315e:	2b01      	cmp	r3, #1
  213160:	d136      	bne.n	2131d0 <ChangeValRGB+0xc4>
	{
	case 1:
		if(color[idx] <= 255-Test.step)
  213162:	68bb      	ldr	r3, [r7, #8]
  213164:	009b      	lsls	r3, r3, #2
  213166:	68fa      	ldr	r2, [r7, #12]
  213168:	4413      	add	r3, r2
  21316a:	681a      	ldr	r2, [r3, #0]
  21316c:	4b20      	ldr	r3, [pc, #128]	; (2131f0 <ChangeValRGB+0xe4>)
  21316e:	f993 301a 	ldrsb.w	r3, [r3, #26]
  213172:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
  213176:	429a      	cmp	r2, r3
  213178:	dc27      	bgt.n	2131ca <ChangeValRGB+0xbe>
			color[idx]+=Test.step;
  21317a:	68bb      	ldr	r3, [r7, #8]
  21317c:	009b      	lsls	r3, r3, #2
  21317e:	68fa      	ldr	r2, [r7, #12]
  213180:	4413      	add	r3, r2
  213182:	68ba      	ldr	r2, [r7, #8]
  213184:	0092      	lsls	r2, r2, #2
  213186:	68f9      	ldr	r1, [r7, #12]
  213188:	440a      	add	r2, r1
  21318a:	6812      	ldr	r2, [r2, #0]
  21318c:	4918      	ldr	r1, [pc, #96]	; (2131f0 <ChangeValRGB+0xe4>)
  21318e:	f991 101a 	ldrsb.w	r1, [r1, #26]
  213192:	440a      	add	r2, r1
  213194:	601a      	str	r2, [r3, #0]
		break;
  213196:	e018      	b.n	2131ca <ChangeValRGB+0xbe>
	case -1:
		if(color[idx] >= Test.step)
  213198:	68bb      	ldr	r3, [r7, #8]
  21319a:	009b      	lsls	r3, r3, #2
  21319c:	68fa      	ldr	r2, [r7, #12]
  21319e:	4413      	add	r3, r2
  2131a0:	681b      	ldr	r3, [r3, #0]
  2131a2:	4a13      	ldr	r2, [pc, #76]	; (2131f0 <ChangeValRGB+0xe4>)
  2131a4:	f992 201a 	ldrsb.w	r2, [r2, #26]
  2131a8:	4293      	cmp	r3, r2
  2131aa:	db10      	blt.n	2131ce <ChangeValRGB+0xc2>
			color[idx]-=Test.step;
  2131ac:	68bb      	ldr	r3, [r7, #8]
  2131ae:	009b      	lsls	r3, r3, #2
  2131b0:	68fa      	ldr	r2, [r7, #12]
  2131b2:	4413      	add	r3, r2
  2131b4:	68ba      	ldr	r2, [r7, #8]
  2131b6:	0092      	lsls	r2, r2, #2
  2131b8:	68f9      	ldr	r1, [r7, #12]
  2131ba:	440a      	add	r2, r1
  2131bc:	6812      	ldr	r2, [r2, #0]
  2131be:	490c      	ldr	r1, [pc, #48]	; (2131f0 <ChangeValRGB+0xe4>)
  2131c0:	f991 101a 	ldrsb.w	r1, [r1, #26]
  2131c4:	1a52      	subs	r2, r2, r1
  2131c6:	601a      	str	r2, [r3, #0]
		break;
  2131c8:	e001      	b.n	2131ce <ChangeValRGB+0xc2>
		break;
  2131ca:	bf00      	nop
  2131cc:	e000      	b.n	2131d0 <ChangeValRGB+0xc4>
		break;
  2131ce:	bf00      	nop
	}
	Data2Refresh(FONTS);
  2131d0:	200c      	movs	r0, #12
  2131d2:	f7ff fd61 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COLOR_FONT);
  2131d6:	2002      	movs	r0, #2
  2131d8:	f7ff fd5e 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COLOR_BK);
  2131dc:	2001      	movs	r0, #1
  2131de:	f7ff fd5b 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  2131e2:	2007      	movs	r0, #7
  2131e4:	f7ff fd58 	bl	212c98 <Data2Refresh>
}
  2131e8:	bf00      	nop
  2131ea:	3710      	adds	r7, #16
  2131ec:	46bd      	mov	sp, r7
  2131ee:	bd80      	pop	{r7, pc}
  2131f0:	200103c0 	.word	0x200103c0
  2131f4:	200103cc 	.word	0x200103cc

002131f8 <IncCoeffRGB>:
}
void DecStepRGB(void){
	Test.step<=0 ? 0 : Test.step--;
}

void IncCoeffRGB(void){
  2131f8:	b580      	push	{r7, lr}
  2131fa:	af00      	add	r7, sp, #0
	if(Test.type)
  2131fc:	4b16      	ldr	r3, [pc, #88]	; (213258 <IncCoeffRGB+0x60>)
  2131fe:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  213202:	2b00      	cmp	r3, #0
  213204:	d00e      	beq.n	213224 <IncCoeffRGB+0x2c>
		Test.coeff>=127 ? 127 : Test.coeff++;
  213206:	4b14      	ldr	r3, [pc, #80]	; (213258 <IncCoeffRGB+0x60>)
  213208:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  21320c:	2b7e      	cmp	r3, #126	; 0x7e
  21320e:	dc17      	bgt.n	213240 <IncCoeffRGB+0x48>
  213210:	4b11      	ldr	r3, [pc, #68]	; (213258 <IncCoeffRGB+0x60>)
  213212:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  213216:	b29b      	uxth	r3, r3
  213218:	3301      	adds	r3, #1
  21321a:	b29b      	uxth	r3, r3
  21321c:	b21a      	sxth	r2, r3
  21321e:	4b0e      	ldr	r3, [pc, #56]	; (213258 <IncCoeffRGB+0x60>)
  213220:	839a      	strh	r2, [r3, #28]
  213222:	e00d      	b.n	213240 <IncCoeffRGB+0x48>
	else
		Test.coeff>=255 ? 255 : Test.coeff++;
  213224:	4b0c      	ldr	r3, [pc, #48]	; (213258 <IncCoeffRGB+0x60>)
  213226:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  21322a:	2bfe      	cmp	r3, #254	; 0xfe
  21322c:	dc08      	bgt.n	213240 <IncCoeffRGB+0x48>
  21322e:	4b0a      	ldr	r3, [pc, #40]	; (213258 <IncCoeffRGB+0x60>)
  213230:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  213234:	b29b      	uxth	r3, r3
  213236:	3301      	adds	r3, #1
  213238:	b29b      	uxth	r3, r3
  21323a:	b21a      	sxth	r2, r3
  21323c:	4b06      	ldr	r3, [pc, #24]	; (213258 <IncCoeffRGB+0x60>)
  21323e:	839a      	strh	r2, [r3, #28]
	Data2Refresh(FONTS);
  213240:	200c      	movs	r0, #12
  213242:	f7ff fd29 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COEFF);
  213246:	2006      	movs	r0, #6
  213248:	f7ff fd26 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  21324c:	2007      	movs	r0, #7
  21324e:	f7ff fd23 	bl	212c98 <Data2Refresh>
}
  213252:	bf00      	nop
  213254:	bd80      	pop	{r7, pc}
  213256:	bf00      	nop
  213258:	200103c0 	.word	0x200103c0

0021325c <DecCoeefRGB>:
void DecCoeefRGB(void){
  21325c:	b580      	push	{r7, lr}
  21325e:	af00      	add	r7, sp, #0
	if(Test.type)
  213260:	4b16      	ldr	r3, [pc, #88]	; (2132bc <DecCoeefRGB+0x60>)
  213262:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  213266:	2b00      	cmp	r3, #0
  213268:	d00f      	beq.n	21328a <DecCoeefRGB+0x2e>
		Test.coeff<=-127 ? -127 : Test.coeff--;
  21326a:	4b14      	ldr	r3, [pc, #80]	; (2132bc <DecCoeefRGB+0x60>)
  21326c:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  213270:	f113 0f7e 	cmn.w	r3, #126	; 0x7e
  213274:	db17      	blt.n	2132a6 <DecCoeefRGB+0x4a>
  213276:	4b11      	ldr	r3, [pc, #68]	; (2132bc <DecCoeefRGB+0x60>)
  213278:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  21327c:	b29b      	uxth	r3, r3
  21327e:	3b01      	subs	r3, #1
  213280:	b29b      	uxth	r3, r3
  213282:	b21a      	sxth	r2, r3
  213284:	4b0d      	ldr	r3, [pc, #52]	; (2132bc <DecCoeefRGB+0x60>)
  213286:	839a      	strh	r2, [r3, #28]
  213288:	e00d      	b.n	2132a6 <DecCoeefRGB+0x4a>
	else
		Test.coeff<=0 ? 0 : Test.coeff--;
  21328a:	4b0c      	ldr	r3, [pc, #48]	; (2132bc <DecCoeefRGB+0x60>)
  21328c:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  213290:	2b00      	cmp	r3, #0
  213292:	dd08      	ble.n	2132a6 <DecCoeefRGB+0x4a>
  213294:	4b09      	ldr	r3, [pc, #36]	; (2132bc <DecCoeefRGB+0x60>)
  213296:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  21329a:	b29b      	uxth	r3, r3
  21329c:	3b01      	subs	r3, #1
  21329e:	b29b      	uxth	r3, r3
  2132a0:	b21a      	sxth	r2, r3
  2132a2:	4b06      	ldr	r3, [pc, #24]	; (2132bc <DecCoeefRGB+0x60>)
  2132a4:	839a      	strh	r2, [r3, #28]
	Data2Refresh(FONTS);
  2132a6:	200c      	movs	r0, #12
  2132a8:	f7ff fcf6 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COEFF);
  2132ac:	2006      	movs	r0, #6
  2132ae:	f7ff fcf3 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  2132b2:	2007      	movs	r0, #7
  2132b4:	f7ff fcf0 	bl	212c98 <Data2Refresh>
}
  2132b8:	bf00      	nop
  2132ba:	bd80      	pop	{r7, pc}
  2132bc:	200103c0 	.word	0x200103c0

002132c0 <ChangeTxt>:

int ChangeTxt(void){
  2132c0:	b580      	push	{r7, lr}
  2132c2:	af00      	add	r7, sp, #0
	return CopyCharsTab(Test.txt,Test.lenWin,Test.offsWin,Test.size);
  2132c4:	4b08      	ldr	r3, [pc, #32]	; (2132e8 <ChangeTxt+0x28>)
  2132c6:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  2132ca:	4619      	mov	r1, r3
  2132cc:	4b06      	ldr	r3, [pc, #24]	; (2132e8 <ChangeTxt+0x28>)
  2132ce:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  2132d2:	461a      	mov	r2, r3
  2132d4:	4b04      	ldr	r3, [pc, #16]	; (2132e8 <ChangeTxt+0x28>)
  2132d6:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2132da:	4804      	ldr	r0, [pc, #16]	; (2132ec <ChangeTxt+0x2c>)
  2132dc:	f7ff f902 	bl	2124e4 <CopyCharsTab>
  2132e0:	4603      	mov	r3, r0
}
  2132e2:	4618      	mov	r0, r3
  2132e4:	bd80      	pop	{r7, pc}
  2132e6:	bf00      	nop
  2132e8:	200103c0 	.word	0x200103c0
  2132ec:	200103e9 	.word	0x200103e9

002132f0 <ResetRGB>:

void ResetRGB(void)
{
  2132f0:	b580      	push	{r7, lr}
  2132f2:	af00      	add	r7, sp, #0
	Test.xFontsField=0;
  2132f4:	4b31      	ldr	r3, [pc, #196]	; (2133bc <ResetRGB+0xcc>)
  2132f6:	2200      	movs	r2, #0
  2132f8:	761a      	strb	r2, [r3, #24]

	Test.bk[0]=0;
  2132fa:	4b30      	ldr	r3, [pc, #192]	; (2133bc <ResetRGB+0xcc>)
  2132fc:	2200      	movs	r2, #0
  2132fe:	601a      	str	r2, [r3, #0]
	Test.bk[1]=0;
  213300:	4b2e      	ldr	r3, [pc, #184]	; (2133bc <ResetRGB+0xcc>)
  213302:	2200      	movs	r2, #0
  213304:	605a      	str	r2, [r3, #4]
	Test.bk[2]=0;
  213306:	4b2d      	ldr	r3, [pc, #180]	; (2133bc <ResetRGB+0xcc>)
  213308:	2200      	movs	r2, #0
  21330a:	609a      	str	r2, [r3, #8]

	Test.font[0]=255;
  21330c:	4b2b      	ldr	r3, [pc, #172]	; (2133bc <ResetRGB+0xcc>)
  21330e:	22ff      	movs	r2, #255	; 0xff
  213310:	60da      	str	r2, [r3, #12]
	Test.font[1]=255;
  213312:	4b2a      	ldr	r3, [pc, #168]	; (2133bc <ResetRGB+0xcc>)
  213314:	22ff      	movs	r2, #255	; 0xff
  213316:	611a      	str	r2, [r3, #16]
	Test.font[2]=255;
  213318:	4b28      	ldr	r3, [pc, #160]	; (2133bc <ResetRGB+0xcc>)
  21331a:	22ff      	movs	r2, #255	; 0xff
  21331c:	615a      	str	r2, [r3, #20]

	Test.step=5;
  21331e:	4b27      	ldr	r3, [pc, #156]	; (2133bc <ResetRGB+0xcc>)
  213320:	2205      	movs	r2, #5
  213322:	769a      	strb	r2, [r3, #26]
	Test.coeff=255;
  213324:	4b25      	ldr	r3, [pc, #148]	; (2133bc <ResetRGB+0xcc>)
  213326:	22ff      	movs	r2, #255	; 0xff
  213328:	839a      	strh	r2, [r3, #28]
	Test.coeff_prev=Test.coeff;
  21332a:	4b24      	ldr	r3, [pc, #144]	; (2133bc <ResetRGB+0xcc>)
  21332c:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
  213330:	4b22      	ldr	r3, [pc, #136]	; (2133bc <ResetRGB+0xcc>)
  213332:	83da      	strh	r2, [r3, #30]

	Test.type=0;
  213334:	4b21      	ldr	r3, [pc, #132]	; (2133bc <ResetRGB+0xcc>)
  213336:	2200      	movs	r2, #0
  213338:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	Test.speed=0;
  21333c:	4b1f      	ldr	r3, [pc, #124]	; (2133bc <ResetRGB+0xcc>)
  21333e:	2200      	movs	r2, #0
  213340:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc

	Test.size=FONT_8;
  213344:	4b1d      	ldr	r3, [pc, #116]	; (2133bc <ResetRGB+0xcc>)
  213346:	2200      	movs	r2, #0
  213348:	f883 2020 	strb.w	r2, [r3, #32]
	Test.style=Arial;
  21334c:	4b1b      	ldr	r3, [pc, #108]	; (2133bc <ResetRGB+0xcc>)
  21334e:	2205      	movs	r2, #5
  213350:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

	//strcpy(Test.txt,"abcd");

	Test.lenWin=4;
  213354:	4b19      	ldr	r3, [pc, #100]	; (2133bc <ResetRGB+0xcc>)
  213356:	2204      	movs	r2, #4
  213358:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	Test.offsWin=0;
  21335c:	4b17      	ldr	r3, [pc, #92]	; (2133bc <ResetRGB+0xcc>)
  21335e:	2200      	movs	r2, #0
  213360:	f8a3 20f4 	strh.w	r2, [r3, #244]	; 0xf4

	Test.lenWin_prev=Test.lenWin;
  213364:	4b15      	ldr	r3, [pc, #84]	; (2133bc <ResetRGB+0xcc>)
  213366:	f9b3 20f2 	ldrsh.w	r2, [r3, #242]	; 0xf2
  21336a:	4b14      	ldr	r3, [pc, #80]	; (2133bc <ResetRGB+0xcc>)
  21336c:	f8a3 20f6 	strh.w	r2, [r3, #246]	; 0xf6
	Test.offsWin_prev=Test.offsWin;
  213370:	4b12      	ldr	r3, [pc, #72]	; (2133bc <ResetRGB+0xcc>)
  213372:	f9b3 20f4 	ldrsh.w	r2, [r3, #244]	; 0xf4
  213376:	4b11      	ldr	r3, [pc, #68]	; (2133bc <ResetRGB+0xcc>)
  213378:	f8a3 20f8 	strh.w	r2, [r3, #248]	; 0xf8

   Test.posCursor=0;
  21337c:	4b0f      	ldr	r3, [pc, #60]	; (2133bc <ResetRGB+0xcc>)
  21337e:	2200      	movs	r2, #0
  213380:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104

	Test.normBoldItal=0;
  213384:	4b0d      	ldr	r3, [pc, #52]	; (2133bc <ResetRGB+0xcc>)
  213386:	2200      	movs	r2, #0
  213388:	f883 20fa 	strb.w	r2, [r3, #250]	; 0xfa

	Test.spaceCoursorY=0;
  21338c:	4b0b      	ldr	r3, [pc, #44]	; (2133bc <ResetRGB+0xcc>)
  21338e:	2200      	movs	r2, #0
  213390:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
	Test.heightCursor=1;
  213394:	4b09      	ldr	r3, [pc, #36]	; (2133bc <ResetRGB+0xcc>)
  213396:	2201      	movs	r2, #1
  213398:	f883 2106 	strb.w	r2, [r3, #262]	; 0x106
	Test.spaceBetweenFonts=0;
  21339c:	4b07      	ldr	r3, [pc, #28]	; (2133bc <ResetRGB+0xcc>)
  21339e:	2200      	movs	r2, #0
  2133a0:	f883 2107 	strb.w	r2, [r3, #263]	; 0x107
	Test.constWidth=0;
  2133a4:	4b05      	ldr	r3, [pc, #20]	; (2133bc <ResetRGB+0xcc>)
  2133a6:	2200      	movs	r2, #0
  2133a8:	f883 2109 	strb.w	r2, [r3, #265]	; 0x109
	Test.dispChangeColorOrNot=0;
  2133ac:	4b03      	ldr	r3, [pc, #12]	; (2133bc <ResetRGB+0xcc>)
  2133ae:	2200      	movs	r2, #0
  2133b0:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108


	ChangeTxt();
  2133b4:	f7ff ff84 	bl	2132c0 <ChangeTxt>
}
  2133b8:	bf00      	nop
  2133ba:	bd80      	pop	{r7, pc}
  2133bc:	200103c0 	.word	0x200103c0

002133c0 <LCD_LoadFontVar>:

static void LCD_LoadFontVar(uint32_t id)
{
  2133c0:	b580      	push	{r7, lr}
  2133c2:	b082      	sub	sp, #8
  2133c4:	af00      	add	r7, sp, #0
  2133c6:	6078      	str	r0, [r7, #4]
	LCD_DeleteFont(fontID_3);
  2133c8:	2002      	movs	r0, #2
  2133ca:	f7f7 fc69 	bl	20aca0 <LCD_DeleteFont>
	StartMeasureTime(0);
  2133ce:	2000      	movs	r0, #0
  2133d0:	f7ee fbc6 	bl	201b60 <StartMeasureTime>
	switch(Test.type)
  2133d4:	4b2a      	ldr	r3, [pc, #168]	; (213480 <LCD_LoadFontVar+0xc0>)
  2133d6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  2133da:	2b01      	cmp	r3, #1
  2133dc:	d012      	beq.n	213404 <LCD_LoadFontVar+0x44>
  2133de:	2b02      	cmp	r3, #2
  2133e0:	d01f      	beq.n	213422 <LCD_LoadFontVar+0x62>
  2133e2:	2b00      	cmp	r3, #0
  2133e4:	d12c      	bne.n	213440 <LCD_LoadFontVar+0x80>
	{
	case 0:
		fontIDVar=LCD_LoadFont_DarkgrayGreen(Test.size,Test.style,id);
  2133e6:	4b26      	ldr	r3, [pc, #152]	; (213480 <LCD_LoadFontVar+0xc0>)
  2133e8:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2133ec:	4618      	mov	r0, r3
  2133ee:	4b24      	ldr	r3, [pc, #144]	; (213480 <LCD_LoadFontVar+0xc0>)
  2133f0:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  2133f4:	687a      	ldr	r2, [r7, #4]
  2133f6:	4619      	mov	r1, r3
  2133f8:	f7f8 ffea 	bl	20c3d0 <LCD_LoadFont_DarkgrayGreen>
  2133fc:	4602      	mov	r2, r0
  2133fe:	4b21      	ldr	r3, [pc, #132]	; (213484 <LCD_LoadFontVar+0xc4>)
  213400:	601a      	str	r2, [r3, #0]
		break;
  213402:	e01d      	b.n	213440 <LCD_LoadFontVar+0x80>
	case 1:
		fontIDVar=LCD_LoadFont_DarkgrayWhite(Test.size,Test.style,id);
  213404:	4b1e      	ldr	r3, [pc, #120]	; (213480 <LCD_LoadFontVar+0xc0>)
  213406:	f993 3020 	ldrsb.w	r3, [r3, #32]
  21340a:	4618      	mov	r0, r3
  21340c:	4b1c      	ldr	r3, [pc, #112]	; (213480 <LCD_LoadFontVar+0xc0>)
  21340e:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  213412:	687a      	ldr	r2, [r7, #4]
  213414:	4619      	mov	r1, r3
  213416:	f7f8 fff1 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
  21341a:	4602      	mov	r2, r0
  21341c:	4b19      	ldr	r3, [pc, #100]	; (213484 <LCD_LoadFontVar+0xc4>)
  21341e:	601a      	str	r2, [r3, #0]
		break;
  213420:	e00e      	b.n	213440 <LCD_LoadFontVar+0x80>
	case 2:
		fontIDVar=LCD_LoadFont_WhiteBlack(Test.size,Test.style,id);
  213422:	4b17      	ldr	r3, [pc, #92]	; (213480 <LCD_LoadFontVar+0xc0>)
  213424:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213428:	4618      	mov	r0, r3
  21342a:	4b15      	ldr	r3, [pc, #84]	; (213480 <LCD_LoadFontVar+0xc0>)
  21342c:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  213430:	687a      	ldr	r2, [r7, #4]
  213432:	4619      	mov	r1, r3
  213434:	f7f8 ffb6 	bl	20c3a4 <LCD_LoadFont_WhiteBlack>
  213438:	4602      	mov	r2, r0
  21343a:	4b12      	ldr	r3, [pc, #72]	; (213484 <LCD_LoadFontVar+0xc4>)
  21343c:	601a      	str	r2, [r3, #0]
		break;
  21343e:	bf00      	nop
	}
	Test.loadFontTime=StopMeasureTime(0,"");
  213440:	4911      	ldr	r1, [pc, #68]	; (213488 <LCD_LoadFontVar+0xc8>)
  213442:	2000      	movs	r0, #0
  213444:	f7ee fba0 	bl	201b88 <StopMeasureTime>
  213448:	4602      	mov	r2, r0
  21344a:	4b0d      	ldr	r3, [pc, #52]	; (213480 <LCD_LoadFontVar+0xc0>)
  21344c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100

	if(fontIDVar<0){
  213450:	4b0c      	ldr	r3, [pc, #48]	; (213484 <LCD_LoadFontVar+0xc4>)
  213452:	681b      	ldr	r3, [r3, #0]
  213454:	2b00      	cmp	r3, #0
  213456:	da06      	bge.n	213466 <LCD_LoadFontVar+0xa6>
		Dbg(1,"\r\nERROR_LoadFontVar ");
  213458:	490c      	ldr	r1, [pc, #48]	; (21348c <LCD_LoadFontVar+0xcc>)
  21345a:	2001      	movs	r0, #1
  21345c:	f7ed fa26 	bl	2008ac <Dbg>
		fontIDVar=0;
  213460:	4b08      	ldr	r3, [pc, #32]	; (213484 <LCD_LoadFontVar+0xc4>)
  213462:	2200      	movs	r2, #0
  213464:	601a      	str	r2, [r3, #0]
	}
	DisplayFontsStructState();
  213466:	f7f7 ffe7 	bl	20b438 <DisplayFontsStructState>
	if(startScreen) Data2Refresh(PARAM_LOAD_FONT_TIME);
  21346a:	4b09      	ldr	r3, [pc, #36]	; (213490 <LCD_LoadFontVar+0xd0>)
  21346c:	681b      	ldr	r3, [r3, #0]
  21346e:	2b00      	cmp	r3, #0
  213470:	d002      	beq.n	213478 <LCD_LoadFontVar+0xb8>
  213472:	2008      	movs	r0, #8
  213474:	f7ff fc10 	bl	212c98 <Data2Refresh>
}
  213478:	bf00      	nop
  21347a:	3708      	adds	r7, #8
  21347c:	46bd      	mov	sp, r7
  21347e:	bd80      	pop	{r7, pc}
  213480:	200103c0 	.word	0x200103c0
  213484:	200103b8 	.word	0x200103b8
  213488:	00228e30 	.word	0x00228e30
  21348c:	00228e44 	.word	0x00228e44
  213490:	200104cc 	.word	0x200104cc

00213494 <AdjustMiddle_X>:

static void AdjustMiddle_X(void){
  213494:	b580      	push	{r7, lr}
  213496:	b082      	sub	sp, #8
  213498:	af02      	add	r7, sp, #8
	LCD_SetStrVar_x(STR_ID_Fonts,LCD_Xmiddle(GetPos,fontIDVar,Test.txt,Test.spaceBetweenFonts,Test.constWidth));
  21349a:	4b0c      	ldr	r3, [pc, #48]	; (2134cc <AdjustMiddle_X+0x38>)
  21349c:	681b      	ldr	r3, [r3, #0]
  21349e:	4619      	mov	r1, r3
  2134a0:	4b0b      	ldr	r3, [pc, #44]	; (2134d0 <AdjustMiddle_X+0x3c>)
  2134a2:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  2134a6:	461a      	mov	r2, r3
  2134a8:	4b09      	ldr	r3, [pc, #36]	; (2134d0 <AdjustMiddle_X+0x3c>)
  2134aa:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
  2134ae:	9300      	str	r3, [sp, #0]
  2134b0:	4613      	mov	r3, r2
  2134b2:	4a08      	ldr	r2, [pc, #32]	; (2134d4 <AdjustMiddle_X+0x40>)
  2134b4:	2001      	movs	r0, #1
  2134b6:	f7ff fac5 	bl	212a44 <LCD_Xmiddle>
  2134ba:	4603      	mov	r3, r0
  2134bc:	4619      	mov	r1, r3
  2134be:	200a      	movs	r0, #10
  2134c0:	f7f7 fa5c 	bl	20a97c <LCD_SetStrVar_x>
}
  2134c4:	bf00      	nop
  2134c6:	46bd      	mov	sp, r7
  2134c8:	bd80      	pop	{r7, pc}
  2134ca:	bf00      	nop
  2134cc:	200103b8 	.word	0x200103b8
  2134d0:	200103c0 	.word	0x200103c0
  2134d4:	200103e9 	.word	0x200103e9

002134d8 <AdjustMiddle_Y>:
static void AdjustMiddle_Y(void){
  2134d8:	b580      	push	{r7, lr}
  2134da:	af00      	add	r7, sp, #0
	LCD_SetStrVar_y(STR_ID_Fonts,LCD_Ymiddle(GetPos,fontIDVar));
  2134dc:	4b06      	ldr	r3, [pc, #24]	; (2134f8 <AdjustMiddle_Y+0x20>)
  2134de:	681b      	ldr	r3, [r3, #0]
  2134e0:	4619      	mov	r1, r3
  2134e2:	2001      	movs	r0, #1
  2134e4:	f7ff fa7c 	bl	2129e0 <LCD_Ymiddle>
  2134e8:	4603      	mov	r3, r0
  2134ea:	4619      	mov	r1, r3
  2134ec:	200a      	movs	r0, #10
  2134ee:	f7f7 fa5f 	bl	20a9b0 <LCD_SetStrVar_y>
}
  2134f2:	bf00      	nop
  2134f4:	bd80      	pop	{r7, pc}
  2134f6:	bf00      	nop
  2134f8:	200103b8 	.word	0x200103b8

002134fc <ChangeFontStyle>:

void ChangeFontStyle(void)
{
  2134fc:	b580      	push	{r7, lr}
  2134fe:	af00      	add	r7, sp, #0
	switch(Test.style)
  213500:	4b1e      	ldr	r3, [pc, #120]	; (21357c <ChangeFontStyle+0x80>)
  213502:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  213506:	2b04      	cmp	r3, #4
  213508:	d009      	beq.n	21351e <ChangeFontStyle+0x22>
  21350a:	2b05      	cmp	r3, #5
  21350c:	d002      	beq.n	213514 <ChangeFontStyle+0x18>
  21350e:	2b03      	cmp	r3, #3
  213510:	d00a      	beq.n	213528 <ChangeFontStyle+0x2c>
  213512:	e00e      	b.n	213532 <ChangeFontStyle+0x36>
	{
	case Arial:   			 Test.style=Times_New_Roman; break;
  213514:	4b19      	ldr	r3, [pc, #100]	; (21357c <ChangeFontStyle+0x80>)
  213516:	2204      	movs	r2, #4
  213518:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  21351c:	e00e      	b.n	21353c <ChangeFontStyle+0x40>
	case Times_New_Roman: Test.style=Comic_Saens_MS;  break;
  21351e:	4b17      	ldr	r3, [pc, #92]	; (21357c <ChangeFontStyle+0x80>)
  213520:	2203      	movs	r2, #3
  213522:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  213526:	e009      	b.n	21353c <ChangeFontStyle+0x40>
	case Comic_Saens_MS:  Test.style=Arial; 			 break;
  213528:	4b14      	ldr	r3, [pc, #80]	; (21357c <ChangeFontStyle+0x80>)
  21352a:	2205      	movs	r2, #5
  21352c:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  213530:	e004      	b.n	21353c <ChangeFontStyle+0x40>
	default:              Test.style=Arial;           break;
  213532:	4b12      	ldr	r3, [pc, #72]	; (21357c <ChangeFontStyle+0x80>)
  213534:	2205      	movs	r2, #5
  213536:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  21353a:	bf00      	nop
	}
	ClearCursorField();
  21353c:	f7ff fade 	bl	212afc <ClearCursorField>
	LCD_LoadFontVar(fontID_3);
  213540:	2002      	movs	r0, #2
  213542:	f7ff ff3d 	bl	2133c0 <LCD_LoadFontVar>
	AdjustMiddle_X();
  213546:	f7ff ffa5 	bl	213494 <AdjustMiddle_X>
	AdjustMiddle_Y();
  21354a:	f7ff ffc5 	bl	2134d8 <AdjustMiddle_Y>
	Data2Refresh(FONTS);
  21354e:	200c      	movs	r0, #12
  213550:	f7ff fba2 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  213554:	4b0a      	ldr	r3, [pc, #40]	; (213580 <ChangeFontStyle+0x84>)
  213556:	881b      	ldrh	r3, [r3, #0]
  213558:	b21a      	sxth	r2, r3
  21355a:	4b08      	ldr	r3, [pc, #32]	; (21357c <ChangeFontStyle+0x80>)
  21355c:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  213560:	f7ff fb04 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  213564:	2003      	movs	r0, #3
  213566:	f7ff fb97 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_STYLE);
  21356a:	2005      	movs	r0, #5
  21356c:	f7ff fb94 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  213570:	2007      	movs	r0, #7
  213572:	f7ff fb91 	bl	212c98 <Data2Refresh>
}
  213576:	bf00      	nop
  213578:	bd80      	pop	{r7, pc}
  21357a:	bf00      	nop
  21357c:	200103c0 	.word	0x200103c0
  213580:	20014a44 	.word	0x20014a44

00213584 <Inc_lenWin>:

void Inc_lenWin(void){
  213584:	b580      	push	{r7, lr}
  213586:	af00      	add	r7, sp, #0
	Test.lenWin++;
  213588:	4b1f      	ldr	r3, [pc, #124]	; (213608 <Inc_lenWin+0x84>)
  21358a:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  21358e:	b29b      	uxth	r3, r3
  213590:	3301      	adds	r3, #1
  213592:	b29b      	uxth	r3, r3
  213594:	b21a      	sxth	r2, r3
  213596:	4b1c      	ldr	r3, [pc, #112]	; (213608 <Inc_lenWin+0x84>)
  213598:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	if(ChangeTxt()){
  21359c:	f7ff fe90 	bl	2132c0 <ChangeTxt>
  2135a0:	4603      	mov	r3, r0
  2135a2:	2b00      	cmp	r3, #0
  2135a4:	d00c      	beq.n	2135c0 <Inc_lenWin+0x3c>
		Test.lenWin--;
  2135a6:	4b18      	ldr	r3, [pc, #96]	; (213608 <Inc_lenWin+0x84>)
  2135a8:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  2135ac:	b29b      	uxth	r3, r3
  2135ae:	3b01      	subs	r3, #1
  2135b0:	b29b      	uxth	r3, r3
  2135b2:	b21a      	sxth	r2, r3
  2135b4:	4b14      	ldr	r3, [pc, #80]	; (213608 <Inc_lenWin+0x84>)
  2135b6:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
		ChangeTxt();
  2135ba:	f7ff fe81 	bl	2132c0 <ChangeTxt>
  2135be:	e01e      	b.n	2135fe <Inc_lenWin+0x7a>
	}
	else{
		lenTxt_prev=lenStr.inChar;
  2135c0:	4b12      	ldr	r3, [pc, #72]	; (21360c <Inc_lenWin+0x88>)
  2135c2:	881b      	ldrh	r3, [r3, #0]
  2135c4:	461a      	mov	r2, r3
  2135c6:	4b12      	ldr	r3, [pc, #72]	; (213610 <Inc_lenWin+0x8c>)
  2135c8:	601a      	str	r2, [r3, #0]
		AdjustMiddle_X();
  2135ca:	f7ff ff63 	bl	213494 <AdjustMiddle_X>
		Data2Refresh(FONTS);
  2135ce:	200c      	movs	r0, #12
  2135d0:	f7ff fb62 	bl	212c98 <Data2Refresh>
		if(lenTxt_prev==lenStr.inChar)
  2135d4:	4b0d      	ldr	r3, [pc, #52]	; (21360c <Inc_lenWin+0x88>)
  2135d6:	881b      	ldrh	r3, [r3, #0]
  2135d8:	461a      	mov	r2, r3
  2135da:	4b0d      	ldr	r3, [pc, #52]	; (213610 <Inc_lenWin+0x8c>)
  2135dc:	681b      	ldr	r3, [r3, #0]
  2135de:	429a      	cmp	r2, r3
  2135e0:	d10a      	bne.n	2135f8 <Inc_lenWin+0x74>
			Test.lenWin--;
  2135e2:	4b09      	ldr	r3, [pc, #36]	; (213608 <Inc_lenWin+0x84>)
  2135e4:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  2135e8:	b29b      	uxth	r3, r3
  2135ea:	3b01      	subs	r3, #1
  2135ec:	b29b      	uxth	r3, r3
  2135ee:	b21a      	sxth	r2, r3
  2135f0:	4b05      	ldr	r3, [pc, #20]	; (213608 <Inc_lenWin+0x84>)
  2135f2:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
  2135f6:	e002      	b.n	2135fe <Inc_lenWin+0x7a>
		else
			Data2Refresh(PARAM_LEN_WINDOW);
  2135f8:	2003      	movs	r0, #3
  2135fa:	f7ff fb4d 	bl	212c98 <Data2Refresh>
	}
	Data2Refresh(PARAM_SPEED);
  2135fe:	2007      	movs	r0, #7
  213600:	f7ff fb4a 	bl	212c98 <Data2Refresh>
}
  213604:	bf00      	nop
  213606:	bd80      	pop	{r7, pc}
  213608:	200103c0 	.word	0x200103c0
  21360c:	20014a44 	.word	0x20014a44
  213610:	200103bc 	.word	0x200103bc

00213614 <Dec_lenWin>:
void Dec_lenWin(void){
  213614:	b580      	push	{r7, lr}
  213616:	af00      	add	r7, sp, #0
	Test.lenWin<=1 ? 1 : Test.lenWin--;
  213618:	4b13      	ldr	r3, [pc, #76]	; (213668 <Dec_lenWin+0x54>)
  21361a:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  21361e:	2b01      	cmp	r3, #1
  213620:	dd09      	ble.n	213636 <Dec_lenWin+0x22>
  213622:	4b11      	ldr	r3, [pc, #68]	; (213668 <Dec_lenWin+0x54>)
  213624:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  213628:	b29b      	uxth	r3, r3
  21362a:	3b01      	subs	r3, #1
  21362c:	b29b      	uxth	r3, r3
  21362e:	b21a      	sxth	r2, r3
  213630:	4b0d      	ldr	r3, [pc, #52]	; (213668 <Dec_lenWin+0x54>)
  213632:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	ChangeTxt();
  213636:	f7ff fe43 	bl	2132c0 <ChangeTxt>
	ClearCursorField();
  21363a:	f7ff fa5f 	bl	212afc <ClearCursorField>
	AdjustMiddle_X();
  21363e:	f7ff ff29 	bl	213494 <AdjustMiddle_X>
	Data2Refresh(FONTS);
  213642:	200c      	movs	r0, #12
  213644:	f7ff fb28 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  213648:	4b08      	ldr	r3, [pc, #32]	; (21366c <Dec_lenWin+0x58>)
  21364a:	881b      	ldrh	r3, [r3, #0]
  21364c:	b21a      	sxth	r2, r3
  21364e:	4b06      	ldr	r3, [pc, #24]	; (213668 <Dec_lenWin+0x54>)
  213650:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  213654:	f7ff fa8a 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  213658:	2003      	movs	r0, #3
  21365a:	f7ff fb1d 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  21365e:	2007      	movs	r0, #7
  213660:	f7ff fb1a 	bl	212c98 <Data2Refresh>
}
  213664:	bf00      	nop
  213666:	bd80      	pop	{r7, pc}
  213668:	200103c0 	.word	0x200103c0
  21366c:	20014a44 	.word	0x20014a44

00213670 <Inc_offsWin>:

void Inc_offsWin(void){
  213670:	b580      	push	{r7, lr}
  213672:	af00      	add	r7, sp, #0
	Test.offsWin++;
  213674:	4b1a      	ldr	r3, [pc, #104]	; (2136e0 <Inc_offsWin+0x70>)
  213676:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  21367a:	b29b      	uxth	r3, r3
  21367c:	3301      	adds	r3, #1
  21367e:	b29b      	uxth	r3, r3
  213680:	b21a      	sxth	r2, r3
  213682:	4b17      	ldr	r3, [pc, #92]	; (2136e0 <Inc_offsWin+0x70>)
  213684:	f8a3 20f4 	strh.w	r2, [r3, #244]	; 0xf4
	if(ChangeTxt()){
  213688:	f7ff fe1a 	bl	2132c0 <ChangeTxt>
  21368c:	4603      	mov	r3, r0
  21368e:	2b00      	cmp	r3, #0
  213690:	d00b      	beq.n	2136aa <Inc_offsWin+0x3a>
		Test.offsWin--;
  213692:	4b13      	ldr	r3, [pc, #76]	; (2136e0 <Inc_offsWin+0x70>)
  213694:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  213698:	b29b      	uxth	r3, r3
  21369a:	3b01      	subs	r3, #1
  21369c:	b29b      	uxth	r3, r3
  21369e:	b21a      	sxth	r2, r3
  2136a0:	4b0f      	ldr	r3, [pc, #60]	; (2136e0 <Inc_offsWin+0x70>)
  2136a2:	f8a3 20f4 	strh.w	r2, [r3, #244]	; 0xf4
		ChangeTxt();
  2136a6:	f7ff fe0b 	bl	2132c0 <ChangeTxt>
	}
	ClearCursorField();
  2136aa:	f7ff fa27 	bl	212afc <ClearCursorField>
	AdjustMiddle_X();
  2136ae:	f7ff fef1 	bl	213494 <AdjustMiddle_X>
	Data2Refresh(FONTS);
  2136b2:	200c      	movs	r0, #12
  2136b4:	f7ff faf0 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  2136b8:	4b0a      	ldr	r3, [pc, #40]	; (2136e4 <Inc_offsWin+0x74>)
  2136ba:	881b      	ldrh	r3, [r3, #0]
  2136bc:	b21a      	sxth	r2, r3
  2136be:	4b08      	ldr	r3, [pc, #32]	; (2136e0 <Inc_offsWin+0x70>)
  2136c0:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  2136c4:	f7ff fa52 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  2136c8:	2003      	movs	r0, #3
  2136ca:	f7ff fae5 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_OFFS_WINDOW);
  2136ce:	2004      	movs	r0, #4
  2136d0:	f7ff fae2 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  2136d4:	2007      	movs	r0, #7
  2136d6:	f7ff fadf 	bl	212c98 <Data2Refresh>
}
  2136da:	bf00      	nop
  2136dc:	bd80      	pop	{r7, pc}
  2136de:	bf00      	nop
  2136e0:	200103c0 	.word	0x200103c0
  2136e4:	20014a44 	.word	0x20014a44

002136e8 <Dec_offsWin>:
void Dec_offsWin(void){
  2136e8:	b580      	push	{r7, lr}
  2136ea:	af00      	add	r7, sp, #0
	Test.offsWin<=0 ? 0 : Test.offsWin--;
  2136ec:	4b15      	ldr	r3, [pc, #84]	; (213744 <Dec_offsWin+0x5c>)
  2136ee:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  2136f2:	2b00      	cmp	r3, #0
  2136f4:	dd09      	ble.n	21370a <Dec_offsWin+0x22>
  2136f6:	4b13      	ldr	r3, [pc, #76]	; (213744 <Dec_offsWin+0x5c>)
  2136f8:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  2136fc:	b29b      	uxth	r3, r3
  2136fe:	3b01      	subs	r3, #1
  213700:	b29b      	uxth	r3, r3
  213702:	b21a      	sxth	r2, r3
  213704:	4b0f      	ldr	r3, [pc, #60]	; (213744 <Dec_offsWin+0x5c>)
  213706:	f8a3 20f4 	strh.w	r2, [r3, #244]	; 0xf4
	ChangeTxt();
  21370a:	f7ff fdd9 	bl	2132c0 <ChangeTxt>
	ClearCursorField();
  21370e:	f7ff f9f5 	bl	212afc <ClearCursorField>
	AdjustMiddle_X();
  213712:	f7ff febf 	bl	213494 <AdjustMiddle_X>
	Data2Refresh(FONTS);
  213716:	200c      	movs	r0, #12
  213718:	f7ff fabe 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  21371c:	4b0a      	ldr	r3, [pc, #40]	; (213748 <Dec_offsWin+0x60>)
  21371e:	881b      	ldrh	r3, [r3, #0]
  213720:	b21a      	sxth	r2, r3
  213722:	4b08      	ldr	r3, [pc, #32]	; (213744 <Dec_offsWin+0x5c>)
  213724:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  213728:	f7ff fa20 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  21372c:	2003      	movs	r0, #3
  21372e:	f7ff fab3 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_OFFS_WINDOW);
  213732:	2004      	movs	r0, #4
  213734:	f7ff fab0 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  213738:	2007      	movs	r0, #7
  21373a:	f7ff faad 	bl	212c98 <Data2Refresh>
}
  21373e:	bf00      	nop
  213740:	bd80      	pop	{r7, pc}
  213742:	bf00      	nop
  213744:	200103c0 	.word	0x200103c0
  213748:	20014a44 	.word	0x20014a44

0021374c <IncFontSize>:

void IncFontSize(void)
{
  21374c:	b580      	push	{r7, lr}
  21374e:	b082      	sub	sp, #8
  213750:	af00      	add	r7, sp, #0
	int sizeLimit;
	Test.size+=3;
  213752:	4b3d      	ldr	r3, [pc, #244]	; (213848 <IncFontSize+0xfc>)
  213754:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213758:	b2db      	uxtb	r3, r3
  21375a:	3303      	adds	r3, #3
  21375c:	b2db      	uxtb	r3, r3
  21375e:	b25a      	sxtb	r2, r3
  213760:	4b39      	ldr	r3, [pc, #228]	; (213848 <IncFontSize+0xfc>)
  213762:	f883 2020 	strb.w	r2, [r3, #32]
	switch(Test.normBoldItal)
  213766:	4b38      	ldr	r3, [pc, #224]	; (213848 <IncFontSize+0xfc>)
  213768:	f893 30fa 	ldrb.w	r3, [r3, #250]	; 0xfa
  21376c:	2b01      	cmp	r3, #1
  21376e:	d004      	beq.n	21377a <IncFontSize+0x2e>
  213770:	2b02      	cmp	r3, #2
  213772:	d005      	beq.n	213780 <IncFontSize+0x34>
	{
	default:
	case 0:  sizeLimit=FONT_130; 			break;
  213774:	2330      	movs	r3, #48	; 0x30
  213776:	607b      	str	r3, [r7, #4]
  213778:	e005      	b.n	213786 <IncFontSize+0x3a>
	case 1:  sizeLimit=FONT_130_bold; 	break;
  21377a:	2331      	movs	r3, #49	; 0x31
  21377c:	607b      	str	r3, [r7, #4]
  21377e:	e002      	b.n	213786 <IncFontSize+0x3a>
	case 2:  sizeLimit=FONT_130_italics; break;
  213780:	2332      	movs	r3, #50	; 0x32
  213782:	607b      	str	r3, [r7, #4]
  213784:	bf00      	nop
	}
	if(Test.size>sizeLimit){
  213786:	4b30      	ldr	r3, [pc, #192]	; (213848 <IncFontSize+0xfc>)
  213788:	f993 3020 	ldrsb.w	r3, [r3, #32]
  21378c:	461a      	mov	r2, r3
  21378e:	687b      	ldr	r3, [r7, #4]
  213790:	429a      	cmp	r2, r3
  213792:	dd05      	ble.n	2137a0 <IncFontSize+0x54>
		Test.size=sizeLimit;
  213794:	687b      	ldr	r3, [r7, #4]
  213796:	b25a      	sxtb	r2, r3
  213798:	4b2b      	ldr	r3, [pc, #172]	; (213848 <IncFontSize+0xfc>)
  21379a:	f883 2020 	strb.w	r2, [r3, #32]
		return;
  21379e:	e050      	b.n	213842 <IncFontSize+0xf6>
	}
	ClearCursorField();
  2137a0:	f7ff f9ac 	bl	212afc <ClearCursorField>
	LCD_LoadFontVar(fontID_3);
  2137a4:	2002      	movs	r0, #2
  2137a6:	f7ff fe0b 	bl	2133c0 <LCD_LoadFontVar>
	if((Test.size==FONT_72)||(Test.size==FONT_72_bold)||(Test.size==FONT_72_italics)||
  2137aa:	4b27      	ldr	r3, [pc, #156]	; (213848 <IncFontSize+0xfc>)
  2137ac:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2137b0:	2b2d      	cmp	r3, #45	; 0x2d
  2137b2:	d018      	beq.n	2137e6 <IncFontSize+0x9a>
  2137b4:	4b24      	ldr	r3, [pc, #144]	; (213848 <IncFontSize+0xfc>)
  2137b6:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2137ba:	2b2e      	cmp	r3, #46	; 0x2e
  2137bc:	d013      	beq.n	2137e6 <IncFontSize+0x9a>
  2137be:	4b22      	ldr	r3, [pc, #136]	; (213848 <IncFontSize+0xfc>)
  2137c0:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2137c4:	2b2f      	cmp	r3, #47	; 0x2f
  2137c6:	d00e      	beq.n	2137e6 <IncFontSize+0x9a>
	   (Test.size==FONT_130)||(Test.size==FONT_130_bold)||(Test.size==FONT_130_italics)){
  2137c8:	4b1f      	ldr	r3, [pc, #124]	; (213848 <IncFontSize+0xfc>)
  2137ca:	f993 3020 	ldrsb.w	r3, [r3, #32]
	if((Test.size==FONT_72)||(Test.size==FONT_72_bold)||(Test.size==FONT_72_italics)||
  2137ce:	2b30      	cmp	r3, #48	; 0x30
  2137d0:	d009      	beq.n	2137e6 <IncFontSize+0x9a>
	   (Test.size==FONT_130)||(Test.size==FONT_130_bold)||(Test.size==FONT_130_italics)){
  2137d2:	4b1d      	ldr	r3, [pc, #116]	; (213848 <IncFontSize+0xfc>)
  2137d4:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2137d8:	2b31      	cmp	r3, #49	; 0x31
  2137da:	d004      	beq.n	2137e6 <IncFontSize+0x9a>
  2137dc:	4b1a      	ldr	r3, [pc, #104]	; (213848 <IncFontSize+0xfc>)
  2137de:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2137e2:	2b32      	cmp	r3, #50	; 0x32
  2137e4:	d115      	bne.n	213812 <IncFontSize+0xc6>
		Test.lenWin_prev=Test.lenWin;
  2137e6:	4b18      	ldr	r3, [pc, #96]	; (213848 <IncFontSize+0xfc>)
  2137e8:	f9b3 20f2 	ldrsh.w	r2, [r3, #242]	; 0xf2
  2137ec:	4b16      	ldr	r3, [pc, #88]	; (213848 <IncFontSize+0xfc>)
  2137ee:	f8a3 20f6 	strh.w	r2, [r3, #246]	; 0xf6
		Test.offsWin_prev=Test.offsWin;
  2137f2:	4b15      	ldr	r3, [pc, #84]	; (213848 <IncFontSize+0xfc>)
  2137f4:	f9b3 20f4 	ldrsh.w	r2, [r3, #244]	; 0xf4
  2137f8:	4b13      	ldr	r3, [pc, #76]	; (213848 <IncFontSize+0xfc>)
  2137fa:	f8a3 20f8 	strh.w	r2, [r3, #248]	; 0xf8
		Test.lenWin=8;
  2137fe:	4b12      	ldr	r3, [pc, #72]	; (213848 <IncFontSize+0xfc>)
  213800:	2208      	movs	r2, #8
  213802:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
		Test.offsWin=0;
  213806:	4b10      	ldr	r3, [pc, #64]	; (213848 <IncFontSize+0xfc>)
  213808:	2200      	movs	r2, #0
  21380a:	f8a3 20f4 	strh.w	r2, [r3, #244]	; 0xf4
		ChangeTxt();
  21380e:	f7ff fd57 	bl	2132c0 <ChangeTxt>
	}
	AdjustMiddle_X();
  213812:	f7ff fe3f 	bl	213494 <AdjustMiddle_X>
	AdjustMiddle_Y();
  213816:	f7ff fe5f 	bl	2134d8 <AdjustMiddle_Y>
	Data2Refresh(FONTS);
  21381a:	200c      	movs	r0, #12
  21381c:	f7ff fa3c 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  213820:	4b0a      	ldr	r3, [pc, #40]	; (21384c <IncFontSize+0x100>)
  213822:	881b      	ldrh	r3, [r3, #0]
  213824:	b21a      	sxth	r2, r3
  213826:	4b08      	ldr	r3, [pc, #32]	; (213848 <IncFontSize+0xfc>)
  213828:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  21382c:	f7ff f99e 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  213830:	2003      	movs	r0, #3
  213832:	f7ff fa31 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SIZE);
  213836:	2000      	movs	r0, #0
  213838:	f7ff fa2e 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  21383c:	2007      	movs	r0, #7
  21383e:	f7ff fa2b 	bl	212c98 <Data2Refresh>
}
  213842:	3708      	adds	r7, #8
  213844:	46bd      	mov	sp, r7
  213846:	bd80      	pop	{r7, pc}
  213848:	200103c0 	.word	0x200103c0
  21384c:	20014a44 	.word	0x20014a44

00213850 <DecFontSize>:

void DecFontSize(void)
{
  213850:	b580      	push	{r7, lr}
  213852:	b082      	sub	sp, #8
  213854:	af00      	add	r7, sp, #0
	int sizeLimit;
	if((Test.size==FONT_72)||(Test.size==FONT_72_bold)||(Test.size==FONT_72_italics)||
  213856:	4b39      	ldr	r3, [pc, #228]	; (21393c <DecFontSize+0xec>)
  213858:	f993 3020 	ldrsb.w	r3, [r3, #32]
  21385c:	2b2d      	cmp	r3, #45	; 0x2d
  21385e:	d018      	beq.n	213892 <DecFontSize+0x42>
  213860:	4b36      	ldr	r3, [pc, #216]	; (21393c <DecFontSize+0xec>)
  213862:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213866:	2b2e      	cmp	r3, #46	; 0x2e
  213868:	d013      	beq.n	213892 <DecFontSize+0x42>
  21386a:	4b34      	ldr	r3, [pc, #208]	; (21393c <DecFontSize+0xec>)
  21386c:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213870:	2b2f      	cmp	r3, #47	; 0x2f
  213872:	d00e      	beq.n	213892 <DecFontSize+0x42>
	   (Test.size==FONT_130)||(Test.size==FONT_130_bold)||(Test.size==FONT_130_italics)){
  213874:	4b31      	ldr	r3, [pc, #196]	; (21393c <DecFontSize+0xec>)
  213876:	f993 3020 	ldrsb.w	r3, [r3, #32]
	if((Test.size==FONT_72)||(Test.size==FONT_72_bold)||(Test.size==FONT_72_italics)||
  21387a:	2b30      	cmp	r3, #48	; 0x30
  21387c:	d009      	beq.n	213892 <DecFontSize+0x42>
	   (Test.size==FONT_130)||(Test.size==FONT_130_bold)||(Test.size==FONT_130_italics)){
  21387e:	4b2f      	ldr	r3, [pc, #188]	; (21393c <DecFontSize+0xec>)
  213880:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213884:	2b31      	cmp	r3, #49	; 0x31
  213886:	d004      	beq.n	213892 <DecFontSize+0x42>
  213888:	4b2c      	ldr	r3, [pc, #176]	; (21393c <DecFontSize+0xec>)
  21388a:	f993 3020 	ldrsb.w	r3, [r3, #32]
  21388e:	2b32      	cmp	r3, #50	; 0x32
  213890:	d10b      	bne.n	2138aa <DecFontSize+0x5a>
		Test.lenWin=Test.lenWin_prev;
  213892:	4b2a      	ldr	r3, [pc, #168]	; (21393c <DecFontSize+0xec>)
  213894:	f9b3 20f6 	ldrsh.w	r2, [r3, #246]	; 0xf6
  213898:	4b28      	ldr	r3, [pc, #160]	; (21393c <DecFontSize+0xec>)
  21389a:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
		Test.offsWin=Test.offsWin_prev;
  21389e:	4b27      	ldr	r3, [pc, #156]	; (21393c <DecFontSize+0xec>)
  2138a0:	f9b3 20f8 	ldrsh.w	r2, [r3, #248]	; 0xf8
  2138a4:	4b25      	ldr	r3, [pc, #148]	; (21393c <DecFontSize+0xec>)
  2138a6:	f8a3 20f4 	strh.w	r2, [r3, #244]	; 0xf4
	}
	Test.size-=3;
  2138aa:	4b24      	ldr	r3, [pc, #144]	; (21393c <DecFontSize+0xec>)
  2138ac:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2138b0:	b2db      	uxtb	r3, r3
  2138b2:	3b03      	subs	r3, #3
  2138b4:	b2db      	uxtb	r3, r3
  2138b6:	b25a      	sxtb	r2, r3
  2138b8:	4b20      	ldr	r3, [pc, #128]	; (21393c <DecFontSize+0xec>)
  2138ba:	f883 2020 	strb.w	r2, [r3, #32]
	switch(Test.normBoldItal)
  2138be:	4b1f      	ldr	r3, [pc, #124]	; (21393c <DecFontSize+0xec>)
  2138c0:	f893 30fa 	ldrb.w	r3, [r3, #250]	; 0xfa
  2138c4:	2b01      	cmp	r3, #1
  2138c6:	d004      	beq.n	2138d2 <DecFontSize+0x82>
  2138c8:	2b02      	cmp	r3, #2
  2138ca:	d005      	beq.n	2138d8 <DecFontSize+0x88>
	{
	default:
	case 0:  sizeLimit=FONT_8; 		  break;
  2138cc:	2300      	movs	r3, #0
  2138ce:	607b      	str	r3, [r7, #4]
  2138d0:	e005      	b.n	2138de <DecFontSize+0x8e>
	case 1:  sizeLimit=FONT_8_bold; 	  break;
  2138d2:	2301      	movs	r3, #1
  2138d4:	607b      	str	r3, [r7, #4]
  2138d6:	e002      	b.n	2138de <DecFontSize+0x8e>
	case 2:  sizeLimit=FONT_8_italics; break;
  2138d8:	2302      	movs	r3, #2
  2138da:	607b      	str	r3, [r7, #4]
  2138dc:	bf00      	nop
	}
	if(Test.size<sizeLimit) Test.size=sizeLimit;
  2138de:	4b17      	ldr	r3, [pc, #92]	; (21393c <DecFontSize+0xec>)
  2138e0:	f993 3020 	ldrsb.w	r3, [r3, #32]
  2138e4:	461a      	mov	r2, r3
  2138e6:	687b      	ldr	r3, [r7, #4]
  2138e8:	429a      	cmp	r2, r3
  2138ea:	da04      	bge.n	2138f6 <DecFontSize+0xa6>
  2138ec:	687b      	ldr	r3, [r7, #4]
  2138ee:	b25a      	sxtb	r2, r3
  2138f0:	4b12      	ldr	r3, [pc, #72]	; (21393c <DecFontSize+0xec>)
  2138f2:	f883 2020 	strb.w	r2, [r3, #32]

	ClearCursorField();
  2138f6:	f7ff f901 	bl	212afc <ClearCursorField>
	LCD_LoadFontVar(fontID_3);
  2138fa:	2002      	movs	r0, #2
  2138fc:	f7ff fd60 	bl	2133c0 <LCD_LoadFontVar>
	ChangeTxt();
  213900:	f7ff fcde 	bl	2132c0 <ChangeTxt>
	AdjustMiddle_X();
  213904:	f7ff fdc6 	bl	213494 <AdjustMiddle_X>
	AdjustMiddle_Y();
  213908:	f7ff fde6 	bl	2134d8 <AdjustMiddle_Y>
	Data2Refresh(FONTS);
  21390c:	200c      	movs	r0, #12
  21390e:	f7ff f9c3 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  213912:	4b0b      	ldr	r3, [pc, #44]	; (213940 <DecFontSize+0xf0>)
  213914:	881b      	ldrh	r3, [r3, #0]
  213916:	b21a      	sxth	r2, r3
  213918:	4b08      	ldr	r3, [pc, #32]	; (21393c <DecFontSize+0xec>)
  21391a:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  21391e:	f7ff f925 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_SIZE);
  213922:	2000      	movs	r0, #0
  213924:	f7ff f9b8 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_LEN_WINDOW);
  213928:	2003      	movs	r0, #3
  21392a:	f7ff f9b5 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  21392e:	2007      	movs	r0, #7
  213930:	f7ff f9b2 	bl	212c98 <Data2Refresh>
}
  213934:	bf00      	nop
  213936:	3708      	adds	r7, #8
  213938:	46bd      	mov	sp, r7
  21393a:	bd80      	pop	{r7, pc}
  21393c:	200103c0 	.word	0x200103c0
  213940:	20014a44 	.word	0x20014a44

00213944 <ChangeFontBoldItalNorm>:

void ChangeFontBoldItalNorm(void)
{
  213944:	b580      	push	{r7, lr}
  213946:	af00      	add	r7, sp, #0
	if(Test.normBoldItal>1){
  213948:	4b22      	ldr	r3, [pc, #136]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  21394a:	f893 30fa 	ldrb.w	r3, [r3, #250]	; 0xfa
  21394e:	2b01      	cmp	r3, #1
  213950:	d90e      	bls.n	213970 <ChangeFontBoldItalNorm+0x2c>
		Test.normBoldItal=0;
  213952:	4b20      	ldr	r3, [pc, #128]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  213954:	2200      	movs	r2, #0
  213956:	f883 20fa 	strb.w	r2, [r3, #250]	; 0xfa
		Test.size-=2;
  21395a:	4b1e      	ldr	r3, [pc, #120]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  21395c:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213960:	b2db      	uxtb	r3, r3
  213962:	3b02      	subs	r3, #2
  213964:	b2db      	uxtb	r3, r3
  213966:	b25a      	sxtb	r2, r3
  213968:	4b1a      	ldr	r3, [pc, #104]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  21396a:	f883 2020 	strb.w	r2, [r3, #32]
  21396e:	e011      	b.n	213994 <ChangeFontBoldItalNorm+0x50>
	}
	else{
		Test.normBoldItal++;
  213970:	4b18      	ldr	r3, [pc, #96]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  213972:	f893 30fa 	ldrb.w	r3, [r3, #250]	; 0xfa
  213976:	3301      	adds	r3, #1
  213978:	b2da      	uxtb	r2, r3
  21397a:	4b16      	ldr	r3, [pc, #88]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  21397c:	f883 20fa 	strb.w	r2, [r3, #250]	; 0xfa
		Test.size++;
  213980:	4b14      	ldr	r3, [pc, #80]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  213982:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213986:	b2db      	uxtb	r3, r3
  213988:	3301      	adds	r3, #1
  21398a:	b2db      	uxtb	r3, r3
  21398c:	b25a      	sxtb	r2, r3
  21398e:	4b11      	ldr	r3, [pc, #68]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  213990:	f883 2020 	strb.w	r2, [r3, #32]
	}
	ClearCursorField();
  213994:	f7ff f8b2 	bl	212afc <ClearCursorField>
	LCD_LoadFontVar(fontID_3);
  213998:	2002      	movs	r0, #2
  21399a:	f7ff fd11 	bl	2133c0 <LCD_LoadFontVar>
	AdjustMiddle_X();
  21399e:	f7ff fd79 	bl	213494 <AdjustMiddle_X>
	AdjustMiddle_Y();
  2139a2:	f7ff fd99 	bl	2134d8 <AdjustMiddle_Y>
	Data2Refresh(FONTS);
  2139a6:	200c      	movs	r0, #12
  2139a8:	f7ff f976 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  2139ac:	4b0a      	ldr	r3, [pc, #40]	; (2139d8 <ChangeFontBoldItalNorm+0x94>)
  2139ae:	881b      	ldrh	r3, [r3, #0]
  2139b0:	b21a      	sxth	r2, r3
  2139b2:	4b08      	ldr	r3, [pc, #32]	; (2139d4 <ChangeFontBoldItalNorm+0x90>)
  2139b4:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  2139b8:	f7ff f8d8 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  2139bc:	2003      	movs	r0, #3
  2139be:	f7ff f96b 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SIZE);
  2139c2:	2000      	movs	r0, #0
  2139c4:	f7ff f968 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  2139c8:	2007      	movs	r0, #7
  2139ca:	f7ff f965 	bl	212c98 <Data2Refresh>
}
  2139ce:	bf00      	nop
  2139d0:	bd80      	pop	{r7, pc}
  2139d2:	bf00      	nop
  2139d4:	200103c0 	.word	0x200103c0
  2139d8:	20014a44 	.word	0x20014a44

002139dc <ReplaceLcdStrType>:

void ReplaceLcdStrType(void)
{
  2139dc:	b580      	push	{r7, lr}
  2139de:	af00      	add	r7, sp, #0
	INCR_WRAP(Test.type,1,0,2);
  2139e0:	4b25      	ldr	r3, [pc, #148]	; (213a78 <ReplaceLcdStrType+0x9c>)
  2139e2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  2139e6:	3301      	adds	r3, #1
  2139e8:	2b02      	cmp	r3, #2
  2139ea:	dd04      	ble.n	2139f6 <ReplaceLcdStrType+0x1a>
  2139ec:	4b22      	ldr	r3, [pc, #136]	; (213a78 <ReplaceLcdStrType+0x9c>)
  2139ee:	2200      	movs	r2, #0
  2139f0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
  2139f4:	e007      	b.n	213a06 <ReplaceLcdStrType+0x2a>
  2139f6:	4b20      	ldr	r3, [pc, #128]	; (213a78 <ReplaceLcdStrType+0x9c>)
  2139f8:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  2139fc:	3301      	adds	r3, #1
  2139fe:	b2da      	uxtb	r2, r3
  213a00:	4b1d      	ldr	r3, [pc, #116]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a02:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
	switch(Test.type)
  213a06:	4b1c      	ldr	r3, [pc, #112]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a08:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  213a0c:	2b00      	cmp	r3, #0
  213a0e:	d00a      	beq.n	213a26 <ReplaceLcdStrType+0x4a>
  213a10:	2b01      	cmp	r3, #1
  213a12:	d10e      	bne.n	213a32 <ReplaceLcdStrType+0x56>
	{
	case 1:
		Test.coeff_prev=Test.coeff;
  213a14:	4b18      	ldr	r3, [pc, #96]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a16:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
  213a1a:	4b17      	ldr	r3, [pc, #92]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a1c:	83da      	strh	r2, [r3, #30]
		Test.coeff=1;
  213a1e:	4b16      	ldr	r3, [pc, #88]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a20:	2201      	movs	r2, #1
  213a22:	839a      	strh	r2, [r3, #28]
		break;
  213a24:	e005      	b.n	213a32 <ReplaceLcdStrType+0x56>
	case 0:
		Test.coeff=Test.coeff_prev;
  213a26:	4b14      	ldr	r3, [pc, #80]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a28:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
  213a2c:	4b12      	ldr	r3, [pc, #72]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a2e:	839a      	strh	r2, [r3, #28]
		break;
  213a30:	bf00      	nop
	}
	ClearCursorField();
  213a32:	f7ff f863 	bl	212afc <ClearCursorField>
	LCD_LoadFontVar(fontID_3);
  213a36:	2002      	movs	r0, #2
  213a38:	f7ff fcc2 	bl	2133c0 <LCD_LoadFontVar>
	AdjustMiddle_X();
  213a3c:	f7ff fd2a 	bl	213494 <AdjustMiddle_X>
	AdjustMiddle_Y();
  213a40:	f7ff fd4a 	bl	2134d8 <AdjustMiddle_Y>
	Data2Refresh(FONTS);
  213a44:	200c      	movs	r0, #12
  213a46:	f7ff f927 	bl	212c98 <Data2Refresh>
	Test.lenWin=lenStr.inChar;
  213a4a:	4b0c      	ldr	r3, [pc, #48]	; (213a7c <ReplaceLcdStrType+0xa0>)
  213a4c:	881b      	ldrh	r3, [r3, #0]
  213a4e:	b21a      	sxth	r2, r3
  213a50:	4b09      	ldr	r3, [pc, #36]	; (213a78 <ReplaceLcdStrType+0x9c>)
  213a52:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
	SetCursor();
  213a56:	f7ff f889 	bl	212b6c <SetCursor>
	Data2Refresh(PARAM_LEN_WINDOW);
  213a5a:	2003      	movs	r0, #3
  213a5c:	f7ff f91c 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SIZE);
  213a60:	2000      	movs	r0, #0
  213a62:	f7ff f919 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_SPEED);
  213a66:	2007      	movs	r0, #7
  213a68:	f7ff f916 	bl	212c98 <Data2Refresh>
	Data2Refresh(PARAM_COEFF);
  213a6c:	2006      	movs	r0, #6
  213a6e:	f7ff f913 	bl	212c98 <Data2Refresh>
}
  213a72:	bf00      	nop
  213a74:	bd80      	pop	{r7, pc}
  213a76:	bf00      	nop
  213a78:	200103c0 	.word	0x200103c0
  213a7c:	20014a44 	.word	0x20014a44

00213a80 <Inc_PosCursor>:

void Inc_PosCursor(void){
  213a80:	b580      	push	{r7, lr}
  213a82:	af00      	add	r7, sp, #0
	if(Test.posCursor<Test.lenWin){
  213a84:	4b0b      	ldr	r3, [pc, #44]	; (213ab4 <Inc_PosCursor+0x34>)
  213a86:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213a8a:	461a      	mov	r2, r3
  213a8c:	4b09      	ldr	r3, [pc, #36]	; (213ab4 <Inc_PosCursor+0x34>)
  213a8e:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  213a92:	429a      	cmp	r2, r3
  213a94:	da0c      	bge.n	213ab0 <Inc_PosCursor+0x30>
		Test.posCursor++;
  213a96:	4b07      	ldr	r3, [pc, #28]	; (213ab4 <Inc_PosCursor+0x34>)
  213a98:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213a9c:	3301      	adds	r3, #1
  213a9e:	b2da      	uxtb	r2, r3
  213aa0:	4b04      	ldr	r3, [pc, #16]	; (213ab4 <Inc_PosCursor+0x34>)
  213aa2:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
		Data2Refresh(PARAM_POS_CURSOR);
  213aa6:	2009      	movs	r0, #9
  213aa8:	f7ff f8f6 	bl	212c98 <Data2Refresh>
		SetCursor();
  213aac:	f7ff f85e 	bl	212b6c <SetCursor>
	}
}
  213ab0:	bf00      	nop
  213ab2:	bd80      	pop	{r7, pc}
  213ab4:	200103c0 	.word	0x200103c0

00213ab8 <Dec_PosCursor>:
void Dec_PosCursor(void){
  213ab8:	b580      	push	{r7, lr}
  213aba:	af00      	add	r7, sp, #0
	if(Test.posCursor>0){
  213abc:	4b09      	ldr	r3, [pc, #36]	; (213ae4 <Dec_PosCursor+0x2c>)
  213abe:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213ac2:	2b00      	cmp	r3, #0
  213ac4:	d00c      	beq.n	213ae0 <Dec_PosCursor+0x28>
		Test.posCursor--;
  213ac6:	4b07      	ldr	r3, [pc, #28]	; (213ae4 <Dec_PosCursor+0x2c>)
  213ac8:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213acc:	3b01      	subs	r3, #1
  213ace:	b2da      	uxtb	r2, r3
  213ad0:	4b04      	ldr	r3, [pc, #16]	; (213ae4 <Dec_PosCursor+0x2c>)
  213ad2:	f883 2104 	strb.w	r2, [r3, #260]	; 0x104
		Data2Refresh(PARAM_POS_CURSOR);
  213ad6:	2009      	movs	r0, #9
  213ad8:	f7ff f8de 	bl	212c98 <Data2Refresh>
		SetCursor();
  213adc:	f7ff f846 	bl	212b6c <SetCursor>
	}
}
  213ae0:	bf00      	nop
  213ae2:	bd80      	pop	{r7, pc}
  213ae4:	200103c0 	.word	0x200103c0

00213ae8 <IncDec_SpaceBetweenFont>:

void IncDec_SpaceBetweenFont(int incDec){
  213ae8:	b5b0      	push	{r4, r5, r7, lr}
  213aea:	b084      	sub	sp, #16
  213aec:	af02      	add	r7, sp, #8
  213aee:	6078      	str	r0, [r7, #4]
	if(((LCD_GetStrVar_x(STR_ID_Fonts)+lenStr.inPixel>=LCD_GetXSize()-1)&&(1==incDec))||
  213af0:	200a      	movs	r0, #10
  213af2:	f7f6 ffef 	bl	20aad4 <LCD_GetStrVar_x>
  213af6:	4602      	mov	r2, r0
  213af8:	4b30      	ldr	r3, [pc, #192]	; (213bbc <IncDec_SpaceBetweenFont+0xd4>)
  213afa:	885b      	ldrh	r3, [r3, #2]
  213afc:	4413      	add	r3, r2
  213afe:	461c      	mov	r4, r3
  213b00:	f7f3 ff52 	bl	2079a8 <LCD_GetXSize>
  213b04:	4603      	mov	r3, r0
  213b06:	3b01      	subs	r3, #1
  213b08:	429c      	cmp	r4, r3
  213b0a:	d302      	bcc.n	213b12 <IncDec_SpaceBetweenFont+0x2a>
  213b0c:	687b      	ldr	r3, [r7, #4]
  213b0e:	2b01      	cmp	r3, #1
  213b10:	d04f      	beq.n	213bb2 <IncDec_SpaceBetweenFont+0xca>
		((0==LCD_GetStrPxlWidth(fontIDVar,Test.txt,Test.posCursor-1,Test.spaceBetweenFonts,Test.constWidth))&&(0==incDec)))
  213b12:	4b2b      	ldr	r3, [pc, #172]	; (213bc0 <IncDec_SpaceBetweenFont+0xd8>)
  213b14:	6818      	ldr	r0, [r3, #0]
  213b16:	4b2b      	ldr	r3, [pc, #172]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b18:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213b1c:	1e5a      	subs	r2, r3, #1
  213b1e:	4b29      	ldr	r3, [pc, #164]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b20:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  213b24:	4619      	mov	r1, r3
  213b26:	4b27      	ldr	r3, [pc, #156]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b28:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
  213b2c:	9300      	str	r3, [sp, #0]
  213b2e:	460b      	mov	r3, r1
  213b30:	4925      	ldr	r1, [pc, #148]	; (213bc8 <IncDec_SpaceBetweenFont+0xe0>)
  213b32:	f7fe fb3b 	bl	2121ac <LCD_GetStrPxlWidth>
  213b36:	4603      	mov	r3, r0
	if(((LCD_GetStrVar_x(STR_ID_Fonts)+lenStr.inPixel>=LCD_GetXSize()-1)&&(1==incDec))||
  213b38:	2b00      	cmp	r3, #0
  213b3a:	d102      	bne.n	213b42 <IncDec_SpaceBetweenFont+0x5a>
		((0==LCD_GetStrPxlWidth(fontIDVar,Test.txt,Test.posCursor-1,Test.spaceBetweenFonts,Test.constWidth))&&(0==incDec)))
  213b3c:	687b      	ldr	r3, [r7, #4]
  213b3e:	2b00      	cmp	r3, #0
  213b40:	d037      	beq.n	213bb2 <IncDec_SpaceBetweenFont+0xca>
		return;
	if(Test.posCursor>1){
  213b42:	4b20      	ldr	r3, [pc, #128]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b44:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213b48:	2b01      	cmp	r3, #1
  213b4a:	d933      	bls.n	213bb4 <IncDec_SpaceBetweenFont+0xcc>
		if(0xFFFF!=LCD_SelectedSpaceBetweenFontsIncrDecr(incDec, Test.style, Test.size, Test.txt[Test.posCursor-2], Test.txt[Test.posCursor-1])){
  213b4c:	687b      	ldr	r3, [r7, #4]
  213b4e:	b2d8      	uxtb	r0, r3
  213b50:	4b1c      	ldr	r3, [pc, #112]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b52:	f893 1021 	ldrb.w	r1, [r3, #33]	; 0x21
  213b56:	4b1b      	ldr	r3, [pc, #108]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b58:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213b5c:	b2dc      	uxtb	r4, r3
  213b5e:	4b19      	ldr	r3, [pc, #100]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b60:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213b64:	3b02      	subs	r3, #2
  213b66:	4a17      	ldr	r2, [pc, #92]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b68:	4413      	add	r3, r2
  213b6a:	f893 5029 	ldrb.w	r5, [r3, #41]	; 0x29
  213b6e:	4b15      	ldr	r3, [pc, #84]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b70:	f893 3104 	ldrb.w	r3, [r3, #260]	; 0x104
  213b74:	3b01      	subs	r3, #1
  213b76:	4a13      	ldr	r2, [pc, #76]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213b78:	4413      	add	r3, r2
  213b7a:	f893 3029 	ldrb.w	r3, [r3, #41]	; 0x29
  213b7e:	9300      	str	r3, [sp, #0]
  213b80:	462b      	mov	r3, r5
  213b82:	4622      	mov	r2, r4
  213b84:	f7fe fcf4 	bl	212570 <LCD_SelectedSpaceBetweenFontsIncrDecr>
  213b88:	4602      	mov	r2, r0
  213b8a:	f64f 73ff 	movw	r3, #65535	; 0xffff
  213b8e:	429a      	cmp	r2, r3
  213b90:	d010      	beq.n	213bb4 <IncDec_SpaceBetweenFont+0xcc>
			ClearCursorField();
  213b92:	f7fe ffb3 	bl	212afc <ClearCursorField>
			Data2Refresh(FONTS);
  213b96:	200c      	movs	r0, #12
  213b98:	f7ff f87e 	bl	212c98 <Data2Refresh>
			Test.lenWin=lenStr.inChar;
  213b9c:	4b07      	ldr	r3, [pc, #28]	; (213bbc <IncDec_SpaceBetweenFont+0xd4>)
  213b9e:	881b      	ldrh	r3, [r3, #0]
  213ba0:	b21a      	sxth	r2, r3
  213ba2:	4b08      	ldr	r3, [pc, #32]	; (213bc4 <IncDec_SpaceBetweenFont+0xdc>)
  213ba4:	f8a3 20f2 	strh.w	r2, [r3, #242]	; 0xf2
			SetCursor();
  213ba8:	f7fe ffe0 	bl	212b6c <SetCursor>
			RefreshAllParam();
  213bac:	f7ff fa88 	bl	2130c0 <RefreshAllParam>
  213bb0:	e000      	b.n	213bb4 <IncDec_SpaceBetweenFont+0xcc>
		return;
  213bb2:	bf00      	nop
		}
	}
}
  213bb4:	3708      	adds	r7, #8
  213bb6:	46bd      	mov	sp, r7
  213bb8:	bdb0      	pop	{r4, r5, r7, pc}
  213bba:	bf00      	nop
  213bbc:	20014a44 	.word	0x20014a44
  213bc0:	200103b8 	.word	0x200103b8
  213bc4:	200103c0 	.word	0x200103c0
  213bc8:	200103e9 	.word	0x200103e9

00213bcc <DisplayFontsWithChangeColorOrNot>:

void DisplayFontsWithChangeColorOrNot(void){
  213bcc:	b580      	push	{r7, lr}
  213bce:	af00      	add	r7, sp, #0
	TOOGLE(Test.dispChangeColorOrNot);
  213bd0:	4b06      	ldr	r3, [pc, #24]	; (213bec <DisplayFontsWithChangeColorOrNot+0x20>)
  213bd2:	f893 3108 	ldrb.w	r3, [r3, #264]	; 0x108
  213bd6:	f1c3 0301 	rsb	r3, r3, #1
  213bda:	b2da      	uxtb	r2, r3
  213bdc:	4b03      	ldr	r3, [pc, #12]	; (213bec <DisplayFontsWithChangeColorOrNot+0x20>)
  213bde:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	RefreshAllParam();
  213be2:	f7ff fa6d 	bl	2130c0 <RefreshAllParam>
}
  213be6:	bf00      	nop
  213be8:	bd80      	pop	{r7, pc}
  213bea:	bf00      	nop
  213bec:	200103c0 	.word	0x200103c0

00213bf0 <SCREEN_ResetAllParameters>:
	}

}

static void SCREEN_ResetAllParameters(void)
{
  213bf0:	b580      	push	{r7, lr}
  213bf2:	af00      	add	r7, sp, #0
	LCD_AllRefreshScreenClear();
  213bf4:	f7f3 fcbc 	bl	207570 <LCD_AllRefreshScreenClear>
	LCD_ResetStrMovBuffPos();
  213bf8:	f7f9 faa4 	bl	20d144 <LCD_ResetStrMovBuffPos>
	LCD_DeleteAllFontAndImages();
  213bfc:	f7f6 ff96 	bl	20ab2c <LCD_DeleteAllFontAndImages>
}
  213c00:	bf00      	nop
  213c02:	bd80      	pop	{r7, pc}

00213c04 <NOWY_0>:

void NOWY_0(void)
{
  213c04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  213c08:	b090      	sub	sp, #64	; 0x40
  213c0a:	af0a      	add	r7, sp, #40	; 0x28
	SCREEN_ResetAllParameters();
  213c0c:	f7ff fff0 	bl	213bf0 <SCREEN_ResetAllParameters>
	ResetRGB();
  213c10:	f7ff fb6e 	bl	2132f0 <ResetRGB>
	LCD_Clear(MYGRAY);
  213c14:	48c8      	ldr	r0, [pc, #800]	; (213f38 <NOWY_0+0x334>)
  213c16:	f7f1 fe57 	bl	2058c8 <LCD_Clear>
	LCD_LoadFont_DarkgrayWhite(FONT_26, Arial, fontID_1);
  213c1a:	2200      	movs	r2, #0
  213c1c:	2105      	movs	r1, #5
  213c1e:	2021      	movs	r0, #33	; 0x21
  213c20:	f7f8 fbec 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	LCD_LoadFont_DarkgrayWhite(FONT_10, Arial, fontID_2);
  213c24:	2201      	movs	r2, #1
  213c26:	2105      	movs	r1, #5
  213c28:	2006      	movs	r0, #6
  213c2a:	f7f8 fbe7 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	LCD_LoadFont_DarkgrayWhite(FONT_12, Arial, fontID_6);
  213c2e:	2205      	movs	r2, #5
  213c30:	2105      	movs	r1, #5
  213c32:	200c      	movs	r0, #12
  213c34:	f7f8 fbe2 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	LCD_LoadFont_DarkgrayGreen(FONT_10, Arial, fontID_7);
  213c38:	2206      	movs	r2, #6
  213c3a:	2105      	movs	r1, #5
  213c3c:	2006      	movs	r0, #6
  213c3e:	f7f8 fbc7 	bl	20c3d0 <LCD_LoadFont_DarkgrayGreen>
	LCD_LoadFont_DarkgrayGreen(FONT_26, Arial, fontID_15);
  213c42:	220e      	movs	r2, #14
  213c44:	2105      	movs	r1, #5
  213c46:	2021      	movs	r0, #33	; 0x21
  213c48:	f7f8 fbc2 	bl	20c3d0 <LCD_LoadFont_DarkgrayGreen>
//	LCD_LoadFont_WhiteBlack(FONT_16, Arial, fontID_11);
//	LCD_LoadFont_WhiteBlack(FONT_11, Arial, fontID_12);

	LCD_LoadFontVar(fontID_3);
  213c4c:	2002      	movs	r0, #2
  213c4e:	f7ff fbb7 	bl	2133c0 <LCD_LoadFontVar>


	lenStr=LCD_StrVar(STR_ID_FontColor,	 fontID_2, 23, LCD_Ypos(lenStr,SetPos,0), TXT_FONT_COLOR, 	 fullHight,0,MYGRAY,0,1,MYGRAY);
  213c52:	4bba      	ldr	r3, [pc, #744]	; (213f3c <NOWY_0+0x338>)
  213c54:	681a      	ldr	r2, [r3, #0]
  213c56:	4610      	mov	r0, r2
  213c58:	889b      	ldrh	r3, [r3, #4]
  213c5a:	2100      	movs	r1, #0
  213c5c:	f363 010f 	bfi	r1, r3, #0, #16
  213c60:	2300      	movs	r3, #0
  213c62:	2200      	movs	r2, #0
  213c64:	f7fe fe58 	bl	212918 <LCD_Ypos>
  213c68:	4603      	mov	r3, r0
  213c6a:	461c      	mov	r4, r3
  213c6c:	4bb4      	ldr	r3, [pc, #720]	; (213f40 <NOWY_0+0x33c>)
  213c6e:	68d8      	ldr	r0, [r3, #12]
  213c70:	2303      	movs	r3, #3
  213c72:	2203      	movs	r2, #3
  213c74:	2130      	movs	r1, #48	; 0x30
  213c76:	f7ed fd25 	bl	2016c4 <Int2Str>
  213c7a:	4605      	mov	r5, r0
  213c7c:	4bb0      	ldr	r3, [pc, #704]	; (213f40 <NOWY_0+0x33c>)
  213c7e:	6918      	ldr	r0, [r3, #16]
  213c80:	2303      	movs	r3, #3
  213c82:	2203      	movs	r2, #3
  213c84:	2130      	movs	r1, #48	; 0x30
  213c86:	f7ed fd1d 	bl	2016c4 <Int2Str>
  213c8a:	4606      	mov	r6, r0
  213c8c:	4bac      	ldr	r3, [pc, #688]	; (213f40 <NOWY_0+0x33c>)
  213c8e:	6958      	ldr	r0, [r3, #20]
  213c90:	2303      	movs	r3, #3
  213c92:	2203      	movs	r2, #3
  213c94:	2130      	movs	r1, #48	; 0x30
  213c96:	f7ed fd15 	bl	2016c4 <Int2Str>
  213c9a:	4603      	mov	r3, r0
  213c9c:	9301      	str	r3, [sp, #4]
  213c9e:	4ba9      	ldr	r3, [pc, #676]	; (213f44 <NOWY_0+0x340>)
  213ca0:	9300      	str	r3, [sp, #0]
  213ca2:	4633      	mov	r3, r6
  213ca4:	4aa7      	ldr	r2, [pc, #668]	; (213f44 <NOWY_0+0x340>)
  213ca6:	4629      	mov	r1, r5
  213ca8:	2005      	movs	r0, #5
  213caa:	f7ed feff 	bl	201aac <StrAll>
  213cae:	4602      	mov	r2, r0
  213cb0:	4da2      	ldr	r5, [pc, #648]	; (213f3c <NOWY_0+0x338>)
  213cb2:	f107 0010 	add.w	r0, r7, #16
  213cb6:	4ba0      	ldr	r3, [pc, #640]	; (213f38 <NOWY_0+0x334>)
  213cb8:	9307      	str	r3, [sp, #28]
  213cba:	2301      	movs	r3, #1
  213cbc:	9306      	str	r3, [sp, #24]
  213cbe:	2300      	movs	r3, #0
  213cc0:	9305      	str	r3, [sp, #20]
  213cc2:	4b9d      	ldr	r3, [pc, #628]	; (213f38 <NOWY_0+0x334>)
  213cc4:	9304      	str	r3, [sp, #16]
  213cc6:	2300      	movs	r3, #0
  213cc8:	9303      	str	r3, [sp, #12]
  213cca:	f06f 0302 	mvn.w	r3, #2
  213cce:	9302      	str	r3, [sp, #8]
  213cd0:	9201      	str	r2, [sp, #4]
  213cd2:	9400      	str	r4, [sp, #0]
  213cd4:	2317      	movs	r3, #23
  213cd6:	2201      	movs	r2, #1
  213cd8:	2104      	movs	r1, #4
  213cda:	f7f8 fc63 	bl	20c5a4 <LCD_StrVar>
  213cde:	462a      	mov	r2, r5
  213ce0:	f107 0310 	add.w	r3, r7, #16
  213ce4:	6819      	ldr	r1, [r3, #0]
  213ce6:	6011      	str	r1, [r2, #0]
  213ce8:	889b      	ldrh	r3, [r3, #4]
  213cea:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrVar(STR_ID_BkColor,	 fontID_2, 23, LCD_Ypos(lenStr,IncPos,5), TXT_BK_COLOR,   	 fullHight,0,MYGRAY,0,1,MYGRAY);
  213cec:	4b93      	ldr	r3, [pc, #588]	; (213f3c <NOWY_0+0x338>)
  213cee:	681a      	ldr	r2, [r3, #0]
  213cf0:	4610      	mov	r0, r2
  213cf2:	889b      	ldrh	r3, [r3, #4]
  213cf4:	2100      	movs	r1, #0
  213cf6:	f363 010f 	bfi	r1, r3, #0, #16
  213cfa:	2305      	movs	r3, #5
  213cfc:	2202      	movs	r2, #2
  213cfe:	f7fe fe0b 	bl	212918 <LCD_Ypos>
  213d02:	4603      	mov	r3, r0
  213d04:	461c      	mov	r4, r3
  213d06:	4b8e      	ldr	r3, [pc, #568]	; (213f40 <NOWY_0+0x33c>)
  213d08:	6818      	ldr	r0, [r3, #0]
  213d0a:	2303      	movs	r3, #3
  213d0c:	2203      	movs	r2, #3
  213d0e:	2130      	movs	r1, #48	; 0x30
  213d10:	f7ed fcd8 	bl	2016c4 <Int2Str>
  213d14:	4605      	mov	r5, r0
  213d16:	4b8a      	ldr	r3, [pc, #552]	; (213f40 <NOWY_0+0x33c>)
  213d18:	6858      	ldr	r0, [r3, #4]
  213d1a:	2303      	movs	r3, #3
  213d1c:	2203      	movs	r2, #3
  213d1e:	2130      	movs	r1, #48	; 0x30
  213d20:	f7ed fcd0 	bl	2016c4 <Int2Str>
  213d24:	4606      	mov	r6, r0
  213d26:	4b86      	ldr	r3, [pc, #536]	; (213f40 <NOWY_0+0x33c>)
  213d28:	6898      	ldr	r0, [r3, #8]
  213d2a:	2303      	movs	r3, #3
  213d2c:	2203      	movs	r2, #3
  213d2e:	2130      	movs	r1, #48	; 0x30
  213d30:	f7ed fcc8 	bl	2016c4 <Int2Str>
  213d34:	4603      	mov	r3, r0
  213d36:	9301      	str	r3, [sp, #4]
  213d38:	4b82      	ldr	r3, [pc, #520]	; (213f44 <NOWY_0+0x340>)
  213d3a:	9300      	str	r3, [sp, #0]
  213d3c:	4633      	mov	r3, r6
  213d3e:	4a81      	ldr	r2, [pc, #516]	; (213f44 <NOWY_0+0x340>)
  213d40:	4629      	mov	r1, r5
  213d42:	2005      	movs	r0, #5
  213d44:	f7ed feb2 	bl	201aac <StrAll>
  213d48:	4602      	mov	r2, r0
  213d4a:	4d7c      	ldr	r5, [pc, #496]	; (213f3c <NOWY_0+0x338>)
  213d4c:	f107 0010 	add.w	r0, r7, #16
  213d50:	4b79      	ldr	r3, [pc, #484]	; (213f38 <NOWY_0+0x334>)
  213d52:	9307      	str	r3, [sp, #28]
  213d54:	2301      	movs	r3, #1
  213d56:	9306      	str	r3, [sp, #24]
  213d58:	2300      	movs	r3, #0
  213d5a:	9305      	str	r3, [sp, #20]
  213d5c:	4b76      	ldr	r3, [pc, #472]	; (213f38 <NOWY_0+0x334>)
  213d5e:	9304      	str	r3, [sp, #16]
  213d60:	2300      	movs	r3, #0
  213d62:	9303      	str	r3, [sp, #12]
  213d64:	f06f 0302 	mvn.w	r3, #2
  213d68:	9302      	str	r3, [sp, #8]
  213d6a:	9201      	str	r2, [sp, #4]
  213d6c:	9400      	str	r4, [sp, #0]
  213d6e:	2317      	movs	r3, #23
  213d70:	2201      	movs	r2, #1
  213d72:	2103      	movs	r1, #3
  213d74:	f7f8 fc16 	bl	20c5a4 <LCD_StrVar>
  213d78:	462a      	mov	r2, r5
  213d7a:	f107 0310 	add.w	r3, r7, #16
  213d7e:	6819      	ldr	r1, [r3, #0]
  213d80:	6011      	str	r1, [r2, #0]
  213d82:	889b      	ldrh	r3, [r3, #4]
  213d84:	8093      	strh	r3, [r2, #4]

	lenStr=LCD_StrVar(STR_ID_FontSize,	 fontID_2, LCD_Xpos(lenStr,SetPos,23), LCD_Ypos(lenStr,IncPos,5), TXT_FONT_SIZE,      fullHight,0,MYGRAY,0,1,MYGRAY);
  213d86:	4b6d      	ldr	r3, [pc, #436]	; (213f3c <NOWY_0+0x338>)
  213d88:	681a      	ldr	r2, [r3, #0]
  213d8a:	4610      	mov	r0, r2
  213d8c:	889b      	ldrh	r3, [r3, #4]
  213d8e:	2100      	movs	r1, #0
  213d90:	f363 010f 	bfi	r1, r3, #0, #16
  213d94:	2317      	movs	r3, #23
  213d96:	2200      	movs	r2, #0
  213d98:	f7fe fdf0 	bl	21297c <LCD_Xpos>
  213d9c:	4603      	mov	r3, r0
  213d9e:	461e      	mov	r6, r3
  213da0:	4b66      	ldr	r3, [pc, #408]	; (213f3c <NOWY_0+0x338>)
  213da2:	681a      	ldr	r2, [r3, #0]
  213da4:	4610      	mov	r0, r2
  213da6:	889b      	ldrh	r3, [r3, #4]
  213da8:	2100      	movs	r1, #0
  213daa:	f363 010f 	bfi	r1, r3, #0, #16
  213dae:	2305      	movs	r3, #5
  213db0:	2202      	movs	r2, #2
  213db2:	f7fe fdb1 	bl	212918 <LCD_Ypos>
  213db6:	4603      	mov	r3, r0
  213db8:	461c      	mov	r4, r3
  213dba:	4b61      	ldr	r3, [pc, #388]	; (213f40 <NOWY_0+0x33c>)
  213dbc:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  213dc0:	461a      	mov	r2, r3
  213dc2:	4961      	ldr	r1, [pc, #388]	; (213f48 <NOWY_0+0x344>)
  213dc4:	2000      	movs	r0, #0
  213dc6:	f003 fb6b 	bl	2174a0 <GetSelTxt>
  213dca:	4605      	mov	r5, r0
  213dcc:	4b5c      	ldr	r3, [pc, #368]	; (213f40 <NOWY_0+0x33c>)
  213dce:	f993 3020 	ldrsb.w	r3, [r3, #32]
  213dd2:	4619      	mov	r1, r3
  213dd4:	485d      	ldr	r0, [pc, #372]	; (213f4c <NOWY_0+0x348>)
  213dd6:	f7f7 f81b 	bl	20ae10 <LCD_FontSize2Str>
  213dda:	4603      	mov	r3, r0
  213ddc:	4a5c      	ldr	r2, [pc, #368]	; (213f50 <NOWY_0+0x34c>)
  213dde:	4629      	mov	r1, r5
  213de0:	2003      	movs	r0, #3
  213de2:	f7ed fe63 	bl	201aac <StrAll>
  213de6:	4602      	mov	r2, r0
  213de8:	4d54      	ldr	r5, [pc, #336]	; (213f3c <NOWY_0+0x338>)
  213dea:	f107 0010 	add.w	r0, r7, #16
  213dee:	4b52      	ldr	r3, [pc, #328]	; (213f38 <NOWY_0+0x334>)
  213df0:	9307      	str	r3, [sp, #28]
  213df2:	2301      	movs	r3, #1
  213df4:	9306      	str	r3, [sp, #24]
  213df6:	2300      	movs	r3, #0
  213df8:	9305      	str	r3, [sp, #20]
  213dfa:	4b4f      	ldr	r3, [pc, #316]	; (213f38 <NOWY_0+0x334>)
  213dfc:	9304      	str	r3, [sp, #16]
  213dfe:	2300      	movs	r3, #0
  213e00:	9303      	str	r3, [sp, #12]
  213e02:	f06f 0302 	mvn.w	r3, #2
  213e06:	9302      	str	r3, [sp, #8]
  213e08:	9201      	str	r2, [sp, #4]
  213e0a:	9400      	str	r4, [sp, #0]
  213e0c:	4633      	mov	r3, r6
  213e0e:	2201      	movs	r2, #1
  213e10:	2105      	movs	r1, #5
  213e12:	f7f8 fbc7 	bl	20c5a4 <LCD_StrVar>
  213e16:	462a      	mov	r2, r5
  213e18:	f107 0310 	add.w	r3, r7, #16
  213e1c:	6819      	ldr	r1, [r3, #0]
  213e1e:	6011      	str	r1, [r2, #0]
  213e20:	889b      	ldrh	r3, [r3, #4]
  213e22:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrVar(STR_ID_FontStyle,	 fontID_2, LCD_Xpos(lenStr,IncPos,70), LCD_Ypos(lenStr,GetPos,0), TXT_FONT_STYLE,     fullHight,0,MYGRAY,0,1,MYGRAY);
  213e24:	4b45      	ldr	r3, [pc, #276]	; (213f3c <NOWY_0+0x338>)
  213e26:	681a      	ldr	r2, [r3, #0]
  213e28:	4610      	mov	r0, r2
  213e2a:	889b      	ldrh	r3, [r3, #4]
  213e2c:	2100      	movs	r1, #0
  213e2e:	f363 010f 	bfi	r1, r3, #0, #16
  213e32:	2346      	movs	r3, #70	; 0x46
  213e34:	2202      	movs	r2, #2
  213e36:	f7fe fda1 	bl	21297c <LCD_Xpos>
  213e3a:	4603      	mov	r3, r0
  213e3c:	461e      	mov	r6, r3
  213e3e:	4b3f      	ldr	r3, [pc, #252]	; (213f3c <NOWY_0+0x338>)
  213e40:	681a      	ldr	r2, [r3, #0]
  213e42:	4610      	mov	r0, r2
  213e44:	889b      	ldrh	r3, [r3, #4]
  213e46:	2100      	movs	r1, #0
  213e48:	f363 010f 	bfi	r1, r3, #0, #16
  213e4c:	2300      	movs	r3, #0
  213e4e:	2201      	movs	r2, #1
  213e50:	f7fe fd62 	bl	212918 <LCD_Ypos>
  213e54:	4603      	mov	r3, r0
  213e56:	461c      	mov	r4, r3
  213e58:	4b39      	ldr	r3, [pc, #228]	; (213f40 <NOWY_0+0x33c>)
  213e5a:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21
  213e5e:	4619      	mov	r1, r3
  213e60:	483a      	ldr	r0, [pc, #232]	; (213f4c <NOWY_0+0x348>)
  213e62:	f7f7 faad 	bl	20b3c0 <LCD_FontStyle2Str>
  213e66:	4602      	mov	r2, r0
  213e68:	4d34      	ldr	r5, [pc, #208]	; (213f3c <NOWY_0+0x338>)
  213e6a:	f107 0010 	add.w	r0, r7, #16
  213e6e:	4b32      	ldr	r3, [pc, #200]	; (213f38 <NOWY_0+0x334>)
  213e70:	9307      	str	r3, [sp, #28]
  213e72:	2301      	movs	r3, #1
  213e74:	9306      	str	r3, [sp, #24]
  213e76:	2300      	movs	r3, #0
  213e78:	9305      	str	r3, [sp, #20]
  213e7a:	4b2f      	ldr	r3, [pc, #188]	; (213f38 <NOWY_0+0x334>)
  213e7c:	9304      	str	r3, [sp, #16]
  213e7e:	2300      	movs	r3, #0
  213e80:	9303      	str	r3, [sp, #12]
  213e82:	f06f 0302 	mvn.w	r3, #2
  213e86:	9302      	str	r3, [sp, #8]
  213e88:	9201      	str	r2, [sp, #4]
  213e8a:	9400      	str	r4, [sp, #0]
  213e8c:	4633      	mov	r3, r6
  213e8e:	2201      	movs	r2, #1
  213e90:	2106      	movs	r1, #6
  213e92:	f7f8 fb87 	bl	20c5a4 <LCD_StrVar>
  213e96:	462a      	mov	r2, r5
  213e98:	f107 0310 	add.w	r3, r7, #16
  213e9c:	6819      	ldr	r1, [r3, #0]
  213e9e:	6011      	str	r1, [r2, #0]
  213ea0:	889b      	ldrh	r3, [r3, #4]
  213ea2:	8093      	strh	r3, [r2, #4]

	LCD_StrVar(	STR_ID_Coeff,		   fontID_2,150,20, TXT_COEFF, 	       fullHight,0,MYGRAY,0,1,MYGRAY);
  213ea4:	4b26      	ldr	r3, [pc, #152]	; (213f40 <NOWY_0+0x33c>)
  213ea6:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
  213eaa:	4618      	mov	r0, r3
  213eac:	2300      	movs	r3, #0
  213eae:	2203      	movs	r2, #3
  213eb0:	2120      	movs	r1, #32
  213eb2:	f7ed fc07 	bl	2016c4 <Int2Str>
  213eb6:	4602      	mov	r2, r0
  213eb8:	f107 0010 	add.w	r0, r7, #16
  213ebc:	4b1e      	ldr	r3, [pc, #120]	; (213f38 <NOWY_0+0x334>)
  213ebe:	9307      	str	r3, [sp, #28]
  213ec0:	2301      	movs	r3, #1
  213ec2:	9306      	str	r3, [sp, #24]
  213ec4:	2300      	movs	r3, #0
  213ec6:	9305      	str	r3, [sp, #20]
  213ec8:	4b1b      	ldr	r3, [pc, #108]	; (213f38 <NOWY_0+0x334>)
  213eca:	9304      	str	r3, [sp, #16]
  213ecc:	2300      	movs	r3, #0
  213ece:	9303      	str	r3, [sp, #12]
  213ed0:	f06f 0302 	mvn.w	r3, #2
  213ed4:	9302      	str	r3, [sp, #8]
  213ed6:	9201      	str	r2, [sp, #4]
  213ed8:	2314      	movs	r3, #20
  213eda:	9300      	str	r3, [sp, #0]
  213edc:	2396      	movs	r3, #150	; 0x96
  213ede:	2201      	movs	r2, #1
  213ee0:	2107      	movs	r1, #7
  213ee2:	f7f8 fb5f 	bl	20c5a4 <LCD_StrVar>
	LCD_StrVar(	STR_ID_LenWin,		   fontID_2,400, 0, TXT_LEN_WIN,	       halfHight,0,MYGRAY,0,1,MYGRAY);
  213ee6:	4b16      	ldr	r3, [pc, #88]	; (213f40 <NOWY_0+0x33c>)
  213ee8:	f9b3 30f2 	ldrsh.w	r3, [r3, #242]	; 0xf2
  213eec:	4618      	mov	r0, r3
  213eee:	2303      	movs	r3, #3
  213ef0:	2203      	movs	r2, #3
  213ef2:	2120      	movs	r1, #32
  213ef4:	f7ed fbe6 	bl	2016c4 <Int2Str>
  213ef8:	4602      	mov	r2, r0
  213efa:	f107 0010 	add.w	r0, r7, #16
  213efe:	4b0e      	ldr	r3, [pc, #56]	; (213f38 <NOWY_0+0x334>)
  213f00:	9307      	str	r3, [sp, #28]
  213f02:	2301      	movs	r3, #1
  213f04:	9306      	str	r3, [sp, #24]
  213f06:	2300      	movs	r3, #0
  213f08:	9305      	str	r3, [sp, #20]
  213f0a:	4b0b      	ldr	r3, [pc, #44]	; (213f38 <NOWY_0+0x334>)
  213f0c:	9304      	str	r3, [sp, #16]
  213f0e:	2300      	movs	r3, #0
  213f10:	9303      	str	r3, [sp, #12]
  213f12:	f06f 0301 	mvn.w	r3, #1
  213f16:	9302      	str	r3, [sp, #8]
  213f18:	9201      	str	r2, [sp, #4]
  213f1a:	2300      	movs	r3, #0
  213f1c:	9300      	str	r3, [sp, #0]
  213f1e:	f44f 73c8 	mov.w	r3, #400	; 0x190
  213f22:	2201      	movs	r2, #1
  213f24:	2100      	movs	r1, #0
  213f26:	f7f8 fb3d 	bl	20c5a4 <LCD_StrVar>
	LCD_StrVar(	STR_ID_OffsWin,	   fontID_2,400,20, TXT_OFFS_WIN,  	    halfHight,0,MYGRAY,0,1,MYGRAY);
  213f2a:	4b05      	ldr	r3, [pc, #20]	; (213f40 <NOWY_0+0x33c>)
  213f2c:	f9b3 30f4 	ldrsh.w	r3, [r3, #244]	; 0xf4
  213f30:	4618      	mov	r0, r3
  213f32:	2303      	movs	r3, #3
  213f34:	2203      	movs	r2, #3
  213f36:	e00d      	b.n	213f54 <NOWY_0+0x350>
  213f38:	ff404040 	.word	0xff404040
  213f3c:	20014a44 	.word	0x20014a44
  213f40:	200103c0 	.word	0x200103c0
  213f44:	00228e34 	.word	0x00228e34
  213f48:	00229320 	.word	0x00229320
  213f4c:	20010384 	.word	0x20010384
  213f50:	00228e2c 	.word	0x00228e2c
  213f54:	2120      	movs	r1, #32
  213f56:	f7ed fbb5 	bl	2016c4 <Int2Str>
  213f5a:	4602      	mov	r2, r0
  213f5c:	f107 0010 	add.w	r0, r7, #16
  213f60:	4b7c      	ldr	r3, [pc, #496]	; (214154 <NOWY_0+0x550>)
  213f62:	9307      	str	r3, [sp, #28]
  213f64:	2301      	movs	r3, #1
  213f66:	9306      	str	r3, [sp, #24]
  213f68:	2300      	movs	r3, #0
  213f6a:	9305      	str	r3, [sp, #20]
  213f6c:	4b79      	ldr	r3, [pc, #484]	; (214154 <NOWY_0+0x550>)
  213f6e:	9304      	str	r3, [sp, #16]
  213f70:	2300      	movs	r3, #0
  213f72:	9303      	str	r3, [sp, #12]
  213f74:	f06f 0301 	mvn.w	r3, #1
  213f78:	9302      	str	r3, [sp, #8]
  213f7a:	9201      	str	r2, [sp, #4]
  213f7c:	2314      	movs	r3, #20
  213f7e:	9300      	str	r3, [sp, #0]
  213f80:	f44f 73c8 	mov.w	r3, #400	; 0x190
  213f84:	2201      	movs	r2, #1
  213f86:	2101      	movs	r1, #1
  213f88:	f7f8 fb0c 	bl	20c5a4 <LCD_StrVar>
	LCD_StrVar(	STR_ID_LoadFontTime, fontID_2,320,20, TXT_LOAD_FONT_TIME, halfHight,0,MYGRAY,0,1,MYGRAY);
  213f8c:	4b72      	ldr	r3, [pc, #456]	; (214158 <NOWY_0+0x554>)
  213f8e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
  213f92:	4618      	mov	r0, r3
  213f94:	2303      	movs	r3, #3
  213f96:	2206      	movs	r2, #6
  213f98:	2120      	movs	r1, #32
  213f9a:	f7ed fb93 	bl	2016c4 <Int2Str>
  213f9e:	4603      	mov	r3, r0
  213fa0:	4a6e      	ldr	r2, [pc, #440]	; (21415c <NOWY_0+0x558>)
  213fa2:	4619      	mov	r1, r3
  213fa4:	2002      	movs	r0, #2
  213fa6:	f7ed fd81 	bl	201aac <StrAll>
  213faa:	4602      	mov	r2, r0
  213fac:	f107 0010 	add.w	r0, r7, #16
  213fb0:	4b68      	ldr	r3, [pc, #416]	; (214154 <NOWY_0+0x550>)
  213fb2:	9307      	str	r3, [sp, #28]
  213fb4:	2301      	movs	r3, #1
  213fb6:	9306      	str	r3, [sp, #24]
  213fb8:	2300      	movs	r3, #0
  213fba:	9305      	str	r3, [sp, #20]
  213fbc:	4b65      	ldr	r3, [pc, #404]	; (214154 <NOWY_0+0x550>)
  213fbe:	9304      	str	r3, [sp, #16]
  213fc0:	2300      	movs	r3, #0
  213fc2:	9303      	str	r3, [sp, #12]
  213fc4:	f06f 0301 	mvn.w	r3, #1
  213fc8:	9302      	str	r3, [sp, #8]
  213fca:	9201      	str	r2, [sp, #4]
  213fcc:	2314      	movs	r3, #20
  213fce:	9300      	str	r3, [sp, #0]
  213fd0:	f44f 73a0 	mov.w	r3, #320	; 0x140
  213fd4:	2201      	movs	r2, #1
  213fd6:	2102      	movs	r1, #2
  213fd8:	f7f8 fae4 	bl	20c5a4 <LCD_StrVar>

	LCD_StrDescrVar(STR_ID_PosCursor,fontID_2,440,40,"T: ",TXT_PosCursor(),halfHight,0,MYGRAY,0,1,MYGRAY);
  213fdc:	f7fe fd70 	bl	212ac0 <TXT_PosCursor>
  213fe0:	4602      	mov	r2, r0
  213fe2:	f107 0010 	add.w	r0, r7, #16
  213fe6:	4b5b      	ldr	r3, [pc, #364]	; (214154 <NOWY_0+0x550>)
  213fe8:	9308      	str	r3, [sp, #32]
  213fea:	2301      	movs	r3, #1
  213fec:	9307      	str	r3, [sp, #28]
  213fee:	2300      	movs	r3, #0
  213ff0:	9306      	str	r3, [sp, #24]
  213ff2:	4b58      	ldr	r3, [pc, #352]	; (214154 <NOWY_0+0x550>)
  213ff4:	9305      	str	r3, [sp, #20]
  213ff6:	2300      	movs	r3, #0
  213ff8:	9304      	str	r3, [sp, #16]
  213ffa:	f06f 0301 	mvn.w	r3, #1
  213ffe:	9303      	str	r3, [sp, #12]
  214000:	9202      	str	r2, [sp, #8]
  214002:	4b57      	ldr	r3, [pc, #348]	; (214160 <NOWY_0+0x55c>)
  214004:	9301      	str	r3, [sp, #4]
  214006:	2328      	movs	r3, #40	; 0x28
  214008:	9300      	str	r3, [sp, #0]
  21400a:	f44f 73dc 	mov.w	r3, #440	; 0x1b8
  21400e:	2201      	movs	r2, #1
  214010:	2109      	movs	r1, #9
  214012:	f7f8 fbaf 	bl	20c774 <LCD_StrDescrVar>

	LCD_StrVar(	STR_ID_CPU_usage, fontID_2,450,0, TXT_CPU_USAGE, halfHight,0,MYGRAY,0,1,MYGRAY);
  214016:	f003 faed 	bl	2175f4 <osGetCPUUsage>
  21401a:	4603      	mov	r3, r0
  21401c:	4618      	mov	r0, r3
  21401e:	2303      	movs	r3, #3
  214020:	2203      	movs	r2, #3
  214022:	2130      	movs	r1, #48	; 0x30
  214024:	f7ed fb4e 	bl	2016c4 <Int2Str>
  214028:	4603      	mov	r3, r0
  21402a:	4a4e      	ldr	r2, [pc, #312]	; (214164 <NOWY_0+0x560>)
  21402c:	4619      	mov	r1, r3
  21402e:	2002      	movs	r0, #2
  214030:	f7ed fd3c 	bl	201aac <StrAll>
  214034:	4602      	mov	r2, r0
  214036:	f107 0010 	add.w	r0, r7, #16
  21403a:	4b46      	ldr	r3, [pc, #280]	; (214154 <NOWY_0+0x550>)
  21403c:	9307      	str	r3, [sp, #28]
  21403e:	2301      	movs	r3, #1
  214040:	9306      	str	r3, [sp, #24]
  214042:	2300      	movs	r3, #0
  214044:	9305      	str	r3, [sp, #20]
  214046:	4b43      	ldr	r3, [pc, #268]	; (214154 <NOWY_0+0x550>)
  214048:	9304      	str	r3, [sp, #16]
  21404a:	2300      	movs	r3, #0
  21404c:	9303      	str	r3, [sp, #12]
  21404e:	f06f 0301 	mvn.w	r3, #1
  214052:	9302      	str	r3, [sp, #8]
  214054:	9201      	str	r2, [sp, #4]
  214056:	2300      	movs	r3, #0
  214058:	9300      	str	r3, [sp, #0]
  21405a:	f44f 73e1 	mov.w	r3, #450	; 0x1c2
  21405e:	2201      	movs	r2, #1
  214060:	2114      	movs	r1, #20
  214062:	f7f8 fa9f 	bl	20c5a4 <LCD_StrVar>


	 Test.yFontsField=LCD_Ypos(lenStr,IncPos,5);
  214066:	4b40      	ldr	r3, [pc, #256]	; (214168 <NOWY_0+0x564>)
  214068:	681a      	ldr	r2, [r3, #0]
  21406a:	4610      	mov	r0, r2
  21406c:	889b      	ldrh	r3, [r3, #4]
  21406e:	2100      	movs	r1, #0
  214070:	f363 010f 	bfi	r1, r3, #0, #16
  214074:	2305      	movs	r3, #5
  214076:	2202      	movs	r2, #2
  214078:	f7fe fc4e 	bl	212918 <LCD_Ypos>
  21407c:	4603      	mov	r3, r0
  21407e:	b25a      	sxtb	r2, r3
  214080:	4b35      	ldr	r3, [pc, #212]	; (214158 <NOWY_0+0x554>)
  214082:	765a      	strb	r2, [r3, #25]
	 LCD_Ymiddle(SetPos, Test.yFontsField|(LCD_GetYSize()-2)<<16 );
  214084:	4b34      	ldr	r3, [pc, #208]	; (214158 <NOWY_0+0x554>)
  214086:	f993 3019 	ldrsb.w	r3, [r3, #25]
  21408a:	461c      	mov	r4, r3
  21408c:	f7f3 fca0 	bl	2079d0 <LCD_GetYSize>
  214090:	4603      	mov	r3, r0
  214092:	3b02      	subs	r3, #2
  214094:	041b      	lsls	r3, r3, #16
  214096:	4323      	orrs	r3, r4
  214098:	4619      	mov	r1, r3
  21409a:	2000      	movs	r0, #0
  21409c:	f7fe fca0 	bl	2129e0 <LCD_Ymiddle>
	 LCD_Xmiddle(SetPos, Test.xFontsField|LCD_GetXSize()<<16,"",0,0);
  2140a0:	4b2d      	ldr	r3, [pc, #180]	; (214158 <NOWY_0+0x554>)
  2140a2:	f993 3018 	ldrsb.w	r3, [r3, #24]
  2140a6:	461c      	mov	r4, r3
  2140a8:	f7f3 fc7e 	bl	2079a8 <LCD_GetXSize>
  2140ac:	4603      	mov	r3, r0
  2140ae:	041b      	lsls	r3, r3, #16
  2140b0:	ea44 0103 	orr.w	r1, r4, r3
  2140b4:	2300      	movs	r3, #0
  2140b6:	9300      	str	r3, [sp, #0]
  2140b8:	2300      	movs	r3, #0
  2140ba:	4a2c      	ldr	r2, [pc, #176]	; (21416c <NOWY_0+0x568>)
  2140bc:	2000      	movs	r0, #0
  2140be:	f7fe fcc1 	bl	212a44 <LCD_Xmiddle>

	StartMeasureTime_us();    //daj mozliwosc wpisywania dowolnego textu aby korygowac odstepy miedzy kazdymi fontami jakimi sie chce !!!!!!!
  2140c2:	f004 fcb9 	bl	218a38 <StartMeasureTime_us>
	if(Test.type)
  2140c6:	4b24      	ldr	r3, [pc, #144]	; (214158 <NOWY_0+0x554>)
  2140c8:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
  2140cc:	2b00      	cmp	r3, #0
  2140ce:	d053      	beq.n	214178 <NOWY_0+0x574>
		lenStr=LCD_StrVar(STR_ID_Fonts,fontIDVar, LCD_Xmiddle(GetPos,fontIDVar,Test.txt,Test.spaceBetweenFonts,Test.constWidth), LCD_Ymiddle(GetPos,fontIDVar), Test.txt, fullHight, Test.spaceBetweenFonts,MYGRAY,0,Test.constWidth,MYGRAY);
  2140d0:	4b27      	ldr	r3, [pc, #156]	; (214170 <NOWY_0+0x56c>)
  2140d2:	681c      	ldr	r4, [r3, #0]
  2140d4:	4b26      	ldr	r3, [pc, #152]	; (214170 <NOWY_0+0x56c>)
  2140d6:	681b      	ldr	r3, [r3, #0]
  2140d8:	4619      	mov	r1, r3
  2140da:	4b1f      	ldr	r3, [pc, #124]	; (214158 <NOWY_0+0x554>)
  2140dc:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  2140e0:	461a      	mov	r2, r3
  2140e2:	4b1d      	ldr	r3, [pc, #116]	; (214158 <NOWY_0+0x554>)
  2140e4:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
  2140e8:	9300      	str	r3, [sp, #0]
  2140ea:	4613      	mov	r3, r2
  2140ec:	4a21      	ldr	r2, [pc, #132]	; (214174 <NOWY_0+0x570>)
  2140ee:	2001      	movs	r0, #1
  2140f0:	f7fe fca8 	bl	212a44 <LCD_Xmiddle>
  2140f4:	4603      	mov	r3, r0
  2140f6:	4698      	mov	r8, r3
  2140f8:	4b1d      	ldr	r3, [pc, #116]	; (214170 <NOWY_0+0x56c>)
  2140fa:	681b      	ldr	r3, [r3, #0]
  2140fc:	4619      	mov	r1, r3
  2140fe:	2001      	movs	r0, #1
  214100:	f7fe fc6e 	bl	2129e0 <LCD_Ymiddle>
  214104:	4603      	mov	r3, r0
  214106:	461a      	mov	r2, r3
  214108:	4b13      	ldr	r3, [pc, #76]	; (214158 <NOWY_0+0x554>)
  21410a:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  21410e:	4619      	mov	r1, r3
  214110:	4b11      	ldr	r3, [pc, #68]	; (214158 <NOWY_0+0x554>)
  214112:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
  214116:	461d      	mov	r5, r3
  214118:	4e13      	ldr	r6, [pc, #76]	; (214168 <NOWY_0+0x564>)
  21411a:	f107 0010 	add.w	r0, r7, #16
  21411e:	4b0d      	ldr	r3, [pc, #52]	; (214154 <NOWY_0+0x550>)
  214120:	9307      	str	r3, [sp, #28]
  214122:	9506      	str	r5, [sp, #24]
  214124:	2300      	movs	r3, #0
  214126:	9305      	str	r3, [sp, #20]
  214128:	4b0a      	ldr	r3, [pc, #40]	; (214154 <NOWY_0+0x550>)
  21412a:	9304      	str	r3, [sp, #16]
  21412c:	9103      	str	r1, [sp, #12]
  21412e:	f06f 0302 	mvn.w	r3, #2
  214132:	9302      	str	r3, [sp, #8]
  214134:	4b0f      	ldr	r3, [pc, #60]	; (214174 <NOWY_0+0x570>)
  214136:	9301      	str	r3, [sp, #4]
  214138:	9200      	str	r2, [sp, #0]
  21413a:	4643      	mov	r3, r8
  21413c:	4622      	mov	r2, r4
  21413e:	210a      	movs	r1, #10
  214140:	f7f8 fa30 	bl	20c5a4 <LCD_StrVar>
  214144:	4632      	mov	r2, r6
  214146:	f107 0310 	add.w	r3, r7, #16
  21414a:	6819      	ldr	r1, [r3, #0]
  21414c:	6011      	str	r1, [r2, #0]
  21414e:	889b      	ldrh	r3, [r3, #4]
  214150:	8093      	strh	r3, [r2, #4]
  214152:	e071      	b.n	214238 <NOWY_0+0x634>
  214154:	ff404040 	.word	0xff404040
  214158:	200103c0 	.word	0x200103c0
  21415c:	00228e3c 	.word	0x00228e3c
  214160:	00228e5c 	.word	0x00228e5c
  214164:	00228e40 	.word	0x00228e40
  214168:	20014a44 	.word	0x20014a44
  21416c:	00228e30 	.word	0x00228e30
  214170:	200103b8 	.word	0x200103b8
  214174:	200103e9 	.word	0x200103e9
	else
		lenStr=LCD_StrChangeColorVar(STR_ID_Fonts,fontIDVar, LCD_Xmiddle(GetPos,fontIDVar,Test.txt,Test.spaceBetweenFonts,Test.constWidth), LCD_Ymiddle(GetPos,fontIDVar), Test.txt, fullHight, Test.spaceBetweenFonts,RGB_BK,RGB_FONT,Test.coeff,Test.constWidth,MYGRAY);
  214178:	4b4a      	ldr	r3, [pc, #296]	; (2142a4 <NOWY_0+0x6a0>)
  21417a:	681d      	ldr	r5, [r3, #0]
  21417c:	4b49      	ldr	r3, [pc, #292]	; (2142a4 <NOWY_0+0x6a0>)
  21417e:	681b      	ldr	r3, [r3, #0]
  214180:	4619      	mov	r1, r3
  214182:	4b49      	ldr	r3, [pc, #292]	; (2142a8 <NOWY_0+0x6a4>)
  214184:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  214188:	461a      	mov	r2, r3
  21418a:	4b47      	ldr	r3, [pc, #284]	; (2142a8 <NOWY_0+0x6a4>)
  21418c:	f893 3109 	ldrb.w	r3, [r3, #265]	; 0x109
  214190:	9300      	str	r3, [sp, #0]
  214192:	4613      	mov	r3, r2
  214194:	4a45      	ldr	r2, [pc, #276]	; (2142ac <NOWY_0+0x6a8>)
  214196:	2001      	movs	r0, #1
  214198:	f7fe fc54 	bl	212a44 <LCD_Xmiddle>
  21419c:	4603      	mov	r3, r0
  21419e:	4698      	mov	r8, r3
  2141a0:	4b40      	ldr	r3, [pc, #256]	; (2142a4 <NOWY_0+0x6a0>)
  2141a2:	681b      	ldr	r3, [r3, #0]
  2141a4:	4619      	mov	r1, r3
  2141a6:	2001      	movs	r0, #1
  2141a8:	f7fe fc1a 	bl	2129e0 <LCD_Ymiddle>
  2141ac:	4603      	mov	r3, r0
  2141ae:	461e      	mov	r6, r3
  2141b0:	4b3d      	ldr	r3, [pc, #244]	; (2142a8 <NOWY_0+0x6a4>)
  2141b2:	f893 3107 	ldrb.w	r3, [r3, #263]	; 0x107
  2141b6:	60fb      	str	r3, [r7, #12]
  2141b8:	4b3b      	ldr	r3, [pc, #236]	; (2142a8 <NOWY_0+0x6a4>)
  2141ba:	681b      	ldr	r3, [r3, #0]
  2141bc:	041a      	lsls	r2, r3, #16
  2141be:	4b3a      	ldr	r3, [pc, #232]	; (2142a8 <NOWY_0+0x6a4>)
  2141c0:	685b      	ldr	r3, [r3, #4]
  2141c2:	021b      	lsls	r3, r3, #8
  2141c4:	431a      	orrs	r2, r3
  2141c6:	4b38      	ldr	r3, [pc, #224]	; (2142a8 <NOWY_0+0x6a4>)
  2141c8:	689b      	ldr	r3, [r3, #8]
  2141ca:	4313      	orrs	r3, r2
  2141cc:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  2141d0:	4a35      	ldr	r2, [pc, #212]	; (2142a8 <NOWY_0+0x6a4>)
  2141d2:	68d2      	ldr	r2, [r2, #12]
  2141d4:	0411      	lsls	r1, r2, #16
  2141d6:	4a34      	ldr	r2, [pc, #208]	; (2142a8 <NOWY_0+0x6a4>)
  2141d8:	6912      	ldr	r2, [r2, #16]
  2141da:	0212      	lsls	r2, r2, #8
  2141dc:	4311      	orrs	r1, r2
  2141de:	4a32      	ldr	r2, [pc, #200]	; (2142a8 <NOWY_0+0x6a4>)
  2141e0:	6952      	ldr	r2, [r2, #20]
  2141e2:	430a      	orrs	r2, r1
  2141e4:	f042 427f 	orr.w	r2, r2, #4278190080	; 0xff000000
  2141e8:	492f      	ldr	r1, [pc, #188]	; (2142a8 <NOWY_0+0x6a4>)
  2141ea:	f9b1 101c 	ldrsh.w	r1, [r1, #28]
  2141ee:	b2c9      	uxtb	r1, r1
  2141f0:	482d      	ldr	r0, [pc, #180]	; (2142a8 <NOWY_0+0x6a4>)
  2141f2:	f890 0109 	ldrb.w	r0, [r0, #265]	; 0x109
  2141f6:	60b8      	str	r0, [r7, #8]
  2141f8:	4c2d      	ldr	r4, [pc, #180]	; (2142b0 <NOWY_0+0x6ac>)
  2141fa:	607c      	str	r4, [r7, #4]
  2141fc:	f107 0410 	add.w	r4, r7, #16
  214200:	482c      	ldr	r0, [pc, #176]	; (2142b4 <NOWY_0+0x6b0>)
  214202:	9008      	str	r0, [sp, #32]
  214204:	68b8      	ldr	r0, [r7, #8]
  214206:	9007      	str	r0, [sp, #28]
  214208:	9106      	str	r1, [sp, #24]
  21420a:	9205      	str	r2, [sp, #20]
  21420c:	9304      	str	r3, [sp, #16]
  21420e:	68fb      	ldr	r3, [r7, #12]
  214210:	9303      	str	r3, [sp, #12]
  214212:	f06f 0302 	mvn.w	r3, #2
  214216:	9302      	str	r3, [sp, #8]
  214218:	4b24      	ldr	r3, [pc, #144]	; (2142ac <NOWY_0+0x6a8>)
  21421a:	9301      	str	r3, [sp, #4]
  21421c:	9600      	str	r6, [sp, #0]
  21421e:	4643      	mov	r3, r8
  214220:	462a      	mov	r2, r5
  214222:	210a      	movs	r1, #10
  214224:	4620      	mov	r0, r4
  214226:	f7f8 fdfd 	bl	20ce24 <LCD_StrChangeColorVar>
  21422a:	687a      	ldr	r2, [r7, #4]
  21422c:	f107 0310 	add.w	r3, r7, #16
  214230:	6819      	ldr	r1, [r3, #0]
  214232:	6011      	str	r1, [r2, #0]
  214234:	889b      	ldrh	r3, [r3, #4]
  214236:	8093      	strh	r3, [r2, #4]
	Test.speed=StopMeasureTime_us("");
  214238:	481f      	ldr	r0, [pc, #124]	; (2142b8 <NOWY_0+0x6b4>)
  21423a:	f004 fc0d 	bl	218a58 <StopMeasureTime_us>
  21423e:	4602      	mov	r2, r0
  214240:	4b19      	ldr	r3, [pc, #100]	; (2142a8 <NOWY_0+0x6a4>)
  214242:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc


	LCD_StrVar(STR_ID_Speed,fontID_2, 150, 0, TXT_SPEED, fullHight, 0,MYGRAY,0,1,MYGRAY);
  214246:	4b18      	ldr	r3, [pc, #96]	; (2142a8 <NOWY_0+0x6a4>)
  214248:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
  21424c:	4618      	mov	r0, r3
  21424e:	2303      	movs	r3, #3
  214250:	2206      	movs	r2, #6
  214252:	2120      	movs	r1, #32
  214254:	f7ed fa36 	bl	2016c4 <Int2Str>
  214258:	4603      	mov	r3, r0
  21425a:	4a18      	ldr	r2, [pc, #96]	; (2142bc <NOWY_0+0x6b8>)
  21425c:	4619      	mov	r1, r3
  21425e:	2002      	movs	r0, #2
  214260:	f7ed fc24 	bl	201aac <StrAll>
  214264:	4602      	mov	r2, r0
  214266:	f107 0010 	add.w	r0, r7, #16
  21426a:	4b12      	ldr	r3, [pc, #72]	; (2142b4 <NOWY_0+0x6b0>)
  21426c:	9307      	str	r3, [sp, #28]
  21426e:	2301      	movs	r3, #1
  214270:	9306      	str	r3, [sp, #24]
  214272:	2300      	movs	r3, #0
  214274:	9305      	str	r3, [sp, #20]
  214276:	4b0f      	ldr	r3, [pc, #60]	; (2142b4 <NOWY_0+0x6b0>)
  214278:	9304      	str	r3, [sp, #16]
  21427a:	2300      	movs	r3, #0
  21427c:	9303      	str	r3, [sp, #12]
  21427e:	f06f 0302 	mvn.w	r3, #2
  214282:	9302      	str	r3, [sp, #8]
  214284:	9201      	str	r2, [sp, #4]
  214286:	2300      	movs	r3, #0
  214288:	9300      	str	r3, [sp, #0]
  21428a:	2396      	movs	r3, #150	; 0x96
  21428c:	2201      	movs	r2, #1
  21428e:	2108      	movs	r1, #8
  214290:	f7f8 f988 	bl	20c5a4 <LCD_StrVar>


	LCD_Show();
  214294:	f7f1 fa9c 	bl	2057d0 <LCD_Show>


	//xTaskCreate(vtaskWifi, "vtaskWifi", 1500, NULL, (unsigned portBASE_TYPE ) 0, &vtaskWifiHandle);


}
  214298:	bf00      	nop
  21429a:	3718      	adds	r7, #24
  21429c:	46bd      	mov	sp, r7
  21429e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2142a2:	bf00      	nop
  2142a4:	200103b8 	.word	0x200103b8
  2142a8:	200103c0 	.word	0x200103c0
  2142ac:	200103e9 	.word	0x200103e9
  2142b0:	20014a44 	.word	0x20014a44
  2142b4:	ff404040 	.word	0xff404040
  2142b8:	00228e30 	.word	0x00228e30
  2142bc:	00228e38 	.word	0x00228e38

002142c0 <NOWY_1>:

void NOWY_1(void)  //dac mozliwosc zablokowania Dbg definem!!!
{
  2142c0:	b5f0      	push	{r4, r5, r6, r7, lr}
  2142c2:	b08f      	sub	sp, #60	; 0x3c
  2142c4:	af0a      	add	r7, sp, #40	; 0x28
	int bkColor=MYGRAY;
  2142c6:	4bc9      	ldr	r3, [pc, #804]	; (2145ec <NOWY_1+0x32c>)
  2142c8:	60fb      	str	r3, [r7, #12]

	SCREEN_ResetAllParameters();
  2142ca:	f7ff fc91 	bl	213bf0 <SCREEN_ResetAllParameters>
	LCD_Clear(bkColor);
  2142ce:	68fb      	ldr	r3, [r7, #12]
  2142d0:	4618      	mov	r0, r3
  2142d2:	f7f1 faf9 	bl	2058c8 <LCD_Clear>

	LCD_LoadFont_DarkgrayWhite(FONT_10, Arial, fontID_6);
  2142d6:	2205      	movs	r2, #5
  2142d8:	2105      	movs	r1, #5
  2142da:	2006      	movs	r0, #6
  2142dc:	f7f8 f88e 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	LCD_LoadFont_DarkgrayGreen(FONT_10, Arial, fontID_7);
  2142e0:	2206      	movs	r2, #6
  2142e2:	2105      	movs	r1, #5
  2142e4:	2006      	movs	r0, #6
  2142e6:	f7f8 f873 	bl	20c3d0 <LCD_LoadFont_DarkgrayGreen>


	lenStr=LCD_StrRot(Rotate_0,fontID_6,        LCD_Xpos(lenStr,SetPos,5),LCD_Ypos(lenStr,SetPos,5), "123ABCabc", fullHight, 0,DARKRED,1,1);
  2142ea:	4bc1      	ldr	r3, [pc, #772]	; (2145f0 <NOWY_1+0x330>)
  2142ec:	681a      	ldr	r2, [r3, #0]
  2142ee:	4610      	mov	r0, r2
  2142f0:	889b      	ldrh	r3, [r3, #4]
  2142f2:	2100      	movs	r1, #0
  2142f4:	f363 010f 	bfi	r1, r3, #0, #16
  2142f8:	2305      	movs	r3, #5
  2142fa:	2200      	movs	r2, #0
  2142fc:	f7fe fb3e 	bl	21297c <LCD_Xpos>
  214300:	4603      	mov	r3, r0
  214302:	461d      	mov	r5, r3
  214304:	4bba      	ldr	r3, [pc, #744]	; (2145f0 <NOWY_1+0x330>)
  214306:	681a      	ldr	r2, [r3, #0]
  214308:	4610      	mov	r0, r2
  21430a:	889b      	ldrh	r3, [r3, #4]
  21430c:	2100      	movs	r1, #0
  21430e:	f363 010f 	bfi	r1, r3, #0, #16
  214312:	2305      	movs	r3, #5
  214314:	2200      	movs	r2, #0
  214316:	f7fe faff 	bl	212918 <LCD_Ypos>
  21431a:	4603      	mov	r3, r0
  21431c:	461a      	mov	r2, r3
  21431e:	4cb4      	ldr	r4, [pc, #720]	; (2145f0 <NOWY_1+0x330>)
  214320:	4638      	mov	r0, r7
  214322:	2301      	movs	r3, #1
  214324:	9306      	str	r3, [sp, #24]
  214326:	2301      	movs	r3, #1
  214328:	9305      	str	r3, [sp, #20]
  21432a:	4bb2      	ldr	r3, [pc, #712]	; (2145f4 <NOWY_1+0x334>)
  21432c:	9304      	str	r3, [sp, #16]
  21432e:	2300      	movs	r3, #0
  214330:	9303      	str	r3, [sp, #12]
  214332:	f06f 0302 	mvn.w	r3, #2
  214336:	9302      	str	r3, [sp, #8]
  214338:	4baf      	ldr	r3, [pc, #700]	; (2145f8 <NOWY_1+0x338>)
  21433a:	9301      	str	r3, [sp, #4]
  21433c:	9200      	str	r2, [sp, #0]
  21433e:	462b      	mov	r3, r5
  214340:	2205      	movs	r2, #5
  214342:	2100      	movs	r1, #0
  214344:	f7f8 ff1e 	bl	20d184 <LCD_StrRot>
  214348:	4622      	mov	r2, r4
  21434a:	463b      	mov	r3, r7
  21434c:	6819      	ldr	r1, [r3, #0]
  21434e:	6011      	str	r1, [r2, #0]
  214350:	889b      	ldrh	r3, [r3, #4]
  214352:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214354:	f7f3 fb28 	bl	2079a8 <LCD_GetXSize>
  214358:	4604      	mov	r4, r0
  21435a:	f7f3 fb39 	bl	2079d0 <LCD_GetYSize>
  21435e:	4605      	mov	r5, r0
  214360:	4ba3      	ldr	r3, [pc, #652]	; (2145f0 <NOWY_1+0x330>)
  214362:	681a      	ldr	r2, [r3, #0]
  214364:	4610      	mov	r0, r2
  214366:	889b      	ldrh	r3, [r3, #4]
  214368:	2100      	movs	r1, #0
  21436a:	f363 010f 	bfi	r1, r3, #0, #16
  21436e:	f04f 33ff 	mov.w	r3, #4294967295
  214372:	2201      	movs	r2, #1
  214374:	f7fe fb02 	bl	21297c <LCD_Xpos>
  214378:	4603      	mov	r3, r0
  21437a:	461e      	mov	r6, r3
  21437c:	4b9c      	ldr	r3, [pc, #624]	; (2145f0 <NOWY_1+0x330>)
  21437e:	681a      	ldr	r2, [r3, #0]
  214380:	4610      	mov	r0, r2
  214382:	889b      	ldrh	r3, [r3, #4]
  214384:	2100      	movs	r1, #0
  214386:	f363 010f 	bfi	r1, r3, #0, #16
  21438a:	f04f 33ff 	mov.w	r3, #4294967295
  21438e:	2201      	movs	r2, #1
  214390:	f7fe fac2 	bl	212918 <LCD_Ypos>
  214394:	4603      	mov	r3, r0
  214396:	461a      	mov	r2, r3
  214398:	4b95      	ldr	r3, [pc, #596]	; (2145f0 <NOWY_1+0x330>)
  21439a:	885b      	ldrh	r3, [r3, #2]
  21439c:	3302      	adds	r3, #2
  21439e:	4619      	mov	r1, r3
  2143a0:	4b93      	ldr	r3, [pc, #588]	; (2145f0 <NOWY_1+0x330>)
  2143a2:	889b      	ldrh	r3, [r3, #4]
  2143a4:	3302      	adds	r3, #2
  2143a6:	4618      	mov	r0, r3
  2143a8:	2300      	movs	r3, #0
  2143aa:	9305      	str	r3, [sp, #20]
  2143ac:	2300      	movs	r3, #0
  2143ae:	9304      	str	r3, [sp, #16]
  2143b0:	f04f 33ff 	mov.w	r3, #4294967295
  2143b4:	9303      	str	r3, [sp, #12]
  2143b6:	9002      	str	r0, [sp, #8]
  2143b8:	9101      	str	r1, [sp, #4]
  2143ba:	9200      	str	r2, [sp, #0]
  2143bc:	4633      	mov	r3, r6
  2143be:	462a      	mov	r2, r5
  2143c0:	4621      	mov	r1, r4
  2143c2:	2000      	movs	r0, #0
  2143c4:	f7f1 fafa 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRot(Rotate_0,fontID_7,       LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "123ABCabc", fullHight, 0,GRAY,MYBLUE,254,1);
  2143c8:	4b89      	ldr	r3, [pc, #548]	; (2145f0 <NOWY_1+0x330>)
  2143ca:	681a      	ldr	r2, [r3, #0]
  2143cc:	4610      	mov	r0, r2
  2143ce:	889b      	ldrh	r3, [r3, #4]
  2143d0:	2100      	movs	r1, #0
  2143d2:	f363 010f 	bfi	r1, r3, #0, #16
  2143d6:	2305      	movs	r3, #5
  2143d8:	2202      	movs	r2, #2
  2143da:	f7fe facf 	bl	21297c <LCD_Xpos>
  2143de:	4603      	mov	r3, r0
  2143e0:	461d      	mov	r5, r3
  2143e2:	4b83      	ldr	r3, [pc, #524]	; (2145f0 <NOWY_1+0x330>)
  2143e4:	681a      	ldr	r2, [r3, #0]
  2143e6:	4610      	mov	r0, r2
  2143e8:	889b      	ldrh	r3, [r3, #4]
  2143ea:	2100      	movs	r1, #0
  2143ec:	f363 010f 	bfi	r1, r3, #0, #16
  2143f0:	2300      	movs	r3, #0
  2143f2:	2201      	movs	r2, #1
  2143f4:	f7fe fa90 	bl	212918 <LCD_Ypos>
  2143f8:	4603      	mov	r3, r0
  2143fa:	461a      	mov	r2, r3
  2143fc:	4c7c      	ldr	r4, [pc, #496]	; (2145f0 <NOWY_1+0x330>)
  2143fe:	4638      	mov	r0, r7
  214400:	2301      	movs	r3, #1
  214402:	9307      	str	r3, [sp, #28]
  214404:	23fe      	movs	r3, #254	; 0xfe
  214406:	9306      	str	r3, [sp, #24]
  214408:	4b7c      	ldr	r3, [pc, #496]	; (2145fc <NOWY_1+0x33c>)
  21440a:	9305      	str	r3, [sp, #20]
  21440c:	4b7c      	ldr	r3, [pc, #496]	; (214600 <NOWY_1+0x340>)
  21440e:	9304      	str	r3, [sp, #16]
  214410:	2300      	movs	r3, #0
  214412:	9303      	str	r3, [sp, #12]
  214414:	f06f 0302 	mvn.w	r3, #2
  214418:	9302      	str	r3, [sp, #8]
  21441a:	4b77      	ldr	r3, [pc, #476]	; (2145f8 <NOWY_1+0x338>)
  21441c:	9301      	str	r3, [sp, #4]
  21441e:	9200      	str	r2, [sp, #0]
  214420:	462b      	mov	r3, r5
  214422:	2206      	movs	r2, #6
  214424:	2100      	movs	r1, #0
  214426:	f7f8 ff43 	bl	20d2b0 <LCD_StrChangeColorRot>
  21442a:	4622      	mov	r2, r4
  21442c:	463b      	mov	r3, r7
  21442e:	6819      	ldr	r1, [r3, #0]
  214430:	6011      	str	r1, [r2, #0]
  214432:	889b      	ldrh	r3, [r3, #4]
  214434:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214436:	f7f3 fab7 	bl	2079a8 <LCD_GetXSize>
  21443a:	4604      	mov	r4, r0
  21443c:	f7f3 fac8 	bl	2079d0 <LCD_GetYSize>
  214440:	4605      	mov	r5, r0
  214442:	4b6b      	ldr	r3, [pc, #428]	; (2145f0 <NOWY_1+0x330>)
  214444:	681a      	ldr	r2, [r3, #0]
  214446:	4610      	mov	r0, r2
  214448:	889b      	ldrh	r3, [r3, #4]
  21444a:	2100      	movs	r1, #0
  21444c:	f363 010f 	bfi	r1, r3, #0, #16
  214450:	f04f 33ff 	mov.w	r3, #4294967295
  214454:	2201      	movs	r2, #1
  214456:	f7fe fa91 	bl	21297c <LCD_Xpos>
  21445a:	4603      	mov	r3, r0
  21445c:	461e      	mov	r6, r3
  21445e:	4b64      	ldr	r3, [pc, #400]	; (2145f0 <NOWY_1+0x330>)
  214460:	681a      	ldr	r2, [r3, #0]
  214462:	4610      	mov	r0, r2
  214464:	889b      	ldrh	r3, [r3, #4]
  214466:	2100      	movs	r1, #0
  214468:	f363 010f 	bfi	r1, r3, #0, #16
  21446c:	f04f 33ff 	mov.w	r3, #4294967295
  214470:	2201      	movs	r2, #1
  214472:	f7fe fa51 	bl	212918 <LCD_Ypos>
  214476:	4603      	mov	r3, r0
  214478:	461a      	mov	r2, r3
  21447a:	4b5d      	ldr	r3, [pc, #372]	; (2145f0 <NOWY_1+0x330>)
  21447c:	885b      	ldrh	r3, [r3, #2]
  21447e:	3302      	adds	r3, #2
  214480:	4619      	mov	r1, r3
  214482:	4b5b      	ldr	r3, [pc, #364]	; (2145f0 <NOWY_1+0x330>)
  214484:	889b      	ldrh	r3, [r3, #4]
  214486:	3302      	adds	r3, #2
  214488:	4618      	mov	r0, r3
  21448a:	2300      	movs	r3, #0
  21448c:	9305      	str	r3, [sp, #20]
  21448e:	2300      	movs	r3, #0
  214490:	9304      	str	r3, [sp, #16]
  214492:	f04f 33ff 	mov.w	r3, #4294967295
  214496:	9303      	str	r3, [sp, #12]
  214498:	9002      	str	r0, [sp, #8]
  21449a:	9101      	str	r1, [sp, #4]
  21449c:	9200      	str	r2, [sp, #0]
  21449e:	4633      	mov	r3, r6
  2144a0:	462a      	mov	r2, r5
  2144a2:	4621      	mov	r1, r4
  2144a4:	2000      	movs	r0, #0
  2144a6:	f7f1 fa89 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrRotWin(Rotate_0,120,fontID_7,       LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "Rafa Markielowski Agnieszaka Markielowska", fullHight, 0,bkColor,1,ConstWidth,0);
  2144aa:	4b51      	ldr	r3, [pc, #324]	; (2145f0 <NOWY_1+0x330>)
  2144ac:	681a      	ldr	r2, [r3, #0]
  2144ae:	4610      	mov	r0, r2
  2144b0:	889b      	ldrh	r3, [r3, #4]
  2144b2:	2100      	movs	r1, #0
  2144b4:	f363 010f 	bfi	r1, r3, #0, #16
  2144b8:	2305      	movs	r3, #5
  2144ba:	2202      	movs	r2, #2
  2144bc:	f7fe fa5e 	bl	21297c <LCD_Xpos>
  2144c0:	4603      	mov	r3, r0
  2144c2:	461c      	mov	r4, r3
  2144c4:	4b4a      	ldr	r3, [pc, #296]	; (2145f0 <NOWY_1+0x330>)
  2144c6:	681a      	ldr	r2, [r3, #0]
  2144c8:	4610      	mov	r0, r2
  2144ca:	889b      	ldrh	r3, [r3, #4]
  2144cc:	2100      	movs	r1, #0
  2144ce:	f363 010f 	bfi	r1, r3, #0, #16
  2144d2:	2300      	movs	r3, #0
  2144d4:	2201      	movs	r2, #1
  2144d6:	f7fe fa1f 	bl	212918 <LCD_Ypos>
  2144da:	4603      	mov	r3, r0
  2144dc:	4619      	mov	r1, r3
  2144de:	68fb      	ldr	r3, [r7, #12]
  2144e0:	4d43      	ldr	r5, [pc, #268]	; (2145f0 <NOWY_1+0x330>)
  2144e2:	4638      	mov	r0, r7
  2144e4:	2200      	movs	r2, #0
  2144e6:	9208      	str	r2, [sp, #32]
  2144e8:	2201      	movs	r2, #1
  2144ea:	9207      	str	r2, [sp, #28]
  2144ec:	2201      	movs	r2, #1
  2144ee:	9206      	str	r2, [sp, #24]
  2144f0:	9305      	str	r3, [sp, #20]
  2144f2:	2300      	movs	r3, #0
  2144f4:	9304      	str	r3, [sp, #16]
  2144f6:	f06f 0302 	mvn.w	r3, #2
  2144fa:	9303      	str	r3, [sp, #12]
  2144fc:	4b41      	ldr	r3, [pc, #260]	; (214604 <NOWY_1+0x344>)
  2144fe:	9302      	str	r3, [sp, #8]
  214500:	9101      	str	r1, [sp, #4]
  214502:	9400      	str	r4, [sp, #0]
  214504:	2306      	movs	r3, #6
  214506:	2278      	movs	r2, #120	; 0x78
  214508:	2100      	movs	r1, #0
  21450a:	f7f9 fcc9 	bl	20dea0 <LCD_StrRotWin>
  21450e:	462a      	mov	r2, r5
  214510:	463b      	mov	r3, r7
  214512:	6819      	ldr	r1, [r3, #0]
  214514:	6011      	str	r1, [r2, #0]
  214516:	889b      	ldrh	r3, [r3, #4]
  214518:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  21451a:	f7f3 fa45 	bl	2079a8 <LCD_GetXSize>
  21451e:	4604      	mov	r4, r0
  214520:	f7f3 fa56 	bl	2079d0 <LCD_GetYSize>
  214524:	4605      	mov	r5, r0
  214526:	4b32      	ldr	r3, [pc, #200]	; (2145f0 <NOWY_1+0x330>)
  214528:	681a      	ldr	r2, [r3, #0]
  21452a:	4610      	mov	r0, r2
  21452c:	889b      	ldrh	r3, [r3, #4]
  21452e:	2100      	movs	r1, #0
  214530:	f363 010f 	bfi	r1, r3, #0, #16
  214534:	f04f 33ff 	mov.w	r3, #4294967295
  214538:	2201      	movs	r2, #1
  21453a:	f7fe fa1f 	bl	21297c <LCD_Xpos>
  21453e:	4603      	mov	r3, r0
  214540:	461e      	mov	r6, r3
  214542:	4b2b      	ldr	r3, [pc, #172]	; (2145f0 <NOWY_1+0x330>)
  214544:	681a      	ldr	r2, [r3, #0]
  214546:	4610      	mov	r0, r2
  214548:	889b      	ldrh	r3, [r3, #4]
  21454a:	2100      	movs	r1, #0
  21454c:	f363 010f 	bfi	r1, r3, #0, #16
  214550:	f04f 33ff 	mov.w	r3, #4294967295
  214554:	2201      	movs	r2, #1
  214556:	f7fe f9df 	bl	212918 <LCD_Ypos>
  21455a:	4603      	mov	r3, r0
  21455c:	461a      	mov	r2, r3
  21455e:	4b24      	ldr	r3, [pc, #144]	; (2145f0 <NOWY_1+0x330>)
  214560:	885b      	ldrh	r3, [r3, #2]
  214562:	3302      	adds	r3, #2
  214564:	4619      	mov	r1, r3
  214566:	4b22      	ldr	r3, [pc, #136]	; (2145f0 <NOWY_1+0x330>)
  214568:	889b      	ldrh	r3, [r3, #4]
  21456a:	3302      	adds	r3, #2
  21456c:	4618      	mov	r0, r3
  21456e:	2300      	movs	r3, #0
  214570:	9305      	str	r3, [sp, #20]
  214572:	2300      	movs	r3, #0
  214574:	9304      	str	r3, [sp, #16]
  214576:	f04f 33ff 	mov.w	r3, #4294967295
  21457a:	9303      	str	r3, [sp, #12]
  21457c:	9002      	str	r0, [sp, #8]
  21457e:	9101      	str	r1, [sp, #4]
  214580:	9200      	str	r2, [sp, #0]
  214582:	4633      	mov	r3, r6
  214584:	462a      	mov	r2, r5
  214586:	4621      	mov	r1, r4
  214588:	2000      	movs	r0, #0
  21458a:	f7f1 fa17 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRotWin(Rotate_0,120,fontID_7,       LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "Rafa Markielowski Agnieszaka Markielowska", fullHight, 0,DARKRED,MAGENTA,244,ConstWidth,0);
  21458e:	4b18      	ldr	r3, [pc, #96]	; (2145f0 <NOWY_1+0x330>)
  214590:	681a      	ldr	r2, [r3, #0]
  214592:	4610      	mov	r0, r2
  214594:	889b      	ldrh	r3, [r3, #4]
  214596:	2100      	movs	r1, #0
  214598:	f363 010f 	bfi	r1, r3, #0, #16
  21459c:	2305      	movs	r3, #5
  21459e:	2202      	movs	r2, #2
  2145a0:	f7fe f9ec 	bl	21297c <LCD_Xpos>
  2145a4:	4603      	mov	r3, r0
  2145a6:	461c      	mov	r4, r3
  2145a8:	4b11      	ldr	r3, [pc, #68]	; (2145f0 <NOWY_1+0x330>)
  2145aa:	681a      	ldr	r2, [r3, #0]
  2145ac:	4610      	mov	r0, r2
  2145ae:	889b      	ldrh	r3, [r3, #4]
  2145b0:	2100      	movs	r1, #0
  2145b2:	f363 010f 	bfi	r1, r3, #0, #16
  2145b6:	2300      	movs	r3, #0
  2145b8:	2201      	movs	r2, #1
  2145ba:	f7fe f9ad 	bl	212918 <LCD_Ypos>
  2145be:	4603      	mov	r3, r0
  2145c0:	461a      	mov	r2, r3
  2145c2:	4d0b      	ldr	r5, [pc, #44]	; (2145f0 <NOWY_1+0x330>)
  2145c4:	4638      	mov	r0, r7
  2145c6:	2300      	movs	r3, #0
  2145c8:	9309      	str	r3, [sp, #36]	; 0x24
  2145ca:	2301      	movs	r3, #1
  2145cc:	9308      	str	r3, [sp, #32]
  2145ce:	23f4      	movs	r3, #244	; 0xf4
  2145d0:	9307      	str	r3, [sp, #28]
  2145d2:	f46f 437f 	mvn.w	r3, #65280	; 0xff00
  2145d6:	9306      	str	r3, [sp, #24]
  2145d8:	4b06      	ldr	r3, [pc, #24]	; (2145f4 <NOWY_1+0x334>)
  2145da:	9305      	str	r3, [sp, #20]
  2145dc:	2300      	movs	r3, #0
  2145de:	9304      	str	r3, [sp, #16]
  2145e0:	f06f 0302 	mvn.w	r3, #2
  2145e4:	9303      	str	r3, [sp, #12]
  2145e6:	4b07      	ldr	r3, [pc, #28]	; (214604 <NOWY_1+0x344>)
  2145e8:	9302      	str	r3, [sp, #8]
  2145ea:	e00d      	b.n	214608 <NOWY_1+0x348>
  2145ec:	ff404040 	.word	0xff404040
  2145f0:	20014a44 	.word	0x20014a44
  2145f4:	ff800000 	.word	0xff800000
  2145f8:	00228e60 	.word	0x00228e60
  2145fc:	ff50c8ff 	.word	0xff50c8ff
  214600:	ff808080 	.word	0xff808080
  214604:	00228e6c 	.word	0x00228e6c
  214608:	9201      	str	r2, [sp, #4]
  21460a:	9400      	str	r4, [sp, #0]
  21460c:	2306      	movs	r3, #6
  21460e:	2278      	movs	r2, #120	; 0x78
  214610:	2100      	movs	r1, #0
  214612:	f7f9 fda1 	bl	20e158 <LCD_StrChangeColorRotWin>
  214616:	462a      	mov	r2, r5
  214618:	463b      	mov	r3, r7
  21461a:	6819      	ldr	r1, [r3, #0]
  21461c:	6011      	str	r1, [r2, #0]
  21461e:	889b      	ldrh	r3, [r3, #4]
  214620:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214622:	f7f3 f9c1 	bl	2079a8 <LCD_GetXSize>
  214626:	4604      	mov	r4, r0
  214628:	f7f3 f9d2 	bl	2079d0 <LCD_GetYSize>
  21462c:	4605      	mov	r5, r0
  21462e:	4bca      	ldr	r3, [pc, #808]	; (214958 <NOWY_1+0x698>)
  214630:	681a      	ldr	r2, [r3, #0]
  214632:	4610      	mov	r0, r2
  214634:	889b      	ldrh	r3, [r3, #4]
  214636:	2100      	movs	r1, #0
  214638:	f363 010f 	bfi	r1, r3, #0, #16
  21463c:	f04f 33ff 	mov.w	r3, #4294967295
  214640:	2201      	movs	r2, #1
  214642:	f7fe f99b 	bl	21297c <LCD_Xpos>
  214646:	4603      	mov	r3, r0
  214648:	461e      	mov	r6, r3
  21464a:	4bc3      	ldr	r3, [pc, #780]	; (214958 <NOWY_1+0x698>)
  21464c:	681a      	ldr	r2, [r3, #0]
  21464e:	4610      	mov	r0, r2
  214650:	889b      	ldrh	r3, [r3, #4]
  214652:	2100      	movs	r1, #0
  214654:	f363 010f 	bfi	r1, r3, #0, #16
  214658:	f04f 33ff 	mov.w	r3, #4294967295
  21465c:	2201      	movs	r2, #1
  21465e:	f7fe f95b 	bl	212918 <LCD_Ypos>
  214662:	4603      	mov	r3, r0
  214664:	461a      	mov	r2, r3
  214666:	4bbc      	ldr	r3, [pc, #752]	; (214958 <NOWY_1+0x698>)
  214668:	885b      	ldrh	r3, [r3, #2]
  21466a:	3302      	adds	r3, #2
  21466c:	4619      	mov	r1, r3
  21466e:	4bba      	ldr	r3, [pc, #744]	; (214958 <NOWY_1+0x698>)
  214670:	889b      	ldrh	r3, [r3, #4]
  214672:	3302      	adds	r3, #2
  214674:	4618      	mov	r0, r3
  214676:	2300      	movs	r3, #0
  214678:	9305      	str	r3, [sp, #20]
  21467a:	2300      	movs	r3, #0
  21467c:	9304      	str	r3, [sp, #16]
  21467e:	f04f 33ff 	mov.w	r3, #4294967295
  214682:	9303      	str	r3, [sp, #12]
  214684:	9002      	str	r0, [sp, #8]
  214686:	9101      	str	r1, [sp, #4]
  214688:	9200      	str	r2, [sp, #0]
  21468a:	4633      	mov	r3, r6
  21468c:	462a      	mov	r2, r5
  21468e:	4621      	mov	r1, r4
  214690:	2000      	movs	r0, #0
  214692:	f7f1 f993 	bl	2059bc <LCD_Frame>



	lenStr=LCD_StrRot(Rotate_90,fontID_6,     LCD_Xpos(lenStr,SetPos,5),LCD_Ypos(lenStr,IncPos,10), "123ABCabc", fullHight, 0,DARKRED,1,1);
  214696:	4bb0      	ldr	r3, [pc, #704]	; (214958 <NOWY_1+0x698>)
  214698:	681a      	ldr	r2, [r3, #0]
  21469a:	4610      	mov	r0, r2
  21469c:	889b      	ldrh	r3, [r3, #4]
  21469e:	2100      	movs	r1, #0
  2146a0:	f363 010f 	bfi	r1, r3, #0, #16
  2146a4:	2305      	movs	r3, #5
  2146a6:	2200      	movs	r2, #0
  2146a8:	f7fe f968 	bl	21297c <LCD_Xpos>
  2146ac:	4603      	mov	r3, r0
  2146ae:	461d      	mov	r5, r3
  2146b0:	4ba9      	ldr	r3, [pc, #676]	; (214958 <NOWY_1+0x698>)
  2146b2:	681a      	ldr	r2, [r3, #0]
  2146b4:	4610      	mov	r0, r2
  2146b6:	889b      	ldrh	r3, [r3, #4]
  2146b8:	2100      	movs	r1, #0
  2146ba:	f363 010f 	bfi	r1, r3, #0, #16
  2146be:	230a      	movs	r3, #10
  2146c0:	2202      	movs	r2, #2
  2146c2:	f7fe f929 	bl	212918 <LCD_Ypos>
  2146c6:	4603      	mov	r3, r0
  2146c8:	461a      	mov	r2, r3
  2146ca:	4ca3      	ldr	r4, [pc, #652]	; (214958 <NOWY_1+0x698>)
  2146cc:	4638      	mov	r0, r7
  2146ce:	2301      	movs	r3, #1
  2146d0:	9306      	str	r3, [sp, #24]
  2146d2:	2301      	movs	r3, #1
  2146d4:	9305      	str	r3, [sp, #20]
  2146d6:	4ba1      	ldr	r3, [pc, #644]	; (21495c <NOWY_1+0x69c>)
  2146d8:	9304      	str	r3, [sp, #16]
  2146da:	2300      	movs	r3, #0
  2146dc:	9303      	str	r3, [sp, #12]
  2146de:	f06f 0302 	mvn.w	r3, #2
  2146e2:	9302      	str	r3, [sp, #8]
  2146e4:	4b9e      	ldr	r3, [pc, #632]	; (214960 <NOWY_1+0x6a0>)
  2146e6:	9301      	str	r3, [sp, #4]
  2146e8:	9200      	str	r2, [sp, #0]
  2146ea:	462b      	mov	r3, r5
  2146ec:	2205      	movs	r2, #5
  2146ee:	2101      	movs	r1, #1
  2146f0:	f7f8 fd48 	bl	20d184 <LCD_StrRot>
  2146f4:	4622      	mov	r2, r4
  2146f6:	463b      	mov	r3, r7
  2146f8:	6819      	ldr	r1, [r3, #0]
  2146fa:	6011      	str	r1, [r2, #0]
  2146fc:	889b      	ldrh	r3, [r3, #4]
  2146fe:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214700:	f7f3 f952 	bl	2079a8 <LCD_GetXSize>
  214704:	4604      	mov	r4, r0
  214706:	f7f3 f963 	bl	2079d0 <LCD_GetYSize>
  21470a:	4605      	mov	r5, r0
  21470c:	4b92      	ldr	r3, [pc, #584]	; (214958 <NOWY_1+0x698>)
  21470e:	681a      	ldr	r2, [r3, #0]
  214710:	4610      	mov	r0, r2
  214712:	889b      	ldrh	r3, [r3, #4]
  214714:	2100      	movs	r1, #0
  214716:	f363 010f 	bfi	r1, r3, #0, #16
  21471a:	f04f 33ff 	mov.w	r3, #4294967295
  21471e:	2201      	movs	r2, #1
  214720:	f7fe f92c 	bl	21297c <LCD_Xpos>
  214724:	4603      	mov	r3, r0
  214726:	461e      	mov	r6, r3
  214728:	4b8b      	ldr	r3, [pc, #556]	; (214958 <NOWY_1+0x698>)
  21472a:	681a      	ldr	r2, [r3, #0]
  21472c:	4610      	mov	r0, r2
  21472e:	889b      	ldrh	r3, [r3, #4]
  214730:	2100      	movs	r1, #0
  214732:	f363 010f 	bfi	r1, r3, #0, #16
  214736:	f04f 33ff 	mov.w	r3, #4294967295
  21473a:	2201      	movs	r2, #1
  21473c:	f7fe f8ec 	bl	212918 <LCD_Ypos>
  214740:	4603      	mov	r3, r0
  214742:	461a      	mov	r2, r3
  214744:	4b84      	ldr	r3, [pc, #528]	; (214958 <NOWY_1+0x698>)
  214746:	885b      	ldrh	r3, [r3, #2]
  214748:	3302      	adds	r3, #2
  21474a:	4619      	mov	r1, r3
  21474c:	4b82      	ldr	r3, [pc, #520]	; (214958 <NOWY_1+0x698>)
  21474e:	889b      	ldrh	r3, [r3, #4]
  214750:	3302      	adds	r3, #2
  214752:	4618      	mov	r0, r3
  214754:	2300      	movs	r3, #0
  214756:	9305      	str	r3, [sp, #20]
  214758:	2300      	movs	r3, #0
  21475a:	9304      	str	r3, [sp, #16]
  21475c:	f04f 33ff 	mov.w	r3, #4294967295
  214760:	9303      	str	r3, [sp, #12]
  214762:	9002      	str	r0, [sp, #8]
  214764:	9101      	str	r1, [sp, #4]
  214766:	9200      	str	r2, [sp, #0]
  214768:	4633      	mov	r3, r6
  21476a:	462a      	mov	r2, r5
  21476c:	4621      	mov	r1, r4
  21476e:	2000      	movs	r0, #0
  214770:	f7f1 f924 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRot(Rotate_90,fontID_7, LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "123ABCabc", fullHight, 0,GRAY,MYBLUE,254,1);
  214774:	4b78      	ldr	r3, [pc, #480]	; (214958 <NOWY_1+0x698>)
  214776:	681a      	ldr	r2, [r3, #0]
  214778:	4610      	mov	r0, r2
  21477a:	889b      	ldrh	r3, [r3, #4]
  21477c:	2100      	movs	r1, #0
  21477e:	f363 010f 	bfi	r1, r3, #0, #16
  214782:	2305      	movs	r3, #5
  214784:	2202      	movs	r2, #2
  214786:	f7fe f8f9 	bl	21297c <LCD_Xpos>
  21478a:	4603      	mov	r3, r0
  21478c:	461d      	mov	r5, r3
  21478e:	4b72      	ldr	r3, [pc, #456]	; (214958 <NOWY_1+0x698>)
  214790:	681a      	ldr	r2, [r3, #0]
  214792:	4610      	mov	r0, r2
  214794:	889b      	ldrh	r3, [r3, #4]
  214796:	2100      	movs	r1, #0
  214798:	f363 010f 	bfi	r1, r3, #0, #16
  21479c:	2300      	movs	r3, #0
  21479e:	2201      	movs	r2, #1
  2147a0:	f7fe f8ba 	bl	212918 <LCD_Ypos>
  2147a4:	4603      	mov	r3, r0
  2147a6:	461a      	mov	r2, r3
  2147a8:	4c6b      	ldr	r4, [pc, #428]	; (214958 <NOWY_1+0x698>)
  2147aa:	4638      	mov	r0, r7
  2147ac:	2301      	movs	r3, #1
  2147ae:	9307      	str	r3, [sp, #28]
  2147b0:	23fe      	movs	r3, #254	; 0xfe
  2147b2:	9306      	str	r3, [sp, #24]
  2147b4:	4b6b      	ldr	r3, [pc, #428]	; (214964 <NOWY_1+0x6a4>)
  2147b6:	9305      	str	r3, [sp, #20]
  2147b8:	4b6b      	ldr	r3, [pc, #428]	; (214968 <NOWY_1+0x6a8>)
  2147ba:	9304      	str	r3, [sp, #16]
  2147bc:	2300      	movs	r3, #0
  2147be:	9303      	str	r3, [sp, #12]
  2147c0:	f06f 0302 	mvn.w	r3, #2
  2147c4:	9302      	str	r3, [sp, #8]
  2147c6:	4b66      	ldr	r3, [pc, #408]	; (214960 <NOWY_1+0x6a0>)
  2147c8:	9301      	str	r3, [sp, #4]
  2147ca:	9200      	str	r2, [sp, #0]
  2147cc:	462b      	mov	r3, r5
  2147ce:	2206      	movs	r2, #6
  2147d0:	2101      	movs	r1, #1
  2147d2:	f7f8 fd6d 	bl	20d2b0 <LCD_StrChangeColorRot>
  2147d6:	4622      	mov	r2, r4
  2147d8:	463b      	mov	r3, r7
  2147da:	6819      	ldr	r1, [r3, #0]
  2147dc:	6011      	str	r1, [r2, #0]
  2147de:	889b      	ldrh	r3, [r3, #4]
  2147e0:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),		 LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  2147e2:	f7f3 f8e1 	bl	2079a8 <LCD_GetXSize>
  2147e6:	4604      	mov	r4, r0
  2147e8:	f7f3 f8f2 	bl	2079d0 <LCD_GetYSize>
  2147ec:	4605      	mov	r5, r0
  2147ee:	4b5a      	ldr	r3, [pc, #360]	; (214958 <NOWY_1+0x698>)
  2147f0:	681a      	ldr	r2, [r3, #0]
  2147f2:	4610      	mov	r0, r2
  2147f4:	889b      	ldrh	r3, [r3, #4]
  2147f6:	2100      	movs	r1, #0
  2147f8:	f363 010f 	bfi	r1, r3, #0, #16
  2147fc:	f04f 33ff 	mov.w	r3, #4294967295
  214800:	2201      	movs	r2, #1
  214802:	f7fe f8bb 	bl	21297c <LCD_Xpos>
  214806:	4603      	mov	r3, r0
  214808:	461e      	mov	r6, r3
  21480a:	4b53      	ldr	r3, [pc, #332]	; (214958 <NOWY_1+0x698>)
  21480c:	681a      	ldr	r2, [r3, #0]
  21480e:	4610      	mov	r0, r2
  214810:	889b      	ldrh	r3, [r3, #4]
  214812:	2100      	movs	r1, #0
  214814:	f363 010f 	bfi	r1, r3, #0, #16
  214818:	f04f 33ff 	mov.w	r3, #4294967295
  21481c:	2201      	movs	r2, #1
  21481e:	f7fe f87b 	bl	212918 <LCD_Ypos>
  214822:	4603      	mov	r3, r0
  214824:	461a      	mov	r2, r3
  214826:	4b4c      	ldr	r3, [pc, #304]	; (214958 <NOWY_1+0x698>)
  214828:	885b      	ldrh	r3, [r3, #2]
  21482a:	3302      	adds	r3, #2
  21482c:	4619      	mov	r1, r3
  21482e:	4b4a      	ldr	r3, [pc, #296]	; (214958 <NOWY_1+0x698>)
  214830:	889b      	ldrh	r3, [r3, #4]
  214832:	3302      	adds	r3, #2
  214834:	4618      	mov	r0, r3
  214836:	2300      	movs	r3, #0
  214838:	9305      	str	r3, [sp, #20]
  21483a:	2300      	movs	r3, #0
  21483c:	9304      	str	r3, [sp, #16]
  21483e:	f04f 33ff 	mov.w	r3, #4294967295
  214842:	9303      	str	r3, [sp, #12]
  214844:	9002      	str	r0, [sp, #8]
  214846:	9101      	str	r1, [sp, #4]
  214848:	9200      	str	r2, [sp, #0]
  21484a:	4633      	mov	r3, r6
  21484c:	462a      	mov	r2, r5
  21484e:	4621      	mov	r1, r4
  214850:	2000      	movs	r0, #0
  214852:	f7f1 f8b3 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrRotWin(Rotate_90,70,fontID_7,       LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "Rafa Markielowski Agnieszaka Markielowska", fullHight, 0,bkColor,1,1,0);
  214856:	4b40      	ldr	r3, [pc, #256]	; (214958 <NOWY_1+0x698>)
  214858:	681a      	ldr	r2, [r3, #0]
  21485a:	4610      	mov	r0, r2
  21485c:	889b      	ldrh	r3, [r3, #4]
  21485e:	2100      	movs	r1, #0
  214860:	f363 010f 	bfi	r1, r3, #0, #16
  214864:	2305      	movs	r3, #5
  214866:	2202      	movs	r2, #2
  214868:	f7fe f888 	bl	21297c <LCD_Xpos>
  21486c:	4603      	mov	r3, r0
  21486e:	461c      	mov	r4, r3
  214870:	4b39      	ldr	r3, [pc, #228]	; (214958 <NOWY_1+0x698>)
  214872:	681a      	ldr	r2, [r3, #0]
  214874:	4610      	mov	r0, r2
  214876:	889b      	ldrh	r3, [r3, #4]
  214878:	2100      	movs	r1, #0
  21487a:	f363 010f 	bfi	r1, r3, #0, #16
  21487e:	2300      	movs	r3, #0
  214880:	2201      	movs	r2, #1
  214882:	f7fe f849 	bl	212918 <LCD_Ypos>
  214886:	4603      	mov	r3, r0
  214888:	4619      	mov	r1, r3
  21488a:	68fb      	ldr	r3, [r7, #12]
  21488c:	4d32      	ldr	r5, [pc, #200]	; (214958 <NOWY_1+0x698>)
  21488e:	4638      	mov	r0, r7
  214890:	2200      	movs	r2, #0
  214892:	9208      	str	r2, [sp, #32]
  214894:	2201      	movs	r2, #1
  214896:	9207      	str	r2, [sp, #28]
  214898:	2201      	movs	r2, #1
  21489a:	9206      	str	r2, [sp, #24]
  21489c:	9305      	str	r3, [sp, #20]
  21489e:	2300      	movs	r3, #0
  2148a0:	9304      	str	r3, [sp, #16]
  2148a2:	f06f 0302 	mvn.w	r3, #2
  2148a6:	9303      	str	r3, [sp, #12]
  2148a8:	4b30      	ldr	r3, [pc, #192]	; (21496c <NOWY_1+0x6ac>)
  2148aa:	9302      	str	r3, [sp, #8]
  2148ac:	9101      	str	r1, [sp, #4]
  2148ae:	9400      	str	r4, [sp, #0]
  2148b0:	2306      	movs	r3, #6
  2148b2:	2246      	movs	r2, #70	; 0x46
  2148b4:	2101      	movs	r1, #1
  2148b6:	f7f9 faf3 	bl	20dea0 <LCD_StrRotWin>
  2148ba:	462a      	mov	r2, r5
  2148bc:	463b      	mov	r3, r7
  2148be:	6819      	ldr	r1, [r3, #0]
  2148c0:	6011      	str	r1, [r2, #0]
  2148c2:	889b      	ldrh	r3, [r3, #4]
  2148c4:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),		  LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  2148c6:	f7f3 f86f 	bl	2079a8 <LCD_GetXSize>
  2148ca:	4604      	mov	r4, r0
  2148cc:	f7f3 f880 	bl	2079d0 <LCD_GetYSize>
  2148d0:	4605      	mov	r5, r0
  2148d2:	4b21      	ldr	r3, [pc, #132]	; (214958 <NOWY_1+0x698>)
  2148d4:	681a      	ldr	r2, [r3, #0]
  2148d6:	4610      	mov	r0, r2
  2148d8:	889b      	ldrh	r3, [r3, #4]
  2148da:	2100      	movs	r1, #0
  2148dc:	f363 010f 	bfi	r1, r3, #0, #16
  2148e0:	f04f 33ff 	mov.w	r3, #4294967295
  2148e4:	2201      	movs	r2, #1
  2148e6:	f7fe f849 	bl	21297c <LCD_Xpos>
  2148ea:	4603      	mov	r3, r0
  2148ec:	461e      	mov	r6, r3
  2148ee:	4b1a      	ldr	r3, [pc, #104]	; (214958 <NOWY_1+0x698>)
  2148f0:	681a      	ldr	r2, [r3, #0]
  2148f2:	4610      	mov	r0, r2
  2148f4:	889b      	ldrh	r3, [r3, #4]
  2148f6:	2100      	movs	r1, #0
  2148f8:	f363 010f 	bfi	r1, r3, #0, #16
  2148fc:	f04f 33ff 	mov.w	r3, #4294967295
  214900:	2201      	movs	r2, #1
  214902:	f7fe f809 	bl	212918 <LCD_Ypos>
  214906:	4603      	mov	r3, r0
  214908:	461a      	mov	r2, r3
  21490a:	4b13      	ldr	r3, [pc, #76]	; (214958 <NOWY_1+0x698>)
  21490c:	885b      	ldrh	r3, [r3, #2]
  21490e:	3302      	adds	r3, #2
  214910:	4619      	mov	r1, r3
  214912:	4b11      	ldr	r3, [pc, #68]	; (214958 <NOWY_1+0x698>)
  214914:	889b      	ldrh	r3, [r3, #4]
  214916:	3302      	adds	r3, #2
  214918:	4618      	mov	r0, r3
  21491a:	2300      	movs	r3, #0
  21491c:	9305      	str	r3, [sp, #20]
  21491e:	2300      	movs	r3, #0
  214920:	9304      	str	r3, [sp, #16]
  214922:	f04f 33ff 	mov.w	r3, #4294967295
  214926:	9303      	str	r3, [sp, #12]
  214928:	9002      	str	r0, [sp, #8]
  21492a:	9101      	str	r1, [sp, #4]
  21492c:	9200      	str	r2, [sp, #0]
  21492e:	4633      	mov	r3, r6
  214930:	462a      	mov	r2, r5
  214932:	4621      	mov	r1, r4
  214934:	2000      	movs	r0, #0
  214936:	f7f1 f841 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRotWin(Rotate_90,70,fontID_7,LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "Rafa Markielowski Agnieszaka Markielowska", fullHight, 0,DARKRED,MAGENTA,244,1,0);
  21493a:	4b07      	ldr	r3, [pc, #28]	; (214958 <NOWY_1+0x698>)
  21493c:	681a      	ldr	r2, [r3, #0]
  21493e:	4610      	mov	r0, r2
  214940:	889b      	ldrh	r3, [r3, #4]
  214942:	2100      	movs	r1, #0
  214944:	f363 010f 	bfi	r1, r3, #0, #16
  214948:	2305      	movs	r3, #5
  21494a:	2202      	movs	r2, #2
  21494c:	f7fe f816 	bl	21297c <LCD_Xpos>
  214950:	4603      	mov	r3, r0
  214952:	461c      	mov	r4, r3
  214954:	e00c      	b.n	214970 <NOWY_1+0x6b0>
  214956:	bf00      	nop
  214958:	20014a44 	.word	0x20014a44
  21495c:	ff800000 	.word	0xff800000
  214960:	00228e60 	.word	0x00228e60
  214964:	ff50c8ff 	.word	0xff50c8ff
  214968:	ff808080 	.word	0xff808080
  21496c:	00228e6c 	.word	0x00228e6c
  214970:	4bc9      	ldr	r3, [pc, #804]	; (214c98 <NOWY_1+0x9d8>)
  214972:	681a      	ldr	r2, [r3, #0]
  214974:	4610      	mov	r0, r2
  214976:	889b      	ldrh	r3, [r3, #4]
  214978:	2100      	movs	r1, #0
  21497a:	f363 010f 	bfi	r1, r3, #0, #16
  21497e:	2300      	movs	r3, #0
  214980:	2201      	movs	r2, #1
  214982:	f7fd ffc9 	bl	212918 <LCD_Ypos>
  214986:	4603      	mov	r3, r0
  214988:	461a      	mov	r2, r3
  21498a:	4dc3      	ldr	r5, [pc, #780]	; (214c98 <NOWY_1+0x9d8>)
  21498c:	4638      	mov	r0, r7
  21498e:	2300      	movs	r3, #0
  214990:	9309      	str	r3, [sp, #36]	; 0x24
  214992:	2301      	movs	r3, #1
  214994:	9308      	str	r3, [sp, #32]
  214996:	23f4      	movs	r3, #244	; 0xf4
  214998:	9307      	str	r3, [sp, #28]
  21499a:	f46f 437f 	mvn.w	r3, #65280	; 0xff00
  21499e:	9306      	str	r3, [sp, #24]
  2149a0:	4bbe      	ldr	r3, [pc, #760]	; (214c9c <NOWY_1+0x9dc>)
  2149a2:	9305      	str	r3, [sp, #20]
  2149a4:	2300      	movs	r3, #0
  2149a6:	9304      	str	r3, [sp, #16]
  2149a8:	f06f 0302 	mvn.w	r3, #2
  2149ac:	9303      	str	r3, [sp, #12]
  2149ae:	4bbc      	ldr	r3, [pc, #752]	; (214ca0 <NOWY_1+0x9e0>)
  2149b0:	9302      	str	r3, [sp, #8]
  2149b2:	9201      	str	r2, [sp, #4]
  2149b4:	9400      	str	r4, [sp, #0]
  2149b6:	2306      	movs	r3, #6
  2149b8:	2246      	movs	r2, #70	; 0x46
  2149ba:	2101      	movs	r1, #1
  2149bc:	f7f9 fbcc 	bl	20e158 <LCD_StrChangeColorRotWin>
  2149c0:	462a      	mov	r2, r5
  2149c2:	463b      	mov	r3, r7
  2149c4:	6819      	ldr	r1, [r3, #0]
  2149c6:	6011      	str	r1, [r2, #0]
  2149c8:	889b      	ldrh	r3, [r3, #4]
  2149ca:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),				LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  2149cc:	f7f2 ffec 	bl	2079a8 <LCD_GetXSize>
  2149d0:	4604      	mov	r4, r0
  2149d2:	f7f2 fffd 	bl	2079d0 <LCD_GetYSize>
  2149d6:	4605      	mov	r5, r0
  2149d8:	4baf      	ldr	r3, [pc, #700]	; (214c98 <NOWY_1+0x9d8>)
  2149da:	681a      	ldr	r2, [r3, #0]
  2149dc:	4610      	mov	r0, r2
  2149de:	889b      	ldrh	r3, [r3, #4]
  2149e0:	2100      	movs	r1, #0
  2149e2:	f363 010f 	bfi	r1, r3, #0, #16
  2149e6:	f04f 33ff 	mov.w	r3, #4294967295
  2149ea:	2201      	movs	r2, #1
  2149ec:	f7fd ffc6 	bl	21297c <LCD_Xpos>
  2149f0:	4603      	mov	r3, r0
  2149f2:	461e      	mov	r6, r3
  2149f4:	4ba8      	ldr	r3, [pc, #672]	; (214c98 <NOWY_1+0x9d8>)
  2149f6:	681a      	ldr	r2, [r3, #0]
  2149f8:	4610      	mov	r0, r2
  2149fa:	889b      	ldrh	r3, [r3, #4]
  2149fc:	2100      	movs	r1, #0
  2149fe:	f363 010f 	bfi	r1, r3, #0, #16
  214a02:	f04f 33ff 	mov.w	r3, #4294967295
  214a06:	2201      	movs	r2, #1
  214a08:	f7fd ff86 	bl	212918 <LCD_Ypos>
  214a0c:	4603      	mov	r3, r0
  214a0e:	461a      	mov	r2, r3
  214a10:	4ba1      	ldr	r3, [pc, #644]	; (214c98 <NOWY_1+0x9d8>)
  214a12:	885b      	ldrh	r3, [r3, #2]
  214a14:	3302      	adds	r3, #2
  214a16:	4619      	mov	r1, r3
  214a18:	4b9f      	ldr	r3, [pc, #636]	; (214c98 <NOWY_1+0x9d8>)
  214a1a:	889b      	ldrh	r3, [r3, #4]
  214a1c:	3302      	adds	r3, #2
  214a1e:	4618      	mov	r0, r3
  214a20:	2300      	movs	r3, #0
  214a22:	9305      	str	r3, [sp, #20]
  214a24:	2300      	movs	r3, #0
  214a26:	9304      	str	r3, [sp, #16]
  214a28:	f04f 33ff 	mov.w	r3, #4294967295
  214a2c:	9303      	str	r3, [sp, #12]
  214a2e:	9002      	str	r0, [sp, #8]
  214a30:	9101      	str	r1, [sp, #4]
  214a32:	9200      	str	r2, [sp, #0]
  214a34:	4633      	mov	r3, r6
  214a36:	462a      	mov	r2, r5
  214a38:	4621      	mov	r1, r4
  214a3a:	2000      	movs	r0, #0
  214a3c:	f7f0 ffbe 	bl	2059bc <LCD_Frame>



	lenStr=LCD_StrRot(Rotate_180,fontID_6,     LCD_Xpos(lenStr,SetPos,5),LCD_Ypos(lenStr,IncPos,10), "123ABCabc", fullHight, 0,DARKRED,1,1);
  214a40:	4b95      	ldr	r3, [pc, #596]	; (214c98 <NOWY_1+0x9d8>)
  214a42:	681a      	ldr	r2, [r3, #0]
  214a44:	4610      	mov	r0, r2
  214a46:	889b      	ldrh	r3, [r3, #4]
  214a48:	2100      	movs	r1, #0
  214a4a:	f363 010f 	bfi	r1, r3, #0, #16
  214a4e:	2305      	movs	r3, #5
  214a50:	2200      	movs	r2, #0
  214a52:	f7fd ff93 	bl	21297c <LCD_Xpos>
  214a56:	4603      	mov	r3, r0
  214a58:	461d      	mov	r5, r3
  214a5a:	4b8f      	ldr	r3, [pc, #572]	; (214c98 <NOWY_1+0x9d8>)
  214a5c:	681a      	ldr	r2, [r3, #0]
  214a5e:	4610      	mov	r0, r2
  214a60:	889b      	ldrh	r3, [r3, #4]
  214a62:	2100      	movs	r1, #0
  214a64:	f363 010f 	bfi	r1, r3, #0, #16
  214a68:	230a      	movs	r3, #10
  214a6a:	2202      	movs	r2, #2
  214a6c:	f7fd ff54 	bl	212918 <LCD_Ypos>
  214a70:	4603      	mov	r3, r0
  214a72:	461a      	mov	r2, r3
  214a74:	4c88      	ldr	r4, [pc, #544]	; (214c98 <NOWY_1+0x9d8>)
  214a76:	4638      	mov	r0, r7
  214a78:	2301      	movs	r3, #1
  214a7a:	9306      	str	r3, [sp, #24]
  214a7c:	2301      	movs	r3, #1
  214a7e:	9305      	str	r3, [sp, #20]
  214a80:	4b86      	ldr	r3, [pc, #536]	; (214c9c <NOWY_1+0x9dc>)
  214a82:	9304      	str	r3, [sp, #16]
  214a84:	2300      	movs	r3, #0
  214a86:	9303      	str	r3, [sp, #12]
  214a88:	f06f 0302 	mvn.w	r3, #2
  214a8c:	9302      	str	r3, [sp, #8]
  214a8e:	4b85      	ldr	r3, [pc, #532]	; (214ca4 <NOWY_1+0x9e4>)
  214a90:	9301      	str	r3, [sp, #4]
  214a92:	9200      	str	r2, [sp, #0]
  214a94:	462b      	mov	r3, r5
  214a96:	2205      	movs	r2, #5
  214a98:	2102      	movs	r1, #2
  214a9a:	f7f8 fb73 	bl	20d184 <LCD_StrRot>
  214a9e:	4622      	mov	r2, r4
  214aa0:	463b      	mov	r3, r7
  214aa2:	6819      	ldr	r1, [r3, #0]
  214aa4:	6011      	str	r1, [r2, #0]
  214aa6:	889b      	ldrh	r3, [r3, #4]
  214aa8:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214aaa:	f7f2 ff7d 	bl	2079a8 <LCD_GetXSize>
  214aae:	4604      	mov	r4, r0
  214ab0:	f7f2 ff8e 	bl	2079d0 <LCD_GetYSize>
  214ab4:	4605      	mov	r5, r0
  214ab6:	4b78      	ldr	r3, [pc, #480]	; (214c98 <NOWY_1+0x9d8>)
  214ab8:	681a      	ldr	r2, [r3, #0]
  214aba:	4610      	mov	r0, r2
  214abc:	889b      	ldrh	r3, [r3, #4]
  214abe:	2100      	movs	r1, #0
  214ac0:	f363 010f 	bfi	r1, r3, #0, #16
  214ac4:	f04f 33ff 	mov.w	r3, #4294967295
  214ac8:	2201      	movs	r2, #1
  214aca:	f7fd ff57 	bl	21297c <LCD_Xpos>
  214ace:	4603      	mov	r3, r0
  214ad0:	461e      	mov	r6, r3
  214ad2:	4b71      	ldr	r3, [pc, #452]	; (214c98 <NOWY_1+0x9d8>)
  214ad4:	681a      	ldr	r2, [r3, #0]
  214ad6:	4610      	mov	r0, r2
  214ad8:	889b      	ldrh	r3, [r3, #4]
  214ada:	2100      	movs	r1, #0
  214adc:	f363 010f 	bfi	r1, r3, #0, #16
  214ae0:	f04f 33ff 	mov.w	r3, #4294967295
  214ae4:	2201      	movs	r2, #1
  214ae6:	f7fd ff17 	bl	212918 <LCD_Ypos>
  214aea:	4603      	mov	r3, r0
  214aec:	461a      	mov	r2, r3
  214aee:	4b6a      	ldr	r3, [pc, #424]	; (214c98 <NOWY_1+0x9d8>)
  214af0:	885b      	ldrh	r3, [r3, #2]
  214af2:	3302      	adds	r3, #2
  214af4:	4619      	mov	r1, r3
  214af6:	4b68      	ldr	r3, [pc, #416]	; (214c98 <NOWY_1+0x9d8>)
  214af8:	889b      	ldrh	r3, [r3, #4]
  214afa:	3302      	adds	r3, #2
  214afc:	4618      	mov	r0, r3
  214afe:	2300      	movs	r3, #0
  214b00:	9305      	str	r3, [sp, #20]
  214b02:	2300      	movs	r3, #0
  214b04:	9304      	str	r3, [sp, #16]
  214b06:	f04f 33ff 	mov.w	r3, #4294967295
  214b0a:	9303      	str	r3, [sp, #12]
  214b0c:	9002      	str	r0, [sp, #8]
  214b0e:	9101      	str	r1, [sp, #4]
  214b10:	9200      	str	r2, [sp, #0]
  214b12:	4633      	mov	r3, r6
  214b14:	462a      	mov	r2, r5
  214b16:	4621      	mov	r1, r4
  214b18:	2000      	movs	r0, #0
  214b1a:	f7f0 ff4f 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRot(Rotate_180,fontID_7, LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "123ABCabc", fullHight, 0,GRAY,MYBLUE,254,1);
  214b1e:	4b5e      	ldr	r3, [pc, #376]	; (214c98 <NOWY_1+0x9d8>)
  214b20:	681a      	ldr	r2, [r3, #0]
  214b22:	4610      	mov	r0, r2
  214b24:	889b      	ldrh	r3, [r3, #4]
  214b26:	2100      	movs	r1, #0
  214b28:	f363 010f 	bfi	r1, r3, #0, #16
  214b2c:	2305      	movs	r3, #5
  214b2e:	2202      	movs	r2, #2
  214b30:	f7fd ff24 	bl	21297c <LCD_Xpos>
  214b34:	4603      	mov	r3, r0
  214b36:	461d      	mov	r5, r3
  214b38:	4b57      	ldr	r3, [pc, #348]	; (214c98 <NOWY_1+0x9d8>)
  214b3a:	681a      	ldr	r2, [r3, #0]
  214b3c:	4610      	mov	r0, r2
  214b3e:	889b      	ldrh	r3, [r3, #4]
  214b40:	2100      	movs	r1, #0
  214b42:	f363 010f 	bfi	r1, r3, #0, #16
  214b46:	2300      	movs	r3, #0
  214b48:	2201      	movs	r2, #1
  214b4a:	f7fd fee5 	bl	212918 <LCD_Ypos>
  214b4e:	4603      	mov	r3, r0
  214b50:	461a      	mov	r2, r3
  214b52:	4c51      	ldr	r4, [pc, #324]	; (214c98 <NOWY_1+0x9d8>)
  214b54:	4638      	mov	r0, r7
  214b56:	2301      	movs	r3, #1
  214b58:	9307      	str	r3, [sp, #28]
  214b5a:	23fe      	movs	r3, #254	; 0xfe
  214b5c:	9306      	str	r3, [sp, #24]
  214b5e:	4b52      	ldr	r3, [pc, #328]	; (214ca8 <NOWY_1+0x9e8>)
  214b60:	9305      	str	r3, [sp, #20]
  214b62:	4b52      	ldr	r3, [pc, #328]	; (214cac <NOWY_1+0x9ec>)
  214b64:	9304      	str	r3, [sp, #16]
  214b66:	2300      	movs	r3, #0
  214b68:	9303      	str	r3, [sp, #12]
  214b6a:	f06f 0302 	mvn.w	r3, #2
  214b6e:	9302      	str	r3, [sp, #8]
  214b70:	4b4c      	ldr	r3, [pc, #304]	; (214ca4 <NOWY_1+0x9e4>)
  214b72:	9301      	str	r3, [sp, #4]
  214b74:	9200      	str	r2, [sp, #0]
  214b76:	462b      	mov	r3, r5
  214b78:	2206      	movs	r2, #6
  214b7a:	2102      	movs	r1, #2
  214b7c:	f7f8 fb98 	bl	20d2b0 <LCD_StrChangeColorRot>
  214b80:	4622      	mov	r2, r4
  214b82:	463b      	mov	r3, r7
  214b84:	6819      	ldr	r1, [r3, #0]
  214b86:	6011      	str	r1, [r2, #0]
  214b88:	889b      	ldrh	r3, [r3, #4]
  214b8a:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),		 LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214b8c:	f7f2 ff0c 	bl	2079a8 <LCD_GetXSize>
  214b90:	4604      	mov	r4, r0
  214b92:	f7f2 ff1d 	bl	2079d0 <LCD_GetYSize>
  214b96:	4605      	mov	r5, r0
  214b98:	4b3f      	ldr	r3, [pc, #252]	; (214c98 <NOWY_1+0x9d8>)
  214b9a:	681a      	ldr	r2, [r3, #0]
  214b9c:	4610      	mov	r0, r2
  214b9e:	889b      	ldrh	r3, [r3, #4]
  214ba0:	2100      	movs	r1, #0
  214ba2:	f363 010f 	bfi	r1, r3, #0, #16
  214ba6:	f04f 33ff 	mov.w	r3, #4294967295
  214baa:	2201      	movs	r2, #1
  214bac:	f7fd fee6 	bl	21297c <LCD_Xpos>
  214bb0:	4603      	mov	r3, r0
  214bb2:	461e      	mov	r6, r3
  214bb4:	4b38      	ldr	r3, [pc, #224]	; (214c98 <NOWY_1+0x9d8>)
  214bb6:	681a      	ldr	r2, [r3, #0]
  214bb8:	4610      	mov	r0, r2
  214bba:	889b      	ldrh	r3, [r3, #4]
  214bbc:	2100      	movs	r1, #0
  214bbe:	f363 010f 	bfi	r1, r3, #0, #16
  214bc2:	f04f 33ff 	mov.w	r3, #4294967295
  214bc6:	2201      	movs	r2, #1
  214bc8:	f7fd fea6 	bl	212918 <LCD_Ypos>
  214bcc:	4603      	mov	r3, r0
  214bce:	461a      	mov	r2, r3
  214bd0:	4b31      	ldr	r3, [pc, #196]	; (214c98 <NOWY_1+0x9d8>)
  214bd2:	885b      	ldrh	r3, [r3, #2]
  214bd4:	3302      	adds	r3, #2
  214bd6:	4619      	mov	r1, r3
  214bd8:	4b2f      	ldr	r3, [pc, #188]	; (214c98 <NOWY_1+0x9d8>)
  214bda:	889b      	ldrh	r3, [r3, #4]
  214bdc:	3302      	adds	r3, #2
  214bde:	4618      	mov	r0, r3
  214be0:	2300      	movs	r3, #0
  214be2:	9305      	str	r3, [sp, #20]
  214be4:	2300      	movs	r3, #0
  214be6:	9304      	str	r3, [sp, #16]
  214be8:	f04f 33ff 	mov.w	r3, #4294967295
  214bec:	9303      	str	r3, [sp, #12]
  214bee:	9002      	str	r0, [sp, #8]
  214bf0:	9101      	str	r1, [sp, #4]
  214bf2:	9200      	str	r2, [sp, #0]
  214bf4:	4633      	mov	r3, r6
  214bf6:	462a      	mov	r2, r5
  214bf8:	4621      	mov	r1, r4
  214bfa:	2000      	movs	r0, #0
  214bfc:	f7f0 fede 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrRotWin(Rotate_180,80,fontID_7,       LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "Rafa Markielowski Agnieszaka Markielowska", fullHight, 0,bkColor,1,1,0);
  214c00:	4b25      	ldr	r3, [pc, #148]	; (214c98 <NOWY_1+0x9d8>)
  214c02:	681a      	ldr	r2, [r3, #0]
  214c04:	4610      	mov	r0, r2
  214c06:	889b      	ldrh	r3, [r3, #4]
  214c08:	2100      	movs	r1, #0
  214c0a:	f363 010f 	bfi	r1, r3, #0, #16
  214c0e:	2305      	movs	r3, #5
  214c10:	2202      	movs	r2, #2
  214c12:	f7fd feb3 	bl	21297c <LCD_Xpos>
  214c16:	4603      	mov	r3, r0
  214c18:	461c      	mov	r4, r3
  214c1a:	4b1f      	ldr	r3, [pc, #124]	; (214c98 <NOWY_1+0x9d8>)
  214c1c:	681a      	ldr	r2, [r3, #0]
  214c1e:	4610      	mov	r0, r2
  214c20:	889b      	ldrh	r3, [r3, #4]
  214c22:	2100      	movs	r1, #0
  214c24:	f363 010f 	bfi	r1, r3, #0, #16
  214c28:	2300      	movs	r3, #0
  214c2a:	2201      	movs	r2, #1
  214c2c:	f7fd fe74 	bl	212918 <LCD_Ypos>
  214c30:	4603      	mov	r3, r0
  214c32:	4619      	mov	r1, r3
  214c34:	68fb      	ldr	r3, [r7, #12]
  214c36:	4d18      	ldr	r5, [pc, #96]	; (214c98 <NOWY_1+0x9d8>)
  214c38:	4638      	mov	r0, r7
  214c3a:	2200      	movs	r2, #0
  214c3c:	9208      	str	r2, [sp, #32]
  214c3e:	2201      	movs	r2, #1
  214c40:	9207      	str	r2, [sp, #28]
  214c42:	2201      	movs	r2, #1
  214c44:	9206      	str	r2, [sp, #24]
  214c46:	9305      	str	r3, [sp, #20]
  214c48:	2300      	movs	r3, #0
  214c4a:	9304      	str	r3, [sp, #16]
  214c4c:	f06f 0302 	mvn.w	r3, #2
  214c50:	9303      	str	r3, [sp, #12]
  214c52:	4b13      	ldr	r3, [pc, #76]	; (214ca0 <NOWY_1+0x9e0>)
  214c54:	9302      	str	r3, [sp, #8]
  214c56:	9101      	str	r1, [sp, #4]
  214c58:	9400      	str	r4, [sp, #0]
  214c5a:	2306      	movs	r3, #6
  214c5c:	2250      	movs	r2, #80	; 0x50
  214c5e:	2102      	movs	r1, #2
  214c60:	f7f9 f91e 	bl	20dea0 <LCD_StrRotWin>
  214c64:	462a      	mov	r2, r5
  214c66:	463b      	mov	r3, r7
  214c68:	6819      	ldr	r1, [r3, #0]
  214c6a:	6011      	str	r1, [r2, #0]
  214c6c:	889b      	ldrh	r3, [r3, #4]
  214c6e:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),		  LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214c70:	f7f2 fe9a 	bl	2079a8 <LCD_GetXSize>
  214c74:	4604      	mov	r4, r0
  214c76:	f7f2 feab 	bl	2079d0 <LCD_GetYSize>
  214c7a:	4605      	mov	r5, r0
  214c7c:	4b06      	ldr	r3, [pc, #24]	; (214c98 <NOWY_1+0x9d8>)
  214c7e:	681a      	ldr	r2, [r3, #0]
  214c80:	4610      	mov	r0, r2
  214c82:	889b      	ldrh	r3, [r3, #4]
  214c84:	2100      	movs	r1, #0
  214c86:	f363 010f 	bfi	r1, r3, #0, #16
  214c8a:	f04f 33ff 	mov.w	r3, #4294967295
  214c8e:	2201      	movs	r2, #1
  214c90:	f7fd fe74 	bl	21297c <LCD_Xpos>
  214c94:	4603      	mov	r3, r0
  214c96:	e00b      	b.n	214cb0 <NOWY_1+0x9f0>
  214c98:	20014a44 	.word	0x20014a44
  214c9c:	ff800000 	.word	0xff800000
  214ca0:	00228e6c 	.word	0x00228e6c
  214ca4:	00228e60 	.word	0x00228e60
  214ca8:	ff50c8ff 	.word	0xff50c8ff
  214cac:	ff808080 	.word	0xff808080
  214cb0:	461e      	mov	r6, r3
  214cb2:	4b51      	ldr	r3, [pc, #324]	; (214df8 <NOWY_1+0xb38>)
  214cb4:	681a      	ldr	r2, [r3, #0]
  214cb6:	4610      	mov	r0, r2
  214cb8:	889b      	ldrh	r3, [r3, #4]
  214cba:	2100      	movs	r1, #0
  214cbc:	f363 010f 	bfi	r1, r3, #0, #16
  214cc0:	f04f 33ff 	mov.w	r3, #4294967295
  214cc4:	2201      	movs	r2, #1
  214cc6:	f7fd fe27 	bl	212918 <LCD_Ypos>
  214cca:	4603      	mov	r3, r0
  214ccc:	461a      	mov	r2, r3
  214cce:	4b4a      	ldr	r3, [pc, #296]	; (214df8 <NOWY_1+0xb38>)
  214cd0:	885b      	ldrh	r3, [r3, #2]
  214cd2:	3302      	adds	r3, #2
  214cd4:	4619      	mov	r1, r3
  214cd6:	4b48      	ldr	r3, [pc, #288]	; (214df8 <NOWY_1+0xb38>)
  214cd8:	889b      	ldrh	r3, [r3, #4]
  214cda:	3302      	adds	r3, #2
  214cdc:	4618      	mov	r0, r3
  214cde:	2300      	movs	r3, #0
  214ce0:	9305      	str	r3, [sp, #20]
  214ce2:	2300      	movs	r3, #0
  214ce4:	9304      	str	r3, [sp, #16]
  214ce6:	f04f 33ff 	mov.w	r3, #4294967295
  214cea:	9303      	str	r3, [sp, #12]
  214cec:	9002      	str	r0, [sp, #8]
  214cee:	9101      	str	r1, [sp, #4]
  214cf0:	9200      	str	r2, [sp, #0]
  214cf2:	4633      	mov	r3, r6
  214cf4:	462a      	mov	r2, r5
  214cf6:	4621      	mov	r1, r4
  214cf8:	2000      	movs	r0, #0
  214cfa:	f7f0 fe5f 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRotWin(Rotate_180,80,fontID_7,LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), "Raf", fullHight, 0,DARKRED,MAGENTA,244,1,0);
  214cfe:	4b3e      	ldr	r3, [pc, #248]	; (214df8 <NOWY_1+0xb38>)
  214d00:	681a      	ldr	r2, [r3, #0]
  214d02:	4610      	mov	r0, r2
  214d04:	889b      	ldrh	r3, [r3, #4]
  214d06:	2100      	movs	r1, #0
  214d08:	f363 010f 	bfi	r1, r3, #0, #16
  214d0c:	2305      	movs	r3, #5
  214d0e:	2202      	movs	r2, #2
  214d10:	f7fd fe34 	bl	21297c <LCD_Xpos>
  214d14:	4603      	mov	r3, r0
  214d16:	461c      	mov	r4, r3
  214d18:	4b37      	ldr	r3, [pc, #220]	; (214df8 <NOWY_1+0xb38>)
  214d1a:	681a      	ldr	r2, [r3, #0]
  214d1c:	4610      	mov	r0, r2
  214d1e:	889b      	ldrh	r3, [r3, #4]
  214d20:	2100      	movs	r1, #0
  214d22:	f363 010f 	bfi	r1, r3, #0, #16
  214d26:	2300      	movs	r3, #0
  214d28:	2201      	movs	r2, #1
  214d2a:	f7fd fdf5 	bl	212918 <LCD_Ypos>
  214d2e:	4603      	mov	r3, r0
  214d30:	461a      	mov	r2, r3
  214d32:	4d31      	ldr	r5, [pc, #196]	; (214df8 <NOWY_1+0xb38>)
  214d34:	4638      	mov	r0, r7
  214d36:	2300      	movs	r3, #0
  214d38:	9309      	str	r3, [sp, #36]	; 0x24
  214d3a:	2301      	movs	r3, #1
  214d3c:	9308      	str	r3, [sp, #32]
  214d3e:	23f4      	movs	r3, #244	; 0xf4
  214d40:	9307      	str	r3, [sp, #28]
  214d42:	f46f 437f 	mvn.w	r3, #65280	; 0xff00
  214d46:	9306      	str	r3, [sp, #24]
  214d48:	4b2c      	ldr	r3, [pc, #176]	; (214dfc <NOWY_1+0xb3c>)
  214d4a:	9305      	str	r3, [sp, #20]
  214d4c:	2300      	movs	r3, #0
  214d4e:	9304      	str	r3, [sp, #16]
  214d50:	f06f 0302 	mvn.w	r3, #2
  214d54:	9303      	str	r3, [sp, #12]
  214d56:	4b2a      	ldr	r3, [pc, #168]	; (214e00 <NOWY_1+0xb40>)
  214d58:	9302      	str	r3, [sp, #8]
  214d5a:	9201      	str	r2, [sp, #4]
  214d5c:	9400      	str	r4, [sp, #0]
  214d5e:	2306      	movs	r3, #6
  214d60:	2250      	movs	r2, #80	; 0x50
  214d62:	2102      	movs	r1, #2
  214d64:	f7f9 f9f8 	bl	20e158 <LCD_StrChangeColorRotWin>
  214d68:	462a      	mov	r2, r5
  214d6a:	463b      	mov	r3, r7
  214d6c:	6819      	ldr	r1, [r3, #0]
  214d6e:	6011      	str	r1, [r2, #0]
  214d70:	889b      	ldrh	r3, [r3, #4]
  214d72:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),				LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214d74:	f7f2 fe18 	bl	2079a8 <LCD_GetXSize>
  214d78:	4604      	mov	r4, r0
  214d7a:	f7f2 fe29 	bl	2079d0 <LCD_GetYSize>
  214d7e:	4605      	mov	r5, r0
  214d80:	4b1d      	ldr	r3, [pc, #116]	; (214df8 <NOWY_1+0xb38>)
  214d82:	681a      	ldr	r2, [r3, #0]
  214d84:	4610      	mov	r0, r2
  214d86:	889b      	ldrh	r3, [r3, #4]
  214d88:	2100      	movs	r1, #0
  214d8a:	f363 010f 	bfi	r1, r3, #0, #16
  214d8e:	f04f 33ff 	mov.w	r3, #4294967295
  214d92:	2201      	movs	r2, #1
  214d94:	f7fd fdf2 	bl	21297c <LCD_Xpos>
  214d98:	4603      	mov	r3, r0
  214d9a:	461e      	mov	r6, r3
  214d9c:	4b16      	ldr	r3, [pc, #88]	; (214df8 <NOWY_1+0xb38>)
  214d9e:	681a      	ldr	r2, [r3, #0]
  214da0:	4610      	mov	r0, r2
  214da2:	889b      	ldrh	r3, [r3, #4]
  214da4:	2100      	movs	r1, #0
  214da6:	f363 010f 	bfi	r1, r3, #0, #16
  214daa:	f04f 33ff 	mov.w	r3, #4294967295
  214dae:	2201      	movs	r2, #1
  214db0:	f7fd fdb2 	bl	212918 <LCD_Ypos>
  214db4:	4603      	mov	r3, r0
  214db6:	461a      	mov	r2, r3
  214db8:	4b0f      	ldr	r3, [pc, #60]	; (214df8 <NOWY_1+0xb38>)
  214dba:	885b      	ldrh	r3, [r3, #2]
  214dbc:	3302      	adds	r3, #2
  214dbe:	4619      	mov	r1, r3
  214dc0:	4b0d      	ldr	r3, [pc, #52]	; (214df8 <NOWY_1+0xb38>)
  214dc2:	889b      	ldrh	r3, [r3, #4]
  214dc4:	3302      	adds	r3, #2
  214dc6:	4618      	mov	r0, r3
  214dc8:	2300      	movs	r3, #0
  214dca:	9305      	str	r3, [sp, #20]
  214dcc:	2300      	movs	r3, #0
  214dce:	9304      	str	r3, [sp, #16]
  214dd0:	f04f 33ff 	mov.w	r3, #4294967295
  214dd4:	9303      	str	r3, [sp, #12]
  214dd6:	9002      	str	r0, [sp, #8]
  214dd8:	9101      	str	r1, [sp, #4]
  214dda:	9200      	str	r2, [sp, #0]
  214ddc:	4633      	mov	r3, r6
  214dde:	462a      	mov	r2, r5
  214de0:	4621      	mov	r1, r4
  214de2:	2000      	movs	r0, #0
  214de4:	f7f0 fdea 	bl	2059bc <LCD_Frame>


	LCD_Show();
  214de8:	f7f0 fcf2 	bl	2057d0 <LCD_Show>
	DisplayFontsStructState();
  214dec:	f7f6 fb24 	bl	20b438 <DisplayFontsStructState>

}
  214df0:	bf00      	nop
  214df2:	3714      	adds	r7, #20
  214df4:	46bd      	mov	sp, r7
  214df6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  214df8:	20014a44 	.word	0x20014a44
  214dfc:	ff800000 	.word	0xff800000
  214e00:	00228e98 	.word	0x00228e98

00214e04 <NOWY_2>:

int test[6]={0,0,0,0,0,0};
void NOWY_2(void)  //dac mozliwosc zablokowania Dbg definem!!!
{
  214e04:	b5f0      	push	{r4, r5, r6, r7, lr}
  214e06:	b08f      	sub	sp, #60	; 0x3c
  214e08:	af0a      	add	r7, sp, #40	; 0x28
	int bkColor=MYGRAY;
  214e0a:	4bca      	ldr	r3, [pc, #808]	; (215134 <NOWY_2+0x330>)
  214e0c:	60fb      	str	r3, [r7, #12]

	SCREEN_ResetAllParameters();
  214e0e:	f7fe feef 	bl	213bf0 <SCREEN_ResetAllParameters>
	LCD_Clear(bkColor);
  214e12:	68fb      	ldr	r3, [r7, #12]
  214e14:	4618      	mov	r0, r3
  214e16:	f7f0 fd57 	bl	2058c8 <LCD_Clear>

	LCD_LoadFont_DarkgrayWhite(FONT_14, Arial, fontID_6);
  214e1a:	2205      	movs	r2, #5
  214e1c:	2105      	movs	r1, #5
  214e1e:	200f      	movs	r0, #15
  214e20:	f7f7 faec 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	LCD_LoadFont_DarkgrayGreen(FONT_14, Arial, fontID_7);
  214e24:	2206      	movs	r2, #6
  214e26:	2105      	movs	r1, #5
  214e28:	200f      	movs	r0, #15
  214e2a:	f7f7 fad1 	bl	20c3d0 <LCD_LoadFont_DarkgrayGreen>


	lenStr=LCD_StrRotVar(fontVar_1,Rotate_0,fontID_6,  LCD_Xpos(lenStr,SetPos,5),LCD_Ypos(lenStr,SetPos,5), INT2STR(test[0]), halfHight, 0,DARKRED,1,ConstWidth,bkColor);
  214e2e:	4bc2      	ldr	r3, [pc, #776]	; (215138 <NOWY_2+0x334>)
  214e30:	681a      	ldr	r2, [r3, #0]
  214e32:	4610      	mov	r0, r2
  214e34:	889b      	ldrh	r3, [r3, #4]
  214e36:	2100      	movs	r1, #0
  214e38:	f363 010f 	bfi	r1, r3, #0, #16
  214e3c:	2305      	movs	r3, #5
  214e3e:	2200      	movs	r2, #0
  214e40:	f7fd fd9c 	bl	21297c <LCD_Xpos>
  214e44:	4603      	mov	r3, r0
  214e46:	461c      	mov	r4, r3
  214e48:	4bbb      	ldr	r3, [pc, #748]	; (215138 <NOWY_2+0x334>)
  214e4a:	681a      	ldr	r2, [r3, #0]
  214e4c:	4610      	mov	r0, r2
  214e4e:	889b      	ldrh	r3, [r3, #4]
  214e50:	2100      	movs	r1, #0
  214e52:	f363 010f 	bfi	r1, r3, #0, #16
  214e56:	2305      	movs	r3, #5
  214e58:	2200      	movs	r2, #0
  214e5a:	f7fd fd5d 	bl	212918 <LCD_Ypos>
  214e5e:	4603      	mov	r3, r0
  214e60:	461d      	mov	r5, r3
  214e62:	4bb6      	ldr	r3, [pc, #728]	; (21513c <NOWY_2+0x338>)
  214e64:	6818      	ldr	r0, [r3, #0]
  214e66:	2303      	movs	r3, #3
  214e68:	2203      	movs	r2, #3
  214e6a:	2130      	movs	r1, #48	; 0x30
  214e6c:	f7ec fc2a 	bl	2016c4 <Int2Str>
  214e70:	4602      	mov	r2, r0
  214e72:	68fb      	ldr	r3, [r7, #12]
  214e74:	4eb0      	ldr	r6, [pc, #704]	; (215138 <NOWY_2+0x334>)
  214e76:	4638      	mov	r0, r7
  214e78:	9308      	str	r3, [sp, #32]
  214e7a:	2301      	movs	r3, #1
  214e7c:	9307      	str	r3, [sp, #28]
  214e7e:	2301      	movs	r3, #1
  214e80:	9306      	str	r3, [sp, #24]
  214e82:	4baf      	ldr	r3, [pc, #700]	; (215140 <NOWY_2+0x33c>)
  214e84:	9305      	str	r3, [sp, #20]
  214e86:	2300      	movs	r3, #0
  214e88:	9304      	str	r3, [sp, #16]
  214e8a:	f06f 0301 	mvn.w	r3, #1
  214e8e:	9303      	str	r3, [sp, #12]
  214e90:	9202      	str	r2, [sp, #8]
  214e92:	9501      	str	r5, [sp, #4]
  214e94:	9400      	str	r4, [sp, #0]
  214e96:	2305      	movs	r3, #5
  214e98:	2200      	movs	r2, #0
  214e9a:	2100      	movs	r1, #0
  214e9c:	f7f8 faa2 	bl	20d3e4 <LCD_StrRotVar>
  214ea0:	4632      	mov	r2, r6
  214ea2:	463b      	mov	r3, r7
  214ea4:	6819      	ldr	r1, [r3, #0]
  214ea6:	6011      	str	r1, [r2, #0]
  214ea8:	889b      	ldrh	r3, [r3, #4]
  214eaa:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),			LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214eac:	f7f2 fd7c 	bl	2079a8 <LCD_GetXSize>
  214eb0:	4604      	mov	r4, r0
  214eb2:	f7f2 fd8d 	bl	2079d0 <LCD_GetYSize>
  214eb6:	4605      	mov	r5, r0
  214eb8:	4b9f      	ldr	r3, [pc, #636]	; (215138 <NOWY_2+0x334>)
  214eba:	681a      	ldr	r2, [r3, #0]
  214ebc:	4610      	mov	r0, r2
  214ebe:	889b      	ldrh	r3, [r3, #4]
  214ec0:	2100      	movs	r1, #0
  214ec2:	f363 010f 	bfi	r1, r3, #0, #16
  214ec6:	f04f 33ff 	mov.w	r3, #4294967295
  214eca:	2201      	movs	r2, #1
  214ecc:	f7fd fd56 	bl	21297c <LCD_Xpos>
  214ed0:	4603      	mov	r3, r0
  214ed2:	461e      	mov	r6, r3
  214ed4:	4b98      	ldr	r3, [pc, #608]	; (215138 <NOWY_2+0x334>)
  214ed6:	681a      	ldr	r2, [r3, #0]
  214ed8:	4610      	mov	r0, r2
  214eda:	889b      	ldrh	r3, [r3, #4]
  214edc:	2100      	movs	r1, #0
  214ede:	f363 010f 	bfi	r1, r3, #0, #16
  214ee2:	f04f 33ff 	mov.w	r3, #4294967295
  214ee6:	2201      	movs	r2, #1
  214ee8:	f7fd fd16 	bl	212918 <LCD_Ypos>
  214eec:	4603      	mov	r3, r0
  214eee:	461a      	mov	r2, r3
  214ef0:	4b91      	ldr	r3, [pc, #580]	; (215138 <NOWY_2+0x334>)
  214ef2:	885b      	ldrh	r3, [r3, #2]
  214ef4:	3302      	adds	r3, #2
  214ef6:	4619      	mov	r1, r3
  214ef8:	4b8f      	ldr	r3, [pc, #572]	; (215138 <NOWY_2+0x334>)
  214efa:	889b      	ldrh	r3, [r3, #4]
  214efc:	3302      	adds	r3, #2
  214efe:	4618      	mov	r0, r3
  214f00:	2300      	movs	r3, #0
  214f02:	9305      	str	r3, [sp, #20]
  214f04:	2300      	movs	r3, #0
  214f06:	9304      	str	r3, [sp, #16]
  214f08:	f04f 33ff 	mov.w	r3, #4294967295
  214f0c:	9303      	str	r3, [sp, #12]
  214f0e:	9002      	str	r0, [sp, #8]
  214f10:	9101      	str	r1, [sp, #4]
  214f12:	9200      	str	r2, [sp, #0]
  214f14:	4633      	mov	r3, r6
  214f16:	462a      	mov	r2, r5
  214f18:	4621      	mov	r1, r4
  214f1a:	2000      	movs	r0, #0
  214f1c:	f7f0 fd4e 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRotVar(fontVar_2,Rotate_0,fontID_7, LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), INT2STR(test[1]), halfHight, 0,GRAY,MYBLUE,249,ConstWidth,bkColor);
  214f20:	4b85      	ldr	r3, [pc, #532]	; (215138 <NOWY_2+0x334>)
  214f22:	681a      	ldr	r2, [r3, #0]
  214f24:	4610      	mov	r0, r2
  214f26:	889b      	ldrh	r3, [r3, #4]
  214f28:	2100      	movs	r1, #0
  214f2a:	f363 010f 	bfi	r1, r3, #0, #16
  214f2e:	2305      	movs	r3, #5
  214f30:	2202      	movs	r2, #2
  214f32:	f7fd fd23 	bl	21297c <LCD_Xpos>
  214f36:	4603      	mov	r3, r0
  214f38:	461c      	mov	r4, r3
  214f3a:	4b7f      	ldr	r3, [pc, #508]	; (215138 <NOWY_2+0x334>)
  214f3c:	681a      	ldr	r2, [r3, #0]
  214f3e:	4610      	mov	r0, r2
  214f40:	889b      	ldrh	r3, [r3, #4]
  214f42:	2100      	movs	r1, #0
  214f44:	f363 010f 	bfi	r1, r3, #0, #16
  214f48:	2300      	movs	r3, #0
  214f4a:	2201      	movs	r2, #1
  214f4c:	f7fd fce4 	bl	212918 <LCD_Ypos>
  214f50:	4603      	mov	r3, r0
  214f52:	461d      	mov	r5, r3
  214f54:	4b79      	ldr	r3, [pc, #484]	; (21513c <NOWY_2+0x338>)
  214f56:	6858      	ldr	r0, [r3, #4]
  214f58:	2303      	movs	r3, #3
  214f5a:	2203      	movs	r2, #3
  214f5c:	2130      	movs	r1, #48	; 0x30
  214f5e:	f7ec fbb1 	bl	2016c4 <Int2Str>
  214f62:	4602      	mov	r2, r0
  214f64:	68fb      	ldr	r3, [r7, #12]
  214f66:	4e74      	ldr	r6, [pc, #464]	; (215138 <NOWY_2+0x334>)
  214f68:	4638      	mov	r0, r7
  214f6a:	9309      	str	r3, [sp, #36]	; 0x24
  214f6c:	2301      	movs	r3, #1
  214f6e:	9308      	str	r3, [sp, #32]
  214f70:	23f9      	movs	r3, #249	; 0xf9
  214f72:	9307      	str	r3, [sp, #28]
  214f74:	4b73      	ldr	r3, [pc, #460]	; (215144 <NOWY_2+0x340>)
  214f76:	9306      	str	r3, [sp, #24]
  214f78:	4b73      	ldr	r3, [pc, #460]	; (215148 <NOWY_2+0x344>)
  214f7a:	9305      	str	r3, [sp, #20]
  214f7c:	2300      	movs	r3, #0
  214f7e:	9304      	str	r3, [sp, #16]
  214f80:	f06f 0301 	mvn.w	r3, #1
  214f84:	9303      	str	r3, [sp, #12]
  214f86:	9202      	str	r2, [sp, #8]
  214f88:	9501      	str	r5, [sp, #4]
  214f8a:	9400      	str	r4, [sp, #0]
  214f8c:	2306      	movs	r3, #6
  214f8e:	2200      	movs	r2, #0
  214f90:	2101      	movs	r1, #1
  214f92:	f7f8 fb6b 	bl	20d66c <LCD_StrChangeColorRotVar>
  214f96:	4632      	mov	r2, r6
  214f98:	463b      	mov	r3, r7
  214f9a:	6819      	ldr	r1, [r3, #0]
  214f9c:	6011      	str	r1, [r2, #0]
  214f9e:	889b      	ldrh	r3, [r3, #4]
  214fa0:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),						LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  214fa2:	f7f2 fd01 	bl	2079a8 <LCD_GetXSize>
  214fa6:	4604      	mov	r4, r0
  214fa8:	f7f2 fd12 	bl	2079d0 <LCD_GetYSize>
  214fac:	4605      	mov	r5, r0
  214fae:	4b62      	ldr	r3, [pc, #392]	; (215138 <NOWY_2+0x334>)
  214fb0:	681a      	ldr	r2, [r3, #0]
  214fb2:	4610      	mov	r0, r2
  214fb4:	889b      	ldrh	r3, [r3, #4]
  214fb6:	2100      	movs	r1, #0
  214fb8:	f363 010f 	bfi	r1, r3, #0, #16
  214fbc:	f04f 33ff 	mov.w	r3, #4294967295
  214fc0:	2201      	movs	r2, #1
  214fc2:	f7fd fcdb 	bl	21297c <LCD_Xpos>
  214fc6:	4603      	mov	r3, r0
  214fc8:	461e      	mov	r6, r3
  214fca:	4b5b      	ldr	r3, [pc, #364]	; (215138 <NOWY_2+0x334>)
  214fcc:	681a      	ldr	r2, [r3, #0]
  214fce:	4610      	mov	r0, r2
  214fd0:	889b      	ldrh	r3, [r3, #4]
  214fd2:	2100      	movs	r1, #0
  214fd4:	f363 010f 	bfi	r1, r3, #0, #16
  214fd8:	f04f 33ff 	mov.w	r3, #4294967295
  214fdc:	2201      	movs	r2, #1
  214fde:	f7fd fc9b 	bl	212918 <LCD_Ypos>
  214fe2:	4603      	mov	r3, r0
  214fe4:	461a      	mov	r2, r3
  214fe6:	4b54      	ldr	r3, [pc, #336]	; (215138 <NOWY_2+0x334>)
  214fe8:	885b      	ldrh	r3, [r3, #2]
  214fea:	3302      	adds	r3, #2
  214fec:	4619      	mov	r1, r3
  214fee:	4b52      	ldr	r3, [pc, #328]	; (215138 <NOWY_2+0x334>)
  214ff0:	889b      	ldrh	r3, [r3, #4]
  214ff2:	3302      	adds	r3, #2
  214ff4:	4618      	mov	r0, r3
  214ff6:	2300      	movs	r3, #0
  214ff8:	9305      	str	r3, [sp, #20]
  214ffa:	2300      	movs	r3, #0
  214ffc:	9304      	str	r3, [sp, #16]
  214ffe:	f04f 33ff 	mov.w	r3, #4294967295
  215002:	9303      	str	r3, [sp, #12]
  215004:	9002      	str	r0, [sp, #8]
  215006:	9101      	str	r1, [sp, #4]
  215008:	9200      	str	r2, [sp, #0]
  21500a:	4633      	mov	r3, r6
  21500c:	462a      	mov	r2, r5
  21500e:	4621      	mov	r1, r4
  215010:	2000      	movs	r0, #0
  215012:	f7f0 fcd3 	bl	2059bc <LCD_Frame>


	lenStr=LCD_StrRotVar(fontVar_3,Rotate_90,fontID_6, LCD_Xpos(lenStr,SetPos,5),LCD_Ypos(lenStr,IncPos,10), INT2STR(test[2]), halfHight, 0,DARKRED,1,ConstWidth,bkColor);
  215016:	4b48      	ldr	r3, [pc, #288]	; (215138 <NOWY_2+0x334>)
  215018:	681a      	ldr	r2, [r3, #0]
  21501a:	4610      	mov	r0, r2
  21501c:	889b      	ldrh	r3, [r3, #4]
  21501e:	2100      	movs	r1, #0
  215020:	f363 010f 	bfi	r1, r3, #0, #16
  215024:	2305      	movs	r3, #5
  215026:	2200      	movs	r2, #0
  215028:	f7fd fca8 	bl	21297c <LCD_Xpos>
  21502c:	4603      	mov	r3, r0
  21502e:	461c      	mov	r4, r3
  215030:	4b41      	ldr	r3, [pc, #260]	; (215138 <NOWY_2+0x334>)
  215032:	681a      	ldr	r2, [r3, #0]
  215034:	4610      	mov	r0, r2
  215036:	889b      	ldrh	r3, [r3, #4]
  215038:	2100      	movs	r1, #0
  21503a:	f363 010f 	bfi	r1, r3, #0, #16
  21503e:	230a      	movs	r3, #10
  215040:	2202      	movs	r2, #2
  215042:	f7fd fc69 	bl	212918 <LCD_Ypos>
  215046:	4603      	mov	r3, r0
  215048:	461d      	mov	r5, r3
  21504a:	4b3c      	ldr	r3, [pc, #240]	; (21513c <NOWY_2+0x338>)
  21504c:	6898      	ldr	r0, [r3, #8]
  21504e:	2303      	movs	r3, #3
  215050:	2203      	movs	r2, #3
  215052:	2130      	movs	r1, #48	; 0x30
  215054:	f7ec fb36 	bl	2016c4 <Int2Str>
  215058:	4602      	mov	r2, r0
  21505a:	68fb      	ldr	r3, [r7, #12]
  21505c:	4e36      	ldr	r6, [pc, #216]	; (215138 <NOWY_2+0x334>)
  21505e:	4638      	mov	r0, r7
  215060:	9308      	str	r3, [sp, #32]
  215062:	2301      	movs	r3, #1
  215064:	9307      	str	r3, [sp, #28]
  215066:	2301      	movs	r3, #1
  215068:	9306      	str	r3, [sp, #24]
  21506a:	4b35      	ldr	r3, [pc, #212]	; (215140 <NOWY_2+0x33c>)
  21506c:	9305      	str	r3, [sp, #20]
  21506e:	2300      	movs	r3, #0
  215070:	9304      	str	r3, [sp, #16]
  215072:	f06f 0301 	mvn.w	r3, #1
  215076:	9303      	str	r3, [sp, #12]
  215078:	9202      	str	r2, [sp, #8]
  21507a:	9501      	str	r5, [sp, #4]
  21507c:	9400      	str	r4, [sp, #0]
  21507e:	2305      	movs	r3, #5
  215080:	2201      	movs	r2, #1
  215082:	2102      	movs	r1, #2
  215084:	f7f8 f9ae 	bl	20d3e4 <LCD_StrRotVar>
  215088:	4632      	mov	r2, r6
  21508a:	463b      	mov	r3, r7
  21508c:	6819      	ldr	r1, [r3, #0]
  21508e:	6011      	str	r1, [r2, #0]
  215090:	889b      	ldrh	r3, [r3, #4]
  215092:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),			LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  215094:	f7f2 fc88 	bl	2079a8 <LCD_GetXSize>
  215098:	4604      	mov	r4, r0
  21509a:	f7f2 fc99 	bl	2079d0 <LCD_GetYSize>
  21509e:	4605      	mov	r5, r0
  2150a0:	4b25      	ldr	r3, [pc, #148]	; (215138 <NOWY_2+0x334>)
  2150a2:	681a      	ldr	r2, [r3, #0]
  2150a4:	4610      	mov	r0, r2
  2150a6:	889b      	ldrh	r3, [r3, #4]
  2150a8:	2100      	movs	r1, #0
  2150aa:	f363 010f 	bfi	r1, r3, #0, #16
  2150ae:	f04f 33ff 	mov.w	r3, #4294967295
  2150b2:	2201      	movs	r2, #1
  2150b4:	f7fd fc62 	bl	21297c <LCD_Xpos>
  2150b8:	4603      	mov	r3, r0
  2150ba:	461e      	mov	r6, r3
  2150bc:	4b1e      	ldr	r3, [pc, #120]	; (215138 <NOWY_2+0x334>)
  2150be:	681a      	ldr	r2, [r3, #0]
  2150c0:	4610      	mov	r0, r2
  2150c2:	889b      	ldrh	r3, [r3, #4]
  2150c4:	2100      	movs	r1, #0
  2150c6:	f363 010f 	bfi	r1, r3, #0, #16
  2150ca:	f04f 33ff 	mov.w	r3, #4294967295
  2150ce:	2201      	movs	r2, #1
  2150d0:	f7fd fc22 	bl	212918 <LCD_Ypos>
  2150d4:	4603      	mov	r3, r0
  2150d6:	461a      	mov	r2, r3
  2150d8:	4b17      	ldr	r3, [pc, #92]	; (215138 <NOWY_2+0x334>)
  2150da:	885b      	ldrh	r3, [r3, #2]
  2150dc:	3302      	adds	r3, #2
  2150de:	4619      	mov	r1, r3
  2150e0:	4b15      	ldr	r3, [pc, #84]	; (215138 <NOWY_2+0x334>)
  2150e2:	889b      	ldrh	r3, [r3, #4]
  2150e4:	3302      	adds	r3, #2
  2150e6:	4618      	mov	r0, r3
  2150e8:	2300      	movs	r3, #0
  2150ea:	9305      	str	r3, [sp, #20]
  2150ec:	2300      	movs	r3, #0
  2150ee:	9304      	str	r3, [sp, #16]
  2150f0:	f04f 33ff 	mov.w	r3, #4294967295
  2150f4:	9303      	str	r3, [sp, #12]
  2150f6:	9002      	str	r0, [sp, #8]
  2150f8:	9101      	str	r1, [sp, #4]
  2150fa:	9200      	str	r2, [sp, #0]
  2150fc:	4633      	mov	r3, r6
  2150fe:	462a      	mov	r2, r5
  215100:	4621      	mov	r1, r4
  215102:	2000      	movs	r0, #0
  215104:	f7f0 fc5a 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRotVar(fontVar_4,Rotate_90,fontID_7, LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), INT2STR(test[3]), halfHight, 0,GRAY,MYBLUE,249,ConstWidth,bkColor);
  215108:	4b0b      	ldr	r3, [pc, #44]	; (215138 <NOWY_2+0x334>)
  21510a:	681a      	ldr	r2, [r3, #0]
  21510c:	4610      	mov	r0, r2
  21510e:	889b      	ldrh	r3, [r3, #4]
  215110:	2100      	movs	r1, #0
  215112:	f363 010f 	bfi	r1, r3, #0, #16
  215116:	2305      	movs	r3, #5
  215118:	2202      	movs	r2, #2
  21511a:	f7fd fc2f 	bl	21297c <LCD_Xpos>
  21511e:	4603      	mov	r3, r0
  215120:	461c      	mov	r4, r3
  215122:	4b05      	ldr	r3, [pc, #20]	; (215138 <NOWY_2+0x334>)
  215124:	681a      	ldr	r2, [r3, #0]
  215126:	4610      	mov	r0, r2
  215128:	889b      	ldrh	r3, [r3, #4]
  21512a:	2100      	movs	r1, #0
  21512c:	f363 010f 	bfi	r1, r3, #0, #16
  215130:	e00c      	b.n	21514c <NOWY_2+0x348>
  215132:	bf00      	nop
  215134:	ff404040 	.word	0xff404040
  215138:	20014a44 	.word	0x20014a44
  21513c:	200104d0 	.word	0x200104d0
  215140:	ff800000 	.word	0xff800000
  215144:	ff50c8ff 	.word	0xff50c8ff
  215148:	ff808080 	.word	0xff808080
  21514c:	2300      	movs	r3, #0
  21514e:	2201      	movs	r2, #1
  215150:	f7fd fbe2 	bl	212918 <LCD_Ypos>
  215154:	4603      	mov	r3, r0
  215156:	461d      	mov	r5, r3
  215158:	4bc5      	ldr	r3, [pc, #788]	; (215470 <NOWY_2+0x66c>)
  21515a:	68d8      	ldr	r0, [r3, #12]
  21515c:	2303      	movs	r3, #3
  21515e:	2203      	movs	r2, #3
  215160:	2130      	movs	r1, #48	; 0x30
  215162:	f7ec faaf 	bl	2016c4 <Int2Str>
  215166:	4602      	mov	r2, r0
  215168:	68fb      	ldr	r3, [r7, #12]
  21516a:	4ec2      	ldr	r6, [pc, #776]	; (215474 <NOWY_2+0x670>)
  21516c:	4638      	mov	r0, r7
  21516e:	9309      	str	r3, [sp, #36]	; 0x24
  215170:	2301      	movs	r3, #1
  215172:	9308      	str	r3, [sp, #32]
  215174:	23f9      	movs	r3, #249	; 0xf9
  215176:	9307      	str	r3, [sp, #28]
  215178:	4bbf      	ldr	r3, [pc, #764]	; (215478 <NOWY_2+0x674>)
  21517a:	9306      	str	r3, [sp, #24]
  21517c:	4bbf      	ldr	r3, [pc, #764]	; (21547c <NOWY_2+0x678>)
  21517e:	9305      	str	r3, [sp, #20]
  215180:	2300      	movs	r3, #0
  215182:	9304      	str	r3, [sp, #16]
  215184:	f06f 0301 	mvn.w	r3, #1
  215188:	9303      	str	r3, [sp, #12]
  21518a:	9202      	str	r2, [sp, #8]
  21518c:	9501      	str	r5, [sp, #4]
  21518e:	9400      	str	r4, [sp, #0]
  215190:	2306      	movs	r3, #6
  215192:	2201      	movs	r2, #1
  215194:	2103      	movs	r1, #3
  215196:	f7f8 fa69 	bl	20d66c <LCD_StrChangeColorRotVar>
  21519a:	4632      	mov	r2, r6
  21519c:	463b      	mov	r3, r7
  21519e:	6819      	ldr	r1, [r3, #0]
  2151a0:	6011      	str	r1, [r2, #0]
  2151a2:	889b      	ldrh	r3, [r3, #4]
  2151a4:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),						 LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  2151a6:	f7f2 fbff 	bl	2079a8 <LCD_GetXSize>
  2151aa:	4604      	mov	r4, r0
  2151ac:	f7f2 fc10 	bl	2079d0 <LCD_GetYSize>
  2151b0:	4605      	mov	r5, r0
  2151b2:	4bb0      	ldr	r3, [pc, #704]	; (215474 <NOWY_2+0x670>)
  2151b4:	681a      	ldr	r2, [r3, #0]
  2151b6:	4610      	mov	r0, r2
  2151b8:	889b      	ldrh	r3, [r3, #4]
  2151ba:	2100      	movs	r1, #0
  2151bc:	f363 010f 	bfi	r1, r3, #0, #16
  2151c0:	f04f 33ff 	mov.w	r3, #4294967295
  2151c4:	2201      	movs	r2, #1
  2151c6:	f7fd fbd9 	bl	21297c <LCD_Xpos>
  2151ca:	4603      	mov	r3, r0
  2151cc:	461e      	mov	r6, r3
  2151ce:	4ba9      	ldr	r3, [pc, #676]	; (215474 <NOWY_2+0x670>)
  2151d0:	681a      	ldr	r2, [r3, #0]
  2151d2:	4610      	mov	r0, r2
  2151d4:	889b      	ldrh	r3, [r3, #4]
  2151d6:	2100      	movs	r1, #0
  2151d8:	f363 010f 	bfi	r1, r3, #0, #16
  2151dc:	f04f 33ff 	mov.w	r3, #4294967295
  2151e0:	2201      	movs	r2, #1
  2151e2:	f7fd fb99 	bl	212918 <LCD_Ypos>
  2151e6:	4603      	mov	r3, r0
  2151e8:	461a      	mov	r2, r3
  2151ea:	4ba2      	ldr	r3, [pc, #648]	; (215474 <NOWY_2+0x670>)
  2151ec:	885b      	ldrh	r3, [r3, #2]
  2151ee:	3302      	adds	r3, #2
  2151f0:	4619      	mov	r1, r3
  2151f2:	4ba0      	ldr	r3, [pc, #640]	; (215474 <NOWY_2+0x670>)
  2151f4:	889b      	ldrh	r3, [r3, #4]
  2151f6:	3302      	adds	r3, #2
  2151f8:	4618      	mov	r0, r3
  2151fa:	2300      	movs	r3, #0
  2151fc:	9305      	str	r3, [sp, #20]
  2151fe:	2300      	movs	r3, #0
  215200:	9304      	str	r3, [sp, #16]
  215202:	f04f 33ff 	mov.w	r3, #4294967295
  215206:	9303      	str	r3, [sp, #12]
  215208:	9002      	str	r0, [sp, #8]
  21520a:	9101      	str	r1, [sp, #4]
  21520c:	9200      	str	r2, [sp, #0]
  21520e:	4633      	mov	r3, r6
  215210:	462a      	mov	r2, r5
  215212:	4621      	mov	r1, r4
  215214:	2000      	movs	r0, #0
  215216:	f7f0 fbd1 	bl	2059bc <LCD_Frame>


	lenStr=LCD_StrRotVar(fontVar_5,Rotate_180,fontID_6,  LCD_Xpos(lenStr,SetPos,5),LCD_Ypos(lenStr,IncPos,10), INT2STR(test[4]), halfHight, 0,DARKRED,1,ConstWidth,bkColor);
  21521a:	4b96      	ldr	r3, [pc, #600]	; (215474 <NOWY_2+0x670>)
  21521c:	681a      	ldr	r2, [r3, #0]
  21521e:	4610      	mov	r0, r2
  215220:	889b      	ldrh	r3, [r3, #4]
  215222:	2100      	movs	r1, #0
  215224:	f363 010f 	bfi	r1, r3, #0, #16
  215228:	2305      	movs	r3, #5
  21522a:	2200      	movs	r2, #0
  21522c:	f7fd fba6 	bl	21297c <LCD_Xpos>
  215230:	4603      	mov	r3, r0
  215232:	461c      	mov	r4, r3
  215234:	4b8f      	ldr	r3, [pc, #572]	; (215474 <NOWY_2+0x670>)
  215236:	681a      	ldr	r2, [r3, #0]
  215238:	4610      	mov	r0, r2
  21523a:	889b      	ldrh	r3, [r3, #4]
  21523c:	2100      	movs	r1, #0
  21523e:	f363 010f 	bfi	r1, r3, #0, #16
  215242:	230a      	movs	r3, #10
  215244:	2202      	movs	r2, #2
  215246:	f7fd fb67 	bl	212918 <LCD_Ypos>
  21524a:	4603      	mov	r3, r0
  21524c:	461d      	mov	r5, r3
  21524e:	4b88      	ldr	r3, [pc, #544]	; (215470 <NOWY_2+0x66c>)
  215250:	6918      	ldr	r0, [r3, #16]
  215252:	2303      	movs	r3, #3
  215254:	2203      	movs	r2, #3
  215256:	2130      	movs	r1, #48	; 0x30
  215258:	f7ec fa34 	bl	2016c4 <Int2Str>
  21525c:	4602      	mov	r2, r0
  21525e:	68fb      	ldr	r3, [r7, #12]
  215260:	4e84      	ldr	r6, [pc, #528]	; (215474 <NOWY_2+0x670>)
  215262:	4638      	mov	r0, r7
  215264:	9308      	str	r3, [sp, #32]
  215266:	2301      	movs	r3, #1
  215268:	9307      	str	r3, [sp, #28]
  21526a:	2301      	movs	r3, #1
  21526c:	9306      	str	r3, [sp, #24]
  21526e:	4b84      	ldr	r3, [pc, #528]	; (215480 <NOWY_2+0x67c>)
  215270:	9305      	str	r3, [sp, #20]
  215272:	2300      	movs	r3, #0
  215274:	9304      	str	r3, [sp, #16]
  215276:	f06f 0301 	mvn.w	r3, #1
  21527a:	9303      	str	r3, [sp, #12]
  21527c:	9202      	str	r2, [sp, #8]
  21527e:	9501      	str	r5, [sp, #4]
  215280:	9400      	str	r4, [sp, #0]
  215282:	2305      	movs	r3, #5
  215284:	2202      	movs	r2, #2
  215286:	2104      	movs	r1, #4
  215288:	f7f8 f8ac 	bl	20d3e4 <LCD_StrRotVar>
  21528c:	4632      	mov	r2, r6
  21528e:	463b      	mov	r3, r7
  215290:	6819      	ldr	r1, [r3, #0]
  215292:	6011      	str	r1, [r2, #0]
  215294:	889b      	ldrh	r3, [r3, #4]
  215296:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),			LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  215298:	f7f2 fb86 	bl	2079a8 <LCD_GetXSize>
  21529c:	4604      	mov	r4, r0
  21529e:	f7f2 fb97 	bl	2079d0 <LCD_GetYSize>
  2152a2:	4605      	mov	r5, r0
  2152a4:	4b73      	ldr	r3, [pc, #460]	; (215474 <NOWY_2+0x670>)
  2152a6:	681a      	ldr	r2, [r3, #0]
  2152a8:	4610      	mov	r0, r2
  2152aa:	889b      	ldrh	r3, [r3, #4]
  2152ac:	2100      	movs	r1, #0
  2152ae:	f363 010f 	bfi	r1, r3, #0, #16
  2152b2:	f04f 33ff 	mov.w	r3, #4294967295
  2152b6:	2201      	movs	r2, #1
  2152b8:	f7fd fb60 	bl	21297c <LCD_Xpos>
  2152bc:	4603      	mov	r3, r0
  2152be:	461e      	mov	r6, r3
  2152c0:	4b6c      	ldr	r3, [pc, #432]	; (215474 <NOWY_2+0x670>)
  2152c2:	681a      	ldr	r2, [r3, #0]
  2152c4:	4610      	mov	r0, r2
  2152c6:	889b      	ldrh	r3, [r3, #4]
  2152c8:	2100      	movs	r1, #0
  2152ca:	f363 010f 	bfi	r1, r3, #0, #16
  2152ce:	f04f 33ff 	mov.w	r3, #4294967295
  2152d2:	2201      	movs	r2, #1
  2152d4:	f7fd fb20 	bl	212918 <LCD_Ypos>
  2152d8:	4603      	mov	r3, r0
  2152da:	461a      	mov	r2, r3
  2152dc:	4b65      	ldr	r3, [pc, #404]	; (215474 <NOWY_2+0x670>)
  2152de:	885b      	ldrh	r3, [r3, #2]
  2152e0:	3302      	adds	r3, #2
  2152e2:	4619      	mov	r1, r3
  2152e4:	4b63      	ldr	r3, [pc, #396]	; (215474 <NOWY_2+0x670>)
  2152e6:	889b      	ldrh	r3, [r3, #4]
  2152e8:	3302      	adds	r3, #2
  2152ea:	4618      	mov	r0, r3
  2152ec:	2300      	movs	r3, #0
  2152ee:	9305      	str	r3, [sp, #20]
  2152f0:	2300      	movs	r3, #0
  2152f2:	9304      	str	r3, [sp, #16]
  2152f4:	f04f 33ff 	mov.w	r3, #4294967295
  2152f8:	9303      	str	r3, [sp, #12]
  2152fa:	9002      	str	r0, [sp, #8]
  2152fc:	9101      	str	r1, [sp, #4]
  2152fe:	9200      	str	r2, [sp, #0]
  215300:	4633      	mov	r3, r6
  215302:	462a      	mov	r2, r5
  215304:	4621      	mov	r1, r4
  215306:	2000      	movs	r0, #0
  215308:	f7f0 fb58 	bl	2059bc <LCD_Frame>

	lenStr=LCD_StrChangeColorRotVar(fontVar_6,Rotate_180,fontID_7, LCD_Xpos(lenStr,IncPos,5),LCD_Ypos(lenStr,GetPos,0), INT2STR(test[5]), halfHight, 0,GRAY,MYBLUE,249,ConstWidth,bkColor);
  21530c:	4b59      	ldr	r3, [pc, #356]	; (215474 <NOWY_2+0x670>)
  21530e:	681a      	ldr	r2, [r3, #0]
  215310:	4610      	mov	r0, r2
  215312:	889b      	ldrh	r3, [r3, #4]
  215314:	2100      	movs	r1, #0
  215316:	f363 010f 	bfi	r1, r3, #0, #16
  21531a:	2305      	movs	r3, #5
  21531c:	2202      	movs	r2, #2
  21531e:	f7fd fb2d 	bl	21297c <LCD_Xpos>
  215322:	4603      	mov	r3, r0
  215324:	461c      	mov	r4, r3
  215326:	4b53      	ldr	r3, [pc, #332]	; (215474 <NOWY_2+0x670>)
  215328:	681a      	ldr	r2, [r3, #0]
  21532a:	4610      	mov	r0, r2
  21532c:	889b      	ldrh	r3, [r3, #4]
  21532e:	2100      	movs	r1, #0
  215330:	f363 010f 	bfi	r1, r3, #0, #16
  215334:	2300      	movs	r3, #0
  215336:	2201      	movs	r2, #1
  215338:	f7fd faee 	bl	212918 <LCD_Ypos>
  21533c:	4603      	mov	r3, r0
  21533e:	461d      	mov	r5, r3
  215340:	4b4b      	ldr	r3, [pc, #300]	; (215470 <NOWY_2+0x66c>)
  215342:	6958      	ldr	r0, [r3, #20]
  215344:	2303      	movs	r3, #3
  215346:	2203      	movs	r2, #3
  215348:	2130      	movs	r1, #48	; 0x30
  21534a:	f7ec f9bb 	bl	2016c4 <Int2Str>
  21534e:	4602      	mov	r2, r0
  215350:	68fb      	ldr	r3, [r7, #12]
  215352:	4e48      	ldr	r6, [pc, #288]	; (215474 <NOWY_2+0x670>)
  215354:	4638      	mov	r0, r7
  215356:	9309      	str	r3, [sp, #36]	; 0x24
  215358:	2301      	movs	r3, #1
  21535a:	9308      	str	r3, [sp, #32]
  21535c:	23f9      	movs	r3, #249	; 0xf9
  21535e:	9307      	str	r3, [sp, #28]
  215360:	4b45      	ldr	r3, [pc, #276]	; (215478 <NOWY_2+0x674>)
  215362:	9306      	str	r3, [sp, #24]
  215364:	4b45      	ldr	r3, [pc, #276]	; (21547c <NOWY_2+0x678>)
  215366:	9305      	str	r3, [sp, #20]
  215368:	2300      	movs	r3, #0
  21536a:	9304      	str	r3, [sp, #16]
  21536c:	f06f 0301 	mvn.w	r3, #1
  215370:	9303      	str	r3, [sp, #12]
  215372:	9202      	str	r2, [sp, #8]
  215374:	9501      	str	r5, [sp, #4]
  215376:	9400      	str	r4, [sp, #0]
  215378:	2306      	movs	r3, #6
  21537a:	2202      	movs	r2, #2
  21537c:	2105      	movs	r1, #5
  21537e:	f7f8 f975 	bl	20d66c <LCD_StrChangeColorRotVar>
  215382:	4632      	mov	r2, r6
  215384:	463b      	mov	r3, r7
  215386:	6819      	ldr	r1, [r3, #0]
  215388:	6011      	str	r1, [r2, #0]
  21538a:	889b      	ldrh	r3, [r3, #4]
  21538c:	8093      	strh	r3, [r2, #4]
	LCD_Frame(0,LCD_GetXSize(),LCD_GetYSize(),						 LCD_Xpos(lenStr,GetPos,-1),LCD_Ypos(lenStr,GetPos,-1), lenStr.inPixel+2,lenStr.height+2,WHITE,0,0);
  21538e:	f7f2 fb0b 	bl	2079a8 <LCD_GetXSize>
  215392:	4604      	mov	r4, r0
  215394:	f7f2 fb1c 	bl	2079d0 <LCD_GetYSize>
  215398:	4605      	mov	r5, r0
  21539a:	4b36      	ldr	r3, [pc, #216]	; (215474 <NOWY_2+0x670>)
  21539c:	681a      	ldr	r2, [r3, #0]
  21539e:	4610      	mov	r0, r2
  2153a0:	889b      	ldrh	r3, [r3, #4]
  2153a2:	2100      	movs	r1, #0
  2153a4:	f363 010f 	bfi	r1, r3, #0, #16
  2153a8:	f04f 33ff 	mov.w	r3, #4294967295
  2153ac:	2201      	movs	r2, #1
  2153ae:	f7fd fae5 	bl	21297c <LCD_Xpos>
  2153b2:	4603      	mov	r3, r0
  2153b4:	461e      	mov	r6, r3
  2153b6:	4b2f      	ldr	r3, [pc, #188]	; (215474 <NOWY_2+0x670>)
  2153b8:	681a      	ldr	r2, [r3, #0]
  2153ba:	4610      	mov	r0, r2
  2153bc:	889b      	ldrh	r3, [r3, #4]
  2153be:	2100      	movs	r1, #0
  2153c0:	f363 010f 	bfi	r1, r3, #0, #16
  2153c4:	f04f 33ff 	mov.w	r3, #4294967295
  2153c8:	2201      	movs	r2, #1
  2153ca:	f7fd faa5 	bl	212918 <LCD_Ypos>
  2153ce:	4603      	mov	r3, r0
  2153d0:	461a      	mov	r2, r3
  2153d2:	4b28      	ldr	r3, [pc, #160]	; (215474 <NOWY_2+0x670>)
  2153d4:	885b      	ldrh	r3, [r3, #2]
  2153d6:	3302      	adds	r3, #2
  2153d8:	4619      	mov	r1, r3
  2153da:	4b26      	ldr	r3, [pc, #152]	; (215474 <NOWY_2+0x670>)
  2153dc:	889b      	ldrh	r3, [r3, #4]
  2153de:	3302      	adds	r3, #2
  2153e0:	4618      	mov	r0, r3
  2153e2:	2300      	movs	r3, #0
  2153e4:	9305      	str	r3, [sp, #20]
  2153e6:	2300      	movs	r3, #0
  2153e8:	9304      	str	r3, [sp, #16]
  2153ea:	f04f 33ff 	mov.w	r3, #4294967295
  2153ee:	9303      	str	r3, [sp, #12]
  2153f0:	9002      	str	r0, [sp, #8]
  2153f2:	9101      	str	r1, [sp, #4]
  2153f4:	9200      	str	r2, [sp, #0]
  2153f6:	4633      	mov	r3, r6
  2153f8:	462a      	mov	r2, r5
  2153fa:	4621      	mov	r1, r4
  2153fc:	2000      	movs	r0, #0
  2153fe:	f7f0 fadd 	bl	2059bc <LCD_Frame>


	lenStr=LCD_StrRotVar				 (fontVar_7,Rotate_180, fontID_6, LCD_Xpos(lenStr,SetPos,100),LCD_Ypos(lenStr,SetPos,50), "1234567890", halfHight, 0,DARKRED,5,NoConstWidth,bkColor);
  215402:	4b1c      	ldr	r3, [pc, #112]	; (215474 <NOWY_2+0x670>)
  215404:	681a      	ldr	r2, [r3, #0]
  215406:	4610      	mov	r0, r2
  215408:	889b      	ldrh	r3, [r3, #4]
  21540a:	2100      	movs	r1, #0
  21540c:	f363 010f 	bfi	r1, r3, #0, #16
  215410:	2364      	movs	r3, #100	; 0x64
  215412:	2200      	movs	r2, #0
  215414:	f7fd fab2 	bl	21297c <LCD_Xpos>
  215418:	4603      	mov	r3, r0
  21541a:	461c      	mov	r4, r3
  21541c:	4b15      	ldr	r3, [pc, #84]	; (215474 <NOWY_2+0x670>)
  21541e:	681a      	ldr	r2, [r3, #0]
  215420:	4610      	mov	r0, r2
  215422:	889b      	ldrh	r3, [r3, #4]
  215424:	2100      	movs	r1, #0
  215426:	f363 010f 	bfi	r1, r3, #0, #16
  21542a:	2332      	movs	r3, #50	; 0x32
  21542c:	2200      	movs	r2, #0
  21542e:	f7fd fa73 	bl	212918 <LCD_Ypos>
  215432:	4603      	mov	r3, r0
  215434:	461a      	mov	r2, r3
  215436:	68fb      	ldr	r3, [r7, #12]
  215438:	4d0e      	ldr	r5, [pc, #56]	; (215474 <NOWY_2+0x670>)
  21543a:	4638      	mov	r0, r7
  21543c:	9308      	str	r3, [sp, #32]
  21543e:	2300      	movs	r3, #0
  215440:	9307      	str	r3, [sp, #28]
  215442:	2305      	movs	r3, #5
  215444:	9306      	str	r3, [sp, #24]
  215446:	4b0e      	ldr	r3, [pc, #56]	; (215480 <NOWY_2+0x67c>)
  215448:	9305      	str	r3, [sp, #20]
  21544a:	2300      	movs	r3, #0
  21544c:	9304      	str	r3, [sp, #16]
  21544e:	f06f 0301 	mvn.w	r3, #1
  215452:	9303      	str	r3, [sp, #12]
  215454:	4b0b      	ldr	r3, [pc, #44]	; (215484 <NOWY_2+0x680>)
  215456:	9302      	str	r3, [sp, #8]
  215458:	9201      	str	r2, [sp, #4]
  21545a:	9400      	str	r4, [sp, #0]
  21545c:	2305      	movs	r3, #5
  21545e:	2202      	movs	r2, #2
  215460:	2106      	movs	r1, #6
  215462:	f7f7 ffbf 	bl	20d3e4 <LCD_StrRotVar>
  215466:	462a      	mov	r2, r5
  215468:	463b      	mov	r3, r7
  21546a:	6819      	ldr	r1, [r3, #0]
  21546c:	6011      	str	r1, [r2, #0]
  21546e:	e00b      	b.n	215488 <NOWY_2+0x684>
  215470:	200104d0 	.word	0x200104d0
  215474:	20014a44 	.word	0x20014a44
  215478:	ff50c8ff 	.word	0xff50c8ff
  21547c:	ff808080 	.word	0xff808080
  215480:	ff800000 	.word	0xff800000
  215484:	00228e9c 	.word	0x00228e9c
  215488:	889b      	ldrh	r3, [r3, #4]
  21548a:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrChangeColorRotVar(fontVar_8,Rotate_90, fontID_7, LCD_Xpos(lenStr,IncPos,50),  LCD_Ypos(lenStr,GetPos,0),   "1234567890", halfHight, 0,GRAY,MYBLUE,249,ConstWidth,bkColor);
  21548c:	4b99      	ldr	r3, [pc, #612]	; (2156f4 <NOWY_2+0x8f0>)
  21548e:	681a      	ldr	r2, [r3, #0]
  215490:	4610      	mov	r0, r2
  215492:	889b      	ldrh	r3, [r3, #4]
  215494:	2100      	movs	r1, #0
  215496:	f363 010f 	bfi	r1, r3, #0, #16
  21549a:	2332      	movs	r3, #50	; 0x32
  21549c:	2202      	movs	r2, #2
  21549e:	f7fd fa6d 	bl	21297c <LCD_Xpos>
  2154a2:	4603      	mov	r3, r0
  2154a4:	461c      	mov	r4, r3
  2154a6:	4b93      	ldr	r3, [pc, #588]	; (2156f4 <NOWY_2+0x8f0>)
  2154a8:	681a      	ldr	r2, [r3, #0]
  2154aa:	4610      	mov	r0, r2
  2154ac:	889b      	ldrh	r3, [r3, #4]
  2154ae:	2100      	movs	r1, #0
  2154b0:	f363 010f 	bfi	r1, r3, #0, #16
  2154b4:	2300      	movs	r3, #0
  2154b6:	2201      	movs	r2, #1
  2154b8:	f7fd fa2e 	bl	212918 <LCD_Ypos>
  2154bc:	4603      	mov	r3, r0
  2154be:	461a      	mov	r2, r3
  2154c0:	68fb      	ldr	r3, [r7, #12]
  2154c2:	4d8c      	ldr	r5, [pc, #560]	; (2156f4 <NOWY_2+0x8f0>)
  2154c4:	4638      	mov	r0, r7
  2154c6:	9309      	str	r3, [sp, #36]	; 0x24
  2154c8:	2301      	movs	r3, #1
  2154ca:	9308      	str	r3, [sp, #32]
  2154cc:	23f9      	movs	r3, #249	; 0xf9
  2154ce:	9307      	str	r3, [sp, #28]
  2154d0:	4b89      	ldr	r3, [pc, #548]	; (2156f8 <NOWY_2+0x8f4>)
  2154d2:	9306      	str	r3, [sp, #24]
  2154d4:	4b89      	ldr	r3, [pc, #548]	; (2156fc <NOWY_2+0x8f8>)
  2154d6:	9305      	str	r3, [sp, #20]
  2154d8:	2300      	movs	r3, #0
  2154da:	9304      	str	r3, [sp, #16]
  2154dc:	f06f 0301 	mvn.w	r3, #1
  2154e0:	9303      	str	r3, [sp, #12]
  2154e2:	4b87      	ldr	r3, [pc, #540]	; (215700 <NOWY_2+0x8fc>)
  2154e4:	9302      	str	r3, [sp, #8]
  2154e6:	9201      	str	r2, [sp, #4]
  2154e8:	9400      	str	r4, [sp, #0]
  2154ea:	2306      	movs	r3, #6
  2154ec:	2201      	movs	r2, #1
  2154ee:	2107      	movs	r1, #7
  2154f0:	f7f8 f8bc 	bl	20d66c <LCD_StrChangeColorRotVar>
  2154f4:	462a      	mov	r2, r5
  2154f6:	463b      	mov	r3, r7
  2154f8:	6819      	ldr	r1, [r3, #0]
  2154fa:	6011      	str	r1, [r2, #0]
  2154fc:	889b      	ldrh	r3, [r3, #4]
  2154fe:	8093      	strh	r3, [r2, #4]
//	StartMeasureTime_us();
//	LCD_RoundRectangle_AA(0,LCD_GetXSize(),LCD_GetYSize(),350,100, 100,45,LIGHTGRAY,MYGRAY,MYGRAY);
//	StopMeasureTime_us("\r\nLCD_DrawRoundRectangle_AA:");


	int frameColor=LIGHTGRAY;
  215500:	4b80      	ldr	r3, [pc, #512]	; (215704 <NOWY_2+0x900>)
  215502:	60bb      	str	r3, [r7, #8]
	//int fillColor=GRAY;

	Set_AACoeff_RoundFrameRectangle(0.55, 0.73);
  215504:	eddf 0a80 	vldr	s1, [pc, #512]	; 215708 <NOWY_2+0x904>
  215508:	ed9f 0a80 	vldr	s0, [pc, #512]	; 21570c <NOWY_2+0x908>
  21550c:	f7ef fb86 	bl	204c1c <Set_AACoeff_RoundFrameRectangle>
	//Set_AACoeff_RoundFrameRectangle(0, 0);
	//Set_AACoeff_RoundFrameRectangle(1, 1);


	StartMeasureTime_us();
  215510:	f003 fa92 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(240,0,LCD_Frame,100,45,frameColor,bkColor,bkColor);
  215514:	68bb      	ldr	r3, [r7, #8]
  215516:	68fa      	ldr	r2, [r7, #12]
  215518:	68f9      	ldr	r1, [r7, #12]
  21551a:	9103      	str	r1, [sp, #12]
  21551c:	9202      	str	r2, [sp, #8]
  21551e:	9301      	str	r3, [sp, #4]
  215520:	232d      	movs	r3, #45	; 0x2d
  215522:	9300      	str	r3, [sp, #0]
  215524:	2364      	movs	r3, #100	; 0x64
  215526:	4a7a      	ldr	r2, [pc, #488]	; (215710 <NOWY_2+0x90c>)
  215528:	2100      	movs	r1, #0
  21552a:	20f0      	movs	r0, #240	; 0xf0
  21552c:	f7f0 f964 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  215530:	4878      	ldr	r0, [pc, #480]	; (215714 <NOWY_2+0x910>)
  215532:	f003 fa91 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  215536:	f003 fa7f 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(240,50,LCD_BoldFrame,100,45,frameColor,bkColor,bkColor);
  21553a:	68bb      	ldr	r3, [r7, #8]
  21553c:	68fa      	ldr	r2, [r7, #12]
  21553e:	68f9      	ldr	r1, [r7, #12]
  215540:	9103      	str	r1, [sp, #12]
  215542:	9202      	str	r2, [sp, #8]
  215544:	9301      	str	r3, [sp, #4]
  215546:	232d      	movs	r3, #45	; 0x2d
  215548:	9300      	str	r3, [sp, #0]
  21554a:	2364      	movs	r3, #100	; 0x64
  21554c:	4a72      	ldr	r2, [pc, #456]	; (215718 <NOWY_2+0x914>)
  21554e:	2132      	movs	r1, #50	; 0x32
  215550:	20f0      	movs	r0, #240	; 0xf0
  215552:	f7f0 f951 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  215556:	486f      	ldr	r0, [pc, #444]	; (215714 <NOWY_2+0x910>)
  215558:	f003 fa7e 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  21555c:	f003 fa6c 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(240,100,LCD_BoldFrame,100,45,SetColorBoldFrame(frameColor,4),bkColor,bkColor);
  215560:	68bb      	ldr	r3, [r7, #8]
  215562:	2104      	movs	r1, #4
  215564:	4618      	mov	r0, r3
  215566:	f7f0 f9d7 	bl	205918 <SetColorBoldFrame>
  21556a:	4601      	mov	r1, r0
  21556c:	68fb      	ldr	r3, [r7, #12]
  21556e:	68fa      	ldr	r2, [r7, #12]
  215570:	9203      	str	r2, [sp, #12]
  215572:	9302      	str	r3, [sp, #8]
  215574:	9101      	str	r1, [sp, #4]
  215576:	232d      	movs	r3, #45	; 0x2d
  215578:	9300      	str	r3, [sp, #0]
  21557a:	2364      	movs	r3, #100	; 0x64
  21557c:	4a66      	ldr	r2, [pc, #408]	; (215718 <NOWY_2+0x914>)
  21557e:	2164      	movs	r1, #100	; 0x64
  215580:	20f0      	movs	r0, #240	; 0xf0
  215582:	f7f0 f939 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  215586:	4863      	ldr	r0, [pc, #396]	; (215714 <NOWY_2+0x910>)
  215588:	f003 fa66 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  21558c:	f003 fa54 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(240,150,LCD_RoundFrame,100,45,frameColor,bkColor,bkColor);
  215590:	68bb      	ldr	r3, [r7, #8]
  215592:	68fa      	ldr	r2, [r7, #12]
  215594:	68f9      	ldr	r1, [r7, #12]
  215596:	9103      	str	r1, [sp, #12]
  215598:	9202      	str	r2, [sp, #8]
  21559a:	9301      	str	r3, [sp, #4]
  21559c:	232d      	movs	r3, #45	; 0x2d
  21559e:	9300      	str	r3, [sp, #0]
  2155a0:	2364      	movs	r3, #100	; 0x64
  2155a2:	4a5e      	ldr	r2, [pc, #376]	; (21571c <NOWY_2+0x918>)
  2155a4:	2196      	movs	r1, #150	; 0x96
  2155a6:	20f0      	movs	r0, #240	; 0xf0
  2155a8:	f7f0 f926 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  2155ac:	4859      	ldr	r0, [pc, #356]	; (215714 <NOWY_2+0x910>)
  2155ae:	f003 fa53 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  2155b2:	f003 fa41 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(240,200,LCD_BoldRoundFrame,100,45,SetColorBoldFrame(frameColor,3),bkColor,bkColor);
  2155b6:	68bb      	ldr	r3, [r7, #8]
  2155b8:	2103      	movs	r1, #3
  2155ba:	4618      	mov	r0, r3
  2155bc:	f7f0 f9ac 	bl	205918 <SetColorBoldFrame>
  2155c0:	4601      	mov	r1, r0
  2155c2:	68fb      	ldr	r3, [r7, #12]
  2155c4:	68fa      	ldr	r2, [r7, #12]
  2155c6:	9203      	str	r2, [sp, #12]
  2155c8:	9302      	str	r3, [sp, #8]
  2155ca:	9101      	str	r1, [sp, #4]
  2155cc:	232d      	movs	r3, #45	; 0x2d
  2155ce:	9300      	str	r3, [sp, #0]
  2155d0:	2364      	movs	r3, #100	; 0x64
  2155d2:	4a53      	ldr	r2, [pc, #332]	; (215720 <NOWY_2+0x91c>)
  2155d4:	21c8      	movs	r1, #200	; 0xc8
  2155d6:	20f0      	movs	r0, #240	; 0xf0
  2155d8:	f7f0 f90e 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA3:");
  2155dc:	4851      	ldr	r0, [pc, #324]	; (215724 <NOWY_2+0x920>)
  2155de:	f003 fa3b 	bl	218a58 <StopMeasureTime_us>


	StartMeasureTime_us();
  2155e2:	f003 fa29 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(350,0,LCD_Rectangle,100,45,frameColor,bkColor,bkColor);
  2155e6:	68bb      	ldr	r3, [r7, #8]
  2155e8:	68fa      	ldr	r2, [r7, #12]
  2155ea:	68f9      	ldr	r1, [r7, #12]
  2155ec:	9103      	str	r1, [sp, #12]
  2155ee:	9202      	str	r2, [sp, #8]
  2155f0:	9301      	str	r3, [sp, #4]
  2155f2:	232d      	movs	r3, #45	; 0x2d
  2155f4:	9300      	str	r3, [sp, #0]
  2155f6:	2364      	movs	r3, #100	; 0x64
  2155f8:	4a4b      	ldr	r2, [pc, #300]	; (215728 <NOWY_2+0x924>)
  2155fa:	2100      	movs	r1, #0
  2155fc:	f44f 70af 	mov.w	r0, #350	; 0x15e
  215600:	f7f0 f8fa 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  215604:	4843      	ldr	r0, [pc, #268]	; (215714 <NOWY_2+0x910>)
  215606:	f003 fa27 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  21560a:	f003 fa15 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(350,50,LCD_BoldRectangle,100,45,frameColor,bkColor,bkColor);
  21560e:	68bb      	ldr	r3, [r7, #8]
  215610:	68fa      	ldr	r2, [r7, #12]
  215612:	68f9      	ldr	r1, [r7, #12]
  215614:	9103      	str	r1, [sp, #12]
  215616:	9202      	str	r2, [sp, #8]
  215618:	9301      	str	r3, [sp, #4]
  21561a:	232d      	movs	r3, #45	; 0x2d
  21561c:	9300      	str	r3, [sp, #0]
  21561e:	2364      	movs	r3, #100	; 0x64
  215620:	4a42      	ldr	r2, [pc, #264]	; (21572c <NOWY_2+0x928>)
  215622:	2132      	movs	r1, #50	; 0x32
  215624:	f44f 70af 	mov.w	r0, #350	; 0x15e
  215628:	f7f0 f8e6 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  21562c:	4839      	ldr	r0, [pc, #228]	; (215714 <NOWY_2+0x910>)
  21562e:	f003 fa13 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  215632:	f003 fa01 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(350,100,LCD_BoldRectangle,100,45,SetColorBoldFrame(GRAY,4),DARKYELLOW,bkColor);
  215636:	2104      	movs	r1, #4
  215638:	4830      	ldr	r0, [pc, #192]	; (2156fc <NOWY_2+0x8f8>)
  21563a:	f7f0 f96d 	bl	205918 <SetColorBoldFrame>
  21563e:	4602      	mov	r2, r0
  215640:	68fb      	ldr	r3, [r7, #12]
  215642:	9303      	str	r3, [sp, #12]
  215644:	4b3a      	ldr	r3, [pc, #232]	; (215730 <NOWY_2+0x92c>)
  215646:	9302      	str	r3, [sp, #8]
  215648:	9201      	str	r2, [sp, #4]
  21564a:	232d      	movs	r3, #45	; 0x2d
  21564c:	9300      	str	r3, [sp, #0]
  21564e:	2364      	movs	r3, #100	; 0x64
  215650:	4a36      	ldr	r2, [pc, #216]	; (21572c <NOWY_2+0x928>)
  215652:	2164      	movs	r1, #100	; 0x64
  215654:	f44f 70af 	mov.w	r0, #350	; 0x15e
  215658:	f7f0 f8ce 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  21565c:	482d      	ldr	r0, [pc, #180]	; (215714 <NOWY_2+0x910>)
  21565e:	f003 f9fb 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  215662:	f003 f9e9 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(350,150,LCD_RoundRectangle,100,45,GRAY,DARKRED,bkColor);  //zrobic jezsli Round to _AA !!!!
  215666:	68fb      	ldr	r3, [r7, #12]
  215668:	9303      	str	r3, [sp, #12]
  21566a:	4b32      	ldr	r3, [pc, #200]	; (215734 <NOWY_2+0x930>)
  21566c:	9302      	str	r3, [sp, #8]
  21566e:	4b23      	ldr	r3, [pc, #140]	; (2156fc <NOWY_2+0x8f8>)
  215670:	9301      	str	r3, [sp, #4]
  215672:	232d      	movs	r3, #45	; 0x2d
  215674:	9300      	str	r3, [sp, #0]
  215676:	2364      	movs	r3, #100	; 0x64
  215678:	4a2f      	ldr	r2, [pc, #188]	; (215738 <NOWY_2+0x934>)
  21567a:	2196      	movs	r1, #150	; 0x96
  21567c:	f44f 70af 	mov.w	r0, #350	; 0x15e
  215680:	f7f0 f8ba 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA1:");
  215684:	4823      	ldr	r0, [pc, #140]	; (215714 <NOWY_2+0x910>)
  215686:	f003 f9e7 	bl	218a58 <StopMeasureTime_us>
	StartMeasureTime_us();
  21568a:	f003 f9d5 	bl	218a38 <StartMeasureTime_us>
	LCD_Shape(350,200,LCD_BoldRoundRectangle,100,45,SetColorBoldFrame(frameColor,3),0x111111,bkColor);
  21568e:	68bb      	ldr	r3, [r7, #8]
  215690:	2103      	movs	r1, #3
  215692:	4618      	mov	r0, r3
  215694:	f7f0 f940 	bl	205918 <SetColorBoldFrame>
  215698:	4602      	mov	r2, r0
  21569a:	68fb      	ldr	r3, [r7, #12]
  21569c:	9303      	str	r3, [sp, #12]
  21569e:	4b27      	ldr	r3, [pc, #156]	; (21573c <NOWY_2+0x938>)
  2156a0:	9302      	str	r3, [sp, #8]
  2156a2:	9201      	str	r2, [sp, #4]
  2156a4:	232d      	movs	r3, #45	; 0x2d
  2156a6:	9300      	str	r3, [sp, #0]
  2156a8:	2364      	movs	r3, #100	; 0x64
  2156aa:	4a25      	ldr	r2, [pc, #148]	; (215740 <NOWY_2+0x93c>)
  2156ac:	21c8      	movs	r1, #200	; 0xc8
  2156ae:	f44f 70af 	mov.w	r0, #350	; 0x15e
  2156b2:	f7f0 f8a1 	bl	2057f8 <LCD_Shape>
	StopMeasureTime_us("\r\nAAAAAAAAAAAA3:");
  2156b6:	481b      	ldr	r0, [pc, #108]	; (215724 <NOWY_2+0x920>)
  2156b8:	f003 f9ce 	bl	218a58 <StopMeasureTime_us>

//RotWin jako select rozwijane zanaczyc text w select !!!!!!!!!!!!!!!!!!!!!!!!



	LCD_Show();
  2156bc:	f7f0 f888 	bl	2057d0 <LCD_Show>
	DisplayFontsStructState();
  2156c0:	f7f5 feba 	bl	20b438 <DisplayFontsStructState>


	LCD_ShapeIndirect(100,200,LCD_BoldRoundRectangle,100,45, SetColorBoldFrame(frameColor,5),DARKGREEN,bkColor);
  2156c4:	68bb      	ldr	r3, [r7, #8]
  2156c6:	2105      	movs	r1, #5
  2156c8:	4618      	mov	r0, r3
  2156ca:	f7f0 f925 	bl	205918 <SetColorBoldFrame>
  2156ce:	4602      	mov	r2, r0
  2156d0:	68fb      	ldr	r3, [r7, #12]
  2156d2:	9303      	str	r3, [sp, #12]
  2156d4:	4b1b      	ldr	r3, [pc, #108]	; (215744 <NOWY_2+0x940>)
  2156d6:	9302      	str	r3, [sp, #8]
  2156d8:	9201      	str	r2, [sp, #4]
  2156da:	232d      	movs	r3, #45	; 0x2d
  2156dc:	9300      	str	r3, [sp, #0]
  2156de:	2364      	movs	r3, #100	; 0x64
  2156e0:	4a17      	ldr	r2, [pc, #92]	; (215740 <NOWY_2+0x93c>)
  2156e2:	21c8      	movs	r1, #200	; 0xc8
  2156e4:	2064      	movs	r0, #100	; 0x64
  2156e6:	f7f0 f8c9 	bl	20587c <LCD_ShapeIndirect>

}
  2156ea:	bf00      	nop
  2156ec:	3714      	adds	r7, #20
  2156ee:	46bd      	mov	sp, r7
  2156f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2156f2:	bf00      	nop
  2156f4:	20014a44 	.word	0x20014a44
  2156f8:	ff50c8ff 	.word	0xff50c8ff
  2156fc:	ff808080 	.word	0xff808080
  215700:	00228e9c 	.word	0x00228e9c
  215704:	ffd0d0d0 	.word	0xffd0d0d0
  215708:	3f3ae148 	.word	0x3f3ae148
  21570c:	3f0ccccd 	.word	0x3f0ccccd
  215710:	002059bd 	.word	0x002059bd
  215714:	00228ea8 	.word	0x00228ea8
  215718:	00205b5d 	.word	0x00205b5d
  21571c:	00205c81 	.word	0x00205c81
  215720:	00205da7 	.word	0x00205da7
  215724:	00228ebc 	.word	0x00228ebc
  215728:	0020593d 	.word	0x0020593d
  21572c:	00205a41 	.word	0x00205a41
  215730:	ff808000 	.word	0xff808000
  215734:	ff800000 	.word	0xff800000
  215738:	00205cbf 	.word	0x00205cbf
  21573c:	00111111 	.word	0x00111111
  215740:	00205cfd 	.word	0x00205cfd
  215744:	ff008000 	.word	0xff008000

00215748 <NOWY_3>:

void NOWY_3(void)  //dac mozliwosc zablokowania Dbg definem!!!
{
  215748:	b590      	push	{r4, r7, lr}
  21574a:	b08f      	sub	sp, #60	; 0x3c
  21574c:	af0c      	add	r7, sp, #48	; 0x30
	SCREEN_ResetAllParameters();
  21574e:	f7fe fa4f 	bl	213bf0 <SCREEN_ResetAllParameters>
	ResetRGB();
  215752:	f7fd fdcd 	bl	2132f0 <ResetRGB>
	LCD_Clear(MYGRAY);
  215756:	48b6      	ldr	r0, [pc, #728]	; (215a30 <NOWY_3+0x2e8>)
  215758:	f7f0 f8b6 	bl	2058c8 <LCD_Clear>
	LCD_LoadFont_DarkgrayWhite(FONT_10, Arial, fontID_6);
  21575c:	2205      	movs	r2, #5
  21575e:	2105      	movs	r1, #5
  215760:	2006      	movs	r0, #6
  215762:	f7f6 fe4b 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	LCD_LoadFont_DarkgrayGreen(FONT_10, Arial, fontID_7);
  215766:	2206      	movs	r2, #6
  215768:	2105      	movs	r1, #5
  21576a:	2006      	movs	r0, #6
  21576c:	f7f6 fe30 	bl	20c3d0 <LCD_LoadFont_DarkgrayGreen>
	//przed LCD_StrMovV dac obrys ramki np


// ZMIENIC lOGIKE width i heght gdy tot80 lub 90 !!!

	lenStr=LCD_StrMovH(fontVar_1,Rotate_0,0,109,   fontID_6,  100,0,"AAA11111111111222222222222222 33333333333333333333A",fullHight,0,DARKBLUE,1,1);
  215770:	4cb0      	ldr	r4, [pc, #704]	; (215a34 <NOWY_3+0x2ec>)
  215772:	4638      	mov	r0, r7
  215774:	2301      	movs	r3, #1
  215776:	9309      	str	r3, [sp, #36]	; 0x24
  215778:	2301      	movs	r3, #1
  21577a:	9308      	str	r3, [sp, #32]
  21577c:	4bae      	ldr	r3, [pc, #696]	; (215a38 <NOWY_3+0x2f0>)
  21577e:	9307      	str	r3, [sp, #28]
  215780:	2300      	movs	r3, #0
  215782:	9306      	str	r3, [sp, #24]
  215784:	f06f 0302 	mvn.w	r3, #2
  215788:	9305      	str	r3, [sp, #20]
  21578a:	4bac      	ldr	r3, [pc, #688]	; (215a3c <NOWY_3+0x2f4>)
  21578c:	9304      	str	r3, [sp, #16]
  21578e:	2300      	movs	r3, #0
  215790:	9303      	str	r3, [sp, #12]
  215792:	2364      	movs	r3, #100	; 0x64
  215794:	9302      	str	r3, [sp, #8]
  215796:	2305      	movs	r3, #5
  215798:	9301      	str	r3, [sp, #4]
  21579a:	236d      	movs	r3, #109	; 0x6d
  21579c:	9300      	str	r3, [sp, #0]
  21579e:	2300      	movs	r3, #0
  2157a0:	2200      	movs	r2, #0
  2157a2:	2100      	movs	r1, #0
  2157a4:	f7f8 fe6e 	bl	20e484 <LCD_StrMovH>
  2157a8:	4622      	mov	r2, r4
  2157aa:	463b      	mov	r3, r7
  2157ac:	6819      	ldr	r1, [r3, #0]
  2157ae:	6011      	str	r1, [r2, #0]
  2157b0:	889b      	ldrh	r3, [r3, #4]
  2157b2:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrMovH(fontVar_2,Rotate_90,0,109,   fontID_6, 0,0,"BBB1111111111222222222222222 33333333333333333333B",fullHight,0,DARKBLUE,1,1);
  2157b4:	4c9f      	ldr	r4, [pc, #636]	; (215a34 <NOWY_3+0x2ec>)
  2157b6:	4638      	mov	r0, r7
  2157b8:	2301      	movs	r3, #1
  2157ba:	9309      	str	r3, [sp, #36]	; 0x24
  2157bc:	2301      	movs	r3, #1
  2157be:	9308      	str	r3, [sp, #32]
  2157c0:	4b9d      	ldr	r3, [pc, #628]	; (215a38 <NOWY_3+0x2f0>)
  2157c2:	9307      	str	r3, [sp, #28]
  2157c4:	2300      	movs	r3, #0
  2157c6:	9306      	str	r3, [sp, #24]
  2157c8:	f06f 0302 	mvn.w	r3, #2
  2157cc:	9305      	str	r3, [sp, #20]
  2157ce:	4b9c      	ldr	r3, [pc, #624]	; (215a40 <NOWY_3+0x2f8>)
  2157d0:	9304      	str	r3, [sp, #16]
  2157d2:	2300      	movs	r3, #0
  2157d4:	9303      	str	r3, [sp, #12]
  2157d6:	2300      	movs	r3, #0
  2157d8:	9302      	str	r3, [sp, #8]
  2157da:	2305      	movs	r3, #5
  2157dc:	9301      	str	r3, [sp, #4]
  2157de:	236d      	movs	r3, #109	; 0x6d
  2157e0:	9300      	str	r3, [sp, #0]
  2157e2:	2300      	movs	r3, #0
  2157e4:	2201      	movs	r2, #1
  2157e6:	2101      	movs	r1, #1
  2157e8:	f7f8 fe4c 	bl	20e484 <LCD_StrMovH>
  2157ec:	4622      	mov	r2, r4
  2157ee:	463b      	mov	r3, r7
  2157f0:	6819      	ldr	r1, [r3, #0]
  2157f2:	6011      	str	r1, [r2, #0]
  2157f4:	889b      	ldrh	r3, [r3, #4]
  2157f6:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrMovH(fontVar_3,Rotate_180,0,109,   fontID_6, 50,0,"CCCC11111111111222222222222222 33333333333333333333C",fullHight,0,DARKBLUE,1,1);
  2157f8:	4c8e      	ldr	r4, [pc, #568]	; (215a34 <NOWY_3+0x2ec>)
  2157fa:	4638      	mov	r0, r7
  2157fc:	2301      	movs	r3, #1
  2157fe:	9309      	str	r3, [sp, #36]	; 0x24
  215800:	2301      	movs	r3, #1
  215802:	9308      	str	r3, [sp, #32]
  215804:	4b8c      	ldr	r3, [pc, #560]	; (215a38 <NOWY_3+0x2f0>)
  215806:	9307      	str	r3, [sp, #28]
  215808:	2300      	movs	r3, #0
  21580a:	9306      	str	r3, [sp, #24]
  21580c:	f06f 0302 	mvn.w	r3, #2
  215810:	9305      	str	r3, [sp, #20]
  215812:	4b8c      	ldr	r3, [pc, #560]	; (215a44 <NOWY_3+0x2fc>)
  215814:	9304      	str	r3, [sp, #16]
  215816:	2300      	movs	r3, #0
  215818:	9303      	str	r3, [sp, #12]
  21581a:	2332      	movs	r3, #50	; 0x32
  21581c:	9302      	str	r3, [sp, #8]
  21581e:	2305      	movs	r3, #5
  215820:	9301      	str	r3, [sp, #4]
  215822:	236d      	movs	r3, #109	; 0x6d
  215824:	9300      	str	r3, [sp, #0]
  215826:	2300      	movs	r3, #0
  215828:	2202      	movs	r2, #2
  21582a:	2102      	movs	r1, #2
  21582c:	f7f8 fe2a 	bl	20e484 <LCD_StrMovH>
  215830:	4622      	mov	r2, r4
  215832:	463b      	mov	r3, r7
  215834:	6819      	ldr	r1, [r3, #0]
  215836:	6011      	str	r1, [r2, #0]
  215838:	889b      	ldrh	r3, [r3, #4]
  21583a:	8093      	strh	r3, [r2, #4]

	lenStr=LCD_StrChangeColorMovH(fontVar_4,Rotate_0,0,80,fontID_7, 100,50,"Zeszyty i ksiki to podrczniki do szkoy dla oA_XY",fullHight,0,DARKYELLOW,DARKRED,254,0);
  21583c:	4c7d      	ldr	r4, [pc, #500]	; (215a34 <NOWY_3+0x2ec>)
  21583e:	4638      	mov	r0, r7
  215840:	2300      	movs	r3, #0
  215842:	930a      	str	r3, [sp, #40]	; 0x28
  215844:	23fe      	movs	r3, #254	; 0xfe
  215846:	9309      	str	r3, [sp, #36]	; 0x24
  215848:	4b7f      	ldr	r3, [pc, #508]	; (215a48 <NOWY_3+0x300>)
  21584a:	9308      	str	r3, [sp, #32]
  21584c:	4b7f      	ldr	r3, [pc, #508]	; (215a4c <NOWY_3+0x304>)
  21584e:	9307      	str	r3, [sp, #28]
  215850:	2300      	movs	r3, #0
  215852:	9306      	str	r3, [sp, #24]
  215854:	f06f 0302 	mvn.w	r3, #2
  215858:	9305      	str	r3, [sp, #20]
  21585a:	4b7d      	ldr	r3, [pc, #500]	; (215a50 <NOWY_3+0x308>)
  21585c:	9304      	str	r3, [sp, #16]
  21585e:	2332      	movs	r3, #50	; 0x32
  215860:	9303      	str	r3, [sp, #12]
  215862:	2364      	movs	r3, #100	; 0x64
  215864:	9302      	str	r3, [sp, #8]
  215866:	2306      	movs	r3, #6
  215868:	9301      	str	r3, [sp, #4]
  21586a:	2350      	movs	r3, #80	; 0x50
  21586c:	9300      	str	r3, [sp, #0]
  21586e:	2300      	movs	r3, #0
  215870:	2200      	movs	r2, #0
  215872:	2103      	movs	r1, #3
  215874:	f7f9 f86e 	bl	20e954 <LCD_StrChangeColorMovH>
  215878:	4622      	mov	r2, r4
  21587a:	463b      	mov	r3, r7
  21587c:	6819      	ldr	r1, [r3, #0]
  21587e:	6011      	str	r1, [r2, #0]
  215880:	889b      	ldrh	r3, [r3, #4]
  215882:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrChangeColorMovH(fontVar_5,Rotate_90,0,80,fontID_7, 400,0,"Zeszyty i ksiki to podrczniki do szkoy dla oA_XY",fullHight,0,DARKYELLOW,DARKRED,254,0);
  215884:	4c6b      	ldr	r4, [pc, #428]	; (215a34 <NOWY_3+0x2ec>)
  215886:	4638      	mov	r0, r7
  215888:	2300      	movs	r3, #0
  21588a:	930a      	str	r3, [sp, #40]	; 0x28
  21588c:	23fe      	movs	r3, #254	; 0xfe
  21588e:	9309      	str	r3, [sp, #36]	; 0x24
  215890:	4b6d      	ldr	r3, [pc, #436]	; (215a48 <NOWY_3+0x300>)
  215892:	9308      	str	r3, [sp, #32]
  215894:	4b6d      	ldr	r3, [pc, #436]	; (215a4c <NOWY_3+0x304>)
  215896:	9307      	str	r3, [sp, #28]
  215898:	2300      	movs	r3, #0
  21589a:	9306      	str	r3, [sp, #24]
  21589c:	f06f 0302 	mvn.w	r3, #2
  2158a0:	9305      	str	r3, [sp, #20]
  2158a2:	4b6b      	ldr	r3, [pc, #428]	; (215a50 <NOWY_3+0x308>)
  2158a4:	9304      	str	r3, [sp, #16]
  2158a6:	2300      	movs	r3, #0
  2158a8:	9303      	str	r3, [sp, #12]
  2158aa:	f44f 73c8 	mov.w	r3, #400	; 0x190
  2158ae:	9302      	str	r3, [sp, #8]
  2158b0:	2306      	movs	r3, #6
  2158b2:	9301      	str	r3, [sp, #4]
  2158b4:	2350      	movs	r3, #80	; 0x50
  2158b6:	9300      	str	r3, [sp, #0]
  2158b8:	2300      	movs	r3, #0
  2158ba:	2201      	movs	r2, #1
  2158bc:	2104      	movs	r1, #4
  2158be:	f7f9 f849 	bl	20e954 <LCD_StrChangeColorMovH>
  2158c2:	4622      	mov	r2, r4
  2158c4:	463b      	mov	r3, r7
  2158c6:	6819      	ldr	r1, [r3, #0]
  2158c8:	6011      	str	r1, [r2, #0]
  2158ca:	889b      	ldrh	r3, [r3, #4]
  2158cc:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrChangeColorMovH(fontVar_6,Rotate_180,0,80,fontID_7, 435,0,"Zeszyty i ksiki to podrczniki do szkoy dla oA_XY",fullHight,0,DARKYELLOW,DARKRED,254,0);
  2158ce:	4c59      	ldr	r4, [pc, #356]	; (215a34 <NOWY_3+0x2ec>)
  2158d0:	4638      	mov	r0, r7
  2158d2:	2300      	movs	r3, #0
  2158d4:	930a      	str	r3, [sp, #40]	; 0x28
  2158d6:	23fe      	movs	r3, #254	; 0xfe
  2158d8:	9309      	str	r3, [sp, #36]	; 0x24
  2158da:	4b5b      	ldr	r3, [pc, #364]	; (215a48 <NOWY_3+0x300>)
  2158dc:	9308      	str	r3, [sp, #32]
  2158de:	4b5b      	ldr	r3, [pc, #364]	; (215a4c <NOWY_3+0x304>)
  2158e0:	9307      	str	r3, [sp, #28]
  2158e2:	2300      	movs	r3, #0
  2158e4:	9306      	str	r3, [sp, #24]
  2158e6:	f06f 0302 	mvn.w	r3, #2
  2158ea:	9305      	str	r3, [sp, #20]
  2158ec:	4b58      	ldr	r3, [pc, #352]	; (215a50 <NOWY_3+0x308>)
  2158ee:	9304      	str	r3, [sp, #16]
  2158f0:	2300      	movs	r3, #0
  2158f2:	9303      	str	r3, [sp, #12]
  2158f4:	f240 13b3 	movw	r3, #435	; 0x1b3
  2158f8:	9302      	str	r3, [sp, #8]
  2158fa:	2306      	movs	r3, #6
  2158fc:	9301      	str	r3, [sp, #4]
  2158fe:	2350      	movs	r3, #80	; 0x50
  215900:	9300      	str	r3, [sp, #0]
  215902:	2300      	movs	r3, #0
  215904:	2202      	movs	r2, #2
  215906:	2105      	movs	r1, #5
  215908:	f7f9 f824 	bl	20e954 <LCD_StrChangeColorMovH>
  21590c:	4622      	mov	r2, r4
  21590e:	463b      	mov	r3, r7
  215910:	6819      	ldr	r1, [r3, #0]
  215912:	6011      	str	r1, [r2, #0]
  215914:	889b      	ldrh	r3, [r3, #4]
  215916:	8093      	strh	r3, [r2, #4]


	lenStr=LCD_StrChangeColorMovV(fontVar_7,Rotate_0,0,100,50,fontID_7,100,100,"Rafa Markielowski jest ww p omieszczeniu gospodarczym lubi krasnale www doku na drzewie takie jego bojowe zadanie  SEX _XY",fullHight,0,LIGHTGRAY,DARKBLUE,249,0);
  215918:	4c46      	ldr	r4, [pc, #280]	; (215a34 <NOWY_3+0x2ec>)
  21591a:	4638      	mov	r0, r7
  21591c:	2300      	movs	r3, #0
  21591e:	930b      	str	r3, [sp, #44]	; 0x2c
  215920:	23f9      	movs	r3, #249	; 0xf9
  215922:	930a      	str	r3, [sp, #40]	; 0x28
  215924:	4b44      	ldr	r3, [pc, #272]	; (215a38 <NOWY_3+0x2f0>)
  215926:	9309      	str	r3, [sp, #36]	; 0x24
  215928:	4b4a      	ldr	r3, [pc, #296]	; (215a54 <NOWY_3+0x30c>)
  21592a:	9308      	str	r3, [sp, #32]
  21592c:	2300      	movs	r3, #0
  21592e:	9307      	str	r3, [sp, #28]
  215930:	f06f 0302 	mvn.w	r3, #2
  215934:	9306      	str	r3, [sp, #24]
  215936:	4b48      	ldr	r3, [pc, #288]	; (215a58 <NOWY_3+0x310>)
  215938:	9305      	str	r3, [sp, #20]
  21593a:	2364      	movs	r3, #100	; 0x64
  21593c:	9304      	str	r3, [sp, #16]
  21593e:	2364      	movs	r3, #100	; 0x64
  215940:	9303      	str	r3, [sp, #12]
  215942:	2306      	movs	r3, #6
  215944:	9302      	str	r3, [sp, #8]
  215946:	2332      	movs	r3, #50	; 0x32
  215948:	9301      	str	r3, [sp, #4]
  21594a:	2364      	movs	r3, #100	; 0x64
  21594c:	9300      	str	r3, [sp, #0]
  21594e:	2300      	movs	r3, #0
  215950:	2200      	movs	r2, #0
  215952:	2106      	movs	r1, #6
  215954:	f7fa fef0 	bl	210738 <LCD_StrChangeColorMovV>
  215958:	4622      	mov	r2, r4
  21595a:	463b      	mov	r3, r7
  21595c:	6819      	ldr	r1, [r3, #0]
  21595e:	6011      	str	r1, [r2, #0]
  215960:	889b      	ldrh	r3, [r3, #4]
  215962:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrMovV           (fontVar_8,Rotate_0,0,100,50,fontID_6,210,100,"1234567890 abcdefghijklnn opqrstuvw ABCDEFGHIJKLMNOPQRTSUVWXYZ iiiiiiiiiiiijjjjjjjjjjjjSSSSSSSSSSEEEEEEEEEERRRRRRRRRA _XY",fullHight,0,MYGRAY,1,0);
  215964:	4c33      	ldr	r4, [pc, #204]	; (215a34 <NOWY_3+0x2ec>)
  215966:	4638      	mov	r0, r7
  215968:	2300      	movs	r3, #0
  21596a:	930a      	str	r3, [sp, #40]	; 0x28
  21596c:	2301      	movs	r3, #1
  21596e:	9309      	str	r3, [sp, #36]	; 0x24
  215970:	4b2f      	ldr	r3, [pc, #188]	; (215a30 <NOWY_3+0x2e8>)
  215972:	9308      	str	r3, [sp, #32]
  215974:	2300      	movs	r3, #0
  215976:	9307      	str	r3, [sp, #28]
  215978:	f06f 0302 	mvn.w	r3, #2
  21597c:	9306      	str	r3, [sp, #24]
  21597e:	4b37      	ldr	r3, [pc, #220]	; (215a5c <NOWY_3+0x314>)
  215980:	9305      	str	r3, [sp, #20]
  215982:	2364      	movs	r3, #100	; 0x64
  215984:	9304      	str	r3, [sp, #16]
  215986:	23d2      	movs	r3, #210	; 0xd2
  215988:	9303      	str	r3, [sp, #12]
  21598a:	2305      	movs	r3, #5
  21598c:	9302      	str	r3, [sp, #8]
  21598e:	2332      	movs	r3, #50	; 0x32
  215990:	9301      	str	r3, [sp, #4]
  215992:	2364      	movs	r3, #100	; 0x64
  215994:	9300      	str	r3, [sp, #0]
  215996:	2300      	movs	r3, #0
  215998:	2200      	movs	r2, #0
  21599a:	2107      	movs	r1, #7
  21599c:	f7fa fb92 	bl	2100c4 <LCD_StrMovV>
  2159a0:	4622      	mov	r2, r4
  2159a2:	463b      	mov	r3, r7
  2159a4:	6819      	ldr	r1, [r3, #0]
  2159a6:	6011      	str	r1, [r2, #0]
  2159a8:	889b      	ldrh	r3, [r3, #4]
  2159aa:	8093      	strh	r3, [r2, #4]

	lenStr=LCD_StrChangeColorMovV(fontVar_9,Rotate_90,0,100,50,fontID_7,0,160,"Rafa Markielowski jest ww p omieszczeniu gospodarczym lubi krasnale www doku na drzewie takie jego bojowe zadanie  SEX _XY",fullHight,0,LIGHTGRAY,DARKBLUE,249,0);
  2159ac:	4c21      	ldr	r4, [pc, #132]	; (215a34 <NOWY_3+0x2ec>)
  2159ae:	4638      	mov	r0, r7
  2159b0:	2300      	movs	r3, #0
  2159b2:	930b      	str	r3, [sp, #44]	; 0x2c
  2159b4:	23f9      	movs	r3, #249	; 0xf9
  2159b6:	930a      	str	r3, [sp, #40]	; 0x28
  2159b8:	4b1f      	ldr	r3, [pc, #124]	; (215a38 <NOWY_3+0x2f0>)
  2159ba:	9309      	str	r3, [sp, #36]	; 0x24
  2159bc:	4b25      	ldr	r3, [pc, #148]	; (215a54 <NOWY_3+0x30c>)
  2159be:	9308      	str	r3, [sp, #32]
  2159c0:	2300      	movs	r3, #0
  2159c2:	9307      	str	r3, [sp, #28]
  2159c4:	f06f 0302 	mvn.w	r3, #2
  2159c8:	9306      	str	r3, [sp, #24]
  2159ca:	4b23      	ldr	r3, [pc, #140]	; (215a58 <NOWY_3+0x310>)
  2159cc:	9305      	str	r3, [sp, #20]
  2159ce:	23a0      	movs	r3, #160	; 0xa0
  2159d0:	9304      	str	r3, [sp, #16]
  2159d2:	2300      	movs	r3, #0
  2159d4:	9303      	str	r3, [sp, #12]
  2159d6:	2306      	movs	r3, #6
  2159d8:	9302      	str	r3, [sp, #8]
  2159da:	2332      	movs	r3, #50	; 0x32
  2159dc:	9301      	str	r3, [sp, #4]
  2159de:	2364      	movs	r3, #100	; 0x64
  2159e0:	9300      	str	r3, [sp, #0]
  2159e2:	2300      	movs	r3, #0
  2159e4:	2201      	movs	r2, #1
  2159e6:	2108      	movs	r1, #8
  2159e8:	f7fa fea6 	bl	210738 <LCD_StrChangeColorMovV>
  2159ec:	4622      	mov	r2, r4
  2159ee:	463b      	mov	r3, r7
  2159f0:	6819      	ldr	r1, [r3, #0]
  2159f2:	6011      	str	r1, [r2, #0]
  2159f4:	889b      	ldrh	r3, [r3, #4]
  2159f6:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrMovV           (fontVar_10,Rotate_90,0,100,50,fontID_6,110,160,"1234567890 abcdefghijklnn opqrstuvw ABCDEFGHIJKLMNOPQRTSUVWXYZ iiiiiiiiiiiijjjjjjjjjjjjSSSSSSSSSSEEEEEEEEEERRRRRRRRRA _XY",fullHight,0,MYGRAY,1,0);
  2159f8:	4c0e      	ldr	r4, [pc, #56]	; (215a34 <NOWY_3+0x2ec>)
  2159fa:	4638      	mov	r0, r7
  2159fc:	2300      	movs	r3, #0
  2159fe:	930a      	str	r3, [sp, #40]	; 0x28
  215a00:	2301      	movs	r3, #1
  215a02:	9309      	str	r3, [sp, #36]	; 0x24
  215a04:	4b0a      	ldr	r3, [pc, #40]	; (215a30 <NOWY_3+0x2e8>)
  215a06:	9308      	str	r3, [sp, #32]
  215a08:	2300      	movs	r3, #0
  215a0a:	9307      	str	r3, [sp, #28]
  215a0c:	f06f 0302 	mvn.w	r3, #2
  215a10:	9306      	str	r3, [sp, #24]
  215a12:	4b12      	ldr	r3, [pc, #72]	; (215a5c <NOWY_3+0x314>)
  215a14:	9305      	str	r3, [sp, #20]
  215a16:	23a0      	movs	r3, #160	; 0xa0
  215a18:	9304      	str	r3, [sp, #16]
  215a1a:	236e      	movs	r3, #110	; 0x6e
  215a1c:	9303      	str	r3, [sp, #12]
  215a1e:	2305      	movs	r3, #5
  215a20:	9302      	str	r3, [sp, #8]
  215a22:	2332      	movs	r3, #50	; 0x32
  215a24:	9301      	str	r3, [sp, #4]
  215a26:	2364      	movs	r3, #100	; 0x64
  215a28:	9300      	str	r3, [sp, #0]
  215a2a:	2300      	movs	r3, #0
  215a2c:	e018      	b.n	215a60 <NOWY_3+0x318>
  215a2e:	bf00      	nop
  215a30:	ff404040 	.word	0xff404040
  215a34:	20014a44 	.word	0x20014a44
  215a38:	ff000080 	.word	0xff000080
  215a3c:	00228ed0 	.word	0x00228ed0
  215a40:	00228f04 	.word	0x00228f04
  215a44:	00228f38 	.word	0x00228f38
  215a48:	ff800000 	.word	0xff800000
  215a4c:	ff808000 	.word	0xff808000
  215a50:	00228f70 	.word	0x00228f70
  215a54:	ffd0d0d0 	.word	0xffd0d0d0
  215a58:	00228fa8 	.word	0x00228fa8
  215a5c:	00229024 	.word	0x00229024
  215a60:	2201      	movs	r2, #1
  215a62:	2109      	movs	r1, #9
  215a64:	f7fa fb2e 	bl	2100c4 <LCD_StrMovV>
  215a68:	4622      	mov	r2, r4
  215a6a:	463b      	mov	r3, r7
  215a6c:	6819      	ldr	r1, [r3, #0]
  215a6e:	6011      	str	r1, [r2, #0]
  215a70:	889b      	ldrh	r3, [r3, #4]
  215a72:	8093      	strh	r3, [r2, #4]

	lenStr=LCD_StrChangeColorMovV(fontVar_11,Rotate_180,0,100,50,fontID_7,220,160,"Rafa Markielowski jest ww p omieszczeniu gospodarczym lubi krasnale www doku na drzewie takie jego bojowe zadanie  SEX _XY",fullHight,0,LIGHTGRAY,DARKBLUE,249,0);
  215a74:	4c2a      	ldr	r4, [pc, #168]	; (215b20 <NOWY_3+0x3d8>)
  215a76:	4638      	mov	r0, r7
  215a78:	2300      	movs	r3, #0
  215a7a:	930b      	str	r3, [sp, #44]	; 0x2c
  215a7c:	23f9      	movs	r3, #249	; 0xf9
  215a7e:	930a      	str	r3, [sp, #40]	; 0x28
  215a80:	4b28      	ldr	r3, [pc, #160]	; (215b24 <NOWY_3+0x3dc>)
  215a82:	9309      	str	r3, [sp, #36]	; 0x24
  215a84:	4b28      	ldr	r3, [pc, #160]	; (215b28 <NOWY_3+0x3e0>)
  215a86:	9308      	str	r3, [sp, #32]
  215a88:	2300      	movs	r3, #0
  215a8a:	9307      	str	r3, [sp, #28]
  215a8c:	f06f 0302 	mvn.w	r3, #2
  215a90:	9306      	str	r3, [sp, #24]
  215a92:	4b26      	ldr	r3, [pc, #152]	; (215b2c <NOWY_3+0x3e4>)
  215a94:	9305      	str	r3, [sp, #20]
  215a96:	23a0      	movs	r3, #160	; 0xa0
  215a98:	9304      	str	r3, [sp, #16]
  215a9a:	23dc      	movs	r3, #220	; 0xdc
  215a9c:	9303      	str	r3, [sp, #12]
  215a9e:	2306      	movs	r3, #6
  215aa0:	9302      	str	r3, [sp, #8]
  215aa2:	2332      	movs	r3, #50	; 0x32
  215aa4:	9301      	str	r3, [sp, #4]
  215aa6:	2364      	movs	r3, #100	; 0x64
  215aa8:	9300      	str	r3, [sp, #0]
  215aaa:	2300      	movs	r3, #0
  215aac:	2202      	movs	r2, #2
  215aae:	210a      	movs	r1, #10
  215ab0:	f7fa fe42 	bl	210738 <LCD_StrChangeColorMovV>
  215ab4:	4622      	mov	r2, r4
  215ab6:	463b      	mov	r3, r7
  215ab8:	6819      	ldr	r1, [r3, #0]
  215aba:	6011      	str	r1, [r2, #0]
  215abc:	889b      	ldrh	r3, [r3, #4]
  215abe:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_StrMovV           (fontVar_12,Rotate_180,0,100,50,fontID_6,330,160,"1234567890 abcdefghijklnn opqrstuvw ABCDEFGHIJKLMNOPQRTSUVWXYZ iiiiiiiiiiiijjjjjjjjjjjjSSSSSSSSSSEEEEEEEEEERRRRRRRRRA _XY",fullHight,0,MYGRAY,1,0);
  215ac0:	4c17      	ldr	r4, [pc, #92]	; (215b20 <NOWY_3+0x3d8>)
  215ac2:	4638      	mov	r0, r7
  215ac4:	2300      	movs	r3, #0
  215ac6:	930a      	str	r3, [sp, #40]	; 0x28
  215ac8:	2301      	movs	r3, #1
  215aca:	9309      	str	r3, [sp, #36]	; 0x24
  215acc:	4b18      	ldr	r3, [pc, #96]	; (215b30 <NOWY_3+0x3e8>)
  215ace:	9308      	str	r3, [sp, #32]
  215ad0:	2300      	movs	r3, #0
  215ad2:	9307      	str	r3, [sp, #28]
  215ad4:	f06f 0302 	mvn.w	r3, #2
  215ad8:	9306      	str	r3, [sp, #24]
  215ada:	4b16      	ldr	r3, [pc, #88]	; (215b34 <NOWY_3+0x3ec>)
  215adc:	9305      	str	r3, [sp, #20]
  215ade:	23a0      	movs	r3, #160	; 0xa0
  215ae0:	9304      	str	r3, [sp, #16]
  215ae2:	f44f 73a5 	mov.w	r3, #330	; 0x14a
  215ae6:	9303      	str	r3, [sp, #12]
  215ae8:	2305      	movs	r3, #5
  215aea:	9302      	str	r3, [sp, #8]
  215aec:	2332      	movs	r3, #50	; 0x32
  215aee:	9301      	str	r3, [sp, #4]
  215af0:	2364      	movs	r3, #100	; 0x64
  215af2:	9300      	str	r3, [sp, #0]
  215af4:	2300      	movs	r3, #0
  215af6:	2202      	movs	r2, #2
  215af8:	210b      	movs	r1, #11
  215afa:	f7fa fae3 	bl	2100c4 <LCD_StrMovV>
  215afe:	4622      	mov	r2, r4
  215b00:	463b      	mov	r3, r7
  215b02:	6819      	ldr	r1, [r3, #0]
  215b04:	6011      	str	r1, [r2, #0]
  215b06:	889b      	ldrh	r3, [r3, #4]
  215b08:	8093      	strh	r3, [r2, #4]
	// wyzej funkcje pobieraja bufor w ktorym sa przewijane texty zastanowic sie ??




	LCD_Show();
  215b0a:	f7ef fe61 	bl	2057d0 <LCD_Show>
	DisplayFontsStructState();
  215b0e:	f7f5 fc93 	bl	20b438 <DisplayFontsStructState>
	LCD_DisplayStrMovBuffState();
  215b12:	f7f7 fb23 	bl	20d15c <LCD_DisplayStrMovBuffState>

}
  215b16:	bf00      	nop
  215b18:	370c      	adds	r7, #12
  215b1a:	46bd      	mov	sp, r7
  215b1c:	bd90      	pop	{r4, r7, pc}
  215b1e:	bf00      	nop
  215b20:	20014a44 	.word	0x20014a44
  215b24:	ff000080 	.word	0xff000080
  215b28:	ffd0d0d0 	.word	0xffd0d0d0
  215b2c:	00228fa8 	.word	0x00228fa8
  215b30:	ff404040 	.word	0xff404040
  215b34:	00229024 	.word	0x00229024

00215b38 <_BkColor.12857>:

int test_len=100;

void SCREEN_Test_Circle(void)  //skopiowac pliki do innego projektu bo mam blad z jakims #udef ?????
{
   uint32_t _BkColor		(void){ return RGB2INT( Circle.bk[0],	  Circle.bk[1],    Circle.bk[2]    ); }
  215b38:	b480      	push	{r7}
  215b3a:	b083      	sub	sp, #12
  215b3c:	af00      	add	r7, sp, #0
  215b3e:	f8c7 c004 	str.w	ip, [r7, #4]
  215b42:	4b09      	ldr	r3, [pc, #36]	; (215b68 <_BkColor.12857+0x30>)
  215b44:	791b      	ldrb	r3, [r3, #4]
  215b46:	041a      	lsls	r2, r3, #16
  215b48:	4b07      	ldr	r3, [pc, #28]	; (215b68 <_BkColor.12857+0x30>)
  215b4a:	795b      	ldrb	r3, [r3, #5]
  215b4c:	021b      	lsls	r3, r3, #8
  215b4e:	4313      	orrs	r3, r2
  215b50:	4a05      	ldr	r2, [pc, #20]	; (215b68 <_BkColor.12857+0x30>)
  215b52:	7992      	ldrb	r2, [r2, #6]
  215b54:	4313      	orrs	r3, r2
  215b56:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  215b5a:	4618      	mov	r0, r3
  215b5c:	370c      	adds	r7, #12
  215b5e:	46bd      	mov	sp, r7
  215b60:	f85d 7b04 	ldr.w	r7, [sp], #4
  215b64:	4770      	bx	lr
  215b66:	bf00      	nop
  215b68:	200104e8 	.word	0x200104e8

00215b6c <SCREEN_Test_Circle>:
{
  215b6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  215b70:	b08a      	sub	sp, #40	; 0x28
  215b72:	af06      	add	r7, sp, #24
void SCREEN_Test_Circle(void)  //skopiowac pliki do innego projektu bo mam blad z jakims #udef ?????
  215b74:	f107 0328 	add.w	r3, r7, #40	; 0x28
  215b78:	60fb      	str	r3, [r7, #12]
		LCD_ClearIndirect(0,width,width,RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]));
		LCD_SetCircleAA(Circle.ratioBk,Circle.ratioFill);
		LCD_ShapeIndirect(x,y,LCD_Circle, width,width, SetColorBoldFrame(_FrameColor(),bold), _FillColor(), _BkColor());
	}

	if(Circle.startFlag!=0x52)
  215b7a:	4bc4      	ldr	r3, [pc, #784]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215b7c:	781b      	ldrb	r3, [r3, #0]
  215b7e:	2b52      	cmp	r3, #82	; 0x52
  215b80:	d064      	beq.n	215c4c <SCREEN_Test_Circle+0xe0>
	{
		Circle.startFlag=0x52;
  215b82:	4bc2      	ldr	r3, [pc, #776]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215b84:	2252      	movs	r2, #82	; 0x52
  215b86:	701a      	strb	r2, [r3, #0]
		Circle.width=270;
  215b88:	4bc0      	ldr	r3, [pc, #768]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215b8a:	f44f 7287 	mov.w	r2, #270	; 0x10e
  215b8e:	805a      	strh	r2, [r3, #2]

		Circle.bk[0]=R_PART(MYGRAY);
  215b90:	4bbe      	ldr	r3, [pc, #760]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215b92:	2240      	movs	r2, #64	; 0x40
  215b94:	711a      	strb	r2, [r3, #4]
		Circle.bk[1]=G_PART(MYGRAY);
  215b96:	4bbd      	ldr	r3, [pc, #756]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215b98:	2240      	movs	r2, #64	; 0x40
  215b9a:	715a      	strb	r2, [r3, #5]
		Circle.bk[2]=B_PART(MYGRAY);
  215b9c:	4bbb      	ldr	r3, [pc, #748]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215b9e:	2240      	movs	r2, #64	; 0x40
  215ba0:	719a      	strb	r2, [r3, #6]

		Circle.frame[0]=R_PART(WHITE);
  215ba2:	4bba      	ldr	r3, [pc, #744]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215ba4:	22ff      	movs	r2, #255	; 0xff
  215ba6:	71da      	strb	r2, [r3, #7]
		Circle.frame[1]=G_PART(WHITE);
  215ba8:	4bb8      	ldr	r3, [pc, #736]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215baa:	22ff      	movs	r2, #255	; 0xff
  215bac:	721a      	strb	r2, [r3, #8]
		Circle.frame[2]=B_PART(WHITE);
  215bae:	4bb7      	ldr	r3, [pc, #732]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bb0:	22ff      	movs	r2, #255	; 0xff
  215bb2:	725a      	strb	r2, [r3, #9]

		Circle.fill[0]=R_PART(MYGRAY);
  215bb4:	4bb5      	ldr	r3, [pc, #724]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bb6:	2240      	movs	r2, #64	; 0x40
  215bb8:	729a      	strb	r2, [r3, #10]
		Circle.fill[1]=G_PART(MYGRAY);
  215bba:	4bb4      	ldr	r3, [pc, #720]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bbc:	2240      	movs	r2, #64	; 0x40
  215bbe:	72da      	strb	r2, [r3, #11]
		Circle.fill[2]=B_PART(MYGRAY);
  215bc0:	4bb2      	ldr	r3, [pc, #712]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bc2:	2240      	movs	r2, #64	; 0x40
  215bc4:	731a      	strb	r2, [r3, #12]

		Circle.ratioBk=0.0;
  215bc6:	4bb1      	ldr	r3, [pc, #708]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bc8:	f04f 0200 	mov.w	r2, #0
  215bcc:	611a      	str	r2, [r3, #16]
		Circle.ratioFill=0.0;
  215bce:	4baf      	ldr	r3, [pc, #700]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bd0:	f04f 0200 	mov.w	r2, #0
  215bd4:	615a      	str	r2, [r3, #20]
		Circle.bold=0;
  215bd6:	4bad      	ldr	r3, [pc, #692]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bd8:	2200      	movs	r2, #0
  215bda:	771a      	strb	r2, [r3, #28]
		Circle.halfCircle=0;
  215bdc:	4bab      	ldr	r3, [pc, #684]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bde:	2200      	movs	r2, #0
  215be0:	775a      	strb	r2, [r3, #29]

		Circle.deg[0]=45;//45;		Circle.degColor[0]=MYGRAY; //nie wykorzystane !!!!!
  215be2:	4baa      	ldr	r3, [pc, #680]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215be4:	222d      	movs	r2, #45	; 0x2d
  215be6:	83da      	strh	r2, [r3, #30]
		Circle.deg[1]=170;	   Circle.degColor[1]=MYRED;
  215be8:	4ba8      	ldr	r3, [pc, #672]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bea:	22aa      	movs	r2, #170	; 0xaa
  215bec:	841a      	strh	r2, [r3, #32]
  215bee:	4ba7      	ldr	r3, [pc, #668]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bf0:	4aa7      	ldr	r2, [pc, #668]	; (215e90 <SCREEN_Test_Circle+0x324>)
  215bf2:	639a      	str	r2, [r3, #56]	; 0x38
		Circle.deg[2]=360; /*185 !!!*/    Circle.degColor[2]=DARKYELLOW;
  215bf4:	4ba5      	ldr	r3, [pc, #660]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bf6:	f44f 72b4 	mov.w	r2, #360	; 0x168
  215bfa:	845a      	strh	r2, [r3, #34]	; 0x22
  215bfc:	4ba3      	ldr	r3, [pc, #652]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215bfe:	4aa5      	ldr	r2, [pc, #660]	; (215e94 <SCREEN_Test_Circle+0x328>)
  215c00:	63da      	str	r2, [r3, #60]	; 0x3c
		Circle.deg[3]=215;   Circle.degColor[3]=DARKGREEN;
  215c02:	4ba2      	ldr	r3, [pc, #648]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c04:	22d7      	movs	r2, #215	; 0xd7
  215c06:	849a      	strh	r2, [r3, #36]	; 0x24
  215c08:	4ba0      	ldr	r3, [pc, #640]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c0a:	4aa3      	ldr	r2, [pc, #652]	; (215e98 <SCREEN_Test_Circle+0x32c>)
  215c0c:	641a      	str	r2, [r3, #64]	; 0x40
		Circle.deg[4]=240;   Circle.degColor[4]=DARKBLUE;
  215c0e:	4b9f      	ldr	r3, [pc, #636]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c10:	22f0      	movs	r2, #240	; 0xf0
  215c12:	84da      	strh	r2, [r3, #38]	; 0x26
  215c14:	4b9d      	ldr	r3, [pc, #628]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c16:	4aa1      	ldr	r2, [pc, #644]	; (215e9c <SCREEN_Test_Circle+0x330>)
  215c18:	645a      	str	r2, [r3, #68]	; 0x44
		Circle.deg[5]=249;   Circle.degColor[5]=DARKCYAN;
  215c1a:	4b9c      	ldr	r3, [pc, #624]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c1c:	22f9      	movs	r2, #249	; 0xf9
  215c1e:	851a      	strh	r2, [r3, #40]	; 0x28
  215c20:	4b9a      	ldr	r3, [pc, #616]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c22:	4a9f      	ldr	r2, [pc, #636]	; (215ea0 <SCREEN_Test_Circle+0x334>)
  215c24:	649a      	str	r2, [r3, #72]	; 0x48
		Circle.deg[6]=310;   Circle.degColor[6]=BROWN;
  215c26:	4b99      	ldr	r3, [pc, #612]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c28:	f44f 729b 	mov.w	r2, #310	; 0x136
  215c2c:	855a      	strh	r2, [r3, #42]	; 0x2a
  215c2e:	4b97      	ldr	r3, [pc, #604]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c30:	4a9c      	ldr	r2, [pc, #624]	; (215ea4 <SCREEN_Test_Circle+0x338>)
  215c32:	64da      	str	r2, [r3, #76]	; 0x4c

		SCREEN_ResetAllParameters();
  215c34:	f7fd ffdc 	bl	213bf0 <SCREEN_ResetAllParameters>
		LCD_LoadFont_DarkgrayWhite(FONT_10, Arial, fontID_1);
  215c38:	2200      	movs	r2, #0
  215c3a:	2105      	movs	r1, #5
  215c3c:	2006      	movs	r0, #6
  215c3e:	f7f6 fbdd 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
		LCD_LoadFont_DarkgrayWhite(FONT_10_bold, Arial, fontID_2);
  215c42:	2201      	movs	r2, #1
  215c44:	2105      	movs	r1, #5
  215c46:	2007      	movs	r0, #7
  215c48:	f7f6 fbd8 	bl	20c3fc <LCD_LoadFont_DarkgrayWhite>
	}

	CorrectLineAA_off();
  215c4c:	f7ee ffda 	bl	204c04 <CorrectLineAA_off>

	//LCD_SetCircleDegrees(4,Circle.deg[0],Circle.deg[1],Circle.deg[2],Circle.deg[3],Circle.deg[4],Circle.deg[5],Circle.deg[6]);
	//LCD_SetCircleDegreesBuff(4,Circle.deg);
	//LCD_SetCircleDegColors(4,Circle.degColor[0],Circle.degColor[1],Circle.degColor[2],Circle.degColor[3],Circle.degColor[4],Circle.degColor[5],Circle.degColor[6]);
	//LCD_SetCircleDegColorsBuff(4,Circle.degColor);
	LCD_SetCirclePercentParam(2,Circle.deg,Circle.degColor);
  215c50:	4a95      	ldr	r2, [pc, #596]	; (215ea8 <SCREEN_Test_Circle+0x33c>)
  215c52:	4996      	ldr	r1, [pc, #600]	; (215eac <SCREEN_Test_Circle+0x340>)
  215c54:	2002      	movs	r0, #2
  215c56:	f7f1 fa8d 	bl	207174 <LCD_SetCirclePercentParam>
	LCD_Clear(RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]));  //dac opisy b: to bold !!!!!! na lcd ekranie
  215c5a:	4b8c      	ldr	r3, [pc, #560]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c5c:	791b      	ldrb	r3, [r3, #4]
  215c5e:	041a      	lsls	r2, r3, #16
  215c60:	4b8a      	ldr	r3, [pc, #552]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c62:	795b      	ldrb	r3, [r3, #5]
  215c64:	021b      	lsls	r3, r3, #8
  215c66:	4313      	orrs	r3, r2
  215c68:	4a88      	ldr	r2, [pc, #544]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215c6a:	7992      	ldrb	r2, [r2, #6]
  215c6c:	4313      	orrs	r3, r2
  215c6e:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
  215c72:	4618      	mov	r0, r3
  215c74:	f7ef fe28 	bl	2058c8 <LCD_Clear>


	lenStr=LCD_Str(fontID_1, LCD_Xpos(lenStr,SetPos,0), LCD_Ypos(lenStr,SetPos,0), StrAll(2,"Radius } | ",Int2Str(Circle.width,' ',3,Sign_none)), 	 fullHight,0,_BkColor(),1,1);  //'znak' w opisie !!!!!
  215c78:	4b8d      	ldr	r3, [pc, #564]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215c7a:	681a      	ldr	r2, [r3, #0]
  215c7c:	2000      	movs	r0, #0
  215c7e:	4610      	mov	r0, r2
  215c80:	889b      	ldrh	r3, [r3, #4]
  215c82:	2100      	movs	r1, #0
  215c84:	f363 010f 	bfi	r1, r3, #0, #16
  215c88:	2300      	movs	r3, #0
  215c8a:	2200      	movs	r2, #0
  215c8c:	f7fc fe76 	bl	21297c <LCD_Xpos>
  215c90:	4603      	mov	r3, r0
  215c92:	461e      	mov	r6, r3
  215c94:	4b86      	ldr	r3, [pc, #536]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215c96:	681a      	ldr	r2, [r3, #0]
  215c98:	2000      	movs	r0, #0
  215c9a:	4610      	mov	r0, r2
  215c9c:	889b      	ldrh	r3, [r3, #4]
  215c9e:	2100      	movs	r1, #0
  215ca0:	f363 010f 	bfi	r1, r3, #0, #16
  215ca4:	2300      	movs	r3, #0
  215ca6:	2200      	movs	r2, #0
  215ca8:	f7fc fe36 	bl	212918 <LCD_Ypos>
  215cac:	4603      	mov	r3, r0
  215cae:	4698      	mov	r8, r3
  215cb0:	4b76      	ldr	r3, [pc, #472]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215cb2:	885b      	ldrh	r3, [r3, #2]
  215cb4:	4618      	mov	r0, r3
  215cb6:	2303      	movs	r3, #3
  215cb8:	2203      	movs	r2, #3
  215cba:	2120      	movs	r1, #32
  215cbc:	f7eb fd02 	bl	2016c4 <Int2Str>
  215cc0:	4603      	mov	r3, r0
  215cc2:	461a      	mov	r2, r3
  215cc4:	497b      	ldr	r1, [pc, #492]	; (215eb4 <SCREEN_Test_Circle+0x348>)
  215cc6:	2002      	movs	r0, #2
  215cc8:	f7eb fef0 	bl	201aac <StrAll>
  215ccc:	4604      	mov	r4, r0
  215cce:	f107 030c 	add.w	r3, r7, #12
  215cd2:	469c      	mov	ip, r3
  215cd4:	f7ff ff30 	bl	215b38 <_BkColor.12857>
  215cd8:	4602      	mov	r2, r0
  215cda:	4d75      	ldr	r5, [pc, #468]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215cdc:	4638      	mov	r0, r7
  215cde:	2301      	movs	r3, #1
  215ce0:	9305      	str	r3, [sp, #20]
  215ce2:	2301      	movs	r3, #1
  215ce4:	9304      	str	r3, [sp, #16]
  215ce6:	9203      	str	r2, [sp, #12]
  215ce8:	2300      	movs	r3, #0
  215cea:	9302      	str	r3, [sp, #8]
  215cec:	f06f 0302 	mvn.w	r3, #2
  215cf0:	9301      	str	r3, [sp, #4]
  215cf2:	9400      	str	r4, [sp, #0]
  215cf4:	4643      	mov	r3, r8
  215cf6:	4632      	mov	r2, r6
  215cf8:	2100      	movs	r1, #0
  215cfa:	f7f6 fb95 	bl	20c428 <LCD_Str>
  215cfe:	462a      	mov	r2, r5
  215d00:	463b      	mov	r3, r7
  215d02:	6819      	ldr	r1, [r3, #0]
  215d04:	6011      	str	r1, [r2, #0]
  215d06:	889b      	ldrh	r3, [r3, #4]
  215d08:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_Str(fontID_2, LCD_Xpos(lenStr,IncPos,10), LCD_Ypos(lenStr,GetPos,0), StrAll(2,"angle:",INT2STR_TIME(Circle.deg[0])),fullHight,0,_BkColor(),1,0);
  215d0a:	4b69      	ldr	r3, [pc, #420]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215d0c:	681a      	ldr	r2, [r3, #0]
  215d0e:	2000      	movs	r0, #0
  215d10:	4610      	mov	r0, r2
  215d12:	889b      	ldrh	r3, [r3, #4]
  215d14:	2100      	movs	r1, #0
  215d16:	f363 010f 	bfi	r1, r3, #0, #16
  215d1a:	230a      	movs	r3, #10
  215d1c:	2202      	movs	r2, #2
  215d1e:	f7fc fe2d 	bl	21297c <LCD_Xpos>
  215d22:	4603      	mov	r3, r0
  215d24:	461e      	mov	r6, r3
  215d26:	4b62      	ldr	r3, [pc, #392]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215d28:	681a      	ldr	r2, [r3, #0]
  215d2a:	2000      	movs	r0, #0
  215d2c:	4610      	mov	r0, r2
  215d2e:	889b      	ldrh	r3, [r3, #4]
  215d30:	2100      	movs	r1, #0
  215d32:	f363 010f 	bfi	r1, r3, #0, #16
  215d36:	2300      	movs	r3, #0
  215d38:	2201      	movs	r2, #1
  215d3a:	f7fc fded 	bl	212918 <LCD_Ypos>
  215d3e:	4603      	mov	r3, r0
  215d40:	4698      	mov	r8, r3
  215d42:	4b52      	ldr	r3, [pc, #328]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215d44:	8bdb      	ldrh	r3, [r3, #30]
  215d46:	4618      	mov	r0, r3
  215d48:	2303      	movs	r3, #3
  215d4a:	2206      	movs	r2, #6
  215d4c:	2120      	movs	r1, #32
  215d4e:	f7eb fcb9 	bl	2016c4 <Int2Str>
  215d52:	4603      	mov	r3, r0
  215d54:	461a      	mov	r2, r3
  215d56:	4958      	ldr	r1, [pc, #352]	; (215eb8 <SCREEN_Test_Circle+0x34c>)
  215d58:	2002      	movs	r0, #2
  215d5a:	f7eb fea7 	bl	201aac <StrAll>
  215d5e:	4604      	mov	r4, r0
  215d60:	f107 030c 	add.w	r3, r7, #12
  215d64:	469c      	mov	ip, r3
  215d66:	f7ff fee7 	bl	215b38 <_BkColor.12857>
  215d6a:	4602      	mov	r2, r0
  215d6c:	4d50      	ldr	r5, [pc, #320]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215d6e:	4638      	mov	r0, r7
  215d70:	2300      	movs	r3, #0
  215d72:	9305      	str	r3, [sp, #20]
  215d74:	2301      	movs	r3, #1
  215d76:	9304      	str	r3, [sp, #16]
  215d78:	9203      	str	r2, [sp, #12]
  215d7a:	2300      	movs	r3, #0
  215d7c:	9302      	str	r3, [sp, #8]
  215d7e:	f06f 0302 	mvn.w	r3, #2
  215d82:	9301      	str	r3, [sp, #4]
  215d84:	9400      	str	r4, [sp, #0]
  215d86:	4643      	mov	r3, r8
  215d88:	4632      	mov	r2, r6
  215d8a:	2101      	movs	r1, #1
  215d8c:	f7f6 fb4c 	bl	20c428 <LCD_Str>
  215d90:	462a      	mov	r2, r5
  215d92:	463b      	mov	r3, r7
  215d94:	6819      	ldr	r1, [r3, #0]
  215d96:	6011      	str	r1, [r2, #0]
  215d98:	889b      	ldrh	r3, [r3, #4]
  215d9a:	8093      	strh	r3, [r2, #4]

	lenStr=LCD_Str(fontID_1, LCD_Xpos(lenStr,SetPos,0), LCD_Ypos(lenStr,IncPos,8), StrAll(6,"Frame: ",INT2STR(Circle.frame[0])," ",INT2STR(Circle.frame[1])," ",INT2STR(Circle.frame[2])),  halfHight,0,_BkColor(),1,1);
  215d9c:	4b44      	ldr	r3, [pc, #272]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215d9e:	681a      	ldr	r2, [r3, #0]
  215da0:	2000      	movs	r0, #0
  215da2:	4610      	mov	r0, r2
  215da4:	889b      	ldrh	r3, [r3, #4]
  215da6:	2100      	movs	r1, #0
  215da8:	f363 010f 	bfi	r1, r3, #0, #16
  215dac:	2300      	movs	r3, #0
  215dae:	2200      	movs	r2, #0
  215db0:	f7fc fde4 	bl	21297c <LCD_Xpos>
  215db4:	4603      	mov	r3, r0
  215db6:	461e      	mov	r6, r3
  215db8:	4b3d      	ldr	r3, [pc, #244]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215dba:	681a      	ldr	r2, [r3, #0]
  215dbc:	2000      	movs	r0, #0
  215dbe:	4610      	mov	r0, r2
  215dc0:	889b      	ldrh	r3, [r3, #4]
  215dc2:	2100      	movs	r1, #0
  215dc4:	f363 010f 	bfi	r1, r3, #0, #16
  215dc8:	2308      	movs	r3, #8
  215dca:	2202      	movs	r2, #2
  215dcc:	f7fc fda4 	bl	212918 <LCD_Ypos>
  215dd0:	4603      	mov	r3, r0
  215dd2:	4698      	mov	r8, r3
  215dd4:	4b2d      	ldr	r3, [pc, #180]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215dd6:	79db      	ldrb	r3, [r3, #7]
  215dd8:	4618      	mov	r0, r3
  215dda:	2303      	movs	r3, #3
  215ddc:	2203      	movs	r2, #3
  215dde:	2130      	movs	r1, #48	; 0x30
  215de0:	f7eb fc70 	bl	2016c4 <Int2Str>
  215de4:	4605      	mov	r5, r0
  215de6:	4b29      	ldr	r3, [pc, #164]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215de8:	7a1b      	ldrb	r3, [r3, #8]
  215dea:	4618      	mov	r0, r3
  215dec:	2303      	movs	r3, #3
  215dee:	2203      	movs	r2, #3
  215df0:	2130      	movs	r1, #48	; 0x30
  215df2:	f7eb fc67 	bl	2016c4 <Int2Str>
  215df6:	4604      	mov	r4, r0
  215df8:	4b24      	ldr	r3, [pc, #144]	; (215e8c <SCREEN_Test_Circle+0x320>)
  215dfa:	7a5b      	ldrb	r3, [r3, #9]
  215dfc:	4618      	mov	r0, r3
  215dfe:	2303      	movs	r3, #3
  215e00:	2203      	movs	r2, #3
  215e02:	2130      	movs	r1, #48	; 0x30
  215e04:	f7eb fc5e 	bl	2016c4 <Int2Str>
  215e08:	4603      	mov	r3, r0
  215e0a:	9302      	str	r3, [sp, #8]
  215e0c:	4b2b      	ldr	r3, [pc, #172]	; (215ebc <SCREEN_Test_Circle+0x350>)
  215e0e:	9301      	str	r3, [sp, #4]
  215e10:	9400      	str	r4, [sp, #0]
  215e12:	4b2a      	ldr	r3, [pc, #168]	; (215ebc <SCREEN_Test_Circle+0x350>)
  215e14:	462a      	mov	r2, r5
  215e16:	492a      	ldr	r1, [pc, #168]	; (215ec0 <SCREEN_Test_Circle+0x354>)
  215e18:	2006      	movs	r0, #6
  215e1a:	f7eb fe47 	bl	201aac <StrAll>
  215e1e:	4604      	mov	r4, r0
  215e20:	f107 030c 	add.w	r3, r7, #12
  215e24:	469c      	mov	ip, r3
  215e26:	f7ff fe87 	bl	215b38 <_BkColor.12857>
  215e2a:	4602      	mov	r2, r0
  215e2c:	4d20      	ldr	r5, [pc, #128]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215e2e:	4638      	mov	r0, r7
  215e30:	2301      	movs	r3, #1
  215e32:	9305      	str	r3, [sp, #20]
  215e34:	2301      	movs	r3, #1
  215e36:	9304      	str	r3, [sp, #16]
  215e38:	9203      	str	r2, [sp, #12]
  215e3a:	2300      	movs	r3, #0
  215e3c:	9302      	str	r3, [sp, #8]
  215e3e:	f06f 0301 	mvn.w	r3, #1
  215e42:	9301      	str	r3, [sp, #4]
  215e44:	9400      	str	r4, [sp, #0]
  215e46:	4643      	mov	r3, r8
  215e48:	4632      	mov	r2, r6
  215e4a:	2100      	movs	r1, #0
  215e4c:	f7f6 faec 	bl	20c428 <LCD_Str>
  215e50:	462a      	mov	r2, r5
  215e52:	463b      	mov	r3, r7
  215e54:	6819      	ldr	r1, [r3, #0]
  215e56:	6011      	str	r1, [r2, #0]
  215e58:	889b      	ldrh	r3, [r3, #4]
  215e5a:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_Str(fontID_1, LCD_Xpos(lenStr,GetPos,0), LCD_Ypos(lenStr,IncPos,5), StrAll(6,"Fill:  ",INT2STR(Circle.fill[0]), " ",INT2STR(Circle.fill[1]), " ",INT2STR(Circle.fill[2])),   halfHight,0,_BkColor(),1,1);
  215e5c:	4b14      	ldr	r3, [pc, #80]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215e5e:	681a      	ldr	r2, [r3, #0]
  215e60:	2000      	movs	r0, #0
  215e62:	4610      	mov	r0, r2
  215e64:	889b      	ldrh	r3, [r3, #4]
  215e66:	2100      	movs	r1, #0
  215e68:	f363 010f 	bfi	r1, r3, #0, #16
  215e6c:	2300      	movs	r3, #0
  215e6e:	2201      	movs	r2, #1
  215e70:	f7fc fd84 	bl	21297c <LCD_Xpos>
  215e74:	4603      	mov	r3, r0
  215e76:	461e      	mov	r6, r3
  215e78:	4b0d      	ldr	r3, [pc, #52]	; (215eb0 <SCREEN_Test_Circle+0x344>)
  215e7a:	681a      	ldr	r2, [r3, #0]
  215e7c:	2000      	movs	r0, #0
  215e7e:	4610      	mov	r0, r2
  215e80:	889b      	ldrh	r3, [r3, #4]
  215e82:	2100      	movs	r1, #0
  215e84:	f363 010f 	bfi	r1, r3, #0, #16
  215e88:	2305      	movs	r3, #5
  215e8a:	e01b      	b.n	215ec4 <SCREEN_Test_Circle+0x358>
  215e8c:	200104e8 	.word	0x200104e8
  215e90:	ffff7878 	.word	0xffff7878
  215e94:	ff808000 	.word	0xff808000
  215e98:	ff008000 	.word	0xff008000
  215e9c:	ff000080 	.word	0xff000080
  215ea0:	ff008080 	.word	0xff008080
  215ea4:	ffa52a2a 	.word	0xffa52a2a
  215ea8:	2001051c 	.word	0x2001051c
  215eac:	20010506 	.word	0x20010506
  215eb0:	20014a44 	.word	0x20014a44
  215eb4:	002290a0 	.word	0x002290a0
  215eb8:	002290ac 	.word	0x002290ac
  215ebc:	00228e34 	.word	0x00228e34
  215ec0:	002290b4 	.word	0x002290b4
  215ec4:	2202      	movs	r2, #2
  215ec6:	f7fc fd27 	bl	212918 <LCD_Ypos>
  215eca:	4603      	mov	r3, r0
  215ecc:	4698      	mov	r8, r3
  215ece:	4bcb      	ldr	r3, [pc, #812]	; (2161fc <SCREEN_Test_Circle+0x690>)
  215ed0:	7a9b      	ldrb	r3, [r3, #10]
  215ed2:	4618      	mov	r0, r3
  215ed4:	2303      	movs	r3, #3
  215ed6:	2203      	movs	r2, #3
  215ed8:	2130      	movs	r1, #48	; 0x30
  215eda:	f7eb fbf3 	bl	2016c4 <Int2Str>
  215ede:	4605      	mov	r5, r0
  215ee0:	4bc6      	ldr	r3, [pc, #792]	; (2161fc <SCREEN_Test_Circle+0x690>)
  215ee2:	7adb      	ldrb	r3, [r3, #11]
  215ee4:	4618      	mov	r0, r3
  215ee6:	2303      	movs	r3, #3
  215ee8:	2203      	movs	r2, #3
  215eea:	2130      	movs	r1, #48	; 0x30
  215eec:	f7eb fbea 	bl	2016c4 <Int2Str>
  215ef0:	4604      	mov	r4, r0
  215ef2:	4bc2      	ldr	r3, [pc, #776]	; (2161fc <SCREEN_Test_Circle+0x690>)
  215ef4:	7b1b      	ldrb	r3, [r3, #12]
  215ef6:	4618      	mov	r0, r3
  215ef8:	2303      	movs	r3, #3
  215efa:	2203      	movs	r2, #3
  215efc:	2130      	movs	r1, #48	; 0x30
  215efe:	f7eb fbe1 	bl	2016c4 <Int2Str>
  215f02:	4603      	mov	r3, r0
  215f04:	9302      	str	r3, [sp, #8]
  215f06:	4bbe      	ldr	r3, [pc, #760]	; (216200 <SCREEN_Test_Circle+0x694>)
  215f08:	9301      	str	r3, [sp, #4]
  215f0a:	9400      	str	r4, [sp, #0]
  215f0c:	4bbc      	ldr	r3, [pc, #752]	; (216200 <SCREEN_Test_Circle+0x694>)
  215f0e:	462a      	mov	r2, r5
  215f10:	49bc      	ldr	r1, [pc, #752]	; (216204 <SCREEN_Test_Circle+0x698>)
  215f12:	2006      	movs	r0, #6
  215f14:	f7eb fdca 	bl	201aac <StrAll>
  215f18:	4604      	mov	r4, r0
  215f1a:	f107 030c 	add.w	r3, r7, #12
  215f1e:	469c      	mov	ip, r3
  215f20:	f7ff fe0a 	bl	215b38 <_BkColor.12857>
  215f24:	4602      	mov	r2, r0
  215f26:	4db8      	ldr	r5, [pc, #736]	; (216208 <SCREEN_Test_Circle+0x69c>)
  215f28:	4638      	mov	r0, r7
  215f2a:	2301      	movs	r3, #1
  215f2c:	9305      	str	r3, [sp, #20]
  215f2e:	2301      	movs	r3, #1
  215f30:	9304      	str	r3, [sp, #16]
  215f32:	9203      	str	r2, [sp, #12]
  215f34:	2300      	movs	r3, #0
  215f36:	9302      	str	r3, [sp, #8]
  215f38:	f06f 0301 	mvn.w	r3, #1
  215f3c:	9301      	str	r3, [sp, #4]
  215f3e:	9400      	str	r4, [sp, #0]
  215f40:	4643      	mov	r3, r8
  215f42:	4632      	mov	r2, r6
  215f44:	2100      	movs	r1, #0
  215f46:	f7f6 fa6f 	bl	20c428 <LCD_Str>
  215f4a:	462a      	mov	r2, r5
  215f4c:	463b      	mov	r3, r7
  215f4e:	6819      	ldr	r1, [r3, #0]
  215f50:	6011      	str	r1, [r2, #0]
  215f52:	889b      	ldrh	r3, [r3, #4]
  215f54:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_Str(fontID_1, LCD_Xpos(lenStr,GetPos,0), LCD_Ypos(lenStr,IncPos,5), StrAll(6,"Backup:",INT2STR(Circle.bk[0]),   " ",INT2STR(Circle.bk[1]),   " ",INT2STR(Circle.bk[2])),   halfHight,0,_BkColor(),1,1);
  215f56:	4bac      	ldr	r3, [pc, #688]	; (216208 <SCREEN_Test_Circle+0x69c>)
  215f58:	681a      	ldr	r2, [r3, #0]
  215f5a:	2000      	movs	r0, #0
  215f5c:	4610      	mov	r0, r2
  215f5e:	889b      	ldrh	r3, [r3, #4]
  215f60:	2100      	movs	r1, #0
  215f62:	f363 010f 	bfi	r1, r3, #0, #16
  215f66:	2300      	movs	r3, #0
  215f68:	2201      	movs	r2, #1
  215f6a:	f7fc fd07 	bl	21297c <LCD_Xpos>
  215f6e:	4603      	mov	r3, r0
  215f70:	461e      	mov	r6, r3
  215f72:	4ba5      	ldr	r3, [pc, #660]	; (216208 <SCREEN_Test_Circle+0x69c>)
  215f74:	681a      	ldr	r2, [r3, #0]
  215f76:	2000      	movs	r0, #0
  215f78:	4610      	mov	r0, r2
  215f7a:	889b      	ldrh	r3, [r3, #4]
  215f7c:	2100      	movs	r1, #0
  215f7e:	f363 010f 	bfi	r1, r3, #0, #16
  215f82:	2305      	movs	r3, #5
  215f84:	2202      	movs	r2, #2
  215f86:	f7fc fcc7 	bl	212918 <LCD_Ypos>
  215f8a:	4603      	mov	r3, r0
  215f8c:	4698      	mov	r8, r3
  215f8e:	4b9b      	ldr	r3, [pc, #620]	; (2161fc <SCREEN_Test_Circle+0x690>)
  215f90:	791b      	ldrb	r3, [r3, #4]
  215f92:	4618      	mov	r0, r3
  215f94:	2303      	movs	r3, #3
  215f96:	2203      	movs	r2, #3
  215f98:	2130      	movs	r1, #48	; 0x30
  215f9a:	f7eb fb93 	bl	2016c4 <Int2Str>
  215f9e:	4605      	mov	r5, r0
  215fa0:	4b96      	ldr	r3, [pc, #600]	; (2161fc <SCREEN_Test_Circle+0x690>)
  215fa2:	795b      	ldrb	r3, [r3, #5]
  215fa4:	4618      	mov	r0, r3
  215fa6:	2303      	movs	r3, #3
  215fa8:	2203      	movs	r2, #3
  215faa:	2130      	movs	r1, #48	; 0x30
  215fac:	f7eb fb8a 	bl	2016c4 <Int2Str>
  215fb0:	4604      	mov	r4, r0
  215fb2:	4b92      	ldr	r3, [pc, #584]	; (2161fc <SCREEN_Test_Circle+0x690>)
  215fb4:	799b      	ldrb	r3, [r3, #6]
  215fb6:	4618      	mov	r0, r3
  215fb8:	2303      	movs	r3, #3
  215fba:	2203      	movs	r2, #3
  215fbc:	2130      	movs	r1, #48	; 0x30
  215fbe:	f7eb fb81 	bl	2016c4 <Int2Str>
  215fc2:	4603      	mov	r3, r0
  215fc4:	9302      	str	r3, [sp, #8]
  215fc6:	4b8e      	ldr	r3, [pc, #568]	; (216200 <SCREEN_Test_Circle+0x694>)
  215fc8:	9301      	str	r3, [sp, #4]
  215fca:	9400      	str	r4, [sp, #0]
  215fcc:	4b8c      	ldr	r3, [pc, #560]	; (216200 <SCREEN_Test_Circle+0x694>)
  215fce:	462a      	mov	r2, r5
  215fd0:	498e      	ldr	r1, [pc, #568]	; (21620c <SCREEN_Test_Circle+0x6a0>)
  215fd2:	2006      	movs	r0, #6
  215fd4:	f7eb fd6a 	bl	201aac <StrAll>
  215fd8:	4604      	mov	r4, r0
  215fda:	f107 030c 	add.w	r3, r7, #12
  215fde:	469c      	mov	ip, r3
  215fe0:	f7ff fdaa 	bl	215b38 <_BkColor.12857>
  215fe4:	4602      	mov	r2, r0
  215fe6:	4d88      	ldr	r5, [pc, #544]	; (216208 <SCREEN_Test_Circle+0x69c>)
  215fe8:	4638      	mov	r0, r7
  215fea:	2301      	movs	r3, #1
  215fec:	9305      	str	r3, [sp, #20]
  215fee:	2301      	movs	r3, #1
  215ff0:	9304      	str	r3, [sp, #16]
  215ff2:	9203      	str	r2, [sp, #12]
  215ff4:	2300      	movs	r3, #0
  215ff6:	9302      	str	r3, [sp, #8]
  215ff8:	f06f 0301 	mvn.w	r3, #1
  215ffc:	9301      	str	r3, [sp, #4]
  215ffe:	9400      	str	r4, [sp, #0]
  216000:	4643      	mov	r3, r8
  216002:	4632      	mov	r2, r6
  216004:	2100      	movs	r1, #0
  216006:	f7f6 fa0f 	bl	20c428 <LCD_Str>
  21600a:	462a      	mov	r2, r5
  21600c:	463b      	mov	r3, r7
  21600e:	6819      	ldr	r1, [r3, #0]
  216010:	6011      	str	r1, [r2, #0]
  216012:	889b      	ldrh	r3, [r3, #4]
  216014:	8093      	strh	r3, [r2, #4]

	lenStr=LCD_Str(fontID_2, LCD_Xpos(lenStr,GetPos,0), LCD_Ypos(lenStr,IncPos,5), StrAll(4,"AA out:",Float2Str(Circle.ratioBk,' ',1,Sign_none,2),"  AA in:",Float2Str(Circle.ratioFill,' ',1,Sign_none,2)), 	 halfHight,0,_BkColor(),1,1);
  216016:	4b7c      	ldr	r3, [pc, #496]	; (216208 <SCREEN_Test_Circle+0x69c>)
  216018:	681a      	ldr	r2, [r3, #0]
  21601a:	2000      	movs	r0, #0
  21601c:	4610      	mov	r0, r2
  21601e:	889b      	ldrh	r3, [r3, #4]
  216020:	2100      	movs	r1, #0
  216022:	f363 010f 	bfi	r1, r3, #0, #16
  216026:	2300      	movs	r3, #0
  216028:	2201      	movs	r2, #1
  21602a:	f7fc fca7 	bl	21297c <LCD_Xpos>
  21602e:	4603      	mov	r3, r0
  216030:	461e      	mov	r6, r3
  216032:	4b75      	ldr	r3, [pc, #468]	; (216208 <SCREEN_Test_Circle+0x69c>)
  216034:	681a      	ldr	r2, [r3, #0]
  216036:	2000      	movs	r0, #0
  216038:	4610      	mov	r0, r2
  21603a:	889b      	ldrh	r3, [r3, #4]
  21603c:	2100      	movs	r1, #0
  21603e:	f363 010f 	bfi	r1, r3, #0, #16
  216042:	2305      	movs	r3, #5
  216044:	2202      	movs	r2, #2
  216046:	f7fc fc67 	bl	212918 <LCD_Ypos>
  21604a:	4603      	mov	r3, r0
  21604c:	4698      	mov	r8, r3
  21604e:	4b6b      	ldr	r3, [pc, #428]	; (2161fc <SCREEN_Test_Circle+0x690>)
  216050:	edd3 7a04 	vldr	s15, [r3, #16]
  216054:	2302      	movs	r3, #2
  216056:	2203      	movs	r2, #3
  216058:	2101      	movs	r1, #1
  21605a:	2020      	movs	r0, #32
  21605c:	eeb0 0a67 	vmov.f32	s0, s15
  216060:	f7eb fc2c 	bl	2018bc <Float2Str>
  216064:	4604      	mov	r4, r0
  216066:	4b65      	ldr	r3, [pc, #404]	; (2161fc <SCREEN_Test_Circle+0x690>)
  216068:	edd3 7a05 	vldr	s15, [r3, #20]
  21606c:	2302      	movs	r3, #2
  21606e:	2203      	movs	r2, #3
  216070:	2101      	movs	r1, #1
  216072:	2020      	movs	r0, #32
  216074:	eeb0 0a67 	vmov.f32	s0, s15
  216078:	f7eb fc20 	bl	2018bc <Float2Str>
  21607c:	4603      	mov	r3, r0
  21607e:	9300      	str	r3, [sp, #0]
  216080:	4b63      	ldr	r3, [pc, #396]	; (216210 <SCREEN_Test_Circle+0x6a4>)
  216082:	4622      	mov	r2, r4
  216084:	4963      	ldr	r1, [pc, #396]	; (216214 <SCREEN_Test_Circle+0x6a8>)
  216086:	2004      	movs	r0, #4
  216088:	f7eb fd10 	bl	201aac <StrAll>
  21608c:	4604      	mov	r4, r0
  21608e:	f107 030c 	add.w	r3, r7, #12
  216092:	469c      	mov	ip, r3
  216094:	f7ff fd50 	bl	215b38 <_BkColor.12857>
  216098:	4602      	mov	r2, r0
  21609a:	4d5b      	ldr	r5, [pc, #364]	; (216208 <SCREEN_Test_Circle+0x69c>)
  21609c:	4638      	mov	r0, r7
  21609e:	2301      	movs	r3, #1
  2160a0:	9305      	str	r3, [sp, #20]
  2160a2:	2301      	movs	r3, #1
  2160a4:	9304      	str	r3, [sp, #16]
  2160a6:	9203      	str	r2, [sp, #12]
  2160a8:	2300      	movs	r3, #0
  2160aa:	9302      	str	r3, [sp, #8]
  2160ac:	f06f 0301 	mvn.w	r3, #1
  2160b0:	9301      	str	r3, [sp, #4]
  2160b2:	9400      	str	r4, [sp, #0]
  2160b4:	4643      	mov	r3, r8
  2160b6:	4632      	mov	r2, r6
  2160b8:	2101      	movs	r1, #1
  2160ba:	f7f6 f9b5 	bl	20c428 <LCD_Str>
  2160be:	462a      	mov	r2, r5
  2160c0:	463b      	mov	r3, r7
  2160c2:	6819      	ldr	r1, [r3, #0]
  2160c4:	6011      	str	r1, [r2, #0]
  2160c6:	889b      	ldrh	r3, [r3, #4]
  2160c8:	8093      	strh	r3, [r2, #4]

//	LCD_SetCircleParam(0.01,0.01,14, 5,4,4,3,3,2,2,2,2,2, 2,2,1,1); // dla tej konfig nie ma Bold  x to srodek kola
//	LCD_Shape(60,160, LCD_Circle, 0,0, _FrameColor(), _FillColor(), _BkColor());


	if(Circle.bold > Circle.width/INCR_WIDTH_CIRCLE_STEP-1)
  2160ca:	4b4c      	ldr	r3, [pc, #304]	; (2161fc <SCREEN_Test_Circle+0x690>)
  2160cc:	7f1b      	ldrb	r3, [r3, #28]
  2160ce:	4619      	mov	r1, r3
  2160d0:	4b4a      	ldr	r3, [pc, #296]	; (2161fc <SCREEN_Test_Circle+0x690>)
  2160d2:	885b      	ldrh	r3, [r3, #2]
  2160d4:	4a50      	ldr	r2, [pc, #320]	; (216218 <SCREEN_Test_Circle+0x6ac>)
  2160d6:	fba2 2303 	umull	r2, r3, r2, r3
  2160da:	089b      	lsrs	r3, r3, #2
  2160dc:	b29b      	uxth	r3, r3
  2160de:	3b01      	subs	r3, #1
  2160e0:	4299      	cmp	r1, r3
  2160e2:	dd0b      	ble.n	2160fc <SCREEN_Test_Circle+0x590>
		Circle.bold=Circle.width/INCR_WIDTH_CIRCLE_STEP-1;
  2160e4:	4b45      	ldr	r3, [pc, #276]	; (2161fc <SCREEN_Test_Circle+0x690>)
  2160e6:	885b      	ldrh	r3, [r3, #2]
  2160e8:	4a4b      	ldr	r2, [pc, #300]	; (216218 <SCREEN_Test_Circle+0x6ac>)
  2160ea:	fba2 2303 	umull	r2, r3, r2, r3
  2160ee:	089b      	lsrs	r3, r3, #2
  2160f0:	b29b      	uxth	r3, r3
  2160f2:	b2db      	uxtb	r3, r3
  2160f4:	3b01      	subs	r3, #1
  2160f6:	b2da      	uxtb	r2, r3
  2160f8:	4b40      	ldr	r3, [pc, #256]	; (2161fc <SCREEN_Test_Circle+0x690>)
  2160fa:	771a      	strb	r2, [r3, #28]

	LCD_SetCircleAA(Circle.ratioBk,Circle.ratioFill);
  2160fc:	4b3f      	ldr	r3, [pc, #252]	; (2161fc <SCREEN_Test_Circle+0x690>)
  2160fe:	edd3 7a04 	vldr	s15, [r3, #16]
  216102:	4b3e      	ldr	r3, [pc, #248]	; (2161fc <SCREEN_Test_Circle+0x690>)
  216104:	ed93 7a05 	vldr	s14, [r3, #20]
  216108:	eef0 0a47 	vmov.f32	s1, s14
  21610c:	eeb0 0a67 	vmov.f32	s0, s15
  216110:	f7f1 f842 	bl	207198 <LCD_SetCircleAA>
	StartMeasureTime_us();
  216114:	f002 fc90 	bl	218a38 <StartMeasureTime_us>
	//LCD_Shape(480-LCD_GetYSize(),0,LCD_Circle, SetParamWidthCircle(Percent_Circle,Circle.width),Circle.width, SetColorBoldFrame(_FrameColor(),Circle.bold), _FillColor(), _BkColor());

	//LCD_Shape(480-LCD_GetYSize()+10,10,LCD_Circle, Circle.width-20,Circle.width-20, _FrameColor(),  _FillColor(), MYGRAY);


	LCD_Shape(480-LCD_GetYSize(),0,LCD_Circle, Circle.width,Circle.width, SetColorBoldFrame(WHITE/*_FrameColor()*/,Circle.bold), TRANSPARENT/* _FillColor()*/, _BkColor());
  216118:	f7f1 fc5a 	bl	2079d0 <LCD_GetYSize>
  21611c:	4603      	mov	r3, r0
  21611e:	f5c3 74f0 	rsb	r4, r3, #480	; 0x1e0
  216122:	4b36      	ldr	r3, [pc, #216]	; (2161fc <SCREEN_Test_Circle+0x690>)
  216124:	885b      	ldrh	r3, [r3, #2]
  216126:	4698      	mov	r8, r3
  216128:	4b34      	ldr	r3, [pc, #208]	; (2161fc <SCREEN_Test_Circle+0x690>)
  21612a:	885b      	ldrh	r3, [r3, #2]
  21612c:	461d      	mov	r5, r3
  21612e:	4b33      	ldr	r3, [pc, #204]	; (2161fc <SCREEN_Test_Circle+0x690>)
  216130:	7f1b      	ldrb	r3, [r3, #28]
  216132:	4619      	mov	r1, r3
  216134:	f04f 30ff 	mov.w	r0, #4294967295
  216138:	f7ef fbee 	bl	205918 <SetColorBoldFrame>
  21613c:	4606      	mov	r6, r0
  21613e:	f107 030c 	add.w	r3, r7, #12
  216142:	469c      	mov	ip, r3
  216144:	f7ff fcf8 	bl	215b38 <_BkColor.12857>
  216148:	4603      	mov	r3, r0
  21614a:	9303      	str	r3, [sp, #12]
  21614c:	2300      	movs	r3, #0
  21614e:	9302      	str	r3, [sp, #8]
  216150:	9601      	str	r6, [sp, #4]
  216152:	9500      	str	r5, [sp, #0]
  216154:	4643      	mov	r3, r8
  216156:	4a31      	ldr	r2, [pc, #196]	; (21621c <SCREEN_Test_Circle+0x6b0>)
  216158:	2100      	movs	r1, #0
  21615a:	4620      	mov	r0, r4
  21615c:	f7ef fb4c 	bl	2057f8 <LCD_Shape>

	//LCD_Shape(480-LCD_GetYSize(),0,LCD_Circle, SetParamWidthCircle(Degree_Circle,Circle.width),Circle.width, SetColorBoldFrame(RED,Circle.bold), _FillColor(), _BkColor());

	//LCD_Shape(480-LCD_GetYSize(),0, LCD_HalfCircle, SetParamWidthCircle(Circle.halfCircle,Circle.width),Circle.width, SetColorBoldFrame(_FrameColor(),Circle.bold), _FillColor(), _BkColor());
	//LCD_Shape(480-LCD_GetYSize(),0,LCD_Frame, LCD_GetCircleWidth(),LCD_GetCircleWidth(), _FrameColor(), _BkColor(), _BkColor()); //RAMKA KWADRATOWA
	Circle.speed=StopMeasureTime_us("");
  216160:	482f      	ldr	r0, [pc, #188]	; (216220 <SCREEN_Test_Circle+0x6b4>)
  216162:	f002 fc79 	bl	218a58 <StopMeasureTime_us>
  216166:	4602      	mov	r2, r0
  216168:	4b24      	ldr	r3, [pc, #144]	; (2161fc <SCREEN_Test_Circle+0x690>)
  21616a:	619a      	str	r2, [r3, #24]


	lenStr=LCD_Str(fontID_2, LCD_Xpos(lenStr,GetPos,0), LCD_Ypos(lenStr,IncPos,8), StrAll(3,"Speed: ",INT2STR_TIME(Circle.speed)," us"), 	 halfHight,0,_BkColor(),1,1);
  21616c:	4b26      	ldr	r3, [pc, #152]	; (216208 <SCREEN_Test_Circle+0x69c>)
  21616e:	681a      	ldr	r2, [r3, #0]
  216170:	2000      	movs	r0, #0
  216172:	4610      	mov	r0, r2
  216174:	889b      	ldrh	r3, [r3, #4]
  216176:	2100      	movs	r1, #0
  216178:	f363 010f 	bfi	r1, r3, #0, #16
  21617c:	2300      	movs	r3, #0
  21617e:	2201      	movs	r2, #1
  216180:	f7fc fbfc 	bl	21297c <LCD_Xpos>
  216184:	4603      	mov	r3, r0
  216186:	461e      	mov	r6, r3
  216188:	4b1f      	ldr	r3, [pc, #124]	; (216208 <SCREEN_Test_Circle+0x69c>)
  21618a:	681a      	ldr	r2, [r3, #0]
  21618c:	2000      	movs	r0, #0
  21618e:	4610      	mov	r0, r2
  216190:	889b      	ldrh	r3, [r3, #4]
  216192:	2100      	movs	r1, #0
  216194:	f363 010f 	bfi	r1, r3, #0, #16
  216198:	2308      	movs	r3, #8
  21619a:	2202      	movs	r2, #2
  21619c:	f7fc fbbc 	bl	212918 <LCD_Ypos>
  2161a0:	4603      	mov	r3, r0
  2161a2:	4698      	mov	r8, r3
  2161a4:	4b15      	ldr	r3, [pc, #84]	; (2161fc <SCREEN_Test_Circle+0x690>)
  2161a6:	699b      	ldr	r3, [r3, #24]
  2161a8:	4618      	mov	r0, r3
  2161aa:	2303      	movs	r3, #3
  2161ac:	2206      	movs	r2, #6
  2161ae:	2120      	movs	r1, #32
  2161b0:	f7eb fa88 	bl	2016c4 <Int2Str>
  2161b4:	4602      	mov	r2, r0
  2161b6:	4b1b      	ldr	r3, [pc, #108]	; (216224 <SCREEN_Test_Circle+0x6b8>)
  2161b8:	491b      	ldr	r1, [pc, #108]	; (216228 <SCREEN_Test_Circle+0x6bc>)
  2161ba:	2003      	movs	r0, #3
  2161bc:	f7eb fc76 	bl	201aac <StrAll>
  2161c0:	4604      	mov	r4, r0
  2161c2:	f107 030c 	add.w	r3, r7, #12
  2161c6:	469c      	mov	ip, r3
  2161c8:	f7ff fcb6 	bl	215b38 <_BkColor.12857>
  2161cc:	4602      	mov	r2, r0
  2161ce:	4d0e      	ldr	r5, [pc, #56]	; (216208 <SCREEN_Test_Circle+0x69c>)
  2161d0:	4638      	mov	r0, r7
  2161d2:	2301      	movs	r3, #1
  2161d4:	9305      	str	r3, [sp, #20]
  2161d6:	2301      	movs	r3, #1
  2161d8:	9304      	str	r3, [sp, #16]
  2161da:	9203      	str	r2, [sp, #12]
  2161dc:	2300      	movs	r3, #0
  2161de:	9302      	str	r3, [sp, #8]
  2161e0:	f06f 0301 	mvn.w	r3, #1
  2161e4:	9301      	str	r3, [sp, #4]
  2161e6:	9400      	str	r4, [sp, #0]
  2161e8:	4643      	mov	r3, r8
  2161ea:	4632      	mov	r2, r6
  2161ec:	2101      	movs	r1, #1
  2161ee:	f7f6 f91b 	bl	20c428 <LCD_Str>
  2161f2:	462a      	mov	r2, r5
  2161f4:	463b      	mov	r3, r7
  2161f6:	6819      	ldr	r1, [r3, #0]
  2161f8:	e018      	b.n	21622c <SCREEN_Test_Circle+0x6c0>
  2161fa:	bf00      	nop
  2161fc:	200104e8 	.word	0x200104e8
  216200:	00228e34 	.word	0x00228e34
  216204:	002290bc 	.word	0x002290bc
  216208:	20014a44 	.word	0x20014a44
  21620c:	002290c4 	.word	0x002290c4
  216210:	002290cc 	.word	0x002290cc
  216214:	002290d8 	.word	0x002290d8
  216218:	aaaaaaab 	.word	0xaaaaaaab
  21621c:	00207459 	.word	0x00207459
  216220:	00228e30 	.word	0x00228e30
  216224:	00228e38 	.word	0x00228e38
  216228:	002290e0 	.word	0x002290e0
  21622c:	6011      	str	r1, [r2, #0]
  21622e:	889b      	ldrh	r3, [r3, #4]
  216230:	8093      	strh	r3, [r2, #4]
	lenStr=LCD_Str(fontID_2, LCD_Xpos(lenStr,GetPos,0), LCD_Ypos(lenStr,IncPos,8), StrAll(2,"Bold: ",Int2Str(Circle.bold,' ',2,Sign_none)), halfHight,0,_BkColor(),1,1);
  216232:	4b28      	ldr	r3, [pc, #160]	; (2162d4 <SCREEN_Test_Circle+0x768>)
  216234:	681a      	ldr	r2, [r3, #0]
  216236:	2000      	movs	r0, #0
  216238:	4610      	mov	r0, r2
  21623a:	889b      	ldrh	r3, [r3, #4]
  21623c:	2100      	movs	r1, #0
  21623e:	f363 010f 	bfi	r1, r3, #0, #16
  216242:	2300      	movs	r3, #0
  216244:	2201      	movs	r2, #1
  216246:	f7fc fb99 	bl	21297c <LCD_Xpos>
  21624a:	4603      	mov	r3, r0
  21624c:	461e      	mov	r6, r3
  21624e:	4b21      	ldr	r3, [pc, #132]	; (2162d4 <SCREEN_Test_Circle+0x768>)
  216250:	681a      	ldr	r2, [r3, #0]
  216252:	2000      	movs	r0, #0
  216254:	4610      	mov	r0, r2
  216256:	889b      	ldrh	r3, [r3, #4]
  216258:	2100      	movs	r1, #0
  21625a:	f363 010f 	bfi	r1, r3, #0, #16
  21625e:	2308      	movs	r3, #8
  216260:	2202      	movs	r2, #2
  216262:	f7fc fb59 	bl	212918 <LCD_Ypos>
  216266:	4603      	mov	r3, r0
  216268:	4698      	mov	r8, r3
  21626a:	4b1b      	ldr	r3, [pc, #108]	; (2162d8 <SCREEN_Test_Circle+0x76c>)
  21626c:	7f1b      	ldrb	r3, [r3, #28]
  21626e:	4618      	mov	r0, r3
  216270:	2303      	movs	r3, #3
  216272:	2202      	movs	r2, #2
  216274:	2120      	movs	r1, #32
  216276:	f7eb fa25 	bl	2016c4 <Int2Str>
  21627a:	4603      	mov	r3, r0
  21627c:	461a      	mov	r2, r3
  21627e:	4917      	ldr	r1, [pc, #92]	; (2162dc <SCREEN_Test_Circle+0x770>)
  216280:	2002      	movs	r0, #2
  216282:	f7eb fc13 	bl	201aac <StrAll>
  216286:	4604      	mov	r4, r0
  216288:	f107 030c 	add.w	r3, r7, #12
  21628c:	469c      	mov	ip, r3
  21628e:	f7ff fc53 	bl	215b38 <_BkColor.12857>
  216292:	4602      	mov	r2, r0
  216294:	4d0f      	ldr	r5, [pc, #60]	; (2162d4 <SCREEN_Test_Circle+0x768>)
  216296:	4638      	mov	r0, r7
  216298:	2301      	movs	r3, #1
  21629a:	9305      	str	r3, [sp, #20]
  21629c:	2301      	movs	r3, #1
  21629e:	9304      	str	r3, [sp, #16]
  2162a0:	9203      	str	r2, [sp, #12]
  2162a2:	2300      	movs	r3, #0
  2162a4:	9302      	str	r3, [sp, #8]
  2162a6:	f06f 0301 	mvn.w	r3, #1
  2162aa:	9301      	str	r3, [sp, #4]
  2162ac:	9400      	str	r4, [sp, #0]
  2162ae:	4643      	mov	r3, r8
  2162b0:	4632      	mov	r2, r6
  2162b2:	2101      	movs	r1, #1
  2162b4:	f7f6 f8b8 	bl	20c428 <LCD_Str>
  2162b8:	462a      	mov	r2, r5
  2162ba:	463b      	mov	r3, r7
  2162bc:	6819      	ldr	r1, [r3, #0]
  2162be:	6011      	str	r1, [r2, #0]
  2162c0:	889b      	ldrh	r3, [r3, #4]
  2162c2:	8093      	strh	r3, [r2, #4]


	//	DrawLine(0,130,190,150,200,MYBLUE,LCD_GetXSize(), Circle.ratioBk,Circle.ratioFill, RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]),RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]));
//	DrawLine(0,130,190,150,210,MYBLUE,LCD_GetXSize(), Circle.ratioBk,Circle.ratioFill, RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]),RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]));
//	DrawLine(0,130,190,150,250,MYBLUE,LCD_GetXSize(), Circle.ratioBk,Circle.ratioFill, RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]),RGB2INT(Circle.bk[0],Circle.bk[1],Circle.bk[2]));
	LCD_Show();
  2162c4:	f7ef fa84 	bl	2057d0 <LCD_Show>





}
  2162c8:	bf00      	nop
  2162ca:	3710      	adds	r7, #16
  2162cc:	46bd      	mov	sp, r7
  2162ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2162d2:	bf00      	nop
  2162d4:	20014a44 	.word	0x20014a44
  2162d8:	200104e8 	.word	0x200104e8
  2162dc:	002290e8 	.word	0x002290e8

002162e0 <SCREEN_ReadPanel>:


int SCREEN_number=4;  //LOAD IMAGE !!!!!

void SCREEN_ReadPanel(void)
{
  2162e0:	b590      	push	{r4, r7, lr}
  2162e2:	b083      	sub	sp, #12
  2162e4:	af00      	add	r7, sp, #0
	if(startScreen==0)
  2162e6:	4bd2      	ldr	r3, [pc, #840]	; (216630 <SCREEN_ReadPanel+0x350>)
  2162e8:	681b      	ldr	r3, [r3, #0]
  2162ea:	2b00      	cmp	r3, #0
  2162ec:	d136      	bne.n	21635c <SCREEN_ReadPanel+0x7c>
	{
		switch(SCREEN_number)
  2162ee:	4bd1      	ldr	r3, [pc, #836]	; (216634 <SCREEN_ReadPanel+0x354>)
  2162f0:	681b      	ldr	r3, [r3, #0]
  2162f2:	2b04      	cmp	r3, #4
  2162f4:	f201 8090 	bhi.w	217418 <SCREEN_ReadPanel+0x1138>
  2162f8:	a201      	add	r2, pc, #4	; (adr r2, 216300 <SCREEN_ReadPanel+0x20>)
  2162fa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  2162fe:	bf00      	nop
  216300:	00216315 	.word	0x00216315
  216304:	00216323 	.word	0x00216323
  216308:	00216331 	.word	0x00216331
  21630c:	0021633f 	.word	0x0021633f
  216310:	0021634d 	.word	0x0021634d
		{
		case 0:
			NOWY_0();
  216314:	f7fd fc76 	bl	213c04 <NOWY_0>
			startScreen=1;
  216318:	4bc5      	ldr	r3, [pc, #788]	; (216630 <SCREEN_ReadPanel+0x350>)
  21631a:	2201      	movs	r2, #1
  21631c:	601a      	str	r2, [r3, #0]
			break;
  21631e:	f001 b87b 	b.w	217418 <SCREEN_ReadPanel+0x1138>
		case 1:
			NOWY_1();
  216322:	f7fd ffcd 	bl	2142c0 <NOWY_1>
			startScreen=1;
  216326:	4bc2      	ldr	r3, [pc, #776]	; (216630 <SCREEN_ReadPanel+0x350>)
  216328:	2201      	movs	r2, #1
  21632a:	601a      	str	r2, [r3, #0]
			break;
  21632c:	f001 b874 	b.w	217418 <SCREEN_ReadPanel+0x1138>
		case 2:
			NOWY_2();
  216330:	f7fe fd68 	bl	214e04 <NOWY_2>
			startScreen=1;
  216334:	4bbe      	ldr	r3, [pc, #760]	; (216630 <SCREEN_ReadPanel+0x350>)
  216336:	2201      	movs	r2, #1
  216338:	601a      	str	r2, [r3, #0]
			break;
  21633a:	f001 b86d 	b.w	217418 <SCREEN_ReadPanel+0x1138>
		case 3:
			NOWY_3();
  21633e:	f7ff fa03 	bl	215748 <NOWY_3>
			startScreen=1;
  216342:	4bbb      	ldr	r3, [pc, #748]	; (216630 <SCREEN_ReadPanel+0x350>)
  216344:	2201      	movs	r2, #1
  216346:	601a      	str	r2, [r3, #0]
			break;
  216348:	f001 b866 	b.w	217418 <SCREEN_ReadPanel+0x1138>
		case 4:
			SCREEN_Test_Circle();
  21634c:	f7ff fc0e 	bl	215b6c <SCREEN_Test_Circle>
			startScreen=1;
  216350:	4bb7      	ldr	r3, [pc, #732]	; (216630 <SCREEN_ReadPanel+0x350>)
  216352:	2201      	movs	r2, #1
  216354:	601a      	str	r2, [r3, #0]
			break;
  216356:	bf00      	nop
  216358:	f001 b85e 	b.w	217418 <SCREEN_ReadPanel+0x1138>
		}
	}
	else
	{
		switch(SCREEN_number)
  21635c:	4bb5      	ldr	r3, [pc, #724]	; (216634 <SCREEN_ReadPanel+0x354>)
  21635e:	681b      	ldr	r3, [r3, #0]
  216360:	2b04      	cmp	r3, #4
  216362:	f201 8059 	bhi.w	217418 <SCREEN_ReadPanel+0x1138>
  216366:	a201      	add	r2, pc, #4	; (adr r2, 21636c <SCREEN_ReadPanel+0x8c>)
  216368:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  21636c:	00216381 	.word	0x00216381
  216370:	00217419 	.word	0x00217419
  216374:	002166ff 	.word	0x002166ff
  216378:	00216a29 	.word	0x00216a29
  21637c:	00216b37 	.word	0x00216b37
		{
		case 0:
				 if(DEBUG_RcvStr("1")) ChangeValRGB('f','R',1);
  216380:	48ad      	ldr	r0, [pc, #692]	; (216638 <SCREEN_ReadPanel+0x358>)
  216382:	f7ea fb0d 	bl	2009a0 <DEBUG_RcvStr>
  216386:	4603      	mov	r3, r0
  216388:	2b00      	cmp	r3, #0
  21638a:	d006      	beq.n	21639a <SCREEN_ReadPanel+0xba>
  21638c:	2201      	movs	r2, #1
  21638e:	2152      	movs	r1, #82	; 0x52
  216390:	2066      	movs	r0, #102	; 0x66
  216392:	f7fc febb 	bl	21310c <ChangeValRGB>



			else if(DEBUG_RcvStr("h")) LCD_StrChangeColorRotVarIndirect(STR_ID_test,"10");
			else if(DEBUG_RcvStr("j")) LCD_StrChangeColorRotVarIndirect(STR_ID_test,"90");
			break;
  216396:	f001 b838 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("q")) ChangeValRGB('f','R',-1);
  21639a:	48a8      	ldr	r0, [pc, #672]	; (21663c <SCREEN_ReadPanel+0x35c>)
  21639c:	f7ea fb00 	bl	2009a0 <DEBUG_RcvStr>
  2163a0:	4603      	mov	r3, r0
  2163a2:	2b00      	cmp	r3, #0
  2163a4:	d007      	beq.n	2163b6 <SCREEN_ReadPanel+0xd6>
  2163a6:	f04f 32ff 	mov.w	r2, #4294967295
  2163aa:	2152      	movs	r1, #82	; 0x52
  2163ac:	2066      	movs	r0, #102	; 0x66
  2163ae:	f7fc fead 	bl	21310c <ChangeValRGB>
			break;
  2163b2:	f001 b82a 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("2")) ChangeValRGB('f','G',1);
  2163b6:	48a2      	ldr	r0, [pc, #648]	; (216640 <SCREEN_ReadPanel+0x360>)
  2163b8:	f7ea faf2 	bl	2009a0 <DEBUG_RcvStr>
  2163bc:	4603      	mov	r3, r0
  2163be:	2b00      	cmp	r3, #0
  2163c0:	d006      	beq.n	2163d0 <SCREEN_ReadPanel+0xf0>
  2163c2:	2201      	movs	r2, #1
  2163c4:	2147      	movs	r1, #71	; 0x47
  2163c6:	2066      	movs	r0, #102	; 0x66
  2163c8:	f7fc fea0 	bl	21310c <ChangeValRGB>
			break;
  2163cc:	f001 b81d 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("w")) ChangeValRGB('f','G',-1);
  2163d0:	489c      	ldr	r0, [pc, #624]	; (216644 <SCREEN_ReadPanel+0x364>)
  2163d2:	f7ea fae5 	bl	2009a0 <DEBUG_RcvStr>
  2163d6:	4603      	mov	r3, r0
  2163d8:	2b00      	cmp	r3, #0
  2163da:	d007      	beq.n	2163ec <SCREEN_ReadPanel+0x10c>
  2163dc:	f04f 32ff 	mov.w	r2, #4294967295
  2163e0:	2147      	movs	r1, #71	; 0x47
  2163e2:	2066      	movs	r0, #102	; 0x66
  2163e4:	f7fc fe92 	bl	21310c <ChangeValRGB>
			break;
  2163e8:	f001 b80f 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("3")) ChangeValRGB('f','B',1);
  2163ec:	4896      	ldr	r0, [pc, #600]	; (216648 <SCREEN_ReadPanel+0x368>)
  2163ee:	f7ea fad7 	bl	2009a0 <DEBUG_RcvStr>
  2163f2:	4603      	mov	r3, r0
  2163f4:	2b00      	cmp	r3, #0
  2163f6:	d006      	beq.n	216406 <SCREEN_ReadPanel+0x126>
  2163f8:	2201      	movs	r2, #1
  2163fa:	2142      	movs	r1, #66	; 0x42
  2163fc:	2066      	movs	r0, #102	; 0x66
  2163fe:	f7fc fe85 	bl	21310c <ChangeValRGB>
			break;
  216402:	f001 b802 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("e")) ChangeValRGB('f','B',-1);
  216406:	4891      	ldr	r0, [pc, #580]	; (21664c <SCREEN_ReadPanel+0x36c>)
  216408:	f7ea faca 	bl	2009a0 <DEBUG_RcvStr>
  21640c:	4603      	mov	r3, r0
  21640e:	2b00      	cmp	r3, #0
  216410:	d007      	beq.n	216422 <SCREEN_ReadPanel+0x142>
  216412:	f04f 32ff 	mov.w	r2, #4294967295
  216416:	2142      	movs	r1, #66	; 0x42
  216418:	2066      	movs	r0, #102	; 0x66
  21641a:	f7fc fe77 	bl	21310c <ChangeValRGB>
			break;
  21641e:	f000 bff4 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("a")) ChangeValRGB('b','R',1);
  216422:	488b      	ldr	r0, [pc, #556]	; (216650 <SCREEN_ReadPanel+0x370>)
  216424:	f7ea fabc 	bl	2009a0 <DEBUG_RcvStr>
  216428:	4603      	mov	r3, r0
  21642a:	2b00      	cmp	r3, #0
  21642c:	d006      	beq.n	21643c <SCREEN_ReadPanel+0x15c>
  21642e:	2201      	movs	r2, #1
  216430:	2152      	movs	r1, #82	; 0x52
  216432:	2062      	movs	r0, #98	; 0x62
  216434:	f7fc fe6a 	bl	21310c <ChangeValRGB>
			break;
  216438:	f000 bfe7 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("z")) ChangeValRGB('b','R',-1);
  21643c:	4885      	ldr	r0, [pc, #532]	; (216654 <SCREEN_ReadPanel+0x374>)
  21643e:	f7ea faaf 	bl	2009a0 <DEBUG_RcvStr>
  216442:	4603      	mov	r3, r0
  216444:	2b00      	cmp	r3, #0
  216446:	d007      	beq.n	216458 <SCREEN_ReadPanel+0x178>
  216448:	f04f 32ff 	mov.w	r2, #4294967295
  21644c:	2152      	movs	r1, #82	; 0x52
  21644e:	2062      	movs	r0, #98	; 0x62
  216450:	f7fc fe5c 	bl	21310c <ChangeValRGB>
			break;
  216454:	f000 bfd9 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("s")) ChangeValRGB('b','G',1);
  216458:	487f      	ldr	r0, [pc, #508]	; (216658 <SCREEN_ReadPanel+0x378>)
  21645a:	f7ea faa1 	bl	2009a0 <DEBUG_RcvStr>
  21645e:	4603      	mov	r3, r0
  216460:	2b00      	cmp	r3, #0
  216462:	d006      	beq.n	216472 <SCREEN_ReadPanel+0x192>
  216464:	2201      	movs	r2, #1
  216466:	2147      	movs	r1, #71	; 0x47
  216468:	2062      	movs	r0, #98	; 0x62
  21646a:	f7fc fe4f 	bl	21310c <ChangeValRGB>
			break;
  21646e:	f000 bfcc 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("x")) ChangeValRGB('b','G',-1);
  216472:	487a      	ldr	r0, [pc, #488]	; (21665c <SCREEN_ReadPanel+0x37c>)
  216474:	f7ea fa94 	bl	2009a0 <DEBUG_RcvStr>
  216478:	4603      	mov	r3, r0
  21647a:	2b00      	cmp	r3, #0
  21647c:	d007      	beq.n	21648e <SCREEN_ReadPanel+0x1ae>
  21647e:	f04f 32ff 	mov.w	r2, #4294967295
  216482:	2147      	movs	r1, #71	; 0x47
  216484:	2062      	movs	r0, #98	; 0x62
  216486:	f7fc fe41 	bl	21310c <ChangeValRGB>
			break;
  21648a:	f000 bfbe 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("d")) ChangeValRGB('b','B',1);
  21648e:	4874      	ldr	r0, [pc, #464]	; (216660 <SCREEN_ReadPanel+0x380>)
  216490:	f7ea fa86 	bl	2009a0 <DEBUG_RcvStr>
  216494:	4603      	mov	r3, r0
  216496:	2b00      	cmp	r3, #0
  216498:	d006      	beq.n	2164a8 <SCREEN_ReadPanel+0x1c8>
  21649a:	2201      	movs	r2, #1
  21649c:	2142      	movs	r1, #66	; 0x42
  21649e:	2062      	movs	r0, #98	; 0x62
  2164a0:	f7fc fe34 	bl	21310c <ChangeValRGB>
			break;
  2164a4:	f000 bfb1 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("c")) ChangeValRGB('b','B',-1);
  2164a8:	486e      	ldr	r0, [pc, #440]	; (216664 <SCREEN_ReadPanel+0x384>)
  2164aa:	f7ea fa79 	bl	2009a0 <DEBUG_RcvStr>
  2164ae:	4603      	mov	r3, r0
  2164b0:	2b00      	cmp	r3, #0
  2164b2:	d007      	beq.n	2164c4 <SCREEN_ReadPanel+0x1e4>
  2164b4:	f04f 32ff 	mov.w	r2, #4294967295
  2164b8:	2142      	movs	r1, #66	; 0x42
  2164ba:	2062      	movs	r0, #98	; 0x62
  2164bc:	f7fc fe26 	bl	21310c <ChangeValRGB>
			break;
  2164c0:	f000 bfa3 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("f")) IncCoeffRGB();
  2164c4:	4868      	ldr	r0, [pc, #416]	; (216668 <SCREEN_ReadPanel+0x388>)
  2164c6:	f7ea fa6b 	bl	2009a0 <DEBUG_RcvStr>
  2164ca:	4603      	mov	r3, r0
  2164cc:	2b00      	cmp	r3, #0
  2164ce:	d003      	beq.n	2164d8 <SCREEN_ReadPanel+0x1f8>
  2164d0:	f7fc fe92 	bl	2131f8 <IncCoeffRGB>
			break;
  2164d4:	f000 bf99 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("v")) DecCoeefRGB();
  2164d8:	4864      	ldr	r0, [pc, #400]	; (21666c <SCREEN_ReadPanel+0x38c>)
  2164da:	f7ea fa61 	bl	2009a0 <DEBUG_RcvStr>
  2164de:	4603      	mov	r3, r0
  2164e0:	2b00      	cmp	r3, #0
  2164e2:	d003      	beq.n	2164ec <SCREEN_ReadPanel+0x20c>
  2164e4:	f7fc feba 	bl	21325c <DecCoeefRGB>
			break;
  2164e8:	f000 bf8f 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("g")) IncFontSize();
  2164ec:	4860      	ldr	r0, [pc, #384]	; (216670 <SCREEN_ReadPanel+0x390>)
  2164ee:	f7ea fa57 	bl	2009a0 <DEBUG_RcvStr>
  2164f2:	4603      	mov	r3, r0
  2164f4:	2b00      	cmp	r3, #0
  2164f6:	d003      	beq.n	216500 <SCREEN_ReadPanel+0x220>
  2164f8:	f7fd f928 	bl	21374c <IncFontSize>
			break;
  2164fc:	f000 bf85 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("b")) DecFontSize();
  216500:	485c      	ldr	r0, [pc, #368]	; (216674 <SCREEN_ReadPanel+0x394>)
  216502:	f7ea fa4d 	bl	2009a0 <DEBUG_RcvStr>
  216506:	4603      	mov	r3, r0
  216508:	2b00      	cmp	r3, #0
  21650a:	d003      	beq.n	216514 <SCREEN_ReadPanel+0x234>
  21650c:	f7fd f9a0 	bl	213850 <DecFontSize>
			break;
  216510:	f000 bf7b 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr(" ")) ChangeFontStyle();
  216514:	4858      	ldr	r0, [pc, #352]	; (216678 <SCREEN_ReadPanel+0x398>)
  216516:	f7ea fa43 	bl	2009a0 <DEBUG_RcvStr>
  21651a:	4603      	mov	r3, r0
  21651c:	2b00      	cmp	r3, #0
  21651e:	d003      	beq.n	216528 <SCREEN_ReadPanel+0x248>
  216520:	f7fc ffec 	bl	2134fc <ChangeFontStyle>
			break;
  216524:	f000 bf71 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("`")) ReplaceLcdStrType();
  216528:	4854      	ldr	r0, [pc, #336]	; (21667c <SCREEN_ReadPanel+0x39c>)
  21652a:	f7ea fa39 	bl	2009a0 <DEBUG_RcvStr>
  21652e:	4603      	mov	r3, r0
  216530:	2b00      	cmp	r3, #0
  216532:	d003      	beq.n	21653c <SCREEN_ReadPanel+0x25c>
  216534:	f7fd fa52 	bl	2139dc <ReplaceLcdStrType>
			break;
  216538:	f000 bf67 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("r")) ChangeFontBoldItalNorm();
  21653c:	4850      	ldr	r0, [pc, #320]	; (216680 <SCREEN_ReadPanel+0x3a0>)
  21653e:	f7ea fa2f 	bl	2009a0 <DEBUG_RcvStr>
  216542:	4603      	mov	r3, r0
  216544:	2b00      	cmp	r3, #0
  216546:	d003      	beq.n	216550 <SCREEN_ReadPanel+0x270>
  216548:	f7fd f9fc 	bl	213944 <ChangeFontBoldItalNorm>
			break;
  21654c:	f000 bf5d 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("t")) Dec_offsWin();
  216550:	484c      	ldr	r0, [pc, #304]	; (216684 <SCREEN_ReadPanel+0x3a4>)
  216552:	f7ea fa25 	bl	2009a0 <DEBUG_RcvStr>
  216556:	4603      	mov	r3, r0
  216558:	2b00      	cmp	r3, #0
  21655a:	d003      	beq.n	216564 <SCREEN_ReadPanel+0x284>
  21655c:	f7fd f8c4 	bl	2136e8 <Dec_offsWin>
			break;
  216560:	f000 bf53 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("y")) Inc_offsWin();
  216564:	4848      	ldr	r0, [pc, #288]	; (216688 <SCREEN_ReadPanel+0x3a8>)
  216566:	f7ea fa1b 	bl	2009a0 <DEBUG_RcvStr>
  21656a:	4603      	mov	r3, r0
  21656c:	2b00      	cmp	r3, #0
  21656e:	d003      	beq.n	216578 <SCREEN_ReadPanel+0x298>
  216570:	f7fd f87e 	bl	213670 <Inc_offsWin>
			break;
  216574:	f000 bf49 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("u")) Dec_lenWin();
  216578:	4844      	ldr	r0, [pc, #272]	; (21668c <SCREEN_ReadPanel+0x3ac>)
  21657a:	f7ea fa11 	bl	2009a0 <DEBUG_RcvStr>
  21657e:	4603      	mov	r3, r0
  216580:	2b00      	cmp	r3, #0
  216582:	d003      	beq.n	21658c <SCREEN_ReadPanel+0x2ac>
  216584:	f7fd f846 	bl	213614 <Dec_lenWin>
			break;
  216588:	f000 bf3f 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("i")) Inc_lenWin();
  21658c:	4840      	ldr	r0, [pc, #256]	; (216690 <SCREEN_ReadPanel+0x3b0>)
  21658e:	f7ea fa07 	bl	2009a0 <DEBUG_RcvStr>
  216592:	4603      	mov	r3, r0
  216594:	2b00      	cmp	r3, #0
  216596:	d003      	beq.n	2165a0 <SCREEN_ReadPanel+0x2c0>
  216598:	f7fc fff4 	bl	213584 <Inc_lenWin>
			break;
  21659c:	f000 bf35 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("0")) DisplayFontsWithChangeColorOrNot();
  2165a0:	483c      	ldr	r0, [pc, #240]	; (216694 <SCREEN_ReadPanel+0x3b4>)
  2165a2:	f7ea f9fd 	bl	2009a0 <DEBUG_RcvStr>
  2165a6:	4603      	mov	r3, r0
  2165a8:	2b00      	cmp	r3, #0
  2165aa:	d003      	beq.n	2165b4 <SCREEN_ReadPanel+0x2d4>
  2165ac:	f7fd fb0e 	bl	213bcc <DisplayFontsWithChangeColorOrNot>
			break;
  2165b0:	f000 bf2b 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("]")) Inc_PosCursor();
  2165b4:	4838      	ldr	r0, [pc, #224]	; (216698 <SCREEN_ReadPanel+0x3b8>)
  2165b6:	f7ea f9f3 	bl	2009a0 <DEBUG_RcvStr>
  2165ba:	4603      	mov	r3, r0
  2165bc:	2b00      	cmp	r3, #0
  2165be:	d003      	beq.n	2165c8 <SCREEN_ReadPanel+0x2e8>
  2165c0:	f7fd fa5e 	bl	213a80 <Inc_PosCursor>
			break;
  2165c4:	f000 bf21 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("[")) Dec_PosCursor();
  2165c8:	4834      	ldr	r0, [pc, #208]	; (21669c <SCREEN_ReadPanel+0x3bc>)
  2165ca:	f7ea f9e9 	bl	2009a0 <DEBUG_RcvStr>
  2165ce:	4603      	mov	r3, r0
  2165d0:	2b00      	cmp	r3, #0
  2165d2:	d003      	beq.n	2165dc <SCREEN_ReadPanel+0x2fc>
  2165d4:	f7fd fa70 	bl	213ab8 <Dec_PosCursor>
			break;
  2165d8:	f000 bf17 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("'")) IncDec_SpaceBetweenFont(0);
  2165dc:	4830      	ldr	r0, [pc, #192]	; (2166a0 <SCREEN_ReadPanel+0x3c0>)
  2165de:	f7ea f9df 	bl	2009a0 <DEBUG_RcvStr>
  2165e2:	4603      	mov	r3, r0
  2165e4:	2b00      	cmp	r3, #0
  2165e6:	d004      	beq.n	2165f2 <SCREEN_ReadPanel+0x312>
  2165e8:	2000      	movs	r0, #0
  2165ea:	f7fd fa7d 	bl	213ae8 <IncDec_SpaceBetweenFont>
			break;
  2165ee:	f000 bf0c 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("\\")) IncDec_SpaceBetweenFont(1);
  2165f2:	482c      	ldr	r0, [pc, #176]	; (2166a4 <SCREEN_ReadPanel+0x3c4>)
  2165f4:	f7ea f9d4 	bl	2009a0 <DEBUG_RcvStr>
  2165f8:	4603      	mov	r3, r0
  2165fa:	2b00      	cmp	r3, #0
  2165fc:	d004      	beq.n	216608 <SCREEN_ReadPanel+0x328>
  2165fe:	2001      	movs	r0, #1
  216600:	f7fd fa72 	bl	213ae8 <IncDec_SpaceBetweenFont>
			break;
  216604:	f000 bf01 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("/")) LCD_DisplayRemeberedSpacesBetweenFonts();
  216608:	4827      	ldr	r0, [pc, #156]	; (2166a8 <SCREEN_ReadPanel+0x3c8>)
  21660a:	f7ea f9c9 	bl	2009a0 <DEBUG_RcvStr>
  21660e:	4603      	mov	r3, r0
  216610:	2b00      	cmp	r3, #0
  216612:	d003      	beq.n	21661c <SCREEN_ReadPanel+0x33c>
  216614:	f7fc f8de 	bl	2127d4 <LCD_DisplayRemeberedSpacesBetweenFonts>
			break;
  216618:	f000 bef7 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("o")) LCD_WriteSpacesBetweenFontsOnSDcard();
  21661c:	4823      	ldr	r0, [pc, #140]	; (2166ac <SCREEN_ReadPanel+0x3cc>)
  21661e:	f7ea f9bf 	bl	2009a0 <DEBUG_RcvStr>
  216622:	4603      	mov	r3, r0
  216624:	2b00      	cmp	r3, #0
  216626:	d043      	beq.n	2166b0 <SCREEN_ReadPanel+0x3d0>
  216628:	f7fc f940 	bl	2128ac <LCD_WriteSpacesBetweenFontsOnSDcard>
			break;
  21662c:	f000 beed 	b.w	21740a <SCREEN_ReadPanel+0x112a>
  216630:	200104cc 	.word	0x200104cc
  216634:	20000000 	.word	0x20000000
  216638:	002290f0 	.word	0x002290f0
  21663c:	002290f4 	.word	0x002290f4
  216640:	002290f8 	.word	0x002290f8
  216644:	002290fc 	.word	0x002290fc
  216648:	00229100 	.word	0x00229100
  21664c:	00229104 	.word	0x00229104
  216650:	00229108 	.word	0x00229108
  216654:	0022910c 	.word	0x0022910c
  216658:	00229110 	.word	0x00229110
  21665c:	00229114 	.word	0x00229114
  216660:	00229118 	.word	0x00229118
  216664:	00228e40 	.word	0x00228e40
  216668:	0022911c 	.word	0x0022911c
  21666c:	00229120 	.word	0x00229120
  216670:	00229124 	.word	0x00229124
  216674:	00229128 	.word	0x00229128
  216678:	00228e34 	.word	0x00228e34
  21667c:	0022912c 	.word	0x0022912c
  216680:	00229130 	.word	0x00229130
  216684:	00229134 	.word	0x00229134
  216688:	00229138 	.word	0x00229138
  21668c:	0022913c 	.word	0x0022913c
  216690:	00229140 	.word	0x00229140
  216694:	00229144 	.word	0x00229144
  216698:	00229148 	.word	0x00229148
  21669c:	0022914c 	.word	0x0022914c
  2166a0:	00229150 	.word	0x00229150
  2166a4:	00229154 	.word	0x00229154
  2166a8:	00229158 	.word	0x00229158
  2166ac:	0022915c 	.word	0x0022915c
			else if(DEBUG_RcvStr("m")) LCD_ResetSpacesBetweenFonts();
  2166b0:	48c7      	ldr	r0, [pc, #796]	; (2169d0 <SCREEN_ReadPanel+0x6f0>)
  2166b2:	f7ea f975 	bl	2009a0 <DEBUG_RcvStr>
  2166b6:	4603      	mov	r3, r0
  2166b8:	2b00      	cmp	r3, #0
  2166ba:	d003      	beq.n	2166c4 <SCREEN_ReadPanel+0x3e4>
  2166bc:	f7fc f918 	bl	2128f0 <LCD_ResetSpacesBetweenFonts>
			break;
  2166c0:	f000 bea3 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("h")) LCD_StrChangeColorRotVarIndirect(STR_ID_test,"10");
  2166c4:	48c3      	ldr	r0, [pc, #780]	; (2169d4 <SCREEN_ReadPanel+0x6f4>)
  2166c6:	f7ea f96b 	bl	2009a0 <DEBUG_RcvStr>
  2166ca:	4603      	mov	r3, r0
  2166cc:	2b00      	cmp	r3, #0
  2166ce:	d007      	beq.n	2166e0 <SCREEN_ReadPanel+0x400>
  2166d0:	463b      	mov	r3, r7
  2166d2:	4ac1      	ldr	r2, [pc, #772]	; (2169d8 <SCREEN_ReadPanel+0x6f8>)
  2166d4:	2113      	movs	r1, #19
  2166d6:	4618      	mov	r0, r3
  2166d8:	f7f7 fa78 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  2166dc:	f000 be95 	b.w	21740a <SCREEN_ReadPanel+0x112a>
			else if(DEBUG_RcvStr("j")) LCD_StrChangeColorRotVarIndirect(STR_ID_test,"90");
  2166e0:	48be      	ldr	r0, [pc, #760]	; (2169dc <SCREEN_ReadPanel+0x6fc>)
  2166e2:	f7ea f95d 	bl	2009a0 <DEBUG_RcvStr>
  2166e6:	4603      	mov	r3, r0
  2166e8:	2b00      	cmp	r3, #0
  2166ea:	f000 868e 	beq.w	21740a <SCREEN_ReadPanel+0x112a>
  2166ee:	463b      	mov	r3, r7
  2166f0:	4abb      	ldr	r2, [pc, #748]	; (2169e0 <SCREEN_ReadPanel+0x700>)
  2166f2:	2113      	movs	r1, #19
  2166f4:	4618      	mov	r0, r3
  2166f6:	f7f7 fa69 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  2166fa:	f000 be86 	b.w	21740a <SCREEN_ReadPanel+0x112a>

		case 1:
			break;

		case 2:
			if(LCD_IsRefreshScreenTimeout(refresh_1,500)) LCD_StrRotVarIndirect				(fontVar_1,INT2STR(++test[0]));
  2166fe:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  216702:	2000      	movs	r0, #0
  216704:	f7f0 ff60 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216708:	4603      	mov	r3, r0
  21670a:	2b00      	cmp	r3, #0
  21670c:	d011      	beq.n	216732 <SCREEN_ReadPanel+0x452>
  21670e:	4bb5      	ldr	r3, [pc, #724]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  216710:	681b      	ldr	r3, [r3, #0]
  216712:	3301      	adds	r3, #1
  216714:	4ab3      	ldr	r2, [pc, #716]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  216716:	6013      	str	r3, [r2, #0]
  216718:	4bb2      	ldr	r3, [pc, #712]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  21671a:	6818      	ldr	r0, [r3, #0]
  21671c:	2303      	movs	r3, #3
  21671e:	2203      	movs	r2, #3
  216720:	2130      	movs	r1, #48	; 0x30
  216722:	f7ea ffcf 	bl	2016c4 <Int2Str>
  216726:	4602      	mov	r2, r0
  216728:	463b      	mov	r3, r7
  21672a:	2100      	movs	r1, #0
  21672c:	4618      	mov	r0, r3
  21672e:	f7f7 f8ef 	bl	20d910 <LCD_StrRotVarIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_2,500)) LCD_StrChangeColorRotVarIndirect(fontVar_2,INT2STR(++test[1]));
  216732:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  216736:	2001      	movs	r0, #1
  216738:	f7f0 ff46 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  21673c:	4603      	mov	r3, r0
  21673e:	2b00      	cmp	r3, #0
  216740:	d011      	beq.n	216766 <SCREEN_ReadPanel+0x486>
  216742:	4ba8      	ldr	r3, [pc, #672]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  216744:	685b      	ldr	r3, [r3, #4]
  216746:	3301      	adds	r3, #1
  216748:	4aa6      	ldr	r2, [pc, #664]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  21674a:	6053      	str	r3, [r2, #4]
  21674c:	4ba5      	ldr	r3, [pc, #660]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  21674e:	6858      	ldr	r0, [r3, #4]
  216750:	2303      	movs	r3, #3
  216752:	2203      	movs	r2, #3
  216754:	2130      	movs	r1, #48	; 0x30
  216756:	f7ea ffb5 	bl	2016c4 <Int2Str>
  21675a:	4602      	mov	r2, r0
  21675c:	463b      	mov	r3, r7
  21675e:	2101      	movs	r1, #1
  216760:	4618      	mov	r0, r3
  216762:	f7f7 fa33 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>

			if(LCD_IsRefreshScreenTimeout(refresh_3,500)) LCD_StrRotVarIndirect				(fontVar_3,INT2STR(++test[2]));
  216766:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  21676a:	2002      	movs	r0, #2
  21676c:	f7f0 ff2c 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216770:	4603      	mov	r3, r0
  216772:	2b00      	cmp	r3, #0
  216774:	d011      	beq.n	21679a <SCREEN_ReadPanel+0x4ba>
  216776:	4b9b      	ldr	r3, [pc, #620]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  216778:	689b      	ldr	r3, [r3, #8]
  21677a:	3301      	adds	r3, #1
  21677c:	4a99      	ldr	r2, [pc, #612]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  21677e:	6093      	str	r3, [r2, #8]
  216780:	4b98      	ldr	r3, [pc, #608]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  216782:	6898      	ldr	r0, [r3, #8]
  216784:	2303      	movs	r3, #3
  216786:	2203      	movs	r2, #3
  216788:	2130      	movs	r1, #48	; 0x30
  21678a:	f7ea ff9b 	bl	2016c4 <Int2Str>
  21678e:	4602      	mov	r2, r0
  216790:	463b      	mov	r3, r7
  216792:	2102      	movs	r1, #2
  216794:	4618      	mov	r0, r3
  216796:	f7f7 f8bb 	bl	20d910 <LCD_StrRotVarIndirect>
		   if(LCD_IsRefreshScreenTimeout(refresh_4,500)) LCD_StrChangeColorRotVarIndirect(fontVar_4,INT2STR(++test[3]));
  21679a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  21679e:	2003      	movs	r0, #3
  2167a0:	f7f0 ff12 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  2167a4:	4603      	mov	r3, r0
  2167a6:	2b00      	cmp	r3, #0
  2167a8:	d011      	beq.n	2167ce <SCREEN_ReadPanel+0x4ee>
  2167aa:	4b8e      	ldr	r3, [pc, #568]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  2167ac:	68db      	ldr	r3, [r3, #12]
  2167ae:	3301      	adds	r3, #1
  2167b0:	4a8c      	ldr	r2, [pc, #560]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  2167b2:	60d3      	str	r3, [r2, #12]
  2167b4:	4b8b      	ldr	r3, [pc, #556]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  2167b6:	68d8      	ldr	r0, [r3, #12]
  2167b8:	2303      	movs	r3, #3
  2167ba:	2203      	movs	r2, #3
  2167bc:	2130      	movs	r1, #48	; 0x30
  2167be:	f7ea ff81 	bl	2016c4 <Int2Str>
  2167c2:	4602      	mov	r2, r0
  2167c4:	463b      	mov	r3, r7
  2167c6:	2103      	movs	r1, #3
  2167c8:	4618      	mov	r0, r3
  2167ca:	f7f7 f9ff 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>

			if(LCD_IsRefreshScreenTimeout(refresh_5,500)) LCD_StrRotVarIndirect				(fontVar_5,INT2STR(++test[4]));
  2167ce:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  2167d2:	2004      	movs	r0, #4
  2167d4:	f7f0 fef8 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  2167d8:	4603      	mov	r3, r0
  2167da:	2b00      	cmp	r3, #0
  2167dc:	d011      	beq.n	216802 <SCREEN_ReadPanel+0x522>
  2167de:	4b81      	ldr	r3, [pc, #516]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  2167e0:	691b      	ldr	r3, [r3, #16]
  2167e2:	3301      	adds	r3, #1
  2167e4:	4a7f      	ldr	r2, [pc, #508]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  2167e6:	6113      	str	r3, [r2, #16]
  2167e8:	4b7e      	ldr	r3, [pc, #504]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  2167ea:	6918      	ldr	r0, [r3, #16]
  2167ec:	2303      	movs	r3, #3
  2167ee:	2203      	movs	r2, #3
  2167f0:	2130      	movs	r1, #48	; 0x30
  2167f2:	f7ea ff67 	bl	2016c4 <Int2Str>
  2167f6:	4602      	mov	r2, r0
  2167f8:	463b      	mov	r3, r7
  2167fa:	2104      	movs	r1, #4
  2167fc:	4618      	mov	r0, r3
  2167fe:	f7f7 f887 	bl	20d910 <LCD_StrRotVarIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_6,500)) LCD_StrChangeColorRotVarIndirect(fontVar_6,INT2STR(++test[5]));
  216802:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
  216806:	2005      	movs	r0, #5
  216808:	f7f0 fede 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  21680c:	4603      	mov	r3, r0
  21680e:	2b00      	cmp	r3, #0
  216810:	d011      	beq.n	216836 <SCREEN_ReadPanel+0x556>
  216812:	4b74      	ldr	r3, [pc, #464]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  216814:	695b      	ldr	r3, [r3, #20]
  216816:	3301      	adds	r3, #1
  216818:	4a72      	ldr	r2, [pc, #456]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  21681a:	6153      	str	r3, [r2, #20]
  21681c:	4b71      	ldr	r3, [pc, #452]	; (2169e4 <SCREEN_ReadPanel+0x704>)
  21681e:	6958      	ldr	r0, [r3, #20]
  216820:	2303      	movs	r3, #3
  216822:	2203      	movs	r2, #3
  216824:	2130      	movs	r1, #48	; 0x30
  216826:	f7ea ff4d 	bl	2016c4 <Int2Str>
  21682a:	4602      	mov	r2, r0
  21682c:	463b      	mov	r3, r7
  21682e:	2105      	movs	r1, #5
  216830:	4618      	mov	r0, r3
  216832:	f7f7 f9cb 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>

			     if(DEBUG_RcvStr("1")) LCD_StrRotVarIndirect(fontVar_7,"abAb");
  216836:	486c      	ldr	r0, [pc, #432]	; (2169e8 <SCREEN_ReadPanel+0x708>)
  216838:	f7ea f8b2 	bl	2009a0 <DEBUG_RcvStr>
  21683c:	4603      	mov	r3, r0
  21683e:	2b00      	cmp	r3, #0
  216840:	d007      	beq.n	216852 <SCREEN_ReadPanel+0x572>
  216842:	463b      	mov	r3, r7
  216844:	4a69      	ldr	r2, [pc, #420]	; (2169ec <SCREEN_ReadPanel+0x70c>)
  216846:	2106      	movs	r1, #6
  216848:	4618      	mov	r0, r3
  21684a:	f7f7 f861 	bl	20d910 <LCD_StrRotVarIndirect>
			else if(DEBUG_RcvStr("b")) LCD_StrChangeColorRotVarIndirect(fontVar_8,"Rafa Markielwski hhhhX");
			else if(DEBUG_RcvStr("c")){ LCD_OffsStrVar_x(fontVar_8,10);  LCD_StrChangeColorRotVarIndirect(fontVar_8,"XY");  }
			else if(DEBUG_RcvStr("d")){ LCD_OffsStrVar_x(fontVar_8,-10); LCD_StrChangeColorRotVarIndirect(fontVar_8,"XY");  }
			else if(DEBUG_RcvStr("e")){ LCD_OffsStrVar_y(fontVar_8,10);  LCD_StrChangeColorRotVarIndirect(fontVar_8,"SD");  }
			else if(DEBUG_RcvStr("f")){ LCD_OffsStrVar_y(fontVar_8,-10); LCD_StrChangeColorRotVarIndirect(fontVar_8,"SD");  }
			break;
  21684e:	f000 bdde 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("2")) LCD_StrRotVarIndirect(fontVar_7,"Rafa Markielwski hhhhX");
  216852:	4867      	ldr	r0, [pc, #412]	; (2169f0 <SCREEN_ReadPanel+0x710>)
  216854:	f7ea f8a4 	bl	2009a0 <DEBUG_RcvStr>
  216858:	4603      	mov	r3, r0
  21685a:	2b00      	cmp	r3, #0
  21685c:	d007      	beq.n	21686e <SCREEN_ReadPanel+0x58e>
  21685e:	463b      	mov	r3, r7
  216860:	4a64      	ldr	r2, [pc, #400]	; (2169f4 <SCREEN_ReadPanel+0x714>)
  216862:	2106      	movs	r1, #6
  216864:	4618      	mov	r0, r3
  216866:	f7f7 f853 	bl	20d910 <LCD_StrRotVarIndirect>
			break;
  21686a:	f000 bdd0 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("3")){ LCD_OffsStrVar_x(fontVar_7,10);  LCD_StrRotVarIndirect(fontVar_7,"XY");  }
  21686e:	4862      	ldr	r0, [pc, #392]	; (2169f8 <SCREEN_ReadPanel+0x718>)
  216870:	f7ea f896 	bl	2009a0 <DEBUG_RcvStr>
  216874:	4603      	mov	r3, r0
  216876:	2b00      	cmp	r3, #0
  216878:	d00b      	beq.n	216892 <SCREEN_ReadPanel+0x5b2>
  21687a:	210a      	movs	r1, #10
  21687c:	2006      	movs	r0, #6
  21687e:	f7f4 f8b1 	bl	20a9e4 <LCD_OffsStrVar_x>
  216882:	463b      	mov	r3, r7
  216884:	4a5d      	ldr	r2, [pc, #372]	; (2169fc <SCREEN_ReadPanel+0x71c>)
  216886:	2106      	movs	r1, #6
  216888:	4618      	mov	r0, r3
  21688a:	f7f7 f841 	bl	20d910 <LCD_StrRotVarIndirect>
			break;
  21688e:	f000 bdbe 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("4")){ LCD_OffsStrVar_x(fontVar_7,-10); LCD_StrRotVarIndirect(fontVar_7,"XY");  }
  216892:	485b      	ldr	r0, [pc, #364]	; (216a00 <SCREEN_ReadPanel+0x720>)
  216894:	f7ea f884 	bl	2009a0 <DEBUG_RcvStr>
  216898:	4603      	mov	r3, r0
  21689a:	2b00      	cmp	r3, #0
  21689c:	d00c      	beq.n	2168b8 <SCREEN_ReadPanel+0x5d8>
  21689e:	f06f 0109 	mvn.w	r1, #9
  2168a2:	2006      	movs	r0, #6
  2168a4:	f7f4 f89e 	bl	20a9e4 <LCD_OffsStrVar_x>
  2168a8:	463b      	mov	r3, r7
  2168aa:	4a54      	ldr	r2, [pc, #336]	; (2169fc <SCREEN_ReadPanel+0x71c>)
  2168ac:	2106      	movs	r1, #6
  2168ae:	4618      	mov	r0, r3
  2168b0:	f7f7 f82e 	bl	20d910 <LCD_StrRotVarIndirect>
			break;
  2168b4:	f000 bdab 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("5")){ LCD_OffsStrVar_y(fontVar_7,10);  LCD_StrRotVarIndirect(fontVar_7,"SD");  }
  2168b8:	4852      	ldr	r0, [pc, #328]	; (216a04 <SCREEN_ReadPanel+0x724>)
  2168ba:	f7ea f871 	bl	2009a0 <DEBUG_RcvStr>
  2168be:	4603      	mov	r3, r0
  2168c0:	2b00      	cmp	r3, #0
  2168c2:	d00b      	beq.n	2168dc <SCREEN_ReadPanel+0x5fc>
  2168c4:	210a      	movs	r1, #10
  2168c6:	2006      	movs	r0, #6
  2168c8:	f7f4 f8b0 	bl	20aa2c <LCD_OffsStrVar_y>
  2168cc:	463b      	mov	r3, r7
  2168ce:	4a4e      	ldr	r2, [pc, #312]	; (216a08 <SCREEN_ReadPanel+0x728>)
  2168d0:	2106      	movs	r1, #6
  2168d2:	4618      	mov	r0, r3
  2168d4:	f7f7 f81c 	bl	20d910 <LCD_StrRotVarIndirect>
			break;
  2168d8:	f000 bd99 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("6")){ LCD_OffsStrVar_y(fontVar_7,-10); LCD_StrRotVarIndirect(fontVar_7,"SD");  }
  2168dc:	484b      	ldr	r0, [pc, #300]	; (216a0c <SCREEN_ReadPanel+0x72c>)
  2168de:	f7ea f85f 	bl	2009a0 <DEBUG_RcvStr>
  2168e2:	4603      	mov	r3, r0
  2168e4:	2b00      	cmp	r3, #0
  2168e6:	d00c      	beq.n	216902 <SCREEN_ReadPanel+0x622>
  2168e8:	f06f 0109 	mvn.w	r1, #9
  2168ec:	2006      	movs	r0, #6
  2168ee:	f7f4 f89d 	bl	20aa2c <LCD_OffsStrVar_y>
  2168f2:	463b      	mov	r3, r7
  2168f4:	4a44      	ldr	r2, [pc, #272]	; (216a08 <SCREEN_ReadPanel+0x728>)
  2168f6:	2106      	movs	r1, #6
  2168f8:	4618      	mov	r0, r3
  2168fa:	f7f7 f809 	bl	20d910 <LCD_StrRotVarIndirect>
			break;
  2168fe:	f000 bd86 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("a")) LCD_StrChangeColorRotVarIndirect(fontVar_8,"abAb");
  216902:	4843      	ldr	r0, [pc, #268]	; (216a10 <SCREEN_ReadPanel+0x730>)
  216904:	f7ea f84c 	bl	2009a0 <DEBUG_RcvStr>
  216908:	4603      	mov	r3, r0
  21690a:	2b00      	cmp	r3, #0
  21690c:	d007      	beq.n	21691e <SCREEN_ReadPanel+0x63e>
  21690e:	463b      	mov	r3, r7
  216910:	4a36      	ldr	r2, [pc, #216]	; (2169ec <SCREEN_ReadPanel+0x70c>)
  216912:	2107      	movs	r1, #7
  216914:	4618      	mov	r0, r3
  216916:	f7f7 f959 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  21691a:	f000 bd78 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("b")) LCD_StrChangeColorRotVarIndirect(fontVar_8,"Rafa Markielwski hhhhX");
  21691e:	483d      	ldr	r0, [pc, #244]	; (216a14 <SCREEN_ReadPanel+0x734>)
  216920:	f7ea f83e 	bl	2009a0 <DEBUG_RcvStr>
  216924:	4603      	mov	r3, r0
  216926:	2b00      	cmp	r3, #0
  216928:	d007      	beq.n	21693a <SCREEN_ReadPanel+0x65a>
  21692a:	463b      	mov	r3, r7
  21692c:	4a31      	ldr	r2, [pc, #196]	; (2169f4 <SCREEN_ReadPanel+0x714>)
  21692e:	2107      	movs	r1, #7
  216930:	4618      	mov	r0, r3
  216932:	f7f7 f94b 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  216936:	f000 bd6a 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("c")){ LCD_OffsStrVar_x(fontVar_8,10);  LCD_StrChangeColorRotVarIndirect(fontVar_8,"XY");  }
  21693a:	4837      	ldr	r0, [pc, #220]	; (216a18 <SCREEN_ReadPanel+0x738>)
  21693c:	f7ea f830 	bl	2009a0 <DEBUG_RcvStr>
  216940:	4603      	mov	r3, r0
  216942:	2b00      	cmp	r3, #0
  216944:	d00b      	beq.n	21695e <SCREEN_ReadPanel+0x67e>
  216946:	210a      	movs	r1, #10
  216948:	2007      	movs	r0, #7
  21694a:	f7f4 f84b 	bl	20a9e4 <LCD_OffsStrVar_x>
  21694e:	463b      	mov	r3, r7
  216950:	4a2a      	ldr	r2, [pc, #168]	; (2169fc <SCREEN_ReadPanel+0x71c>)
  216952:	2107      	movs	r1, #7
  216954:	4618      	mov	r0, r3
  216956:	f7f7 f939 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  21695a:	f000 bd58 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("d")){ LCD_OffsStrVar_x(fontVar_8,-10); LCD_StrChangeColorRotVarIndirect(fontVar_8,"XY");  }
  21695e:	482f      	ldr	r0, [pc, #188]	; (216a1c <SCREEN_ReadPanel+0x73c>)
  216960:	f7ea f81e 	bl	2009a0 <DEBUG_RcvStr>
  216964:	4603      	mov	r3, r0
  216966:	2b00      	cmp	r3, #0
  216968:	d00c      	beq.n	216984 <SCREEN_ReadPanel+0x6a4>
  21696a:	f06f 0109 	mvn.w	r1, #9
  21696e:	2007      	movs	r0, #7
  216970:	f7f4 f838 	bl	20a9e4 <LCD_OffsStrVar_x>
  216974:	463b      	mov	r3, r7
  216976:	4a21      	ldr	r2, [pc, #132]	; (2169fc <SCREEN_ReadPanel+0x71c>)
  216978:	2107      	movs	r1, #7
  21697a:	4618      	mov	r0, r3
  21697c:	f7f7 f926 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  216980:	f000 bd45 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("e")){ LCD_OffsStrVar_y(fontVar_8,10);  LCD_StrChangeColorRotVarIndirect(fontVar_8,"SD");  }
  216984:	4826      	ldr	r0, [pc, #152]	; (216a20 <SCREEN_ReadPanel+0x740>)
  216986:	f7ea f80b 	bl	2009a0 <DEBUG_RcvStr>
  21698a:	4603      	mov	r3, r0
  21698c:	2b00      	cmp	r3, #0
  21698e:	d00b      	beq.n	2169a8 <SCREEN_ReadPanel+0x6c8>
  216990:	210a      	movs	r1, #10
  216992:	2007      	movs	r0, #7
  216994:	f7f4 f84a 	bl	20aa2c <LCD_OffsStrVar_y>
  216998:	463b      	mov	r3, r7
  21699a:	4a1b      	ldr	r2, [pc, #108]	; (216a08 <SCREEN_ReadPanel+0x728>)
  21699c:	2107      	movs	r1, #7
  21699e:	4618      	mov	r0, r3
  2169a0:	f7f7 f914 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  2169a4:	f000 bd33 	b.w	21740e <SCREEN_ReadPanel+0x112e>
			else if(DEBUG_RcvStr("f")){ LCD_OffsStrVar_y(fontVar_8,-10); LCD_StrChangeColorRotVarIndirect(fontVar_8,"SD");  }
  2169a8:	481e      	ldr	r0, [pc, #120]	; (216a24 <SCREEN_ReadPanel+0x744>)
  2169aa:	f7e9 fff9 	bl	2009a0 <DEBUG_RcvStr>
  2169ae:	4603      	mov	r3, r0
  2169b0:	2b00      	cmp	r3, #0
  2169b2:	f000 852c 	beq.w	21740e <SCREEN_ReadPanel+0x112e>
  2169b6:	f06f 0109 	mvn.w	r1, #9
  2169ba:	2007      	movs	r0, #7
  2169bc:	f7f4 f836 	bl	20aa2c <LCD_OffsStrVar_y>
  2169c0:	463b      	mov	r3, r7
  2169c2:	4a11      	ldr	r2, [pc, #68]	; (216a08 <SCREEN_ReadPanel+0x728>)
  2169c4:	2107      	movs	r1, #7
  2169c6:	4618      	mov	r0, r3
  2169c8:	f7f7 f900 	bl	20dbcc <LCD_StrChangeColorRotVarIndirect>
			break;
  2169cc:	f000 bd1f 	b.w	21740e <SCREEN_ReadPanel+0x112e>
  2169d0:	00229160 	.word	0x00229160
  2169d4:	00229164 	.word	0x00229164
  2169d8:	00229168 	.word	0x00229168
  2169dc:	0022916c 	.word	0x0022916c
  2169e0:	00229170 	.word	0x00229170
  2169e4:	200104d0 	.word	0x200104d0
  2169e8:	002290f0 	.word	0x002290f0
  2169ec:	00229174 	.word	0x00229174
  2169f0:	002290f8 	.word	0x002290f8
  2169f4:	0022917c 	.word	0x0022917c
  2169f8:	00229100 	.word	0x00229100
  2169fc:	00229198 	.word	0x00229198
  216a00:	0022919c 	.word	0x0022919c
  216a04:	002291a0 	.word	0x002291a0
  216a08:	002291a4 	.word	0x002291a4
  216a0c:	002291a8 	.word	0x002291a8
  216a10:	00229108 	.word	0x00229108
  216a14:	00229128 	.word	0x00229128
  216a18:	00228e40 	.word	0x00228e40
  216a1c:	00229118 	.word	0x00229118
  216a20:	00229104 	.word	0x00229104
  216a24:	0022911c 	.word	0x0022911c

		case 3:
			if(LCD_IsRefreshScreenTimeout(refresh_1,60)) LCD_StrMovHIndirect(fontVar_1,1);
  216a28:	213c      	movs	r1, #60	; 0x3c
  216a2a:	2000      	movs	r0, #0
  216a2c:	f7f0 fdcc 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216a30:	4603      	mov	r3, r0
  216a32:	2b00      	cmp	r3, #0
  216a34:	d003      	beq.n	216a3e <SCREEN_ReadPanel+0x75e>
  216a36:	2101      	movs	r1, #1
  216a38:	2000      	movs	r0, #0
  216a3a:	f7f8 f9f5 	bl	20ee28 <LCD_StrMovHIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_2,60)) LCD_StrMovHIndirect(fontVar_2,1);
  216a3e:	213c      	movs	r1, #60	; 0x3c
  216a40:	2001      	movs	r0, #1
  216a42:	f7f0 fdc1 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216a46:	4603      	mov	r3, r0
  216a48:	2b00      	cmp	r3, #0
  216a4a:	d003      	beq.n	216a54 <SCREEN_ReadPanel+0x774>
  216a4c:	2101      	movs	r1, #1
  216a4e:	2001      	movs	r0, #1
  216a50:	f7f8 f9ea 	bl	20ee28 <LCD_StrMovHIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_3,20)) LCD_StrMovHIndirect(fontVar_3,1);
  216a54:	2114      	movs	r1, #20
  216a56:	2002      	movs	r0, #2
  216a58:	f7f0 fdb6 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216a5c:	4603      	mov	r3, r0
  216a5e:	2b00      	cmp	r3, #0
  216a60:	d003      	beq.n	216a6a <SCREEN_ReadPanel+0x78a>
  216a62:	2101      	movs	r1, #1
  216a64:	2002      	movs	r0, #2
  216a66:	f7f8 f9df 	bl	20ee28 <LCD_StrMovHIndirect>

			if(LCD_IsRefreshScreenTimeout(refresh_4,60)) LCD_StrMovHIndirect(fontVar_4,1);
  216a6a:	213c      	movs	r1, #60	; 0x3c
  216a6c:	2003      	movs	r0, #3
  216a6e:	f7f0 fdab 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216a72:	4603      	mov	r3, r0
  216a74:	2b00      	cmp	r3, #0
  216a76:	d003      	beq.n	216a80 <SCREEN_ReadPanel+0x7a0>
  216a78:	2101      	movs	r1, #1
  216a7a:	2003      	movs	r0, #3
  216a7c:	f7f8 f9d4 	bl	20ee28 <LCD_StrMovHIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_5,60)) LCD_StrMovHIndirect(fontVar_5,1);
  216a80:	213c      	movs	r1, #60	; 0x3c
  216a82:	2004      	movs	r0, #4
  216a84:	f7f0 fda0 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216a88:	4603      	mov	r3, r0
  216a8a:	2b00      	cmp	r3, #0
  216a8c:	d003      	beq.n	216a96 <SCREEN_ReadPanel+0x7b6>
  216a8e:	2101      	movs	r1, #1
  216a90:	2004      	movs	r0, #4
  216a92:	f7f8 f9c9 	bl	20ee28 <LCD_StrMovHIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_6,20)) LCD_StrMovHIndirect(fontVar_6,1);
  216a96:	2114      	movs	r1, #20
  216a98:	2005      	movs	r0, #5
  216a9a:	f7f0 fd95 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216a9e:	4603      	mov	r3, r0
  216aa0:	2b00      	cmp	r3, #0
  216aa2:	d003      	beq.n	216aac <SCREEN_ReadPanel+0x7cc>
  216aa4:	2101      	movs	r1, #1
  216aa6:	2005      	movs	r0, #5
  216aa8:	f7f8 f9be 	bl	20ee28 <LCD_StrMovHIndirect>

			if(LCD_IsRefreshScreenTimeout(refresh_7,60)) LCD_StrMovVIndirect(fontVar_7,1);
  216aac:	213c      	movs	r1, #60	; 0x3c
  216aae:	2006      	movs	r0, #6
  216ab0:	f7f0 fd8a 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216ab4:	4603      	mov	r3, r0
  216ab6:	2b00      	cmp	r3, #0
  216ab8:	d003      	beq.n	216ac2 <SCREEN_ReadPanel+0x7e2>
  216aba:	2101      	movs	r1, #1
  216abc:	2006      	movs	r0, #6
  216abe:	f7fa f9b7 	bl	210e30 <LCD_StrMovVIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_8,20)) LCD_StrMovVIndirect(fontVar_8,1);
  216ac2:	2114      	movs	r1, #20
  216ac4:	2007      	movs	r0, #7
  216ac6:	f7f0 fd7f 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216aca:	4603      	mov	r3, r0
  216acc:	2b00      	cmp	r3, #0
  216ace:	d003      	beq.n	216ad8 <SCREEN_ReadPanel+0x7f8>
  216ad0:	2101      	movs	r1, #1
  216ad2:	2007      	movs	r0, #7
  216ad4:	f7fa f9ac 	bl	210e30 <LCD_StrMovVIndirect>

			if(LCD_IsRefreshScreenTimeout(refresh_9,60))  LCD_StrMovVIndirect(fontVar_9,1);
  216ad8:	213c      	movs	r1, #60	; 0x3c
  216ada:	2008      	movs	r0, #8
  216adc:	f7f0 fd74 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216ae0:	4603      	mov	r3, r0
  216ae2:	2b00      	cmp	r3, #0
  216ae4:	d003      	beq.n	216aee <SCREEN_ReadPanel+0x80e>
  216ae6:	2101      	movs	r1, #1
  216ae8:	2008      	movs	r0, #8
  216aea:	f7fa f9a1 	bl	210e30 <LCD_StrMovVIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_10,20)) LCD_StrMovVIndirect(fontVar_10,1);
  216aee:	2114      	movs	r1, #20
  216af0:	2009      	movs	r0, #9
  216af2:	f7f0 fd69 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216af6:	4603      	mov	r3, r0
  216af8:	2b00      	cmp	r3, #0
  216afa:	d003      	beq.n	216b04 <SCREEN_ReadPanel+0x824>
  216afc:	2101      	movs	r1, #1
  216afe:	2009      	movs	r0, #9
  216b00:	f7fa f996 	bl	210e30 <LCD_StrMovVIndirect>

			if(LCD_IsRefreshScreenTimeout(refresh_11,60))  LCD_StrMovVIndirect(fontVar_11,1);
  216b04:	213c      	movs	r1, #60	; 0x3c
  216b06:	200a      	movs	r0, #10
  216b08:	f7f0 fd5e 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216b0c:	4603      	mov	r3, r0
  216b0e:	2b00      	cmp	r3, #0
  216b10:	d003      	beq.n	216b1a <SCREEN_ReadPanel+0x83a>
  216b12:	2101      	movs	r1, #1
  216b14:	200a      	movs	r0, #10
  216b16:	f7fa f98b 	bl	210e30 <LCD_StrMovVIndirect>
			if(LCD_IsRefreshScreenTimeout(refresh_12,20)) LCD_StrMovVIndirect(fontVar_12,1);
  216b1a:	2114      	movs	r1, #20
  216b1c:	200b      	movs	r0, #11
  216b1e:	f7f0 fd53 	bl	2075c8 <LCD_IsRefreshScreenTimeout>
  216b22:	4603      	mov	r3, r0
  216b24:	2b00      	cmp	r3, #0
  216b26:	f000 8474 	beq.w	217412 <SCREEN_ReadPanel+0x1132>
  216b2a:	2101      	movs	r1, #1
  216b2c:	200b      	movs	r0, #11
  216b2e:	f7fa f97f 	bl	210e30 <LCD_StrMovVIndirect>
			break;
  216b32:	f000 bc6e 	b.w	217412 <SCREEN_ReadPanel+0x1132>

		case 4:
				  if(DEBUG_RcvStr("]")){ INCR_WRAP(Circle.width,INCR_WIDTH_CIRCLE_STEP,12,MAX_WIDTH_CIRCLE);  SCREEN_Test_Circle(); }
  216b36:	48a9      	ldr	r0, [pc, #676]	; (216ddc <SCREEN_ReadPanel+0xafc>)
  216b38:	f7e9 ff32 	bl	2009a0 <DEBUG_RcvStr>
  216b3c:	4603      	mov	r3, r0
  216b3e:	2b00      	cmp	r3, #0
  216b40:	d01e      	beq.n	216b80 <SCREEN_ReadPanel+0x8a0>
  216b42:	4ba7      	ldr	r3, [pc, #668]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216b44:	885b      	ldrh	r3, [r3, #2]
  216b46:	3306      	adds	r3, #6
  216b48:	461c      	mov	r4, r3
  216b4a:	f7f0 ff41 	bl	2079d0 <LCD_GetYSize>
  216b4e:	4602      	mov	r2, r0
  216b50:	4ba4      	ldr	r3, [pc, #656]	; (216de4 <SCREEN_ReadPanel+0xb04>)
  216b52:	fba3 2302 	umull	r2, r3, r3, r2
  216b56:	089a      	lsrs	r2, r3, #2
  216b58:	4613      	mov	r3, r2
  216b5a:	005b      	lsls	r3, r3, #1
  216b5c:	4413      	add	r3, r2
  216b5e:	005b      	lsls	r3, r3, #1
  216b60:	429c      	cmp	r4, r3
  216b62:	d903      	bls.n	216b6c <SCREEN_ReadPanel+0x88c>
  216b64:	4b9e      	ldr	r3, [pc, #632]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216b66:	220c      	movs	r2, #12
  216b68:	805a      	strh	r2, [r3, #2]
  216b6a:	e005      	b.n	216b78 <SCREEN_ReadPanel+0x898>
  216b6c:	4b9c      	ldr	r3, [pc, #624]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216b6e:	885b      	ldrh	r3, [r3, #2]
  216b70:	3306      	adds	r3, #6
  216b72:	b29a      	uxth	r2, r3
  216b74:	4b9a      	ldr	r3, [pc, #616]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216b76:	805a      	strh	r2, [r3, #2]
  216b78:	f7fe fff8 	bl	215b6c <SCREEN_Test_Circle>
			else if(DEBUG_RcvStr("7")){ DECR(Circle.deg[3],1,Circle.deg[2]+1);    SCREEN_Test_Circle(); }
			else if(DEBUG_RcvStr("8")){ INCR(Circle.deg[3],1,360);   SCREEN_Test_Circle(); }  //TU ograniczenie do ostatniego degree a nie do 360 !!!!

			//else if(DEBUG_RcvStr("-")){ INCR(test_len,1,360);   SCREEN_Test_Circle(); }

			break;
  216b7c:	f000 bc4b 	b.w	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("\\")){ DECR_WRAP(Circle.width,INCR_WIDTH_CIRCLE_STEP,12,MAX_WIDTH_CIRCLE);  SCREEN_Test_Circle(); }
  216b80:	4899      	ldr	r0, [pc, #612]	; (216de8 <SCREEN_ReadPanel+0xb08>)
  216b82:	f7e9 ff0d 	bl	2009a0 <DEBUG_RcvStr>
  216b86:	4603      	mov	r3, r0
  216b88:	2b00      	cmp	r3, #0
  216b8a:	d01e      	beq.n	216bca <SCREEN_ReadPanel+0x8ea>
  216b8c:	4b94      	ldr	r3, [pc, #592]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216b8e:	885b      	ldrh	r3, [r3, #2]
  216b90:	3b06      	subs	r3, #6
  216b92:	2b0b      	cmp	r3, #11
  216b94:	dc0f      	bgt.n	216bb6 <SCREEN_ReadPanel+0x8d6>
  216b96:	f7f0 ff1b 	bl	2079d0 <LCD_GetYSize>
  216b9a:	4602      	mov	r2, r0
  216b9c:	4b91      	ldr	r3, [pc, #580]	; (216de4 <SCREEN_ReadPanel+0xb04>)
  216b9e:	fba3 2302 	umull	r2, r3, r3, r2
  216ba2:	089b      	lsrs	r3, r3, #2
  216ba4:	b29b      	uxth	r3, r3
  216ba6:	461a      	mov	r2, r3
  216ba8:	0052      	lsls	r2, r2, #1
  216baa:	4413      	add	r3, r2
  216bac:	005b      	lsls	r3, r3, #1
  216bae:	b29a      	uxth	r2, r3
  216bb0:	4b8b      	ldr	r3, [pc, #556]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216bb2:	805a      	strh	r2, [r3, #2]
  216bb4:	e005      	b.n	216bc2 <SCREEN_ReadPanel+0x8e2>
  216bb6:	4b8a      	ldr	r3, [pc, #552]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216bb8:	885b      	ldrh	r3, [r3, #2]
  216bba:	3b06      	subs	r3, #6
  216bbc:	b29a      	uxth	r2, r3
  216bbe:	4b88      	ldr	r3, [pc, #544]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216bc0:	805a      	strh	r2, [r3, #2]
  216bc2:	f7fe ffd3 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216bc6:	f000 bc26 	b.w	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("1")){ INCR_WRAP(Circle.frame[0],1,0,255);  SCREEN_Test_Circle(); }
  216bca:	4888      	ldr	r0, [pc, #544]	; (216dec <SCREEN_ReadPanel+0xb0c>)
  216bcc:	f7e9 fee8 	bl	2009a0 <DEBUG_RcvStr>
  216bd0:	4603      	mov	r3, r0
  216bd2:	2b00      	cmp	r3, #0
  216bd4:	d012      	beq.n	216bfc <SCREEN_ReadPanel+0x91c>
  216bd6:	4b82      	ldr	r3, [pc, #520]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216bd8:	79db      	ldrb	r3, [r3, #7]
  216bda:	3301      	adds	r3, #1
  216bdc:	2bff      	cmp	r3, #255	; 0xff
  216bde:	dd03      	ble.n	216be8 <SCREEN_ReadPanel+0x908>
  216be0:	4b7f      	ldr	r3, [pc, #508]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216be2:	2200      	movs	r2, #0
  216be4:	71da      	strb	r2, [r3, #7]
  216be6:	e005      	b.n	216bf4 <SCREEN_ReadPanel+0x914>
  216be8:	4b7d      	ldr	r3, [pc, #500]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216bea:	79db      	ldrb	r3, [r3, #7]
  216bec:	3301      	adds	r3, #1
  216bee:	b2da      	uxtb	r2, r3
  216bf0:	4b7b      	ldr	r3, [pc, #492]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216bf2:	71da      	strb	r2, [r3, #7]
  216bf4:	f7fe ffba 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216bf8:	f000 bc0d 	b.w	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("2")){ INCR_WRAP(Circle.frame[1],1,0,255);  SCREEN_Test_Circle(); }
  216bfc:	487c      	ldr	r0, [pc, #496]	; (216df0 <SCREEN_ReadPanel+0xb10>)
  216bfe:	f7e9 fecf 	bl	2009a0 <DEBUG_RcvStr>
  216c02:	4603      	mov	r3, r0
  216c04:	2b00      	cmp	r3, #0
  216c06:	d011      	beq.n	216c2c <SCREEN_ReadPanel+0x94c>
  216c08:	4b75      	ldr	r3, [pc, #468]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c0a:	7a1b      	ldrb	r3, [r3, #8]
  216c0c:	3301      	adds	r3, #1
  216c0e:	2bff      	cmp	r3, #255	; 0xff
  216c10:	dd03      	ble.n	216c1a <SCREEN_ReadPanel+0x93a>
  216c12:	4b73      	ldr	r3, [pc, #460]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c14:	2200      	movs	r2, #0
  216c16:	721a      	strb	r2, [r3, #8]
  216c18:	e005      	b.n	216c26 <SCREEN_ReadPanel+0x946>
  216c1a:	4b71      	ldr	r3, [pc, #452]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c1c:	7a1b      	ldrb	r3, [r3, #8]
  216c1e:	3301      	adds	r3, #1
  216c20:	b2da      	uxtb	r2, r3
  216c22:	4b6f      	ldr	r3, [pc, #444]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c24:	721a      	strb	r2, [r3, #8]
  216c26:	f7fe ffa1 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216c2a:	e3f4      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("3")){ INCR_WRAP(Circle.frame[2],1,0,255);  SCREEN_Test_Circle(); }
  216c2c:	4871      	ldr	r0, [pc, #452]	; (216df4 <SCREEN_ReadPanel+0xb14>)
  216c2e:	f7e9 feb7 	bl	2009a0 <DEBUG_RcvStr>
  216c32:	4603      	mov	r3, r0
  216c34:	2b00      	cmp	r3, #0
  216c36:	d011      	beq.n	216c5c <SCREEN_ReadPanel+0x97c>
  216c38:	4b69      	ldr	r3, [pc, #420]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c3a:	7a5b      	ldrb	r3, [r3, #9]
  216c3c:	3301      	adds	r3, #1
  216c3e:	2bff      	cmp	r3, #255	; 0xff
  216c40:	dd03      	ble.n	216c4a <SCREEN_ReadPanel+0x96a>
  216c42:	4b67      	ldr	r3, [pc, #412]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c44:	2200      	movs	r2, #0
  216c46:	725a      	strb	r2, [r3, #9]
  216c48:	e005      	b.n	216c56 <SCREEN_ReadPanel+0x976>
  216c4a:	4b65      	ldr	r3, [pc, #404]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c4c:	7a5b      	ldrb	r3, [r3, #9]
  216c4e:	3301      	adds	r3, #1
  216c50:	b2da      	uxtb	r2, r3
  216c52:	4b63      	ldr	r3, [pc, #396]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c54:	725a      	strb	r2, [r3, #9]
  216c56:	f7fe ff89 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216c5a:	e3dc      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("q")){ DECR_WRAP(Circle.frame[0],1,0,255);  SCREEN_Test_Circle(); }
  216c5c:	4866      	ldr	r0, [pc, #408]	; (216df8 <SCREEN_ReadPanel+0xb18>)
  216c5e:	f7e9 fe9f 	bl	2009a0 <DEBUG_RcvStr>
  216c62:	4603      	mov	r3, r0
  216c64:	2b00      	cmp	r3, #0
  216c66:	d011      	beq.n	216c8c <SCREEN_ReadPanel+0x9ac>
  216c68:	4b5d      	ldr	r3, [pc, #372]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c6a:	79db      	ldrb	r3, [r3, #7]
  216c6c:	3b01      	subs	r3, #1
  216c6e:	2b00      	cmp	r3, #0
  216c70:	da03      	bge.n	216c7a <SCREEN_ReadPanel+0x99a>
  216c72:	4b5b      	ldr	r3, [pc, #364]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c74:	22ff      	movs	r2, #255	; 0xff
  216c76:	71da      	strb	r2, [r3, #7]
  216c78:	e005      	b.n	216c86 <SCREEN_ReadPanel+0x9a6>
  216c7a:	4b59      	ldr	r3, [pc, #356]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c7c:	79db      	ldrb	r3, [r3, #7]
  216c7e:	3b01      	subs	r3, #1
  216c80:	b2da      	uxtb	r2, r3
  216c82:	4b57      	ldr	r3, [pc, #348]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c84:	71da      	strb	r2, [r3, #7]
  216c86:	f7fe ff71 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216c8a:	e3c4      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("w")){ DECR_WRAP(Circle.frame[1],1,0,255);  SCREEN_Test_Circle(); }
  216c8c:	485b      	ldr	r0, [pc, #364]	; (216dfc <SCREEN_ReadPanel+0xb1c>)
  216c8e:	f7e9 fe87 	bl	2009a0 <DEBUG_RcvStr>
  216c92:	4603      	mov	r3, r0
  216c94:	2b00      	cmp	r3, #0
  216c96:	d011      	beq.n	216cbc <SCREEN_ReadPanel+0x9dc>
  216c98:	4b51      	ldr	r3, [pc, #324]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216c9a:	7a1b      	ldrb	r3, [r3, #8]
  216c9c:	3b01      	subs	r3, #1
  216c9e:	2b00      	cmp	r3, #0
  216ca0:	da03      	bge.n	216caa <SCREEN_ReadPanel+0x9ca>
  216ca2:	4b4f      	ldr	r3, [pc, #316]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216ca4:	22ff      	movs	r2, #255	; 0xff
  216ca6:	721a      	strb	r2, [r3, #8]
  216ca8:	e005      	b.n	216cb6 <SCREEN_ReadPanel+0x9d6>
  216caa:	4b4d      	ldr	r3, [pc, #308]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216cac:	7a1b      	ldrb	r3, [r3, #8]
  216cae:	3b01      	subs	r3, #1
  216cb0:	b2da      	uxtb	r2, r3
  216cb2:	4b4b      	ldr	r3, [pc, #300]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216cb4:	721a      	strb	r2, [r3, #8]
  216cb6:	f7fe ff59 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216cba:	e3ac      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("e")){ DECR_WRAP(Circle.frame[2],1,0,255);  SCREEN_Test_Circle(); }
  216cbc:	4850      	ldr	r0, [pc, #320]	; (216e00 <SCREEN_ReadPanel+0xb20>)
  216cbe:	f7e9 fe6f 	bl	2009a0 <DEBUG_RcvStr>
  216cc2:	4603      	mov	r3, r0
  216cc4:	2b00      	cmp	r3, #0
  216cc6:	d011      	beq.n	216cec <SCREEN_ReadPanel+0xa0c>
  216cc8:	4b45      	ldr	r3, [pc, #276]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216cca:	7a5b      	ldrb	r3, [r3, #9]
  216ccc:	3b01      	subs	r3, #1
  216cce:	2b00      	cmp	r3, #0
  216cd0:	da03      	bge.n	216cda <SCREEN_ReadPanel+0x9fa>
  216cd2:	4b43      	ldr	r3, [pc, #268]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216cd4:	22ff      	movs	r2, #255	; 0xff
  216cd6:	725a      	strb	r2, [r3, #9]
  216cd8:	e005      	b.n	216ce6 <SCREEN_ReadPanel+0xa06>
  216cda:	4b41      	ldr	r3, [pc, #260]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216cdc:	7a5b      	ldrb	r3, [r3, #9]
  216cde:	3b01      	subs	r3, #1
  216ce0:	b2da      	uxtb	r2, r3
  216ce2:	4b3f      	ldr	r3, [pc, #252]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216ce4:	725a      	strb	r2, [r3, #9]
  216ce6:	f7fe ff41 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216cea:	e394      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("a")){ INCR_WRAP(Circle.bk[0],1,0,255);  SCREEN_Test_Circle(); }
  216cec:	4845      	ldr	r0, [pc, #276]	; (216e04 <SCREEN_ReadPanel+0xb24>)
  216cee:	f7e9 fe57 	bl	2009a0 <DEBUG_RcvStr>
  216cf2:	4603      	mov	r3, r0
  216cf4:	2b00      	cmp	r3, #0
  216cf6:	d011      	beq.n	216d1c <SCREEN_ReadPanel+0xa3c>
  216cf8:	4b39      	ldr	r3, [pc, #228]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216cfa:	791b      	ldrb	r3, [r3, #4]
  216cfc:	3301      	adds	r3, #1
  216cfe:	2bff      	cmp	r3, #255	; 0xff
  216d00:	dd03      	ble.n	216d0a <SCREEN_ReadPanel+0xa2a>
  216d02:	4b37      	ldr	r3, [pc, #220]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d04:	2200      	movs	r2, #0
  216d06:	711a      	strb	r2, [r3, #4]
  216d08:	e005      	b.n	216d16 <SCREEN_ReadPanel+0xa36>
  216d0a:	4b35      	ldr	r3, [pc, #212]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d0c:	791b      	ldrb	r3, [r3, #4]
  216d0e:	3301      	adds	r3, #1
  216d10:	b2da      	uxtb	r2, r3
  216d12:	4b33      	ldr	r3, [pc, #204]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d14:	711a      	strb	r2, [r3, #4]
  216d16:	f7fe ff29 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216d1a:	e37c      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("s")){ INCR_WRAP(Circle.bk[1],1,0,255);  SCREEN_Test_Circle(); }
  216d1c:	483a      	ldr	r0, [pc, #232]	; (216e08 <SCREEN_ReadPanel+0xb28>)
  216d1e:	f7e9 fe3f 	bl	2009a0 <DEBUG_RcvStr>
  216d22:	4603      	mov	r3, r0
  216d24:	2b00      	cmp	r3, #0
  216d26:	d011      	beq.n	216d4c <SCREEN_ReadPanel+0xa6c>
  216d28:	4b2d      	ldr	r3, [pc, #180]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d2a:	795b      	ldrb	r3, [r3, #5]
  216d2c:	3301      	adds	r3, #1
  216d2e:	2bff      	cmp	r3, #255	; 0xff
  216d30:	dd03      	ble.n	216d3a <SCREEN_ReadPanel+0xa5a>
  216d32:	4b2b      	ldr	r3, [pc, #172]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d34:	2200      	movs	r2, #0
  216d36:	715a      	strb	r2, [r3, #5]
  216d38:	e005      	b.n	216d46 <SCREEN_ReadPanel+0xa66>
  216d3a:	4b29      	ldr	r3, [pc, #164]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d3c:	795b      	ldrb	r3, [r3, #5]
  216d3e:	3301      	adds	r3, #1
  216d40:	b2da      	uxtb	r2, r3
  216d42:	4b27      	ldr	r3, [pc, #156]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d44:	715a      	strb	r2, [r3, #5]
  216d46:	f7fe ff11 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216d4a:	e364      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("d")){ INCR_WRAP(Circle.bk[2],1,0,255);  SCREEN_Test_Circle(); }
  216d4c:	482f      	ldr	r0, [pc, #188]	; (216e0c <SCREEN_ReadPanel+0xb2c>)
  216d4e:	f7e9 fe27 	bl	2009a0 <DEBUG_RcvStr>
  216d52:	4603      	mov	r3, r0
  216d54:	2b00      	cmp	r3, #0
  216d56:	d011      	beq.n	216d7c <SCREEN_ReadPanel+0xa9c>
  216d58:	4b21      	ldr	r3, [pc, #132]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d5a:	799b      	ldrb	r3, [r3, #6]
  216d5c:	3301      	adds	r3, #1
  216d5e:	2bff      	cmp	r3, #255	; 0xff
  216d60:	dd03      	ble.n	216d6a <SCREEN_ReadPanel+0xa8a>
  216d62:	4b1f      	ldr	r3, [pc, #124]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d64:	2200      	movs	r2, #0
  216d66:	719a      	strb	r2, [r3, #6]
  216d68:	e005      	b.n	216d76 <SCREEN_ReadPanel+0xa96>
  216d6a:	4b1d      	ldr	r3, [pc, #116]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d6c:	799b      	ldrb	r3, [r3, #6]
  216d6e:	3301      	adds	r3, #1
  216d70:	b2da      	uxtb	r2, r3
  216d72:	4b1b      	ldr	r3, [pc, #108]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d74:	719a      	strb	r2, [r3, #6]
  216d76:	f7fe fef9 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216d7a:	e34c      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("z")){ DECR_WRAP(Circle.bk[0],1,0,255);  SCREEN_Test_Circle(); }
  216d7c:	4824      	ldr	r0, [pc, #144]	; (216e10 <SCREEN_ReadPanel+0xb30>)
  216d7e:	f7e9 fe0f 	bl	2009a0 <DEBUG_RcvStr>
  216d82:	4603      	mov	r3, r0
  216d84:	2b00      	cmp	r3, #0
  216d86:	d011      	beq.n	216dac <SCREEN_ReadPanel+0xacc>
  216d88:	4b15      	ldr	r3, [pc, #84]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d8a:	791b      	ldrb	r3, [r3, #4]
  216d8c:	3b01      	subs	r3, #1
  216d8e:	2b00      	cmp	r3, #0
  216d90:	da03      	bge.n	216d9a <SCREEN_ReadPanel+0xaba>
  216d92:	4b13      	ldr	r3, [pc, #76]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d94:	22ff      	movs	r2, #255	; 0xff
  216d96:	711a      	strb	r2, [r3, #4]
  216d98:	e005      	b.n	216da6 <SCREEN_ReadPanel+0xac6>
  216d9a:	4b11      	ldr	r3, [pc, #68]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216d9c:	791b      	ldrb	r3, [r3, #4]
  216d9e:	3b01      	subs	r3, #1
  216da0:	b2da      	uxtb	r2, r3
  216da2:	4b0f      	ldr	r3, [pc, #60]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216da4:	711a      	strb	r2, [r3, #4]
  216da6:	f7fe fee1 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216daa:	e334      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("x")){ DECR_WRAP(Circle.bk[1],1,0,255);  SCREEN_Test_Circle(); }
  216dac:	4819      	ldr	r0, [pc, #100]	; (216e14 <SCREEN_ReadPanel+0xb34>)
  216dae:	f7e9 fdf7 	bl	2009a0 <DEBUG_RcvStr>
  216db2:	4603      	mov	r3, r0
  216db4:	2b00      	cmp	r3, #0
  216db6:	d02f      	beq.n	216e18 <SCREEN_ReadPanel+0xb38>
  216db8:	4b09      	ldr	r3, [pc, #36]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216dba:	795b      	ldrb	r3, [r3, #5]
  216dbc:	3b01      	subs	r3, #1
  216dbe:	2b00      	cmp	r3, #0
  216dc0:	da03      	bge.n	216dca <SCREEN_ReadPanel+0xaea>
  216dc2:	4b07      	ldr	r3, [pc, #28]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216dc4:	22ff      	movs	r2, #255	; 0xff
  216dc6:	715a      	strb	r2, [r3, #5]
  216dc8:	e005      	b.n	216dd6 <SCREEN_ReadPanel+0xaf6>
  216dca:	4b05      	ldr	r3, [pc, #20]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216dcc:	795b      	ldrb	r3, [r3, #5]
  216dce:	3b01      	subs	r3, #1
  216dd0:	b2da      	uxtb	r2, r3
  216dd2:	4b03      	ldr	r3, [pc, #12]	; (216de0 <SCREEN_ReadPanel+0xb00>)
  216dd4:	715a      	strb	r2, [r3, #5]
  216dd6:	f7fe fec9 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216dda:	e31c      	b.n	217416 <SCREEN_ReadPanel+0x1136>
  216ddc:	00229148 	.word	0x00229148
  216de0:	200104e8 	.word	0x200104e8
  216de4:	aaaaaaab 	.word	0xaaaaaaab
  216de8:	00229154 	.word	0x00229154
  216dec:	002290f0 	.word	0x002290f0
  216df0:	002290f8 	.word	0x002290f8
  216df4:	00229100 	.word	0x00229100
  216df8:	002290f4 	.word	0x002290f4
  216dfc:	002290fc 	.word	0x002290fc
  216e00:	00229104 	.word	0x00229104
  216e04:	00229108 	.word	0x00229108
  216e08:	00229110 	.word	0x00229110
  216e0c:	00229118 	.word	0x00229118
  216e10:	0022910c 	.word	0x0022910c
  216e14:	00229114 	.word	0x00229114
			else if(DEBUG_RcvStr("c")){ DECR_WRAP(Circle.bk[2],1,0,255);  SCREEN_Test_Circle(); }
  216e18:	48b5      	ldr	r0, [pc, #724]	; (2170f0 <SCREEN_ReadPanel+0xe10>)
  216e1a:	f7e9 fdc1 	bl	2009a0 <DEBUG_RcvStr>
  216e1e:	4603      	mov	r3, r0
  216e20:	2b00      	cmp	r3, #0
  216e22:	d011      	beq.n	216e48 <SCREEN_ReadPanel+0xb68>
  216e24:	4bb3      	ldr	r3, [pc, #716]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e26:	799b      	ldrb	r3, [r3, #6]
  216e28:	3b01      	subs	r3, #1
  216e2a:	2b00      	cmp	r3, #0
  216e2c:	da03      	bge.n	216e36 <SCREEN_ReadPanel+0xb56>
  216e2e:	4bb1      	ldr	r3, [pc, #708]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e30:	22ff      	movs	r2, #255	; 0xff
  216e32:	719a      	strb	r2, [r3, #6]
  216e34:	e005      	b.n	216e42 <SCREEN_ReadPanel+0xb62>
  216e36:	4baf      	ldr	r3, [pc, #700]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e38:	799b      	ldrb	r3, [r3, #6]
  216e3a:	3b01      	subs	r3, #1
  216e3c:	b2da      	uxtb	r2, r3
  216e3e:	4bad      	ldr	r3, [pc, #692]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e40:	719a      	strb	r2, [r3, #6]
  216e42:	f7fe fe93 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216e46:	e2e6      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("4")){ INCR_WRAP(Circle.fill[0],1,0,255);  SCREEN_Test_Circle(); }
  216e48:	48ab      	ldr	r0, [pc, #684]	; (2170f8 <SCREEN_ReadPanel+0xe18>)
  216e4a:	f7e9 fda9 	bl	2009a0 <DEBUG_RcvStr>
  216e4e:	4603      	mov	r3, r0
  216e50:	2b00      	cmp	r3, #0
  216e52:	d011      	beq.n	216e78 <SCREEN_ReadPanel+0xb98>
  216e54:	4ba7      	ldr	r3, [pc, #668]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e56:	7a9b      	ldrb	r3, [r3, #10]
  216e58:	3301      	adds	r3, #1
  216e5a:	2bff      	cmp	r3, #255	; 0xff
  216e5c:	dd03      	ble.n	216e66 <SCREEN_ReadPanel+0xb86>
  216e5e:	4ba5      	ldr	r3, [pc, #660]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e60:	2200      	movs	r2, #0
  216e62:	729a      	strb	r2, [r3, #10]
  216e64:	e005      	b.n	216e72 <SCREEN_ReadPanel+0xb92>
  216e66:	4ba3      	ldr	r3, [pc, #652]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e68:	7a9b      	ldrb	r3, [r3, #10]
  216e6a:	3301      	adds	r3, #1
  216e6c:	b2da      	uxtb	r2, r3
  216e6e:	4ba1      	ldr	r3, [pc, #644]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e70:	729a      	strb	r2, [r3, #10]
  216e72:	f7fe fe7b 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216e76:	e2ce      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("5")){ INCR_WRAP(Circle.fill[1],1,0,255);  SCREEN_Test_Circle(); }
  216e78:	48a0      	ldr	r0, [pc, #640]	; (2170fc <SCREEN_ReadPanel+0xe1c>)
  216e7a:	f7e9 fd91 	bl	2009a0 <DEBUG_RcvStr>
  216e7e:	4603      	mov	r3, r0
  216e80:	2b00      	cmp	r3, #0
  216e82:	d011      	beq.n	216ea8 <SCREEN_ReadPanel+0xbc8>
  216e84:	4b9b      	ldr	r3, [pc, #620]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e86:	7adb      	ldrb	r3, [r3, #11]
  216e88:	3301      	adds	r3, #1
  216e8a:	2bff      	cmp	r3, #255	; 0xff
  216e8c:	dd03      	ble.n	216e96 <SCREEN_ReadPanel+0xbb6>
  216e8e:	4b99      	ldr	r3, [pc, #612]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e90:	2200      	movs	r2, #0
  216e92:	72da      	strb	r2, [r3, #11]
  216e94:	e005      	b.n	216ea2 <SCREEN_ReadPanel+0xbc2>
  216e96:	4b97      	ldr	r3, [pc, #604]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216e98:	7adb      	ldrb	r3, [r3, #11]
  216e9a:	3301      	adds	r3, #1
  216e9c:	b2da      	uxtb	r2, r3
  216e9e:	4b95      	ldr	r3, [pc, #596]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ea0:	72da      	strb	r2, [r3, #11]
  216ea2:	f7fe fe63 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216ea6:	e2b6      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("6")){ INCR_WRAP(Circle.fill[2],1,0,255);  SCREEN_Test_Circle(); }
  216ea8:	4895      	ldr	r0, [pc, #596]	; (217100 <SCREEN_ReadPanel+0xe20>)
  216eaa:	f7e9 fd79 	bl	2009a0 <DEBUG_RcvStr>
  216eae:	4603      	mov	r3, r0
  216eb0:	2b00      	cmp	r3, #0
  216eb2:	d011      	beq.n	216ed8 <SCREEN_ReadPanel+0xbf8>
  216eb4:	4b8f      	ldr	r3, [pc, #572]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216eb6:	7b1b      	ldrb	r3, [r3, #12]
  216eb8:	3301      	adds	r3, #1
  216eba:	2bff      	cmp	r3, #255	; 0xff
  216ebc:	dd03      	ble.n	216ec6 <SCREEN_ReadPanel+0xbe6>
  216ebe:	4b8d      	ldr	r3, [pc, #564]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ec0:	2200      	movs	r2, #0
  216ec2:	731a      	strb	r2, [r3, #12]
  216ec4:	e005      	b.n	216ed2 <SCREEN_ReadPanel+0xbf2>
  216ec6:	4b8b      	ldr	r3, [pc, #556]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ec8:	7b1b      	ldrb	r3, [r3, #12]
  216eca:	3301      	adds	r3, #1
  216ecc:	b2da      	uxtb	r2, r3
  216ece:	4b89      	ldr	r3, [pc, #548]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ed0:	731a      	strb	r2, [r3, #12]
  216ed2:	f7fe fe4b 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216ed6:	e29e      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("r")){ DECR_WRAP(Circle.fill[0],1,0,255);  SCREEN_Test_Circle(); }
  216ed8:	488a      	ldr	r0, [pc, #552]	; (217104 <SCREEN_ReadPanel+0xe24>)
  216eda:	f7e9 fd61 	bl	2009a0 <DEBUG_RcvStr>
  216ede:	4603      	mov	r3, r0
  216ee0:	2b00      	cmp	r3, #0
  216ee2:	d011      	beq.n	216f08 <SCREEN_ReadPanel+0xc28>
  216ee4:	4b83      	ldr	r3, [pc, #524]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ee6:	7a9b      	ldrb	r3, [r3, #10]
  216ee8:	3b01      	subs	r3, #1
  216eea:	2b00      	cmp	r3, #0
  216eec:	da03      	bge.n	216ef6 <SCREEN_ReadPanel+0xc16>
  216eee:	4b81      	ldr	r3, [pc, #516]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ef0:	22ff      	movs	r2, #255	; 0xff
  216ef2:	729a      	strb	r2, [r3, #10]
  216ef4:	e005      	b.n	216f02 <SCREEN_ReadPanel+0xc22>
  216ef6:	4b7f      	ldr	r3, [pc, #508]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ef8:	7a9b      	ldrb	r3, [r3, #10]
  216efa:	3b01      	subs	r3, #1
  216efc:	b2da      	uxtb	r2, r3
  216efe:	4b7d      	ldr	r3, [pc, #500]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f00:	729a      	strb	r2, [r3, #10]
  216f02:	f7fe fe33 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216f06:	e286      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("t")){ DECR_WRAP(Circle.fill[1],1,0,255);  SCREEN_Test_Circle(); }
  216f08:	487f      	ldr	r0, [pc, #508]	; (217108 <SCREEN_ReadPanel+0xe28>)
  216f0a:	f7e9 fd49 	bl	2009a0 <DEBUG_RcvStr>
  216f0e:	4603      	mov	r3, r0
  216f10:	2b00      	cmp	r3, #0
  216f12:	d011      	beq.n	216f38 <SCREEN_ReadPanel+0xc58>
  216f14:	4b77      	ldr	r3, [pc, #476]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f16:	7adb      	ldrb	r3, [r3, #11]
  216f18:	3b01      	subs	r3, #1
  216f1a:	2b00      	cmp	r3, #0
  216f1c:	da03      	bge.n	216f26 <SCREEN_ReadPanel+0xc46>
  216f1e:	4b75      	ldr	r3, [pc, #468]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f20:	22ff      	movs	r2, #255	; 0xff
  216f22:	72da      	strb	r2, [r3, #11]
  216f24:	e005      	b.n	216f32 <SCREEN_ReadPanel+0xc52>
  216f26:	4b73      	ldr	r3, [pc, #460]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f28:	7adb      	ldrb	r3, [r3, #11]
  216f2a:	3b01      	subs	r3, #1
  216f2c:	b2da      	uxtb	r2, r3
  216f2e:	4b71      	ldr	r3, [pc, #452]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f30:	72da      	strb	r2, [r3, #11]
  216f32:	f7fe fe1b 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216f36:	e26e      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("y")){ DECR_WRAP(Circle.fill[2],1,0,255);  SCREEN_Test_Circle(); }
  216f38:	4874      	ldr	r0, [pc, #464]	; (21710c <SCREEN_ReadPanel+0xe2c>)
  216f3a:	f7e9 fd31 	bl	2009a0 <DEBUG_RcvStr>
  216f3e:	4603      	mov	r3, r0
  216f40:	2b00      	cmp	r3, #0
  216f42:	d011      	beq.n	216f68 <SCREEN_ReadPanel+0xc88>
  216f44:	4b6b      	ldr	r3, [pc, #428]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f46:	7b1b      	ldrb	r3, [r3, #12]
  216f48:	3b01      	subs	r3, #1
  216f4a:	2b00      	cmp	r3, #0
  216f4c:	da03      	bge.n	216f56 <SCREEN_ReadPanel+0xc76>
  216f4e:	4b69      	ldr	r3, [pc, #420]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f50:	22ff      	movs	r2, #255	; 0xff
  216f52:	731a      	strb	r2, [r3, #12]
  216f54:	e005      	b.n	216f62 <SCREEN_ReadPanel+0xc82>
  216f56:	4b67      	ldr	r3, [pc, #412]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f58:	7b1b      	ldrb	r3, [r3, #12]
  216f5a:	3b01      	subs	r3, #1
  216f5c:	b2da      	uxtb	r2, r3
  216f5e:	4b65      	ldr	r3, [pc, #404]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f60:	731a      	strb	r2, [r3, #12]
  216f62:	f7fe fe03 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216f66:	e256      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("h")){ INCR_FLOAT_WRAP(Circle.ratioBk,  0.10, 0.00, 1.00);  SCREEN_Test_Circle(); }
  216f68:	4869      	ldr	r0, [pc, #420]	; (217110 <SCREEN_ReadPanel+0xe30>)
  216f6a:	f7e9 fd19 	bl	2009a0 <DEBUG_RcvStr>
  216f6e:	4603      	mov	r3, r0
  216f70:	2b00      	cmp	r3, #0
  216f72:	d021      	beq.n	216fb8 <SCREEN_ReadPanel+0xcd8>
  216f74:	4b5f      	ldr	r3, [pc, #380]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f76:	edd3 7a04 	vldr	s15, [r3, #16]
  216f7a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  216f7e:	ed9f 6b56 	vldr	d6, [pc, #344]	; 2170d8 <SCREEN_ReadPanel+0xdf8>
  216f82:	eeb4 7bc6 	vcmpe.f64	d7, d6
  216f86:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  216f8a:	d50e      	bpl.n	216faa <SCREEN_ReadPanel+0xcca>
  216f8c:	4b59      	ldr	r3, [pc, #356]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216f8e:	edd3 7a04 	vldr	s15, [r3, #16]
  216f92:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  216f96:	ed9f 6b52 	vldr	d6, [pc, #328]	; 2170e0 <SCREEN_ReadPanel+0xe00>
  216f9a:	ee37 7b06 	vadd.f64	d7, d7, d6
  216f9e:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  216fa2:	4b54      	ldr	r3, [pc, #336]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216fa4:	edc3 7a04 	vstr	s15, [r3, #16]
  216fa8:	e003      	b.n	216fb2 <SCREEN_ReadPanel+0xcd2>
  216faa:	4b52      	ldr	r3, [pc, #328]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216fac:	f04f 0200 	mov.w	r2, #0
  216fb0:	611a      	str	r2, [r3, #16]
  216fb2:	f7fe fddb 	bl	215b6c <SCREEN_Test_Circle>
			break;
  216fb6:	e22e      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("j")){ INCR_FLOAT_WRAP(Circle.ratioFill,0.10, 0.00, 1.00);  SCREEN_Test_Circle(); }
  216fb8:	4856      	ldr	r0, [pc, #344]	; (217114 <SCREEN_ReadPanel+0xe34>)
  216fba:	f7e9 fcf1 	bl	2009a0 <DEBUG_RcvStr>
  216fbe:	4603      	mov	r3, r0
  216fc0:	2b00      	cmp	r3, #0
  216fc2:	d021      	beq.n	217008 <SCREEN_ReadPanel+0xd28>
  216fc4:	4b4b      	ldr	r3, [pc, #300]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216fc6:	edd3 7a05 	vldr	s15, [r3, #20]
  216fca:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  216fce:	ed9f 6b42 	vldr	d6, [pc, #264]	; 2170d8 <SCREEN_ReadPanel+0xdf8>
  216fd2:	eeb4 7bc6 	vcmpe.f64	d7, d6
  216fd6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  216fda:	d50e      	bpl.n	216ffa <SCREEN_ReadPanel+0xd1a>
  216fdc:	4b45      	ldr	r3, [pc, #276]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216fde:	edd3 7a05 	vldr	s15, [r3, #20]
  216fe2:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  216fe6:	ed9f 6b3e 	vldr	d6, [pc, #248]	; 2170e0 <SCREEN_ReadPanel+0xe00>
  216fea:	ee37 7b06 	vadd.f64	d7, d7, d6
  216fee:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  216ff2:	4b40      	ldr	r3, [pc, #256]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ff4:	edc3 7a05 	vstr	s15, [r3, #20]
  216ff8:	e003      	b.n	217002 <SCREEN_ReadPanel+0xd22>
  216ffa:	4b3e      	ldr	r3, [pc, #248]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  216ffc:	f04f 0200 	mov.w	r2, #0
  217000:	615a      	str	r2, [r3, #20]
  217002:	f7fe fdb3 	bl	215b6c <SCREEN_Test_Circle>
			break;
  217006:	e206      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("n")){ DECR_FLOAT_WRAP(Circle.ratioBk  ,0.10, 0.00, 1.00);  SCREEN_Test_Circle(); }
  217008:	4843      	ldr	r0, [pc, #268]	; (217118 <SCREEN_ReadPanel+0xe38>)
  21700a:	f7e9 fcc9 	bl	2009a0 <DEBUG_RcvStr>
  21700e:	4603      	mov	r3, r0
  217010:	2b00      	cmp	r3, #0
  217012:	d021      	beq.n	217058 <SCREEN_ReadPanel+0xd78>
  217014:	4b37      	ldr	r3, [pc, #220]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  217016:	edd3 7a04 	vldr	s15, [r3, #16]
  21701a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  21701e:	ed9f 6b32 	vldr	d6, [pc, #200]	; 2170e8 <SCREEN_ReadPanel+0xe08>
  217022:	eeb4 7bc6 	vcmpe.f64	d7, d6
  217026:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  21702a:	d504      	bpl.n	217036 <SCREEN_ReadPanel+0xd56>
  21702c:	4b31      	ldr	r3, [pc, #196]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  21702e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  217032:	611a      	str	r2, [r3, #16]
  217034:	e00d      	b.n	217052 <SCREEN_ReadPanel+0xd72>
  217036:	4b2f      	ldr	r3, [pc, #188]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  217038:	edd3 7a04 	vldr	s15, [r3, #16]
  21703c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  217040:	ed9f 6b27 	vldr	d6, [pc, #156]	; 2170e0 <SCREEN_ReadPanel+0xe00>
  217044:	ee37 7b46 	vsub.f64	d7, d7, d6
  217048:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  21704c:	4b29      	ldr	r3, [pc, #164]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  21704e:	edc3 7a04 	vstr	s15, [r3, #16]
  217052:	f7fe fd8b 	bl	215b6c <SCREEN_Test_Circle>
			break;
  217056:	e1de      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("m")){ DECR_FLOAT_WRAP(Circle.ratioFill,0.10, 0.00, 1.00);  SCREEN_Test_Circle(); }
  217058:	4830      	ldr	r0, [pc, #192]	; (21711c <SCREEN_ReadPanel+0xe3c>)
  21705a:	f7e9 fca1 	bl	2009a0 <DEBUG_RcvStr>
  21705e:	4603      	mov	r3, r0
  217060:	2b00      	cmp	r3, #0
  217062:	d021      	beq.n	2170a8 <SCREEN_ReadPanel+0xdc8>
  217064:	4b23      	ldr	r3, [pc, #140]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  217066:	edd3 7a05 	vldr	s15, [r3, #20]
  21706a:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  21706e:	ed9f 6b1e 	vldr	d6, [pc, #120]	; 2170e8 <SCREEN_ReadPanel+0xe08>
  217072:	eeb4 7bc6 	vcmpe.f64	d7, d6
  217076:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  21707a:	d504      	bpl.n	217086 <SCREEN_ReadPanel+0xda6>
  21707c:	4b1d      	ldr	r3, [pc, #116]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  21707e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
  217082:	615a      	str	r2, [r3, #20]
  217084:	e00d      	b.n	2170a2 <SCREEN_ReadPanel+0xdc2>
  217086:	4b1b      	ldr	r3, [pc, #108]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  217088:	edd3 7a05 	vldr	s15, [r3, #20]
  21708c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
  217090:	ed9f 6b13 	vldr	d6, [pc, #76]	; 2170e0 <SCREEN_ReadPanel+0xe00>
  217094:	ee37 7b46 	vsub.f64	d7, d7, d6
  217098:	eef7 7bc7 	vcvt.f32.f64	s15, d7
  21709c:	4b15      	ldr	r3, [pc, #84]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  21709e:	edc3 7a05 	vstr	s15, [r3, #20]
  2170a2:	f7fe fd63 	bl	215b6c <SCREEN_Test_Circle>
			break;
  2170a6:	e1b6      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("g")){ INCR_WRAP(Circle.bold,1,0,Circle.width/6-1);  SCREEN_Test_Circle(); }
  2170a8:	481d      	ldr	r0, [pc, #116]	; (217120 <SCREEN_ReadPanel+0xe40>)
  2170aa:	f7e9 fc79 	bl	2009a0 <DEBUG_RcvStr>
  2170ae:	4603      	mov	r3, r0
  2170b0:	2b00      	cmp	r3, #0
  2170b2:	d042      	beq.n	21713a <SCREEN_ReadPanel+0xe5a>
  2170b4:	4b0f      	ldr	r3, [pc, #60]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  2170b6:	7f1b      	ldrb	r3, [r3, #28]
  2170b8:	1c5a      	adds	r2, r3, #1
  2170ba:	4b0e      	ldr	r3, [pc, #56]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  2170bc:	885b      	ldrh	r3, [r3, #2]
  2170be:	4919      	ldr	r1, [pc, #100]	; (217124 <SCREEN_ReadPanel+0xe44>)
  2170c0:	fba1 1303 	umull	r1, r3, r1, r3
  2170c4:	089b      	lsrs	r3, r3, #2
  2170c6:	b29b      	uxth	r3, r3
  2170c8:	3b01      	subs	r3, #1
  2170ca:	429a      	cmp	r2, r3
  2170cc:	dd2c      	ble.n	217128 <SCREEN_ReadPanel+0xe48>
  2170ce:	4b09      	ldr	r3, [pc, #36]	; (2170f4 <SCREEN_ReadPanel+0xe14>)
  2170d0:	2200      	movs	r2, #0
  2170d2:	771a      	strb	r2, [r3, #28]
  2170d4:	e02e      	b.n	217134 <SCREEN_ReadPanel+0xe54>
  2170d6:	bf00      	nop
  2170d8:	66666666 	.word	0x66666666
  2170dc:	3fee6666 	.word	0x3fee6666
  2170e0:	9999999a 	.word	0x9999999a
  2170e4:	3fb99999 	.word	0x3fb99999
  2170e8:	9999999a 	.word	0x9999999a
  2170ec:	3fa99999 	.word	0x3fa99999
  2170f0:	00228e40 	.word	0x00228e40
  2170f4:	200104e8 	.word	0x200104e8
  2170f8:	0022919c 	.word	0x0022919c
  2170fc:	002291a0 	.word	0x002291a0
  217100:	002291a8 	.word	0x002291a8
  217104:	00229130 	.word	0x00229130
  217108:	00229134 	.word	0x00229134
  21710c:	00229138 	.word	0x00229138
  217110:	00229164 	.word	0x00229164
  217114:	0022916c 	.word	0x0022916c
  217118:	002291ac 	.word	0x002291ac
  21711c:	00229160 	.word	0x00229160
  217120:	00229124 	.word	0x00229124
  217124:	aaaaaaab 	.word	0xaaaaaaab
  217128:	4b9b      	ldr	r3, [pc, #620]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21712a:	7f1b      	ldrb	r3, [r3, #28]
  21712c:	3301      	adds	r3, #1
  21712e:	b2da      	uxtb	r2, r3
  217130:	4b99      	ldr	r3, [pc, #612]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217132:	771a      	strb	r2, [r3, #28]
  217134:	f7fe fd1a 	bl	215b6c <SCREEN_Test_Circle>
			break;
  217138:	e16d      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("b")){ DECR_WRAP(Circle.bold,1,0,Circle.width/6-1);  SCREEN_Test_Circle(); }
  21713a:	4898      	ldr	r0, [pc, #608]	; (21739c <SCREEN_ReadPanel+0x10bc>)
  21713c:	f7e9 fc30 	bl	2009a0 <DEBUG_RcvStr>
  217140:	4603      	mov	r3, r0
  217142:	2b00      	cmp	r3, #0
  217144:	d01a      	beq.n	21717c <SCREEN_ReadPanel+0xe9c>
  217146:	4b94      	ldr	r3, [pc, #592]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217148:	7f1b      	ldrb	r3, [r3, #28]
  21714a:	3b01      	subs	r3, #1
  21714c:	2b00      	cmp	r3, #0
  21714e:	da0c      	bge.n	21716a <SCREEN_ReadPanel+0xe8a>
  217150:	4b91      	ldr	r3, [pc, #580]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217152:	885b      	ldrh	r3, [r3, #2]
  217154:	4a92      	ldr	r2, [pc, #584]	; (2173a0 <SCREEN_ReadPanel+0x10c0>)
  217156:	fba2 2303 	umull	r2, r3, r2, r3
  21715a:	089b      	lsrs	r3, r3, #2
  21715c:	b29b      	uxth	r3, r3
  21715e:	b2db      	uxtb	r3, r3
  217160:	3b01      	subs	r3, #1
  217162:	b2da      	uxtb	r2, r3
  217164:	4b8c      	ldr	r3, [pc, #560]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217166:	771a      	strb	r2, [r3, #28]
  217168:	e005      	b.n	217176 <SCREEN_ReadPanel+0xe96>
  21716a:	4b8b      	ldr	r3, [pc, #556]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21716c:	7f1b      	ldrb	r3, [r3, #28]
  21716e:	3b01      	subs	r3, #1
  217170:	b2da      	uxtb	r2, r3
  217172:	4b89      	ldr	r3, [pc, #548]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217174:	771a      	strb	r2, [r3, #28]
  217176:	f7fe fcf9 	bl	215b6c <SCREEN_Test_Circle>
			break;
  21717a:	e14c      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("o")){ INCR_WRAP(Circle.halfCircle,1,0,3);  SCREEN_Test_Circle(); }
  21717c:	4889      	ldr	r0, [pc, #548]	; (2173a4 <SCREEN_ReadPanel+0x10c4>)
  21717e:	f7e9 fc0f 	bl	2009a0 <DEBUG_RcvStr>
  217182:	4603      	mov	r3, r0
  217184:	2b00      	cmp	r3, #0
  217186:	d011      	beq.n	2171ac <SCREEN_ReadPanel+0xecc>
  217188:	4b83      	ldr	r3, [pc, #524]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21718a:	7f5b      	ldrb	r3, [r3, #29]
  21718c:	3301      	adds	r3, #1
  21718e:	2b03      	cmp	r3, #3
  217190:	dd03      	ble.n	21719a <SCREEN_ReadPanel+0xeba>
  217192:	4b81      	ldr	r3, [pc, #516]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217194:	2200      	movs	r2, #0
  217196:	775a      	strb	r2, [r3, #29]
  217198:	e005      	b.n	2171a6 <SCREEN_ReadPanel+0xec6>
  21719a:	4b7f      	ldr	r3, [pc, #508]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21719c:	7f5b      	ldrb	r3, [r3, #29]
  21719e:	3301      	adds	r3, #1
  2171a0:	b2da      	uxtb	r2, r3
  2171a2:	4b7d      	ldr	r3, [pc, #500]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171a4:	775a      	strb	r2, [r3, #29]
  2171a6:	f7fe fce1 	bl	215b6c <SCREEN_Test_Circle>
			break;
  2171aa:	e134      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("k")){ DECR(Circle.deg[0],1,0);   SCREEN_Test_Circle(); }
  2171ac:	487e      	ldr	r0, [pc, #504]	; (2173a8 <SCREEN_ReadPanel+0x10c8>)
  2171ae:	f7e9 fbf7 	bl	2009a0 <DEBUG_RcvStr>
  2171b2:	4603      	mov	r3, r0
  2171b4:	2b00      	cmp	r3, #0
  2171b6:	d011      	beq.n	2171dc <SCREEN_ReadPanel+0xefc>
  2171b8:	4b77      	ldr	r3, [pc, #476]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171ba:	8bdb      	ldrh	r3, [r3, #30]
  2171bc:	3b01      	subs	r3, #1
  2171be:	2b00      	cmp	r3, #0
  2171c0:	da03      	bge.n	2171ca <SCREEN_ReadPanel+0xeea>
  2171c2:	4b75      	ldr	r3, [pc, #468]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171c4:	2200      	movs	r2, #0
  2171c6:	83da      	strh	r2, [r3, #30]
  2171c8:	e005      	b.n	2171d6 <SCREEN_ReadPanel+0xef6>
  2171ca:	4b73      	ldr	r3, [pc, #460]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171cc:	8bdb      	ldrh	r3, [r3, #30]
  2171ce:	3b01      	subs	r3, #1
  2171d0:	b29a      	uxth	r2, r3
  2171d2:	4b71      	ldr	r3, [pc, #452]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171d4:	83da      	strh	r2, [r3, #30]
  2171d6:	f7fe fcc9 	bl	215b6c <SCREEN_Test_Circle>
			break;
  2171da:	e11c      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("l")){ INCR(Circle.deg[0],1,Circle.deg[1]-1);  SCREEN_Test_Circle(); }
  2171dc:	4873      	ldr	r0, [pc, #460]	; (2173ac <SCREEN_ReadPanel+0x10cc>)
  2171de:	f7e9 fbdf 	bl	2009a0 <DEBUG_RcvStr>
  2171e2:	4603      	mov	r3, r0
  2171e4:	2b00      	cmp	r3, #0
  2171e6:	d017      	beq.n	217218 <SCREEN_ReadPanel+0xf38>
  2171e8:	4b6b      	ldr	r3, [pc, #428]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171ea:	8bdb      	ldrh	r3, [r3, #30]
  2171ec:	1c5a      	adds	r2, r3, #1
  2171ee:	4b6a      	ldr	r3, [pc, #424]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171f0:	8c1b      	ldrh	r3, [r3, #32]
  2171f2:	3b01      	subs	r3, #1
  2171f4:	429a      	cmp	r2, r3
  2171f6:	dd06      	ble.n	217206 <SCREEN_ReadPanel+0xf26>
  2171f8:	4b67      	ldr	r3, [pc, #412]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2171fa:	8c1b      	ldrh	r3, [r3, #32]
  2171fc:	3b01      	subs	r3, #1
  2171fe:	b29a      	uxth	r2, r3
  217200:	4b65      	ldr	r3, [pc, #404]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217202:	83da      	strh	r2, [r3, #30]
  217204:	e005      	b.n	217212 <SCREEN_ReadPanel+0xf32>
  217206:	4b64      	ldr	r3, [pc, #400]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217208:	8bdb      	ldrh	r3, [r3, #30]
  21720a:	3301      	adds	r3, #1
  21720c:	b29a      	uxth	r2, r3
  21720e:	4b62      	ldr	r3, [pc, #392]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217210:	83da      	strh	r2, [r3, #30]
  217212:	f7fe fcab 	bl	215b6c <SCREEN_Test_Circle>
			break;
  217216:	e0fe      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("k")){ DECR(Circle.deg[0],1,0);   SCREEN_Test_Circle(); }
  217218:	4863      	ldr	r0, [pc, #396]	; (2173a8 <SCREEN_ReadPanel+0x10c8>)
  21721a:	f7e9 fbc1 	bl	2009a0 <DEBUG_RcvStr>
  21721e:	4603      	mov	r3, r0
  217220:	2b00      	cmp	r3, #0
  217222:	d011      	beq.n	217248 <SCREEN_ReadPanel+0xf68>
  217224:	4b5c      	ldr	r3, [pc, #368]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217226:	8bdb      	ldrh	r3, [r3, #30]
  217228:	3b01      	subs	r3, #1
  21722a:	2b00      	cmp	r3, #0
  21722c:	da03      	bge.n	217236 <SCREEN_ReadPanel+0xf56>
  21722e:	4b5a      	ldr	r3, [pc, #360]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217230:	2200      	movs	r2, #0
  217232:	83da      	strh	r2, [r3, #30]
  217234:	e005      	b.n	217242 <SCREEN_ReadPanel+0xf62>
  217236:	4b58      	ldr	r3, [pc, #352]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217238:	8bdb      	ldrh	r3, [r3, #30]
  21723a:	3b01      	subs	r3, #1
  21723c:	b29a      	uxth	r2, r3
  21723e:	4b56      	ldr	r3, [pc, #344]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217240:	83da      	strh	r2, [r3, #30]
  217242:	f7fe fc93 	bl	215b6c <SCREEN_Test_Circle>
			break;
  217246:	e0e6      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("l")){ INCR(Circle.deg[0],1,360);  SCREEN_Test_Circle(); }
  217248:	4858      	ldr	r0, [pc, #352]	; (2173ac <SCREEN_ReadPanel+0x10cc>)
  21724a:	f7e9 fba9 	bl	2009a0 <DEBUG_RcvStr>
  21724e:	4603      	mov	r3, r0
  217250:	2b00      	cmp	r3, #0
  217252:	d013      	beq.n	21727c <SCREEN_ReadPanel+0xf9c>
  217254:	4b50      	ldr	r3, [pc, #320]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217256:	8bdb      	ldrh	r3, [r3, #30]
  217258:	3301      	adds	r3, #1
  21725a:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  21725e:	dd04      	ble.n	21726a <SCREEN_ReadPanel+0xf8a>
  217260:	4b4d      	ldr	r3, [pc, #308]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217262:	f44f 72b4 	mov.w	r2, #360	; 0x168
  217266:	83da      	strh	r2, [r3, #30]
  217268:	e005      	b.n	217276 <SCREEN_ReadPanel+0xf96>
  21726a:	4b4b      	ldr	r3, [pc, #300]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21726c:	8bdb      	ldrh	r3, [r3, #30]
  21726e:	3301      	adds	r3, #1
  217270:	b29a      	uxth	r2, r3
  217272:	4b49      	ldr	r3, [pc, #292]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217274:	83da      	strh	r2, [r3, #30]
  217276:	f7fe fc79 	bl	215b6c <SCREEN_Test_Circle>
			break;
  21727a:	e0cc      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr(",")){ DECR(Circle.deg[1],1,Circle.deg[0]+1);    SCREEN_Test_Circle(); }
  21727c:	484c      	ldr	r0, [pc, #304]	; (2173b0 <SCREEN_ReadPanel+0x10d0>)
  21727e:	f7e9 fb8f 	bl	2009a0 <DEBUG_RcvStr>
  217282:	4603      	mov	r3, r0
  217284:	2b00      	cmp	r3, #0
  217286:	d017      	beq.n	2172b8 <SCREEN_ReadPanel+0xfd8>
  217288:	4b43      	ldr	r3, [pc, #268]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21728a:	8c1b      	ldrh	r3, [r3, #32]
  21728c:	1e5a      	subs	r2, r3, #1
  21728e:	4b42      	ldr	r3, [pc, #264]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217290:	8bdb      	ldrh	r3, [r3, #30]
  217292:	3301      	adds	r3, #1
  217294:	429a      	cmp	r2, r3
  217296:	da06      	bge.n	2172a6 <SCREEN_ReadPanel+0xfc6>
  217298:	4b3f      	ldr	r3, [pc, #252]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21729a:	8bdb      	ldrh	r3, [r3, #30]
  21729c:	3301      	adds	r3, #1
  21729e:	b29a      	uxth	r2, r3
  2172a0:	4b3d      	ldr	r3, [pc, #244]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172a2:	841a      	strh	r2, [r3, #32]
  2172a4:	e005      	b.n	2172b2 <SCREEN_ReadPanel+0xfd2>
  2172a6:	4b3c      	ldr	r3, [pc, #240]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172a8:	8c1b      	ldrh	r3, [r3, #32]
  2172aa:	3b01      	subs	r3, #1
  2172ac:	b29a      	uxth	r2, r3
  2172ae:	4b3a      	ldr	r3, [pc, #232]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172b0:	841a      	strh	r2, [r3, #32]
  2172b2:	f7fe fc5b 	bl	215b6c <SCREEN_Test_Circle>
			break;
  2172b6:	e0ae      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr(".")){ INCR(Circle.deg[1],1,Circle.deg[2]-1);   SCREEN_Test_Circle(); }
  2172b8:	483e      	ldr	r0, [pc, #248]	; (2173b4 <SCREEN_ReadPanel+0x10d4>)
  2172ba:	f7e9 fb71 	bl	2009a0 <DEBUG_RcvStr>
  2172be:	4603      	mov	r3, r0
  2172c0:	2b00      	cmp	r3, #0
  2172c2:	d017      	beq.n	2172f4 <SCREEN_ReadPanel+0x1014>
  2172c4:	4b34      	ldr	r3, [pc, #208]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172c6:	8c1b      	ldrh	r3, [r3, #32]
  2172c8:	1c5a      	adds	r2, r3, #1
  2172ca:	4b33      	ldr	r3, [pc, #204]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172cc:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  2172ce:	3b01      	subs	r3, #1
  2172d0:	429a      	cmp	r2, r3
  2172d2:	dd06      	ble.n	2172e2 <SCREEN_ReadPanel+0x1002>
  2172d4:	4b30      	ldr	r3, [pc, #192]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172d6:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  2172d8:	3b01      	subs	r3, #1
  2172da:	b29a      	uxth	r2, r3
  2172dc:	4b2e      	ldr	r3, [pc, #184]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172de:	841a      	strh	r2, [r3, #32]
  2172e0:	e005      	b.n	2172ee <SCREEN_ReadPanel+0x100e>
  2172e2:	4b2d      	ldr	r3, [pc, #180]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172e4:	8c1b      	ldrh	r3, [r3, #32]
  2172e6:	3301      	adds	r3, #1
  2172e8:	b29a      	uxth	r2, r3
  2172ea:	4b2b      	ldr	r3, [pc, #172]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  2172ec:	841a      	strh	r2, [r3, #32]
  2172ee:	f7fe fc3d 	bl	215b6c <SCREEN_Test_Circle>
			break;
  2172f2:	e090      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("9")){ DECR(Circle.deg[2],1,Circle.deg[1]+1);    SCREEN_Test_Circle(); }
  2172f4:	4830      	ldr	r0, [pc, #192]	; (2173b8 <SCREEN_ReadPanel+0x10d8>)
  2172f6:	f7e9 fb53 	bl	2009a0 <DEBUG_RcvStr>
  2172fa:	4603      	mov	r3, r0
  2172fc:	2b00      	cmp	r3, #0
  2172fe:	d017      	beq.n	217330 <SCREEN_ReadPanel+0x1050>
  217300:	4b25      	ldr	r3, [pc, #148]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217302:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  217304:	1e5a      	subs	r2, r3, #1
  217306:	4b24      	ldr	r3, [pc, #144]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217308:	8c1b      	ldrh	r3, [r3, #32]
  21730a:	3301      	adds	r3, #1
  21730c:	429a      	cmp	r2, r3
  21730e:	da06      	bge.n	21731e <SCREEN_ReadPanel+0x103e>
  217310:	4b21      	ldr	r3, [pc, #132]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217312:	8c1b      	ldrh	r3, [r3, #32]
  217314:	3301      	adds	r3, #1
  217316:	b29a      	uxth	r2, r3
  217318:	4b1f      	ldr	r3, [pc, #124]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21731a:	845a      	strh	r2, [r3, #34]	; 0x22
  21731c:	e005      	b.n	21732a <SCREEN_ReadPanel+0x104a>
  21731e:	4b1e      	ldr	r3, [pc, #120]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217320:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  217322:	3b01      	subs	r3, #1
  217324:	b29a      	uxth	r2, r3
  217326:	4b1c      	ldr	r3, [pc, #112]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217328:	845a      	strh	r2, [r3, #34]	; 0x22
  21732a:	f7fe fc1f 	bl	215b6c <SCREEN_Test_Circle>
			break;
  21732e:	e072      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("0")){ INCR(Circle.deg[2],1,Circle.deg[3]-1);   SCREEN_Test_Circle(); }
  217330:	4822      	ldr	r0, [pc, #136]	; (2173bc <SCREEN_ReadPanel+0x10dc>)
  217332:	f7e9 fb35 	bl	2009a0 <DEBUG_RcvStr>
  217336:	4603      	mov	r3, r0
  217338:	2b00      	cmp	r3, #0
  21733a:	d017      	beq.n	21736c <SCREEN_ReadPanel+0x108c>
  21733c:	4b16      	ldr	r3, [pc, #88]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21733e:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  217340:	1c5a      	adds	r2, r3, #1
  217342:	4b15      	ldr	r3, [pc, #84]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217344:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  217346:	3b01      	subs	r3, #1
  217348:	429a      	cmp	r2, r3
  21734a:	dd06      	ble.n	21735a <SCREEN_ReadPanel+0x107a>
  21734c:	4b12      	ldr	r3, [pc, #72]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21734e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  217350:	3b01      	subs	r3, #1
  217352:	b29a      	uxth	r2, r3
  217354:	4b10      	ldr	r3, [pc, #64]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217356:	845a      	strh	r2, [r3, #34]	; 0x22
  217358:	e005      	b.n	217366 <SCREEN_ReadPanel+0x1086>
  21735a:	4b0f      	ldr	r3, [pc, #60]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21735c:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  21735e:	3301      	adds	r3, #1
  217360:	b29a      	uxth	r2, r3
  217362:	4b0d      	ldr	r3, [pc, #52]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217364:	845a      	strh	r2, [r3, #34]	; 0x22
  217366:	f7fe fc01 	bl	215b6c <SCREEN_Test_Circle>
			break;
  21736a:	e054      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("7")){ DECR(Circle.deg[3],1,Circle.deg[2]+1);    SCREEN_Test_Circle(); }
  21736c:	4814      	ldr	r0, [pc, #80]	; (2173c0 <SCREEN_ReadPanel+0x10e0>)
  21736e:	f7e9 fb17 	bl	2009a0 <DEBUG_RcvStr>
  217372:	4603      	mov	r3, r0
  217374:	2b00      	cmp	r3, #0
  217376:	d02e      	beq.n	2173d6 <SCREEN_ReadPanel+0x10f6>
  217378:	4b07      	ldr	r3, [pc, #28]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21737a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  21737c:	1e5a      	subs	r2, r3, #1
  21737e:	4b06      	ldr	r3, [pc, #24]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217380:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  217382:	3301      	adds	r3, #1
  217384:	429a      	cmp	r2, r3
  217386:	da1d      	bge.n	2173c4 <SCREEN_ReadPanel+0x10e4>
  217388:	4b03      	ldr	r3, [pc, #12]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  21738a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
  21738c:	3301      	adds	r3, #1
  21738e:	b29a      	uxth	r2, r3
  217390:	4b01      	ldr	r3, [pc, #4]	; (217398 <SCREEN_ReadPanel+0x10b8>)
  217392:	849a      	strh	r2, [r3, #36]	; 0x24
  217394:	e01c      	b.n	2173d0 <SCREEN_ReadPanel+0x10f0>
  217396:	bf00      	nop
  217398:	200104e8 	.word	0x200104e8
  21739c:	00229128 	.word	0x00229128
  2173a0:	aaaaaaab 	.word	0xaaaaaaab
  2173a4:	0022915c 	.word	0x0022915c
  2173a8:	002291b0 	.word	0x002291b0
  2173ac:	002291b4 	.word	0x002291b4
  2173b0:	002291b8 	.word	0x002291b8
  2173b4:	002291bc 	.word	0x002291bc
  2173b8:	002291c0 	.word	0x002291c0
  2173bc:	00229144 	.word	0x00229144
  2173c0:	002291c4 	.word	0x002291c4
  2173c4:	4b26      	ldr	r3, [pc, #152]	; (217460 <SCREEN_ReadPanel+0x1180>)
  2173c6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  2173c8:	3b01      	subs	r3, #1
  2173ca:	b29a      	uxth	r2, r3
  2173cc:	4b24      	ldr	r3, [pc, #144]	; (217460 <SCREEN_ReadPanel+0x1180>)
  2173ce:	849a      	strh	r2, [r3, #36]	; 0x24
  2173d0:	f7fe fbcc 	bl	215b6c <SCREEN_Test_Circle>
			break;
  2173d4:	e01f      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			else if(DEBUG_RcvStr("8")){ INCR(Circle.deg[3],1,360);   SCREEN_Test_Circle(); }  //TU ograniczenie do ostatniego degree a nie do 360 !!!!
  2173d6:	4823      	ldr	r0, [pc, #140]	; (217464 <SCREEN_ReadPanel+0x1184>)
  2173d8:	f7e9 fae2 	bl	2009a0 <DEBUG_RcvStr>
  2173dc:	4603      	mov	r3, r0
  2173de:	2b00      	cmp	r3, #0
  2173e0:	d019      	beq.n	217416 <SCREEN_ReadPanel+0x1136>
  2173e2:	4b1f      	ldr	r3, [pc, #124]	; (217460 <SCREEN_ReadPanel+0x1180>)
  2173e4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  2173e6:	3301      	adds	r3, #1
  2173e8:	f5b3 7fb4 	cmp.w	r3, #360	; 0x168
  2173ec:	dd04      	ble.n	2173f8 <SCREEN_ReadPanel+0x1118>
  2173ee:	4b1c      	ldr	r3, [pc, #112]	; (217460 <SCREEN_ReadPanel+0x1180>)
  2173f0:	f44f 72b4 	mov.w	r2, #360	; 0x168
  2173f4:	849a      	strh	r2, [r3, #36]	; 0x24
  2173f6:	e005      	b.n	217404 <SCREEN_ReadPanel+0x1124>
  2173f8:	4b19      	ldr	r3, [pc, #100]	; (217460 <SCREEN_ReadPanel+0x1180>)
  2173fa:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
  2173fc:	3301      	adds	r3, #1
  2173fe:	b29a      	uxth	r2, r3
  217400:	4b17      	ldr	r3, [pc, #92]	; (217460 <SCREEN_ReadPanel+0x1180>)
  217402:	849a      	strh	r2, [r3, #36]	; 0x24
  217404:	f7fe fbb2 	bl	215b6c <SCREEN_Test_Circle>
			break;
  217408:	e005      	b.n	217416 <SCREEN_ReadPanel+0x1136>
			break;
  21740a:	bf00      	nop
  21740c:	e004      	b.n	217418 <SCREEN_ReadPanel+0x1138>
			break;
  21740e:	bf00      	nop
  217410:	e002      	b.n	217418 <SCREEN_ReadPanel+0x1138>
			break;
  217412:	bf00      	nop
  217414:	e000      	b.n	217418 <SCREEN_ReadPanel+0x1138>
			break;
  217416:	bf00      	nop
	//if(IsRefreshScreenTimeout(refresh_8,50)) LCD_StrMovVIndirect_TEST(STR_ID_MovFonts_8,1);




	if(DEBUG_RcvStr("=")){ startScreen=0; INCR_WRAP(SCREEN_number,1,0,4); }
  217418:	4813      	ldr	r0, [pc, #76]	; (217468 <SCREEN_ReadPanel+0x1188>)
  21741a:	f7e9 fac1 	bl	2009a0 <DEBUG_RcvStr>
  21741e:	4603      	mov	r3, r0
  217420:	2b00      	cmp	r3, #0
  217422:	d010      	beq.n	217446 <SCREEN_ReadPanel+0x1166>
  217424:	4b11      	ldr	r3, [pc, #68]	; (21746c <SCREEN_ReadPanel+0x118c>)
  217426:	2200      	movs	r2, #0
  217428:	601a      	str	r2, [r3, #0]
  21742a:	4b11      	ldr	r3, [pc, #68]	; (217470 <SCREEN_ReadPanel+0x1190>)
  21742c:	681b      	ldr	r3, [r3, #0]
  21742e:	3301      	adds	r3, #1
  217430:	2b04      	cmp	r3, #4
  217432:	dd03      	ble.n	21743c <SCREEN_ReadPanel+0x115c>
  217434:	4b0e      	ldr	r3, [pc, #56]	; (217470 <SCREEN_ReadPanel+0x1190>)
  217436:	2200      	movs	r2, #0
  217438:	601a      	str	r2, [r3, #0]
  21743a:	e004      	b.n	217446 <SCREEN_ReadPanel+0x1166>
  21743c:	4b0c      	ldr	r3, [pc, #48]	; (217470 <SCREEN_ReadPanel+0x1190>)
  21743e:	681b      	ldr	r3, [r3, #0]
  217440:	3301      	adds	r3, #1
  217442:	4a0b      	ldr	r2, [pc, #44]	; (217470 <SCREEN_ReadPanel+0x1190>)
  217444:	6013      	str	r3, [r2, #0]
	if(DEBUG_RcvStr("n")) LCD_DisplayStrMovBuffState();
  217446:	480b      	ldr	r0, [pc, #44]	; (217474 <SCREEN_ReadPanel+0x1194>)
  217448:	f7e9 faaa 	bl	2009a0 <DEBUG_RcvStr>
  21744c:	4603      	mov	r3, r0
  21744e:	2b00      	cmp	r3, #0
  217450:	d001      	beq.n	217456 <SCREEN_ReadPanel+0x1176>
  217452:	f7f5 fe83 	bl	20d15c <LCD_DisplayStrMovBuffState>


}
  217456:	bf00      	nop
  217458:	370c      	adds	r7, #12
  21745a:	46bd      	mov	sp, r7
  21745c:	bd90      	pop	{r4, r7, pc}
  21745e:	bf00      	nop
  217460:	200104e8 	.word	0x200104e8
  217464:	002291c8 	.word	0x002291c8
  217468:	002291cc 	.word	0x002291cc
  21746c:	200104cc 	.word	0x200104cc
  217470:	20000000 	.word	0x20000000
  217474:	002291ac 	.word	0x002291ac

00217478 <SetLang>:
static char bufTemp[MAX_BUFTEMP];

Language Lang;

void SetLang(int howMuch, int what)
{
  217478:	b480      	push	{r7}
  21747a:	b083      	sub	sp, #12
  21747c:	af00      	add	r7, sp, #0
  21747e:	6078      	str	r0, [r7, #4]
  217480:	6039      	str	r1, [r7, #0]
	Lang.howMuch=howMuch;
  217482:	4a06      	ldr	r2, [pc, #24]	; (21749c <SetLang+0x24>)
  217484:	687b      	ldr	r3, [r7, #4]
  217486:	6013      	str	r3, [r2, #0]
	Lang.what=what;
  217488:	4a04      	ldr	r2, [pc, #16]	; (21749c <SetLang+0x24>)
  21748a:	683b      	ldr	r3, [r7, #0]
  21748c:	6053      	str	r3, [r2, #4]
}
  21748e:	bf00      	nop
  217490:	370c      	adds	r7, #12
  217492:	46bd      	mov	sp, r7
  217494:	f85d 7b04 	ldr.w	r7, [sp], #4
  217498:	4770      	bx	lr
  21749a:	bf00      	nop
  21749c:	20014a4c 	.word	0x20014a4c

002174a0 <GetSelTxt>:

char* GetSelTxt(int nrBuff, const char* txt, int line)
{
  2174a0:	b580      	push	{r7, lr}
  2174a2:	b088      	sub	sp, #32
  2174a4:	af00      	add	r7, sp, #0
  2174a6:	60f8      	str	r0, [r7, #12]
  2174a8:	60b9      	str	r1, [r7, #8]
  2174aa:	607a      	str	r2, [r7, #4]
	int i, j;
	const char *ptr=txt;
  2174ac:	68bb      	ldr	r3, [r7, #8]
  2174ae:	617b      	str	r3, [r7, #20]

	for (i=0; i<line; ++i)
  2174b0:	2300      	movs	r3, #0
  2174b2:	61fb      	str	r3, [r7, #28]
  2174b4:	e014      	b.n	2174e0 <GetSelTxt+0x40>
	{
		for (j=0; j<Lang.howMuch; ++j)
  2174b6:	2300      	movs	r3, #0
  2174b8:	61bb      	str	r3, [r7, #24]
  2174ba:	e009      	b.n	2174d0 <GetSelTxt+0x30>
			ptr=strstr(ptr, ",")+1;
  2174bc:	212c      	movs	r1, #44	; 0x2c
  2174be:	6978      	ldr	r0, [r7, #20]
  2174c0:	f00f f83f 	bl	226542 <strchr>
  2174c4:	4603      	mov	r3, r0
  2174c6:	3301      	adds	r3, #1
  2174c8:	617b      	str	r3, [r7, #20]
		for (j=0; j<Lang.howMuch; ++j)
  2174ca:	69bb      	ldr	r3, [r7, #24]
  2174cc:	3301      	adds	r3, #1
  2174ce:	61bb      	str	r3, [r7, #24]
  2174d0:	4b23      	ldr	r3, [pc, #140]	; (217560 <GetSelTxt+0xc0>)
  2174d2:	681a      	ldr	r2, [r3, #0]
  2174d4:	69bb      	ldr	r3, [r7, #24]
  2174d6:	429a      	cmp	r2, r3
  2174d8:	dcf0      	bgt.n	2174bc <GetSelTxt+0x1c>
	for (i=0; i<line; ++i)
  2174da:	69fb      	ldr	r3, [r7, #28]
  2174dc:	3301      	adds	r3, #1
  2174de:	61fb      	str	r3, [r7, #28]
  2174e0:	69fa      	ldr	r2, [r7, #28]
  2174e2:	687b      	ldr	r3, [r7, #4]
  2174e4:	429a      	cmp	r2, r3
  2174e6:	dbe6      	blt.n	2174b6 <GetSelTxt+0x16>
	}
	for (i=0; i<Lang.what; ++i)
  2174e8:	2300      	movs	r3, #0
  2174ea:	61fb      	str	r3, [r7, #28]
  2174ec:	e009      	b.n	217502 <GetSelTxt+0x62>
		ptr=strstr(ptr, ",")+1;
  2174ee:	212c      	movs	r1, #44	; 0x2c
  2174f0:	6978      	ldr	r0, [r7, #20]
  2174f2:	f00f f826 	bl	226542 <strchr>
  2174f6:	4603      	mov	r3, r0
  2174f8:	3301      	adds	r3, #1
  2174fa:	617b      	str	r3, [r7, #20]
	for (i=0; i<Lang.what; ++i)
  2174fc:	69fb      	ldr	r3, [r7, #28]
  2174fe:	3301      	adds	r3, #1
  217500:	61fb      	str	r3, [r7, #28]
  217502:	4b17      	ldr	r3, [pc, #92]	; (217560 <GetSelTxt+0xc0>)
  217504:	685a      	ldr	r2, [r3, #4]
  217506:	69fb      	ldr	r3, [r7, #28]
  217508:	429a      	cmp	r2, r3
  21750a:	dcf0      	bgt.n	2174ee <GetSelTxt+0x4e>

	i=0;
  21750c:	2300      	movs	r3, #0
  21750e:	61fb      	str	r3, [r7, #28]
	while (ptr[i]!=',')
  217510:	e011      	b.n	217536 <GetSelTxt+0x96>
	{
		if (nrBuff+i>MAX_BUFTEMP-1)
  217512:	68fa      	ldr	r2, [r7, #12]
  217514:	69fb      	ldr	r3, [r7, #28]
  217516:	4413      	add	r3, r2
  217518:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
  21751c:	da12      	bge.n	217544 <GetSelTxt+0xa4>
			break;
		bufTemp[nrBuff+i]=ptr[i];
  21751e:	68fa      	ldr	r2, [r7, #12]
  217520:	69fb      	ldr	r3, [r7, #28]
  217522:	4413      	add	r3, r2
  217524:	69fa      	ldr	r2, [r7, #28]
  217526:	6979      	ldr	r1, [r7, #20]
  217528:	440a      	add	r2, r1
  21752a:	7811      	ldrb	r1, [r2, #0]
  21752c:	4a0d      	ldr	r2, [pc, #52]	; (217564 <GetSelTxt+0xc4>)
  21752e:	54d1      	strb	r1, [r2, r3]
		i++;
  217530:	69fb      	ldr	r3, [r7, #28]
  217532:	3301      	adds	r3, #1
  217534:	61fb      	str	r3, [r7, #28]
	while (ptr[i]!=',')
  217536:	69fb      	ldr	r3, [r7, #28]
  217538:	697a      	ldr	r2, [r7, #20]
  21753a:	4413      	add	r3, r2
  21753c:	781b      	ldrb	r3, [r3, #0]
  21753e:	2b2c      	cmp	r3, #44	; 0x2c
  217540:	d1e7      	bne.n	217512 <GetSelTxt+0x72>
  217542:	e000      	b.n	217546 <GetSelTxt+0xa6>
			break;
  217544:	bf00      	nop
	}
	bufTemp[nrBuff+i]=0;
  217546:	68fa      	ldr	r2, [r7, #12]
  217548:	69fb      	ldr	r3, [r7, #28]
  21754a:	4413      	add	r3, r2
  21754c:	4a05      	ldr	r2, [pc, #20]	; (217564 <GetSelTxt+0xc4>)
  21754e:	2100      	movs	r1, #0
  217550:	54d1      	strb	r1, [r2, r3]
	return &bufTemp[nrBuff];
  217552:	68fb      	ldr	r3, [r7, #12]
  217554:	4a03      	ldr	r2, [pc, #12]	; (217564 <GetSelTxt+0xc4>)
  217556:	4413      	add	r3, r2
}
  217558:	4618      	mov	r0, r3
  21755a:	3720      	adds	r7, #32
  21755c:	46bd      	mov	sp, r7
  21755e:	bd80      	pop	{r7, pc}
  217560:	20014a4c 	.word	0x20014a4c
  217564:	20010544 	.word	0x20010544

00217568 <vApplicationIdleHook>:
  * @brief  Application Idle Hook
  * @param  None
  * @retval None
  */
void vApplicationIdleHook(void)
 {
  217568:	b580      	push	{r7, lr}
  21756a:	af00      	add	r7, sp, #0
  if( xIdleHandle == NULL )
  21756c:	4b05      	ldr	r3, [pc, #20]	; (217584 <vApplicationIdleHook+0x1c>)
  21756e:	681b      	ldr	r3, [r3, #0]
  217570:	2b00      	cmp	r3, #0
  217572:	d104      	bne.n	21757e <vApplicationIdleHook+0x16>
  {
    /* Store the handle to the idle task. */
    xIdleHandle = xTaskGetCurrentTaskHandle();
  217574:	f00e fd18 	bl	225fa8 <xTaskGetCurrentTaskHandle>
  217578:	4602      	mov	r2, r0
  21757a:	4b02      	ldr	r3, [pc, #8]	; (217584 <vApplicationIdleHook+0x1c>)
  21757c:	601a      	str	r2, [r3, #0]
  }
}
  21757e:	bf00      	nop
  217580:	bd80      	pop	{r7, pc}
  217582:	bf00      	nop
  217584:	20010738 	.word	0x20010738

00217588 <vApplicationTickHook>:
  * @brief  Application Idle Hook
  * @param  None
  * @retval None
  */
void vApplicationTickHook (void)
{
  217588:	b480      	push	{r7}
  21758a:	af00      	add	r7, sp, #0
  static int tick = 0;

  if(tick ++ > CALCULATION_PERIOD)
  21758c:	4b15      	ldr	r3, [pc, #84]	; (2175e4 <vApplicationTickHook+0x5c>)
  21758e:	681b      	ldr	r3, [r3, #0]
  217590:	1c5a      	adds	r2, r3, #1
  217592:	4914      	ldr	r1, [pc, #80]	; (2175e4 <vApplicationTickHook+0x5c>)
  217594:	600a      	str	r2, [r1, #0]
  217596:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  21759a:	dd1d      	ble.n	2175d8 <vApplicationTickHook+0x50>
  {
    tick = 0;
  21759c:	4b11      	ldr	r3, [pc, #68]	; (2175e4 <vApplicationTickHook+0x5c>)
  21759e:	2200      	movs	r2, #0
  2175a0:	601a      	str	r2, [r3, #0]

    if(osCPU_TotalIdleTime > CALCULATION_PERIOD)
  2175a2:	4b11      	ldr	r3, [pc, #68]	; (2175e8 <vApplicationTickHook+0x60>)
  2175a4:	681b      	ldr	r3, [r3, #0]
  2175a6:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  2175aa:	d903      	bls.n	2175b4 <vApplicationTickHook+0x2c>
    {
      osCPU_TotalIdleTime = CALCULATION_PERIOD;
  2175ac:	4b0e      	ldr	r3, [pc, #56]	; (2175e8 <vApplicationTickHook+0x60>)
  2175ae:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  2175b2:	601a      	str	r2, [r3, #0]
    }
    osCPU_Usage = (100 - (osCPU_TotalIdleTime * 100) / CALCULATION_PERIOD);
  2175b4:	4b0c      	ldr	r3, [pc, #48]	; (2175e8 <vApplicationTickHook+0x60>)
  2175b6:	681b      	ldr	r3, [r3, #0]
  2175b8:	2264      	movs	r2, #100	; 0x64
  2175ba:	fb02 f303 	mul.w	r3, r2, r3
  2175be:	4a0b      	ldr	r2, [pc, #44]	; (2175ec <vApplicationTickHook+0x64>)
  2175c0:	fba2 2303 	umull	r2, r3, r2, r3
  2175c4:	099b      	lsrs	r3, r3, #6
  2175c6:	b29b      	uxth	r3, r3
  2175c8:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
  2175cc:	b29a      	uxth	r2, r3
  2175ce:	4b08      	ldr	r3, [pc, #32]	; (2175f0 <vApplicationTickHook+0x68>)
  2175d0:	801a      	strh	r2, [r3, #0]
    osCPU_TotalIdleTime = 0;
  2175d2:	4b05      	ldr	r3, [pc, #20]	; (2175e8 <vApplicationTickHook+0x60>)
  2175d4:	2200      	movs	r2, #0
  2175d6:	601a      	str	r2, [r3, #0]
  }
}
  2175d8:	bf00      	nop
  2175da:	46bd      	mov	sp, r7
  2175dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  2175e0:	4770      	bx	lr
  2175e2:	bf00      	nop
  2175e4:	20010744 	.word	0x20010744
  2175e8:	20010740 	.word	0x20010740
  2175ec:	10624dd3 	.word	0x10624dd3
  2175f0:	2001073c 	.word	0x2001073c

002175f4 <osGetCPUUsage>:
  * @brief  Stop Idle monitor
  * @param  None
  * @retval None
  */
unsigned short osGetCPUUsage (void)
{
  2175f4:	b480      	push	{r7}
  2175f6:	af00      	add	r7, sp, #0
  return osCPU_Usage;
  2175f8:	4b03      	ldr	r3, [pc, #12]	; (217608 <osGetCPUUsage+0x14>)
  2175fa:	881b      	ldrh	r3, [r3, #0]
  2175fc:	b29b      	uxth	r3, r3
}
  2175fe:	4618      	mov	r0, r3
  217600:	46bd      	mov	sp, r7
  217602:	f85d 7b04 	ldr.w	r7, [sp], #4
  217606:	4770      	bx	lr
  217608:	2001073c 	.word	0x2001073c

0021760c <MX_DMA_Init>:

/**
  * Enable DMA controller clock
  */
void MX_DMA_Init(void)
{
  21760c:	b580      	push	{r7, lr}
  21760e:	b082      	sub	sp, #8
  217610:	af00      	add	r7, sp, #0

  /* DMA controller clock enable */
  __HAL_RCC_DMA1_CLK_ENABLE();
  217612:	4a1a      	ldr	r2, [pc, #104]	; (21767c <MX_DMA_Init+0x70>)
  217614:	4b19      	ldr	r3, [pc, #100]	; (21767c <MX_DMA_Init+0x70>)
  217616:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217618:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  21761c:	6313      	str	r3, [r2, #48]	; 0x30
  21761e:	4b17      	ldr	r3, [pc, #92]	; (21767c <MX_DMA_Init+0x70>)
  217620:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217622:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  217626:	607b      	str	r3, [r7, #4]
  217628:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_DMA2_CLK_ENABLE();
  21762a:	4a14      	ldr	r2, [pc, #80]	; (21767c <MX_DMA_Init+0x70>)
  21762c:	4b13      	ldr	r3, [pc, #76]	; (21767c <MX_DMA_Init+0x70>)
  21762e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217630:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
  217634:	6313      	str	r3, [r2, #48]	; 0x30
  217636:	4b11      	ldr	r3, [pc, #68]	; (21767c <MX_DMA_Init+0x70>)
  217638:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21763a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  21763e:	603b      	str	r3, [r7, #0]
  217640:	683b      	ldr	r3, [r7, #0]

  /* DMA interrupt init */
  /* DMA1_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 14, 0);
  217642:	2200      	movs	r2, #0
  217644:	210e      	movs	r1, #14
  217646:	200e      	movs	r0, #14
  217648:	f001 fcd6 	bl	218ff8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);
  21764c:	200e      	movs	r0, #14
  21764e:	f001 fcef 	bl	219030 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream3_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
  217652:	2200      	movs	r2, #0
  217654:	2105      	movs	r1, #5
  217656:	203b      	movs	r0, #59	; 0x3b
  217658:	f001 fcce 	bl	218ff8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
  21765c:	203b      	movs	r0, #59	; 0x3b
  21765e:	f001 fce7 	bl	219030 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream6_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream6_IRQn, 5, 0);
  217662:	2200      	movs	r2, #0
  217664:	2105      	movs	r1, #5
  217666:	2045      	movs	r0, #69	; 0x45
  217668:	f001 fcc6 	bl	218ff8 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
  21766c:	2045      	movs	r0, #69	; 0x45
  21766e:	f001 fcdf 	bl	219030 <HAL_NVIC_EnableIRQ>

}
  217672:	bf00      	nop
  217674:	3708      	adds	r7, #8
  217676:	46bd      	mov	sp, r7
  217678:	bd80      	pop	{r7, pc}
  21767a:	bf00      	nop
  21767c:	40023800 	.word	0x40023800

00217680 <MX_DMA2D_Init>:

DMA2D_HandleTypeDef hdma2d;

/* DMA2D init function */
void MX_DMA2D_Init(void)
{
  217680:	b580      	push	{r7, lr}
  217682:	af00      	add	r7, sp, #0
  /* USER CODE END DMA2D_Init 0 */

  /* USER CODE BEGIN DMA2D_Init 1 */

  /* USER CODE END DMA2D_Init 1 */
  hdma2d.Instance = DMA2D;
  217684:	4b18      	ldr	r3, [pc, #96]	; (2176e8 <MX_DMA2D_Init+0x68>)
  217686:	4a19      	ldr	r2, [pc, #100]	; (2176ec <MX_DMA2D_Init+0x6c>)
  217688:	601a      	str	r2, [r3, #0]
  hdma2d.Init.Mode = DMA2D_M2M_PFC;
  21768a:	4b17      	ldr	r3, [pc, #92]	; (2176e8 <MX_DMA2D_Init+0x68>)
  21768c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  217690:	605a      	str	r2, [r3, #4]
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_RGB888;
  217692:	4b15      	ldr	r3, [pc, #84]	; (2176e8 <MX_DMA2D_Init+0x68>)
  217694:	2201      	movs	r2, #1
  217696:	609a      	str	r2, [r3, #8]
  hdma2d.Init.OutputOffset = 0;
  217698:	4b13      	ldr	r3, [pc, #76]	; (2176e8 <MX_DMA2D_Init+0x68>)
  21769a:	2200      	movs	r2, #0
  21769c:	60da      	str	r2, [r3, #12]
  hdma2d.LayerCfg[1].InputOffset = 0;
  21769e:	4b12      	ldr	r3, [pc, #72]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176a0:	2200      	movs	r2, #0
  2176a2:	639a      	str	r2, [r3, #56]	; 0x38
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_ARGB8888;
  2176a4:	4b10      	ldr	r3, [pc, #64]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176a6:	2200      	movs	r2, #0
  2176a8:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
  2176aa:	4b0f      	ldr	r3, [pc, #60]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176ac:	2200      	movs	r2, #0
  2176ae:	641a      	str	r2, [r3, #64]	; 0x40
  hdma2d.LayerCfg[1].InputAlpha = 0;
  2176b0:	4b0d      	ldr	r3, [pc, #52]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176b2:	2200      	movs	r2, #0
  2176b4:	645a      	str	r2, [r3, #68]	; 0x44
  hdma2d.LayerCfg[1].AlphaInverted = DMA2D_REGULAR_ALPHA;
  2176b6:	4b0c      	ldr	r3, [pc, #48]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176b8:	2200      	movs	r2, #0
  2176ba:	649a      	str	r2, [r3, #72]	; 0x48
  hdma2d.LayerCfg[1].RedBlueSwap = DMA2D_RB_REGULAR;
  2176bc:	4b0a      	ldr	r3, [pc, #40]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176be:	2200      	movs	r2, #0
  2176c0:	64da      	str	r2, [r3, #76]	; 0x4c
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
  2176c2:	4809      	ldr	r0, [pc, #36]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176c4:	f002 f94e 	bl	219964 <HAL_DMA2D_Init>
  2176c8:	4603      	mov	r3, r0
  2176ca:	2b00      	cmp	r3, #0
  2176cc:	d001      	beq.n	2176d2 <MX_DMA2D_Init+0x52>
  {
    Error_Handler();
  2176ce:	f000 ff33 	bl	218538 <Error_Handler>
  }
  if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
  2176d2:	2101      	movs	r1, #1
  2176d4:	4804      	ldr	r0, [pc, #16]	; (2176e8 <MX_DMA2D_Init+0x68>)
  2176d6:	f002 fae3 	bl	219ca0 <HAL_DMA2D_ConfigLayer>
  2176da:	4603      	mov	r3, r0
  2176dc:	2b00      	cmp	r3, #0
  2176de:	d001      	beq.n	2176e4 <MX_DMA2D_Init+0x64>
  {
    Error_Handler();
  2176e0:	f000 ff2a 	bl	218538 <Error_Handler>
  }
  /* USER CODE BEGIN DMA2D_Init 2 */

  /* USER CODE END DMA2D_Init 2 */

}
  2176e4:	bf00      	nop
  2176e6:	bd80      	pop	{r7, pc}
  2176e8:	20014a54 	.word	0x20014a54
  2176ec:	4002b000 	.word	0x4002b000

002176f0 <HAL_DMA2D_MspInit>:

void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* dma2dHandle)
{
  2176f0:	b580      	push	{r7, lr}
  2176f2:	b084      	sub	sp, #16
  2176f4:	af00      	add	r7, sp, #0
  2176f6:	6078      	str	r0, [r7, #4]

  if(dma2dHandle->Instance==DMA2D)
  2176f8:	687b      	ldr	r3, [r7, #4]
  2176fa:	681b      	ldr	r3, [r3, #0]
  2176fc:	4a0d      	ldr	r2, [pc, #52]	; (217734 <HAL_DMA2D_MspInit+0x44>)
  2176fe:	4293      	cmp	r3, r2
  217700:	d113      	bne.n	21772a <HAL_DMA2D_MspInit+0x3a>
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */

  /* USER CODE END DMA2D_MspInit 0 */
    /* DMA2D clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
  217702:	4a0d      	ldr	r2, [pc, #52]	; (217738 <HAL_DMA2D_MspInit+0x48>)
  217704:	4b0c      	ldr	r3, [pc, #48]	; (217738 <HAL_DMA2D_MspInit+0x48>)
  217706:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217708:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
  21770c:	6313      	str	r3, [r2, #48]	; 0x30
  21770e:	4b0a      	ldr	r3, [pc, #40]	; (217738 <HAL_DMA2D_MspInit+0x48>)
  217710:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217712:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  217716:	60fb      	str	r3, [r7, #12]
  217718:	68fb      	ldr	r3, [r7, #12]

    /* DMA2D interrupt Init */
    HAL_NVIC_SetPriority(DMA2D_IRQn, 5, 0);
  21771a:	2200      	movs	r2, #0
  21771c:	2105      	movs	r1, #5
  21771e:	205a      	movs	r0, #90	; 0x5a
  217720:	f001 fc6a 	bl	218ff8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DMA2D_IRQn);
  217724:	205a      	movs	r0, #90	; 0x5a
  217726:	f001 fc83 	bl	219030 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN DMA2D_MspInit 1 */

  /* USER CODE END DMA2D_MspInit 1 */
  }
}
  21772a:	bf00      	nop
  21772c:	3710      	adds	r7, #16
  21772e:	46bd      	mov	sp, r7
  217730:	bd80      	pop	{r7, pc}
  217732:	bf00      	nop
  217734:	4002b000 	.word	0x4002b000
  217738:	40023800 	.word	0x40023800

0021773c <SDRAM_Initialization_Sequence>:
#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE     ((uint16_t)0x0200)

FMC_SDRAM_CommandTypeDef command;

void SDRAM_Initialization_Sequence(void)
{
  21773c:	b580      	push	{r7, lr}
  21773e:	b082      	sub	sp, #8
  217740:	af00      	add	r7, sp, #0
	__IO uint32_t tmpmrd = 0;
  217742:	2300      	movs	r3, #0
  217744:	607b      	str	r3, [r7, #4]
	/* Step 3:  Configure a clock configuration enable command */
	command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
  217746:	4b2d      	ldr	r3, [pc, #180]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217748:	2201      	movs	r2, #1
  21774a:	601a      	str	r2, [r3, #0]
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
  21774c:	4b2b      	ldr	r3, [pc, #172]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  21774e:	2210      	movs	r2, #16
  217750:	605a      	str	r2, [r3, #4]
	command.AutoRefreshNumber = 1;
  217752:	4b2a      	ldr	r3, [pc, #168]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217754:	2201      	movs	r2, #1
  217756:	609a      	str	r2, [r3, #8]
	command.ModeRegisterDefinition = 0;
  217758:	4b28      	ldr	r3, [pc, #160]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  21775a:	2200      	movs	r2, #0
  21775c:	60da      	str	r2, [r3, #12]

	/* Send the command */
	HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
  21775e:	f64f 72ff 	movw	r2, #65535	; 0xffff
  217762:	4926      	ldr	r1, [pc, #152]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217764:	4826      	ldr	r0, [pc, #152]	; (217800 <SDRAM_Initialization_Sequence+0xc4>)
  217766:	f005 fcde 	bl	21d126 <HAL_SDRAM_SendCommand>

	/* Step 4: Insert 100 us minimum delay */
	/* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
	HAL_Delay(1);
  21776a:	2001      	movs	r0, #1
  21776c:	f001 fb6c 	bl	218e48 <HAL_Delay>

	/* Step 5: Configure a PALL (precharge all) command */
	command.CommandMode = FMC_SDRAM_CMD_PALL;
  217770:	4b22      	ldr	r3, [pc, #136]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217772:	2202      	movs	r2, #2
  217774:	601a      	str	r2, [r3, #0]
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
  217776:	4b21      	ldr	r3, [pc, #132]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217778:	2210      	movs	r2, #16
  21777a:	605a      	str	r2, [r3, #4]
	command.AutoRefreshNumber = 1;
  21777c:	4b1f      	ldr	r3, [pc, #124]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  21777e:	2201      	movs	r2, #1
  217780:	609a      	str	r2, [r3, #8]
	command.ModeRegisterDefinition = 0;
  217782:	4b1e      	ldr	r3, [pc, #120]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217784:	2200      	movs	r2, #0
  217786:	60da      	str	r2, [r3, #12]

	/* Send the command */
	HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
  217788:	f64f 72ff 	movw	r2, #65535	; 0xffff
  21778c:	491b      	ldr	r1, [pc, #108]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  21778e:	481c      	ldr	r0, [pc, #112]	; (217800 <SDRAM_Initialization_Sequence+0xc4>)
  217790:	f005 fcc9 	bl	21d126 <HAL_SDRAM_SendCommand>

	/* Step 6 : Configure a Auto-Refresh command */
	command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
  217794:	4b19      	ldr	r3, [pc, #100]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  217796:	2203      	movs	r2, #3
  217798:	601a      	str	r2, [r3, #0]
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
  21779a:	4b18      	ldr	r3, [pc, #96]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  21779c:	2210      	movs	r2, #16
  21779e:	605a      	str	r2, [r3, #4]
	command.AutoRefreshNumber = 8;
  2177a0:	4b16      	ldr	r3, [pc, #88]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177a2:	2208      	movs	r2, #8
  2177a4:	609a      	str	r2, [r3, #8]
	command.ModeRegisterDefinition = 0;
  2177a6:	4b15      	ldr	r3, [pc, #84]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177a8:	2200      	movs	r2, #0
  2177aa:	60da      	str	r2, [r3, #12]

	/* Send the command */
	HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
  2177ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
  2177b0:	4912      	ldr	r1, [pc, #72]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177b2:	4813      	ldr	r0, [pc, #76]	; (217800 <SDRAM_Initialization_Sequence+0xc4>)
  2177b4:	f005 fcb7 	bl	21d126 <HAL_SDRAM_SendCommand>

	/* Step 7: Program the external memory mode register */
	tmpmrd = (uint32_t) SDRAM_MODEREG_BURST_LENGTH_4 |
  2177b8:	f240 2322 	movw	r3, #546	; 0x222
  2177bc:	607b      	str	r3, [r7, #4]
	SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL |
	SDRAM_MODEREG_CAS_LATENCY_2 |
	SDRAM_MODEREG_OPERATING_MODE_STANDARD |
	SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;

	command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
  2177be:	4b0f      	ldr	r3, [pc, #60]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177c0:	2204      	movs	r2, #4
  2177c2:	601a      	str	r2, [r3, #0]
	command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
  2177c4:	4b0d      	ldr	r3, [pc, #52]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177c6:	2210      	movs	r2, #16
  2177c8:	605a      	str	r2, [r3, #4]
	command.AutoRefreshNumber = 1;
  2177ca:	4b0c      	ldr	r3, [pc, #48]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177cc:	2201      	movs	r2, #1
  2177ce:	609a      	str	r2, [r3, #8]
	command.ModeRegisterDefinition = tmpmrd;
  2177d0:	687b      	ldr	r3, [r7, #4]
  2177d2:	4a0a      	ldr	r2, [pc, #40]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177d4:	60d3      	str	r3, [r2, #12]

	/* Send the command */
	HAL_SDRAM_SendCommand(&hsdram1, &command, SDRAM_TIMEOUT);
  2177d6:	f64f 72ff 	movw	r2, #65535	; 0xffff
  2177da:	4908      	ldr	r1, [pc, #32]	; (2177fc <SDRAM_Initialization_Sequence+0xc0>)
  2177dc:	4808      	ldr	r0, [pc, #32]	; (217800 <SDRAM_Initialization_Sequence+0xc4>)
  2177de:	f005 fca2 	bl	21d126 <HAL_SDRAM_SendCommand>

	/* Step 8: Set the refresh rate counter */
	/* (15.62 us x Freq) - 20 */
	/* Set the device refresh counter */
	hsdram1.Instance->SDRTR |= ((uint32_t) ((1292) << 1));
  2177e2:	4b07      	ldr	r3, [pc, #28]	; (217800 <SDRAM_Initialization_Sequence+0xc4>)
  2177e4:	681a      	ldr	r2, [r3, #0]
  2177e6:	4b06      	ldr	r3, [pc, #24]	; (217800 <SDRAM_Initialization_Sequence+0xc4>)
  2177e8:	681b      	ldr	r3, [r3, #0]
  2177ea:	6959      	ldr	r1, [r3, #20]
  2177ec:	f640 2318 	movw	r3, #2584	; 0xa18
  2177f0:	430b      	orrs	r3, r1
  2177f2:	6153      	str	r3, [r2, #20]
}
  2177f4:	bf00      	nop
  2177f6:	3708      	adds	r7, #8
  2177f8:	46bd      	mov	sp, r7
  2177fa:	bd80      	pop	{r7, pc}
  2177fc:	20014aac 	.word	0x20014aac
  217800:	20014abc 	.word	0x20014abc

00217804 <TestSDRAM>:

void TestSDRAM(void)
{
  217804:	b580      	push	{r7, lr}
  217806:	b088      	sub	sp, #32
  217808:	af00      	add	r7, sp, #0
	uint32_t WriteReadAddr = 4;
  21780a:	2304      	movs	r3, #4
  21780c:	617b      	str	r3, [r7, #20]
	uint32_t aTxBuffer;
	uint32_t aRxBuffer;

	uint32_t uwWriteReadStatus = 0;
  21780e:	2300      	movs	r3, #0
  217810:	61fb      	str	r3, [r7, #28]

	uint32_t Sdram_addr = 0;
  217812:	2300      	movs	r3, #0
  217814:	613b      	str	r3, [r7, #16]
	long int i, iter;

	iter = SDRAM_DEVICE_SIZE / WriteReadAddr;
  217816:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  21781a:	697b      	ldr	r3, [r7, #20]
  21781c:	fbb2 f3f3 	udiv	r3, r2, r3
  217820:	60fb      	str	r3, [r7, #12]

	//-----------------------------START TEST 1-----------------------------

	for (i = 0; i < iter; i++)
  217822:	2300      	movs	r3, #0
  217824:	61bb      	str	r3, [r7, #24]
  217826:	e00e      	b.n	217846 <TestSDRAM+0x42>
	{
		Sdram_addr = SDRAM_DEVICE_ADDR + WriteReadAddr * i;
  217828:	69bb      	ldr	r3, [r7, #24]
  21782a:	697a      	ldr	r2, [r7, #20]
  21782c:	fb02 f303 	mul.w	r3, r2, r3
  217830:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
  217834:	613b      	str	r3, [r7, #16]
		aTxBuffer = Sdram_addr;
  217836:	693b      	ldr	r3, [r7, #16]
  217838:	60bb      	str	r3, [r7, #8]
		*(volatile uint32_t*) Sdram_addr = aTxBuffer;
  21783a:	693b      	ldr	r3, [r7, #16]
  21783c:	68ba      	ldr	r2, [r7, #8]
  21783e:	601a      	str	r2, [r3, #0]
	for (i = 0; i < iter; i++)
  217840:	69bb      	ldr	r3, [r7, #24]
  217842:	3301      	adds	r3, #1
  217844:	61bb      	str	r3, [r7, #24]
  217846:	69ba      	ldr	r2, [r7, #24]
  217848:	68fb      	ldr	r3, [r7, #12]
  21784a:	429a      	cmp	r2, r3
  21784c:	dbec      	blt.n	217828 <TestSDRAM+0x24>
	}

	for (i = 0; i < iter; i++)
  21784e:	2300      	movs	r3, #0
  217850:	61bb      	str	r3, [r7, #24]
  217852:	e01b      	b.n	21788c <TestSDRAM+0x88>
	{
		aRxBuffer = 0x0;
  217854:	2300      	movs	r3, #0
  217856:	607b      	str	r3, [r7, #4]
		Sdram_addr = SDRAM_DEVICE_ADDR + WriteReadAddr * i;
  217858:	69bb      	ldr	r3, [r7, #24]
  21785a:	697a      	ldr	r2, [r7, #20]
  21785c:	fb02 f303 	mul.w	r3, r2, r3
  217860:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
  217864:	613b      	str	r3, [r7, #16]
		aRxBuffer = *(volatile uint32_t*) Sdram_addr;
  217866:	693b      	ldr	r3, [r7, #16]
  217868:	681b      	ldr	r3, [r3, #0]
  21786a:	607b      	str	r3, [r7, #4]

		if (aRxBuffer != Sdram_addr)
  21786c:	687a      	ldr	r2, [r7, #4]
  21786e:	693b      	ldr	r3, [r7, #16]
  217870:	429a      	cmp	r2, r3
  217872:	d002      	beq.n	21787a <TestSDRAM+0x76>
			uwWriteReadStatus++;
  217874:	69fb      	ldr	r3, [r7, #28]
  217876:	3301      	adds	r3, #1
  217878:	61fb      	str	r3, [r7, #28]

		if (uwWriteReadStatus)
  21787a:	69fb      	ldr	r3, [r7, #28]
  21787c:	2b00      	cmp	r3, #0
  21787e:	d002      	beq.n	217886 <TestSDRAM+0x82>
		{
			ERROR_Sdram();
  217880:	f7e9 fc2a 	bl	2010d8 <ERROR_Sdram>
			break;
  217884:	e006      	b.n	217894 <TestSDRAM+0x90>
	for (i = 0; i < iter; i++)
  217886:	69bb      	ldr	r3, [r7, #24]
  217888:	3301      	adds	r3, #1
  21788a:	61bb      	str	r3, [r7, #24]
  21788c:	69ba      	ldr	r2, [r7, #24]
  21788e:	68fb      	ldr	r3, [r7, #12]
  217890:	429a      	cmp	r2, r3
  217892:	dbdf      	blt.n	217854 <TestSDRAM+0x50>
	if (!uwWriteReadStatus)
	{

	}

	uwWriteReadStatus = 0;
  217894:	2300      	movs	r3, #0
  217896:	61fb      	str	r3, [r7, #28]

	//------------------------------END TEST 1------------------------------

	//-----------------------------START TEST 2-----------------------------

	for (i = 0; i < iter; i++)
  217898:	2300      	movs	r3, #0
  21789a:	61bb      	str	r3, [r7, #24]
  21789c:	e00f      	b.n	2178be <TestSDRAM+0xba>
	{
		Sdram_addr = SDRAM_DEVICE_ADDR + WriteReadAddr * i;
  21789e:	69bb      	ldr	r3, [r7, #24]
  2178a0:	697a      	ldr	r2, [r7, #20]
  2178a2:	fb02 f303 	mul.w	r3, r2, r3
  2178a6:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
  2178aa:	613b      	str	r3, [r7, #16]
		aTxBuffer = ~Sdram_addr;
  2178ac:	693b      	ldr	r3, [r7, #16]
  2178ae:	43db      	mvns	r3, r3
  2178b0:	60bb      	str	r3, [r7, #8]
		*(volatile uint32_t*) Sdram_addr = aTxBuffer;
  2178b2:	693b      	ldr	r3, [r7, #16]
  2178b4:	68ba      	ldr	r2, [r7, #8]
  2178b6:	601a      	str	r2, [r3, #0]
	for (i = 0; i < iter; i++)
  2178b8:	69bb      	ldr	r3, [r7, #24]
  2178ba:	3301      	adds	r3, #1
  2178bc:	61bb      	str	r3, [r7, #24]
  2178be:	69ba      	ldr	r2, [r7, #24]
  2178c0:	68fb      	ldr	r3, [r7, #12]
  2178c2:	429a      	cmp	r2, r3
  2178c4:	dbeb      	blt.n	21789e <TestSDRAM+0x9a>
	}

	for (i = 0; i < iter; i++)
  2178c6:	2300      	movs	r3, #0
  2178c8:	61bb      	str	r3, [r7, #24]
  2178ca:	e01c      	b.n	217906 <TestSDRAM+0x102>
	{
		aRxBuffer = 0x0;
  2178cc:	2300      	movs	r3, #0
  2178ce:	607b      	str	r3, [r7, #4]
		Sdram_addr = SDRAM_DEVICE_ADDR + WriteReadAddr * i;
  2178d0:	69bb      	ldr	r3, [r7, #24]
  2178d2:	697a      	ldr	r2, [r7, #20]
  2178d4:	fb02 f303 	mul.w	r3, r2, r3
  2178d8:	f103 4340 	add.w	r3, r3, #3221225472	; 0xc0000000
  2178dc:	613b      	str	r3, [r7, #16]
		aRxBuffer = *(volatile uint32_t*) Sdram_addr;
  2178de:	693b      	ldr	r3, [r7, #16]
  2178e0:	681b      	ldr	r3, [r3, #0]
  2178e2:	607b      	str	r3, [r7, #4]

		if (aRxBuffer != ~Sdram_addr)
  2178e4:	693b      	ldr	r3, [r7, #16]
  2178e6:	43da      	mvns	r2, r3
  2178e8:	687b      	ldr	r3, [r7, #4]
  2178ea:	429a      	cmp	r2, r3
  2178ec:	d002      	beq.n	2178f4 <TestSDRAM+0xf0>
			uwWriteReadStatus++;
  2178ee:	69fb      	ldr	r3, [r7, #28]
  2178f0:	3301      	adds	r3, #1
  2178f2:	61fb      	str	r3, [r7, #28]

		if (uwWriteReadStatus)
  2178f4:	69fb      	ldr	r3, [r7, #28]
  2178f6:	2b00      	cmp	r3, #0
  2178f8:	d002      	beq.n	217900 <TestSDRAM+0xfc>
		{
			ERROR_Sdram();
  2178fa:	f7e9 fbed 	bl	2010d8 <ERROR_Sdram>
			break;
  2178fe:	e006      	b.n	21790e <TestSDRAM+0x10a>
	for (i = 0; i < iter; i++)
  217900:	69bb      	ldr	r3, [r7, #24]
  217902:	3301      	adds	r3, #1
  217904:	61bb      	str	r3, [r7, #24]
  217906:	69ba      	ldr	r2, [r7, #24]
  217908:	68fb      	ldr	r3, [r7, #12]
  21790a:	429a      	cmp	r2, r3
  21790c:	dbde      	blt.n	2178cc <TestSDRAM+0xc8>
	}
	if (!uwWriteReadStatus)
	{
	}

	uwWriteReadStatus = 0;
  21790e:	2300      	movs	r3, #0
  217910:	61fb      	str	r3, [r7, #28]
	//------------------------------END TEST 2------------------------------
}
  217912:	bf00      	nop
  217914:	3720      	adds	r7, #32
  217916:	46bd      	mov	sp, r7
  217918:	bd80      	pop	{r7, pc}
	...

0021791c <MX_FMC_Init>:

SDRAM_HandleTypeDef hsdram1;

/* FMC initialization function */
void MX_FMC_Init(void)
{
  21791c:	b580      	push	{r7, lr}
  21791e:	b088      	sub	sp, #32
  217920:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_Init 0 */

  /* USER CODE END FMC_Init 0 */

  FMC_SDRAM_TimingTypeDef SdramTiming = {0};
  217922:	1d3b      	adds	r3, r7, #4
  217924:	2200      	movs	r2, #0
  217926:	601a      	str	r2, [r3, #0]
  217928:	605a      	str	r2, [r3, #4]
  21792a:	609a      	str	r2, [r3, #8]
  21792c:	60da      	str	r2, [r3, #12]
  21792e:	611a      	str	r2, [r3, #16]
  217930:	615a      	str	r2, [r3, #20]
  217932:	619a      	str	r2, [r3, #24]

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
  217934:	4b1f      	ldr	r3, [pc, #124]	; (2179b4 <MX_FMC_Init+0x98>)
  217936:	4a20      	ldr	r2, [pc, #128]	; (2179b8 <MX_FMC_Init+0x9c>)
  217938:	601a      	str	r2, [r3, #0]
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
  21793a:	4b1e      	ldr	r3, [pc, #120]	; (2179b4 <MX_FMC_Init+0x98>)
  21793c:	2200      	movs	r2, #0
  21793e:	605a      	str	r2, [r3, #4]
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
  217940:	4b1c      	ldr	r3, [pc, #112]	; (2179b4 <MX_FMC_Init+0x98>)
  217942:	2200      	movs	r2, #0
  217944:	609a      	str	r2, [r3, #8]
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
  217946:	4b1b      	ldr	r3, [pc, #108]	; (2179b4 <MX_FMC_Init+0x98>)
  217948:	2204      	movs	r2, #4
  21794a:	60da      	str	r2, [r3, #12]
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_32;
  21794c:	4b19      	ldr	r3, [pc, #100]	; (2179b4 <MX_FMC_Init+0x98>)
  21794e:	2220      	movs	r2, #32
  217950:	611a      	str	r2, [r3, #16]
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
  217952:	4b18      	ldr	r3, [pc, #96]	; (2179b4 <MX_FMC_Init+0x98>)
  217954:	2240      	movs	r2, #64	; 0x40
  217956:	615a      	str	r2, [r3, #20]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
  217958:	4b16      	ldr	r3, [pc, #88]	; (2179b4 <MX_FMC_Init+0x98>)
  21795a:	f44f 7280 	mov.w	r2, #256	; 0x100
  21795e:	619a      	str	r2, [r3, #24]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  217960:	4b14      	ldr	r3, [pc, #80]	; (2179b4 <MX_FMC_Init+0x98>)
  217962:	2200      	movs	r2, #0
  217964:	61da      	str	r2, [r3, #28]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
  217966:	4b13      	ldr	r3, [pc, #76]	; (2179b4 <MX_FMC_Init+0x98>)
  217968:	f44f 6200 	mov.w	r2, #2048	; 0x800
  21796c:	621a      	str	r2, [r3, #32]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;
  21796e:	4b11      	ldr	r3, [pc, #68]	; (2179b4 <MX_FMC_Init+0x98>)
  217970:	2200      	movs	r2, #0
  217972:	625a      	str	r2, [r3, #36]	; 0x24
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_1;
  217974:	4b0f      	ldr	r3, [pc, #60]	; (2179b4 <MX_FMC_Init+0x98>)
  217976:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  21797a:	629a      	str	r2, [r3, #40]	; 0x28
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
  21797c:	2302      	movs	r3, #2
  21797e:	607b      	str	r3, [r7, #4]
  SdramTiming.ExitSelfRefreshDelay = 7;
  217980:	2307      	movs	r3, #7
  217982:	60bb      	str	r3, [r7, #8]
  SdramTiming.SelfRefreshTime = 4;
  217984:	2304      	movs	r3, #4
  217986:	60fb      	str	r3, [r7, #12]
  SdramTiming.RowCycleDelay = 7;
  217988:	2307      	movs	r3, #7
  21798a:	613b      	str	r3, [r7, #16]
  SdramTiming.WriteRecoveryTime = 3;
  21798c:	2303      	movs	r3, #3
  21798e:	617b      	str	r3, [r7, #20]
  SdramTiming.RPDelay = 2;
  217990:	2302      	movs	r3, #2
  217992:	61bb      	str	r3, [r7, #24]
  SdramTiming.RCDDelay = 2;
  217994:	2302      	movs	r3, #2
  217996:	61fb      	str	r3, [r7, #28]

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
  217998:	1d3b      	adds	r3, r7, #4
  21799a:	4619      	mov	r1, r3
  21799c:	4805      	ldr	r0, [pc, #20]	; (2179b4 <MX_FMC_Init+0x98>)
  21799e:	f005 fb8e 	bl	21d0be <HAL_SDRAM_Init>
  2179a2:	4603      	mov	r3, r0
  2179a4:	2b00      	cmp	r3, #0
  2179a6:	d001      	beq.n	2179ac <MX_FMC_Init+0x90>
  {
    Error_Handler( );
  2179a8:	f000 fdc6 	bl	218538 <Error_Handler>
  }

  /* USER CODE BEGIN FMC_Init 2 */

  /* USER CODE END FMC_Init 2 */
}
  2179ac:	bf00      	nop
  2179ae:	3720      	adds	r7, #32
  2179b0:	46bd      	mov	sp, r7
  2179b2:	bd80      	pop	{r7, pc}
  2179b4:	20014abc 	.word	0x20014abc
  2179b8:	a0000140 	.word	0xa0000140

002179bc <HAL_FMC_MspInit>:

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
  2179bc:	b580      	push	{r7, lr}
  2179be:	b086      	sub	sp, #24
  2179c0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  2179c2:	1d3b      	adds	r3, r7, #4
  2179c4:	2200      	movs	r2, #0
  2179c6:	601a      	str	r2, [r3, #0]
  2179c8:	605a      	str	r2, [r3, #4]
  2179ca:	609a      	str	r2, [r3, #8]
  2179cc:	60da      	str	r2, [r3, #12]
  2179ce:	611a      	str	r2, [r3, #16]
  if (FMC_Initialized) {
  2179d0:	4b3b      	ldr	r3, [pc, #236]	; (217ac0 <HAL_FMC_MspInit+0x104>)
  2179d2:	681b      	ldr	r3, [r3, #0]
  2179d4:	2b00      	cmp	r3, #0
  2179d6:	d16f      	bne.n	217ab8 <HAL_FMC_MspInit+0xfc>
    return;
  }
  FMC_Initialized = 1;
  2179d8:	4b39      	ldr	r3, [pc, #228]	; (217ac0 <HAL_FMC_MspInit+0x104>)
  2179da:	2201      	movs	r2, #1
  2179dc:	601a      	str	r2, [r3, #0]

  /* Peripheral clock enable */
  __HAL_RCC_FMC_CLK_ENABLE();
  2179de:	4a39      	ldr	r2, [pc, #228]	; (217ac4 <HAL_FMC_MspInit+0x108>)
  2179e0:	4b38      	ldr	r3, [pc, #224]	; (217ac4 <HAL_FMC_MspInit+0x108>)
  2179e2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  2179e4:	f043 0301 	orr.w	r3, r3, #1
  2179e8:	6393      	str	r3, [r2, #56]	; 0x38
  2179ea:	4b36      	ldr	r3, [pc, #216]	; (217ac4 <HAL_FMC_MspInit+0x108>)
  2179ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  2179ee:	f003 0301 	and.w	r3, r3, #1
  2179f2:	603b      	str	r3, [r7, #0]
  2179f4:	683b      	ldr	r3, [r7, #0]
  PI5   ------> FMC_NBL3
  PI6   ------> FMC_D28
  PI7   ------> FMC_D29
  */
  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_0|GPIO_PIN_1
  2179f6:	f240 63ff 	movw	r3, #1791	; 0x6ff
  2179fa:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5
                          |GPIO_PIN_6|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2179fc:	2302      	movs	r3, #2
  2179fe:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217a00:	2300      	movs	r3, #0
  217a02:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  217a04:	2303      	movs	r3, #3
  217a06:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  217a08:	230c      	movs	r3, #12
  217a0a:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
  217a0c:	1d3b      	adds	r3, r7, #4
  217a0e:	4619      	mov	r1, r3
  217a10:	482d      	ldr	r0, [pc, #180]	; (217ac8 <HAL_FMC_MspInit+0x10c>)
  217a12:	f002 fa8b 	bl	219f2c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
  217a16:	f64f 033f 	movw	r3, #63551	; 0xf83f
  217a1a:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_11|GPIO_PIN_12
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217a1c:	2302      	movs	r3, #2
  217a1e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217a20:	2300      	movs	r3, #0
  217a22:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  217a24:	2303      	movs	r3, #3
  217a26:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  217a28:	230c      	movs	r3, #12
  217a2a:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
  217a2c:	1d3b      	adds	r3, r7, #4
  217a2e:	4619      	mov	r1, r3
  217a30:	4826      	ldr	r0, [pc, #152]	; (217acc <HAL_FMC_MspInit+0x110>)
  217a32:	f002 fa7b 	bl	219f2c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5|GPIO_PIN_8
  217a36:	f64f 732c 	movw	r3, #65324	; 0xff2c
  217a3a:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12
                          |GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217a3c:	2302      	movs	r3, #2
  217a3e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217a40:	2300      	movs	r3, #0
  217a42:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  217a44:	2303      	movs	r3, #3
  217a46:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  217a48:	230c      	movs	r3, #12
  217a4a:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
  217a4c:	1d3b      	adds	r3, r7, #4
  217a4e:	4619      	mov	r1, r3
  217a50:	481f      	ldr	r0, [pc, #124]	; (217ad0 <HAL_FMC_MspInit+0x114>)
  217a52:	f002 fa6b 	bl	219f2c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_5
  217a56:	f248 1333 	movw	r3, #33075	; 0x8133
  217a5a:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_8|GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217a5c:	2302      	movs	r3, #2
  217a5e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217a60:	2300      	movs	r3, #0
  217a62:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  217a64:	2303      	movs	r3, #3
  217a66:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  217a68:	230c      	movs	r3, #12
  217a6a:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
  217a6c:	1d3b      	adds	r3, r7, #4
  217a6e:	4619      	mov	r1, r3
  217a70:	4818      	ldr	r0, [pc, #96]	; (217ad4 <HAL_FMC_MspInit+0x118>)
  217a72:	f002 fa5b 	bl	219f2c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10
  217a76:	f64f 7383 	movw	r3, #65411	; 0xff83
  217a7a:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_11|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217a7c:	2302      	movs	r3, #2
  217a7e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217a80:	2300      	movs	r3, #0
  217a82:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  217a84:	2303      	movs	r3, #3
  217a86:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  217a88:	230c      	movs	r3, #12
  217a8a:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  217a8c:	1d3b      	adds	r3, r7, #4
  217a8e:	4619      	mov	r1, r3
  217a90:	4811      	ldr	r0, [pc, #68]	; (217ad8 <HAL_FMC_MspInit+0x11c>)
  217a92:	f002 fa4b 	bl	219f2c <HAL_GPIO_Init>

  /* GPIO_InitStruct */
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14
  217a96:	f24c 7303 	movw	r3, #50947	; 0xc703
  217a9a:	607b      	str	r3, [r7, #4]
                          |GPIO_PIN_15|GPIO_PIN_0|GPIO_PIN_1;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217a9c:	2302      	movs	r3, #2
  217a9e:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217aa0:	2300      	movs	r3, #0
  217aa2:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  217aa4:	2303      	movs	r3, #3
  217aa6:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
  217aa8:	230c      	movs	r3, #12
  217aaa:	617b      	str	r3, [r7, #20]

  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  217aac:	1d3b      	adds	r3, r7, #4
  217aae:	4619      	mov	r1, r3
  217ab0:	480a      	ldr	r0, [pc, #40]	; (217adc <HAL_FMC_MspInit+0x120>)
  217ab2:	f002 fa3b 	bl	219f2c <HAL_GPIO_Init>
  217ab6:	e000      	b.n	217aba <HAL_FMC_MspInit+0xfe>
    return;
  217ab8:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
  217aba:	3718      	adds	r7, #24
  217abc:	46bd      	mov	sp, r7
  217abe:	bd80      	pop	{r7, pc}
  217ac0:	20010748 	.word	0x20010748
  217ac4:	40023800 	.word	0x40023800
  217ac8:	40022000 	.word	0x40022000
  217acc:	40021400 	.word	0x40021400
  217ad0:	40021c00 	.word	0x40021c00
  217ad4:	40021800 	.word	0x40021800
  217ad8:	40021000 	.word	0x40021000
  217adc:	40020c00 	.word	0x40020c00

00217ae0 <HAL_SDRAM_MspInit>:

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
  217ae0:	b580      	push	{r7, lr}
  217ae2:	b082      	sub	sp, #8
  217ae4:	af00      	add	r7, sp, #0
  217ae6:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN SDRAM_MspInit 0 */

  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  217ae8:	f7ff ff68 	bl	2179bc <HAL_FMC_MspInit>
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
  217aec:	bf00      	nop
  217aee:	3708      	adds	r7, #8
  217af0:	46bd      	mov	sp, r7
  217af2:	bd80      	pop	{r7, pc}

00217af4 <vApplicationGetIdleTaskMemory>:
/* USER CODE BEGIN GET_IDLE_TASK_MEMORY */
static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
{
  217af4:	b480      	push	{r7}
  217af6:	b085      	sub	sp, #20
  217af8:	af00      	add	r7, sp, #0
  217afa:	60f8      	str	r0, [r7, #12]
  217afc:	60b9      	str	r1, [r7, #8]
  217afe:	607a      	str	r2, [r7, #4]
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  217b00:	68fb      	ldr	r3, [r7, #12]
  217b02:	4a07      	ldr	r2, [pc, #28]	; (217b20 <vApplicationGetIdleTaskMemory+0x2c>)
  217b04:	601a      	str	r2, [r3, #0]
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  217b06:	68bb      	ldr	r3, [r7, #8]
  217b08:	4a06      	ldr	r2, [pc, #24]	; (217b24 <vApplicationGetIdleTaskMemory+0x30>)
  217b0a:	601a      	str	r2, [r3, #0]
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
  217b0c:	687b      	ldr	r3, [r7, #4]
  217b0e:	2280      	movs	r2, #128	; 0x80
  217b10:	601a      	str	r2, [r3, #0]
  /* place for user code */
}
  217b12:	bf00      	nop
  217b14:	3714      	adds	r7, #20
  217b16:	46bd      	mov	sp, r7
  217b18:	f85d 7b04 	ldr.w	r7, [sp], #4
  217b1c:	4770      	bx	lr
  217b1e:	bf00      	nop
  217b20:	2001074c 	.word	0x2001074c
  217b24:	200107a0 	.word	0x200107a0

00217b28 <MX_FREERTOS_Init>:
/**
  * @brief  FreeRTOS initialization
  * @param  None
  * @retval None
  */
void MX_FREERTOS_Init(void) {
  217b28:	b5b0      	push	{r4, r5, r7, lr}
  217b2a:	b088      	sub	sp, #32
  217b2c:	af00      	add	r7, sp, #0
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* definition and creation of defaultTask */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 2048);
  217b2e:	4b0a      	ldr	r3, [pc, #40]	; (217b58 <MX_FREERTOS_Init+0x30>)
  217b30:	1d3c      	adds	r4, r7, #4
  217b32:	461d      	mov	r5, r3
  217b34:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  217b36:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  217b38:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
  217b3c:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
  217b40:	1d3b      	adds	r3, r7, #4
  217b42:	2100      	movs	r1, #0
  217b44:	4618      	mov	r0, r3
  217b46:	f00b fe17 	bl	223778 <osThreadCreate>
  217b4a:	4602      	mov	r2, r0
  217b4c:	4b03      	ldr	r3, [pc, #12]	; (217b5c <MX_FREERTOS_Init+0x34>)
  217b4e:	601a      	str	r2, [r3, #0]

  /* USER CODE BEGIN RTOS_THREADS */
  /* add threads, ... */
  /* USER CODE END RTOS_THREADS */

}
  217b50:	bf00      	nop
  217b52:	3720      	adds	r7, #32
  217b54:	46bd      	mov	sp, r7
  217b56:	bdb0      	pop	{r4, r5, r7, pc}
  217b58:	002291dc 	.word	0x002291dc
  217b5c:	20014af0 	.word	0x20014af0

00217b60 <StartDefaultTask>:


#include "tim.h"
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
  217b60:	b580      	push	{r7, lr}
  217b62:	b082      	sub	sp, #8
  217b64:	af00      	add	r7, sp, #0
  217b66:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN StartDefaultTask */

	MX_FATFS_Init();
  217b68:	f007 ffdc 	bl	21fb24 <MX_FATFS_Init>

	 SetLang(2,English);
  217b6c:	2101      	movs	r1, #1
  217b6e:	2002      	movs	r0, #2
  217b70:	f7ff fc82 	bl	217478 <SetLang>
	 LCD_SetSpacesBetweenFonts();
  217b74:	f7fa fec4 	bl	212900 <LCD_SetSpacesBetweenFonts>

  /* Infinite loop */
  for(;;)
  {

	 SCREEN_ReadPanel();
  217b78:	f7fe fbb2 	bl	2162e0 <SCREEN_ReadPanel>
	 vTaskDelay(2);
  217b7c:	2002      	movs	r0, #2
  217b7e:	f00d fda9 	bl	2256d4 <vTaskDelay>
	 SCREEN_ReadPanel();
  217b82:	e7f9      	b.n	217b78 <StartDefaultTask+0x18>

00217b84 <MX_GPIO_Init>:
        * Output
        * EVENT_OUT
        * EXTI
*/
void MX_GPIO_Init(void)
{
  217b84:	b580      	push	{r7, lr}
  217b86:	b090      	sub	sp, #64	; 0x40
  217b88:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  217b8a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  217b8e:	2200      	movs	r2, #0
  217b90:	601a      	str	r2, [r3, #0]
  217b92:	605a      	str	r2, [r3, #4]
  217b94:	609a      	str	r2, [r3, #8]
  217b96:	60da      	str	r2, [r3, #12]
  217b98:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  217b9a:	4a4e      	ldr	r2, [pc, #312]	; (217cd4 <MX_GPIO_Init+0x150>)
  217b9c:	4b4d      	ldr	r3, [pc, #308]	; (217cd4 <MX_GPIO_Init+0x150>)
  217b9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ba0:	f043 0310 	orr.w	r3, r3, #16
  217ba4:	6313      	str	r3, [r2, #48]	; 0x30
  217ba6:	4b4b      	ldr	r3, [pc, #300]	; (217cd4 <MX_GPIO_Init+0x150>)
  217ba8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217baa:	f003 0310 	and.w	r3, r3, #16
  217bae:	62bb      	str	r3, [r7, #40]	; 0x28
  217bb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  __HAL_RCC_GPIOI_CLK_ENABLE();
  217bb2:	4a48      	ldr	r2, [pc, #288]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bb4:	4b47      	ldr	r3, [pc, #284]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bb6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217bb8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  217bbc:	6313      	str	r3, [r2, #48]	; 0x30
  217bbe:	4b45      	ldr	r3, [pc, #276]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bc0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217bc2:	f403 7380 	and.w	r3, r3, #256	; 0x100
  217bc6:	627b      	str	r3, [r7, #36]	; 0x24
  217bc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  __HAL_RCC_GPIOF_CLK_ENABLE();
  217bca:	4a42      	ldr	r2, [pc, #264]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bcc:	4b41      	ldr	r3, [pc, #260]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217bd0:	f043 0320 	orr.w	r3, r3, #32
  217bd4:	6313      	str	r3, [r2, #48]	; 0x30
  217bd6:	4b3f      	ldr	r3, [pc, #252]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bd8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217bda:	f003 0320 	and.w	r3, r3, #32
  217bde:	623b      	str	r3, [r7, #32]
  217be0:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOH_CLK_ENABLE();
  217be2:	4a3c      	ldr	r2, [pc, #240]	; (217cd4 <MX_GPIO_Init+0x150>)
  217be4:	4b3b      	ldr	r3, [pc, #236]	; (217cd4 <MX_GPIO_Init+0x150>)
  217be6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217be8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  217bec:	6313      	str	r3, [r2, #48]	; 0x30
  217bee:	4b39      	ldr	r3, [pc, #228]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bf0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217bf2:	f003 0380 	and.w	r3, r3, #128	; 0x80
  217bf6:	61fb      	str	r3, [r7, #28]
  217bf8:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOC_CLK_ENABLE();
  217bfa:	4a36      	ldr	r2, [pc, #216]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bfc:	4b35      	ldr	r3, [pc, #212]	; (217cd4 <MX_GPIO_Init+0x150>)
  217bfe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c00:	f043 0304 	orr.w	r3, r3, #4
  217c04:	6313      	str	r3, [r2, #48]	; 0x30
  217c06:	4b33      	ldr	r3, [pc, #204]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c0a:	f003 0304 	and.w	r3, r3, #4
  217c0e:	61bb      	str	r3, [r7, #24]
  217c10:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOA_CLK_ENABLE();
  217c12:	4a30      	ldr	r2, [pc, #192]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c14:	4b2f      	ldr	r3, [pc, #188]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c18:	f043 0301 	orr.w	r3, r3, #1
  217c1c:	6313      	str	r3, [r2, #48]	; 0x30
  217c1e:	4b2d      	ldr	r3, [pc, #180]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c22:	f003 0301 	and.w	r3, r3, #1
  217c26:	617b      	str	r3, [r7, #20]
  217c28:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
  217c2a:	4a2a      	ldr	r2, [pc, #168]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c2c:	4b29      	ldr	r3, [pc, #164]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c30:	f043 0302 	orr.w	r3, r3, #2
  217c34:	6313      	str	r3, [r2, #48]	; 0x30
  217c36:	4b27      	ldr	r3, [pc, #156]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c3a:	f003 0302 	and.w	r3, r3, #2
  217c3e:	613b      	str	r3, [r7, #16]
  217c40:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
  217c42:	4a24      	ldr	r2, [pc, #144]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c44:	4b23      	ldr	r3, [pc, #140]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c48:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  217c4c:	6313      	str	r3, [r2, #48]	; 0x30
  217c4e:	4b21      	ldr	r3, [pc, #132]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c50:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c52:	f403 7300 	and.w	r3, r3, #512	; 0x200
  217c56:	60fb      	str	r3, [r7, #12]
  217c58:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOG_CLK_ENABLE();
  217c5a:	4a1e      	ldr	r2, [pc, #120]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c5c:	4b1d      	ldr	r3, [pc, #116]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c60:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  217c64:	6313      	str	r3, [r2, #48]	; 0x30
  217c66:	4b1b      	ldr	r3, [pc, #108]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c6a:	f003 0340 	and.w	r3, r3, #64	; 0x40
  217c6e:	60bb      	str	r3, [r7, #8]
  217c70:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOD_CLK_ENABLE();
  217c72:	4a18      	ldr	r2, [pc, #96]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c74:	4b17      	ldr	r3, [pc, #92]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c78:	f043 0308 	orr.w	r3, r3, #8
  217c7c:	6313      	str	r3, [r2, #48]	; 0x30
  217c7e:	4b15      	ldr	r3, [pc, #84]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c80:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c82:	f003 0308 	and.w	r3, r3, #8
  217c86:	607b      	str	r3, [r7, #4]
  217c88:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOK_CLK_ENABLE();
  217c8a:	4a12      	ldr	r2, [pc, #72]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c8c:	4b11      	ldr	r3, [pc, #68]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c90:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  217c94:	6313      	str	r3, [r2, #48]	; 0x30
  217c96:	4b0f      	ldr	r3, [pc, #60]	; (217cd4 <MX_GPIO_Init+0x150>)
  217c98:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217c9a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  217c9e:	603b      	str	r3, [r7, #0]
  217ca0:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
  217ca2:	2200      	movs	r2, #0
  217ca4:	f44f 4100 	mov.w	r1, #32768	; 0x8000
  217ca8:	480b      	ldr	r0, [pc, #44]	; (217cd8 <MX_GPIO_Init+0x154>)
  217caa:	f002 fae9 	bl	21a280 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = LED_Pin;
  217cae:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  217cb2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  217cb4:	2301      	movs	r3, #1
  217cb6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  217cb8:	2300      	movs	r3, #0
  217cba:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217cbc:	2300      	movs	r3, #0
  217cbe:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
  217cc0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  217cc4:	4619      	mov	r1, r3
  217cc6:	4804      	ldr	r0, [pc, #16]	; (217cd8 <MX_GPIO_Init+0x154>)
  217cc8:	f002 f930 	bl	219f2c <HAL_GPIO_Init>

}
  217ccc:	bf00      	nop
  217cce:	3740      	adds	r7, #64	; 0x40
  217cd0:	46bd      	mov	sp, r7
  217cd2:	bd80      	pop	{r7, pc}
  217cd4:	40023800 	.word	0x40023800
  217cd8:	40020000 	.word	0x40020000

00217cdc <MX_LTDC_Init>:

LTDC_HandleTypeDef hltdc;

/* LTDC init function */
void MX_LTDC_Init(void)
{
  217cdc:	b580      	push	{r7, lr}
  217cde:	b08e      	sub	sp, #56	; 0x38
  217ce0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
  217ce2:	1d3b      	adds	r3, r7, #4
  217ce4:	2234      	movs	r2, #52	; 0x34
  217ce6:	2100      	movs	r1, #0
  217ce8:	4618      	mov	r0, r3
  217cea:	f00e fc22 	bl	226532 <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
  217cee:	4b3a      	ldr	r3, [pc, #232]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217cf0:	4a3a      	ldr	r2, [pc, #232]	; (217ddc <MX_LTDC_Init+0x100>)
  217cf2:	601a      	str	r2, [r3, #0]
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
  217cf4:	4b38      	ldr	r3, [pc, #224]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217cf6:	2200      	movs	r2, #0
  217cf8:	605a      	str	r2, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
  217cfa:	4b37      	ldr	r3, [pc, #220]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217cfc:	2200      	movs	r2, #0
  217cfe:	609a      	str	r2, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
  217d00:	4b35      	ldr	r3, [pc, #212]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d02:	2200      	movs	r2, #0
  217d04:	60da      	str	r2, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
  217d06:	4b34      	ldr	r3, [pc, #208]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d08:	2200      	movs	r2, #0
  217d0a:	611a      	str	r2, [r3, #16]
  hltdc.Init.HorizontalSync = 39;
  217d0c:	4b32      	ldr	r3, [pc, #200]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d0e:	2227      	movs	r2, #39	; 0x27
  217d10:	615a      	str	r2, [r3, #20]
  hltdc.Init.VerticalSync = 8;
  217d12:	4b31      	ldr	r3, [pc, #196]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d14:	2208      	movs	r2, #8
  217d16:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 46;
  217d18:	4b2f      	ldr	r3, [pc, #188]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d1a:	222e      	movs	r2, #46	; 0x2e
  217d1c:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedVBP = 10;
  217d1e:	4b2e      	ldr	r3, [pc, #184]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d20:	220a      	movs	r2, #10
  217d22:	621a      	str	r2, [r3, #32]
  hltdc.Init.AccumulatedActiveW = 526;
  217d24:	4b2c      	ldr	r3, [pc, #176]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d26:	f240 220e 	movw	r2, #526	; 0x20e
  217d2a:	625a      	str	r2, [r3, #36]	; 0x24
  hltdc.Init.AccumulatedActiveH = 282;
  217d2c:	4b2a      	ldr	r3, [pc, #168]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d2e:	f44f 728d 	mov.w	r2, #282	; 0x11a
  217d32:	629a      	str	r2, [r3, #40]	; 0x28
  hltdc.Init.TotalWidth = 532;
  217d34:	4b28      	ldr	r3, [pc, #160]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d36:	f44f 7205 	mov.w	r2, #532	; 0x214
  217d3a:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc.Init.TotalHeigh = 284;
  217d3c:	4b26      	ldr	r3, [pc, #152]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d3e:	f44f 728e 	mov.w	r2, #284	; 0x11c
  217d42:	631a      	str	r2, [r3, #48]	; 0x30
  hltdc.Init.Backcolor.Blue = 0;
  217d44:	4b24      	ldr	r3, [pc, #144]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d46:	2200      	movs	r2, #0
  217d48:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hltdc.Init.Backcolor.Green = 0;
  217d4c:	4b22      	ldr	r3, [pc, #136]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d4e:	2200      	movs	r2, #0
  217d50:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  hltdc.Init.Backcolor.Red = 0;
  217d54:	4b20      	ldr	r3, [pc, #128]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d56:	2200      	movs	r2, #0
  217d58:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
  217d5c:	481e      	ldr	r0, [pc, #120]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217d5e:	f002 faa9 	bl	21a2b4 <HAL_LTDC_Init>
  217d62:	4603      	mov	r3, r0
  217d64:	2b00      	cmp	r3, #0
  217d66:	d001      	beq.n	217d6c <MX_LTDC_Init+0x90>
  {
    Error_Handler();
  217d68:	f000 fbe6 	bl	218538 <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
  217d6c:	2300      	movs	r3, #0
  217d6e:	607b      	str	r3, [r7, #4]
  pLayerCfg.WindowX1 = 480;
  217d70:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
  217d74:	60bb      	str	r3, [r7, #8]
  pLayerCfg.WindowY0 = 0;
  217d76:	2300      	movs	r3, #0
  217d78:	60fb      	str	r3, [r7, #12]
  pLayerCfg.WindowY1 = 272;
  217d7a:	f44f 7388 	mov.w	r3, #272	; 0x110
  217d7e:	613b      	str	r3, [r7, #16]
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB888;
  217d80:	2301      	movs	r3, #1
  217d82:	617b      	str	r3, [r7, #20]
  pLayerCfg.Alpha = 255;
  217d84:	23ff      	movs	r3, #255	; 0xff
  217d86:	61bb      	str	r3, [r7, #24]
  pLayerCfg.Alpha0 = 255;
  217d88:	23ff      	movs	r3, #255	; 0xff
  217d8a:	61fb      	str	r3, [r7, #28]
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
  217d8c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
  217d90:	623b      	str	r3, [r7, #32]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
  217d92:	2307      	movs	r3, #7
  217d94:	627b      	str	r3, [r7, #36]	; 0x24
  pLayerCfg.FBStartAdress = 0xC0E89000;
  217d96:	4b12      	ldr	r3, [pc, #72]	; (217de0 <MX_LTDC_Init+0x104>)
  217d98:	62bb      	str	r3, [r7, #40]	; 0x28
  pLayerCfg.ImageWidth = 480;
  217d9a:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
  217d9e:	62fb      	str	r3, [r7, #44]	; 0x2c
  pLayerCfg.ImageHeight = 272;
  217da0:	f44f 7388 	mov.w	r3, #272	; 0x110
  217da4:	633b      	str	r3, [r7, #48]	; 0x30
  pLayerCfg.Backcolor.Blue = 0;
  217da6:	2300      	movs	r3, #0
  217da8:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
  pLayerCfg.Backcolor.Green = 0;
  217dac:	2300      	movs	r3, #0
  217dae:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
  pLayerCfg.Backcolor.Red = 0;
  217db2:	2300      	movs	r3, #0
  217db4:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
  217db8:	1d3b      	adds	r3, r7, #4
  217dba:	2200      	movs	r2, #0
  217dbc:	4619      	mov	r1, r3
  217dbe:	4806      	ldr	r0, [pc, #24]	; (217dd8 <MX_LTDC_Init+0xfc>)
  217dc0:	f002 fb48 	bl	21a454 <HAL_LTDC_ConfigLayer>
  217dc4:	4603      	mov	r3, r0
  217dc6:	2b00      	cmp	r3, #0
  217dc8:	d001      	beq.n	217dce <MX_LTDC_Init+0xf2>
  {
    Error_Handler();
  217dca:	f000 fbb5 	bl	218538 <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */

  /* USER CODE END LTDC_Init 2 */

}
  217dce:	bf00      	nop
  217dd0:	3738      	adds	r7, #56	; 0x38
  217dd2:	46bd      	mov	sp, r7
  217dd4:	bd80      	pop	{r7, pc}
  217dd6:	bf00      	nop
  217dd8:	20014af4 	.word	0x20014af4
  217ddc:	40016800 	.word	0x40016800
  217de0:	c0e89000 	.word	0xc0e89000

00217de4 <HAL_LTDC_MspInit>:

void HAL_LTDC_MspInit(LTDC_HandleTypeDef* ltdcHandle)
{
  217de4:	b580      	push	{r7, lr}
  217de6:	b094      	sub	sp, #80	; 0x50
  217de8:	af00      	add	r7, sp, #0
  217dea:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  217dec:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217df0:	2200      	movs	r2, #0
  217df2:	601a      	str	r2, [r3, #0]
  217df4:	605a      	str	r2, [r3, #4]
  217df6:	609a      	str	r2, [r3, #8]
  217df8:	60da      	str	r2, [r3, #12]
  217dfa:	611a      	str	r2, [r3, #16]
  if(ltdcHandle->Instance==LTDC)
  217dfc:	687b      	ldr	r3, [r7, #4]
  217dfe:	681b      	ldr	r3, [r3, #0]
  217e00:	4aaa      	ldr	r2, [pc, #680]	; (2180ac <HAL_LTDC_MspInit+0x2c8>)
  217e02:	4293      	cmp	r3, r2
  217e04:	f040 81b0 	bne.w	218168 <HAL_LTDC_MspInit+0x384>
  {
  /* USER CODE BEGIN LTDC_MspInit 0 */

  /* USER CODE END LTDC_MspInit 0 */
    /* LTDC clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
  217e08:	4aa9      	ldr	r2, [pc, #676]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e0a:	4ba9      	ldr	r3, [pc, #676]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e0c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  217e0e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
  217e12:	6453      	str	r3, [r2, #68]	; 0x44
  217e14:	4ba6      	ldr	r3, [pc, #664]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  217e18:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  217e1c:	63bb      	str	r3, [r7, #56]	; 0x38
  217e1e:	6bbb      	ldr	r3, [r7, #56]	; 0x38

    __HAL_RCC_GPIOE_CLK_ENABLE();
  217e20:	4aa3      	ldr	r2, [pc, #652]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e22:	4ba3      	ldr	r3, [pc, #652]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e26:	f043 0310 	orr.w	r3, r3, #16
  217e2a:	6313      	str	r3, [r2, #48]	; 0x30
  217e2c:	4ba0      	ldr	r3, [pc, #640]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e2e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e30:	f003 0310 	and.w	r3, r3, #16
  217e34:	637b      	str	r3, [r7, #52]	; 0x34
  217e36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    __HAL_RCC_GPIOI_CLK_ENABLE();
  217e38:	4a9d      	ldr	r2, [pc, #628]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e3a:	4b9d      	ldr	r3, [pc, #628]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e3c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e3e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  217e42:	6313      	str	r3, [r2, #48]	; 0x30
  217e44:	4b9a      	ldr	r3, [pc, #616]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e46:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e48:	f403 7380 	and.w	r3, r3, #256	; 0x100
  217e4c:	633b      	str	r3, [r7, #48]	; 0x30
  217e4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    __HAL_RCC_GPIOF_CLK_ENABLE();
  217e50:	4a97      	ldr	r2, [pc, #604]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e52:	4b97      	ldr	r3, [pc, #604]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e54:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e56:	f043 0320 	orr.w	r3, r3, #32
  217e5a:	6313      	str	r3, [r2, #48]	; 0x30
  217e5c:	4b94      	ldr	r3, [pc, #592]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e5e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e60:	f003 0320 	and.w	r3, r3, #32
  217e64:	62fb      	str	r3, [r7, #44]	; 0x2c
  217e66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    __HAL_RCC_GPIOC_CLK_ENABLE();
  217e68:	4a91      	ldr	r2, [pc, #580]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e6a:	4b91      	ldr	r3, [pc, #580]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e6e:	f043 0304 	orr.w	r3, r3, #4
  217e72:	6313      	str	r3, [r2, #48]	; 0x30
  217e74:	4b8e      	ldr	r3, [pc, #568]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e76:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e78:	f003 0304 	and.w	r3, r3, #4
  217e7c:	62bb      	str	r3, [r7, #40]	; 0x28
  217e7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
    __HAL_RCC_GPIOH_CLK_ENABLE();
  217e80:	4a8b      	ldr	r2, [pc, #556]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e82:	4b8b      	ldr	r3, [pc, #556]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e86:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  217e8a:	6313      	str	r3, [r2, #48]	; 0x30
  217e8c:	4b88      	ldr	r3, [pc, #544]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e90:	f003 0380 	and.w	r3, r3, #128	; 0x80
  217e94:	627b      	str	r3, [r7, #36]	; 0x24
  217e96:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
  217e98:	4a85      	ldr	r2, [pc, #532]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e9a:	4b85      	ldr	r3, [pc, #532]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217e9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217e9e:	f043 0301 	orr.w	r3, r3, #1
  217ea2:	6313      	str	r3, [r2, #48]	; 0x30
  217ea4:	4b82      	ldr	r3, [pc, #520]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217ea6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ea8:	f003 0301 	and.w	r3, r3, #1
  217eac:	623b      	str	r3, [r7, #32]
  217eae:	6a3b      	ldr	r3, [r7, #32]
    __HAL_RCC_GPIOB_CLK_ENABLE();
  217eb0:	4a7f      	ldr	r2, [pc, #508]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217eb2:	4b7f      	ldr	r3, [pc, #508]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217eb4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217eb6:	f043 0302 	orr.w	r3, r3, #2
  217eba:	6313      	str	r3, [r2, #48]	; 0x30
  217ebc:	4b7c      	ldr	r3, [pc, #496]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217ebe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ec0:	f003 0302 	and.w	r3, r3, #2
  217ec4:	61fb      	str	r3, [r7, #28]
  217ec6:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
  217ec8:	4a79      	ldr	r2, [pc, #484]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217eca:	4b79      	ldr	r3, [pc, #484]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217ecc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ece:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  217ed2:	6313      	str	r3, [r2, #48]	; 0x30
  217ed4:	4b76      	ldr	r3, [pc, #472]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217ed6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ed8:	f403 7300 	and.w	r3, r3, #512	; 0x200
  217edc:	61bb      	str	r3, [r7, #24]
  217ede:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOG_CLK_ENABLE();
  217ee0:	4a73      	ldr	r2, [pc, #460]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217ee2:	4b73      	ldr	r3, [pc, #460]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217ee4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ee6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  217eea:	6313      	str	r3, [r2, #48]	; 0x30
  217eec:	4b70      	ldr	r3, [pc, #448]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217eee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217ef0:	f003 0340 	and.w	r3, r3, #64	; 0x40
  217ef4:	617b      	str	r3, [r7, #20]
  217ef6:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOD_CLK_ENABLE();
  217ef8:	4a6d      	ldr	r2, [pc, #436]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217efa:	4b6d      	ldr	r3, [pc, #436]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217efc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217efe:	f043 0308 	orr.w	r3, r3, #8
  217f02:	6313      	str	r3, [r2, #48]	; 0x30
  217f04:	4b6a      	ldr	r3, [pc, #424]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217f06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217f08:	f003 0308 	and.w	r3, r3, #8
  217f0c:	613b      	str	r3, [r7, #16]
  217f0e:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOK_CLK_ENABLE();
  217f10:	4a67      	ldr	r2, [pc, #412]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217f12:	4b67      	ldr	r3, [pc, #412]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217f14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217f16:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
  217f1a:	6313      	str	r3, [r2, #48]	; 0x30
  217f1c:	4b64      	ldr	r3, [pc, #400]	; (2180b0 <HAL_LTDC_MspInit+0x2cc>)
  217f1e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  217f20:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  217f24:	60fb      	str	r3, [r7, #12]
  217f26:	68fb      	ldr	r3, [r7, #12]
    PJ12     ------> LTDC_G3
    PJ13     ------> LTDC_B1
    PK5     ------> LTDC_B6
    PK6     ------> LTDC_B7
    */
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
  217f28:	2370      	movs	r3, #112	; 0x70
  217f2a:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217f2c:	2302      	movs	r3, #2
  217f2e:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217f30:	2300      	movs	r3, #0
  217f32:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217f34:	2300      	movs	r3, #0
  217f36:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  217f38:	230e      	movs	r3, #14
  217f3a:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
  217f3c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217f40:	4619      	mov	r1, r3
  217f42:	485c      	ldr	r0, [pc, #368]	; (2180b4 <HAL_LTDC_MspInit+0x2d0>)
  217f44:	f001 fff2 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_11;
  217f48:	f44f 6300 	mov.w	r3, #2048	; 0x800
  217f4c:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217f4e:	2302      	movs	r3, #2
  217f50:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217f52:	2300      	movs	r3, #0
  217f54:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217f56:	2300      	movs	r3, #0
  217f58:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
  217f5a:	2309      	movs	r3, #9
  217f5c:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
  217f5e:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217f62:	4619      	mov	r1, r3
  217f64:	4854      	ldr	r0, [pc, #336]	; (2180b8 <HAL_LTDC_MspInit+0x2d4>)
  217f66:	f001 ffe1 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
  217f6a:	f44f 4370 	mov.w	r3, #61440	; 0xf000
  217f6e:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217f70:	2302      	movs	r3, #2
  217f72:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217f74:	2300      	movs	r3, #0
  217f76:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217f78:	2300      	movs	r3, #0
  217f7a:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  217f7c:	230e      	movs	r3, #14
  217f7e:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
  217f80:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217f84:	4619      	mov	r1, r3
  217f86:	484c      	ldr	r0, [pc, #304]	; (2180b8 <HAL_LTDC_MspInit+0x2d4>)
  217f88:	f001 ffd0 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
  217f8c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  217f90:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217f92:	2302      	movs	r3, #2
  217f94:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217f96:	2300      	movs	r3, #0
  217f98:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217f9a:	2300      	movs	r3, #0
  217f9c:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  217f9e:	230e      	movs	r3, #14
  217fa0:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
  217fa2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217fa6:	4619      	mov	r1, r3
  217fa8:	4844      	ldr	r0, [pc, #272]	; (2180bc <HAL_LTDC_MspInit+0x2d8>)
  217faa:	f001 ffbf 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0;
  217fae:	2301      	movs	r3, #1
  217fb0:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217fb2:	2302      	movs	r3, #2
  217fb4:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217fb6:	2300      	movs	r3, #0
  217fb8:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217fba:	2300      	movs	r3, #0
  217fbc:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  217fbe:	230e      	movs	r3, #14
  217fc0:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  217fc2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217fc6:	4619      	mov	r1, r3
  217fc8:	483d      	ldr	r0, [pc, #244]	; (2180c0 <HAL_LTDC_MspInit+0x2dc>)
  217fca:	f001 ffaf 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_4;
  217fce:	2310      	movs	r3, #16
  217fd0:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217fd2:	2302      	movs	r3, #2
  217fd4:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217fd6:	2300      	movs	r3, #0
  217fd8:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217fda:	2300      	movs	r3, #0
  217fdc:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
  217fde:	2309      	movs	r3, #9
  217fe0:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
  217fe2:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  217fe6:	4619      	mov	r1, r3
  217fe8:	4836      	ldr	r0, [pc, #216]	; (2180c4 <HAL_LTDC_MspInit+0x2e0>)
  217fea:	f001 ff9f 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_5|GPIO_PIN_6;
  217fee:	2368      	movs	r3, #104	; 0x68
  217ff0:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  217ff2:	2302      	movs	r3, #2
  217ff4:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  217ff6:	2300      	movs	r3, #0
  217ff8:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  217ffa:	2300      	movs	r3, #0
  217ffc:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  217ffe:	230e      	movs	r3, #14
  218000:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  218002:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  218006:	4619      	mov	r1, r3
  218008:	482f      	ldr	r0, [pc, #188]	; (2180c8 <HAL_LTDC_MspInit+0x2e4>)
  21800a:	f001 ff8f 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
  21800e:	2303      	movs	r3, #3
  218010:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218012:	2302      	movs	r3, #2
  218014:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  218016:	2300      	movs	r3, #0
  218018:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  21801a:	2300      	movs	r3, #0
  21801c:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
  21801e:	2309      	movs	r3, #9
  218020:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  218022:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  218026:	4619      	mov	r1, r3
  218028:	4828      	ldr	r0, [pc, #160]	; (2180cc <HAL_LTDC_MspInit+0x2e8>)
  21802a:	f001 ff7f 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_13;
  21802e:	f242 0303 	movw	r3, #8195	; 0x2003
  218032:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218034:	2302      	movs	r3, #2
  218036:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  218038:	2300      	movs	r3, #0
  21803a:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  21803c:	2300      	movs	r3, #0
  21803e:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  218040:	230e      	movs	r3, #14
  218042:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
  218044:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  218048:	4619      	mov	r1, r3
  21804a:	4821      	ldr	r0, [pc, #132]	; (2180d0 <HAL_LTDC_MspInit+0x2ec>)
  21804c:	f001 ff6e 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
  218050:	f44f 6380 	mov.w	r3, #1024	; 0x400
  218054:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218056:	2302      	movs	r3, #2
  218058:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  21805a:	2300      	movs	r3, #0
  21805c:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  21805e:	2300      	movs	r3, #0
  218060:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  218062:	230e      	movs	r3, #14
  218064:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
  218066:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  21806a:	4619      	mov	r1, r3
  21806c:	4817      	ldr	r0, [pc, #92]	; (2180cc <HAL_LTDC_MspInit+0x2e8>)
  21806e:	f001 ff5d 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_6;
  218072:	2340      	movs	r3, #64	; 0x40
  218074:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218076:	2302      	movs	r3, #2
  218078:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  21807a:	2300      	movs	r3, #0
  21807c:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  21807e:	2300      	movs	r3, #0
  218080:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  218082:	230e      	movs	r3, #14
  218084:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
  218086:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  21808a:	4619      	mov	r1, r3
  21808c:	4811      	ldr	r0, [pc, #68]	; (2180d4 <HAL_LTDC_MspInit+0x2f0>)
  21808e:	f001 ff4d 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_8;
  218092:	f44f 7380 	mov.w	r3, #256	; 0x100
  218096:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218098:	2302      	movs	r3, #2
  21809a:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  21809c:	2300      	movs	r3, #0
  21809e:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2180a0:	2300      	movs	r3, #0
  2180a2:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF13_LTDC;
  2180a4:	230d      	movs	r3, #13
  2180a6:	64fb      	str	r3, [r7, #76]	; 0x4c
  2180a8:	e016      	b.n	2180d8 <HAL_LTDC_MspInit+0x2f4>
  2180aa:	bf00      	nop
  2180ac:	40016800 	.word	0x40016800
  2180b0:	40023800 	.word	0x40023800
  2180b4:	40021000 	.word	0x40021000
  2180b8:	40022000 	.word	0x40022000
  2180bc:	40021400 	.word	0x40021400
  2180c0:	40020800 	.word	0x40020800
  2180c4:	40021c00 	.word	0x40021c00
  2180c8:	40020000 	.word	0x40020000
  2180cc:	40020400 	.word	0x40020400
  2180d0:	40022400 	.word	0x40022400
  2180d4:	40021800 	.word	0x40021800
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  2180d8:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  2180dc:	4619      	mov	r1, r3
  2180de:	4824      	ldr	r0, [pc, #144]	; (218170 <HAL_LTDC_MspInit+0x38c>)
  2180e0:	f001 ff24 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_10;
  2180e4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  2180e8:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2180ea:	2302      	movs	r3, #2
  2180ec:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2180ee:	2300      	movs	r3, #0
  2180f0:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  2180f2:	2300      	movs	r3, #0
  2180f4:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
  2180f6:	2309      	movs	r3, #9
  2180f8:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  2180fa:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  2180fe:	4619      	mov	r1, r3
  218100:	481b      	ldr	r0, [pc, #108]	; (218170 <HAL_LTDC_MspInit+0x38c>)
  218102:	f001 ff13 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_6;
  218106:	2348      	movs	r3, #72	; 0x48
  218108:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  21810a:	2302      	movs	r3, #2
  21810c:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  21810e:	2300      	movs	r3, #0
  218110:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  218112:	2300      	movs	r3, #0
  218114:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  218116:	230e      	movs	r3, #14
  218118:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  21811a:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  21811e:	4619      	mov	r1, r3
  218120:	4814      	ldr	r0, [pc, #80]	; (218174 <HAL_LTDC_MspInit+0x390>)
  218122:	f001 ff03 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_12;
  218126:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  21812a:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  21812c:	2302      	movs	r3, #2
  21812e:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  218130:	2300      	movs	r3, #0
  218132:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  218134:	2300      	movs	r3, #0
  218136:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
  218138:	2309      	movs	r3, #9
  21813a:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
  21813c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  218140:	4619      	mov	r1, r3
  218142:	480d      	ldr	r0, [pc, #52]	; (218178 <HAL_LTDC_MspInit+0x394>)
  218144:	f001 fef2 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
  218148:	2360      	movs	r3, #96	; 0x60
  21814a:	63fb      	str	r3, [r7, #60]	; 0x3c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  21814c:	2302      	movs	r3, #2
  21814e:	643b      	str	r3, [r7, #64]	; 0x40
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  218150:	2300      	movs	r3, #0
  218152:	647b      	str	r3, [r7, #68]	; 0x44
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  218154:	2300      	movs	r3, #0
  218156:	64bb      	str	r3, [r7, #72]	; 0x48
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
  218158:	230e      	movs	r3, #14
  21815a:	64fb      	str	r3, [r7, #76]	; 0x4c
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
  21815c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
  218160:	4619      	mov	r1, r3
  218162:	4806      	ldr	r0, [pc, #24]	; (21817c <HAL_LTDC_MspInit+0x398>)
  218164:	f001 fee2 	bl	219f2c <HAL_GPIO_Init>

  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }
}
  218168:	bf00      	nop
  21816a:	3750      	adds	r7, #80	; 0x50
  21816c:	46bd      	mov	sp, r7
  21816e:	bd80      	pop	{r7, pc}
  218170:	40020000 	.word	0x40020000
  218174:	40020c00 	.word	0x40020c00
  218178:	40022400 	.word	0x40022400
  21817c:	40022800 	.word	0x40022800

00218180 <SCB_EnableICache>:
{
  218180:	b480      	push	{r7}
  218182:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
  218184:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  218188:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  21818c:	4b0b      	ldr	r3, [pc, #44]	; (2181bc <SCB_EnableICache+0x3c>)
  21818e:	2200      	movs	r2, #0
  218190:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  218194:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  218198:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  21819c:	4a07      	ldr	r2, [pc, #28]	; (2181bc <SCB_EnableICache+0x3c>)
  21819e:	4b07      	ldr	r3, [pc, #28]	; (2181bc <SCB_EnableICache+0x3c>)
  2181a0:	695b      	ldr	r3, [r3, #20]
  2181a2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  2181a6:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  2181a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2181ac:	f3bf 8f6f 	isb	sy
}
  2181b0:	bf00      	nop
  2181b2:	46bd      	mov	sp, r7
  2181b4:	f85d 7b04 	ldr.w	r7, [sp], #4
  2181b8:	4770      	bx	lr
  2181ba:	bf00      	nop
  2181bc:	e000ed00 	.word	0xe000ed00

002181c0 <SCB_InvalidateICache>:
{
  2181c0:	b480      	push	{r7}
  2181c2:	af00      	add	r7, sp, #0
  __ASM volatile ("dsb 0xF":::"memory");
  2181c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2181c8:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;
  2181cc:	4b06      	ldr	r3, [pc, #24]	; (2181e8 <SCB_InvalidateICache+0x28>)
  2181ce:	2200      	movs	r2, #0
  2181d0:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  2181d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2181d8:	f3bf 8f6f 	isb	sy
}
  2181dc:	bf00      	nop
  2181de:	46bd      	mov	sp, r7
  2181e0:	f85d 7b04 	ldr.w	r7, [sp], #4
  2181e4:	4770      	bx	lr
  2181e6:	bf00      	nop
  2181e8:	e000ed00 	.word	0xe000ed00

002181ec <SCB_EnableDCache>:
{
  2181ec:	b480      	push	{r7}
  2181ee:	b085      	sub	sp, #20
  2181f0:	af00      	add	r7, sp, #0
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  2181f2:	4b1d      	ldr	r3, [pc, #116]	; (218268 <SCB_EnableDCache+0x7c>)
  2181f4:	2200      	movs	r2, #0
  2181f6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  2181fa:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
  2181fe:	4b1a      	ldr	r3, [pc, #104]	; (218268 <SCB_EnableDCache+0x7c>)
  218200:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  218204:	607b      	str	r3, [r7, #4]
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  218206:	687b      	ldr	r3, [r7, #4]
  218208:	0b5b      	lsrs	r3, r3, #13
  21820a:	f3c3 030e 	ubfx	r3, r3, #0, #15
  21820e:	60fb      	str	r3, [r7, #12]
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  218210:	687b      	ldr	r3, [r7, #4]
  218212:	08db      	lsrs	r3, r3, #3
  218214:	f3c3 0309 	ubfx	r3, r3, #0, #10
  218218:	60bb      	str	r3, [r7, #8]
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  21821a:	4913      	ldr	r1, [pc, #76]	; (218268 <SCB_EnableDCache+0x7c>)
  21821c:	68fb      	ldr	r3, [r7, #12]
  21821e:	015a      	lsls	r2, r3, #5
  218220:	f643 73e0 	movw	r3, #16352	; 0x3fe0
  218224:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
  218226:	68ba      	ldr	r2, [r7, #8]
  218228:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  21822a:	4313      	orrs	r3, r2
  21822c:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
      } while (ways-- != 0U);
  218230:	68bb      	ldr	r3, [r7, #8]
  218232:	1e5a      	subs	r2, r3, #1
  218234:	60ba      	str	r2, [r7, #8]
  218236:	2b00      	cmp	r3, #0
  218238:	d1ef      	bne.n	21821a <SCB_EnableDCache+0x2e>
    } while(sets-- != 0U);
  21823a:	68fb      	ldr	r3, [r7, #12]
  21823c:	1e5a      	subs	r2, r3, #1
  21823e:	60fa      	str	r2, [r7, #12]
  218240:	2b00      	cmp	r3, #0
  218242:	d1e5      	bne.n	218210 <SCB_EnableDCache+0x24>
  218244:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  218248:	4a07      	ldr	r2, [pc, #28]	; (218268 <SCB_EnableDCache+0x7c>)
  21824a:	4b07      	ldr	r3, [pc, #28]	; (218268 <SCB_EnableDCache+0x7c>)
  21824c:	695b      	ldr	r3, [r3, #20]
  21824e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  218252:	6153      	str	r3, [r2, #20]
  218254:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  218258:	f3bf 8f6f 	isb	sy
}
  21825c:	bf00      	nop
  21825e:	3714      	adds	r7, #20
  218260:	46bd      	mov	sp, r7
  218262:	f85d 7b04 	ldr.w	r7, [sp], #4
  218266:	4770      	bx	lr
  218268:	e000ed00 	.word	0xe000ed00

0021826c <SCB_InvalidateDCache>:
{
  21826c:	b480      	push	{r7}
  21826e:	b085      	sub	sp, #20
  218270:	af00      	add	r7, sp, #0
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  218272:	4b19      	ldr	r3, [pc, #100]	; (2182d8 <SCB_InvalidateDCache+0x6c>)
  218274:	2200      	movs	r2, #0
  218276:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  21827a:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
  21827e:	4b16      	ldr	r3, [pc, #88]	; (2182d8 <SCB_InvalidateDCache+0x6c>)
  218280:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  218284:	607b      	str	r3, [r7, #4]
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  218286:	687b      	ldr	r3, [r7, #4]
  218288:	0b5b      	lsrs	r3, r3, #13
  21828a:	f3c3 030e 	ubfx	r3, r3, #0, #15
  21828e:	60fb      	str	r3, [r7, #12]
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  218290:	687b      	ldr	r3, [r7, #4]
  218292:	08db      	lsrs	r3, r3, #3
  218294:	f3c3 0309 	ubfx	r3, r3, #0, #10
  218298:	60bb      	str	r3, [r7, #8]
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  21829a:	490f      	ldr	r1, [pc, #60]	; (2182d8 <SCB_InvalidateDCache+0x6c>)
  21829c:	68fb      	ldr	r3, [r7, #12]
  21829e:	015a      	lsls	r2, r3, #5
  2182a0:	f643 73e0 	movw	r3, #16352	; 0x3fe0
  2182a4:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
  2182a6:	68ba      	ldr	r2, [r7, #8]
  2182a8:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  2182aa:	4313      	orrs	r3, r2
  2182ac:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
      } while (ways-- != 0U);
  2182b0:	68bb      	ldr	r3, [r7, #8]
  2182b2:	1e5a      	subs	r2, r3, #1
  2182b4:	60ba      	str	r2, [r7, #8]
  2182b6:	2b00      	cmp	r3, #0
  2182b8:	d1ef      	bne.n	21829a <SCB_InvalidateDCache+0x2e>
    } while(sets-- != 0U);
  2182ba:	68fb      	ldr	r3, [r7, #12]
  2182bc:	1e5a      	subs	r2, r3, #1
  2182be:	60fa      	str	r2, [r7, #12]
  2182c0:	2b00      	cmp	r3, #0
  2182c2:	d1e5      	bne.n	218290 <SCB_InvalidateDCache+0x24>
  2182c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  2182c8:	f3bf 8f6f 	isb	sy
}
  2182cc:	bf00      	nop
  2182ce:	3714      	adds	r7, #20
  2182d0:	46bd      	mov	sp, r7
  2182d2:	f85d 7b04 	ldr.w	r7, [sp], #4
  2182d6:	4770      	bx	lr
  2182d8:	e000ed00 	.word	0xe000ed00

002182dc <HARDWARE_Init>:
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
void HARDWARE_Init(void)
{
  2182dc:	b580      	push	{r7, lr}
  2182de:	af00      	add	r7, sp, #0
	SystemClock_Config();
  2182e0:	f000 f82e 	bl	218340 <SystemClock_Config>
	HAL_Delay(200);
  2182e4:	20c8      	movs	r0, #200	; 0xc8
  2182e6:	f000 fdaf 	bl	218e48 <HAL_Delay>

	MX_GPIO_Init();
  2182ea:	f7ff fc4b 	bl	217b84 <MX_GPIO_Init>
	MX_DMA_Init();
  2182ee:	f7ff f98d 	bl	21760c <MX_DMA_Init>
	DEBUG_Init();
  2182f2:	f7e8 fac9 	bl	200888 <DEBUG_Init>
	MX_SDMMC1_SD_Init();
  2182f6:	f000 f923 	bl	218540 <MX_SDMMC1_SD_Init>

	MX_FMC_Init();
  2182fa:	f7ff fb0f 	bl	21791c <MX_FMC_Init>
	SDRAM_Initialization_Sequence();
  2182fe:	f7ff fa1d 	bl	21773c <SDRAM_Initialization_Sequence>
	TestSDRAM();
  218302:	f7ff fa7f 	bl	217804 <TestSDRAM>

	MX_LTDC_Init();
  218306:	f7ff fce9 	bl	217cdc <MX_LTDC_Init>
	MX_DMA2D_Init();
  21830a:	f7ff f9b9 	bl	217680 <MX_DMA2D_Init>

	MX_TIM5_Init();
  21830e:	f000 fb1b 	bl	218948 <MX_TIM5_Init>





}
  218312:	bf00      	nop
  218314:	bd80      	pop	{r7, pc}

00218316 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  218316:	b580      	push	{r7, lr}
  218318:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN 1 */
	SCB_InvalidateICache();
  21831a:	f7ff ff51 	bl	2181c0 <SCB_InvalidateICache>
	SCB_InvalidateDCache();
  21831e:	f7ff ffa5 	bl	21826c <SCB_InvalidateDCache>
  /* USER CODE END 1 */

  /* MPU Configuration--------------------------------------------------------*/
  MPU_Config();
  218322:	f000 f8b1 	bl	218488 <MPU_Config>

  /* Enable I-Cache---------------------------------------------------------*/
  SCB_EnableICache();
  218326:	f7ff ff2b 	bl	218180 <SCB_EnableICache>

  /* Enable D-Cache---------------------------------------------------------*/
  SCB_EnableDCache();
  21832a:	f7ff ff5f 	bl	2181ec <SCB_EnableDCache>

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
  21832e:	f000 fd4f 	bl	218dd0 <HAL_Init>

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  /* USER CODE BEGIN 2 */
  HARDWARE_Init();
  218332:	f7ff ffd3 	bl	2182dc <HARDWARE_Init>
  /* USER CODE END 2 */

  /* Call init function for freertos objects (in freertos.c) */
  MX_FREERTOS_Init();
  218336:	f7ff fbf7 	bl	217b28 <MX_FREERTOS_Init>
  /* Start scheduler */
  osKernelStart();
  21833a:	f00b f9fa 	bl	223732 <osKernelStart>

  /* We should never get here as control is now taken by the scheduler */
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  21833e:	e7fe      	b.n	21833e <main+0x28>

00218340 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  218340:	b580      	push	{r7, lr}
  218342:	b0b8      	sub	sp, #224	; 0xe0
  218344:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  218346:	f107 03ac 	add.w	r3, r7, #172	; 0xac
  21834a:	2234      	movs	r2, #52	; 0x34
  21834c:	2100      	movs	r1, #0
  21834e:	4618      	mov	r0, r3
  218350:	f00e f8ef 	bl	226532 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  218354:	f107 0398 	add.w	r3, r7, #152	; 0x98
  218358:	2200      	movs	r2, #0
  21835a:	601a      	str	r2, [r3, #0]
  21835c:	605a      	str	r2, [r3, #4]
  21835e:	609a      	str	r2, [r3, #8]
  218360:	60da      	str	r2, [r3, #12]
  218362:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
  218364:	f107 0308 	add.w	r3, r7, #8
  218368:	2290      	movs	r2, #144	; 0x90
  21836a:	2100      	movs	r1, #0
  21836c:	4618      	mov	r0, r3
  21836e:	f00e f8e0 	bl	226532 <memset>

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  218372:	4a42      	ldr	r2, [pc, #264]	; (21847c <SystemClock_Config+0x13c>)
  218374:	4b41      	ldr	r3, [pc, #260]	; (21847c <SystemClock_Config+0x13c>)
  218376:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218378:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  21837c:	6413      	str	r3, [r2, #64]	; 0x40
  21837e:	4b3f      	ldr	r3, [pc, #252]	; (21847c <SystemClock_Config+0x13c>)
  218380:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218382:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  218386:	607b      	str	r3, [r7, #4]
  218388:	687b      	ldr	r3, [r7, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  21838a:	4a3d      	ldr	r2, [pc, #244]	; (218480 <SystemClock_Config+0x140>)
  21838c:	4b3c      	ldr	r3, [pc, #240]	; (218480 <SystemClock_Config+0x140>)
  21838e:	681b      	ldr	r3, [r3, #0]
  218390:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
  218394:	6013      	str	r3, [r2, #0]
  218396:	4b3a      	ldr	r3, [pc, #232]	; (218480 <SystemClock_Config+0x140>)
  218398:	681b      	ldr	r3, [r3, #0]
  21839a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  21839e:	603b      	str	r3, [r7, #0]
  2183a0:	683b      	ldr	r3, [r7, #0]
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  2183a2:	2301      	movs	r3, #1
  2183a4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  2183a8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  2183ac:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  2183b0:	2302      	movs	r3, #2
  2183b2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  2183b6:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  2183ba:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  RCC_OscInitStruct.PLL.PLLM = 25;
  2183be:	2319      	movs	r3, #25
  2183c0:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  RCC_OscInitStruct.PLL.PLLN = 432;
  2183c4:	f44f 73d8 	mov.w	r3, #432	; 0x1b0
  2183c8:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  2183cc:	2302      	movs	r3, #2
  2183ce:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  RCC_OscInitStruct.PLL.PLLQ = 9;
  2183d2:	2309      	movs	r3, #9
  2183d4:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  2183d8:	f107 03ac 	add.w	r3, r7, #172	; 0xac
  2183dc:	4618      	mov	r0, r3
  2183de:	f002 fa69 	bl	21a8b4 <HAL_RCC_OscConfig>
  2183e2:	4603      	mov	r3, r0
  2183e4:	2b00      	cmp	r3, #0
  2183e6:	d001      	beq.n	2183ec <SystemClock_Config+0xac>
  {
    Error_Handler();
  2183e8:	f000 f8a6 	bl	218538 <Error_Handler>
  }
  /** Activate the Over-Drive mode
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
  2183ec:	f002 fa12 	bl	21a814 <HAL_PWREx_EnableOverDrive>
  2183f0:	4603      	mov	r3, r0
  2183f2:	2b00      	cmp	r3, #0
  2183f4:	d001      	beq.n	2183fa <SystemClock_Config+0xba>
  {
    Error_Handler();
  2183f6:	f000 f89f 	bl	218538 <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
  2183fa:	230f      	movs	r3, #15
  2183fc:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  218400:	2302      	movs	r3, #2
  218402:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  218406:	2300      	movs	r3, #0
  218408:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  21840c:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  218410:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  218414:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  218418:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
  21841c:	f107 0398 	add.w	r3, r7, #152	; 0x98
  218420:	2107      	movs	r1, #7
  218422:	4618      	mov	r0, r3
  218424:	f002 fcf4 	bl	21ae10 <HAL_RCC_ClockConfig>
  218428:	4603      	mov	r3, r0
  21842a:	2b00      	cmp	r3, #0
  21842c:	d001      	beq.n	218432 <SystemClock_Config+0xf2>
  {
    Error_Handler();
  21842e:	f000 f883 	bl	218538 <Error_Handler>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_UART7
  218432:	4b14      	ldr	r3, [pc, #80]	; (218484 <SystemClock_Config+0x144>)
  218434:	60bb      	str	r3, [r7, #8]
                              |RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
  218436:	23c0      	movs	r3, #192	; 0xc0
  218438:	61fb      	str	r3, [r7, #28]
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 2;
  21843a:	2302      	movs	r3, #2
  21843c:	627b      	str	r3, [r7, #36]	; 0x24
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
  21843e:	2302      	movs	r3, #2
  218440:	623b      	str	r3, [r7, #32]
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV2;
  218442:	2300      	movs	r3, #0
  218444:	62bb      	str	r3, [r7, #40]	; 0x28
  PeriphClkInitStruct.PLLSAIDivQ = 1;
  218446:	2301      	movs	r3, #1
  218448:	633b      	str	r3, [r7, #48]	; 0x30
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
  21844a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  21844e:	637b      	str	r3, [r7, #52]	; 0x34
  PeriphClkInitStruct.Uart7ClockSelection = RCC_UART7CLKSOURCE_PCLK1;
  218450:	2300      	movs	r3, #0
  218452:	667b      	str	r3, [r7, #100]	; 0x64
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
  218454:	2300      	movs	r3, #0
  218456:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  PeriphClkInitStruct.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_CLK48;
  21845a:	2300      	movs	r3, #0
  21845c:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
  218460:	f107 0308 	add.w	r3, r7, #8
  218464:	4618      	mov	r0, r3
  218466:	f002 fedb 	bl	21b220 <HAL_RCCEx_PeriphCLKConfig>
  21846a:	4603      	mov	r3, r0
  21846c:	2b00      	cmp	r3, #0
  21846e:	d001      	beq.n	218474 <SystemClock_Config+0x134>
  {
    Error_Handler();
  218470:	f000 f862 	bl	218538 <Error_Handler>
  }
}
  218474:	bf00      	nop
  218476:	37e0      	adds	r7, #224	; 0xe0
  218478:	46bd      	mov	sp, r7
  21847a:	bd80      	pop	{r7, pc}
  21847c:	40023800 	.word	0x40023800
  218480:	40007000 	.word	0x40007000
  218484:	00a01008 	.word	0x00a01008

00218488 <MPU_Config>:
/* USER CODE END 4 */

/* MPU Configuration */

void MPU_Config(void)
{
  218488:	b580      	push	{r7, lr}
  21848a:	b084      	sub	sp, #16
  21848c:	af00      	add	r7, sp, #0
  MPU_Region_InitTypeDef MPU_InitStruct = {0};
  21848e:	463b      	mov	r3, r7
  218490:	2200      	movs	r2, #0
  218492:	601a      	str	r2, [r3, #0]
  218494:	605a      	str	r2, [r3, #4]
  218496:	609a      	str	r2, [r3, #8]
  218498:	60da      	str	r2, [r3, #12]

  /* Disables the MPU */
  HAL_MPU_Disable();
  21849a:	f000 fdd7 	bl	21904c <HAL_MPU_Disable>
  /** Initializes and configures the Region and the memory to be protected
  */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
  21849e:	2301      	movs	r3, #1
  2184a0:	703b      	strb	r3, [r7, #0]
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  2184a2:	2300      	movs	r3, #0
  2184a4:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.BaseAddress = 0x0;
  2184a6:	2300      	movs	r3, #0
  2184a8:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_2MB;
  2184aa:	2314      	movs	r3, #20
  2184ac:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.SubRegionDisable = 0x0;
  2184ae:	2300      	movs	r3, #0
  2184b0:	727b      	strb	r3, [r7, #9]
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  2184b2:	2300      	movs	r3, #0
  2184b4:	72bb      	strb	r3, [r7, #10]
  MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
  2184b6:	2303      	movs	r3, #3
  2184b8:	72fb      	strb	r3, [r7, #11]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
  2184ba:	2300      	movs	r3, #0
  2184bc:	733b      	strb	r3, [r7, #12]
  MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
  2184be:	2300      	movs	r3, #0
  2184c0:	737b      	strb	r3, [r7, #13]
  MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
  2184c2:	2301      	movs	r3, #1
  2184c4:	73bb      	strb	r3, [r7, #14]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
  2184c6:	2301      	movs	r3, #1
  2184c8:	73fb      	strb	r3, [r7, #15]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  2184ca:	463b      	mov	r3, r7
  2184cc:	4618      	mov	r0, r3
  2184ce:	f000 fdf1 	bl	2190b4 <HAL_MPU_ConfigRegion>
  /** Initializes and configures the Region and the memory to be protected
  */
  MPU_InitStruct.Number = MPU_REGION_NUMBER1;
  2184d2:	2301      	movs	r3, #1
  2184d4:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.BaseAddress = 0x20000000;
  2184d6:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000
  2184da:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_512KB;
  2184dc:	2312      	movs	r3, #18
  2184de:	723b      	strb	r3, [r7, #8]
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
  2184e0:	2301      	movs	r3, #1
  2184e2:	733b      	strb	r3, [r7, #12]
  MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
  2184e4:	2300      	movs	r3, #0
  2184e6:	73fb      	strb	r3, [r7, #15]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  2184e8:	463b      	mov	r3, r7
  2184ea:	4618      	mov	r0, r3
  2184ec:	f000 fde2 	bl	2190b4 <HAL_MPU_ConfigRegion>
  /** Initializes and configures the Region and the memory to be protected
  */
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
  2184f0:	2302      	movs	r3, #2
  2184f2:	707b      	strb	r3, [r7, #1]
  MPU_InitStruct.BaseAddress = 0xC0000000;
  2184f4:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
  2184f8:	607b      	str	r3, [r7, #4]
  MPU_InitStruct.Size = MPU_REGION_SIZE_16MB;
  2184fa:	2317      	movs	r3, #23
  2184fc:	723b      	strb	r3, [r7, #8]

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  2184fe:	463b      	mov	r3, r7
  218500:	4618      	mov	r0, r3
  218502:	f000 fdd7 	bl	2190b4 <HAL_MPU_ConfigRegion>
  /* Enables the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
  218506:	2004      	movs	r0, #4
  218508:	f000 fdb6 	bl	219078 <HAL_MPU_Enable>

}
  21850c:	bf00      	nop
  21850e:	3710      	adds	r7, #16
  218510:	46bd      	mov	sp, r7
  218512:	bd80      	pop	{r7, pc}

00218514 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  218514:	b580      	push	{r7, lr}
  218516:	b082      	sub	sp, #8
  218518:	af00      	add	r7, sp, #0
  21851a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM14) {
  21851c:	687b      	ldr	r3, [r7, #4]
  21851e:	681b      	ldr	r3, [r3, #0]
  218520:	4a04      	ldr	r2, [pc, #16]	; (218534 <HAL_TIM_PeriodElapsedCallback+0x20>)
  218522:	4293      	cmp	r3, r2
  218524:	d101      	bne.n	21852a <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
  218526:	f000 fc6f 	bl	218e08 <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
  21852a:	bf00      	nop
  21852c:	3708      	adds	r7, #8
  21852e:	46bd      	mov	sp, r7
  218530:	bd80      	pop	{r7, pc}
  218532:	bf00      	nop
  218534:	40002000 	.word	0x40002000

00218538 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  218538:	b480      	push	{r7}
  21853a:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
  21853c:	b672      	cpsid	i
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  21853e:	e7fe      	b.n	21853e <Error_Handler+0x6>

00218540 <MX_SDMMC1_SD_Init>:
DMA_HandleTypeDef hdma_sdmmc1_tx;

/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{
  218540:	b480      	push	{r7}
  218542:	af00      	add	r7, sp, #0
  /* USER CODE END SDMMC1_Init 0 */

  /* USER CODE BEGIN SDMMC1_Init 1 */

  /* USER CODE END SDMMC1_Init 1 */
  hsd1.Instance = SDMMC1;
  218544:	4b0c      	ldr	r3, [pc, #48]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  218546:	4a0d      	ldr	r2, [pc, #52]	; (21857c <MX_SDMMC1_SD_Init+0x3c>)
  218548:	601a      	str	r2, [r3, #0]
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
  21854a:	4b0b      	ldr	r3, [pc, #44]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  21854c:	2200      	movs	r2, #0
  21854e:	605a      	str	r2, [r3, #4]
  hsd1.Init.ClockBypass = SDMMC_CLOCK_BYPASS_DISABLE;
  218550:	4b09      	ldr	r3, [pc, #36]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  218552:	2200      	movs	r2, #0
  218554:	609a      	str	r2, [r3, #8]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  218556:	4b08      	ldr	r3, [pc, #32]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  218558:	2200      	movs	r2, #0
  21855a:	60da      	str	r2, [r3, #12]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_1B;
  21855c:	4b06      	ldr	r3, [pc, #24]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  21855e:	2200      	movs	r2, #0
  218560:	611a      	str	r2, [r3, #16]
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  218562:	4b05      	ldr	r3, [pc, #20]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  218564:	2200      	movs	r2, #0
  218566:	615a      	str	r2, [r3, #20]
  hsd1.Init.ClockDiv = 0;
  218568:	4b03      	ldr	r3, [pc, #12]	; (218578 <MX_SDMMC1_SD_Init+0x38>)
  21856a:	2200      	movs	r2, #0
  21856c:	619a      	str	r2, [r3, #24]
  /* USER CODE BEGIN SDMMC1_Init 2 */

  /* USER CODE END SDMMC1_Init 2 */

}
  21856e:	bf00      	nop
  218570:	46bd      	mov	sp, r7
  218572:	f85d 7b04 	ldr.w	r7, [sp], #4
  218576:	4770      	bx	lr
  218578:	20014b9c 	.word	0x20014b9c
  21857c:	40012c00 	.word	0x40012c00

00218580 <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
  218580:	b580      	push	{r7, lr}
  218582:	b08a      	sub	sp, #40	; 0x28
  218584:	af00      	add	r7, sp, #0
  218586:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  218588:	f107 0314 	add.w	r3, r7, #20
  21858c:	2200      	movs	r2, #0
  21858e:	601a      	str	r2, [r3, #0]
  218590:	605a      	str	r2, [r3, #4]
  218592:	609a      	str	r2, [r3, #8]
  218594:	60da      	str	r2, [r3, #12]
  218596:	611a      	str	r2, [r3, #16]
  if(sdHandle->Instance==SDMMC1)
  218598:	687b      	ldr	r3, [r7, #4]
  21859a:	681b      	ldr	r3, [r3, #0]
  21859c:	4a66      	ldr	r2, [pc, #408]	; (218738 <HAL_SD_MspInit+0x1b8>)
  21859e:	4293      	cmp	r3, r2
  2185a0:	f040 80c5 	bne.w	21872e <HAL_SD_MspInit+0x1ae>
  {
  /* USER CODE BEGIN SDMMC1_MspInit 0 */

  /* USER CODE END SDMMC1_MspInit 0 */
    /* SDMMC1 clock enable */
    __HAL_RCC_SDMMC1_CLK_ENABLE();
  2185a4:	4a65      	ldr	r2, [pc, #404]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185a6:	4b65      	ldr	r3, [pc, #404]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2185aa:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  2185ae:	6453      	str	r3, [r2, #68]	; 0x44
  2185b0:	4b62      	ldr	r3, [pc, #392]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2185b4:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  2185b8:	613b      	str	r3, [r7, #16]
  2185ba:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOC_CLK_ENABLE();
  2185bc:	4a5f      	ldr	r2, [pc, #380]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185be:	4b5f      	ldr	r3, [pc, #380]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  2185c2:	f043 0304 	orr.w	r3, r3, #4
  2185c6:	6313      	str	r3, [r2, #48]	; 0x30
  2185c8:	4b5c      	ldr	r3, [pc, #368]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  2185cc:	f003 0304 	and.w	r3, r3, #4
  2185d0:	60fb      	str	r3, [r7, #12]
  2185d2:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOD_CLK_ENABLE();
  2185d4:	4a59      	ldr	r2, [pc, #356]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185d6:	4b59      	ldr	r3, [pc, #356]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185d8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  2185da:	f043 0308 	orr.w	r3, r3, #8
  2185de:	6313      	str	r3, [r2, #48]	; 0x30
  2185e0:	4b56      	ldr	r3, [pc, #344]	; (21873c <HAL_SD_MspInit+0x1bc>)
  2185e2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  2185e4:	f003 0308 	and.w	r3, r3, #8
  2185e8:	60bb      	str	r3, [r7, #8]
  2185ea:	68bb      	ldr	r3, [r7, #8]
    PC10     ------> SDMMC1_D2
    PC11     ------> SDMMC1_D3
    PC12     ------> SDMMC1_CK
    PD2     ------> SDMMC1_CMD
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
  2185ec:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
  2185f0:	617b      	str	r3, [r7, #20]
                          |GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  2185f2:	2302      	movs	r3, #2
  2185f4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  2185f6:	2300      	movs	r3, #0
  2185f8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  2185fa:	2302      	movs	r3, #2
  2185fc:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
  2185fe:	230c      	movs	r3, #12
  218600:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
  218602:	f107 0314 	add.w	r3, r7, #20
  218606:	4619      	mov	r1, r3
  218608:	484d      	ldr	r0, [pc, #308]	; (218740 <HAL_SD_MspInit+0x1c0>)
  21860a:	f001 fc8f 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
  21860e:	2304      	movs	r3, #4
  218610:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218612:	2302      	movs	r3, #2
  218614:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  218616:	2300      	movs	r3, #0
  218618:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
  21861a:	2302      	movs	r3, #2
  21861c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
  21861e:	230c      	movs	r3, #12
  218620:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  218622:	f107 0314 	add.w	r3, r7, #20
  218626:	4619      	mov	r1, r3
  218628:	4846      	ldr	r0, [pc, #280]	; (218744 <HAL_SD_MspInit+0x1c4>)
  21862a:	f001 fc7f 	bl	219f2c <HAL_GPIO_Init>

    /* SDMMC1 DMA Init */
    /* SDMMC1_RX Init */
    hdma_sdmmc1_rx.Instance = DMA2_Stream3;
  21862e:	4b46      	ldr	r3, [pc, #280]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218630:	4a46      	ldr	r2, [pc, #280]	; (21874c <HAL_SD_MspInit+0x1cc>)
  218632:	601a      	str	r2, [r3, #0]
    hdma_sdmmc1_rx.Init.Channel = DMA_CHANNEL_4;
  218634:	4b44      	ldr	r3, [pc, #272]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218636:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  21863a:	605a      	str	r2, [r3, #4]
    hdma_sdmmc1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
  21863c:	4b42      	ldr	r3, [pc, #264]	; (218748 <HAL_SD_MspInit+0x1c8>)
  21863e:	2200      	movs	r2, #0
  218640:	609a      	str	r2, [r3, #8]
    hdma_sdmmc1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
  218642:	4b41      	ldr	r3, [pc, #260]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218644:	2200      	movs	r2, #0
  218646:	60da      	str	r2, [r3, #12]
    hdma_sdmmc1_rx.Init.MemInc = DMA_MINC_ENABLE;
  218648:	4b3f      	ldr	r3, [pc, #252]	; (218748 <HAL_SD_MspInit+0x1c8>)
  21864a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  21864e:	611a      	str	r2, [r3, #16]
    hdma_sdmmc1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  218650:	4b3d      	ldr	r3, [pc, #244]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218652:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  218656:	615a      	str	r2, [r3, #20]
    hdma_sdmmc1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
  218658:	4b3b      	ldr	r3, [pc, #236]	; (218748 <HAL_SD_MspInit+0x1c8>)
  21865a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  21865e:	619a      	str	r2, [r3, #24]
    hdma_sdmmc1_rx.Init.Mode = DMA_PFCTRL;
  218660:	4b39      	ldr	r3, [pc, #228]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218662:	2220      	movs	r2, #32
  218664:	61da      	str	r2, [r3, #28]
    hdma_sdmmc1_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
  218666:	4b38      	ldr	r3, [pc, #224]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218668:	f44f 3240 	mov.w	r2, #196608	; 0x30000
  21866c:	621a      	str	r2, [r3, #32]
    hdma_sdmmc1_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
  21866e:	4b36      	ldr	r3, [pc, #216]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218670:	2204      	movs	r2, #4
  218672:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sdmmc1_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
  218674:	4b34      	ldr	r3, [pc, #208]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218676:	2203      	movs	r2, #3
  218678:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sdmmc1_rx.Init.MemBurst = DMA_MBURST_INC4;
  21867a:	4b33      	ldr	r3, [pc, #204]	; (218748 <HAL_SD_MspInit+0x1c8>)
  21867c:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  218680:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sdmmc1_rx.Init.PeriphBurst = DMA_PBURST_INC4;
  218682:	4b31      	ldr	r3, [pc, #196]	; (218748 <HAL_SD_MspInit+0x1c8>)
  218684:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  218688:	631a      	str	r2, [r3, #48]	; 0x30
    if (HAL_DMA_Init(&hdma_sdmmc1_rx) != HAL_OK)
  21868a:	482f      	ldr	r0, [pc, #188]	; (218748 <HAL_SD_MspInit+0x1c8>)
  21868c:	f000 fd56 	bl	21913c <HAL_DMA_Init>
  218690:	4603      	mov	r3, r0
  218692:	2b00      	cmp	r3, #0
  218694:	d001      	beq.n	21869a <HAL_SD_MspInit+0x11a>
    {
      Error_Handler();
  218696:	f7ff ff4f 	bl	218538 <Error_Handler>
    }

    __HAL_LINKDMA(sdHandle,hdmarx,hdma_sdmmc1_rx);
  21869a:	687b      	ldr	r3, [r7, #4]
  21869c:	4a2a      	ldr	r2, [pc, #168]	; (218748 <HAL_SD_MspInit+0x1c8>)
  21869e:	641a      	str	r2, [r3, #64]	; 0x40
  2186a0:	4a29      	ldr	r2, [pc, #164]	; (218748 <HAL_SD_MspInit+0x1c8>)
  2186a2:	687b      	ldr	r3, [r7, #4]
  2186a4:	6393      	str	r3, [r2, #56]	; 0x38

    /* SDMMC1_TX Init */
    hdma_sdmmc1_tx.Instance = DMA2_Stream6;
  2186a6:	4b2a      	ldr	r3, [pc, #168]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186a8:	4a2a      	ldr	r2, [pc, #168]	; (218754 <HAL_SD_MspInit+0x1d4>)
  2186aa:	601a      	str	r2, [r3, #0]
    hdma_sdmmc1_tx.Init.Channel = DMA_CHANNEL_4;
  2186ac:	4b28      	ldr	r3, [pc, #160]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186ae:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  2186b2:	605a      	str	r2, [r3, #4]
    hdma_sdmmc1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
  2186b4:	4b26      	ldr	r3, [pc, #152]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186b6:	2240      	movs	r2, #64	; 0x40
  2186b8:	609a      	str	r2, [r3, #8]
    hdma_sdmmc1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
  2186ba:	4b25      	ldr	r3, [pc, #148]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186bc:	2200      	movs	r2, #0
  2186be:	60da      	str	r2, [r3, #12]
    hdma_sdmmc1_tx.Init.MemInc = DMA_MINC_ENABLE;
  2186c0:	4b23      	ldr	r3, [pc, #140]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186c2:	f44f 6280 	mov.w	r2, #1024	; 0x400
  2186c6:	611a      	str	r2, [r3, #16]
    hdma_sdmmc1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  2186c8:	4b21      	ldr	r3, [pc, #132]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186ca:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  2186ce:	615a      	str	r2, [r3, #20]
    hdma_sdmmc1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
  2186d0:	4b1f      	ldr	r3, [pc, #124]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186d2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
  2186d6:	619a      	str	r2, [r3, #24]
    hdma_sdmmc1_tx.Init.Mode = DMA_PFCTRL;
  2186d8:	4b1d      	ldr	r3, [pc, #116]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186da:	2220      	movs	r2, #32
  2186dc:	61da      	str	r2, [r3, #28]
    hdma_sdmmc1_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
  2186de:	4b1c      	ldr	r3, [pc, #112]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186e0:	f44f 3240 	mov.w	r2, #196608	; 0x30000
  2186e4:	621a      	str	r2, [r3, #32]
    hdma_sdmmc1_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
  2186e6:	4b1a      	ldr	r3, [pc, #104]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186e8:	2204      	movs	r2, #4
  2186ea:	625a      	str	r2, [r3, #36]	; 0x24
    hdma_sdmmc1_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
  2186ec:	4b18      	ldr	r3, [pc, #96]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186ee:	2203      	movs	r2, #3
  2186f0:	629a      	str	r2, [r3, #40]	; 0x28
    hdma_sdmmc1_tx.Init.MemBurst = DMA_MBURST_INC4;
  2186f2:	4b17      	ldr	r3, [pc, #92]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186f4:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  2186f8:	62da      	str	r2, [r3, #44]	; 0x2c
    hdma_sdmmc1_tx.Init.PeriphBurst = DMA_PBURST_INC4;
  2186fa:	4b15      	ldr	r3, [pc, #84]	; (218750 <HAL_SD_MspInit+0x1d0>)
  2186fc:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
  218700:	631a      	str	r2, [r3, #48]	; 0x30
    if (HAL_DMA_Init(&hdma_sdmmc1_tx) != HAL_OK)
  218702:	4813      	ldr	r0, [pc, #76]	; (218750 <HAL_SD_MspInit+0x1d0>)
  218704:	f000 fd1a 	bl	21913c <HAL_DMA_Init>
  218708:	4603      	mov	r3, r0
  21870a:	2b00      	cmp	r3, #0
  21870c:	d001      	beq.n	218712 <HAL_SD_MspInit+0x192>
    {
      Error_Handler();
  21870e:	f7ff ff13 	bl	218538 <Error_Handler>
    }

    __HAL_LINKDMA(sdHandle,hdmatx,hdma_sdmmc1_tx);
  218712:	687b      	ldr	r3, [r7, #4]
  218714:	4a0e      	ldr	r2, [pc, #56]	; (218750 <HAL_SD_MspInit+0x1d0>)
  218716:	63da      	str	r2, [r3, #60]	; 0x3c
  218718:	4a0d      	ldr	r2, [pc, #52]	; (218750 <HAL_SD_MspInit+0x1d0>)
  21871a:	687b      	ldr	r3, [r7, #4]
  21871c:	6393      	str	r3, [r2, #56]	; 0x38

    /* SDMMC1 interrupt Init */
    HAL_NVIC_SetPriority(SDMMC1_IRQn, 5, 0);
  21871e:	2200      	movs	r2, #0
  218720:	2105      	movs	r1, #5
  218722:	2031      	movs	r0, #49	; 0x31
  218724:	f000 fc68 	bl	218ff8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
  218728:	2031      	movs	r0, #49	; 0x31
  21872a:	f000 fc81 	bl	219030 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
  21872e:	bf00      	nop
  218730:	3728      	adds	r7, #40	; 0x28
  218732:	46bd      	mov	sp, r7
  218734:	bd80      	pop	{r7, pc}
  218736:	bf00      	nop
  218738:	40012c00 	.word	0x40012c00
  21873c:	40023800 	.word	0x40023800
  218740:	40020800 	.word	0x40020800
  218744:	40020c00 	.word	0x40020c00
  218748:	20014c20 	.word	0x20014c20
  21874c:	40026458 	.word	0x40026458
  218750:	20014c80 	.word	0x20014c80
  218754:	400264a0 	.word	0x400264a0

00218758 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
  218758:	b580      	push	{r7, lr}
  21875a:	b082      	sub	sp, #8
  21875c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
  21875e:	4a11      	ldr	r2, [pc, #68]	; (2187a4 <HAL_MspInit+0x4c>)
  218760:	4b10      	ldr	r3, [pc, #64]	; (2187a4 <HAL_MspInit+0x4c>)
  218762:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218764:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  218768:	6413      	str	r3, [r2, #64]	; 0x40
  21876a:	4b0e      	ldr	r3, [pc, #56]	; (2187a4 <HAL_MspInit+0x4c>)
  21876c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21876e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  218772:	607b      	str	r3, [r7, #4]
  218774:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
  218776:	4a0b      	ldr	r2, [pc, #44]	; (2187a4 <HAL_MspInit+0x4c>)
  218778:	4b0a      	ldr	r3, [pc, #40]	; (2187a4 <HAL_MspInit+0x4c>)
  21877a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21877c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  218780:	6453      	str	r3, [r2, #68]	; 0x44
  218782:	4b08      	ldr	r3, [pc, #32]	; (2187a4 <HAL_MspInit+0x4c>)
  218784:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  218786:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  21878a:	603b      	str	r3, [r7, #0]
  21878c:	683b      	ldr	r3, [r7, #0]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
  21878e:	2200      	movs	r2, #0
  218790:	210f      	movs	r1, #15
  218792:	f06f 0001 	mvn.w	r0, #1
  218796:	f000 fc2f 	bl	218ff8 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
  21879a:	bf00      	nop
  21879c:	3708      	adds	r7, #8
  21879e:	46bd      	mov	sp, r7
  2187a0:	bd80      	pop	{r7, pc}
  2187a2:	bf00      	nop
  2187a4:	40023800 	.word	0x40023800

002187a8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  2187a8:	b580      	push	{r7, lr}
  2187aa:	b08c      	sub	sp, #48	; 0x30
  2187ac:	af00      	add	r7, sp, #0
  2187ae:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
  2187b0:	2300      	movs	r3, #0
  2187b2:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              uwPrescalerValue = 0;
  2187b4:	2300      	movs	r3, #0
  2187b6:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t              pFLatency;
  /*Configure the TIM14 IRQ priority */
  HAL_NVIC_SetPriority(TIM8_TRG_COM_TIM14_IRQn, TickPriority ,0);
  2187b8:	2200      	movs	r2, #0
  2187ba:	6879      	ldr	r1, [r7, #4]
  2187bc:	202d      	movs	r0, #45	; 0x2d
  2187be:	f000 fc1b 	bl	218ff8 <HAL_NVIC_SetPriority>

  /* Enable the TIM14 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM8_TRG_COM_TIM14_IRQn);
  2187c2:	202d      	movs	r0, #45	; 0x2d
  2187c4:	f000 fc34 	bl	219030 <HAL_NVIC_EnableIRQ>
  /* Enable TIM14 clock */
  __HAL_RCC_TIM14_CLK_ENABLE();
  2187c8:	4a1f      	ldr	r2, [pc, #124]	; (218848 <HAL_InitTick+0xa0>)
  2187ca:	4b1f      	ldr	r3, [pc, #124]	; (218848 <HAL_InitTick+0xa0>)
  2187cc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2187ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  2187d2:	6413      	str	r3, [r2, #64]	; 0x40
  2187d4:	4b1c      	ldr	r3, [pc, #112]	; (218848 <HAL_InitTick+0xa0>)
  2187d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2187d8:	f403 7380 	and.w	r3, r3, #256	; 0x100
  2187dc:	60fb      	str	r3, [r7, #12]
  2187de:	68fb      	ldr	r3, [r7, #12]

  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
  2187e0:	f107 0210 	add.w	r2, r7, #16
  2187e4:	f107 0314 	add.w	r3, r7, #20
  2187e8:	4611      	mov	r1, r2
  2187ea:	4618      	mov	r0, r3
  2187ec:	f002 fce6 	bl	21b1bc <HAL_RCC_GetClockConfig>

  /* Compute TIM14 clock */
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
  2187f0:	f002 fcbc 	bl	21b16c <HAL_RCC_GetPCLK1Freq>
  2187f4:	4603      	mov	r3, r0
  2187f6:	005b      	lsls	r3, r3, #1
  2187f8:	62fb      	str	r3, [r7, #44]	; 0x2c
  /* Compute the prescaler value to have TIM14 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
  2187fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2187fc:	4a13      	ldr	r2, [pc, #76]	; (21884c <HAL_InitTick+0xa4>)
  2187fe:	fba2 2303 	umull	r2, r3, r2, r3
  218802:	0c9b      	lsrs	r3, r3, #18
  218804:	3b01      	subs	r3, #1
  218806:	62bb      	str	r3, [r7, #40]	; 0x28

  /* Initialize TIM14 */
  htim14.Instance = TIM14;
  218808:	4b11      	ldr	r3, [pc, #68]	; (218850 <HAL_InitTick+0xa8>)
  21880a:	4a12      	ldr	r2, [pc, #72]	; (218854 <HAL_InitTick+0xac>)
  21880c:	601a      	str	r2, [r3, #0]
  + Period = [(TIM14CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim14.Init.Period = (1000000U / 1000U) - 1U;
  21880e:	4b10      	ldr	r3, [pc, #64]	; (218850 <HAL_InitTick+0xa8>)
  218810:	f240 32e7 	movw	r2, #999	; 0x3e7
  218814:	60da      	str	r2, [r3, #12]
  htim14.Init.Prescaler = uwPrescalerValue;
  218816:	4a0e      	ldr	r2, [pc, #56]	; (218850 <HAL_InitTick+0xa8>)
  218818:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21881a:	6053      	str	r3, [r2, #4]
  htim14.Init.ClockDivision = 0;
  21881c:	4b0c      	ldr	r3, [pc, #48]	; (218850 <HAL_InitTick+0xa8>)
  21881e:	2200      	movs	r2, #0
  218820:	611a      	str	r2, [r3, #16]
  htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
  218822:	4b0b      	ldr	r3, [pc, #44]	; (218850 <HAL_InitTick+0xa8>)
  218824:	2200      	movs	r2, #0
  218826:	609a      	str	r2, [r3, #8]
  if(HAL_TIM_Base_Init(&htim14) == HAL_OK)
  218828:	4809      	ldr	r0, [pc, #36]	; (218850 <HAL_InitTick+0xa8>)
  21882a:	f004 fca7 	bl	21d17c <HAL_TIM_Base_Init>
  21882e:	4603      	mov	r3, r0
  218830:	2b00      	cmp	r3, #0
  218832:	d104      	bne.n	21883e <HAL_InitTick+0x96>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim14);
  218834:	4806      	ldr	r0, [pc, #24]	; (218850 <HAL_InitTick+0xa8>)
  218836:	f004 fd91 	bl	21d35c <HAL_TIM_Base_Start_IT>
  21883a:	4603      	mov	r3, r0
  21883c:	e000      	b.n	218840 <HAL_InitTick+0x98>
  }

  /* Return function status */
  return HAL_ERROR;
  21883e:	2301      	movs	r3, #1
}
  218840:	4618      	mov	r0, r3
  218842:	3730      	adds	r7, #48	; 0x30
  218844:	46bd      	mov	sp, r7
  218846:	bd80      	pop	{r7, pc}
  218848:	40023800 	.word	0x40023800
  21884c:	431bde83 	.word	0x431bde83
  218850:	20014ce0 	.word	0x20014ce0
  218854:	40002000 	.word	0x40002000

00218858 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
  218858:	b580      	push	{r7, lr}
  21885a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
	ERROR_NMIHandler();
  21885c:	f7e8 fc00 	bl	201060 <ERROR_NMIHandler>
  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
  while (1)
  218860:	e7fe      	b.n	218860 <NMI_Handler+0x8>

00218862 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
  218862:	b580      	push	{r7, lr}
  218864:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */
	ERROR_HardFaulHandler();
  218866:	f7e8 fc05 	bl	201074 <ERROR_HardFaulHandler>
  /* USER CODE END HardFault_IRQn 0 */
  while (1)
  21886a:	e7fe      	b.n	21886a <HardFault_Handler+0x8>

0021886c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
  21886c:	b580      	push	{r7, lr}
  21886e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */
	ERROR_MemManageHandler();
  218870:	f7e8 fc0a 	bl	201088 <ERROR_MemManageHandler>
  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
  218874:	e7fe      	b.n	218874 <MemManage_Handler+0x8>

00218876 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
  218876:	b580      	push	{r7, lr}
  218878:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */
	ERROR_BusFaultHandler();
  21887a:	f7e8 fc0f 	bl	20109c <ERROR_BusFaultHandler>
  /* USER CODE END BusFault_IRQn 0 */
  while (1)
  21887e:	e7fe      	b.n	21887e <BusFault_Handler+0x8>

00218880 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
  218880:	b580      	push	{r7, lr}
  218882:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */
	ERROR_UsageFaultHandler();
  218884:	f7e8 fc14 	bl	2010b0 <ERROR_UsageFaultHandler>
  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
  218888:	e7fe      	b.n	218888 <UsageFault_Handler+0x8>

0021888a <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
  21888a:	b580      	push	{r7, lr}
  21888c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DebugMonitor_IRQn 0 */
	ERROR_DebugMonHandler();
  21888e:	f7e8 fc19 	bl	2010c4 <ERROR_DebugMonHandler>
  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
  218892:	bf00      	nop
  218894:	bd80      	pop	{r7, pc}
	...

00218898 <DMA1_Stream3_IRQHandler>:

/**
  * @brief This function handles DMA1 stream3 global interrupt.
  */
void DMA1_Stream3_IRQHandler(void)
{
  218898:	b580      	push	{r7, lr}
  21889a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA1_Stream3_IRQn 0 */

  /* USER CODE END DMA1_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_uart7_rx);
  21889c:	4802      	ldr	r0, [pc, #8]	; (2188a8 <DMA1_Stream3_IRQHandler+0x10>)
  21889e:	f000 fded 	bl	21947c <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA1_Stream3_IRQn 1 */

  /* USER CODE END DMA1_Stream3_IRQn 1 */
}
  2188a2:	bf00      	nop
  2188a4:	bd80      	pop	{r7, pc}
  2188a6:	bf00      	nop
  2188a8:	20014dfc 	.word	0x20014dfc

002188ac <TIM8_TRG_COM_TIM14_IRQHandler>:

/**
  * @brief This function handles TIM8 trigger and commutation interrupts and TIM14 global interrupt.
  */
void TIM8_TRG_COM_TIM14_IRQHandler(void)
{
  2188ac:	b580      	push	{r7, lr}
  2188ae:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM8_TRG_COM_TIM14_IRQn 0 */

  /* USER CODE END TIM8_TRG_COM_TIM14_IRQn 0 */
  HAL_TIM_IRQHandler(&htim14);
  2188b0:	4802      	ldr	r0, [pc, #8]	; (2188bc <TIM8_TRG_COM_TIM14_IRQHandler+0x10>)
  2188b2:	f004 fdcb 	bl	21d44c <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM8_TRG_COM_TIM14_IRQn 1 */

  /* USER CODE END TIM8_TRG_COM_TIM14_IRQn 1 */
}
  2188b6:	bf00      	nop
  2188b8:	bd80      	pop	{r7, pc}
  2188ba:	bf00      	nop
  2188bc:	20014ce0 	.word	0x20014ce0

002188c0 <SDMMC1_IRQHandler>:

/**
  * @brief This function handles SDMMC1 global interrupt.
  */
void SDMMC1_IRQHandler(void)
{
  2188c0:	b580      	push	{r7, lr}
  2188c2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SDMMC1_IRQn 0 */

  /* USER CODE END SDMMC1_IRQn 0 */
  HAL_SD_IRQHandler(&hsd1);
  2188c4:	4802      	ldr	r0, [pc, #8]	; (2188d0 <SDMMC1_IRQHandler+0x10>)
  2188c6:	f003 fb4f 	bl	21bf68 <HAL_SD_IRQHandler>
  /* USER CODE BEGIN SDMMC1_IRQn 1 */

  /* USER CODE END SDMMC1_IRQn 1 */
}
  2188ca:	bf00      	nop
  2188cc:	bd80      	pop	{r7, pc}
  2188ce:	bf00      	nop
  2188d0:	20014b9c 	.word	0x20014b9c

002188d4 <DMA2_Stream3_IRQHandler>:

/**
  * @brief This function handles DMA2 stream3 global interrupt.
  */
void DMA2_Stream3_IRQHandler(void)
{
  2188d4:	b580      	push	{r7, lr}
  2188d6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream3_IRQn 0 */

  /* USER CODE END DMA2_Stream3_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdmmc1_rx);
  2188d8:	4802      	ldr	r0, [pc, #8]	; (2188e4 <DMA2_Stream3_IRQHandler+0x10>)
  2188da:	f000 fdcf 	bl	21947c <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream3_IRQn 1 */

  /* USER CODE END DMA2_Stream3_IRQn 1 */
}
  2188de:	bf00      	nop
  2188e0:	bd80      	pop	{r7, pc}
  2188e2:	bf00      	nop
  2188e4:	20014c20 	.word	0x20014c20

002188e8 <DMA2_Stream6_IRQHandler>:

/**
  * @brief This function handles DMA2 stream6 global interrupt.
  */
void DMA2_Stream6_IRQHandler(void)
{
  2188e8:	b580      	push	{r7, lr}
  2188ea:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2_Stream6_IRQn 0 */

  /* USER CODE END DMA2_Stream6_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sdmmc1_tx);
  2188ec:	4802      	ldr	r0, [pc, #8]	; (2188f8 <DMA2_Stream6_IRQHandler+0x10>)
  2188ee:	f000 fdc5 	bl	21947c <HAL_DMA_IRQHandler>
  /* USER CODE BEGIN DMA2_Stream6_IRQn 1 */

  /* USER CODE END DMA2_Stream6_IRQn 1 */
}
  2188f2:	bf00      	nop
  2188f4:	bd80      	pop	{r7, pc}
  2188f6:	bf00      	nop
  2188f8:	20014c80 	.word	0x20014c80

002188fc <UART7_IRQHandler>:

/**
  * @brief This function handles UART7 global interrupt.
  */
void UART7_IRQHandler(void)
{
  2188fc:	b580      	push	{r7, lr}
  2188fe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UART7_IRQn 0 */

  /* USER CODE END UART7_IRQn 0 */
  HAL_UART_IRQHandler(&huart7);
  218900:	4802      	ldr	r0, [pc, #8]	; (21890c <UART7_IRQHandler+0x10>)
  218902:	f005 fb15 	bl	21df30 <HAL_UART_IRQHandler>
  /* USER CODE BEGIN UART7_IRQn 1 */

  /* USER CODE END UART7_IRQn 1 */
}
  218906:	bf00      	nop
  218908:	bd80      	pop	{r7, pc}
  21890a:	bf00      	nop
  21890c:	20014d78 	.word	0x20014d78

00218910 <DMA2D_IRQHandler>:

/**
  * @brief This function handles DMA2D global interrupt.
  */
void DMA2D_IRQHandler(void)
{
  218910:	b580      	push	{r7, lr}
  218912:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN DMA2D_IRQn 0 */

  /* USER CODE END DMA2D_IRQn 0 */
  HAL_DMA2D_IRQHandler(&hdma2d);
  218914:	4802      	ldr	r0, [pc, #8]	; (218920 <DMA2D_IRQHandler+0x10>)
  218916:	f001 f8b2 	bl	219a7e <HAL_DMA2D_IRQHandler>
  /* USER CODE BEGIN DMA2D_IRQn 1 */

  /* USER CODE END DMA2D_IRQn 1 */
}
  21891a:	bf00      	nop
  21891c:	bd80      	pop	{r7, pc}
  21891e:	bf00      	nop
  218920:	20014a54 	.word	0x20014a54

00218924 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
  218924:	b480      	push	{r7}
  218926:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  218928:	4a06      	ldr	r2, [pc, #24]	; (218944 <SystemInit+0x20>)
  21892a:	4b06      	ldr	r3, [pc, #24]	; (218944 <SystemInit+0x20>)
  21892c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  218930:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  218934:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#endif /* USER_VECT_TAB_ADDRESS */
}
  218938:	bf00      	nop
  21893a:	46bd      	mov	sp, r7
  21893c:	f85d 7b04 	ldr.w	r7, [sp], #4
  218940:	4770      	bx	lr
  218942:	bf00      	nop
  218944:	e000ed00 	.word	0xe000ed00

00218948 <MX_TIM5_Init>:

TIM_HandleTypeDef htim5;

/* TIM5 init function */
void MX_TIM5_Init(void)
{
  218948:	b580      	push	{r7, lr}
  21894a:	b088      	sub	sp, #32
  21894c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  21894e:	f107 0310 	add.w	r3, r7, #16
  218952:	2200      	movs	r2, #0
  218954:	601a      	str	r2, [r3, #0]
  218956:	605a      	str	r2, [r3, #4]
  218958:	609a      	str	r2, [r3, #8]
  21895a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  21895c:	1d3b      	adds	r3, r7, #4
  21895e:	2200      	movs	r2, #0
  218960:	601a      	str	r2, [r3, #0]
  218962:	605a      	str	r2, [r3, #4]
  218964:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
  218966:	4b22      	ldr	r3, [pc, #136]	; (2189f0 <MX_TIM5_Init+0xa8>)
  218968:	4a22      	ldr	r2, [pc, #136]	; (2189f4 <MX_TIM5_Init+0xac>)
  21896a:	601a      	str	r2, [r3, #0]
  htim5.Init.Prescaler = 0;
  21896c:	4b20      	ldr	r3, [pc, #128]	; (2189f0 <MX_TIM5_Init+0xa8>)
  21896e:	2200      	movs	r2, #0
  218970:	605a      	str	r2, [r3, #4]
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
  218972:	4b1f      	ldr	r3, [pc, #124]	; (2189f0 <MX_TIM5_Init+0xa8>)
  218974:	2200      	movs	r2, #0
  218976:	609a      	str	r2, [r3, #8]
  htim5.Init.Period = 4294967295;
  218978:	4b1d      	ldr	r3, [pc, #116]	; (2189f0 <MX_TIM5_Init+0xa8>)
  21897a:	f04f 32ff 	mov.w	r2, #4294967295
  21897e:	60da      	str	r2, [r3, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  218980:	4b1b      	ldr	r3, [pc, #108]	; (2189f0 <MX_TIM5_Init+0xa8>)
  218982:	2200      	movs	r2, #0
  218984:	611a      	str	r2, [r3, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  218986:	4b1a      	ldr	r3, [pc, #104]	; (2189f0 <MX_TIM5_Init+0xa8>)
  218988:	2200      	movs	r2, #0
  21898a:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
  21898c:	4818      	ldr	r0, [pc, #96]	; (2189f0 <MX_TIM5_Init+0xa8>)
  21898e:	f004 fbf5 	bl	21d17c <HAL_TIM_Base_Init>
  218992:	4603      	mov	r3, r0
  218994:	2b00      	cmp	r3, #0
  218996:	d001      	beq.n	21899c <MX_TIM5_Init+0x54>
  {
    Error_Handler();
  218998:	f7ff fdce 	bl	218538 <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  21899c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  2189a0:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
  2189a2:	f107 0310 	add.w	r3, r7, #16
  2189a6:	4619      	mov	r1, r3
  2189a8:	4811      	ldr	r0, [pc, #68]	; (2189f0 <MX_TIM5_Init+0xa8>)
  2189aa:	f004 fe6f 	bl	21d68c <HAL_TIM_ConfigClockSource>
  2189ae:	4603      	mov	r3, r0
  2189b0:	2b00      	cmp	r3, #0
  2189b2:	d001      	beq.n	2189b8 <MX_TIM5_Init+0x70>
  {
    Error_Handler();
  2189b4:	f7ff fdc0 	bl	218538 <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  2189b8:	2300      	movs	r3, #0
  2189ba:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  2189bc:	2300      	movs	r3, #0
  2189be:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
  2189c0:	1d3b      	adds	r3, r7, #4
  2189c2:	4619      	mov	r1, r3
  2189c4:	480a      	ldr	r0, [pc, #40]	; (2189f0 <MX_TIM5_Init+0xa8>)
  2189c6:	f005 f87d 	bl	21dac4 <HAL_TIMEx_MasterConfigSynchronization>
  2189ca:	4603      	mov	r3, r0
  2189cc:	2b00      	cmp	r3, #0
  2189ce:	d001      	beq.n	2189d4 <MX_TIM5_Init+0x8c>
  {
    Error_Handler();
  2189d0:	f7ff fdb2 	bl	218538 <Error_Handler>
  }
  /* USER CODE BEGIN TIM5_Init 2 */
  HAL_TIM_Base_Start(&htim5);
  2189d4:	4806      	ldr	r0, [pc, #24]	; (2189f0 <MX_TIM5_Init+0xa8>)
  2189d6:	f004 fc29 	bl	21d22c <HAL_TIM_Base_Start>
  HAL_Delay(1);
  2189da:	2001      	movs	r0, #1
  2189dc:	f000 fa34 	bl	218e48 <HAL_Delay>
  HAL_TIM_Base_Stop(&htim5);
  2189e0:	4803      	ldr	r0, [pc, #12]	; (2189f0 <MX_TIM5_Init+0xa8>)
  2189e2:	f004 fc93 	bl	21d30c <HAL_TIM_Base_Stop>
  /* USER CODE END TIM5_Init 2 */

}
  2189e6:	bf00      	nop
  2189e8:	3720      	adds	r7, #32
  2189ea:	46bd      	mov	sp, r7
  2189ec:	bd80      	pop	{r7, pc}
  2189ee:	bf00      	nop
  2189f0:	20014d2c 	.word	0x20014d2c
  2189f4:	40000c00 	.word	0x40000c00

002189f8 <HAL_TIM_Base_MspInit>:

void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
{
  2189f8:	b480      	push	{r7}
  2189fa:	b085      	sub	sp, #20
  2189fc:	af00      	add	r7, sp, #0
  2189fe:	6078      	str	r0, [r7, #4]

  if(tim_baseHandle->Instance==TIM5)
  218a00:	687b      	ldr	r3, [r7, #4]
  218a02:	681b      	ldr	r3, [r3, #0]
  218a04:	4a0a      	ldr	r2, [pc, #40]	; (218a30 <HAL_TIM_Base_MspInit+0x38>)
  218a06:	4293      	cmp	r3, r2
  218a08:	d10b      	bne.n	218a22 <HAL_TIM_Base_MspInit+0x2a>
  {
  /* USER CODE BEGIN TIM5_MspInit 0 */

  /* USER CODE END TIM5_MspInit 0 */
    /* TIM5 clock enable */
    __HAL_RCC_TIM5_CLK_ENABLE();
  218a0a:	4a0a      	ldr	r2, [pc, #40]	; (218a34 <HAL_TIM_Base_MspInit+0x3c>)
  218a0c:	4b09      	ldr	r3, [pc, #36]	; (218a34 <HAL_TIM_Base_MspInit+0x3c>)
  218a0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218a10:	f043 0308 	orr.w	r3, r3, #8
  218a14:	6413      	str	r3, [r2, #64]	; 0x40
  218a16:	4b07      	ldr	r3, [pc, #28]	; (218a34 <HAL_TIM_Base_MspInit+0x3c>)
  218a18:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218a1a:	f003 0308 	and.w	r3, r3, #8
  218a1e:	60fb      	str	r3, [r7, #12]
  218a20:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM5_MspInit 1 */

  /* USER CODE END TIM5_MspInit 1 */
  }
}
  218a22:	bf00      	nop
  218a24:	3714      	adds	r7, #20
  218a26:	46bd      	mov	sp, r7
  218a28:	f85d 7b04 	ldr.w	r7, [sp], #4
  218a2c:	4770      	bx	lr
  218a2e:	bf00      	nop
  218a30:	40000c00 	.word	0x40000c00
  218a34:	40023800 	.word	0x40023800

00218a38 <StartMeasureTime_us>:
  }
}

/* USER CODE BEGIN 1 */
void StartMeasureTime_us(void)
{
  218a38:	b580      	push	{r7, lr}
  218a3a:	af00      	add	r7, sp, #0
	__HAL_TIM_SET_COUNTER(&htim5,0);
  218a3c:	4b04      	ldr	r3, [pc, #16]	; (218a50 <StartMeasureTime_us+0x18>)
  218a3e:	681b      	ldr	r3, [r3, #0]
  218a40:	2200      	movs	r2, #0
  218a42:	625a      	str	r2, [r3, #36]	; 0x24
	HAL_TIM_Base_Start(&htim5);
  218a44:	4802      	ldr	r0, [pc, #8]	; (218a50 <StartMeasureTime_us+0x18>)
  218a46:	f004 fbf1 	bl	21d22c <HAL_TIM_Base_Start>
}
  218a4a:	bf00      	nop
  218a4c:	bd80      	pop	{r7, pc}
  218a4e:	bf00      	nop
  218a50:	20014d2c 	.word	0x20014d2c
  218a54:	00000000 	.word	0x00000000

00218a58 <StopMeasureTime_us>:

uint32_t StopMeasureTime_us(char *nameTime)
{
  218a58:	b590      	push	{r4, r7, lr}
  218a5a:	b087      	sub	sp, #28
  218a5c:	af02      	add	r7, sp, #8
  218a5e:	6078      	str	r0, [r7, #4]
	register uint32_t counterTicks =__HAL_TIM_GET_COUNTER(&htim5);
  218a60:	4b1b      	ldr	r3, [pc, #108]	; (218ad0 <StopMeasureTime_us+0x78>)
  218a62:	681b      	ldr	r3, [r3, #0]
  218a64:	6a5c      	ldr	r4, [r3, #36]	; 0x24
	float counterClock = 2*HAL_RCC_GetPCLK1Freq();
  218a66:	f002 fb81 	bl	21b16c <HAL_RCC_GetPCLK1Freq>
  218a6a:	4603      	mov	r3, r0
  218a6c:	005b      	lsls	r3, r3, #1
  218a6e:	ee07 3a90 	vmov	s15, r3
  218a72:	eef8 7a67 	vcvt.f32.u32	s15, s15
  218a76:	edc7 7a03 	vstr	s15, [r7, #12]
	uint32_t result = (uint32_t)(1000000 / (counterClock/(double)counterTicks));
  218a7a:	edd7 7a03 	vldr	s15, [r7, #12]
  218a7e:	eeb7 5ae7 	vcvt.f64.f32	d5, s15
  218a82:	ee07 4a90 	vmov	s15, r4
  218a86:	eeb8 7b67 	vcvt.f64.u32	d7, s15
  218a8a:	ee85 6b07 	vdiv.f64	d6, d5, d7
  218a8e:	ed9f 5b0e 	vldr	d5, [pc, #56]	; 218ac8 <StopMeasureTime_us+0x70>
  218a92:	ee85 7b06 	vdiv.f64	d7, d5, d6
  218a96:	eefc 7bc7 	vcvt.u32.f64	s15, d7
  218a9a:	ee17 3a90 	vmov	r3, s15
  218a9e:	60bb      	str	r3, [r7, #8]

	HAL_TIM_Base_Stop(&htim5);
  218aa0:	480b      	ldr	r0, [pc, #44]	; (218ad0 <StopMeasureTime_us+0x78>)
  218aa2:	f004 fc33 	bl	21d30c <HAL_TIM_Base_Stop>
	if(nameTime[0]>0)
  218aa6:	687b      	ldr	r3, [r7, #4]
  218aa8:	781b      	ldrb	r3, [r3, #0]
  218aaa:	2b00      	cmp	r3, #0
  218aac:	d007      	beq.n	218abe <StopMeasureTime_us+0x66>
		DbgVar(1,100,"%s%dus ",nameTime,result);
  218aae:	68bb      	ldr	r3, [r7, #8]
  218ab0:	9300      	str	r3, [sp, #0]
  218ab2:	687b      	ldr	r3, [r7, #4]
  218ab4:	4a07      	ldr	r2, [pc, #28]	; (218ad4 <StopMeasureTime_us+0x7c>)
  218ab6:	2164      	movs	r1, #100	; 0x64
  218ab8:	2001      	movs	r0, #1
  218aba:	f7e7 ff06 	bl	2008ca <DbgVar>
	return result;
  218abe:	68bb      	ldr	r3, [r7, #8]
}
  218ac0:	4618      	mov	r0, r3
  218ac2:	3714      	adds	r7, #20
  218ac4:	46bd      	mov	sp, r7
  218ac6:	bd90      	pop	{r4, r7, pc}
  218ac8:	00000000 	.word	0x00000000
  218acc:	412e8480 	.word	0x412e8480
  218ad0:	20014d2c 	.word	0x20014d2c
  218ad4:	002291f8 	.word	0x002291f8

00218ad8 <SCB_InvalidateDCache_by_Addr>:
{
  218ad8:	b480      	push	{r7}
  218ada:	b087      	sub	sp, #28
  218adc:	af00      	add	r7, sp, #0
  218ade:	6078      	str	r0, [r7, #4]
  218ae0:	6039      	str	r1, [r7, #0]
     int32_t op_size = dsize;
  218ae2:	683b      	ldr	r3, [r7, #0]
  218ae4:	617b      	str	r3, [r7, #20]
    uint32_t op_addr = (uint32_t)addr;
  218ae6:	687b      	ldr	r3, [r7, #4]
  218ae8:	613b      	str	r3, [r7, #16]
     int32_t linesize = 32;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
  218aea:	2320      	movs	r3, #32
  218aec:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("dsb 0xF":::"memory");
  218aee:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
  218af2:	e00b      	b.n	218b0c <SCB_InvalidateDCache_by_Addr+0x34>
      SCB->DCIMVAC = op_addr;
  218af4:	4a0c      	ldr	r2, [pc, #48]	; (218b28 <SCB_InvalidateDCache_by_Addr+0x50>)
  218af6:	693b      	ldr	r3, [r7, #16]
  218af8:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
  218afc:	68fb      	ldr	r3, [r7, #12]
  218afe:	693a      	ldr	r2, [r7, #16]
  218b00:	4413      	add	r3, r2
  218b02:	613b      	str	r3, [r7, #16]
      op_size -=           linesize;
  218b04:	697a      	ldr	r2, [r7, #20]
  218b06:	68fb      	ldr	r3, [r7, #12]
  218b08:	1ad3      	subs	r3, r2, r3
  218b0a:	617b      	str	r3, [r7, #20]
    while (op_size > 0) {
  218b0c:	697b      	ldr	r3, [r7, #20]
  218b0e:	2b00      	cmp	r3, #0
  218b10:	dcf0      	bgt.n	218af4 <SCB_InvalidateDCache_by_Addr+0x1c>
  218b12:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  218b16:	f3bf 8f6f 	isb	sy
}
  218b1a:	bf00      	nop
  218b1c:	371c      	adds	r7, #28
  218b1e:	46bd      	mov	sp, r7
  218b20:	f85d 7b04 	ldr.w	r7, [sp], #4
  218b24:	4770      	bx	lr
  218b26:	bf00      	nop
  218b28:	e000ed00 	.word	0xe000ed00

00218b2c <MX_UART7_Init>:
UART_HandleTypeDef huart7;
DMA_HandleTypeDef hdma_uart7_rx;

/* UART7 init function */
void MX_UART7_Init(void)
{
  218b2c:	b580      	push	{r7, lr}
  218b2e:	af00      	add	r7, sp, #0
  /* USER CODE END UART7_Init 0 */

  /* USER CODE BEGIN UART7_Init 1 */

  /* USER CODE END UART7_Init 1 */
  huart7.Instance = UART7;
  218b30:	4b13      	ldr	r3, [pc, #76]	; (218b80 <MX_UART7_Init+0x54>)
  218b32:	4a14      	ldr	r2, [pc, #80]	; (218b84 <MX_UART7_Init+0x58>)
  218b34:	601a      	str	r2, [r3, #0]
  huart7.Init.BaudRate = 2000000;
  218b36:	4b12      	ldr	r3, [pc, #72]	; (218b80 <MX_UART7_Init+0x54>)
  218b38:	4a13      	ldr	r2, [pc, #76]	; (218b88 <MX_UART7_Init+0x5c>)
  218b3a:	605a      	str	r2, [r3, #4]
  huart7.Init.WordLength = UART_WORDLENGTH_8B;
  218b3c:	4b10      	ldr	r3, [pc, #64]	; (218b80 <MX_UART7_Init+0x54>)
  218b3e:	2200      	movs	r2, #0
  218b40:	609a      	str	r2, [r3, #8]
  huart7.Init.StopBits = UART_STOPBITS_1;
  218b42:	4b0f      	ldr	r3, [pc, #60]	; (218b80 <MX_UART7_Init+0x54>)
  218b44:	2200      	movs	r2, #0
  218b46:	60da      	str	r2, [r3, #12]
  huart7.Init.Parity = UART_PARITY_NONE;
  218b48:	4b0d      	ldr	r3, [pc, #52]	; (218b80 <MX_UART7_Init+0x54>)
  218b4a:	2200      	movs	r2, #0
  218b4c:	611a      	str	r2, [r3, #16]
  huart7.Init.Mode = UART_MODE_TX_RX;
  218b4e:	4b0c      	ldr	r3, [pc, #48]	; (218b80 <MX_UART7_Init+0x54>)
  218b50:	220c      	movs	r2, #12
  218b52:	615a      	str	r2, [r3, #20]
  huart7.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  218b54:	4b0a      	ldr	r3, [pc, #40]	; (218b80 <MX_UART7_Init+0x54>)
  218b56:	2200      	movs	r2, #0
  218b58:	619a      	str	r2, [r3, #24]
  huart7.Init.OverSampling = UART_OVERSAMPLING_16;
  218b5a:	4b09      	ldr	r3, [pc, #36]	; (218b80 <MX_UART7_Init+0x54>)
  218b5c:	2200      	movs	r2, #0
  218b5e:	61da      	str	r2, [r3, #28]
  huart7.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  218b60:	4b07      	ldr	r3, [pc, #28]	; (218b80 <MX_UART7_Init+0x54>)
  218b62:	2200      	movs	r2, #0
  218b64:	621a      	str	r2, [r3, #32]
  huart7.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  218b66:	4b06      	ldr	r3, [pc, #24]	; (218b80 <MX_UART7_Init+0x54>)
  218b68:	2200      	movs	r2, #0
  218b6a:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart7) != HAL_OK)
  218b6c:	4804      	ldr	r0, [pc, #16]	; (218b80 <MX_UART7_Init+0x54>)
  218b6e:	f005 f855 	bl	21dc1c <HAL_UART_Init>
  218b72:	4603      	mov	r3, r0
  218b74:	2b00      	cmp	r3, #0
  218b76:	d001      	beq.n	218b7c <MX_UART7_Init+0x50>
  {
    Error_Handler();
  218b78:	f7ff fcde 	bl	218538 <Error_Handler>
  }
  /* USER CODE BEGIN UART7_Init 2 */

  /* USER CODE END UART7_Init 2 */

}
  218b7c:	bf00      	nop
  218b7e:	bd80      	pop	{r7, pc}
  218b80:	20014d78 	.word	0x20014d78
  218b84:	40007800 	.word	0x40007800
  218b88:	001e8480 	.word	0x001e8480

00218b8c <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
  218b8c:	b580      	push	{r7, lr}
  218b8e:	b08a      	sub	sp, #40	; 0x28
  218b90:	af00      	add	r7, sp, #0
  218b92:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  218b94:	f107 0314 	add.w	r3, r7, #20
  218b98:	2200      	movs	r2, #0
  218b9a:	601a      	str	r2, [r3, #0]
  218b9c:	605a      	str	r2, [r3, #4]
  218b9e:	609a      	str	r2, [r3, #8]
  218ba0:	60da      	str	r2, [r3, #12]
  218ba2:	611a      	str	r2, [r3, #16]
  if(uartHandle->Instance==UART7)
  218ba4:	687b      	ldr	r3, [r7, #4]
  218ba6:	681b      	ldr	r3, [r3, #0]
  218ba8:	4a3a      	ldr	r2, [pc, #232]	; (218c94 <HAL_UART_MspInit+0x108>)
  218baa:	4293      	cmp	r3, r2
  218bac:	d16d      	bne.n	218c8a <HAL_UART_MspInit+0xfe>
  {
  /* USER CODE BEGIN UART7_MspInit 0 */

  /* USER CODE END UART7_MspInit 0 */
    /* UART7 clock enable */
    __HAL_RCC_UART7_CLK_ENABLE();
  218bae:	4a3a      	ldr	r2, [pc, #232]	; (218c98 <HAL_UART_MspInit+0x10c>)
  218bb0:	4b39      	ldr	r3, [pc, #228]	; (218c98 <HAL_UART_MspInit+0x10c>)
  218bb2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218bb4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  218bb8:	6413      	str	r3, [r2, #64]	; 0x40
  218bba:	4b37      	ldr	r3, [pc, #220]	; (218c98 <HAL_UART_MspInit+0x10c>)
  218bbc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  218bbe:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  218bc2:	613b      	str	r3, [r7, #16]
  218bc4:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOF_CLK_ENABLE();
  218bc6:	4a34      	ldr	r2, [pc, #208]	; (218c98 <HAL_UART_MspInit+0x10c>)
  218bc8:	4b33      	ldr	r3, [pc, #204]	; (218c98 <HAL_UART_MspInit+0x10c>)
  218bca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  218bcc:	f043 0320 	orr.w	r3, r3, #32
  218bd0:	6313      	str	r3, [r2, #48]	; 0x30
  218bd2:	4b31      	ldr	r3, [pc, #196]	; (218c98 <HAL_UART_MspInit+0x10c>)
  218bd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  218bd6:	f003 0320 	and.w	r3, r3, #32
  218bda:	60fb      	str	r3, [r7, #12]
  218bdc:	68fb      	ldr	r3, [r7, #12]
    /**UART7 GPIO Configuration
    PF6     ------> UART7_RX
    PF7     ------> UART7_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6;
  218bde:	2340      	movs	r3, #64	; 0x40
  218be0:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218be2:	2302      	movs	r3, #2
  218be4:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
  218be6:	2301      	movs	r3, #1
  218be8:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  218bea:	2300      	movs	r3, #0
  218bec:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF8_UART7;
  218bee:	2308      	movs	r3, #8
  218bf0:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
  218bf2:	f107 0314 	add.w	r3, r7, #20
  218bf6:	4619      	mov	r1, r3
  218bf8:	4828      	ldr	r0, [pc, #160]	; (218c9c <HAL_UART_MspInit+0x110>)
  218bfa:	f001 f997 	bl	219f2c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_7;
  218bfe:	2380      	movs	r3, #128	; 0x80
  218c00:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  218c02:	2302      	movs	r3, #2
  218c04:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
  218c06:	2300      	movs	r3, #0
  218c08:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  218c0a:	2300      	movs	r3, #0
  218c0c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF8_UART7;
  218c0e:	2308      	movs	r3, #8
  218c10:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
  218c12:	f107 0314 	add.w	r3, r7, #20
  218c16:	4619      	mov	r1, r3
  218c18:	4820      	ldr	r0, [pc, #128]	; (218c9c <HAL_UART_MspInit+0x110>)
  218c1a:	f001 f987 	bl	219f2c <HAL_GPIO_Init>

    /* UART7 DMA Init */
    /* UART7_RX Init */
    hdma_uart7_rx.Instance = DMA1_Stream3;
  218c1e:	4b20      	ldr	r3, [pc, #128]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c20:	4a20      	ldr	r2, [pc, #128]	; (218ca4 <HAL_UART_MspInit+0x118>)
  218c22:	601a      	str	r2, [r3, #0]
    hdma_uart7_rx.Init.Channel = DMA_CHANNEL_5;
  218c24:	4b1e      	ldr	r3, [pc, #120]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c26:	f04f 6220 	mov.w	r2, #167772160	; 0xa000000
  218c2a:	605a      	str	r2, [r3, #4]
    hdma_uart7_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
  218c2c:	4b1c      	ldr	r3, [pc, #112]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c2e:	2200      	movs	r2, #0
  218c30:	609a      	str	r2, [r3, #8]
    hdma_uart7_rx.Init.PeriphInc = DMA_PINC_DISABLE;
  218c32:	4b1b      	ldr	r3, [pc, #108]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c34:	2200      	movs	r2, #0
  218c36:	60da      	str	r2, [r3, #12]
    hdma_uart7_rx.Init.MemInc = DMA_MINC_ENABLE;
  218c38:	4b19      	ldr	r3, [pc, #100]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c3a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  218c3e:	611a      	str	r2, [r3, #16]
    hdma_uart7_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
  218c40:	4b17      	ldr	r3, [pc, #92]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c42:	2200      	movs	r2, #0
  218c44:	615a      	str	r2, [r3, #20]
    hdma_uart7_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
  218c46:	4b16      	ldr	r3, [pc, #88]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c48:	2200      	movs	r2, #0
  218c4a:	619a      	str	r2, [r3, #24]
    hdma_uart7_rx.Init.Mode = DMA_NORMAL;
  218c4c:	4b14      	ldr	r3, [pc, #80]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c4e:	2200      	movs	r2, #0
  218c50:	61da      	str	r2, [r3, #28]
    hdma_uart7_rx.Init.Priority = DMA_PRIORITY_LOW;
  218c52:	4b13      	ldr	r3, [pc, #76]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c54:	2200      	movs	r2, #0
  218c56:	621a      	str	r2, [r3, #32]
    hdma_uart7_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
  218c58:	4b11      	ldr	r3, [pc, #68]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c5a:	2200      	movs	r2, #0
  218c5c:	625a      	str	r2, [r3, #36]	; 0x24
    if (HAL_DMA_Init(&hdma_uart7_rx) != HAL_OK)
  218c5e:	4810      	ldr	r0, [pc, #64]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c60:	f000 fa6c 	bl	21913c <HAL_DMA_Init>
  218c64:	4603      	mov	r3, r0
  218c66:	2b00      	cmp	r3, #0
  218c68:	d001      	beq.n	218c6e <HAL_UART_MspInit+0xe2>
    {
      Error_Handler();
  218c6a:	f7ff fc65 	bl	218538 <Error_Handler>
    }

    __HAL_LINKDMA(uartHandle,hdmarx,hdma_uart7_rx);
  218c6e:	687b      	ldr	r3, [r7, #4]
  218c70:	4a0b      	ldr	r2, [pc, #44]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c72:	671a      	str	r2, [r3, #112]	; 0x70
  218c74:	4a0a      	ldr	r2, [pc, #40]	; (218ca0 <HAL_UART_MspInit+0x114>)
  218c76:	687b      	ldr	r3, [r7, #4]
  218c78:	6393      	str	r3, [r2, #56]	; 0x38

    /* UART7 interrupt Init */
    HAL_NVIC_SetPriority(UART7_IRQn, 15, 0);
  218c7a:	2200      	movs	r2, #0
  218c7c:	210f      	movs	r1, #15
  218c7e:	2052      	movs	r0, #82	; 0x52
  218c80:	f000 f9ba 	bl	218ff8 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(UART7_IRQn);
  218c84:	2052      	movs	r0, #82	; 0x52
  218c86:	f000 f9d3 	bl	219030 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN UART7_MspInit 1 */

  /* USER CODE END UART7_MspInit 1 */
  }
}
  218c8a:	bf00      	nop
  218c8c:	3728      	adds	r7, #40	; 0x28
  218c8e:	46bd      	mov	sp, r7
  218c90:	bd80      	pop	{r7, pc}
  218c92:	bf00      	nop
  218c94:	40007800 	.word	0x40007800
  218c98:	40023800 	.word	0x40023800
  218c9c:	40021400 	.word	0x40021400
  218ca0:	20014dfc 	.word	0x20014dfc
  218ca4:	40026058 	.word	0x40026058

00218ca8 <HAL_UART_TxCpltCallback>:
  }
}

/* USER CODE BEGIN 1 */
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
  218ca8:	b480      	push	{r7}
  218caa:	b083      	sub	sp, #12
  218cac:	af00      	add	r7, sp, #0
  218cae:	6078      	str	r0, [r7, #4]
	if(huart->Instance==UART7)
  218cb0:	687b      	ldr	r3, [r7, #4]
  218cb2:	681b      	ldr	r3, [r3, #0]
  218cb4:	4a12      	ldr	r2, [pc, #72]	; (218d00 <HAL_UART_TxCpltCallback+0x58>)
  218cb6:	4293      	cmp	r3, r2
  218cb8:	d11b      	bne.n	218cf2 <HAL_UART_TxCpltCallback+0x4a>
	{
		__HAL_UART_CLEAR_FEFLAG(huart);
  218cba:	687b      	ldr	r3, [r7, #4]
  218cbc:	681b      	ldr	r3, [r3, #0]
  218cbe:	2202      	movs	r2, #2
  218cc0:	621a      	str	r2, [r3, #32]
		__HAL_UART_CLEAR_PEFLAG(huart);
  218cc2:	687b      	ldr	r3, [r7, #4]
  218cc4:	681b      	ldr	r3, [r3, #0]
  218cc6:	2201      	movs	r2, #1
  218cc8:	621a      	str	r2, [r3, #32]
		__HAL_UART_CLEAR_OREFLAG(huart);
  218cca:	687b      	ldr	r3, [r7, #4]
  218ccc:	681b      	ldr	r3, [r3, #0]
  218cce:	2208      	movs	r2, #8
  218cd0:	621a      	str	r2, [r3, #32]
		__HAL_UART_FLUSH_DRREGISTER(huart);
  218cd2:	687b      	ldr	r3, [r7, #4]
  218cd4:	681b      	ldr	r3, [r3, #0]
  218cd6:	687a      	ldr	r2, [r7, #4]
  218cd8:	6812      	ldr	r2, [r2, #0]
  218cda:	6992      	ldr	r2, [r2, #24]
  218cdc:	f042 0208 	orr.w	r2, r2, #8
  218ce0:	619a      	str	r2, [r3, #24]
  218ce2:	687b      	ldr	r3, [r7, #4]
  218ce4:	681b      	ldr	r3, [r3, #0]
  218ce6:	687a      	ldr	r2, [r7, #4]
  218ce8:	6812      	ldr	r2, [r2, #0]
  218cea:	6992      	ldr	r2, [r2, #24]
  218cec:	f042 0210 	orr.w	r2, r2, #16
  218cf0:	619a      	str	r2, [r3, #24]
	}
}
  218cf2:	bf00      	nop
  218cf4:	370c      	adds	r7, #12
  218cf6:	46bd      	mov	sp, r7
  218cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
  218cfc:	4770      	bx	lr
  218cfe:	bf00      	nop
  218d00:	40007800 	.word	0x40007800

00218d04 <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  218d04:	b580      	push	{r7, lr}
  218d06:	b082      	sub	sp, #8
  218d08:	af00      	add	r7, sp, #0
  218d0a:	6078      	str	r0, [r7, #4]
	if(huart->Instance==UART7)
  218d0c:	687b      	ldr	r3, [r7, #4]
  218d0e:	681b      	ldr	r3, [r3, #0]
  218d10:	4a04      	ldr	r2, [pc, #16]	; (218d24 <HAL_UART_RxCpltCallback+0x20>)
  218d12:	4293      	cmp	r3, r2
  218d14:	d101      	bne.n	218d1a <HAL_UART_RxCpltCallback+0x16>
	{
		DEBUG_RxFullBuffService();
  218d16:	f7e7 fe2b 	bl	200970 <DEBUG_RxFullBuffService>
	}
}
  218d1a:	bf00      	nop
  218d1c:	3708      	adds	r7, #8
  218d1e:	46bd      	mov	sp, r7
  218d20:	bd80      	pop	{r7, pc}
  218d22:	bf00      	nop
  218d24:	40007800 	.word	0x40007800

00218d28 <HAL_UART_ErrorCallback>:

void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)  //W PRZERWANIACH TYLKO FLAGI !!!!!!
{
  218d28:	b480      	push	{r7}
  218d2a:	b083      	sub	sp, #12
  218d2c:	af00      	add	r7, sp, #0
  218d2e:	6078      	str	r0, [r7, #4]
	if(huart->Instance==UART7)
	{

	}
}
  218d30:	bf00      	nop
  218d32:	370c      	adds	r7, #12
  218d34:	46bd      	mov	sp, r7
  218d36:	f85d 7b04 	ldr.w	r7, [sp], #4
  218d3a:	4770      	bx	lr

00218d3c <DEBUG_Send>:

void DEBUG_Send(char *txt){
  218d3c:	b580      	push	{r7, lr}
  218d3e:	b082      	sub	sp, #8
  218d40:	af00      	add	r7, sp, #0
  218d42:	6078      	str	r0, [r7, #4]
	HAL_UART_Transmit(&huart7, (uint8_t*)txt, mini_strlen(txt),300);
  218d44:	6878      	ldr	r0, [r7, #4]
  218d46:	f7e8 f9db 	bl	201100 <mini_strlen>
  218d4a:	4603      	mov	r3, r0
  218d4c:	b29a      	uxth	r2, r3
  218d4e:	f44f 7396 	mov.w	r3, #300	; 0x12c
  218d52:	6879      	ldr	r1, [r7, #4]
  218d54:	4803      	ldr	r0, [pc, #12]	; (218d64 <DEBUG_Send+0x28>)
  218d56:	f004 ffaf 	bl	21dcb8 <HAL_UART_Transmit>
}
  218d5a:	bf00      	nop
  218d5c:	3708      	adds	r7, #8
  218d5e:	46bd      	mov	sp, r7
  218d60:	bd80      	pop	{r7, pc}
  218d62:	bf00      	nop
  218d64:	20014d78 	.word	0x20014d78

00218d68 <DEBUG_ReceiveStart>:
void DEBUG_ReceiveStart(uint8_t* buffer, uint16_t len)
{
  218d68:	b580      	push	{r7, lr}
  218d6a:	b082      	sub	sp, #8
  218d6c:	af00      	add	r7, sp, #0
  218d6e:	6078      	str	r0, [r7, #4]
  218d70:	460b      	mov	r3, r1
  218d72:	807b      	strh	r3, [r7, #2]
	SCB_InvalidateDCache_by_Addr((uint32_t *)buffer, len);
  218d74:	887b      	ldrh	r3, [r7, #2]
  218d76:	4619      	mov	r1, r3
  218d78:	6878      	ldr	r0, [r7, #4]
  218d7a:	f7ff fead 	bl	218ad8 <SCB_InvalidateDCache_by_Addr>
	__HAL_UART_FLUSH_DRREGISTER(&huart7);
  218d7e:	4b0e      	ldr	r3, [pc, #56]	; (218db8 <DEBUG_ReceiveStart+0x50>)
  218d80:	681b      	ldr	r3, [r3, #0]
  218d82:	4a0d      	ldr	r2, [pc, #52]	; (218db8 <DEBUG_ReceiveStart+0x50>)
  218d84:	6812      	ldr	r2, [r2, #0]
  218d86:	6992      	ldr	r2, [r2, #24]
  218d88:	f042 0208 	orr.w	r2, r2, #8
  218d8c:	619a      	str	r2, [r3, #24]
  218d8e:	4b0a      	ldr	r3, [pc, #40]	; (218db8 <DEBUG_ReceiveStart+0x50>)
  218d90:	681b      	ldr	r3, [r3, #0]
  218d92:	4a09      	ldr	r2, [pc, #36]	; (218db8 <DEBUG_ReceiveStart+0x50>)
  218d94:	6812      	ldr	r2, [r2, #0]
  218d96:	6992      	ldr	r2, [r2, #24]
  218d98:	f042 0210 	orr.w	r2, r2, #16
  218d9c:	619a      	str	r2, [r3, #24]
	HAL_UART_Receive_DMA(&huart7, buffer, len-1);
  218d9e:	887b      	ldrh	r3, [r7, #2]
  218da0:	3b01      	subs	r3, #1
  218da2:	b29b      	uxth	r3, r3
  218da4:	461a      	mov	r2, r3
  218da6:	6879      	ldr	r1, [r7, #4]
  218da8:	4803      	ldr	r0, [pc, #12]	; (218db8 <DEBUG_ReceiveStart+0x50>)
  218daa:	f005 f816 	bl	21ddda <HAL_UART_Receive_DMA>
}
  218dae:	bf00      	nop
  218db0:	3708      	adds	r7, #8
  218db2:	46bd      	mov	sp, r7
  218db4:	bd80      	pop	{r7, pc}
  218db6:	bf00      	nop
  218db8:	20014d78 	.word	0x20014d78

00218dbc <DEBUG_ReceiveStop>:
void DEBUG_ReceiveStop(void){
  218dbc:	b580      	push	{r7, lr}
  218dbe:	af00      	add	r7, sp, #0
	HAL_UART_DMAStop(&huart7);
  218dc0:	4802      	ldr	r0, [pc, #8]	; (218dcc <DEBUG_ReceiveStop+0x10>)
  218dc2:	f005 f847 	bl	21de54 <HAL_UART_DMAStop>
}
  218dc6:	bf00      	nop
  218dc8:	bd80      	pop	{r7, pc}
  218dca:	bf00      	nop
  218dcc:	20014d78 	.word	0x20014d78

00218dd0 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
  218dd0:	b580      	push	{r7, lr}
  218dd2:	af00      	add	r7, sp, #0
  /* Configure Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
  218dd4:	4a0b      	ldr	r2, [pc, #44]	; (218e04 <HAL_Init+0x34>)
  218dd6:	4b0b      	ldr	r3, [pc, #44]	; (218e04 <HAL_Init+0x34>)
  218dd8:	681b      	ldr	r3, [r3, #0]
  218dda:	f443 7300 	orr.w	r3, r3, #512	; 0x200
  218dde:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
  218de0:	4a08      	ldr	r2, [pc, #32]	; (218e04 <HAL_Init+0x34>)
  218de2:	4b08      	ldr	r3, [pc, #32]	; (218e04 <HAL_Init+0x34>)
  218de4:	681b      	ldr	r3, [r3, #0]
  218de6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  218dea:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  218dec:	2003      	movs	r0, #3
  218dee:	f000 f8f8 	bl	218fe2 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
  218df2:	2000      	movs	r0, #0
  218df4:	f7ff fcd8 	bl	2187a8 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
  218df8:	f7ff fcae 	bl	218758 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
  218dfc:	2300      	movs	r3, #0
}
  218dfe:	4618      	mov	r0, r3
  218e00:	bd80      	pop	{r7, pc}
  218e02:	bf00      	nop
  218e04:	40023c00 	.word	0x40023c00

00218e08 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  218e08:	b480      	push	{r7}
  218e0a:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
  218e0c:	4b06      	ldr	r3, [pc, #24]	; (218e28 <HAL_IncTick+0x20>)
  218e0e:	781b      	ldrb	r3, [r3, #0]
  218e10:	461a      	mov	r2, r3
  218e12:	4b06      	ldr	r3, [pc, #24]	; (218e2c <HAL_IncTick+0x24>)
  218e14:	681b      	ldr	r3, [r3, #0]
  218e16:	4413      	add	r3, r2
  218e18:	4a04      	ldr	r2, [pc, #16]	; (218e2c <HAL_IncTick+0x24>)
  218e1a:	6013      	str	r3, [r2, #0]
}
  218e1c:	bf00      	nop
  218e1e:	46bd      	mov	sp, r7
  218e20:	f85d 7b04 	ldr.w	r7, [sp], #4
  218e24:	4770      	bx	lr
  218e26:	bf00      	nop
  218e28:	2000000c 	.word	0x2000000c
  218e2c:	20014e5c 	.word	0x20014e5c

00218e30 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  218e30:	b480      	push	{r7}
  218e32:	af00      	add	r7, sp, #0
  return uwTick;
  218e34:	4b03      	ldr	r3, [pc, #12]	; (218e44 <HAL_GetTick+0x14>)
  218e36:	681b      	ldr	r3, [r3, #0]
}
  218e38:	4618      	mov	r0, r3
  218e3a:	46bd      	mov	sp, r7
  218e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
  218e40:	4770      	bx	lr
  218e42:	bf00      	nop
  218e44:	20014e5c 	.word	0x20014e5c

00218e48 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
  218e48:	b580      	push	{r7, lr}
  218e4a:	b084      	sub	sp, #16
  218e4c:	af00      	add	r7, sp, #0
  218e4e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
  218e50:	f7ff ffee 	bl	218e30 <HAL_GetTick>
  218e54:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
  218e56:	687b      	ldr	r3, [r7, #4]
  218e58:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
  218e5a:	68fb      	ldr	r3, [r7, #12]
  218e5c:	f1b3 3fff 	cmp.w	r3, #4294967295
  218e60:	d005      	beq.n	218e6e <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
  218e62:	4b09      	ldr	r3, [pc, #36]	; (218e88 <HAL_Delay+0x40>)
  218e64:	781b      	ldrb	r3, [r3, #0]
  218e66:	461a      	mov	r2, r3
  218e68:	68fb      	ldr	r3, [r7, #12]
  218e6a:	4413      	add	r3, r2
  218e6c:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
  218e6e:	bf00      	nop
  218e70:	f7ff ffde 	bl	218e30 <HAL_GetTick>
  218e74:	4602      	mov	r2, r0
  218e76:	68bb      	ldr	r3, [r7, #8]
  218e78:	1ad2      	subs	r2, r2, r3
  218e7a:	68fb      	ldr	r3, [r7, #12]
  218e7c:	429a      	cmp	r2, r3
  218e7e:	d3f7      	bcc.n	218e70 <HAL_Delay+0x28>
  {
  }
}
  218e80:	bf00      	nop
  218e82:	3710      	adds	r7, #16
  218e84:	46bd      	mov	sp, r7
  218e86:	bd80      	pop	{r7, pc}
  218e88:	2000000c 	.word	0x2000000c

00218e8c <__NVIC_SetPriorityGrouping>:
{
  218e8c:	b480      	push	{r7}
  218e8e:	b085      	sub	sp, #20
  218e90:	af00      	add	r7, sp, #0
  218e92:	6078      	str	r0, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
  218e94:	687b      	ldr	r3, [r7, #4]
  218e96:	f003 0307 	and.w	r3, r3, #7
  218e9a:	60fb      	str	r3, [r7, #12]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  218e9c:	4b0b      	ldr	r3, [pc, #44]	; (218ecc <__NVIC_SetPriorityGrouping+0x40>)
  218e9e:	68db      	ldr	r3, [r3, #12]
  218ea0:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  218ea2:	68ba      	ldr	r2, [r7, #8]
  218ea4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
  218ea8:	4013      	ands	r3, r2
  218eaa:	60bb      	str	r3, [r7, #8]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  218eac:	68fb      	ldr	r3, [r7, #12]
  218eae:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
  218eb0:	68bb      	ldr	r3, [r7, #8]
  218eb2:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
  218eb4:	4b06      	ldr	r3, [pc, #24]	; (218ed0 <__NVIC_SetPriorityGrouping+0x44>)
  218eb6:	4313      	orrs	r3, r2
  218eb8:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
  218eba:	4a04      	ldr	r2, [pc, #16]	; (218ecc <__NVIC_SetPriorityGrouping+0x40>)
  218ebc:	68bb      	ldr	r3, [r7, #8]
  218ebe:	60d3      	str	r3, [r2, #12]
}
  218ec0:	bf00      	nop
  218ec2:	3714      	adds	r7, #20
  218ec4:	46bd      	mov	sp, r7
  218ec6:	f85d 7b04 	ldr.w	r7, [sp], #4
  218eca:	4770      	bx	lr
  218ecc:	e000ed00 	.word	0xe000ed00
  218ed0:	05fa0000 	.word	0x05fa0000

00218ed4 <__NVIC_GetPriorityGrouping>:
{
  218ed4:	b480      	push	{r7}
  218ed6:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
  218ed8:	4b04      	ldr	r3, [pc, #16]	; (218eec <__NVIC_GetPriorityGrouping+0x18>)
  218eda:	68db      	ldr	r3, [r3, #12]
  218edc:	0a1b      	lsrs	r3, r3, #8
  218ede:	f003 0307 	and.w	r3, r3, #7
}
  218ee2:	4618      	mov	r0, r3
  218ee4:	46bd      	mov	sp, r7
  218ee6:	f85d 7b04 	ldr.w	r7, [sp], #4
  218eea:	4770      	bx	lr
  218eec:	e000ed00 	.word	0xe000ed00

00218ef0 <__NVIC_EnableIRQ>:
{
  218ef0:	b480      	push	{r7}
  218ef2:	b083      	sub	sp, #12
  218ef4:	af00      	add	r7, sp, #0
  218ef6:	4603      	mov	r3, r0
  218ef8:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  218efa:	f997 3007 	ldrsb.w	r3, [r7, #7]
  218efe:	2b00      	cmp	r3, #0
  218f00:	db0b      	blt.n	218f1a <__NVIC_EnableIRQ+0x2a>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  218f02:	4909      	ldr	r1, [pc, #36]	; (218f28 <__NVIC_EnableIRQ+0x38>)
  218f04:	f997 3007 	ldrsb.w	r3, [r7, #7]
  218f08:	095b      	lsrs	r3, r3, #5
  218f0a:	79fa      	ldrb	r2, [r7, #7]
  218f0c:	f002 021f 	and.w	r2, r2, #31
  218f10:	2001      	movs	r0, #1
  218f12:	fa00 f202 	lsl.w	r2, r0, r2
  218f16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
  218f1a:	bf00      	nop
  218f1c:	370c      	adds	r7, #12
  218f1e:	46bd      	mov	sp, r7
  218f20:	f85d 7b04 	ldr.w	r7, [sp], #4
  218f24:	4770      	bx	lr
  218f26:	bf00      	nop
  218f28:	e000e100 	.word	0xe000e100

00218f2c <__NVIC_SetPriority>:
{
  218f2c:	b480      	push	{r7}
  218f2e:	b083      	sub	sp, #12
  218f30:	af00      	add	r7, sp, #0
  218f32:	4603      	mov	r3, r0
  218f34:	6039      	str	r1, [r7, #0]
  218f36:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  218f38:	f997 3007 	ldrsb.w	r3, [r7, #7]
  218f3c:	2b00      	cmp	r3, #0
  218f3e:	db0a      	blt.n	218f56 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  218f40:	490d      	ldr	r1, [pc, #52]	; (218f78 <__NVIC_SetPriority+0x4c>)
  218f42:	f997 3007 	ldrsb.w	r3, [r7, #7]
  218f46:	683a      	ldr	r2, [r7, #0]
  218f48:	b2d2      	uxtb	r2, r2
  218f4a:	0112      	lsls	r2, r2, #4
  218f4c:	b2d2      	uxtb	r2, r2
  218f4e:	440b      	add	r3, r1
  218f50:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
  218f54:	e00a      	b.n	218f6c <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  218f56:	4909      	ldr	r1, [pc, #36]	; (218f7c <__NVIC_SetPriority+0x50>)
  218f58:	79fb      	ldrb	r3, [r7, #7]
  218f5a:	f003 030f 	and.w	r3, r3, #15
  218f5e:	3b04      	subs	r3, #4
  218f60:	683a      	ldr	r2, [r7, #0]
  218f62:	b2d2      	uxtb	r2, r2
  218f64:	0112      	lsls	r2, r2, #4
  218f66:	b2d2      	uxtb	r2, r2
  218f68:	440b      	add	r3, r1
  218f6a:	761a      	strb	r2, [r3, #24]
}
  218f6c:	bf00      	nop
  218f6e:	370c      	adds	r7, #12
  218f70:	46bd      	mov	sp, r7
  218f72:	f85d 7b04 	ldr.w	r7, [sp], #4
  218f76:	4770      	bx	lr
  218f78:	e000e100 	.word	0xe000e100
  218f7c:	e000ed00 	.word	0xe000ed00

00218f80 <NVIC_EncodePriority>:
{
  218f80:	b480      	push	{r7}
  218f82:	b089      	sub	sp, #36	; 0x24
  218f84:	af00      	add	r7, sp, #0
  218f86:	60f8      	str	r0, [r7, #12]
  218f88:	60b9      	str	r1, [r7, #8]
  218f8a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  218f8c:	68fb      	ldr	r3, [r7, #12]
  218f8e:	f003 0307 	and.w	r3, r3, #7
  218f92:	61fb      	str	r3, [r7, #28]
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  218f94:	69fb      	ldr	r3, [r7, #28]
  218f96:	f1c3 0307 	rsb	r3, r3, #7
  218f9a:	2b04      	cmp	r3, #4
  218f9c:	bf28      	it	cs
  218f9e:	2304      	movcs	r3, #4
  218fa0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
  218fa2:	69fb      	ldr	r3, [r7, #28]
  218fa4:	3304      	adds	r3, #4
  218fa6:	2b06      	cmp	r3, #6
  218fa8:	d902      	bls.n	218fb0 <NVIC_EncodePriority+0x30>
  218faa:	69fb      	ldr	r3, [r7, #28]
  218fac:	3b03      	subs	r3, #3
  218fae:	e000      	b.n	218fb2 <NVIC_EncodePriority+0x32>
  218fb0:	2300      	movs	r3, #0
  218fb2:	617b      	str	r3, [r7, #20]
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  218fb4:	2201      	movs	r2, #1
  218fb6:	69bb      	ldr	r3, [r7, #24]
  218fb8:	fa02 f303 	lsl.w	r3, r2, r3
  218fbc:	1e5a      	subs	r2, r3, #1
  218fbe:	68bb      	ldr	r3, [r7, #8]
  218fc0:	401a      	ands	r2, r3
  218fc2:	697b      	ldr	r3, [r7, #20]
  218fc4:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
  218fc6:	2101      	movs	r1, #1
  218fc8:	697b      	ldr	r3, [r7, #20]
  218fca:	fa01 f303 	lsl.w	r3, r1, r3
  218fce:	1e59      	subs	r1, r3, #1
  218fd0:	687b      	ldr	r3, [r7, #4]
  218fd2:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
  218fd4:	4313      	orrs	r3, r2
}
  218fd6:	4618      	mov	r0, r3
  218fd8:	3724      	adds	r7, #36	; 0x24
  218fda:	46bd      	mov	sp, r7
  218fdc:	f85d 7b04 	ldr.w	r7, [sp], #4
  218fe0:	4770      	bx	lr

00218fe2 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  218fe2:	b580      	push	{r7, lr}
  218fe4:	b082      	sub	sp, #8
  218fe6:	af00      	add	r7, sp, #0
  218fe8:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
  218fea:	6878      	ldr	r0, [r7, #4]
  218fec:	f7ff ff4e 	bl	218e8c <__NVIC_SetPriorityGrouping>
}
  218ff0:	bf00      	nop
  218ff2:	3708      	adds	r7, #8
  218ff4:	46bd      	mov	sp, r7
  218ff6:	bd80      	pop	{r7, pc}

00218ff8 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
  218ff8:	b580      	push	{r7, lr}
  218ffa:	b086      	sub	sp, #24
  218ffc:	af00      	add	r7, sp, #0
  218ffe:	4603      	mov	r3, r0
  219000:	60b9      	str	r1, [r7, #8]
  219002:	607a      	str	r2, [r7, #4]
  219004:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
  219006:	2300      	movs	r3, #0
  219008:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
  21900a:	f7ff ff63 	bl	218ed4 <__NVIC_GetPriorityGrouping>
  21900e:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
  219010:	687a      	ldr	r2, [r7, #4]
  219012:	68b9      	ldr	r1, [r7, #8]
  219014:	6978      	ldr	r0, [r7, #20]
  219016:	f7ff ffb3 	bl	218f80 <NVIC_EncodePriority>
  21901a:	4602      	mov	r2, r0
  21901c:	f997 300f 	ldrsb.w	r3, [r7, #15]
  219020:	4611      	mov	r1, r2
  219022:	4618      	mov	r0, r3
  219024:	f7ff ff82 	bl	218f2c <__NVIC_SetPriority>
}
  219028:	bf00      	nop
  21902a:	3718      	adds	r7, #24
  21902c:	46bd      	mov	sp, r7
  21902e:	bd80      	pop	{r7, pc}

00219030 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  219030:	b580      	push	{r7, lr}
  219032:	b082      	sub	sp, #8
  219034:	af00      	add	r7, sp, #0
  219036:	4603      	mov	r3, r0
  219038:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
  21903a:	f997 3007 	ldrsb.w	r3, [r7, #7]
  21903e:	4618      	mov	r0, r3
  219040:	f7ff ff56 	bl	218ef0 <__NVIC_EnableIRQ>
}
  219044:	bf00      	nop
  219046:	3708      	adds	r7, #8
  219048:	46bd      	mov	sp, r7
  21904a:	bd80      	pop	{r7, pc}

0021904c <HAL_MPU_Disable>:
/**
  * @brief  Disables the MPU
  * @retval None
  */
void HAL_MPU_Disable(void)
{
  21904c:	b480      	push	{r7}
  21904e:	af00      	add	r7, sp, #0
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  219050:	f3bf 8f5f 	dmb	sy
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
  219054:	4a06      	ldr	r2, [pc, #24]	; (219070 <HAL_MPU_Disable+0x24>)
  219056:	4b06      	ldr	r3, [pc, #24]	; (219070 <HAL_MPU_Disable+0x24>)
  219058:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21905a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  21905e:	6253      	str	r3, [r2, #36]	; 0x24
  
  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
  219060:	4b04      	ldr	r3, [pc, #16]	; (219074 <HAL_MPU_Disable+0x28>)
  219062:	2200      	movs	r2, #0
  219064:	605a      	str	r2, [r3, #4]
}
  219066:	bf00      	nop
  219068:	46bd      	mov	sp, r7
  21906a:	f85d 7b04 	ldr.w	r7, [sp], #4
  21906e:	4770      	bx	lr
  219070:	e000ed00 	.word	0xe000ed00
  219074:	e000ed90 	.word	0xe000ed90

00219078 <HAL_MPU_Enable>:
  *            @arg MPU_PRIVILEGED_DEFAULT
  *            @arg MPU_HFNMI_PRIVDEF
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  219078:	b480      	push	{r7}
  21907a:	b083      	sub	sp, #12
  21907c:	af00      	add	r7, sp, #0
  21907e:	6078      	str	r0, [r7, #4]
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
  219080:	4a0a      	ldr	r2, [pc, #40]	; (2190ac <HAL_MPU_Enable+0x34>)
  219082:	687b      	ldr	r3, [r7, #4]
  219084:	f043 0301 	orr.w	r3, r3, #1
  219088:	6053      	str	r3, [r2, #4]
  
  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
  21908a:	4a09      	ldr	r2, [pc, #36]	; (2190b0 <HAL_MPU_Enable+0x38>)
  21908c:	4b08      	ldr	r3, [pc, #32]	; (2190b0 <HAL_MPU_Enable+0x38>)
  21908e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  219090:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  219094:	6253      	str	r3, [r2, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
  219096:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  21909a:	f3bf 8f6f 	isb	sy
  
  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
  21909e:	bf00      	nop
  2190a0:	370c      	adds	r7, #12
  2190a2:	46bd      	mov	sp, r7
  2190a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  2190a8:	4770      	bx	lr
  2190aa:	bf00      	nop
  2190ac:	e000ed90 	.word	0xe000ed90
  2190b0:	e000ed00 	.word	0xe000ed00

002190b4 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
  2190b4:	b480      	push	{r7}
  2190b6:	b083      	sub	sp, #12
  2190b8:	af00      	add	r7, sp, #0
  2190ba:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
  2190bc:	4a1e      	ldr	r2, [pc, #120]	; (219138 <HAL_MPU_ConfigRegion+0x84>)
  2190be:	687b      	ldr	r3, [r7, #4]
  2190c0:	785b      	ldrb	r3, [r3, #1]
  2190c2:	6093      	str	r3, [r2, #8]

  if ((MPU_Init->Enable) != RESET)
  2190c4:	687b      	ldr	r3, [r7, #4]
  2190c6:	781b      	ldrb	r3, [r3, #0]
  2190c8:	2b00      	cmp	r3, #0
  2190ca:	d028      	beq.n	21911e <HAL_MPU_ConfigRegion+0x6a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
    
    MPU->RBAR = MPU_Init->BaseAddress;
  2190cc:	4a1a      	ldr	r2, [pc, #104]	; (219138 <HAL_MPU_ConfigRegion+0x84>)
  2190ce:	687b      	ldr	r3, [r7, #4]
  2190d0:	685b      	ldr	r3, [r3, #4]
  2190d2:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
  2190d4:	4918      	ldr	r1, [pc, #96]	; (219138 <HAL_MPU_ConfigRegion+0x84>)
  2190d6:	687b      	ldr	r3, [r7, #4]
  2190d8:	7b1b      	ldrb	r3, [r3, #12]
  2190da:	071a      	lsls	r2, r3, #28
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
  2190dc:	687b      	ldr	r3, [r7, #4]
  2190de:	7adb      	ldrb	r3, [r3, #11]
  2190e0:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
  2190e2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
  2190e4:	687b      	ldr	r3, [r7, #4]
  2190e6:	7a9b      	ldrb	r3, [r3, #10]
  2190e8:	04db      	lsls	r3, r3, #19
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
  2190ea:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
  2190ec:	687b      	ldr	r3, [r7, #4]
  2190ee:	7b5b      	ldrb	r3, [r3, #13]
  2190f0:	049b      	lsls	r3, r3, #18
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
  2190f2:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
  2190f4:	687b      	ldr	r3, [r7, #4]
  2190f6:	7b9b      	ldrb	r3, [r3, #14]
  2190f8:	045b      	lsls	r3, r3, #17
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
  2190fa:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
  2190fc:	687b      	ldr	r3, [r7, #4]
  2190fe:	7bdb      	ldrb	r3, [r3, #15]
  219100:	041b      	lsls	r3, r3, #16
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
  219102:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
  219104:	687b      	ldr	r3, [r7, #4]
  219106:	7a5b      	ldrb	r3, [r3, #9]
  219108:	021b      	lsls	r3, r3, #8
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
  21910a:	431a      	orrs	r2, r3
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
  21910c:	687b      	ldr	r3, [r7, #4]
  21910e:	7a1b      	ldrb	r3, [r3, #8]
  219110:	005b      	lsls	r3, r3, #1
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
  219112:	4313      	orrs	r3, r2
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
  219114:	687a      	ldr	r2, [r7, #4]
  219116:	7812      	ldrb	r2, [r2, #0]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
  219118:	4313      	orrs	r3, r2
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
  21911a:	610b      	str	r3, [r1, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
  21911c:	e005      	b.n	21912a <HAL_MPU_ConfigRegion+0x76>
    MPU->RBAR = 0x00;
  21911e:	4b06      	ldr	r3, [pc, #24]	; (219138 <HAL_MPU_ConfigRegion+0x84>)
  219120:	2200      	movs	r2, #0
  219122:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
  219124:	4b04      	ldr	r3, [pc, #16]	; (219138 <HAL_MPU_ConfigRegion+0x84>)
  219126:	2200      	movs	r2, #0
  219128:	611a      	str	r2, [r3, #16]
}
  21912a:	bf00      	nop
  21912c:	370c      	adds	r7, #12
  21912e:	46bd      	mov	sp, r7
  219130:	f85d 7b04 	ldr.w	r7, [sp], #4
  219134:	4770      	bx	lr
  219136:	bf00      	nop
  219138:	e000ed90 	.word	0xe000ed90

0021913c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
  21913c:	b580      	push	{r7, lr}
  21913e:	b086      	sub	sp, #24
  219140:	af00      	add	r7, sp, #0
  219142:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
  219144:	2300      	movs	r3, #0
  219146:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
  219148:	f7ff fe72 	bl	218e30 <HAL_GetTick>
  21914c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
  21914e:	687b      	ldr	r3, [r7, #4]
  219150:	2b00      	cmp	r3, #0
  219152:	d101      	bne.n	219158 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
  219154:	2301      	movs	r3, #1
  219156:	e099      	b.n	21928c <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
  219158:	687b      	ldr	r3, [r7, #4]
  21915a:	2200      	movs	r2, #0
  21915c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
  219160:	687b      	ldr	r3, [r7, #4]
  219162:	2202      	movs	r2, #2
  219164:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
  219168:	687b      	ldr	r3, [r7, #4]
  21916a:	681b      	ldr	r3, [r3, #0]
  21916c:	687a      	ldr	r2, [r7, #4]
  21916e:	6812      	ldr	r2, [r2, #0]
  219170:	6812      	ldr	r2, [r2, #0]
  219172:	f022 0201 	bic.w	r2, r2, #1
  219176:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  219178:	e00f      	b.n	21919a <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
  21917a:	f7ff fe59 	bl	218e30 <HAL_GetTick>
  21917e:	4602      	mov	r2, r0
  219180:	693b      	ldr	r3, [r7, #16]
  219182:	1ad3      	subs	r3, r2, r3
  219184:	2b05      	cmp	r3, #5
  219186:	d908      	bls.n	21919a <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
  219188:	687b      	ldr	r3, [r7, #4]
  21918a:	2220      	movs	r2, #32
  21918c:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
  21918e:	687b      	ldr	r3, [r7, #4]
  219190:	2203      	movs	r2, #3
  219192:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
  219196:	2303      	movs	r3, #3
  219198:	e078      	b.n	21928c <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  21919a:	687b      	ldr	r3, [r7, #4]
  21919c:	681b      	ldr	r3, [r3, #0]
  21919e:	681b      	ldr	r3, [r3, #0]
  2191a0:	f003 0301 	and.w	r3, r3, #1
  2191a4:	2b00      	cmp	r3, #0
  2191a6:	d1e8      	bne.n	21917a <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
  2191a8:	687b      	ldr	r3, [r7, #4]
  2191aa:	681b      	ldr	r3, [r3, #0]
  2191ac:	681b      	ldr	r3, [r3, #0]
  2191ae:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
  2191b0:	697a      	ldr	r2, [r7, #20]
  2191b2:	4b38      	ldr	r3, [pc, #224]	; (219294 <HAL_DMA_Init+0x158>)
  2191b4:	4013      	ands	r3, r2
  2191b6:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  2191b8:	687b      	ldr	r3, [r7, #4]
  2191ba:	685a      	ldr	r2, [r3, #4]
  2191bc:	687b      	ldr	r3, [r7, #4]
  2191be:	689b      	ldr	r3, [r3, #8]
  2191c0:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
  2191c2:	687b      	ldr	r3, [r7, #4]
  2191c4:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  2191c6:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
  2191c8:	687b      	ldr	r3, [r7, #4]
  2191ca:	691b      	ldr	r3, [r3, #16]
  2191cc:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
  2191ce:	687b      	ldr	r3, [r7, #4]
  2191d0:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
  2191d2:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
  2191d4:	687b      	ldr	r3, [r7, #4]
  2191d6:	699b      	ldr	r3, [r3, #24]
  2191d8:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
  2191da:	687b      	ldr	r3, [r7, #4]
  2191dc:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
  2191de:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
  2191e0:	687b      	ldr	r3, [r7, #4]
  2191e2:	6a1b      	ldr	r3, [r3, #32]
  2191e4:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
  2191e6:	697a      	ldr	r2, [r7, #20]
  2191e8:	4313      	orrs	r3, r2
  2191ea:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
  2191ec:	687b      	ldr	r3, [r7, #4]
  2191ee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  2191f0:	2b04      	cmp	r3, #4
  2191f2:	d107      	bne.n	219204 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
  2191f4:	687b      	ldr	r3, [r7, #4]
  2191f6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2191f8:	687b      	ldr	r3, [r7, #4]
  2191fa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  2191fc:	4313      	orrs	r3, r2
  2191fe:	697a      	ldr	r2, [r7, #20]
  219200:	4313      	orrs	r3, r2
  219202:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
  219204:	687b      	ldr	r3, [r7, #4]
  219206:	681b      	ldr	r3, [r3, #0]
  219208:	697a      	ldr	r2, [r7, #20]
  21920a:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
  21920c:	687b      	ldr	r3, [r7, #4]
  21920e:	681b      	ldr	r3, [r3, #0]
  219210:	695b      	ldr	r3, [r3, #20]
  219212:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
  219214:	697b      	ldr	r3, [r7, #20]
  219216:	f023 0307 	bic.w	r3, r3, #7
  21921a:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
  21921c:	687b      	ldr	r3, [r7, #4]
  21921e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  219220:	697a      	ldr	r2, [r7, #20]
  219222:	4313      	orrs	r3, r2
  219224:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
  219226:	687b      	ldr	r3, [r7, #4]
  219228:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21922a:	2b04      	cmp	r3, #4
  21922c:	d117      	bne.n	21925e <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
  21922e:	687b      	ldr	r3, [r7, #4]
  219230:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  219232:	697a      	ldr	r2, [r7, #20]
  219234:	4313      	orrs	r3, r2
  219236:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
  219238:	687b      	ldr	r3, [r7, #4]
  21923a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21923c:	2b00      	cmp	r3, #0
  21923e:	d00e      	beq.n	21925e <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
  219240:	6878      	ldr	r0, [r7, #4]
  219242:	f000 fb15 	bl	219870 <DMA_CheckFifoParam>
  219246:	4603      	mov	r3, r0
  219248:	2b00      	cmp	r3, #0
  21924a:	d008      	beq.n	21925e <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
  21924c:	687b      	ldr	r3, [r7, #4]
  21924e:	2240      	movs	r2, #64	; 0x40
  219250:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
  219252:	687b      	ldr	r3, [r7, #4]
  219254:	2201      	movs	r2, #1
  219256:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
  21925a:	2301      	movs	r3, #1
  21925c:	e016      	b.n	21928c <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
  21925e:	687b      	ldr	r3, [r7, #4]
  219260:	681b      	ldr	r3, [r3, #0]
  219262:	697a      	ldr	r2, [r7, #20]
  219264:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
  219266:	6878      	ldr	r0, [r7, #4]
  219268:	f000 facc 	bl	219804 <DMA_CalcBaseAndBitshift>
  21926c:	4603      	mov	r3, r0
  21926e:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
  219270:	687b      	ldr	r3, [r7, #4]
  219272:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219274:	223f      	movs	r2, #63	; 0x3f
  219276:	409a      	lsls	r2, r3
  219278:	68fb      	ldr	r3, [r7, #12]
  21927a:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  21927c:	687b      	ldr	r3, [r7, #4]
  21927e:	2200      	movs	r2, #0
  219280:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
  219282:	687b      	ldr	r3, [r7, #4]
  219284:	2201      	movs	r2, #1
  219286:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
  21928a:	2300      	movs	r3, #0
}
  21928c:	4618      	mov	r0, r3
  21928e:	3718      	adds	r7, #24
  219290:	46bd      	mov	sp, r7
  219292:	bd80      	pop	{r7, pc}
  219294:	e010803f 	.word	0xe010803f

00219298 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  219298:	b580      	push	{r7, lr}
  21929a:	b086      	sub	sp, #24
  21929c:	af00      	add	r7, sp, #0
  21929e:	60f8      	str	r0, [r7, #12]
  2192a0:	60b9      	str	r1, [r7, #8]
  2192a2:	607a      	str	r2, [r7, #4]
  2192a4:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
  2192a6:	2300      	movs	r3, #0
  2192a8:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  2192aa:	68fb      	ldr	r3, [r7, #12]
  2192ac:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  2192ae:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
  2192b0:	68fb      	ldr	r3, [r7, #12]
  2192b2:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
  2192b6:	2b01      	cmp	r3, #1
  2192b8:	d101      	bne.n	2192be <HAL_DMA_Start_IT+0x26>
  2192ba:	2302      	movs	r3, #2
  2192bc:	e048      	b.n	219350 <HAL_DMA_Start_IT+0xb8>
  2192be:	68fb      	ldr	r3, [r7, #12]
  2192c0:	2201      	movs	r2, #1
  2192c2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
  2192c6:	68fb      	ldr	r3, [r7, #12]
  2192c8:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  2192cc:	b2db      	uxtb	r3, r3
  2192ce:	2b01      	cmp	r3, #1
  2192d0:	d137      	bne.n	219342 <HAL_DMA_Start_IT+0xaa>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
  2192d2:	68fb      	ldr	r3, [r7, #12]
  2192d4:	2202      	movs	r2, #2
  2192d6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
  2192da:	68fb      	ldr	r3, [r7, #12]
  2192dc:	2200      	movs	r2, #0
  2192de:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
  2192e0:	683b      	ldr	r3, [r7, #0]
  2192e2:	687a      	ldr	r2, [r7, #4]
  2192e4:	68b9      	ldr	r1, [r7, #8]
  2192e6:	68f8      	ldr	r0, [r7, #12]
  2192e8:	f000 fa5e 	bl	2197a8 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
  2192ec:	68fb      	ldr	r3, [r7, #12]
  2192ee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  2192f0:	223f      	movs	r2, #63	; 0x3f
  2192f2:	409a      	lsls	r2, r3
  2192f4:	693b      	ldr	r3, [r7, #16]
  2192f6:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
  2192f8:	68fb      	ldr	r3, [r7, #12]
  2192fa:	681b      	ldr	r3, [r3, #0]
  2192fc:	68fa      	ldr	r2, [r7, #12]
  2192fe:	6812      	ldr	r2, [r2, #0]
  219300:	6812      	ldr	r2, [r2, #0]
  219302:	f042 0216 	orr.w	r2, r2, #22
  219306:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
  219308:	68fb      	ldr	r3, [r7, #12]
  21930a:	681b      	ldr	r3, [r3, #0]
  21930c:	68fa      	ldr	r2, [r7, #12]
  21930e:	6812      	ldr	r2, [r2, #0]
  219310:	6952      	ldr	r2, [r2, #20]
  219312:	f042 0280 	orr.w	r2, r2, #128	; 0x80
  219316:	615a      	str	r2, [r3, #20]
    
    if(hdma->XferHalfCpltCallback != NULL)
  219318:	68fb      	ldr	r3, [r7, #12]
  21931a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21931c:	2b00      	cmp	r3, #0
  21931e:	d007      	beq.n	219330 <HAL_DMA_Start_IT+0x98>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
  219320:	68fb      	ldr	r3, [r7, #12]
  219322:	681b      	ldr	r3, [r3, #0]
  219324:	68fa      	ldr	r2, [r7, #12]
  219326:	6812      	ldr	r2, [r2, #0]
  219328:	6812      	ldr	r2, [r2, #0]
  21932a:	f042 0208 	orr.w	r2, r2, #8
  21932e:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
  219330:	68fb      	ldr	r3, [r7, #12]
  219332:	681b      	ldr	r3, [r3, #0]
  219334:	68fa      	ldr	r2, [r7, #12]
  219336:	6812      	ldr	r2, [r2, #0]
  219338:	6812      	ldr	r2, [r2, #0]
  21933a:	f042 0201 	orr.w	r2, r2, #1
  21933e:	601a      	str	r2, [r3, #0]
  219340:	e005      	b.n	21934e <HAL_DMA_Start_IT+0xb6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
  219342:	68fb      	ldr	r3, [r7, #12]
  219344:	2200      	movs	r2, #0
  219346:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
  21934a:	2302      	movs	r3, #2
  21934c:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
  21934e:	7dfb      	ldrb	r3, [r7, #23]
}
  219350:	4618      	mov	r0, r3
  219352:	3718      	adds	r7, #24
  219354:	46bd      	mov	sp, r7
  219356:	bd80      	pop	{r7, pc}

00219358 <HAL_DMA_Abort>:
  *        and the Stream will be effectively disabled only after the transfer of
  *        this single data is finished.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *hdma)
{
  219358:	b580      	push	{r7, lr}
  21935a:	b084      	sub	sp, #16
  21935c:	af00      	add	r7, sp, #0
  21935e:	6078      	str	r0, [r7, #4]
  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  219360:	687b      	ldr	r3, [r7, #4]
  219362:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  219364:	60fb      	str	r3, [r7, #12]
  
  uint32_t tickstart = HAL_GetTick();
  219366:	f7ff fd63 	bl	218e30 <HAL_GetTick>
  21936a:	60b8      	str	r0, [r7, #8]
  
  if(hdma->State != HAL_DMA_STATE_BUSY)
  21936c:	687b      	ldr	r3, [r7, #4]
  21936e:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  219372:	b2db      	uxtb	r3, r3
  219374:	2b02      	cmp	r3, #2
  219376:	d008      	beq.n	21938a <HAL_DMA_Abort+0x32>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  219378:	687b      	ldr	r3, [r7, #4]
  21937a:	2280      	movs	r2, #128	; 0x80
  21937c:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
  21937e:	687b      	ldr	r3, [r7, #4]
  219380:	2200      	movs	r2, #0
  219382:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    return HAL_ERROR;
  219386:	2301      	movs	r3, #1
  219388:	e052      	b.n	219430 <HAL_DMA_Abort+0xd8>
  }
  else
  {
    /* Disable all the transfer interrupts */
    hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
  21938a:	687b      	ldr	r3, [r7, #4]
  21938c:	681b      	ldr	r3, [r3, #0]
  21938e:	687a      	ldr	r2, [r7, #4]
  219390:	6812      	ldr	r2, [r2, #0]
  219392:	6812      	ldr	r2, [r2, #0]
  219394:	f022 0216 	bic.w	r2, r2, #22
  219398:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR &= ~(DMA_IT_FE);
  21939a:	687b      	ldr	r3, [r7, #4]
  21939c:	681b      	ldr	r3, [r3, #0]
  21939e:	687a      	ldr	r2, [r7, #4]
  2193a0:	6812      	ldr	r2, [r2, #0]
  2193a2:	6952      	ldr	r2, [r2, #20]
  2193a4:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  2193a8:	615a      	str	r2, [r3, #20]
    
    if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
  2193aa:	687b      	ldr	r3, [r7, #4]
  2193ac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2193ae:	2b00      	cmp	r3, #0
  2193b0:	d103      	bne.n	2193ba <HAL_DMA_Abort+0x62>
  2193b2:	687b      	ldr	r3, [r7, #4]
  2193b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  2193b6:	2b00      	cmp	r3, #0
  2193b8:	d007      	beq.n	2193ca <HAL_DMA_Abort+0x72>
    {
      hdma->Instance->CR  &= ~(DMA_IT_HT);
  2193ba:	687b      	ldr	r3, [r7, #4]
  2193bc:	681b      	ldr	r3, [r3, #0]
  2193be:	687a      	ldr	r2, [r7, #4]
  2193c0:	6812      	ldr	r2, [r2, #0]
  2193c2:	6812      	ldr	r2, [r2, #0]
  2193c4:	f022 0208 	bic.w	r2, r2, #8
  2193c8:	601a      	str	r2, [r3, #0]
    }
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
  2193ca:	687b      	ldr	r3, [r7, #4]
  2193cc:	681b      	ldr	r3, [r3, #0]
  2193ce:	687a      	ldr	r2, [r7, #4]
  2193d0:	6812      	ldr	r2, [r2, #0]
  2193d2:	6812      	ldr	r2, [r2, #0]
  2193d4:	f022 0201 	bic.w	r2, r2, #1
  2193d8:	601a      	str	r2, [r3, #0]
    
    /* Check if the DMA Stream is effectively disabled */
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  2193da:	e013      	b.n	219404 <HAL_DMA_Abort+0xac>
    {
      /* Check for the Timeout */
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
  2193dc:	f7ff fd28 	bl	218e30 <HAL_GetTick>
  2193e0:	4602      	mov	r2, r0
  2193e2:	68bb      	ldr	r3, [r7, #8]
  2193e4:	1ad3      	subs	r3, r2, r3
  2193e6:	2b05      	cmp	r3, #5
  2193e8:	d90c      	bls.n	219404 <HAL_DMA_Abort+0xac>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
  2193ea:	687b      	ldr	r3, [r7, #4]
  2193ec:	2220      	movs	r2, #32
  2193ee:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
  2193f0:	687b      	ldr	r3, [r7, #4]
  2193f2:	2200      	movs	r2, #0
  2193f4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_TIMEOUT;
  2193f8:	687b      	ldr	r3, [r7, #4]
  2193fa:	2203      	movs	r2, #3
  2193fc:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_TIMEOUT;
  219400:	2303      	movs	r3, #3
  219402:	e015      	b.n	219430 <HAL_DMA_Abort+0xd8>
    while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
  219404:	687b      	ldr	r3, [r7, #4]
  219406:	681b      	ldr	r3, [r3, #0]
  219408:	681b      	ldr	r3, [r3, #0]
  21940a:	f003 0301 	and.w	r3, r3, #1
  21940e:	2b00      	cmp	r3, #0
  219410:	d1e4      	bne.n	2193dc <HAL_DMA_Abort+0x84>
      }
    }
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
  219412:	687b      	ldr	r3, [r7, #4]
  219414:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219416:	223f      	movs	r2, #63	; 0x3f
  219418:	409a      	lsls	r2, r3
  21941a:	68fb      	ldr	r3, [r7, #12]
  21941c:	609a      	str	r2, [r3, #8]
    
    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
  21941e:	687b      	ldr	r3, [r7, #4]
  219420:	2200      	movs	r2, #0
  219422:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Change the DMA state*/
    hdma->State = HAL_DMA_STATE_READY;
  219426:	687b      	ldr	r3, [r7, #4]
  219428:	2201      	movs	r2, #1
  21942a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  }
  return HAL_OK;
  21942e:	2300      	movs	r3, #0
}
  219430:	4618      	mov	r0, r3
  219432:	3710      	adds	r7, #16
  219434:	46bd      	mov	sp, r7
  219436:	bd80      	pop	{r7, pc}

00219438 <HAL_DMA_Abort_IT>:
  * @param  hdma   pointer to a DMA_HandleTypeDef structure that contains
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  219438:	b480      	push	{r7}
  21943a:	b083      	sub	sp, #12
  21943c:	af00      	add	r7, sp, #0
  21943e:	6078      	str	r0, [r7, #4]
  if(hdma->State != HAL_DMA_STATE_BUSY)
  219440:	687b      	ldr	r3, [r7, #4]
  219442:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  219446:	b2db      	uxtb	r3, r3
  219448:	2b02      	cmp	r3, #2
  21944a:	d004      	beq.n	219456 <HAL_DMA_Abort_IT+0x1e>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
  21944c:	687b      	ldr	r3, [r7, #4]
  21944e:	2280      	movs	r2, #128	; 0x80
  219450:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
  219452:	2301      	movs	r3, #1
  219454:	e00c      	b.n	219470 <HAL_DMA_Abort_IT+0x38>
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
  219456:	687b      	ldr	r3, [r7, #4]
  219458:	2205      	movs	r2, #5
  21945a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
  21945e:	687b      	ldr	r3, [r7, #4]
  219460:	681b      	ldr	r3, [r3, #0]
  219462:	687a      	ldr	r2, [r7, #4]
  219464:	6812      	ldr	r2, [r2, #0]
  219466:	6812      	ldr	r2, [r2, #0]
  219468:	f022 0201 	bic.w	r2, r2, #1
  21946c:	601a      	str	r2, [r3, #0]
  }

  return HAL_OK;
  21946e:	2300      	movs	r3, #0
}
  219470:	4618      	mov	r0, r3
  219472:	370c      	adds	r7, #12
  219474:	46bd      	mov	sp, r7
  219476:	f85d 7b04 	ldr.w	r7, [sp], #4
  21947a:	4770      	bx	lr

0021947c <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
  21947c:	b580      	push	{r7, lr}
  21947e:	b086      	sub	sp, #24
  219480:	af00      	add	r7, sp, #0
  219482:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0;
  219484:	2300      	movs	r3, #0
  219486:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600;
  219488:	4b92      	ldr	r3, [pc, #584]	; (2196d4 <HAL_DMA_IRQHandler+0x258>)
  21948a:	681b      	ldr	r3, [r3, #0]
  21948c:	4a92      	ldr	r2, [pc, #584]	; (2196d8 <HAL_DMA_IRQHandler+0x25c>)
  21948e:	fba2 2303 	umull	r2, r3, r2, r3
  219492:	0a9b      	lsrs	r3, r3, #10
  219494:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
  219496:	687b      	ldr	r3, [r7, #4]
  219498:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  21949a:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
  21949c:	693b      	ldr	r3, [r7, #16]
  21949e:	681b      	ldr	r3, [r3, #0]
  2194a0:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
  2194a2:	687b      	ldr	r3, [r7, #4]
  2194a4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  2194a6:	2208      	movs	r2, #8
  2194a8:	409a      	lsls	r2, r3
  2194aa:	68fb      	ldr	r3, [r7, #12]
  2194ac:	4013      	ands	r3, r2
  2194ae:	2b00      	cmp	r3, #0
  2194b0:	d01a      	beq.n	2194e8 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
  2194b2:	687b      	ldr	r3, [r7, #4]
  2194b4:	681b      	ldr	r3, [r3, #0]
  2194b6:	681b      	ldr	r3, [r3, #0]
  2194b8:	f003 0304 	and.w	r3, r3, #4
  2194bc:	2b00      	cmp	r3, #0
  2194be:	d013      	beq.n	2194e8 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
  2194c0:	687b      	ldr	r3, [r7, #4]
  2194c2:	681b      	ldr	r3, [r3, #0]
  2194c4:	687a      	ldr	r2, [r7, #4]
  2194c6:	6812      	ldr	r2, [r2, #0]
  2194c8:	6812      	ldr	r2, [r2, #0]
  2194ca:	f022 0204 	bic.w	r2, r2, #4
  2194ce:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
  2194d0:	687b      	ldr	r3, [r7, #4]
  2194d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  2194d4:	2208      	movs	r2, #8
  2194d6:	409a      	lsls	r2, r3
  2194d8:	693b      	ldr	r3, [r7, #16]
  2194da:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
  2194dc:	687b      	ldr	r3, [r7, #4]
  2194de:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  2194e0:	f043 0201 	orr.w	r2, r3, #1
  2194e4:	687b      	ldr	r3, [r7, #4]
  2194e6:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
  2194e8:	687b      	ldr	r3, [r7, #4]
  2194ea:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  2194ec:	2201      	movs	r2, #1
  2194ee:	409a      	lsls	r2, r3
  2194f0:	68fb      	ldr	r3, [r7, #12]
  2194f2:	4013      	ands	r3, r2
  2194f4:	2b00      	cmp	r3, #0
  2194f6:	d012      	beq.n	21951e <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
  2194f8:	687b      	ldr	r3, [r7, #4]
  2194fa:	681b      	ldr	r3, [r3, #0]
  2194fc:	695b      	ldr	r3, [r3, #20]
  2194fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
  219502:	2b00      	cmp	r3, #0
  219504:	d00b      	beq.n	21951e <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
  219506:	687b      	ldr	r3, [r7, #4]
  219508:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  21950a:	2201      	movs	r2, #1
  21950c:	409a      	lsls	r2, r3
  21950e:	693b      	ldr	r3, [r7, #16]
  219510:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
  219512:	687b      	ldr	r3, [r7, #4]
  219514:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  219516:	f043 0202 	orr.w	r2, r3, #2
  21951a:	687b      	ldr	r3, [r7, #4]
  21951c:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
  21951e:	687b      	ldr	r3, [r7, #4]
  219520:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219522:	2204      	movs	r2, #4
  219524:	409a      	lsls	r2, r3
  219526:	68fb      	ldr	r3, [r7, #12]
  219528:	4013      	ands	r3, r2
  21952a:	2b00      	cmp	r3, #0
  21952c:	d012      	beq.n	219554 <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
  21952e:	687b      	ldr	r3, [r7, #4]
  219530:	681b      	ldr	r3, [r3, #0]
  219532:	681b      	ldr	r3, [r3, #0]
  219534:	f003 0302 	and.w	r3, r3, #2
  219538:	2b00      	cmp	r3, #0
  21953a:	d00b      	beq.n	219554 <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
  21953c:	687b      	ldr	r3, [r7, #4]
  21953e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219540:	2204      	movs	r2, #4
  219542:	409a      	lsls	r2, r3
  219544:	693b      	ldr	r3, [r7, #16]
  219546:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
  219548:	687b      	ldr	r3, [r7, #4]
  21954a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21954c:	f043 0204 	orr.w	r2, r3, #4
  219550:	687b      	ldr	r3, [r7, #4]
  219552:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
  219554:	687b      	ldr	r3, [r7, #4]
  219556:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219558:	2210      	movs	r2, #16
  21955a:	409a      	lsls	r2, r3
  21955c:	68fb      	ldr	r3, [r7, #12]
  21955e:	4013      	ands	r3, r2
  219560:	2b00      	cmp	r3, #0
  219562:	d043      	beq.n	2195ec <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
  219564:	687b      	ldr	r3, [r7, #4]
  219566:	681b      	ldr	r3, [r3, #0]
  219568:	681b      	ldr	r3, [r3, #0]
  21956a:	f003 0308 	and.w	r3, r3, #8
  21956e:	2b00      	cmp	r3, #0
  219570:	d03c      	beq.n	2195ec <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
  219572:	687b      	ldr	r3, [r7, #4]
  219574:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219576:	2210      	movs	r2, #16
  219578:	409a      	lsls	r2, r3
  21957a:	693b      	ldr	r3, [r7, #16]
  21957c:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
  21957e:	687b      	ldr	r3, [r7, #4]
  219580:	681b      	ldr	r3, [r3, #0]
  219582:	681b      	ldr	r3, [r3, #0]
  219584:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  219588:	2b00      	cmp	r3, #0
  21958a:	d018      	beq.n	2195be <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
  21958c:	687b      	ldr	r3, [r7, #4]
  21958e:	681b      	ldr	r3, [r3, #0]
  219590:	681b      	ldr	r3, [r3, #0]
  219592:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  219596:	2b00      	cmp	r3, #0
  219598:	d108      	bne.n	2195ac <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
  21959a:	687b      	ldr	r3, [r7, #4]
  21959c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21959e:	2b00      	cmp	r3, #0
  2195a0:	d024      	beq.n	2195ec <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
  2195a2:	687b      	ldr	r3, [r7, #4]
  2195a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2195a6:	6878      	ldr	r0, [r7, #4]
  2195a8:	4798      	blx	r3
  2195aa:	e01f      	b.n	2195ec <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
  2195ac:	687b      	ldr	r3, [r7, #4]
  2195ae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  2195b0:	2b00      	cmp	r3, #0
  2195b2:	d01b      	beq.n	2195ec <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
  2195b4:	687b      	ldr	r3, [r7, #4]
  2195b6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  2195b8:	6878      	ldr	r0, [r7, #4]
  2195ba:	4798      	blx	r3
  2195bc:	e016      	b.n	2195ec <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
  2195be:	687b      	ldr	r3, [r7, #4]
  2195c0:	681b      	ldr	r3, [r3, #0]
  2195c2:	681b      	ldr	r3, [r3, #0]
  2195c4:	f403 7380 	and.w	r3, r3, #256	; 0x100
  2195c8:	2b00      	cmp	r3, #0
  2195ca:	d107      	bne.n	2195dc <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
  2195cc:	687b      	ldr	r3, [r7, #4]
  2195ce:	681b      	ldr	r3, [r3, #0]
  2195d0:	687a      	ldr	r2, [r7, #4]
  2195d2:	6812      	ldr	r2, [r2, #0]
  2195d4:	6812      	ldr	r2, [r2, #0]
  2195d6:	f022 0208 	bic.w	r2, r2, #8
  2195da:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
  2195dc:	687b      	ldr	r3, [r7, #4]
  2195de:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2195e0:	2b00      	cmp	r3, #0
  2195e2:	d003      	beq.n	2195ec <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
  2195e4:	687b      	ldr	r3, [r7, #4]
  2195e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2195e8:	6878      	ldr	r0, [r7, #4]
  2195ea:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
  2195ec:	687b      	ldr	r3, [r7, #4]
  2195ee:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  2195f0:	2220      	movs	r2, #32
  2195f2:	409a      	lsls	r2, r3
  2195f4:	68fb      	ldr	r3, [r7, #12]
  2195f6:	4013      	ands	r3, r2
  2195f8:	2b00      	cmp	r3, #0
  2195fa:	f000 808e 	beq.w	21971a <HAL_DMA_IRQHandler+0x29e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
  2195fe:	687b      	ldr	r3, [r7, #4]
  219600:	681b      	ldr	r3, [r3, #0]
  219602:	681b      	ldr	r3, [r3, #0]
  219604:	f003 0310 	and.w	r3, r3, #16
  219608:	2b00      	cmp	r3, #0
  21960a:	f000 8086 	beq.w	21971a <HAL_DMA_IRQHandler+0x29e>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
  21960e:	687b      	ldr	r3, [r7, #4]
  219610:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  219612:	2220      	movs	r2, #32
  219614:	409a      	lsls	r2, r3
  219616:	693b      	ldr	r3, [r7, #16]
  219618:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
  21961a:	687b      	ldr	r3, [r7, #4]
  21961c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  219620:	b2db      	uxtb	r3, r3
  219622:	2b05      	cmp	r3, #5
  219624:	d136      	bne.n	219694 <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
  219626:	687b      	ldr	r3, [r7, #4]
  219628:	681b      	ldr	r3, [r3, #0]
  21962a:	687a      	ldr	r2, [r7, #4]
  21962c:	6812      	ldr	r2, [r2, #0]
  21962e:	6812      	ldr	r2, [r2, #0]
  219630:	f022 0216 	bic.w	r2, r2, #22
  219634:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
  219636:	687b      	ldr	r3, [r7, #4]
  219638:	681b      	ldr	r3, [r3, #0]
  21963a:	687a      	ldr	r2, [r7, #4]
  21963c:	6812      	ldr	r2, [r2, #0]
  21963e:	6952      	ldr	r2, [r2, #20]
  219640:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  219644:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
  219646:	687b      	ldr	r3, [r7, #4]
  219648:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21964a:	2b00      	cmp	r3, #0
  21964c:	d103      	bne.n	219656 <HAL_DMA_IRQHandler+0x1da>
  21964e:	687b      	ldr	r3, [r7, #4]
  219650:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  219652:	2b00      	cmp	r3, #0
  219654:	d007      	beq.n	219666 <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
  219656:	687b      	ldr	r3, [r7, #4]
  219658:	681b      	ldr	r3, [r3, #0]
  21965a:	687a      	ldr	r2, [r7, #4]
  21965c:	6812      	ldr	r2, [r2, #0]
  21965e:	6812      	ldr	r2, [r2, #0]
  219660:	f022 0208 	bic.w	r2, r2, #8
  219664:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
  219666:	687b      	ldr	r3, [r7, #4]
  219668:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  21966a:	223f      	movs	r2, #63	; 0x3f
  21966c:	409a      	lsls	r2, r3
  21966e:	693b      	ldr	r3, [r7, #16]
  219670:	609a      	str	r2, [r3, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
  219672:	687b      	ldr	r3, [r7, #4]
  219674:	2200      	movs	r2, #0
  219676:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
  21967a:	687b      	ldr	r3, [r7, #4]
  21967c:	2201      	movs	r2, #1
  21967e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
  219682:	687b      	ldr	r3, [r7, #4]
  219684:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  219686:	2b00      	cmp	r3, #0
  219688:	d07d      	beq.n	219786 <HAL_DMA_IRQHandler+0x30a>
        {
          hdma->XferAbortCallback(hdma);
  21968a:	687b      	ldr	r3, [r7, #4]
  21968c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21968e:	6878      	ldr	r0, [r7, #4]
  219690:	4798      	blx	r3
        }
        return;
  219692:	e078      	b.n	219786 <HAL_DMA_IRQHandler+0x30a>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
  219694:	687b      	ldr	r3, [r7, #4]
  219696:	681b      	ldr	r3, [r3, #0]
  219698:	681b      	ldr	r3, [r3, #0]
  21969a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  21969e:	2b00      	cmp	r3, #0
  2196a0:	d01c      	beq.n	2196dc <HAL_DMA_IRQHandler+0x260>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
  2196a2:	687b      	ldr	r3, [r7, #4]
  2196a4:	681b      	ldr	r3, [r3, #0]
  2196a6:	681b      	ldr	r3, [r3, #0]
  2196a8:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  2196ac:	2b00      	cmp	r3, #0
  2196ae:	d108      	bne.n	2196c2 <HAL_DMA_IRQHandler+0x246>
        {
          if(hdma->XferM1CpltCallback != NULL)
  2196b0:	687b      	ldr	r3, [r7, #4]
  2196b2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2196b4:	2b00      	cmp	r3, #0
  2196b6:	d030      	beq.n	21971a <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
  2196b8:	687b      	ldr	r3, [r7, #4]
  2196ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  2196bc:	6878      	ldr	r0, [r7, #4]
  2196be:	4798      	blx	r3
  2196c0:	e02b      	b.n	21971a <HAL_DMA_IRQHandler+0x29e>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
  2196c2:	687b      	ldr	r3, [r7, #4]
  2196c4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  2196c6:	2b00      	cmp	r3, #0
  2196c8:	d027      	beq.n	21971a <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
  2196ca:	687b      	ldr	r3, [r7, #4]
  2196cc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  2196ce:	6878      	ldr	r0, [r7, #4]
  2196d0:	4798      	blx	r3
  2196d2:	e022      	b.n	21971a <HAL_DMA_IRQHandler+0x29e>
  2196d4:	20000004 	.word	0x20000004
  2196d8:	1b4e81b5 	.word	0x1b4e81b5
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
  2196dc:	687b      	ldr	r3, [r7, #4]
  2196de:	681b      	ldr	r3, [r3, #0]
  2196e0:	681b      	ldr	r3, [r3, #0]
  2196e2:	f403 7380 	and.w	r3, r3, #256	; 0x100
  2196e6:	2b00      	cmp	r3, #0
  2196e8:	d10f      	bne.n	21970a <HAL_DMA_IRQHandler+0x28e>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
  2196ea:	687b      	ldr	r3, [r7, #4]
  2196ec:	681b      	ldr	r3, [r3, #0]
  2196ee:	687a      	ldr	r2, [r7, #4]
  2196f0:	6812      	ldr	r2, [r2, #0]
  2196f2:	6812      	ldr	r2, [r2, #0]
  2196f4:	f022 0210 	bic.w	r2, r2, #16
  2196f8:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
  2196fa:	687b      	ldr	r3, [r7, #4]
  2196fc:	2200      	movs	r2, #0
  2196fe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
  219702:	687b      	ldr	r3, [r7, #4]
  219704:	2201      	movs	r2, #1
  219706:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
  21970a:	687b      	ldr	r3, [r7, #4]
  21970c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21970e:	2b00      	cmp	r3, #0
  219710:	d003      	beq.n	21971a <HAL_DMA_IRQHandler+0x29e>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
  219712:	687b      	ldr	r3, [r7, #4]
  219714:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  219716:	6878      	ldr	r0, [r7, #4]
  219718:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
  21971a:	687b      	ldr	r3, [r7, #4]
  21971c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21971e:	2b00      	cmp	r3, #0
  219720:	d032      	beq.n	219788 <HAL_DMA_IRQHandler+0x30c>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
  219722:	687b      	ldr	r3, [r7, #4]
  219724:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  219726:	f003 0301 	and.w	r3, r3, #1
  21972a:	2b00      	cmp	r3, #0
  21972c:	d022      	beq.n	219774 <HAL_DMA_IRQHandler+0x2f8>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
  21972e:	687b      	ldr	r3, [r7, #4]
  219730:	2205      	movs	r2, #5
  219732:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
  219736:	687b      	ldr	r3, [r7, #4]
  219738:	681b      	ldr	r3, [r3, #0]
  21973a:	687a      	ldr	r2, [r7, #4]
  21973c:	6812      	ldr	r2, [r2, #0]
  21973e:	6812      	ldr	r2, [r2, #0]
  219740:	f022 0201 	bic.w	r2, r2, #1
  219744:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
  219746:	68bb      	ldr	r3, [r7, #8]
  219748:	3301      	adds	r3, #1
  21974a:	60bb      	str	r3, [r7, #8]
  21974c:	697a      	ldr	r2, [r7, #20]
  21974e:	4293      	cmp	r3, r2
  219750:	d807      	bhi.n	219762 <HAL_DMA_IRQHandler+0x2e6>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
  219752:	687b      	ldr	r3, [r7, #4]
  219754:	681b      	ldr	r3, [r3, #0]
  219756:	681b      	ldr	r3, [r3, #0]
  219758:	f003 0301 	and.w	r3, r3, #1
  21975c:	2b00      	cmp	r3, #0
  21975e:	d1f2      	bne.n	219746 <HAL_DMA_IRQHandler+0x2ca>
  219760:	e000      	b.n	219764 <HAL_DMA_IRQHandler+0x2e8>
          break;
  219762:	bf00      	nop

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
  219764:	687b      	ldr	r3, [r7, #4]
  219766:	2200      	movs	r2, #0
  219768:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
  21976c:	687b      	ldr	r3, [r7, #4]
  21976e:	2201      	movs	r2, #1
  219770:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
  219774:	687b      	ldr	r3, [r7, #4]
  219776:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  219778:	2b00      	cmp	r3, #0
  21977a:	d005      	beq.n	219788 <HAL_DMA_IRQHandler+0x30c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
  21977c:	687b      	ldr	r3, [r7, #4]
  21977e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  219780:	6878      	ldr	r0, [r7, #4]
  219782:	4798      	blx	r3
  219784:	e000      	b.n	219788 <HAL_DMA_IRQHandler+0x30c>
        return;
  219786:	bf00      	nop
    }
  }
}
  219788:	3718      	adds	r7, #24
  21978a:	46bd      	mov	sp, r7
  21978c:	bd80      	pop	{r7, pc}
  21978e:	bf00      	nop

00219790 <HAL_DMA_GetError>:
  * @param  hdma  pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA Stream.
  * @retval DMA Error Code
  */
uint32_t HAL_DMA_GetError(DMA_HandleTypeDef *hdma)
{
  219790:	b480      	push	{r7}
  219792:	b083      	sub	sp, #12
  219794:	af00      	add	r7, sp, #0
  219796:	6078      	str	r0, [r7, #4]
  return hdma->ErrorCode;
  219798:	687b      	ldr	r3, [r7, #4]
  21979a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
}
  21979c:	4618      	mov	r0, r3
  21979e:	370c      	adds	r7, #12
  2197a0:	46bd      	mov	sp, r7
  2197a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  2197a6:	4770      	bx	lr

002197a8 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
  2197a8:	b480      	push	{r7}
  2197aa:	b085      	sub	sp, #20
  2197ac:	af00      	add	r7, sp, #0
  2197ae:	60f8      	str	r0, [r7, #12]
  2197b0:	60b9      	str	r1, [r7, #8]
  2197b2:	607a      	str	r2, [r7, #4]
  2197b4:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
  2197b6:	68fb      	ldr	r3, [r7, #12]
  2197b8:	681b      	ldr	r3, [r3, #0]
  2197ba:	68fa      	ldr	r2, [r7, #12]
  2197bc:	6812      	ldr	r2, [r2, #0]
  2197be:	6812      	ldr	r2, [r2, #0]
  2197c0:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
  2197c4:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
  2197c6:	68fb      	ldr	r3, [r7, #12]
  2197c8:	681b      	ldr	r3, [r3, #0]
  2197ca:	683a      	ldr	r2, [r7, #0]
  2197cc:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
  2197ce:	68fb      	ldr	r3, [r7, #12]
  2197d0:	689b      	ldr	r3, [r3, #8]
  2197d2:	2b40      	cmp	r3, #64	; 0x40
  2197d4:	d108      	bne.n	2197e8 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
  2197d6:	68fb      	ldr	r3, [r7, #12]
  2197d8:	681b      	ldr	r3, [r3, #0]
  2197da:	687a      	ldr	r2, [r7, #4]
  2197dc:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
  2197de:	68fb      	ldr	r3, [r7, #12]
  2197e0:	681b      	ldr	r3, [r3, #0]
  2197e2:	68ba      	ldr	r2, [r7, #8]
  2197e4:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
  2197e6:	e007      	b.n	2197f8 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
  2197e8:	68fb      	ldr	r3, [r7, #12]
  2197ea:	681b      	ldr	r3, [r3, #0]
  2197ec:	68ba      	ldr	r2, [r7, #8]
  2197ee:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
  2197f0:	68fb      	ldr	r3, [r7, #12]
  2197f2:	681b      	ldr	r3, [r3, #0]
  2197f4:	687a      	ldr	r2, [r7, #4]
  2197f6:	60da      	str	r2, [r3, #12]
}
  2197f8:	bf00      	nop
  2197fa:	3714      	adds	r7, #20
  2197fc:	46bd      	mov	sp, r7
  2197fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  219802:	4770      	bx	lr

00219804 <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  219804:	b480      	push	{r7}
  219806:	b085      	sub	sp, #20
  219808:	af00      	add	r7, sp, #0
  21980a:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
  21980c:	687b      	ldr	r3, [r7, #4]
  21980e:	681b      	ldr	r3, [r3, #0]
  219810:	b2db      	uxtb	r3, r3
  219812:	3b10      	subs	r3, #16
  219814:	4a13      	ldr	r2, [pc, #76]	; (219864 <DMA_CalcBaseAndBitshift+0x60>)
  219816:	fba2 2303 	umull	r2, r3, r2, r3
  21981a:	091b      	lsrs	r3, r3, #4
  21981c:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
  21981e:	4a12      	ldr	r2, [pc, #72]	; (219868 <DMA_CalcBaseAndBitshift+0x64>)
  219820:	68fb      	ldr	r3, [r7, #12]
  219822:	4413      	add	r3, r2
  219824:	781b      	ldrb	r3, [r3, #0]
  219826:	461a      	mov	r2, r3
  219828:	687b      	ldr	r3, [r7, #4]
  21982a:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
  21982c:	68fb      	ldr	r3, [r7, #12]
  21982e:	2b03      	cmp	r3, #3
  219830:	d908      	bls.n	219844 <DMA_CalcBaseAndBitshift+0x40>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
  219832:	687b      	ldr	r3, [r7, #4]
  219834:	681b      	ldr	r3, [r3, #0]
  219836:	461a      	mov	r2, r3
  219838:	4b0c      	ldr	r3, [pc, #48]	; (21986c <DMA_CalcBaseAndBitshift+0x68>)
  21983a:	4013      	ands	r3, r2
  21983c:	1d1a      	adds	r2, r3, #4
  21983e:	687b      	ldr	r3, [r7, #4]
  219840:	659a      	str	r2, [r3, #88]	; 0x58
  219842:	e006      	b.n	219852 <DMA_CalcBaseAndBitshift+0x4e>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  219844:	687b      	ldr	r3, [r7, #4]
  219846:	681b      	ldr	r3, [r3, #0]
  219848:	461a      	mov	r2, r3
  21984a:	4b08      	ldr	r3, [pc, #32]	; (21986c <DMA_CalcBaseAndBitshift+0x68>)
  21984c:	4013      	ands	r3, r2
  21984e:	687a      	ldr	r2, [r7, #4]
  219850:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
  219852:	687b      	ldr	r3, [r7, #4]
  219854:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
  219856:	4618      	mov	r0, r3
  219858:	3714      	adds	r7, #20
  21985a:	46bd      	mov	sp, r7
  21985c:	f85d 7b04 	ldr.w	r7, [sp], #4
  219860:	4770      	bx	lr
  219862:	bf00      	nop
  219864:	aaaaaaab 	.word	0xaaaaaaab
  219868:	00229388 	.word	0x00229388
  21986c:	fffffc00 	.word	0xfffffc00

00219870 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  219870:	b480      	push	{r7}
  219872:	b085      	sub	sp, #20
  219874:	af00      	add	r7, sp, #0
  219876:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
  219878:	2300      	movs	r3, #0
  21987a:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
  21987c:	687b      	ldr	r3, [r7, #4]
  21987e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  219880:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
  219882:	687b      	ldr	r3, [r7, #4]
  219884:	699b      	ldr	r3, [r3, #24]
  219886:	2b00      	cmp	r3, #0
  219888:	d11f      	bne.n	2198ca <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
  21988a:	68bb      	ldr	r3, [r7, #8]
  21988c:	2b03      	cmp	r3, #3
  21988e:	d855      	bhi.n	21993c <DMA_CheckFifoParam+0xcc>
  219890:	a201      	add	r2, pc, #4	; (adr r2, 219898 <DMA_CheckFifoParam+0x28>)
  219892:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  219896:	bf00      	nop
  219898:	002198a9 	.word	0x002198a9
  21989c:	002198bb 	.word	0x002198bb
  2198a0:	002198a9 	.word	0x002198a9
  2198a4:	0021993d 	.word	0x0021993d
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
  2198a8:	687b      	ldr	r3, [r7, #4]
  2198aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2198ac:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  2198b0:	2b00      	cmp	r3, #0
  2198b2:	d045      	beq.n	219940 <DMA_CheckFifoParam+0xd0>
      {
        status = HAL_ERROR;
  2198b4:	2301      	movs	r3, #1
  2198b6:	73fb      	strb	r3, [r7, #15]
      }
      break;
  2198b8:	e042      	b.n	219940 <DMA_CheckFifoParam+0xd0>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
  2198ba:	687b      	ldr	r3, [r7, #4]
  2198bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2198be:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
  2198c2:	d13f      	bne.n	219944 <DMA_CheckFifoParam+0xd4>
      {
        status = HAL_ERROR;
  2198c4:	2301      	movs	r3, #1
  2198c6:	73fb      	strb	r3, [r7, #15]
      }
      break;
  2198c8:	e03c      	b.n	219944 <DMA_CheckFifoParam+0xd4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
  2198ca:	687b      	ldr	r3, [r7, #4]
  2198cc:	699b      	ldr	r3, [r3, #24]
  2198ce:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  2198d2:	d121      	bne.n	219918 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
  2198d4:	68bb      	ldr	r3, [r7, #8]
  2198d6:	2b03      	cmp	r3, #3
  2198d8:	d836      	bhi.n	219948 <DMA_CheckFifoParam+0xd8>
  2198da:	a201      	add	r2, pc, #4	; (adr r2, 2198e0 <DMA_CheckFifoParam+0x70>)
  2198dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  2198e0:	002198f1 	.word	0x002198f1
  2198e4:	002198f7 	.word	0x002198f7
  2198e8:	002198f1 	.word	0x002198f1
  2198ec:	00219909 	.word	0x00219909
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
  2198f0:	2301      	movs	r3, #1
  2198f2:	73fb      	strb	r3, [r7, #15]
      break;
  2198f4:	e02f      	b.n	219956 <DMA_CheckFifoParam+0xe6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
  2198f6:	687b      	ldr	r3, [r7, #4]
  2198f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2198fa:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  2198fe:	2b00      	cmp	r3, #0
  219900:	d024      	beq.n	21994c <DMA_CheckFifoParam+0xdc>
      {
        status = HAL_ERROR;
  219902:	2301      	movs	r3, #1
  219904:	73fb      	strb	r3, [r7, #15]
      }
      break;
  219906:	e021      	b.n	21994c <DMA_CheckFifoParam+0xdc>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
  219908:	687b      	ldr	r3, [r7, #4]
  21990a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21990c:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
  219910:	d11e      	bne.n	219950 <DMA_CheckFifoParam+0xe0>
      {
        status = HAL_ERROR;
  219912:	2301      	movs	r3, #1
  219914:	73fb      	strb	r3, [r7, #15]
      }
      break;   
  219916:	e01b      	b.n	219950 <DMA_CheckFifoParam+0xe0>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
  219918:	68bb      	ldr	r3, [r7, #8]
  21991a:	2b02      	cmp	r3, #2
  21991c:	d902      	bls.n	219924 <DMA_CheckFifoParam+0xb4>
  21991e:	2b03      	cmp	r3, #3
  219920:	d003      	beq.n	21992a <DMA_CheckFifoParam+0xba>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
  219922:	e018      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      status = HAL_ERROR;
  219924:	2301      	movs	r3, #1
  219926:	73fb      	strb	r3, [r7, #15]
      break;
  219928:	e015      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
  21992a:	687b      	ldr	r3, [r7, #4]
  21992c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21992e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  219932:	2b00      	cmp	r3, #0
  219934:	d00e      	beq.n	219954 <DMA_CheckFifoParam+0xe4>
        status = HAL_ERROR;
  219936:	2301      	movs	r3, #1
  219938:	73fb      	strb	r3, [r7, #15]
      break;
  21993a:	e00b      	b.n	219954 <DMA_CheckFifoParam+0xe4>
      break;
  21993c:	bf00      	nop
  21993e:	e00a      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      break;
  219940:	bf00      	nop
  219942:	e008      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      break;
  219944:	bf00      	nop
  219946:	e006      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      break;
  219948:	bf00      	nop
  21994a:	e004      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      break;
  21994c:	bf00      	nop
  21994e:	e002      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      break;   
  219950:	bf00      	nop
  219952:	e000      	b.n	219956 <DMA_CheckFifoParam+0xe6>
      break;
  219954:	bf00      	nop
    }
  } 
  
  return status; 
  219956:	7bfb      	ldrb	r3, [r7, #15]
}
  219958:	4618      	mov	r0, r3
  21995a:	3714      	adds	r7, #20
  21995c:	46bd      	mov	sp, r7
  21995e:	f85d 7b04 	ldr.w	r7, [sp], #4
  219962:	4770      	bx	lr

00219964 <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
  219964:	b580      	push	{r7, lr}
  219966:	b082      	sub	sp, #8
  219968:	af00      	add	r7, sp, #0
  21996a:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if (hdma2d == NULL)
  21996c:	687b      	ldr	r3, [r7, #4]
  21996e:	2b00      	cmp	r3, #0
  219970:	d101      	bne.n	219976 <HAL_DMA2D_Init+0x12>
  {
    return HAL_ERROR;
  219972:	2301      	movs	r3, #1
  219974:	e049      	b.n	219a0a <HAL_DMA2D_Init+0xa6>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if (hdma2d->State == HAL_DMA2D_STATE_RESET)
  219976:	687b      	ldr	r3, [r7, #4]
  219978:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
  21997c:	b2db      	uxtb	r3, r3
  21997e:	2b00      	cmp	r3, #0
  219980:	d106      	bne.n	219990 <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
  219982:	687b      	ldr	r3, [r7, #4]
  219984:	2200      	movs	r2, #0
  219986:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
  21998a:	6878      	ldr	r0, [r7, #4]
  21998c:	f7fd feb0 	bl	2176f0 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
  219990:	687b      	ldr	r3, [r7, #4]
  219992:	2202      	movs	r2, #2
  219994:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
  219998:	687b      	ldr	r3, [r7, #4]
  21999a:	681b      	ldr	r3, [r3, #0]
  21999c:	687a      	ldr	r2, [r7, #4]
  21999e:	6812      	ldr	r2, [r2, #0]
  2199a0:	6812      	ldr	r2, [r2, #0]
  2199a2:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
  2199a6:	687a      	ldr	r2, [r7, #4]
  2199a8:	6852      	ldr	r2, [r2, #4]
  2199aa:	430a      	orrs	r2, r1
  2199ac:	601a      	str	r2, [r3, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
  2199ae:	687b      	ldr	r3, [r7, #4]
  2199b0:	681b      	ldr	r3, [r3, #0]
  2199b2:	687a      	ldr	r2, [r7, #4]
  2199b4:	6812      	ldr	r2, [r2, #0]
  2199b6:	6b52      	ldr	r2, [r2, #52]	; 0x34
  2199b8:	f022 0107 	bic.w	r1, r2, #7
  2199bc:	687a      	ldr	r2, [r7, #4]
  2199be:	6892      	ldr	r2, [r2, #8]
  2199c0:	430a      	orrs	r2, r1
  2199c2:	635a      	str	r2, [r3, #52]	; 0x34

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
  2199c4:	687b      	ldr	r3, [r7, #4]
  2199c6:	681a      	ldr	r2, [r3, #0]
  2199c8:	687b      	ldr	r3, [r7, #4]
  2199ca:	681b      	ldr	r3, [r3, #0]
  2199cc:	6c19      	ldr	r1, [r3, #64]	; 0x40
  2199ce:	4b11      	ldr	r3, [pc, #68]	; (219a14 <HAL_DMA2D_Init+0xb0>)
  2199d0:	400b      	ands	r3, r1
  2199d2:	6879      	ldr	r1, [r7, #4]
  2199d4:	68c9      	ldr	r1, [r1, #12]
  2199d6:	430b      	orrs	r3, r1
  2199d8:	6413      	str	r3, [r2, #64]	; 0x40
#if defined (DMA2D_ALPHA_INV_RB_SWAP_SUPPORT)
  /* DMA2D OPFCCR AI and RBS fields setting (Output Alpha Inversion)*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, (DMA2D_OPFCCR_AI | DMA2D_OPFCCR_RBS),
  2199da:	687b      	ldr	r3, [r7, #4]
  2199dc:	681b      	ldr	r3, [r3, #0]
  2199de:	687a      	ldr	r2, [r7, #4]
  2199e0:	6812      	ldr	r2, [r2, #0]
  2199e2:	6b52      	ldr	r2, [r2, #52]	; 0x34
  2199e4:	f422 1140 	bic.w	r1, r2, #3145728	; 0x300000
  2199e8:	687a      	ldr	r2, [r7, #4]
  2199ea:	6912      	ldr	r2, [r2, #16]
  2199ec:	0510      	lsls	r0, r2, #20
  2199ee:	687a      	ldr	r2, [r7, #4]
  2199f0:	6952      	ldr	r2, [r2, #20]
  2199f2:	0552      	lsls	r2, r2, #21
  2199f4:	4302      	orrs	r2, r0
  2199f6:	430a      	orrs	r2, r1
  2199f8:	635a      	str	r2, [r3, #52]	; 0x34
              (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
  2199fa:	687b      	ldr	r3, [r7, #4]
  2199fc:	2200      	movs	r2, #0
  2199fe:	655a      	str	r2, [r3, #84]	; 0x54

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
  219a00:	687b      	ldr	r3, [r7, #4]
  219a02:	2201      	movs	r2, #1
  219a04:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  return HAL_OK;
  219a08:	2300      	movs	r3, #0
}
  219a0a:	4618      	mov	r0, r3
  219a0c:	3708      	adds	r7, #8
  219a0e:	46bd      	mov	sp, r7
  219a10:	bd80      	pop	{r7, pc}
  219a12:	bf00      	nop
  219a14:	ffffc000 	.word	0xffffc000

00219a18 <HAL_DMA2D_Start_IT>:
  * @param  Height     The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Start_IT(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                                     uint32_t Height)
{
  219a18:	b580      	push	{r7, lr}
  219a1a:	b086      	sub	sp, #24
  219a1c:	af02      	add	r7, sp, #8
  219a1e:	60f8      	str	r0, [r7, #12]
  219a20:	60b9      	str	r1, [r7, #8]
  219a22:	607a      	str	r2, [r7, #4]
  219a24:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
  219a26:	68fb      	ldr	r3, [r7, #12]
  219a28:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
  219a2c:	2b01      	cmp	r3, #1
  219a2e:	d101      	bne.n	219a34 <HAL_DMA2D_Start_IT+0x1c>
  219a30:	2302      	movs	r3, #2
  219a32:	e020      	b.n	219a76 <HAL_DMA2D_Start_IT+0x5e>
  219a34:	68fb      	ldr	r3, [r7, #12]
  219a36:	2201      	movs	r2, #1
  219a38:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
  219a3c:	68fb      	ldr	r3, [r7, #12]
  219a3e:	2202      	movs	r2, #2
  219a40:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, pdata, DstAddress, Width, Height);
  219a44:	69bb      	ldr	r3, [r7, #24]
  219a46:	9300      	str	r3, [sp, #0]
  219a48:	683b      	ldr	r3, [r7, #0]
  219a4a:	687a      	ldr	r2, [r7, #4]
  219a4c:	68b9      	ldr	r1, [r7, #8]
  219a4e:	68f8      	ldr	r0, [r7, #12]
  219a50:	f000 f9d0 	bl	219df4 <DMA2D_SetConfig>

  /* Enable the transfer complete, transfer error and configuration error interrupts */
  __HAL_DMA2D_ENABLE_IT(hdma2d, DMA2D_IT_TC | DMA2D_IT_TE | DMA2D_IT_CE);
  219a54:	68fb      	ldr	r3, [r7, #12]
  219a56:	681b      	ldr	r3, [r3, #0]
  219a58:	68fa      	ldr	r2, [r7, #12]
  219a5a:	6812      	ldr	r2, [r2, #0]
  219a5c:	6812      	ldr	r2, [r2, #0]
  219a5e:	f442 520c 	orr.w	r2, r2, #8960	; 0x2300
  219a62:	601a      	str	r2, [r3, #0]

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
  219a64:	68fb      	ldr	r3, [r7, #12]
  219a66:	681b      	ldr	r3, [r3, #0]
  219a68:	68fa      	ldr	r2, [r7, #12]
  219a6a:	6812      	ldr	r2, [r2, #0]
  219a6c:	6812      	ldr	r2, [r2, #0]
  219a6e:	f042 0201 	orr.w	r2, r2, #1
  219a72:	601a      	str	r2, [r3, #0]

  return HAL_OK;
  219a74:	2300      	movs	r3, #0
}
  219a76:	4618      	mov	r0, r3
  219a78:	3710      	adds	r7, #16
  219a7a:	46bd      	mov	sp, r7
  219a7c:	bd80      	pop	{r7, pc}

00219a7e <HAL_DMA2D_IRQHandler>:
  * @param  hdma2d Pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
void HAL_DMA2D_IRQHandler(DMA2D_HandleTypeDef *hdma2d)
{
  219a7e:	b580      	push	{r7, lr}
  219a80:	b084      	sub	sp, #16
  219a82:	af00      	add	r7, sp, #0
  219a84:	6078      	str	r0, [r7, #4]
  uint32_t isrflags = READ_REG(hdma2d->Instance->ISR);
  219a86:	687b      	ldr	r3, [r7, #4]
  219a88:	681b      	ldr	r3, [r3, #0]
  219a8a:	685b      	ldr	r3, [r3, #4]
  219a8c:	60fb      	str	r3, [r7, #12]
  uint32_t crflags = READ_REG(hdma2d->Instance->CR);
  219a8e:	687b      	ldr	r3, [r7, #4]
  219a90:	681b      	ldr	r3, [r3, #0]
  219a92:	681b      	ldr	r3, [r3, #0]
  219a94:	60bb      	str	r3, [r7, #8]

  /* Transfer Error Interrupt management ***************************************/
  if ((isrflags & DMA2D_FLAG_TE) != 0U)
  219a96:	68fb      	ldr	r3, [r7, #12]
  219a98:	f003 0301 	and.w	r3, r3, #1
  219a9c:	2b00      	cmp	r3, #0
  219a9e:	d026      	beq.n	219aee <HAL_DMA2D_IRQHandler+0x70>
  {
    if ((crflags & DMA2D_IT_TE) != 0U)
  219aa0:	68bb      	ldr	r3, [r7, #8]
  219aa2:	f403 7380 	and.w	r3, r3, #256	; 0x100
  219aa6:	2b00      	cmp	r3, #0
  219aa8:	d021      	beq.n	219aee <HAL_DMA2D_IRQHandler+0x70>
    {
      /* Disable the transfer Error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TE);
  219aaa:	687b      	ldr	r3, [r7, #4]
  219aac:	681b      	ldr	r3, [r3, #0]
  219aae:	687a      	ldr	r2, [r7, #4]
  219ab0:	6812      	ldr	r2, [r2, #0]
  219ab2:	6812      	ldr	r2, [r2, #0]
  219ab4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  219ab8:	601a      	str	r2, [r3, #0]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
  219aba:	687b      	ldr	r3, [r7, #4]
  219abc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  219abe:	f043 0201 	orr.w	r2, r3, #1
  219ac2:	687b      	ldr	r3, [r7, #4]
  219ac4:	655a      	str	r2, [r3, #84]	; 0x54

      /* Clear the transfer error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TE);
  219ac6:	687b      	ldr	r3, [r7, #4]
  219ac8:	681b      	ldr	r3, [r3, #0]
  219aca:	2201      	movs	r2, #1
  219acc:	609a      	str	r2, [r3, #8]

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
  219ace:	687b      	ldr	r3, [r7, #4]
  219ad0:	2204      	movs	r2, #4
  219ad2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
  219ad6:	687b      	ldr	r3, [r7, #4]
  219ad8:	2200      	movs	r2, #0
  219ada:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      if (hdma2d->XferErrorCallback != NULL)
  219ade:	687b      	ldr	r3, [r7, #4]
  219ae0:	69db      	ldr	r3, [r3, #28]
  219ae2:	2b00      	cmp	r3, #0
  219ae4:	d003      	beq.n	219aee <HAL_DMA2D_IRQHandler+0x70>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
  219ae6:	687b      	ldr	r3, [r7, #4]
  219ae8:	69db      	ldr	r3, [r3, #28]
  219aea:	6878      	ldr	r0, [r7, #4]
  219aec:	4798      	blx	r3
      }
    }
  }
  /* Configuration Error Interrupt management **********************************/
  if ((isrflags & DMA2D_FLAG_CE) != 0U)
  219aee:	68fb      	ldr	r3, [r7, #12]
  219af0:	f003 0320 	and.w	r3, r3, #32
  219af4:	2b00      	cmp	r3, #0
  219af6:	d026      	beq.n	219b46 <HAL_DMA2D_IRQHandler+0xc8>
  {
    if ((crflags & DMA2D_IT_CE) != 0U)
  219af8:	68bb      	ldr	r3, [r7, #8]
  219afa:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  219afe:	2b00      	cmp	r3, #0
  219b00:	d021      	beq.n	219b46 <HAL_DMA2D_IRQHandler+0xc8>
    {
      /* Disable the Configuration Error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CE);
  219b02:	687b      	ldr	r3, [r7, #4]
  219b04:	681b      	ldr	r3, [r3, #0]
  219b06:	687a      	ldr	r2, [r7, #4]
  219b08:	6812      	ldr	r2, [r2, #0]
  219b0a:	6812      	ldr	r2, [r2, #0]
  219b0c:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  219b10:	601a      	str	r2, [r3, #0]

      /* Clear the Configuration error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE);
  219b12:	687b      	ldr	r3, [r7, #4]
  219b14:	681b      	ldr	r3, [r3, #0]
  219b16:	2220      	movs	r2, #32
  219b18:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
  219b1a:	687b      	ldr	r3, [r7, #4]
  219b1c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  219b1e:	f043 0202 	orr.w	r2, r3, #2
  219b22:	687b      	ldr	r3, [r7, #4]
  219b24:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
  219b26:	687b      	ldr	r3, [r7, #4]
  219b28:	2204      	movs	r2, #4
  219b2a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
  219b2e:	687b      	ldr	r3, [r7, #4]
  219b30:	2200      	movs	r2, #0
  219b32:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      if (hdma2d->XferErrorCallback != NULL)
  219b36:	687b      	ldr	r3, [r7, #4]
  219b38:	69db      	ldr	r3, [r3, #28]
  219b3a:	2b00      	cmp	r3, #0
  219b3c:	d003      	beq.n	219b46 <HAL_DMA2D_IRQHandler+0xc8>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
  219b3e:	687b      	ldr	r3, [r7, #4]
  219b40:	69db      	ldr	r3, [r3, #28]
  219b42:	6878      	ldr	r0, [r7, #4]
  219b44:	4798      	blx	r3
      }
    }
  }
  /* CLUT access Error Interrupt management ***********************************/
  if ((isrflags & DMA2D_FLAG_CAE) != 0U)
  219b46:	68fb      	ldr	r3, [r7, #12]
  219b48:	f003 0308 	and.w	r3, r3, #8
  219b4c:	2b00      	cmp	r3, #0
  219b4e:	d026      	beq.n	219b9e <HAL_DMA2D_IRQHandler+0x120>
  {
    if ((crflags & DMA2D_IT_CAE) != 0U)
  219b50:	68bb      	ldr	r3, [r7, #8]
  219b52:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  219b56:	2b00      	cmp	r3, #0
  219b58:	d021      	beq.n	219b9e <HAL_DMA2D_IRQHandler+0x120>
    {
      /* Disable the CLUT access error interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CAE);
  219b5a:	687b      	ldr	r3, [r7, #4]
  219b5c:	681b      	ldr	r3, [r3, #0]
  219b5e:	687a      	ldr	r2, [r7, #4]
  219b60:	6812      	ldr	r2, [r2, #0]
  219b62:	6812      	ldr	r2, [r2, #0]
  219b64:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
  219b68:	601a      	str	r2, [r3, #0]

      /* Clear the CLUT access error flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE);
  219b6a:	687b      	ldr	r3, [r7, #4]
  219b6c:	681b      	ldr	r3, [r3, #0]
  219b6e:	2208      	movs	r2, #8
  219b70:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
  219b72:	687b      	ldr	r3, [r7, #4]
  219b74:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  219b76:	f043 0204 	orr.w	r2, r3, #4
  219b7a:	687b      	ldr	r3, [r7, #4]
  219b7c:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_ERROR;
  219b7e:	687b      	ldr	r3, [r7, #4]
  219b80:	2204      	movs	r2, #4
  219b82:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
  219b86:	687b      	ldr	r3, [r7, #4]
  219b88:	2200      	movs	r2, #0
  219b8a:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      if (hdma2d->XferErrorCallback != NULL)
  219b8e:	687b      	ldr	r3, [r7, #4]
  219b90:	69db      	ldr	r3, [r3, #28]
  219b92:	2b00      	cmp	r3, #0
  219b94:	d003      	beq.n	219b9e <HAL_DMA2D_IRQHandler+0x120>
      {
        /* Transfer error Callback */
        hdma2d->XferErrorCallback(hdma2d);
  219b96:	687b      	ldr	r3, [r7, #4]
  219b98:	69db      	ldr	r3, [r3, #28]
  219b9a:	6878      	ldr	r0, [r7, #4]
  219b9c:	4798      	blx	r3
      }
    }
  }
  /* Transfer watermark Interrupt management **********************************/
  if ((isrflags & DMA2D_FLAG_TW) != 0U)
  219b9e:	68fb      	ldr	r3, [r7, #12]
  219ba0:	f003 0304 	and.w	r3, r3, #4
  219ba4:	2b00      	cmp	r3, #0
  219ba6:	d013      	beq.n	219bd0 <HAL_DMA2D_IRQHandler+0x152>
  {
    if ((crflags & DMA2D_IT_TW) != 0U)
  219ba8:	68bb      	ldr	r3, [r7, #8]
  219baa:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  219bae:	2b00      	cmp	r3, #0
  219bb0:	d00e      	beq.n	219bd0 <HAL_DMA2D_IRQHandler+0x152>
    {
      /* Disable the transfer watermark interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TW);
  219bb2:	687b      	ldr	r3, [r7, #4]
  219bb4:	681b      	ldr	r3, [r3, #0]
  219bb6:	687a      	ldr	r2, [r7, #4]
  219bb8:	6812      	ldr	r2, [r2, #0]
  219bba:	6812      	ldr	r2, [r2, #0]
  219bbc:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
  219bc0:	601a      	str	r2, [r3, #0]

      /* Clear the transfer watermark flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TW);
  219bc2:	687b      	ldr	r3, [r7, #4]
  219bc4:	681b      	ldr	r3, [r3, #0]
  219bc6:	2204      	movs	r2, #4
  219bc8:	609a      	str	r2, [r3, #8]

      /* Transfer watermark Callback */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
      hdma2d->LineEventCallback(hdma2d);
#else
      HAL_DMA2D_LineEventCallback(hdma2d);
  219bca:	6878      	ldr	r0, [r7, #4]
  219bcc:	f000 f853 	bl	219c76 <HAL_DMA2D_LineEventCallback>
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */

    }
  }
  /* Transfer Complete Interrupt management ************************************/
  if ((isrflags & DMA2D_FLAG_TC) != 0U)
  219bd0:	68fb      	ldr	r3, [r7, #12]
  219bd2:	f003 0302 	and.w	r3, r3, #2
  219bd6:	2b00      	cmp	r3, #0
  219bd8:	d024      	beq.n	219c24 <HAL_DMA2D_IRQHandler+0x1a6>
  {
    if ((crflags & DMA2D_IT_TC) != 0U)
  219bda:	68bb      	ldr	r3, [r7, #8]
  219bdc:	f403 7300 	and.w	r3, r3, #512	; 0x200
  219be0:	2b00      	cmp	r3, #0
  219be2:	d01f      	beq.n	219c24 <HAL_DMA2D_IRQHandler+0x1a6>
    {
      /* Disable the transfer complete interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_TC);
  219be4:	687b      	ldr	r3, [r7, #4]
  219be6:	681b      	ldr	r3, [r3, #0]
  219be8:	687a      	ldr	r2, [r7, #4]
  219bea:	6812      	ldr	r2, [r2, #0]
  219bec:	6812      	ldr	r2, [r2, #0]
  219bee:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  219bf2:	601a      	str	r2, [r3, #0]

      /* Clear the transfer complete flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC);
  219bf4:	687b      	ldr	r3, [r7, #4]
  219bf6:	681b      	ldr	r3, [r3, #0]
  219bf8:	2202      	movs	r2, #2
  219bfa:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
  219bfc:	687b      	ldr	r3, [r7, #4]
  219bfe:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  219c00:	687b      	ldr	r3, [r7, #4]
  219c02:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_READY;
  219c04:	687b      	ldr	r3, [r7, #4]
  219c06:	2201      	movs	r2, #1
  219c08:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
  219c0c:	687b      	ldr	r3, [r7, #4]
  219c0e:	2200      	movs	r2, #0
  219c10:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      if (hdma2d->XferCpltCallback != NULL)
  219c14:	687b      	ldr	r3, [r7, #4]
  219c16:	699b      	ldr	r3, [r3, #24]
  219c18:	2b00      	cmp	r3, #0
  219c1a:	d003      	beq.n	219c24 <HAL_DMA2D_IRQHandler+0x1a6>
      {
        /* Transfer complete Callback */
        hdma2d->XferCpltCallback(hdma2d);
  219c1c:	687b      	ldr	r3, [r7, #4]
  219c1e:	699b      	ldr	r3, [r3, #24]
  219c20:	6878      	ldr	r0, [r7, #4]
  219c22:	4798      	blx	r3
      }
    }
  }
  /* CLUT Transfer Complete Interrupt management ******************************/
  if ((isrflags & DMA2D_FLAG_CTC) != 0U)
  219c24:	68fb      	ldr	r3, [r7, #12]
  219c26:	f003 0310 	and.w	r3, r3, #16
  219c2a:	2b00      	cmp	r3, #0
  219c2c:	d01f      	beq.n	219c6e <HAL_DMA2D_IRQHandler+0x1f0>
  {
    if ((crflags & DMA2D_IT_CTC) != 0U)
  219c2e:	68bb      	ldr	r3, [r7, #8]
  219c30:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  219c34:	2b00      	cmp	r3, #0
  219c36:	d01a      	beq.n	219c6e <HAL_DMA2D_IRQHandler+0x1f0>
    {
      /* Disable the CLUT transfer complete interrupt */
      __HAL_DMA2D_DISABLE_IT(hdma2d, DMA2D_IT_CTC);
  219c38:	687b      	ldr	r3, [r7, #4]
  219c3a:	681b      	ldr	r3, [r3, #0]
  219c3c:	687a      	ldr	r2, [r7, #4]
  219c3e:	6812      	ldr	r2, [r2, #0]
  219c40:	6812      	ldr	r2, [r2, #0]
  219c42:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
  219c46:	601a      	str	r2, [r3, #0]

      /* Clear the CLUT transfer complete flag */
      __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CTC);
  219c48:	687b      	ldr	r3, [r7, #4]
  219c4a:	681b      	ldr	r3, [r3, #0]
  219c4c:	2210      	movs	r2, #16
  219c4e:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma2d->ErrorCode |= HAL_DMA2D_ERROR_NONE;
  219c50:	687b      	ldr	r3, [r7, #4]
  219c52:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  219c54:	687b      	ldr	r3, [r7, #4]
  219c56:	655a      	str	r2, [r3, #84]	; 0x54

      /* Change DMA2D state */
      hdma2d->State = HAL_DMA2D_STATE_READY;
  219c58:	687b      	ldr	r3, [r7, #4]
  219c5a:	2201      	movs	r2, #1
  219c5c:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

      /* Process Unlocked */
      __HAL_UNLOCK(hdma2d);
  219c60:	687b      	ldr	r3, [r7, #4]
  219c62:	2200      	movs	r2, #0
  219c64:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

      /* CLUT Transfer complete Callback */
#if (USE_HAL_DMA2D_REGISTER_CALLBACKS == 1)
      hdma2d->CLUTLoadingCpltCallback(hdma2d);
#else
      HAL_DMA2D_CLUTLoadingCpltCallback(hdma2d);
  219c68:	6878      	ldr	r0, [r7, #4]
  219c6a:	f000 f80e 	bl	219c8a <HAL_DMA2D_CLUTLoadingCpltCallback>
#endif /* USE_HAL_DMA2D_REGISTER_CALLBACKS */
    }
  }

}
  219c6e:	bf00      	nop
  219c70:	3710      	adds	r7, #16
  219c72:	46bd      	mov	sp, r7
  219c74:	bd80      	pop	{r7, pc}

00219c76 <HAL_DMA2D_LineEventCallback>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_LineEventCallback(DMA2D_HandleTypeDef *hdma2d)
{
  219c76:	b480      	push	{r7}
  219c78:	b083      	sub	sp, #12
  219c7a:	af00      	add	r7, sp, #0
  219c7c:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_LineEventCallback can be implemented in the user file.
   */
}
  219c7e:	bf00      	nop
  219c80:	370c      	adds	r7, #12
  219c82:	46bd      	mov	sp, r7
  219c84:	f85d 7b04 	ldr.w	r7, [sp], #4
  219c88:	4770      	bx	lr

00219c8a <HAL_DMA2D_CLUTLoadingCpltCallback>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval None
  */
__weak void HAL_DMA2D_CLUTLoadingCpltCallback(DMA2D_HandleTypeDef *hdma2d)
{
  219c8a:	b480      	push	{r7}
  219c8c:	b083      	sub	sp, #12
  219c8e:	af00      	add	r7, sp, #0
  219c90:	6078      	str	r0, [r7, #4]
  UNUSED(hdma2d);

  /* NOTE : This function should not be modified; when the callback is needed,
            the HAL_DMA2D_CLUTLoadingCpltCallback can be implemented in the user file.
   */
}
  219c92:	bf00      	nop
  219c94:	370c      	adds	r7, #12
  219c96:	46bd      	mov	sp, r7
  219c98:	f85d 7b04 	ldr.w	r7, [sp], #4
  219c9c:	4770      	bx	lr
	...

00219ca0 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
  219ca0:	b480      	push	{r7}
  219ca2:	b087      	sub	sp, #28
  219ca4:	af00      	add	r7, sp, #0
  219ca6:	6078      	str	r0, [r7, #4]
  219ca8:	6039      	str	r1, [r7, #0]
  uint32_t regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if (hdma2d->Init.Mode != DMA2D_R2M)
  219caa:	687b      	ldr	r3, [r7, #4]
  219cac:	685b      	ldr	r3, [r3, #4]
  219cae:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */

  /* Process locked */
  __HAL_LOCK(hdma2d);
  219cb2:	687b      	ldr	r3, [r7, #4]
  219cb4:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
  219cb8:	2b01      	cmp	r3, #1
  219cba:	d101      	bne.n	219cc0 <HAL_DMA2D_ConfigLayer+0x20>
  219cbc:	2302      	movs	r3, #2
  219cbe:	e082      	b.n	219dc6 <HAL_DMA2D_ConfigLayer+0x126>
  219cc0:	687b      	ldr	r3, [r7, #4]
  219cc2:	2201      	movs	r2, #1
  219cc4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
  219cc8:	687b      	ldr	r3, [r7, #4]
  219cca:	2202      	movs	r2, #2
  219ccc:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
  219cd0:	683a      	ldr	r2, [r7, #0]
  219cd2:	4613      	mov	r3, r2
  219cd4:	005b      	lsls	r3, r3, #1
  219cd6:	4413      	add	r3, r2
  219cd8:	00db      	lsls	r3, r3, #3
  219cda:	3320      	adds	r3, #32
  219cdc:	687a      	ldr	r2, [r7, #4]
  219cde:	4413      	add	r3, r2
  219ce0:	613b      	str	r3, [r7, #16]

  /* Prepare the value to be written to the BGPFCCR or FGPFCCR register */
#if defined (DMA2D_ALPHA_INV_RB_SWAP_SUPPORT)
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
  219ce2:	693b      	ldr	r3, [r7, #16]
  219ce4:	685a      	ldr	r2, [r3, #4]
  219ce6:	693b      	ldr	r3, [r7, #16]
  219ce8:	689b      	ldr	r3, [r3, #8]
  219cea:	041b      	lsls	r3, r3, #16
  219cec:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
  219cee:	693b      	ldr	r3, [r7, #16]
  219cf0:	691b      	ldr	r3, [r3, #16]
  219cf2:	051b      	lsls	r3, r3, #20
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
  219cf4:	431a      	orrs	r2, r3
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
  219cf6:	693b      	ldr	r3, [r7, #16]
  219cf8:	695b      	ldr	r3, [r3, #20]
  219cfa:	055b      	lsls	r3, r3, #21
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) | \
  219cfc:	4313      	orrs	r3, r2
  219cfe:	617b      	str	r3, [r7, #20]
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
  219d00:	4b34      	ldr	r3, [pc, #208]	; (219dd4 <HAL_DMA2D_ConfigLayer+0x134>)
  219d02:	60fb      	str	r3, [r7, #12]
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
  regMask  = DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA;
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
  219d04:	693b      	ldr	r3, [r7, #16]
  219d06:	685b      	ldr	r3, [r3, #4]
  219d08:	2b0a      	cmp	r3, #10
  219d0a:	d003      	beq.n	219d14 <HAL_DMA2D_ConfigLayer+0x74>
  219d0c:	693b      	ldr	r3, [r7, #16]
  219d0e:	685b      	ldr	r3, [r3, #4]
  219d10:	2b09      	cmp	r3, #9
  219d12:	d107      	bne.n	219d24 <HAL_DMA2D_ConfigLayer+0x84>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
  219d14:	693b      	ldr	r3, [r7, #16]
  219d16:	68db      	ldr	r3, [r3, #12]
  219d18:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  219d1c:	697a      	ldr	r2, [r7, #20]
  219d1e:	4313      	orrs	r3, r2
  219d20:	617b      	str	r3, [r7, #20]
  219d22:	e005      	b.n	219d30 <HAL_DMA2D_ConfigLayer+0x90>
  }
  else
  {
    regValue |= (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
  219d24:	693b      	ldr	r3, [r7, #16]
  219d26:	68db      	ldr	r3, [r3, #12]
  219d28:	061b      	lsls	r3, r3, #24
  219d2a:	697a      	ldr	r2, [r7, #20]
  219d2c:	4313      	orrs	r3, r2
  219d2e:	617b      	str	r3, [r7, #20]
  }

  /* Configure the background DMA2D layer */
  if (LayerIdx == DMA2D_BACKGROUND_LAYER)
  219d30:	683b      	ldr	r3, [r7, #0]
  219d32:	2b00      	cmp	r3, #0
  219d34:	d11f      	bne.n	219d76 <HAL_DMA2D_ConfigLayer+0xd6>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
  219d36:	687b      	ldr	r3, [r7, #4]
  219d38:	681b      	ldr	r3, [r3, #0]
  219d3a:	687a      	ldr	r2, [r7, #4]
  219d3c:	6812      	ldr	r2, [r2, #0]
  219d3e:	6a51      	ldr	r1, [r2, #36]	; 0x24
  219d40:	68fa      	ldr	r2, [r7, #12]
  219d42:	43d2      	mvns	r2, r2
  219d44:	4011      	ands	r1, r2
  219d46:	697a      	ldr	r2, [r7, #20]
  219d48:	430a      	orrs	r2, r1
  219d4a:	625a      	str	r2, [r3, #36]	; 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
  219d4c:	687b      	ldr	r3, [r7, #4]
  219d4e:	681b      	ldr	r3, [r3, #0]
  219d50:	693a      	ldr	r2, [r7, #16]
  219d52:	6812      	ldr	r2, [r2, #0]
  219d54:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
  219d56:	693b      	ldr	r3, [r7, #16]
  219d58:	685b      	ldr	r3, [r3, #4]
  219d5a:	2b0a      	cmp	r3, #10
  219d5c:	d003      	beq.n	219d66 <HAL_DMA2D_ConfigLayer+0xc6>
  219d5e:	693b      	ldr	r3, [r7, #16]
  219d60:	685b      	ldr	r3, [r3, #4]
  219d62:	2b09      	cmp	r3, #9
  219d64:	d126      	bne.n	219db4 <HAL_DMA2D_ConfigLayer+0x114>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE | DMA2D_BGCOLR_GREEN | \
  219d66:	687b      	ldr	r3, [r7, #4]
  219d68:	681b      	ldr	r3, [r3, #0]
  219d6a:	693a      	ldr	r2, [r7, #16]
  219d6c:	68d2      	ldr	r2, [r2, #12]
  219d6e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  219d72:	629a      	str	r2, [r3, #40]	; 0x28
  219d74:	e01e      	b.n	219db4 <HAL_DMA2D_ConfigLayer+0x114>
  else
  {


    /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
  219d76:	687b      	ldr	r3, [r7, #4]
  219d78:	681b      	ldr	r3, [r3, #0]
  219d7a:	687a      	ldr	r2, [r7, #4]
  219d7c:	6812      	ldr	r2, [r2, #0]
  219d7e:	69d1      	ldr	r1, [r2, #28]
  219d80:	68fa      	ldr	r2, [r7, #12]
  219d82:	43d2      	mvns	r2, r2
  219d84:	4011      	ands	r1, r2
  219d86:	697a      	ldr	r2, [r7, #20]
  219d88:	430a      	orrs	r2, r1
  219d8a:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
  219d8c:	687b      	ldr	r3, [r7, #4]
  219d8e:	681b      	ldr	r3, [r3, #0]
  219d90:	693a      	ldr	r2, [r7, #16]
  219d92:	6812      	ldr	r2, [r2, #0]
  219d94:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
  219d96:	693b      	ldr	r3, [r7, #16]
  219d98:	685b      	ldr	r3, [r3, #4]
  219d9a:	2b0a      	cmp	r3, #10
  219d9c:	d003      	beq.n	219da6 <HAL_DMA2D_ConfigLayer+0x106>
  219d9e:	693b      	ldr	r3, [r7, #16]
  219da0:	685b      	ldr	r3, [r3, #4]
  219da2:	2b09      	cmp	r3, #9
  219da4:	d106      	bne.n	219db4 <HAL_DMA2D_ConfigLayer+0x114>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE | DMA2D_FGCOLR_GREEN | \
  219da6:	687b      	ldr	r3, [r7, #4]
  219da8:	681b      	ldr	r3, [r3, #0]
  219daa:	693a      	ldr	r2, [r7, #16]
  219dac:	68d2      	ldr	r2, [r2, #12]
  219dae:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  219db2:	621a      	str	r2, [r3, #32]
                                                                   DMA2D_FGCOLR_RED));
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
  219db4:	687b      	ldr	r3, [r7, #4]
  219db6:	2201      	movs	r2, #1
  219db8:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
  219dbc:	687b      	ldr	r3, [r7, #4]
  219dbe:	2200      	movs	r2, #0
  219dc0:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50

  return HAL_OK;
  219dc4:	2300      	movs	r3, #0
}
  219dc6:	4618      	mov	r0, r3
  219dc8:	371c      	adds	r7, #28
  219dca:	46bd      	mov	sp, r7
  219dcc:	f85d 7b04 	ldr.w	r7, [sp], #4
  219dd0:	4770      	bx	lr
  219dd2:	bf00      	nop
  219dd4:	ff33000f 	.word	0xff33000f

00219dd8 <HAL_DMA2D_GetState>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL state
  */
HAL_DMA2D_StateTypeDef HAL_DMA2D_GetState(DMA2D_HandleTypeDef *hdma2d)
{
  219dd8:	b480      	push	{r7}
  219dda:	b083      	sub	sp, #12
  219ddc:	af00      	add	r7, sp, #0
  219dde:	6078      	str	r0, [r7, #4]
  return hdma2d->State;
  219de0:	687b      	ldr	r3, [r7, #4]
  219de2:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
  219de6:	b2db      	uxtb	r3, r3
}
  219de8:	4618      	mov	r0, r3
  219dea:	370c      	adds	r7, #12
  219dec:	46bd      	mov	sp, r7
  219dee:	f85d 7b04 	ldr.w	r7, [sp], #4
  219df2:	4770      	bx	lr

00219df4 <DMA2D_SetConfig>:
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width,
                            uint32_t Height)
{
  219df4:	b480      	push	{r7}
  219df6:	b08b      	sub	sp, #44	; 0x2c
  219df8:	af00      	add	r7, sp, #0
  219dfa:	60f8      	str	r0, [r7, #12]
  219dfc:	60b9      	str	r1, [r7, #8]
  219dfe:	607a      	str	r2, [r7, #4]
  219e00:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL | DMA2D_NLR_PL), (Height | (Width << DMA2D_NLR_PL_Pos)));
  219e02:	68fb      	ldr	r3, [r7, #12]
  219e04:	681b      	ldr	r3, [r3, #0]
  219e06:	68fa      	ldr	r2, [r7, #12]
  219e08:	6812      	ldr	r2, [r2, #0]
  219e0a:	6c52      	ldr	r2, [r2, #68]	; 0x44
  219e0c:	f002 4140 	and.w	r1, r2, #3221225472	; 0xc0000000
  219e10:	683a      	ldr	r2, [r7, #0]
  219e12:	0410      	lsls	r0, r2, #16
  219e14:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  219e16:	4302      	orrs	r2, r0
  219e18:	430a      	orrs	r2, r1
  219e1a:	645a      	str	r2, [r3, #68]	; 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
  219e1c:	68fb      	ldr	r3, [r7, #12]
  219e1e:	681b      	ldr	r3, [r3, #0]
  219e20:	687a      	ldr	r2, [r7, #4]
  219e22:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
  219e24:	68fb      	ldr	r3, [r7, #12]
  219e26:	685b      	ldr	r3, [r3, #4]
  219e28:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
  219e2c:	d174      	bne.n	219f18 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
  219e2e:	68bb      	ldr	r3, [r7, #8]
  219e30:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
  219e34:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
  219e36:	68bb      	ldr	r3, [r7, #8]
  219e38:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  219e3c:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
  219e3e:	68bb      	ldr	r3, [r7, #8]
  219e40:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
  219e44:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
  219e46:	68bb      	ldr	r3, [r7, #8]
  219e48:	b2db      	uxtb	r3, r3
  219e4a:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
  219e4c:	68fb      	ldr	r3, [r7, #12]
  219e4e:	689b      	ldr	r3, [r3, #8]
  219e50:	2b00      	cmp	r3, #0
  219e52:	d108      	bne.n	219e66 <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1 | tmp4);
  219e54:	69ba      	ldr	r2, [r7, #24]
  219e56:	69fb      	ldr	r3, [r7, #28]
  219e58:	431a      	orrs	r2, r3
  219e5a:	6a3b      	ldr	r3, [r7, #32]
  219e5c:	431a      	orrs	r2, r3
  219e5e:	697b      	ldr	r3, [r7, #20]
  219e60:	4313      	orrs	r3, r2
  219e62:	627b      	str	r3, [r7, #36]	; 0x24
  219e64:	e053      	b.n	219f0e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
  219e66:	68fb      	ldr	r3, [r7, #12]
  219e68:	689b      	ldr	r3, [r3, #8]
  219e6a:	2b01      	cmp	r3, #1
  219e6c:	d106      	bne.n	219e7c <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
  219e6e:	69ba      	ldr	r2, [r7, #24]
  219e70:	69fb      	ldr	r3, [r7, #28]
  219e72:	431a      	orrs	r2, r3
  219e74:	697b      	ldr	r3, [r7, #20]
  219e76:	4313      	orrs	r3, r2
  219e78:	627b      	str	r3, [r7, #36]	; 0x24
  219e7a:	e048      	b.n	219f0e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
  219e7c:	68fb      	ldr	r3, [r7, #12]
  219e7e:	689b      	ldr	r3, [r3, #8]
  219e80:	2b02      	cmp	r3, #2
  219e82:	d111      	bne.n	219ea8 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
  219e84:	69fb      	ldr	r3, [r7, #28]
  219e86:	0cdb      	lsrs	r3, r3, #19
  219e88:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
  219e8a:	69bb      	ldr	r3, [r7, #24]
  219e8c:	0a9b      	lsrs	r3, r3, #10
  219e8e:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
  219e90:	697b      	ldr	r3, [r7, #20]
  219e92:	08db      	lsrs	r3, r3, #3
  219e94:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
  219e96:	69bb      	ldr	r3, [r7, #24]
  219e98:	015a      	lsls	r2, r3, #5
  219e9a:	69fb      	ldr	r3, [r7, #28]
  219e9c:	02db      	lsls	r3, r3, #11
  219e9e:	431a      	orrs	r2, r3
  219ea0:	697b      	ldr	r3, [r7, #20]
  219ea2:	4313      	orrs	r3, r2
  219ea4:	627b      	str	r3, [r7, #36]	; 0x24
  219ea6:	e032      	b.n	219f0e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
  219ea8:	68fb      	ldr	r3, [r7, #12]
  219eaa:	689b      	ldr	r3, [r3, #8]
  219eac:	2b03      	cmp	r3, #3
  219eae:	d117      	bne.n	219ee0 <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
  219eb0:	6a3b      	ldr	r3, [r7, #32]
  219eb2:	0fdb      	lsrs	r3, r3, #31
  219eb4:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
  219eb6:	69fb      	ldr	r3, [r7, #28]
  219eb8:	0cdb      	lsrs	r3, r3, #19
  219eba:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
  219ebc:	69bb      	ldr	r3, [r7, #24]
  219ebe:	0adb      	lsrs	r3, r3, #11
  219ec0:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U);
  219ec2:	697b      	ldr	r3, [r7, #20]
  219ec4:	08db      	lsrs	r3, r3, #3
  219ec6:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
  219ec8:	69bb      	ldr	r3, [r7, #24]
  219eca:	015a      	lsls	r2, r3, #5
  219ecc:	69fb      	ldr	r3, [r7, #28]
  219ece:	029b      	lsls	r3, r3, #10
  219ed0:	431a      	orrs	r2, r3
  219ed2:	6a3b      	ldr	r3, [r7, #32]
  219ed4:	03db      	lsls	r3, r3, #15
  219ed6:	431a      	orrs	r2, r3
  219ed8:	697b      	ldr	r3, [r7, #20]
  219eda:	4313      	orrs	r3, r2
  219edc:	627b      	str	r3, [r7, #36]	; 0x24
  219ede:	e016      	b.n	219f0e <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
  219ee0:	6a3b      	ldr	r3, [r7, #32]
  219ee2:	0f1b      	lsrs	r3, r3, #28
  219ee4:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
  219ee6:	69fb      	ldr	r3, [r7, #28]
  219ee8:	0d1b      	lsrs	r3, r3, #20
  219eea:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
  219eec:	69bb      	ldr	r3, [r7, #24]
  219eee:	0b1b      	lsrs	r3, r3, #12
  219ef0:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U);
  219ef2:	697b      	ldr	r3, [r7, #20]
  219ef4:	091b      	lsrs	r3, r3, #4
  219ef6:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
  219ef8:	69bb      	ldr	r3, [r7, #24]
  219efa:	011a      	lsls	r2, r3, #4
  219efc:	69fb      	ldr	r3, [r7, #28]
  219efe:	021b      	lsls	r3, r3, #8
  219f00:	431a      	orrs	r2, r3
  219f02:	6a3b      	ldr	r3, [r7, #32]
  219f04:	031b      	lsls	r3, r3, #12
  219f06:	431a      	orrs	r2, r3
  219f08:	697b      	ldr	r3, [r7, #20]
  219f0a:	4313      	orrs	r3, r2
  219f0c:	627b      	str	r3, [r7, #36]	; 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
  219f0e:	68fb      	ldr	r3, [r7, #12]
  219f10:	681b      	ldr	r3, [r3, #0]
  219f12:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  219f14:	639a      	str	r2, [r3, #56]	; 0x38
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
  219f16:	e003      	b.n	219f20 <DMA2D_SetConfig+0x12c>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  219f18:	68fb      	ldr	r3, [r7, #12]
  219f1a:	681b      	ldr	r3, [r3, #0]
  219f1c:	68ba      	ldr	r2, [r7, #8]
  219f1e:	60da      	str	r2, [r3, #12]
}
  219f20:	bf00      	nop
  219f22:	372c      	adds	r7, #44	; 0x2c
  219f24:	46bd      	mov	sp, r7
  219f26:	f85d 7b04 	ldr.w	r7, [sp], #4
  219f2a:	4770      	bx	lr

00219f2c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
  219f2c:	b480      	push	{r7}
  219f2e:	b089      	sub	sp, #36	; 0x24
  219f30:	af00      	add	r7, sp, #0
  219f32:	6078      	str	r0, [r7, #4]
  219f34:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
  219f36:	2300      	movs	r3, #0
  219f38:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
  219f3a:	2300      	movs	r3, #0
  219f3c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
  219f3e:	2300      	movs	r3, #0
  219f40:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
  219f42:	2300      	movs	r3, #0
  219f44:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
  219f46:	2300      	movs	r3, #0
  219f48:	61fb      	str	r3, [r7, #28]
  219f4a:	e175      	b.n	21a238 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
  219f4c:	2201      	movs	r2, #1
  219f4e:	69fb      	ldr	r3, [r7, #28]
  219f50:	fa02 f303 	lsl.w	r3, r2, r3
  219f54:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
  219f56:	683b      	ldr	r3, [r7, #0]
  219f58:	681a      	ldr	r2, [r3, #0]
  219f5a:	697b      	ldr	r3, [r7, #20]
  219f5c:	4013      	ands	r3, r2
  219f5e:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
  219f60:	693a      	ldr	r2, [r7, #16]
  219f62:	697b      	ldr	r3, [r7, #20]
  219f64:	429a      	cmp	r2, r3
  219f66:	f040 8164 	bne.w	21a232 <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  219f6a:	683b      	ldr	r3, [r7, #0]
  219f6c:	685b      	ldr	r3, [r3, #4]
  219f6e:	2b01      	cmp	r3, #1
  219f70:	d00b      	beq.n	219f8a <HAL_GPIO_Init+0x5e>
  219f72:	683b      	ldr	r3, [r7, #0]
  219f74:	685b      	ldr	r3, [r3, #4]
  219f76:	2b02      	cmp	r3, #2
  219f78:	d007      	beq.n	219f8a <HAL_GPIO_Init+0x5e>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  219f7a:	683b      	ldr	r3, [r7, #0]
  219f7c:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
  219f7e:	2b11      	cmp	r3, #17
  219f80:	d003      	beq.n	219f8a <HAL_GPIO_Init+0x5e>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  219f82:	683b      	ldr	r3, [r7, #0]
  219f84:	685b      	ldr	r3, [r3, #4]
  219f86:	2b12      	cmp	r3, #18
  219f88:	d130      	bne.n	219fec <HAL_GPIO_Init+0xc0>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
  219f8a:	687b      	ldr	r3, [r7, #4]
  219f8c:	689b      	ldr	r3, [r3, #8]
  219f8e:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
  219f90:	69fb      	ldr	r3, [r7, #28]
  219f92:	005b      	lsls	r3, r3, #1
  219f94:	2203      	movs	r2, #3
  219f96:	fa02 f303 	lsl.w	r3, r2, r3
  219f9a:	43db      	mvns	r3, r3
  219f9c:	69ba      	ldr	r2, [r7, #24]
  219f9e:	4013      	ands	r3, r2
  219fa0:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
  219fa2:	683b      	ldr	r3, [r7, #0]
  219fa4:	68da      	ldr	r2, [r3, #12]
  219fa6:	69fb      	ldr	r3, [r7, #28]
  219fa8:	005b      	lsls	r3, r3, #1
  219faa:	fa02 f303 	lsl.w	r3, r2, r3
  219fae:	69ba      	ldr	r2, [r7, #24]
  219fb0:	4313      	orrs	r3, r2
  219fb2:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
  219fb4:	687b      	ldr	r3, [r7, #4]
  219fb6:	69ba      	ldr	r2, [r7, #24]
  219fb8:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
  219fba:	687b      	ldr	r3, [r7, #4]
  219fbc:	685b      	ldr	r3, [r3, #4]
  219fbe:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
  219fc0:	2201      	movs	r2, #1
  219fc2:	69fb      	ldr	r3, [r7, #28]
  219fc4:	fa02 f303 	lsl.w	r3, r2, r3
  219fc8:	43db      	mvns	r3, r3
  219fca:	69ba      	ldr	r2, [r7, #24]
  219fcc:	4013      	ands	r3, r2
  219fce:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
  219fd0:	683b      	ldr	r3, [r7, #0]
  219fd2:	685b      	ldr	r3, [r3, #4]
  219fd4:	091b      	lsrs	r3, r3, #4
  219fd6:	f003 0201 	and.w	r2, r3, #1
  219fda:	69fb      	ldr	r3, [r7, #28]
  219fdc:	fa02 f303 	lsl.w	r3, r2, r3
  219fe0:	69ba      	ldr	r2, [r7, #24]
  219fe2:	4313      	orrs	r3, r2
  219fe4:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
  219fe6:	687b      	ldr	r3, [r7, #4]
  219fe8:	69ba      	ldr	r2, [r7, #24]
  219fea:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
  219fec:	687b      	ldr	r3, [r7, #4]
  219fee:	68db      	ldr	r3, [r3, #12]
  219ff0:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
  219ff2:	69fb      	ldr	r3, [r7, #28]
  219ff4:	005b      	lsls	r3, r3, #1
  219ff6:	2203      	movs	r2, #3
  219ff8:	fa02 f303 	lsl.w	r3, r2, r3
  219ffc:	43db      	mvns	r3, r3
  219ffe:	69ba      	ldr	r2, [r7, #24]
  21a000:	4013      	ands	r3, r2
  21a002:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
  21a004:	683b      	ldr	r3, [r7, #0]
  21a006:	689a      	ldr	r2, [r3, #8]
  21a008:	69fb      	ldr	r3, [r7, #28]
  21a00a:	005b      	lsls	r3, r3, #1
  21a00c:	fa02 f303 	lsl.w	r3, r2, r3
  21a010:	69ba      	ldr	r2, [r7, #24]
  21a012:	4313      	orrs	r3, r2
  21a014:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
  21a016:	687b      	ldr	r3, [r7, #4]
  21a018:	69ba      	ldr	r2, [r7, #24]
  21a01a:	60da      	str	r2, [r3, #12]

      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
  21a01c:	683b      	ldr	r3, [r7, #0]
  21a01e:	685b      	ldr	r3, [r3, #4]
  21a020:	2b02      	cmp	r3, #2
  21a022:	d003      	beq.n	21a02c <HAL_GPIO_Init+0x100>
  21a024:	683b      	ldr	r3, [r7, #0]
  21a026:	685b      	ldr	r3, [r3, #4]
  21a028:	2b12      	cmp	r3, #18
  21a02a:	d123      	bne.n	21a074 <HAL_GPIO_Init+0x148>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
  21a02c:	69fb      	ldr	r3, [r7, #28]
  21a02e:	08da      	lsrs	r2, r3, #3
  21a030:	687b      	ldr	r3, [r7, #4]
  21a032:	3208      	adds	r2, #8
  21a034:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  21a038:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
  21a03a:	69fb      	ldr	r3, [r7, #28]
  21a03c:	f003 0307 	and.w	r3, r3, #7
  21a040:	009b      	lsls	r3, r3, #2
  21a042:	220f      	movs	r2, #15
  21a044:	fa02 f303 	lsl.w	r3, r2, r3
  21a048:	43db      	mvns	r3, r3
  21a04a:	69ba      	ldr	r2, [r7, #24]
  21a04c:	4013      	ands	r3, r2
  21a04e:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
  21a050:	683b      	ldr	r3, [r7, #0]
  21a052:	691a      	ldr	r2, [r3, #16]
  21a054:	69fb      	ldr	r3, [r7, #28]
  21a056:	f003 0307 	and.w	r3, r3, #7
  21a05a:	009b      	lsls	r3, r3, #2
  21a05c:	fa02 f303 	lsl.w	r3, r2, r3
  21a060:	69ba      	ldr	r2, [r7, #24]
  21a062:	4313      	orrs	r3, r2
  21a064:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
  21a066:	69fb      	ldr	r3, [r7, #28]
  21a068:	08da      	lsrs	r2, r3, #3
  21a06a:	687b      	ldr	r3, [r7, #4]
  21a06c:	3208      	adds	r2, #8
  21a06e:	69b9      	ldr	r1, [r7, #24]
  21a070:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }
      
      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
  21a074:	687b      	ldr	r3, [r7, #4]
  21a076:	681b      	ldr	r3, [r3, #0]
  21a078:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
  21a07a:	69fb      	ldr	r3, [r7, #28]
  21a07c:	005b      	lsls	r3, r3, #1
  21a07e:	2203      	movs	r2, #3
  21a080:	fa02 f303 	lsl.w	r3, r2, r3
  21a084:	43db      	mvns	r3, r3
  21a086:	69ba      	ldr	r2, [r7, #24]
  21a088:	4013      	ands	r3, r2
  21a08a:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
  21a08c:	683b      	ldr	r3, [r7, #0]
  21a08e:	685b      	ldr	r3, [r3, #4]
  21a090:	f003 0203 	and.w	r2, r3, #3
  21a094:	69fb      	ldr	r3, [r7, #28]
  21a096:	005b      	lsls	r3, r3, #1
  21a098:	fa02 f303 	lsl.w	r3, r2, r3
  21a09c:	69ba      	ldr	r2, [r7, #24]
  21a09e:	4313      	orrs	r3, r2
  21a0a0:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
  21a0a2:	687b      	ldr	r3, [r7, #4]
  21a0a4:	69ba      	ldr	r2, [r7, #24]
  21a0a6:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
  21a0a8:	683b      	ldr	r3, [r7, #0]
  21a0aa:	685b      	ldr	r3, [r3, #4]
  21a0ac:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21a0b0:	2b00      	cmp	r3, #0
  21a0b2:	f000 80be 	beq.w	21a232 <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
  21a0b6:	4a65      	ldr	r2, [pc, #404]	; (21a24c <HAL_GPIO_Init+0x320>)
  21a0b8:	4b64      	ldr	r3, [pc, #400]	; (21a24c <HAL_GPIO_Init+0x320>)
  21a0ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21a0bc:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  21a0c0:	6453      	str	r3, [r2, #68]	; 0x44
  21a0c2:	4b62      	ldr	r3, [pc, #392]	; (21a24c <HAL_GPIO_Init+0x320>)
  21a0c4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21a0c6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  21a0ca:	60fb      	str	r3, [r7, #12]
  21a0cc:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
  21a0ce:	4a60      	ldr	r2, [pc, #384]	; (21a250 <HAL_GPIO_Init+0x324>)
  21a0d0:	69fb      	ldr	r3, [r7, #28]
  21a0d2:	089b      	lsrs	r3, r3, #2
  21a0d4:	3302      	adds	r3, #2
  21a0d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  21a0da:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
  21a0dc:	69fb      	ldr	r3, [r7, #28]
  21a0de:	f003 0303 	and.w	r3, r3, #3
  21a0e2:	009b      	lsls	r3, r3, #2
  21a0e4:	220f      	movs	r2, #15
  21a0e6:	fa02 f303 	lsl.w	r3, r2, r3
  21a0ea:	43db      	mvns	r3, r3
  21a0ec:	69ba      	ldr	r2, [r7, #24]
  21a0ee:	4013      	ands	r3, r2
  21a0f0:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
  21a0f2:	687b      	ldr	r3, [r7, #4]
  21a0f4:	4a57      	ldr	r2, [pc, #348]	; (21a254 <HAL_GPIO_Init+0x328>)
  21a0f6:	4293      	cmp	r3, r2
  21a0f8:	d037      	beq.n	21a16a <HAL_GPIO_Init+0x23e>
  21a0fa:	687b      	ldr	r3, [r7, #4]
  21a0fc:	4a56      	ldr	r2, [pc, #344]	; (21a258 <HAL_GPIO_Init+0x32c>)
  21a0fe:	4293      	cmp	r3, r2
  21a100:	d031      	beq.n	21a166 <HAL_GPIO_Init+0x23a>
  21a102:	687b      	ldr	r3, [r7, #4]
  21a104:	4a55      	ldr	r2, [pc, #340]	; (21a25c <HAL_GPIO_Init+0x330>)
  21a106:	4293      	cmp	r3, r2
  21a108:	d02b      	beq.n	21a162 <HAL_GPIO_Init+0x236>
  21a10a:	687b      	ldr	r3, [r7, #4]
  21a10c:	4a54      	ldr	r2, [pc, #336]	; (21a260 <HAL_GPIO_Init+0x334>)
  21a10e:	4293      	cmp	r3, r2
  21a110:	d025      	beq.n	21a15e <HAL_GPIO_Init+0x232>
  21a112:	687b      	ldr	r3, [r7, #4]
  21a114:	4a53      	ldr	r2, [pc, #332]	; (21a264 <HAL_GPIO_Init+0x338>)
  21a116:	4293      	cmp	r3, r2
  21a118:	d01f      	beq.n	21a15a <HAL_GPIO_Init+0x22e>
  21a11a:	687b      	ldr	r3, [r7, #4]
  21a11c:	4a52      	ldr	r2, [pc, #328]	; (21a268 <HAL_GPIO_Init+0x33c>)
  21a11e:	4293      	cmp	r3, r2
  21a120:	d019      	beq.n	21a156 <HAL_GPIO_Init+0x22a>
  21a122:	687b      	ldr	r3, [r7, #4]
  21a124:	4a51      	ldr	r2, [pc, #324]	; (21a26c <HAL_GPIO_Init+0x340>)
  21a126:	4293      	cmp	r3, r2
  21a128:	d013      	beq.n	21a152 <HAL_GPIO_Init+0x226>
  21a12a:	687b      	ldr	r3, [r7, #4]
  21a12c:	4a50      	ldr	r2, [pc, #320]	; (21a270 <HAL_GPIO_Init+0x344>)
  21a12e:	4293      	cmp	r3, r2
  21a130:	d00d      	beq.n	21a14e <HAL_GPIO_Init+0x222>
  21a132:	687b      	ldr	r3, [r7, #4]
  21a134:	4a4f      	ldr	r2, [pc, #316]	; (21a274 <HAL_GPIO_Init+0x348>)
  21a136:	4293      	cmp	r3, r2
  21a138:	d007      	beq.n	21a14a <HAL_GPIO_Init+0x21e>
  21a13a:	687b      	ldr	r3, [r7, #4]
  21a13c:	4a4e      	ldr	r2, [pc, #312]	; (21a278 <HAL_GPIO_Init+0x34c>)
  21a13e:	4293      	cmp	r3, r2
  21a140:	d101      	bne.n	21a146 <HAL_GPIO_Init+0x21a>
  21a142:	2309      	movs	r3, #9
  21a144:	e012      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a146:	230a      	movs	r3, #10
  21a148:	e010      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a14a:	2308      	movs	r3, #8
  21a14c:	e00e      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a14e:	2307      	movs	r3, #7
  21a150:	e00c      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a152:	2306      	movs	r3, #6
  21a154:	e00a      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a156:	2305      	movs	r3, #5
  21a158:	e008      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a15a:	2304      	movs	r3, #4
  21a15c:	e006      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a15e:	2303      	movs	r3, #3
  21a160:	e004      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a162:	2302      	movs	r3, #2
  21a164:	e002      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a166:	2301      	movs	r3, #1
  21a168:	e000      	b.n	21a16c <HAL_GPIO_Init+0x240>
  21a16a:	2300      	movs	r3, #0
  21a16c:	69fa      	ldr	r2, [r7, #28]
  21a16e:	f002 0203 	and.w	r2, r2, #3
  21a172:	0092      	lsls	r2, r2, #2
  21a174:	4093      	lsls	r3, r2
  21a176:	69ba      	ldr	r2, [r7, #24]
  21a178:	4313      	orrs	r3, r2
  21a17a:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
  21a17c:	4934      	ldr	r1, [pc, #208]	; (21a250 <HAL_GPIO_Init+0x324>)
  21a17e:	69fb      	ldr	r3, [r7, #28]
  21a180:	089b      	lsrs	r3, r3, #2
  21a182:	3302      	adds	r3, #2
  21a184:	69ba      	ldr	r2, [r7, #24]
  21a186:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
  21a18a:	4b3c      	ldr	r3, [pc, #240]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a18c:	681b      	ldr	r3, [r3, #0]
  21a18e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
  21a190:	693b      	ldr	r3, [r7, #16]
  21a192:	43db      	mvns	r3, r3
  21a194:	69ba      	ldr	r2, [r7, #24]
  21a196:	4013      	ands	r3, r2
  21a198:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
  21a19a:	683b      	ldr	r3, [r7, #0]
  21a19c:	685b      	ldr	r3, [r3, #4]
  21a19e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  21a1a2:	2b00      	cmp	r3, #0
  21a1a4:	d003      	beq.n	21a1ae <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
  21a1a6:	69ba      	ldr	r2, [r7, #24]
  21a1a8:	693b      	ldr	r3, [r7, #16]
  21a1aa:	4313      	orrs	r3, r2
  21a1ac:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
  21a1ae:	4a33      	ldr	r2, [pc, #204]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a1b0:	69bb      	ldr	r3, [r7, #24]
  21a1b2:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
  21a1b4:	4b31      	ldr	r3, [pc, #196]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a1b6:	685b      	ldr	r3, [r3, #4]
  21a1b8:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
  21a1ba:	693b      	ldr	r3, [r7, #16]
  21a1bc:	43db      	mvns	r3, r3
  21a1be:	69ba      	ldr	r2, [r7, #24]
  21a1c0:	4013      	ands	r3, r2
  21a1c2:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
  21a1c4:	683b      	ldr	r3, [r7, #0]
  21a1c6:	685b      	ldr	r3, [r3, #4]
  21a1c8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21a1cc:	2b00      	cmp	r3, #0
  21a1ce:	d003      	beq.n	21a1d8 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
  21a1d0:	69ba      	ldr	r2, [r7, #24]
  21a1d2:	693b      	ldr	r3, [r7, #16]
  21a1d4:	4313      	orrs	r3, r2
  21a1d6:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
  21a1d8:	4a28      	ldr	r2, [pc, #160]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a1da:	69bb      	ldr	r3, [r7, #24]
  21a1dc:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
  21a1de:	4b27      	ldr	r3, [pc, #156]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a1e0:	689b      	ldr	r3, [r3, #8]
  21a1e2:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
  21a1e4:	693b      	ldr	r3, [r7, #16]
  21a1e6:	43db      	mvns	r3, r3
  21a1e8:	69ba      	ldr	r2, [r7, #24]
  21a1ea:	4013      	ands	r3, r2
  21a1ec:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
  21a1ee:	683b      	ldr	r3, [r7, #0]
  21a1f0:	685b      	ldr	r3, [r3, #4]
  21a1f2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  21a1f6:	2b00      	cmp	r3, #0
  21a1f8:	d003      	beq.n	21a202 <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
  21a1fa:	69ba      	ldr	r2, [r7, #24]
  21a1fc:	693b      	ldr	r3, [r7, #16]
  21a1fe:	4313      	orrs	r3, r2
  21a200:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
  21a202:	4a1e      	ldr	r2, [pc, #120]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a204:	69bb      	ldr	r3, [r7, #24]
  21a206:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
  21a208:	4b1c      	ldr	r3, [pc, #112]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a20a:	68db      	ldr	r3, [r3, #12]
  21a20c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
  21a20e:	693b      	ldr	r3, [r7, #16]
  21a210:	43db      	mvns	r3, r3
  21a212:	69ba      	ldr	r2, [r7, #24]
  21a214:	4013      	ands	r3, r2
  21a216:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
  21a218:	683b      	ldr	r3, [r7, #0]
  21a21a:	685b      	ldr	r3, [r3, #4]
  21a21c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  21a220:	2b00      	cmp	r3, #0
  21a222:	d003      	beq.n	21a22c <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
  21a224:	69ba      	ldr	r2, [r7, #24]
  21a226:	693b      	ldr	r3, [r7, #16]
  21a228:	4313      	orrs	r3, r2
  21a22a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
  21a22c:	4a13      	ldr	r2, [pc, #76]	; (21a27c <HAL_GPIO_Init+0x350>)
  21a22e:	69bb      	ldr	r3, [r7, #24]
  21a230:	60d3      	str	r3, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
  21a232:	69fb      	ldr	r3, [r7, #28]
  21a234:	3301      	adds	r3, #1
  21a236:	61fb      	str	r3, [r7, #28]
  21a238:	69fb      	ldr	r3, [r7, #28]
  21a23a:	2b0f      	cmp	r3, #15
  21a23c:	f67f ae86 	bls.w	219f4c <HAL_GPIO_Init+0x20>
      }
    }
  }
}
  21a240:	bf00      	nop
  21a242:	3724      	adds	r7, #36	; 0x24
  21a244:	46bd      	mov	sp, r7
  21a246:	f85d 7b04 	ldr.w	r7, [sp], #4
  21a24a:	4770      	bx	lr
  21a24c:	40023800 	.word	0x40023800
  21a250:	40013800 	.word	0x40013800
  21a254:	40020000 	.word	0x40020000
  21a258:	40020400 	.word	0x40020400
  21a25c:	40020800 	.word	0x40020800
  21a260:	40020c00 	.word	0x40020c00
  21a264:	40021000 	.word	0x40021000
  21a268:	40021400 	.word	0x40021400
  21a26c:	40021800 	.word	0x40021800
  21a270:	40021c00 	.word	0x40021c00
  21a274:	40022000 	.word	0x40022000
  21a278:	40022400 	.word	0x40022400
  21a27c:	40013c00 	.word	0x40013c00

0021a280 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
  21a280:	b480      	push	{r7}
  21a282:	b083      	sub	sp, #12
  21a284:	af00      	add	r7, sp, #0
  21a286:	6078      	str	r0, [r7, #4]
  21a288:	460b      	mov	r3, r1
  21a28a:	807b      	strh	r3, [r7, #2]
  21a28c:	4613      	mov	r3, r2
  21a28e:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
  21a290:	787b      	ldrb	r3, [r7, #1]
  21a292:	2b00      	cmp	r3, #0
  21a294:	d003      	beq.n	21a29e <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
  21a296:	887a      	ldrh	r2, [r7, #2]
  21a298:	687b      	ldr	r3, [r7, #4]
  21a29a:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  }
}
  21a29c:	e003      	b.n	21a2a6 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  21a29e:	887b      	ldrh	r3, [r7, #2]
  21a2a0:	041a      	lsls	r2, r3, #16
  21a2a2:	687b      	ldr	r3, [r7, #4]
  21a2a4:	619a      	str	r2, [r3, #24]
}
  21a2a6:	bf00      	nop
  21a2a8:	370c      	adds	r7, #12
  21a2aa:	46bd      	mov	sp, r7
  21a2ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  21a2b0:	4770      	bx	lr
	...

0021a2b4 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
  21a2b4:	b580      	push	{r7, lr}
  21a2b6:	b084      	sub	sp, #16
  21a2b8:	af00      	add	r7, sp, #0
  21a2ba:	6078      	str	r0, [r7, #4]
  uint32_t tmp, tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
  21a2bc:	687b      	ldr	r3, [r7, #4]
  21a2be:	2b00      	cmp	r3, #0
  21a2c0:	d101      	bne.n	21a2c6 <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
  21a2c2:	2301      	movs	r3, #1
  21a2c4:	e0bf      	b.n	21a446 <HAL_LTDC_Init+0x192>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
  21a2c6:	687b      	ldr	r3, [r7, #4]
  21a2c8:	f893 30a1 	ldrb.w	r3, [r3, #161]	; 0xa1
  21a2cc:	b2db      	uxtb	r3, r3
  21a2ce:	2b00      	cmp	r3, #0
  21a2d0:	d106      	bne.n	21a2e0 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
  21a2d2:	687b      	ldr	r3, [r7, #4]
  21a2d4:	2200      	movs	r2, #0
  21a2d6:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
  21a2da:	6878      	ldr	r0, [r7, #4]
  21a2dc:	f7fd fd82 	bl	217de4 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
  21a2e0:	687b      	ldr	r3, [r7, #4]
  21a2e2:	2202      	movs	r2, #2
  21a2e4:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
  21a2e8:	687b      	ldr	r3, [r7, #4]
  21a2ea:	681b      	ldr	r3, [r3, #0]
  21a2ec:	687a      	ldr	r2, [r7, #4]
  21a2ee:	6812      	ldr	r2, [r2, #0]
  21a2f0:	6992      	ldr	r2, [r2, #24]
  21a2f2:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
  21a2f6:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
  21a2f8:	687b      	ldr	r3, [r7, #4]
  21a2fa:	681b      	ldr	r3, [r3, #0]
  21a2fc:	687a      	ldr	r2, [r7, #4]
  21a2fe:	6812      	ldr	r2, [r2, #0]
  21a300:	6991      	ldr	r1, [r2, #24]
  21a302:	687a      	ldr	r2, [r7, #4]
  21a304:	6850      	ldr	r0, [r2, #4]
  21a306:	687a      	ldr	r2, [r7, #4]
  21a308:	6892      	ldr	r2, [r2, #8]
  21a30a:	4310      	orrs	r0, r2
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
  21a30c:	687a      	ldr	r2, [r7, #4]
  21a30e:	68d2      	ldr	r2, [r2, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
  21a310:	4310      	orrs	r0, r2
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
  21a312:	687a      	ldr	r2, [r7, #4]
  21a314:	6912      	ldr	r2, [r2, #16]
  21a316:	4302      	orrs	r2, r0
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
  21a318:	430a      	orrs	r2, r1
  21a31a:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
  21a31c:	687b      	ldr	r3, [r7, #4]
  21a31e:	681a      	ldr	r2, [r3, #0]
  21a320:	687b      	ldr	r3, [r7, #4]
  21a322:	681b      	ldr	r3, [r3, #0]
  21a324:	6899      	ldr	r1, [r3, #8]
  21a326:	4b4a      	ldr	r3, [pc, #296]	; (21a450 <HAL_LTDC_Init+0x19c>)
  21a328:	400b      	ands	r3, r1
  21a32a:	6093      	str	r3, [r2, #8]
  tmp = (hltdc->Init.HorizontalSync << 16U);
  21a32c:	687b      	ldr	r3, [r7, #4]
  21a32e:	695b      	ldr	r3, [r3, #20]
  21a330:	041b      	lsls	r3, r3, #16
  21a332:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
  21a334:	687b      	ldr	r3, [r7, #4]
  21a336:	681b      	ldr	r3, [r3, #0]
  21a338:	687a      	ldr	r2, [r7, #4]
  21a33a:	6812      	ldr	r2, [r2, #0]
  21a33c:	6891      	ldr	r1, [r2, #8]
  21a33e:	687a      	ldr	r2, [r7, #4]
  21a340:	6990      	ldr	r0, [r2, #24]
  21a342:	68fa      	ldr	r2, [r7, #12]
  21a344:	4302      	orrs	r2, r0
  21a346:	430a      	orrs	r2, r1
  21a348:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
  21a34a:	687b      	ldr	r3, [r7, #4]
  21a34c:	681a      	ldr	r2, [r3, #0]
  21a34e:	687b      	ldr	r3, [r7, #4]
  21a350:	681b      	ldr	r3, [r3, #0]
  21a352:	68d9      	ldr	r1, [r3, #12]
  21a354:	4b3e      	ldr	r3, [pc, #248]	; (21a450 <HAL_LTDC_Init+0x19c>)
  21a356:	400b      	ands	r3, r1
  21a358:	60d3      	str	r3, [r2, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
  21a35a:	687b      	ldr	r3, [r7, #4]
  21a35c:	69db      	ldr	r3, [r3, #28]
  21a35e:	041b      	lsls	r3, r3, #16
  21a360:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
  21a362:	687b      	ldr	r3, [r7, #4]
  21a364:	681b      	ldr	r3, [r3, #0]
  21a366:	687a      	ldr	r2, [r7, #4]
  21a368:	6812      	ldr	r2, [r2, #0]
  21a36a:	68d1      	ldr	r1, [r2, #12]
  21a36c:	687a      	ldr	r2, [r7, #4]
  21a36e:	6a10      	ldr	r0, [r2, #32]
  21a370:	68fa      	ldr	r2, [r7, #12]
  21a372:	4302      	orrs	r2, r0
  21a374:	430a      	orrs	r2, r1
  21a376:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
  21a378:	687b      	ldr	r3, [r7, #4]
  21a37a:	681a      	ldr	r2, [r3, #0]
  21a37c:	687b      	ldr	r3, [r7, #4]
  21a37e:	681b      	ldr	r3, [r3, #0]
  21a380:	6919      	ldr	r1, [r3, #16]
  21a382:	4b33      	ldr	r3, [pc, #204]	; (21a450 <HAL_LTDC_Init+0x19c>)
  21a384:	400b      	ands	r3, r1
  21a386:	6113      	str	r3, [r2, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
  21a388:	687b      	ldr	r3, [r7, #4]
  21a38a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21a38c:	041b      	lsls	r3, r3, #16
  21a38e:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
  21a390:	687b      	ldr	r3, [r7, #4]
  21a392:	681b      	ldr	r3, [r3, #0]
  21a394:	687a      	ldr	r2, [r7, #4]
  21a396:	6812      	ldr	r2, [r2, #0]
  21a398:	6911      	ldr	r1, [r2, #16]
  21a39a:	687a      	ldr	r2, [r7, #4]
  21a39c:	6a90      	ldr	r0, [r2, #40]	; 0x28
  21a39e:	68fa      	ldr	r2, [r7, #12]
  21a3a0:	4302      	orrs	r2, r0
  21a3a2:	430a      	orrs	r2, r1
  21a3a4:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
  21a3a6:	687b      	ldr	r3, [r7, #4]
  21a3a8:	681a      	ldr	r2, [r3, #0]
  21a3aa:	687b      	ldr	r3, [r7, #4]
  21a3ac:	681b      	ldr	r3, [r3, #0]
  21a3ae:	6959      	ldr	r1, [r3, #20]
  21a3b0:	4b27      	ldr	r3, [pc, #156]	; (21a450 <HAL_LTDC_Init+0x19c>)
  21a3b2:	400b      	ands	r3, r1
  21a3b4:	6153      	str	r3, [r2, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
  21a3b6:	687b      	ldr	r3, [r7, #4]
  21a3b8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21a3ba:	041b      	lsls	r3, r3, #16
  21a3bc:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
  21a3be:	687b      	ldr	r3, [r7, #4]
  21a3c0:	681b      	ldr	r3, [r3, #0]
  21a3c2:	687a      	ldr	r2, [r7, #4]
  21a3c4:	6812      	ldr	r2, [r2, #0]
  21a3c6:	6951      	ldr	r1, [r2, #20]
  21a3c8:	687a      	ldr	r2, [r7, #4]
  21a3ca:	6b10      	ldr	r0, [r2, #48]	; 0x30
  21a3cc:	68fa      	ldr	r2, [r7, #12]
  21a3ce:	4302      	orrs	r2, r0
  21a3d0:	430a      	orrs	r2, r1
  21a3d2:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
  21a3d4:	687b      	ldr	r3, [r7, #4]
  21a3d6:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
  21a3da:	021b      	lsls	r3, r3, #8
  21a3dc:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
  21a3de:	687b      	ldr	r3, [r7, #4]
  21a3e0:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
  21a3e4:	041b      	lsls	r3, r3, #16
  21a3e6:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
  21a3e8:	687b      	ldr	r3, [r7, #4]
  21a3ea:	681b      	ldr	r3, [r3, #0]
  21a3ec:	687a      	ldr	r2, [r7, #4]
  21a3ee:	6812      	ldr	r2, [r2, #0]
  21a3f0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21a3f2:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
  21a3f6:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
  21a3f8:	687b      	ldr	r3, [r7, #4]
  21a3fa:	681b      	ldr	r3, [r3, #0]
  21a3fc:	687a      	ldr	r2, [r7, #4]
  21a3fe:	6812      	ldr	r2, [r2, #0]
  21a400:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  21a402:	68b8      	ldr	r0, [r7, #8]
  21a404:	68fa      	ldr	r2, [r7, #12]
  21a406:	4302      	orrs	r2, r0
  21a408:	6878      	ldr	r0, [r7, #4]
  21a40a:	f890 0034 	ldrb.w	r0, [r0, #52]	; 0x34
  21a40e:	4302      	orrs	r2, r0
  21a410:	430a      	orrs	r2, r1
  21a412:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
  21a414:	687b      	ldr	r3, [r7, #4]
  21a416:	681b      	ldr	r3, [r3, #0]
  21a418:	687a      	ldr	r2, [r7, #4]
  21a41a:	6812      	ldr	r2, [r2, #0]
  21a41c:	6b52      	ldr	r2, [r2, #52]	; 0x34
  21a41e:	f042 0206 	orr.w	r2, r2, #6
  21a422:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
  21a424:	687b      	ldr	r3, [r7, #4]
  21a426:	681b      	ldr	r3, [r3, #0]
  21a428:	687a      	ldr	r2, [r7, #4]
  21a42a:	6812      	ldr	r2, [r2, #0]
  21a42c:	6992      	ldr	r2, [r2, #24]
  21a42e:	f042 0201 	orr.w	r2, r2, #1
  21a432:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
  21a434:	687b      	ldr	r3, [r7, #4]
  21a436:	2200      	movs	r2, #0
  21a438:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
  21a43c:	687b      	ldr	r3, [r7, #4]
  21a43e:	2201      	movs	r2, #1
  21a440:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  return HAL_OK;
  21a444:	2300      	movs	r3, #0
}
  21a446:	4618      	mov	r0, r3
  21a448:	3710      	adds	r7, #16
  21a44a:	46bd      	mov	sp, r7
  21a44c:	bd80      	pop	{r7, pc}
  21a44e:	bf00      	nop
  21a450:	f000f800 	.word	0xf000f800

0021a454 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
  21a454:	b5b0      	push	{r4, r5, r7, lr}
  21a456:	b084      	sub	sp, #16
  21a458:	af00      	add	r7, sp, #0
  21a45a:	60f8      	str	r0, [r7, #12]
  21a45c:	60b9      	str	r1, [r7, #8]
  21a45e:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
  21a460:	68fb      	ldr	r3, [r7, #12]
  21a462:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
  21a466:	2b01      	cmp	r3, #1
  21a468:	d101      	bne.n	21a46e <HAL_LTDC_ConfigLayer+0x1a>
  21a46a:	2302      	movs	r3, #2
  21a46c:	e02c      	b.n	21a4c8 <HAL_LTDC_ConfigLayer+0x74>
  21a46e:	68fb      	ldr	r3, [r7, #12]
  21a470:	2201      	movs	r2, #1
  21a472:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
  21a476:	68fb      	ldr	r3, [r7, #12]
  21a478:	2202      	movs	r2, #2
  21a47a:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
  21a47e:	68fa      	ldr	r2, [r7, #12]
  21a480:	687b      	ldr	r3, [r7, #4]
  21a482:	2134      	movs	r1, #52	; 0x34
  21a484:	fb01 f303 	mul.w	r3, r1, r3
  21a488:	4413      	add	r3, r2
  21a48a:	f103 0238 	add.w	r2, r3, #56	; 0x38
  21a48e:	68bb      	ldr	r3, [r7, #8]
  21a490:	4614      	mov	r4, r2
  21a492:	461d      	mov	r5, r3
  21a494:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  21a496:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  21a498:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  21a49a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  21a49c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
  21a49e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
  21a4a0:	682b      	ldr	r3, [r5, #0]
  21a4a2:	6023      	str	r3, [r4, #0]

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
  21a4a4:	687a      	ldr	r2, [r7, #4]
  21a4a6:	68b9      	ldr	r1, [r7, #8]
  21a4a8:	68f8      	ldr	r0, [r7, #12]
  21a4aa:	f000 f811 	bl	21a4d0 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
  21a4ae:	68fb      	ldr	r3, [r7, #12]
  21a4b0:	681b      	ldr	r3, [r3, #0]
  21a4b2:	2201      	movs	r2, #1
  21a4b4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
  21a4b6:	68fb      	ldr	r3, [r7, #12]
  21a4b8:	2201      	movs	r2, #1
  21a4ba:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
  21a4be:	68fb      	ldr	r3, [r7, #12]
  21a4c0:	2200      	movs	r2, #0
  21a4c2:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  return HAL_OK;
  21a4c6:	2300      	movs	r3, #0
}
  21a4c8:	4618      	mov	r0, r3
  21a4ca:	3710      	adds	r7, #16
  21a4cc:	46bd      	mov	sp, r7
  21a4ce:	bdb0      	pop	{r4, r5, r7, pc}

0021a4d0 <LTDC_SetConfig>:
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values: LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval None
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
  21a4d0:	b480      	push	{r7}
  21a4d2:	b089      	sub	sp, #36	; 0x24
  21a4d4:	af00      	add	r7, sp, #0
  21a4d6:	60f8      	str	r0, [r7, #12]
  21a4d8:	60b9      	str	r1, [r7, #8]
  21a4da:	607a      	str	r2, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
  21a4dc:	68bb      	ldr	r3, [r7, #8]
  21a4de:	685a      	ldr	r2, [r3, #4]
  21a4e0:	68fb      	ldr	r3, [r7, #12]
  21a4e2:	681b      	ldr	r3, [r3, #0]
  21a4e4:	68db      	ldr	r3, [r3, #12]
  21a4e6:	0c1b      	lsrs	r3, r3, #16
  21a4e8:	f3c3 030b 	ubfx	r3, r3, #0, #12
  21a4ec:	4413      	add	r3, r2
  21a4ee:	041b      	lsls	r3, r3, #16
  21a4f0:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
  21a4f2:	68fb      	ldr	r3, [r7, #12]
  21a4f4:	681b      	ldr	r3, [r3, #0]
  21a4f6:	461a      	mov	r2, r3
  21a4f8:	687b      	ldr	r3, [r7, #4]
  21a4fa:	01db      	lsls	r3, r3, #7
  21a4fc:	4413      	add	r3, r2
  21a4fe:	3384      	adds	r3, #132	; 0x84
  21a500:	461a      	mov	r2, r3
  21a502:	68fb      	ldr	r3, [r7, #12]
  21a504:	681b      	ldr	r3, [r3, #0]
  21a506:	4619      	mov	r1, r3
  21a508:	687b      	ldr	r3, [r7, #4]
  21a50a:	01db      	lsls	r3, r3, #7
  21a50c:	440b      	add	r3, r1
  21a50e:	3384      	adds	r3, #132	; 0x84
  21a510:	685b      	ldr	r3, [r3, #4]
  21a512:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
  21a516:	6053      	str	r3, [r2, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
  21a518:	68fb      	ldr	r3, [r7, #12]
  21a51a:	681b      	ldr	r3, [r3, #0]
  21a51c:	461a      	mov	r2, r3
  21a51e:	687b      	ldr	r3, [r7, #4]
  21a520:	01db      	lsls	r3, r3, #7
  21a522:	4413      	add	r3, r2
  21a524:	3384      	adds	r3, #132	; 0x84
  21a526:	4619      	mov	r1, r3
  21a528:	68bb      	ldr	r3, [r7, #8]
  21a52a:	681a      	ldr	r2, [r3, #0]
  21a52c:	68fb      	ldr	r3, [r7, #12]
  21a52e:	681b      	ldr	r3, [r3, #0]
  21a530:	68db      	ldr	r3, [r3, #12]
  21a532:	0c1b      	lsrs	r3, r3, #16
  21a534:	f3c3 030b 	ubfx	r3, r3, #0, #12
  21a538:	4413      	add	r3, r2
  21a53a:	1c5a      	adds	r2, r3, #1
  21a53c:	69fb      	ldr	r3, [r7, #28]
  21a53e:	4313      	orrs	r3, r2
  21a540:	604b      	str	r3, [r1, #4]

  /* Configure the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
  21a542:	68bb      	ldr	r3, [r7, #8]
  21a544:	68da      	ldr	r2, [r3, #12]
  21a546:	68fb      	ldr	r3, [r7, #12]
  21a548:	681b      	ldr	r3, [r3, #0]
  21a54a:	68db      	ldr	r3, [r3, #12]
  21a54c:	f3c3 030a 	ubfx	r3, r3, #0, #11
  21a550:	4413      	add	r3, r2
  21a552:	041b      	lsls	r3, r3, #16
  21a554:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
  21a556:	68fb      	ldr	r3, [r7, #12]
  21a558:	681b      	ldr	r3, [r3, #0]
  21a55a:	461a      	mov	r2, r3
  21a55c:	687b      	ldr	r3, [r7, #4]
  21a55e:	01db      	lsls	r3, r3, #7
  21a560:	4413      	add	r3, r2
  21a562:	3384      	adds	r3, #132	; 0x84
  21a564:	461a      	mov	r2, r3
  21a566:	68fb      	ldr	r3, [r7, #12]
  21a568:	681b      	ldr	r3, [r3, #0]
  21a56a:	4619      	mov	r1, r3
  21a56c:	687b      	ldr	r3, [r7, #4]
  21a56e:	01db      	lsls	r3, r3, #7
  21a570:	440b      	add	r3, r1
  21a572:	3384      	adds	r3, #132	; 0x84
  21a574:	689b      	ldr	r3, [r3, #8]
  21a576:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
  21a57a:	6093      	str	r3, [r2, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
  21a57c:	68fb      	ldr	r3, [r7, #12]
  21a57e:	681b      	ldr	r3, [r3, #0]
  21a580:	461a      	mov	r2, r3
  21a582:	687b      	ldr	r3, [r7, #4]
  21a584:	01db      	lsls	r3, r3, #7
  21a586:	4413      	add	r3, r2
  21a588:	3384      	adds	r3, #132	; 0x84
  21a58a:	4619      	mov	r1, r3
  21a58c:	68bb      	ldr	r3, [r7, #8]
  21a58e:	689a      	ldr	r2, [r3, #8]
  21a590:	68fb      	ldr	r3, [r7, #12]
  21a592:	681b      	ldr	r3, [r3, #0]
  21a594:	68db      	ldr	r3, [r3, #12]
  21a596:	f3c3 030a 	ubfx	r3, r3, #0, #11
  21a59a:	4413      	add	r3, r2
  21a59c:	1c5a      	adds	r2, r3, #1
  21a59e:	69fb      	ldr	r3, [r7, #28]
  21a5a0:	4313      	orrs	r3, r2
  21a5a2:	608b      	str	r3, [r1, #8]

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
  21a5a4:	68fb      	ldr	r3, [r7, #12]
  21a5a6:	681b      	ldr	r3, [r3, #0]
  21a5a8:	461a      	mov	r2, r3
  21a5aa:	687b      	ldr	r3, [r7, #4]
  21a5ac:	01db      	lsls	r3, r3, #7
  21a5ae:	4413      	add	r3, r2
  21a5b0:	3384      	adds	r3, #132	; 0x84
  21a5b2:	461a      	mov	r2, r3
  21a5b4:	68fb      	ldr	r3, [r7, #12]
  21a5b6:	681b      	ldr	r3, [r3, #0]
  21a5b8:	4619      	mov	r1, r3
  21a5ba:	687b      	ldr	r3, [r7, #4]
  21a5bc:	01db      	lsls	r3, r3, #7
  21a5be:	440b      	add	r3, r1
  21a5c0:	3384      	adds	r3, #132	; 0x84
  21a5c2:	691b      	ldr	r3, [r3, #16]
  21a5c4:	f023 0307 	bic.w	r3, r3, #7
  21a5c8:	6113      	str	r3, [r2, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
  21a5ca:	68fb      	ldr	r3, [r7, #12]
  21a5cc:	681b      	ldr	r3, [r3, #0]
  21a5ce:	461a      	mov	r2, r3
  21a5d0:	687b      	ldr	r3, [r7, #4]
  21a5d2:	01db      	lsls	r3, r3, #7
  21a5d4:	4413      	add	r3, r2
  21a5d6:	3384      	adds	r3, #132	; 0x84
  21a5d8:	461a      	mov	r2, r3
  21a5da:	68bb      	ldr	r3, [r7, #8]
  21a5dc:	691b      	ldr	r3, [r3, #16]
  21a5de:	6113      	str	r3, [r2, #16]

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  21a5e0:	68bb      	ldr	r3, [r7, #8]
  21a5e2:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
  21a5e6:	021b      	lsls	r3, r3, #8
  21a5e8:	61fb      	str	r3, [r7, #28]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  21a5ea:	68bb      	ldr	r3, [r7, #8]
  21a5ec:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
  21a5f0:	041b      	lsls	r3, r3, #16
  21a5f2:	61bb      	str	r3, [r7, #24]
  tmp2 = (pLayerCfg->Alpha0 << 24U);
  21a5f4:	68bb      	ldr	r3, [r7, #8]
  21a5f6:	699b      	ldr	r3, [r3, #24]
  21a5f8:	061b      	lsls	r3, r3, #24
  21a5fa:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
  21a5fc:	68fb      	ldr	r3, [r7, #12]
  21a5fe:	681b      	ldr	r3, [r3, #0]
  21a600:	461a      	mov	r2, r3
  21a602:	687b      	ldr	r3, [r7, #4]
  21a604:	01db      	lsls	r3, r3, #7
  21a606:	4413      	add	r3, r2
  21a608:	3384      	adds	r3, #132	; 0x84
  21a60a:	699b      	ldr	r3, [r3, #24]
  21a60c:	68fb      	ldr	r3, [r7, #12]
  21a60e:	681b      	ldr	r3, [r3, #0]
  21a610:	461a      	mov	r2, r3
  21a612:	687b      	ldr	r3, [r7, #4]
  21a614:	01db      	lsls	r3, r3, #7
  21a616:	4413      	add	r3, r2
  21a618:	3384      	adds	r3, #132	; 0x84
  21a61a:	461a      	mov	r2, r3
  21a61c:	2300      	movs	r3, #0
  21a61e:	6193      	str	r3, [r2, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
  21a620:	68fb      	ldr	r3, [r7, #12]
  21a622:	681b      	ldr	r3, [r3, #0]
  21a624:	461a      	mov	r2, r3
  21a626:	687b      	ldr	r3, [r7, #4]
  21a628:	01db      	lsls	r3, r3, #7
  21a62a:	4413      	add	r3, r2
  21a62c:	3384      	adds	r3, #132	; 0x84
  21a62e:	4619      	mov	r1, r3
  21a630:	68bb      	ldr	r3, [r7, #8]
  21a632:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  21a636:	461a      	mov	r2, r3
  21a638:	69fb      	ldr	r3, [r7, #28]
  21a63a:	431a      	orrs	r2, r3
  21a63c:	69bb      	ldr	r3, [r7, #24]
  21a63e:	431a      	orrs	r2, r3
  21a640:	697b      	ldr	r3, [r7, #20]
  21a642:	4313      	orrs	r3, r2
  21a644:	618b      	str	r3, [r1, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
  21a646:	68fb      	ldr	r3, [r7, #12]
  21a648:	681b      	ldr	r3, [r3, #0]
  21a64a:	461a      	mov	r2, r3
  21a64c:	687b      	ldr	r3, [r7, #4]
  21a64e:	01db      	lsls	r3, r3, #7
  21a650:	4413      	add	r3, r2
  21a652:	3384      	adds	r3, #132	; 0x84
  21a654:	461a      	mov	r2, r3
  21a656:	68fb      	ldr	r3, [r7, #12]
  21a658:	681b      	ldr	r3, [r3, #0]
  21a65a:	4619      	mov	r1, r3
  21a65c:	687b      	ldr	r3, [r7, #4]
  21a65e:	01db      	lsls	r3, r3, #7
  21a660:	440b      	add	r3, r1
  21a662:	3384      	adds	r3, #132	; 0x84
  21a664:	695b      	ldr	r3, [r3, #20]
  21a666:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  21a66a:	6153      	str	r3, [r2, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
  21a66c:	68fb      	ldr	r3, [r7, #12]
  21a66e:	681b      	ldr	r3, [r3, #0]
  21a670:	461a      	mov	r2, r3
  21a672:	687b      	ldr	r3, [r7, #4]
  21a674:	01db      	lsls	r3, r3, #7
  21a676:	4413      	add	r3, r2
  21a678:	3384      	adds	r3, #132	; 0x84
  21a67a:	461a      	mov	r2, r3
  21a67c:	68bb      	ldr	r3, [r7, #8]
  21a67e:	695b      	ldr	r3, [r3, #20]
  21a680:	6153      	str	r3, [r2, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
  21a682:	68fb      	ldr	r3, [r7, #12]
  21a684:	681b      	ldr	r3, [r3, #0]
  21a686:	461a      	mov	r2, r3
  21a688:	687b      	ldr	r3, [r7, #4]
  21a68a:	01db      	lsls	r3, r3, #7
  21a68c:	4413      	add	r3, r2
  21a68e:	3384      	adds	r3, #132	; 0x84
  21a690:	4619      	mov	r1, r3
  21a692:	68fb      	ldr	r3, [r7, #12]
  21a694:	681b      	ldr	r3, [r3, #0]
  21a696:	461a      	mov	r2, r3
  21a698:	687b      	ldr	r3, [r7, #4]
  21a69a:	01db      	lsls	r3, r3, #7
  21a69c:	4413      	add	r3, r2
  21a69e:	3384      	adds	r3, #132	; 0x84
  21a6a0:	69da      	ldr	r2, [r3, #28]
  21a6a2:	4b5a      	ldr	r3, [pc, #360]	; (21a80c <LTDC_SetConfig+0x33c>)
  21a6a4:	4013      	ands	r3, r2
  21a6a6:	61cb      	str	r3, [r1, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
  21a6a8:	68fb      	ldr	r3, [r7, #12]
  21a6aa:	681b      	ldr	r3, [r3, #0]
  21a6ac:	461a      	mov	r2, r3
  21a6ae:	687b      	ldr	r3, [r7, #4]
  21a6b0:	01db      	lsls	r3, r3, #7
  21a6b2:	4413      	add	r3, r2
  21a6b4:	3384      	adds	r3, #132	; 0x84
  21a6b6:	4619      	mov	r1, r3
  21a6b8:	68bb      	ldr	r3, [r7, #8]
  21a6ba:	69da      	ldr	r2, [r3, #28]
  21a6bc:	68bb      	ldr	r3, [r7, #8]
  21a6be:	6a1b      	ldr	r3, [r3, #32]
  21a6c0:	4313      	orrs	r3, r2
  21a6c2:	61cb      	str	r3, [r1, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
  21a6c4:	68fb      	ldr	r3, [r7, #12]
  21a6c6:	681b      	ldr	r3, [r3, #0]
  21a6c8:	461a      	mov	r2, r3
  21a6ca:	687b      	ldr	r3, [r7, #4]
  21a6cc:	01db      	lsls	r3, r3, #7
  21a6ce:	4413      	add	r3, r2
  21a6d0:	3384      	adds	r3, #132	; 0x84
  21a6d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  21a6d4:	68fb      	ldr	r3, [r7, #12]
  21a6d6:	681b      	ldr	r3, [r3, #0]
  21a6d8:	461a      	mov	r2, r3
  21a6da:	687b      	ldr	r3, [r7, #4]
  21a6dc:	01db      	lsls	r3, r3, #7
  21a6de:	4413      	add	r3, r2
  21a6e0:	3384      	adds	r3, #132	; 0x84
  21a6e2:	461a      	mov	r2, r3
  21a6e4:	2300      	movs	r3, #0
  21a6e6:	6293      	str	r3, [r2, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
  21a6e8:	68fb      	ldr	r3, [r7, #12]
  21a6ea:	681b      	ldr	r3, [r3, #0]
  21a6ec:	461a      	mov	r2, r3
  21a6ee:	687b      	ldr	r3, [r7, #4]
  21a6f0:	01db      	lsls	r3, r3, #7
  21a6f2:	4413      	add	r3, r2
  21a6f4:	3384      	adds	r3, #132	; 0x84
  21a6f6:	461a      	mov	r2, r3
  21a6f8:	68bb      	ldr	r3, [r7, #8]
  21a6fa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21a6fc:	6293      	str	r3, [r2, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
  21a6fe:	68bb      	ldr	r3, [r7, #8]
  21a700:	691b      	ldr	r3, [r3, #16]
  21a702:	2b00      	cmp	r3, #0
  21a704:	d102      	bne.n	21a70c <LTDC_SetConfig+0x23c>
  {
    tmp = 4U;
  21a706:	2304      	movs	r3, #4
  21a708:	61fb      	str	r3, [r7, #28]
  21a70a:	e01b      	b.n	21a744 <LTDC_SetConfig+0x274>
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
  21a70c:	68bb      	ldr	r3, [r7, #8]
  21a70e:	691b      	ldr	r3, [r3, #16]
  21a710:	2b01      	cmp	r3, #1
  21a712:	d102      	bne.n	21a71a <LTDC_SetConfig+0x24a>
  {
    tmp = 3U;
  21a714:	2303      	movs	r3, #3
  21a716:	61fb      	str	r3, [r7, #28]
  21a718:	e014      	b.n	21a744 <LTDC_SetConfig+0x274>
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
  21a71a:	68bb      	ldr	r3, [r7, #8]
  21a71c:	691b      	ldr	r3, [r3, #16]
  21a71e:	2b04      	cmp	r3, #4
  21a720:	d00b      	beq.n	21a73a <LTDC_SetConfig+0x26a>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
  21a722:	68bb      	ldr	r3, [r7, #8]
  21a724:	691b      	ldr	r3, [r3, #16]
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
  21a726:	2b02      	cmp	r3, #2
  21a728:	d007      	beq.n	21a73a <LTDC_SetConfig+0x26a>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
  21a72a:	68bb      	ldr	r3, [r7, #8]
  21a72c:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
  21a72e:	2b03      	cmp	r3, #3
  21a730:	d003      	beq.n	21a73a <LTDC_SetConfig+0x26a>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
  21a732:	68bb      	ldr	r3, [r7, #8]
  21a734:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
  21a736:	2b07      	cmp	r3, #7
  21a738:	d102      	bne.n	21a740 <LTDC_SetConfig+0x270>
  {
    tmp = 2U;
  21a73a:	2302      	movs	r3, #2
  21a73c:	61fb      	str	r3, [r7, #28]
  21a73e:	e001      	b.n	21a744 <LTDC_SetConfig+0x274>
  }
  else
  {
    tmp = 1U;
  21a740:	2301      	movs	r3, #1
  21a742:	61fb      	str	r3, [r7, #28]
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
  21a744:	68fb      	ldr	r3, [r7, #12]
  21a746:	681b      	ldr	r3, [r3, #0]
  21a748:	461a      	mov	r2, r3
  21a74a:	687b      	ldr	r3, [r7, #4]
  21a74c:	01db      	lsls	r3, r3, #7
  21a74e:	4413      	add	r3, r2
  21a750:	3384      	adds	r3, #132	; 0x84
  21a752:	461a      	mov	r2, r3
  21a754:	68fb      	ldr	r3, [r7, #12]
  21a756:	681b      	ldr	r3, [r3, #0]
  21a758:	4619      	mov	r1, r3
  21a75a:	687b      	ldr	r3, [r7, #4]
  21a75c:	01db      	lsls	r3, r3, #7
  21a75e:	440b      	add	r3, r1
  21a760:	3384      	adds	r3, #132	; 0x84
  21a762:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21a764:	f003 23e0 	and.w	r3, r3, #3758153728	; 0xe000e000
  21a768:	62d3      	str	r3, [r2, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
  21a76a:	68fb      	ldr	r3, [r7, #12]
  21a76c:	681b      	ldr	r3, [r3, #0]
  21a76e:	461a      	mov	r2, r3
  21a770:	687b      	ldr	r3, [r7, #4]
  21a772:	01db      	lsls	r3, r3, #7
  21a774:	4413      	add	r3, r2
  21a776:	3384      	adds	r3, #132	; 0x84
  21a778:	4618      	mov	r0, r3
  21a77a:	68bb      	ldr	r3, [r7, #8]
  21a77c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  21a77e:	69fa      	ldr	r2, [r7, #28]
  21a780:	fb02 f303 	mul.w	r3, r2, r3
  21a784:	041a      	lsls	r2, r3, #16
  21a786:	68bb      	ldr	r3, [r7, #8]
  21a788:	6859      	ldr	r1, [r3, #4]
  21a78a:	68bb      	ldr	r3, [r7, #8]
  21a78c:	681b      	ldr	r3, [r3, #0]
  21a78e:	1acb      	subs	r3, r1, r3
  21a790:	69f9      	ldr	r1, [r7, #28]
  21a792:	fb01 f303 	mul.w	r3, r1, r3
  21a796:	3303      	adds	r3, #3
  21a798:	4313      	orrs	r3, r2
  21a79a:	62c3      	str	r3, [r0, #44]	; 0x2c
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  21a79c:	68fb      	ldr	r3, [r7, #12]
  21a79e:	681b      	ldr	r3, [r3, #0]
  21a7a0:	461a      	mov	r2, r3
  21a7a2:	687b      	ldr	r3, [r7, #4]
  21a7a4:	01db      	lsls	r3, r3, #7
  21a7a6:	4413      	add	r3, r2
  21a7a8:	3384      	adds	r3, #132	; 0x84
  21a7aa:	4619      	mov	r1, r3
  21a7ac:	68fb      	ldr	r3, [r7, #12]
  21a7ae:	681b      	ldr	r3, [r3, #0]
  21a7b0:	461a      	mov	r2, r3
  21a7b2:	687b      	ldr	r3, [r7, #4]
  21a7b4:	01db      	lsls	r3, r3, #7
  21a7b6:	4413      	add	r3, r2
  21a7b8:	3384      	adds	r3, #132	; 0x84
  21a7ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  21a7bc:	4b14      	ldr	r3, [pc, #80]	; (21a810 <LTDC_SetConfig+0x340>)
  21a7be:	4013      	ands	r3, r2
  21a7c0:	630b      	str	r3, [r1, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
  21a7c2:	68fb      	ldr	r3, [r7, #12]
  21a7c4:	681b      	ldr	r3, [r3, #0]
  21a7c6:	461a      	mov	r2, r3
  21a7c8:	687b      	ldr	r3, [r7, #4]
  21a7ca:	01db      	lsls	r3, r3, #7
  21a7cc:	4413      	add	r3, r2
  21a7ce:	3384      	adds	r3, #132	; 0x84
  21a7d0:	461a      	mov	r2, r3
  21a7d2:	68bb      	ldr	r3, [r7, #8]
  21a7d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21a7d6:	6313      	str	r3, [r2, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
  21a7d8:	68fb      	ldr	r3, [r7, #12]
  21a7da:	681b      	ldr	r3, [r3, #0]
  21a7dc:	461a      	mov	r2, r3
  21a7de:	687b      	ldr	r3, [r7, #4]
  21a7e0:	01db      	lsls	r3, r3, #7
  21a7e2:	4413      	add	r3, r2
  21a7e4:	3384      	adds	r3, #132	; 0x84
  21a7e6:	461a      	mov	r2, r3
  21a7e8:	68fb      	ldr	r3, [r7, #12]
  21a7ea:	681b      	ldr	r3, [r3, #0]
  21a7ec:	4619      	mov	r1, r3
  21a7ee:	687b      	ldr	r3, [r7, #4]
  21a7f0:	01db      	lsls	r3, r3, #7
  21a7f2:	440b      	add	r3, r1
  21a7f4:	3384      	adds	r3, #132	; 0x84
  21a7f6:	681b      	ldr	r3, [r3, #0]
  21a7f8:	f043 0301 	orr.w	r3, r3, #1
  21a7fc:	6013      	str	r3, [r2, #0]
}
  21a7fe:	bf00      	nop
  21a800:	3724      	adds	r7, #36	; 0x24
  21a802:	46bd      	mov	sp, r7
  21a804:	f85d 7b04 	ldr.w	r7, [sp], #4
  21a808:	4770      	bx	lr
  21a80a:	bf00      	nop
  21a80c:	fffff8f8 	.word	0xfffff8f8
  21a810:	fffff800 	.word	0xfffff800

0021a814 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
  21a814:	b580      	push	{r7, lr}
  21a816:	b082      	sub	sp, #8
  21a818:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
  21a81a:	2300      	movs	r3, #0
  21a81c:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
  21a81e:	4a23      	ldr	r2, [pc, #140]	; (21a8ac <HAL_PWREx_EnableOverDrive+0x98>)
  21a820:	4b22      	ldr	r3, [pc, #136]	; (21a8ac <HAL_PWREx_EnableOverDrive+0x98>)
  21a822:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21a824:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  21a828:	6413      	str	r3, [r2, #64]	; 0x40
  21a82a:	4b20      	ldr	r3, [pc, #128]	; (21a8ac <HAL_PWREx_EnableOverDrive+0x98>)
  21a82c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21a82e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21a832:	603b      	str	r3, [r7, #0]
  21a834:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
  21a836:	4a1e      	ldr	r2, [pc, #120]	; (21a8b0 <HAL_PWREx_EnableOverDrive+0x9c>)
  21a838:	4b1d      	ldr	r3, [pc, #116]	; (21a8b0 <HAL_PWREx_EnableOverDrive+0x9c>)
  21a83a:	681b      	ldr	r3, [r3, #0]
  21a83c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  21a840:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
  21a842:	f7fe faf5 	bl	218e30 <HAL_GetTick>
  21a846:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
  21a848:	e009      	b.n	21a85e <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
  21a84a:	f7fe faf1 	bl	218e30 <HAL_GetTick>
  21a84e:	4602      	mov	r2, r0
  21a850:	687b      	ldr	r3, [r7, #4]
  21a852:	1ad3      	subs	r3, r2, r3
  21a854:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  21a858:	d901      	bls.n	21a85e <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
  21a85a:	2303      	movs	r3, #3
  21a85c:	e022      	b.n	21a8a4 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
  21a85e:	4b14      	ldr	r3, [pc, #80]	; (21a8b0 <HAL_PWREx_EnableOverDrive+0x9c>)
  21a860:	685b      	ldr	r3, [r3, #4]
  21a862:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  21a866:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  21a86a:	d1ee      	bne.n	21a84a <HAL_PWREx_EnableOverDrive+0x36>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
  21a86c:	4a10      	ldr	r2, [pc, #64]	; (21a8b0 <HAL_PWREx_EnableOverDrive+0x9c>)
  21a86e:	4b10      	ldr	r3, [pc, #64]	; (21a8b0 <HAL_PWREx_EnableOverDrive+0x9c>)
  21a870:	681b      	ldr	r3, [r3, #0]
  21a872:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  21a876:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
  21a878:	f7fe fada 	bl	218e30 <HAL_GetTick>
  21a87c:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
  21a87e:	e009      	b.n	21a894 <HAL_PWREx_EnableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
  21a880:	f7fe fad6 	bl	218e30 <HAL_GetTick>
  21a884:	4602      	mov	r2, r0
  21a886:	687b      	ldr	r3, [r7, #4]
  21a888:	1ad3      	subs	r3, r2, r3
  21a88a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
  21a88e:	d901      	bls.n	21a894 <HAL_PWREx_EnableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
  21a890:	2303      	movs	r3, #3
  21a892:	e007      	b.n	21a8a4 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
  21a894:	4b06      	ldr	r3, [pc, #24]	; (21a8b0 <HAL_PWREx_EnableOverDrive+0x9c>)
  21a896:	685b      	ldr	r3, [r3, #4]
  21a898:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21a89c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
  21a8a0:	d1ee      	bne.n	21a880 <HAL_PWREx_EnableOverDrive+0x6c>
    }
  } 
  return HAL_OK;
  21a8a2:	2300      	movs	r3, #0
}
  21a8a4:	4618      	mov	r0, r3
  21a8a6:	3708      	adds	r7, #8
  21a8a8:	46bd      	mov	sp, r7
  21a8aa:	bd80      	pop	{r7, pc}
  21a8ac:	40023800 	.word	0x40023800
  21a8b0:	40007000 	.word	0x40007000

0021a8b4 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
  21a8b4:	b580      	push	{r7, lr}
  21a8b6:	b086      	sub	sp, #24
  21a8b8:	af00      	add	r7, sp, #0
  21a8ba:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  uint32_t pll_config;
  FlagStatus pwrclkchanged = RESET;
  21a8bc:	2300      	movs	r3, #0
  21a8be:	75fb      	strb	r3, [r7, #23]

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
  21a8c0:	687b      	ldr	r3, [r7, #4]
  21a8c2:	2b00      	cmp	r3, #0
  21a8c4:	d101      	bne.n	21a8ca <HAL_RCC_OscConfig+0x16>
  {
    return HAL_ERROR;
  21a8c6:	2301      	movs	r3, #1
  21a8c8:	e29b      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  21a8ca:	687b      	ldr	r3, [r7, #4]
  21a8cc:	681b      	ldr	r3, [r3, #0]
  21a8ce:	f003 0301 	and.w	r3, r3, #1
  21a8d2:	2b00      	cmp	r3, #0
  21a8d4:	f000 8087 	beq.w	21a9e6 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
  21a8d8:	4b96      	ldr	r3, [pc, #600]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a8da:	689b      	ldr	r3, [r3, #8]
  21a8dc:	f003 030c 	and.w	r3, r3, #12
  21a8e0:	2b04      	cmp	r3, #4
  21a8e2:	d00c      	beq.n	21a8fe <HAL_RCC_OscConfig+0x4a>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
  21a8e4:	4b93      	ldr	r3, [pc, #588]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a8e6:	689b      	ldr	r3, [r3, #8]
  21a8e8:	f003 030c 	and.w	r3, r3, #12
  21a8ec:	2b08      	cmp	r3, #8
  21a8ee:	d112      	bne.n	21a916 <HAL_RCC_OscConfig+0x62>
  21a8f0:	4b90      	ldr	r3, [pc, #576]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a8f2:	685b      	ldr	r3, [r3, #4]
  21a8f4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  21a8f8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
  21a8fc:	d10b      	bne.n	21a916 <HAL_RCC_OscConfig+0x62>
    {
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  21a8fe:	4b8d      	ldr	r3, [pc, #564]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a900:	681b      	ldr	r3, [r3, #0]
  21a902:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21a906:	2b00      	cmp	r3, #0
  21a908:	d06c      	beq.n	21a9e4 <HAL_RCC_OscConfig+0x130>
  21a90a:	687b      	ldr	r3, [r7, #4]
  21a90c:	685b      	ldr	r3, [r3, #4]
  21a90e:	2b00      	cmp	r3, #0
  21a910:	d168      	bne.n	21a9e4 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
  21a912:	2301      	movs	r3, #1
  21a914:	e275      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
  21a916:	687b      	ldr	r3, [r7, #4]
  21a918:	685b      	ldr	r3, [r3, #4]
  21a91a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  21a91e:	d106      	bne.n	21a92e <HAL_RCC_OscConfig+0x7a>
  21a920:	4a84      	ldr	r2, [pc, #528]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a922:	4b84      	ldr	r3, [pc, #528]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a924:	681b      	ldr	r3, [r3, #0]
  21a926:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  21a92a:	6013      	str	r3, [r2, #0]
  21a92c:	e02e      	b.n	21a98c <HAL_RCC_OscConfig+0xd8>
  21a92e:	687b      	ldr	r3, [r7, #4]
  21a930:	685b      	ldr	r3, [r3, #4]
  21a932:	2b00      	cmp	r3, #0
  21a934:	d10c      	bne.n	21a950 <HAL_RCC_OscConfig+0x9c>
  21a936:	4a7f      	ldr	r2, [pc, #508]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a938:	4b7e      	ldr	r3, [pc, #504]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a93a:	681b      	ldr	r3, [r3, #0]
  21a93c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  21a940:	6013      	str	r3, [r2, #0]
  21a942:	4a7c      	ldr	r2, [pc, #496]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a944:	4b7b      	ldr	r3, [pc, #492]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a946:	681b      	ldr	r3, [r3, #0]
  21a948:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
  21a94c:	6013      	str	r3, [r2, #0]
  21a94e:	e01d      	b.n	21a98c <HAL_RCC_OscConfig+0xd8>
  21a950:	687b      	ldr	r3, [r7, #4]
  21a952:	685b      	ldr	r3, [r3, #4]
  21a954:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
  21a958:	d10c      	bne.n	21a974 <HAL_RCC_OscConfig+0xc0>
  21a95a:	4a76      	ldr	r2, [pc, #472]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a95c:	4b75      	ldr	r3, [pc, #468]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a95e:	681b      	ldr	r3, [r3, #0]
  21a960:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
  21a964:	6013      	str	r3, [r2, #0]
  21a966:	4a73      	ldr	r2, [pc, #460]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a968:	4b72      	ldr	r3, [pc, #456]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a96a:	681b      	ldr	r3, [r3, #0]
  21a96c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  21a970:	6013      	str	r3, [r2, #0]
  21a972:	e00b      	b.n	21a98c <HAL_RCC_OscConfig+0xd8>
  21a974:	4a6f      	ldr	r2, [pc, #444]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a976:	4b6f      	ldr	r3, [pc, #444]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a978:	681b      	ldr	r3, [r3, #0]
  21a97a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  21a97e:	6013      	str	r3, [r2, #0]
  21a980:	4a6c      	ldr	r2, [pc, #432]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a982:	4b6c      	ldr	r3, [pc, #432]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a984:	681b      	ldr	r3, [r3, #0]
  21a986:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
  21a98a:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
  21a98c:	687b      	ldr	r3, [r7, #4]
  21a98e:	685b      	ldr	r3, [r3, #4]
  21a990:	2b00      	cmp	r3, #0
  21a992:	d013      	beq.n	21a9bc <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21a994:	f7fe fa4c 	bl	218e30 <HAL_GetTick>
  21a998:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  21a99a:	e008      	b.n	21a9ae <HAL_RCC_OscConfig+0xfa>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
  21a99c:	f7fe fa48 	bl	218e30 <HAL_GetTick>
  21a9a0:	4602      	mov	r2, r0
  21a9a2:	693b      	ldr	r3, [r7, #16]
  21a9a4:	1ad3      	subs	r3, r2, r3
  21a9a6:	2b64      	cmp	r3, #100	; 0x64
  21a9a8:	d901      	bls.n	21a9ae <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
  21a9aa:	2303      	movs	r3, #3
  21a9ac:	e229      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  21a9ae:	4b61      	ldr	r3, [pc, #388]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a9b0:	681b      	ldr	r3, [r3, #0]
  21a9b2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21a9b6:	2b00      	cmp	r3, #0
  21a9b8:	d0f0      	beq.n	21a99c <HAL_RCC_OscConfig+0xe8>
  21a9ba:	e014      	b.n	21a9e6 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21a9bc:	f7fe fa38 	bl	218e30 <HAL_GetTick>
  21a9c0:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  21a9c2:	e008      	b.n	21a9d6 <HAL_RCC_OscConfig+0x122>
        {
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
  21a9c4:	f7fe fa34 	bl	218e30 <HAL_GetTick>
  21a9c8:	4602      	mov	r2, r0
  21a9ca:	693b      	ldr	r3, [r7, #16]
  21a9cc:	1ad3      	subs	r3, r2, r3
  21a9ce:	2b64      	cmp	r3, #100	; 0x64
  21a9d0:	d901      	bls.n	21a9d6 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
  21a9d2:	2303      	movs	r3, #3
  21a9d4:	e215      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
  21a9d6:	4b57      	ldr	r3, [pc, #348]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a9d8:	681b      	ldr	r3, [r3, #0]
  21a9da:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21a9de:	2b00      	cmp	r3, #0
  21a9e0:	d1f0      	bne.n	21a9c4 <HAL_RCC_OscConfig+0x110>
  21a9e2:	e000      	b.n	21a9e6 <HAL_RCC_OscConfig+0x132>
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
  21a9e4:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
  21a9e6:	687b      	ldr	r3, [r7, #4]
  21a9e8:	681b      	ldr	r3, [r3, #0]
  21a9ea:	f003 0302 	and.w	r3, r3, #2
  21a9ee:	2b00      	cmp	r3, #0
  21a9f0:	d069      	beq.n	21aac6 <HAL_RCC_OscConfig+0x212>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
  21a9f2:	4b50      	ldr	r3, [pc, #320]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21a9f4:	689b      	ldr	r3, [r3, #8]
  21a9f6:	f003 030c 	and.w	r3, r3, #12
  21a9fa:	2b00      	cmp	r3, #0
  21a9fc:	d00b      	beq.n	21aa16 <HAL_RCC_OscConfig+0x162>
        || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
  21a9fe:	4b4d      	ldr	r3, [pc, #308]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa00:	689b      	ldr	r3, [r3, #8]
  21aa02:	f003 030c 	and.w	r3, r3, #12
  21aa06:	2b08      	cmp	r3, #8
  21aa08:	d11c      	bne.n	21aa44 <HAL_RCC_OscConfig+0x190>
  21aa0a:	4b4a      	ldr	r3, [pc, #296]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa0c:	685b      	ldr	r3, [r3, #4]
  21aa0e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  21aa12:	2b00      	cmp	r3, #0
  21aa14:	d116      	bne.n	21aa44 <HAL_RCC_OscConfig+0x190>
    {
      /* When HSI is used as system clock it will not disabled */
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  21aa16:	4b47      	ldr	r3, [pc, #284]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa18:	681b      	ldr	r3, [r3, #0]
  21aa1a:	f003 0302 	and.w	r3, r3, #2
  21aa1e:	2b00      	cmp	r3, #0
  21aa20:	d005      	beq.n	21aa2e <HAL_RCC_OscConfig+0x17a>
  21aa22:	687b      	ldr	r3, [r7, #4]
  21aa24:	68db      	ldr	r3, [r3, #12]
  21aa26:	2b01      	cmp	r3, #1
  21aa28:	d001      	beq.n	21aa2e <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
  21aa2a:	2301      	movs	r3, #1
  21aa2c:	e1e9      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  21aa2e:	4941      	ldr	r1, [pc, #260]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa30:	4b40      	ldr	r3, [pc, #256]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa32:	681b      	ldr	r3, [r3, #0]
  21aa34:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
  21aa38:	687b      	ldr	r3, [r7, #4]
  21aa3a:	691b      	ldr	r3, [r3, #16]
  21aa3c:	00db      	lsls	r3, r3, #3
  21aa3e:	4313      	orrs	r3, r2
  21aa40:	600b      	str	r3, [r1, #0]
      if ((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
  21aa42:	e040      	b.n	21aac6 <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if ((RCC_OscInitStruct->HSIState) != RCC_HSI_OFF)
  21aa44:	687b      	ldr	r3, [r7, #4]
  21aa46:	68db      	ldr	r3, [r3, #12]
  21aa48:	2b00      	cmp	r3, #0
  21aa4a:	d023      	beq.n	21aa94 <HAL_RCC_OscConfig+0x1e0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
  21aa4c:	4a39      	ldr	r2, [pc, #228]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa4e:	4b39      	ldr	r3, [pc, #228]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa50:	681b      	ldr	r3, [r3, #0]
  21aa52:	f043 0301 	orr.w	r3, r3, #1
  21aa56:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21aa58:	f7fe f9ea 	bl	218e30 <HAL_GetTick>
  21aa5c:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  21aa5e:	e008      	b.n	21aa72 <HAL_RCC_OscConfig+0x1be>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
  21aa60:	f7fe f9e6 	bl	218e30 <HAL_GetTick>
  21aa64:	4602      	mov	r2, r0
  21aa66:	693b      	ldr	r3, [r7, #16]
  21aa68:	1ad3      	subs	r3, r2, r3
  21aa6a:	2b02      	cmp	r3, #2
  21aa6c:	d901      	bls.n	21aa72 <HAL_RCC_OscConfig+0x1be>
          {
            return HAL_TIMEOUT;
  21aa6e:	2303      	movs	r3, #3
  21aa70:	e1c7      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  21aa72:	4b30      	ldr	r3, [pc, #192]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa74:	681b      	ldr	r3, [r3, #0]
  21aa76:	f003 0302 	and.w	r3, r3, #2
  21aa7a:	2b00      	cmp	r3, #0
  21aa7c:	d0f0      	beq.n	21aa60 <HAL_RCC_OscConfig+0x1ac>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
  21aa7e:	492d      	ldr	r1, [pc, #180]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa80:	4b2c      	ldr	r3, [pc, #176]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa82:	681b      	ldr	r3, [r3, #0]
  21aa84:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
  21aa88:	687b      	ldr	r3, [r7, #4]
  21aa8a:	691b      	ldr	r3, [r3, #16]
  21aa8c:	00db      	lsls	r3, r3, #3
  21aa8e:	4313      	orrs	r3, r2
  21aa90:	600b      	str	r3, [r1, #0]
  21aa92:	e018      	b.n	21aac6 <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
  21aa94:	4a27      	ldr	r2, [pc, #156]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa96:	4b27      	ldr	r3, [pc, #156]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aa98:	681b      	ldr	r3, [r3, #0]
  21aa9a:	f023 0301 	bic.w	r3, r3, #1
  21aa9e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21aaa0:	f7fe f9c6 	bl	218e30 <HAL_GetTick>
  21aaa4:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
  21aaa6:	e008      	b.n	21aaba <HAL_RCC_OscConfig+0x206>
        {
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
  21aaa8:	f7fe f9c2 	bl	218e30 <HAL_GetTick>
  21aaac:	4602      	mov	r2, r0
  21aaae:	693b      	ldr	r3, [r7, #16]
  21aab0:	1ad3      	subs	r3, r2, r3
  21aab2:	2b02      	cmp	r3, #2
  21aab4:	d901      	bls.n	21aaba <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
  21aab6:	2303      	movs	r3, #3
  21aab8:	e1a3      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
  21aaba:	4b1e      	ldr	r3, [pc, #120]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aabc:	681b      	ldr	r3, [r3, #0]
  21aabe:	f003 0302 	and.w	r3, r3, #2
  21aac2:	2b00      	cmp	r3, #0
  21aac4:	d1f0      	bne.n	21aaa8 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
  21aac6:	687b      	ldr	r3, [r7, #4]
  21aac8:	681b      	ldr	r3, [r3, #0]
  21aaca:	f003 0308 	and.w	r3, r3, #8
  21aace:	2b00      	cmp	r3, #0
  21aad0:	d038      	beq.n	21ab44 <HAL_RCC_OscConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if ((RCC_OscInitStruct->LSIState) != RCC_LSI_OFF)
  21aad2:	687b      	ldr	r3, [r7, #4]
  21aad4:	695b      	ldr	r3, [r3, #20]
  21aad6:	2b00      	cmp	r3, #0
  21aad8:	d019      	beq.n	21ab0e <HAL_RCC_OscConfig+0x25a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
  21aada:	4a16      	ldr	r2, [pc, #88]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aadc:	4b15      	ldr	r3, [pc, #84]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21aade:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  21aae0:	f043 0301 	orr.w	r3, r3, #1
  21aae4:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
  21aae6:	f7fe f9a3 	bl	218e30 <HAL_GetTick>
  21aaea:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
  21aaec:	e008      	b.n	21ab00 <HAL_RCC_OscConfig+0x24c>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
  21aaee:	f7fe f99f 	bl	218e30 <HAL_GetTick>
  21aaf2:	4602      	mov	r2, r0
  21aaf4:	693b      	ldr	r3, [r7, #16]
  21aaf6:	1ad3      	subs	r3, r2, r3
  21aaf8:	2b02      	cmp	r3, #2
  21aafa:	d901      	bls.n	21ab00 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
  21aafc:	2303      	movs	r3, #3
  21aafe:	e180      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
  21ab00:	4b0c      	ldr	r3, [pc, #48]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21ab02:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  21ab04:	f003 0302 	and.w	r3, r3, #2
  21ab08:	2b00      	cmp	r3, #0
  21ab0a:	d0f0      	beq.n	21aaee <HAL_RCC_OscConfig+0x23a>
  21ab0c:	e01a      	b.n	21ab44 <HAL_RCC_OscConfig+0x290>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
  21ab0e:	4a09      	ldr	r2, [pc, #36]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21ab10:	4b08      	ldr	r3, [pc, #32]	; (21ab34 <HAL_RCC_OscConfig+0x280>)
  21ab12:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  21ab14:	f023 0301 	bic.w	r3, r3, #1
  21ab18:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
  21ab1a:	f7fe f989 	bl	218e30 <HAL_GetTick>
  21ab1e:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
  21ab20:	e00a      	b.n	21ab38 <HAL_RCC_OscConfig+0x284>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
  21ab22:	f7fe f985 	bl	218e30 <HAL_GetTick>
  21ab26:	4602      	mov	r2, r0
  21ab28:	693b      	ldr	r3, [r7, #16]
  21ab2a:	1ad3      	subs	r3, r2, r3
  21ab2c:	2b02      	cmp	r3, #2
  21ab2e:	d903      	bls.n	21ab38 <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
  21ab30:	2303      	movs	r3, #3
  21ab32:	e166      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
  21ab34:	40023800 	.word	0x40023800
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
  21ab38:	4b92      	ldr	r3, [pc, #584]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ab3a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  21ab3c:	f003 0302 	and.w	r3, r3, #2
  21ab40:	2b00      	cmp	r3, #0
  21ab42:	d1ee      	bne.n	21ab22 <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
  21ab44:	687b      	ldr	r3, [r7, #4]
  21ab46:	681b      	ldr	r3, [r3, #0]
  21ab48:	f003 0304 	and.w	r3, r3, #4
  21ab4c:	2b00      	cmp	r3, #0
  21ab4e:	f000 80a4 	beq.w	21ac9a <HAL_RCC_OscConfig+0x3e6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED())
  21ab52:	4b8c      	ldr	r3, [pc, #560]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ab54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21ab56:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21ab5a:	2b00      	cmp	r3, #0
  21ab5c:	d10d      	bne.n	21ab7a <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
  21ab5e:	4a89      	ldr	r2, [pc, #548]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ab60:	4b88      	ldr	r3, [pc, #544]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ab62:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21ab64:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  21ab68:	6413      	str	r3, [r2, #64]	; 0x40
  21ab6a:	4b86      	ldr	r3, [pc, #536]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ab6c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21ab6e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21ab72:	60bb      	str	r3, [r7, #8]
  21ab74:	68bb      	ldr	r3, [r7, #8]
      pwrclkchanged = SET;
  21ab76:	2301      	movs	r3, #1
  21ab78:	75fb      	strb	r3, [r7, #23]
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
  21ab7a:	4b83      	ldr	r3, [pc, #524]	; (21ad88 <HAL_RCC_OscConfig+0x4d4>)
  21ab7c:	681b      	ldr	r3, [r3, #0]
  21ab7e:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21ab82:	2b00      	cmp	r3, #0
  21ab84:	d118      	bne.n	21abb8 <HAL_RCC_OscConfig+0x304>
    {
      /* Enable write access to Backup domain */
      PWR->CR1 |= PWR_CR1_DBP;
  21ab86:	4a80      	ldr	r2, [pc, #512]	; (21ad88 <HAL_RCC_OscConfig+0x4d4>)
  21ab88:	4b7f      	ldr	r3, [pc, #508]	; (21ad88 <HAL_RCC_OscConfig+0x4d4>)
  21ab8a:	681b      	ldr	r3, [r3, #0]
  21ab8c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  21ab90:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
  21ab92:	f7fe f94d 	bl	218e30 <HAL_GetTick>
  21ab96:	6138      	str	r0, [r7, #16]

      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
  21ab98:	e008      	b.n	21abac <HAL_RCC_OscConfig+0x2f8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
  21ab9a:	f7fe f949 	bl	218e30 <HAL_GetTick>
  21ab9e:	4602      	mov	r2, r0
  21aba0:	693b      	ldr	r3, [r7, #16]
  21aba2:	1ad3      	subs	r3, r2, r3
  21aba4:	2b64      	cmp	r3, #100	; 0x64
  21aba6:	d901      	bls.n	21abac <HAL_RCC_OscConfig+0x2f8>
        {
          return HAL_TIMEOUT;
  21aba8:	2303      	movs	r3, #3
  21abaa:	e12a      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
  21abac:	4b76      	ldr	r3, [pc, #472]	; (21ad88 <HAL_RCC_OscConfig+0x4d4>)
  21abae:	681b      	ldr	r3, [r3, #0]
  21abb0:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21abb4:	2b00      	cmp	r3, #0
  21abb6:	d0f0      	beq.n	21ab9a <HAL_RCC_OscConfig+0x2e6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
  21abb8:	687b      	ldr	r3, [r7, #4]
  21abba:	689b      	ldr	r3, [r3, #8]
  21abbc:	2b01      	cmp	r3, #1
  21abbe:	d106      	bne.n	21abce <HAL_RCC_OscConfig+0x31a>
  21abc0:	4a70      	ldr	r2, [pc, #448]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abc2:	4b70      	ldr	r3, [pc, #448]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abc4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21abc6:	f043 0301 	orr.w	r3, r3, #1
  21abca:	6713      	str	r3, [r2, #112]	; 0x70
  21abcc:	e02d      	b.n	21ac2a <HAL_RCC_OscConfig+0x376>
  21abce:	687b      	ldr	r3, [r7, #4]
  21abd0:	689b      	ldr	r3, [r3, #8]
  21abd2:	2b00      	cmp	r3, #0
  21abd4:	d10c      	bne.n	21abf0 <HAL_RCC_OscConfig+0x33c>
  21abd6:	4a6b      	ldr	r2, [pc, #428]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abd8:	4b6a      	ldr	r3, [pc, #424]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abda:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21abdc:	f023 0301 	bic.w	r3, r3, #1
  21abe0:	6713      	str	r3, [r2, #112]	; 0x70
  21abe2:	4a68      	ldr	r2, [pc, #416]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abe4:	4b67      	ldr	r3, [pc, #412]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abe6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21abe8:	f023 0304 	bic.w	r3, r3, #4
  21abec:	6713      	str	r3, [r2, #112]	; 0x70
  21abee:	e01c      	b.n	21ac2a <HAL_RCC_OscConfig+0x376>
  21abf0:	687b      	ldr	r3, [r7, #4]
  21abf2:	689b      	ldr	r3, [r3, #8]
  21abf4:	2b05      	cmp	r3, #5
  21abf6:	d10c      	bne.n	21ac12 <HAL_RCC_OscConfig+0x35e>
  21abf8:	4a62      	ldr	r2, [pc, #392]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abfa:	4b62      	ldr	r3, [pc, #392]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21abfc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21abfe:	f043 0304 	orr.w	r3, r3, #4
  21ac02:	6713      	str	r3, [r2, #112]	; 0x70
  21ac04:	4a5f      	ldr	r2, [pc, #380]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac06:	4b5f      	ldr	r3, [pc, #380]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac08:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21ac0a:	f043 0301 	orr.w	r3, r3, #1
  21ac0e:	6713      	str	r3, [r2, #112]	; 0x70
  21ac10:	e00b      	b.n	21ac2a <HAL_RCC_OscConfig+0x376>
  21ac12:	4a5c      	ldr	r2, [pc, #368]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac14:	4b5b      	ldr	r3, [pc, #364]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac16:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21ac18:	f023 0301 	bic.w	r3, r3, #1
  21ac1c:	6713      	str	r3, [r2, #112]	; 0x70
  21ac1e:	4a59      	ldr	r2, [pc, #356]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac20:	4b58      	ldr	r3, [pc, #352]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac22:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21ac24:	f023 0304 	bic.w	r3, r3, #4
  21ac28:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if ((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
  21ac2a:	687b      	ldr	r3, [r7, #4]
  21ac2c:	689b      	ldr	r3, [r3, #8]
  21ac2e:	2b00      	cmp	r3, #0
  21ac30:	d015      	beq.n	21ac5e <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
  21ac32:	f7fe f8fd 	bl	218e30 <HAL_GetTick>
  21ac36:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  21ac38:	e00a      	b.n	21ac50 <HAL_RCC_OscConfig+0x39c>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
  21ac3a:	f7fe f8f9 	bl	218e30 <HAL_GetTick>
  21ac3e:	4602      	mov	r2, r0
  21ac40:	693b      	ldr	r3, [r7, #16]
  21ac42:	1ad3      	subs	r3, r2, r3
  21ac44:	f241 3288 	movw	r2, #5000	; 0x1388
  21ac48:	4293      	cmp	r3, r2
  21ac4a:	d901      	bls.n	21ac50 <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
  21ac4c:	2303      	movs	r3, #3
  21ac4e:	e0d8      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  21ac50:	4b4c      	ldr	r3, [pc, #304]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac52:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21ac54:	f003 0302 	and.w	r3, r3, #2
  21ac58:	2b00      	cmp	r3, #0
  21ac5a:	d0ee      	beq.n	21ac3a <HAL_RCC_OscConfig+0x386>
  21ac5c:	e014      	b.n	21ac88 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
  21ac5e:	f7fe f8e7 	bl	218e30 <HAL_GetTick>
  21ac62:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
  21ac64:	e00a      	b.n	21ac7c <HAL_RCC_OscConfig+0x3c8>
      {
        if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
  21ac66:	f7fe f8e3 	bl	218e30 <HAL_GetTick>
  21ac6a:	4602      	mov	r2, r0
  21ac6c:	693b      	ldr	r3, [r7, #16]
  21ac6e:	1ad3      	subs	r3, r2, r3
  21ac70:	f241 3288 	movw	r2, #5000	; 0x1388
  21ac74:	4293      	cmp	r3, r2
  21ac76:	d901      	bls.n	21ac7c <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
  21ac78:	2303      	movs	r3, #3
  21ac7a:	e0c2      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
  21ac7c:	4b41      	ldr	r3, [pc, #260]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac7e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21ac80:	f003 0302 	and.w	r3, r3, #2
  21ac84:	2b00      	cmp	r3, #0
  21ac86:	d1ee      	bne.n	21ac66 <HAL_RCC_OscConfig+0x3b2>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
  21ac88:	7dfb      	ldrb	r3, [r7, #23]
  21ac8a:	2b01      	cmp	r3, #1
  21ac8c:	d105      	bne.n	21ac9a <HAL_RCC_OscConfig+0x3e6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
  21ac8e:	4a3d      	ldr	r2, [pc, #244]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac90:	4b3c      	ldr	r3, [pc, #240]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ac92:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21ac94:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  21ac98:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  21ac9a:	687b      	ldr	r3, [r7, #4]
  21ac9c:	699b      	ldr	r3, [r3, #24]
  21ac9e:	2b00      	cmp	r3, #0
  21aca0:	f000 80ae 	beq.w	21ae00 <HAL_RCC_OscConfig+0x54c>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
  21aca4:	4b37      	ldr	r3, [pc, #220]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21aca6:	689b      	ldr	r3, [r3, #8]
  21aca8:	f003 030c 	and.w	r3, r3, #12
  21acac:	2b08      	cmp	r3, #8
  21acae:	d06d      	beq.n	21ad8c <HAL_RCC_OscConfig+0x4d8>
    {
      if ((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
  21acb0:	687b      	ldr	r3, [r7, #4]
  21acb2:	699b      	ldr	r3, [r3, #24]
  21acb4:	2b02      	cmp	r3, #2
  21acb6:	d14b      	bne.n	21ad50 <HAL_RCC_OscConfig+0x49c>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
  21acb8:	4a32      	ldr	r2, [pc, #200]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21acba:	4b32      	ldr	r3, [pc, #200]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21acbc:	681b      	ldr	r3, [r3, #0]
  21acbe:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  21acc2:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21acc4:	f7fe f8b4 	bl	218e30 <HAL_GetTick>
  21acc8:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
  21acca:	e008      	b.n	21acde <HAL_RCC_OscConfig+0x42a>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
  21accc:	f7fe f8b0 	bl	218e30 <HAL_GetTick>
  21acd0:	4602      	mov	r2, r0
  21acd2:	693b      	ldr	r3, [r7, #16]
  21acd4:	1ad3      	subs	r3, r2, r3
  21acd6:	2b02      	cmp	r3, #2
  21acd8:	d901      	bls.n	21acde <HAL_RCC_OscConfig+0x42a>
          {
            return HAL_TIMEOUT;
  21acda:	2303      	movs	r3, #3
  21acdc:	e091      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
  21acde:	4b29      	ldr	r3, [pc, #164]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ace0:	681b      	ldr	r3, [r3, #0]
  21ace2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21ace6:	2b00      	cmp	r3, #0
  21ace8:	d1f0      	bne.n	21accc <HAL_RCC_OscConfig+0x418>
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
#if defined (RCC_PLLCFGR_PLLR)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
  21acea:	4926      	ldr	r1, [pc, #152]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21acec:	687b      	ldr	r3, [r7, #4]
  21acee:	69da      	ldr	r2, [r3, #28]
  21acf0:	687b      	ldr	r3, [r7, #4]
  21acf2:	6a1b      	ldr	r3, [r3, #32]
  21acf4:	431a      	orrs	r2, r3
  21acf6:	687b      	ldr	r3, [r7, #4]
  21acf8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21acfa:	019b      	lsls	r3, r3, #6
  21acfc:	431a      	orrs	r2, r3
  21acfe:	687b      	ldr	r3, [r7, #4]
  21ad00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  21ad02:	085b      	lsrs	r3, r3, #1
  21ad04:	3b01      	subs	r3, #1
  21ad06:	041b      	lsls	r3, r3, #16
  21ad08:	431a      	orrs	r2, r3
  21ad0a:	687b      	ldr	r3, [r7, #4]
  21ad0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21ad0e:	061b      	lsls	r3, r3, #24
  21ad10:	431a      	orrs	r2, r3
  21ad12:	687b      	ldr	r3, [r7, #4]
  21ad14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21ad16:	071b      	lsls	r3, r3, #28
  21ad18:	4313      	orrs	r3, r2
  21ad1a:	604b      	str	r3, [r1, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
  21ad1c:	4a19      	ldr	r2, [pc, #100]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ad1e:	4b19      	ldr	r3, [pc, #100]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ad20:	681b      	ldr	r3, [r3, #0]
  21ad22:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  21ad26:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21ad28:	f7fe f882 	bl	218e30 <HAL_GetTick>
  21ad2c:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
  21ad2e:	e008      	b.n	21ad42 <HAL_RCC_OscConfig+0x48e>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
  21ad30:	f7fe f87e 	bl	218e30 <HAL_GetTick>
  21ad34:	4602      	mov	r2, r0
  21ad36:	693b      	ldr	r3, [r7, #16]
  21ad38:	1ad3      	subs	r3, r2, r3
  21ad3a:	2b02      	cmp	r3, #2
  21ad3c:	d901      	bls.n	21ad42 <HAL_RCC_OscConfig+0x48e>
          {
            return HAL_TIMEOUT;
  21ad3e:	2303      	movs	r3, #3
  21ad40:	e05f      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
  21ad42:	4b10      	ldr	r3, [pc, #64]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ad44:	681b      	ldr	r3, [r3, #0]
  21ad46:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21ad4a:	2b00      	cmp	r3, #0
  21ad4c:	d0f0      	beq.n	21ad30 <HAL_RCC_OscConfig+0x47c>
  21ad4e:	e057      	b.n	21ae00 <HAL_RCC_OscConfig+0x54c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
  21ad50:	4a0c      	ldr	r2, [pc, #48]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ad52:	4b0c      	ldr	r3, [pc, #48]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ad54:	681b      	ldr	r3, [r3, #0]
  21ad56:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  21ad5a:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21ad5c:	f7fe f868 	bl	218e30 <HAL_GetTick>
  21ad60:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
  21ad62:	e008      	b.n	21ad76 <HAL_RCC_OscConfig+0x4c2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
  21ad64:	f7fe f864 	bl	218e30 <HAL_GetTick>
  21ad68:	4602      	mov	r2, r0
  21ad6a:	693b      	ldr	r3, [r7, #16]
  21ad6c:	1ad3      	subs	r3, r2, r3
  21ad6e:	2b02      	cmp	r3, #2
  21ad70:	d901      	bls.n	21ad76 <HAL_RCC_OscConfig+0x4c2>
          {
            return HAL_TIMEOUT;
  21ad72:	2303      	movs	r3, #3
  21ad74:	e045      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
  21ad76:	4b03      	ldr	r3, [pc, #12]	; (21ad84 <HAL_RCC_OscConfig+0x4d0>)
  21ad78:	681b      	ldr	r3, [r3, #0]
  21ad7a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21ad7e:	2b00      	cmp	r3, #0
  21ad80:	d1f0      	bne.n	21ad64 <HAL_RCC_OscConfig+0x4b0>
  21ad82:	e03d      	b.n	21ae00 <HAL_RCC_OscConfig+0x54c>
  21ad84:	40023800 	.word	0x40023800
  21ad88:	40007000 	.word	0x40007000
      }
    }
    else
    {
      /* Do not return HAL_ERROR if request repeats the current configuration */
      pll_config = RCC->PLLCFGR;
  21ad8c:	4b1f      	ldr	r3, [pc, #124]	; (21ae0c <HAL_RCC_OscConfig+0x558>)
  21ad8e:	685b      	ldr	r3, [r3, #4]
  21ad90:	60fb      	str	r3, [r7, #12]
#if defined (RCC_PLLCFGR_PLLR)
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
  21ad92:	687b      	ldr	r3, [r7, #4]
  21ad94:	699b      	ldr	r3, [r3, #24]
  21ad96:	2b01      	cmp	r3, #1
  21ad98:	d030      	beq.n	21adfc <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
  21ad9a:	68fb      	ldr	r3, [r7, #12]
  21ad9c:	f403 0280 	and.w	r2, r3, #4194304	; 0x400000
  21ada0:	687b      	ldr	r3, [r7, #4]
  21ada2:	69db      	ldr	r3, [r3, #28]
      if (((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
  21ada4:	429a      	cmp	r2, r3
  21ada6:	d129      	bne.n	21adfc <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
  21ada8:	68fb      	ldr	r3, [r7, #12]
  21adaa:	f003 023f 	and.w	r2, r3, #63	; 0x3f
  21adae:	687b      	ldr	r3, [r7, #4]
  21adb0:	6a1b      	ldr	r3, [r3, #32]
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
  21adb2:	429a      	cmp	r2, r3
  21adb4:	d122      	bne.n	21adfc <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
  21adb6:	68fa      	ldr	r2, [r7, #12]
  21adb8:	f647 73c0 	movw	r3, #32704	; 0x7fc0
  21adbc:	4013      	ands	r3, r2
  21adbe:	687a      	ldr	r2, [r7, #4]
  21adc0:	6a52      	ldr	r2, [r2, #36]	; 0x24
  21adc2:	0192      	lsls	r2, r2, #6
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLM) != RCC_OscInitStruct->PLL.PLLM) ||
  21adc4:	4293      	cmp	r3, r2
  21adc6:	d119      	bne.n	21adfc <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
  21adc8:	68fb      	ldr	r3, [r7, #12]
  21adca:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
  21adce:	687b      	ldr	r3, [r7, #4]
  21add0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  21add2:	085b      	lsrs	r3, r3, #1
  21add4:	3b01      	subs	r3, #1
  21add6:	041b      	lsls	r3, r3, #16
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
  21add8:	429a      	cmp	r2, r3
  21adda:	d10f      	bne.n	21adfc <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
  21addc:	68fb      	ldr	r3, [r7, #12]
  21adde:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
  21ade2:	687b      	ldr	r3, [r7, #4]
  21ade4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21ade6:	061b      	lsls	r3, r3, #24
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
  21ade8:	429a      	cmp	r2, r3
  21adea:	d107      	bne.n	21adfc <HAL_RCC_OscConfig+0x548>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLR) != (RCC_OscInitStruct->PLL.PLLR << RCC_PLLCFGR_PLLR_Pos)))
  21adec:	68fb      	ldr	r3, [r7, #12]
  21adee:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
  21adf2:	687b      	ldr	r3, [r7, #4]
  21adf4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21adf6:	071b      	lsls	r3, r3, #28
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)) ||
  21adf8:	429a      	cmp	r2, r3
  21adfa:	d001      	beq.n	21ae00 <HAL_RCC_OscConfig+0x54c>
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLN) != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLP) != ((((RCC_OscInitStruct->PLL.PLLP) >> 1U) - 1U) << RCC_PLLCFGR_PLLP_Pos)) ||
          (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ) != (RCC_OscInitStruct->PLL.PLLQ << RCC_PLLCFGR_PLLQ_Pos)))
#endif
      {
        return HAL_ERROR;
  21adfc:	2301      	movs	r3, #1
  21adfe:	e000      	b.n	21ae02 <HAL_RCC_OscConfig+0x54e>
      }
    }
  }
  return HAL_OK;
  21ae00:	2300      	movs	r3, #0
}
  21ae02:	4618      	mov	r0, r3
  21ae04:	3718      	adds	r7, #24
  21ae06:	46bd      	mov	sp, r7
  21ae08:	bd80      	pop	{r7, pc}
  21ae0a:	bf00      	nop
  21ae0c:	40023800 	.word	0x40023800

0021ae10 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
  21ae10:	b580      	push	{r7, lr}
  21ae12:	b084      	sub	sp, #16
  21ae14:	af00      	add	r7, sp, #0
  21ae16:	6078      	str	r0, [r7, #4]
  21ae18:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
  21ae1a:	2300      	movs	r3, #0
  21ae1c:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if (RCC_ClkInitStruct == NULL)
  21ae1e:	687b      	ldr	r3, [r7, #4]
  21ae20:	2b00      	cmp	r3, #0
  21ae22:	d101      	bne.n	21ae28 <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
  21ae24:	2301      	movs	r3, #1
  21ae26:	e0d0      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if (FLatency > __HAL_FLASH_GET_LATENCY())
  21ae28:	4b6a      	ldr	r3, [pc, #424]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21ae2a:	681b      	ldr	r3, [r3, #0]
  21ae2c:	f003 020f 	and.w	r2, r3, #15
  21ae30:	683b      	ldr	r3, [r7, #0]
  21ae32:	429a      	cmp	r2, r3
  21ae34:	d210      	bcs.n	21ae58 <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
  21ae36:	4967      	ldr	r1, [pc, #412]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21ae38:	4b66      	ldr	r3, [pc, #408]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21ae3a:	681b      	ldr	r3, [r3, #0]
  21ae3c:	f023 020f 	bic.w	r2, r3, #15
  21ae40:	683b      	ldr	r3, [r7, #0]
  21ae42:	4313      	orrs	r3, r2
  21ae44:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
  21ae46:	4b63      	ldr	r3, [pc, #396]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21ae48:	681b      	ldr	r3, [r3, #0]
  21ae4a:	f003 020f 	and.w	r2, r3, #15
  21ae4e:	683b      	ldr	r3, [r7, #0]
  21ae50:	429a      	cmp	r2, r3
  21ae52:	d001      	beq.n	21ae58 <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
  21ae54:	2301      	movs	r3, #1
  21ae56:	e0b8      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
  21ae58:	687b      	ldr	r3, [r7, #4]
  21ae5a:	681b      	ldr	r3, [r3, #0]
  21ae5c:	f003 0302 	and.w	r3, r3, #2
  21ae60:	2b00      	cmp	r3, #0
  21ae62:	d020      	beq.n	21aea6 <HAL_RCC_ClockConfig+0x96>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
  21ae64:	687b      	ldr	r3, [r7, #4]
  21ae66:	681b      	ldr	r3, [r3, #0]
  21ae68:	f003 0304 	and.w	r3, r3, #4
  21ae6c:	2b00      	cmp	r3, #0
  21ae6e:	d005      	beq.n	21ae7c <HAL_RCC_ClockConfig+0x6c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
  21ae70:	4a59      	ldr	r2, [pc, #356]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21ae72:	4b59      	ldr	r3, [pc, #356]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21ae74:	689b      	ldr	r3, [r3, #8]
  21ae76:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
  21ae7a:	6093      	str	r3, [r2, #8]
    }

    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
  21ae7c:	687b      	ldr	r3, [r7, #4]
  21ae7e:	681b      	ldr	r3, [r3, #0]
  21ae80:	f003 0308 	and.w	r3, r3, #8
  21ae84:	2b00      	cmp	r3, #0
  21ae86:	d005      	beq.n	21ae94 <HAL_RCC_ClockConfig+0x84>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
  21ae88:	4a53      	ldr	r2, [pc, #332]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21ae8a:	4b53      	ldr	r3, [pc, #332]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21ae8c:	689b      	ldr	r3, [r3, #8]
  21ae8e:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
  21ae92:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  21ae94:	4950      	ldr	r1, [pc, #320]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21ae96:	4b50      	ldr	r3, [pc, #320]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21ae98:	689b      	ldr	r3, [r3, #8]
  21ae9a:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
  21ae9e:	687b      	ldr	r3, [r7, #4]
  21aea0:	689b      	ldr	r3, [r3, #8]
  21aea2:	4313      	orrs	r3, r2
  21aea4:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  21aea6:	687b      	ldr	r3, [r7, #4]
  21aea8:	681b      	ldr	r3, [r3, #0]
  21aeaa:	f003 0301 	and.w	r3, r3, #1
  21aeae:	2b00      	cmp	r3, #0
  21aeb0:	d040      	beq.n	21af34 <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
  21aeb2:	687b      	ldr	r3, [r7, #4]
  21aeb4:	685b      	ldr	r3, [r3, #4]
  21aeb6:	2b01      	cmp	r3, #1
  21aeb8:	d107      	bne.n	21aeca <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the HSE ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
  21aeba:	4b47      	ldr	r3, [pc, #284]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21aebc:	681b      	ldr	r3, [r3, #0]
  21aebe:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21aec2:	2b00      	cmp	r3, #0
  21aec4:	d115      	bne.n	21aef2 <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
  21aec6:	2301      	movs	r3, #1
  21aec8:	e07f      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
      }
    }
    /* PLL is selected as System Clock Source */
    else if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
  21aeca:	687b      	ldr	r3, [r7, #4]
  21aecc:	685b      	ldr	r3, [r3, #4]
  21aece:	2b02      	cmp	r3, #2
  21aed0:	d107      	bne.n	21aee2 <HAL_RCC_ClockConfig+0xd2>
    {
      /* Check the PLL ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
  21aed2:	4b41      	ldr	r3, [pc, #260]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21aed4:	681b      	ldr	r3, [r3, #0]
  21aed6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21aeda:	2b00      	cmp	r3, #0
  21aedc:	d109      	bne.n	21aef2 <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
  21aede:	2301      	movs	r3, #1
  21aee0:	e073      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
  21aee2:	4b3d      	ldr	r3, [pc, #244]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21aee4:	681b      	ldr	r3, [r3, #0]
  21aee6:	f003 0302 	and.w	r3, r3, #2
  21aeea:	2b00      	cmp	r3, #0
  21aeec:	d101      	bne.n	21aef2 <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
  21aeee:	2301      	movs	r3, #1
  21aef0:	e06b      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
  21aef2:	4939      	ldr	r1, [pc, #228]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21aef4:	4b38      	ldr	r3, [pc, #224]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21aef6:	689b      	ldr	r3, [r3, #8]
  21aef8:	f023 0203 	bic.w	r2, r3, #3
  21aefc:	687b      	ldr	r3, [r7, #4]
  21aefe:	685b      	ldr	r3, [r3, #4]
  21af00:	4313      	orrs	r3, r2
  21af02:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  21af04:	f7fd ff94 	bl	218e30 <HAL_GetTick>
  21af08:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
  21af0a:	e00a      	b.n	21af22 <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
  21af0c:	f7fd ff90 	bl	218e30 <HAL_GetTick>
  21af10:	4602      	mov	r2, r0
  21af12:	68fb      	ldr	r3, [r7, #12]
  21af14:	1ad3      	subs	r3, r2, r3
  21af16:	f241 3288 	movw	r2, #5000	; 0x1388
  21af1a:	4293      	cmp	r3, r2
  21af1c:	d901      	bls.n	21af22 <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
  21af1e:	2303      	movs	r3, #3
  21af20:	e053      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
  21af22:	4b2d      	ldr	r3, [pc, #180]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21af24:	689b      	ldr	r3, [r3, #8]
  21af26:	f003 020c 	and.w	r2, r3, #12
  21af2a:	687b      	ldr	r3, [r7, #4]
  21af2c:	685b      	ldr	r3, [r3, #4]
  21af2e:	009b      	lsls	r3, r3, #2
  21af30:	429a      	cmp	r2, r3
  21af32:	d1eb      	bne.n	21af0c <HAL_RCC_ClockConfig+0xfc>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if (FLatency < __HAL_FLASH_GET_LATENCY())
  21af34:	4b27      	ldr	r3, [pc, #156]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21af36:	681b      	ldr	r3, [r3, #0]
  21af38:	f003 020f 	and.w	r2, r3, #15
  21af3c:	683b      	ldr	r3, [r7, #0]
  21af3e:	429a      	cmp	r2, r3
  21af40:	d910      	bls.n	21af64 <HAL_RCC_ClockConfig+0x154>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
  21af42:	4924      	ldr	r1, [pc, #144]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21af44:	4b23      	ldr	r3, [pc, #140]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21af46:	681b      	ldr	r3, [r3, #0]
  21af48:	f023 020f 	bic.w	r2, r3, #15
  21af4c:	683b      	ldr	r3, [r7, #0]
  21af4e:	4313      	orrs	r3, r2
  21af50:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
  21af52:	4b20      	ldr	r3, [pc, #128]	; (21afd4 <HAL_RCC_ClockConfig+0x1c4>)
  21af54:	681b      	ldr	r3, [r3, #0]
  21af56:	f003 020f 	and.w	r2, r3, #15
  21af5a:	683b      	ldr	r3, [r7, #0]
  21af5c:	429a      	cmp	r2, r3
  21af5e:	d001      	beq.n	21af64 <HAL_RCC_ClockConfig+0x154>
    {
      return HAL_ERROR;
  21af60:	2301      	movs	r3, #1
  21af62:	e032      	b.n	21afca <HAL_RCC_ClockConfig+0x1ba>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
  21af64:	687b      	ldr	r3, [r7, #4]
  21af66:	681b      	ldr	r3, [r3, #0]
  21af68:	f003 0304 	and.w	r3, r3, #4
  21af6c:	2b00      	cmp	r3, #0
  21af6e:	d008      	beq.n	21af82 <HAL_RCC_ClockConfig+0x172>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
  21af70:	4919      	ldr	r1, [pc, #100]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21af72:	4b19      	ldr	r3, [pc, #100]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21af74:	689b      	ldr	r3, [r3, #8]
  21af76:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
  21af7a:	687b      	ldr	r3, [r7, #4]
  21af7c:	68db      	ldr	r3, [r3, #12]
  21af7e:	4313      	orrs	r3, r2
  21af80:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
  21af82:	687b      	ldr	r3, [r7, #4]
  21af84:	681b      	ldr	r3, [r3, #0]
  21af86:	f003 0308 	and.w	r3, r3, #8
  21af8a:	2b00      	cmp	r3, #0
  21af8c:	d009      	beq.n	21afa2 <HAL_RCC_ClockConfig+0x192>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
  21af8e:	4912      	ldr	r1, [pc, #72]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21af90:	4b11      	ldr	r3, [pc, #68]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21af92:	689b      	ldr	r3, [r3, #8]
  21af94:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
  21af98:	687b      	ldr	r3, [r7, #4]
  21af9a:	691b      	ldr	r3, [r3, #16]
  21af9c:	00db      	lsls	r3, r3, #3
  21af9e:	4313      	orrs	r3, r2
  21afa0:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
  21afa2:	f000 f821 	bl	21afe8 <HAL_RCC_GetSysClockFreq>
  21afa6:	4601      	mov	r1, r0
  21afa8:	4b0b      	ldr	r3, [pc, #44]	; (21afd8 <HAL_RCC_ClockConfig+0x1c8>)
  21afaa:	689b      	ldr	r3, [r3, #8]
  21afac:	091b      	lsrs	r3, r3, #4
  21afae:	f003 030f 	and.w	r3, r3, #15
  21afb2:	4a0a      	ldr	r2, [pc, #40]	; (21afdc <HAL_RCC_ClockConfig+0x1cc>)
  21afb4:	5cd3      	ldrb	r3, [r2, r3]
  21afb6:	fa21 f303 	lsr.w	r3, r1, r3
  21afba:	4a09      	ldr	r2, [pc, #36]	; (21afe0 <HAL_RCC_ClockConfig+0x1d0>)
  21afbc:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick(uwTickPrio);
  21afbe:	4b09      	ldr	r3, [pc, #36]	; (21afe4 <HAL_RCC_ClockConfig+0x1d4>)
  21afc0:	681b      	ldr	r3, [r3, #0]
  21afc2:	4618      	mov	r0, r3
  21afc4:	f7fd fbf0 	bl	2187a8 <HAL_InitTick>

  return HAL_OK;
  21afc8:	2300      	movs	r3, #0
}
  21afca:	4618      	mov	r0, r3
  21afcc:	3710      	adds	r7, #16
  21afce:	46bd      	mov	sp, r7
  21afd0:	bd80      	pop	{r7, pc}
  21afd2:	bf00      	nop
  21afd4:	40023c00 	.word	0x40023c00
  21afd8:	40023800 	.word	0x40023800
  21afdc:	00229370 	.word	0x00229370
  21afe0:	20000004 	.word	0x20000004
  21afe4:	20000008 	.word	0x20000008

0021afe8 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  21afe8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  21afec:	b087      	sub	sp, #28
  21afee:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
  21aff0:	2200      	movs	r2, #0
  21aff2:	60fa      	str	r2, [r7, #12]
  21aff4:	2200      	movs	r2, #0
  21aff6:	617a      	str	r2, [r7, #20]
  21aff8:	2200      	movs	r2, #0
  21affa:	60ba      	str	r2, [r7, #8]
  uint32_t sysclockfreq = 0;
  21affc:	2200      	movs	r2, #0
  21affe:	613a      	str	r2, [r7, #16]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  21b000:	4a51      	ldr	r2, [pc, #324]	; (21b148 <HAL_RCC_GetSysClockFreq+0x160>)
  21b002:	6892      	ldr	r2, [r2, #8]
  21b004:	f002 020c 	and.w	r2, r2, #12
  21b008:	2a04      	cmp	r2, #4
  21b00a:	d007      	beq.n	21b01c <HAL_RCC_GetSysClockFreq+0x34>
  21b00c:	2a08      	cmp	r2, #8
  21b00e:	d008      	beq.n	21b022 <HAL_RCC_GetSysClockFreq+0x3a>
  21b010:	2a00      	cmp	r2, #0
  21b012:	f040 8090 	bne.w	21b136 <HAL_RCC_GetSysClockFreq+0x14e>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
  21b016:	4b4d      	ldr	r3, [pc, #308]	; (21b14c <HAL_RCC_GetSysClockFreq+0x164>)
  21b018:	613b      	str	r3, [r7, #16]
      break;
  21b01a:	e08f      	b.n	21b13c <HAL_RCC_GetSysClockFreq+0x154>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
  21b01c:	4b4c      	ldr	r3, [pc, #304]	; (21b150 <HAL_RCC_GetSysClockFreq+0x168>)
  21b01e:	613b      	str	r3, [r7, #16]
      break;
  21b020:	e08c      	b.n	21b13c <HAL_RCC_GetSysClockFreq+0x154>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
  21b022:	4a49      	ldr	r2, [pc, #292]	; (21b148 <HAL_RCC_GetSysClockFreq+0x160>)
  21b024:	6852      	ldr	r2, [r2, #4]
  21b026:	f002 023f 	and.w	r2, r2, #63	; 0x3f
  21b02a:	60fa      	str	r2, [r7, #12]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
  21b02c:	4a46      	ldr	r2, [pc, #280]	; (21b148 <HAL_RCC_GetSysClockFreq+0x160>)
  21b02e:	6852      	ldr	r2, [r2, #4]
  21b030:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
  21b034:	2a00      	cmp	r2, #0
  21b036:	d023      	beq.n	21b080 <HAL_RCC_GetSysClockFreq+0x98>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSE_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
  21b038:	4b43      	ldr	r3, [pc, #268]	; (21b148 <HAL_RCC_GetSysClockFreq+0x160>)
  21b03a:	685b      	ldr	r3, [r3, #4]
  21b03c:	099b      	lsrs	r3, r3, #6
  21b03e:	f04f 0400 	mov.w	r4, #0
  21b042:	f240 11ff 	movw	r1, #511	; 0x1ff
  21b046:	f04f 0200 	mov.w	r2, #0
  21b04a:	ea03 0301 	and.w	r3, r3, r1
  21b04e:	ea04 0402 	and.w	r4, r4, r2
  21b052:	4a3f      	ldr	r2, [pc, #252]	; (21b150 <HAL_RCC_GetSysClockFreq+0x168>)
  21b054:	fb02 f104 	mul.w	r1, r2, r4
  21b058:	2200      	movs	r2, #0
  21b05a:	fb02 f203 	mul.w	r2, r2, r3
  21b05e:	440a      	add	r2, r1
  21b060:	493b      	ldr	r1, [pc, #236]	; (21b150 <HAL_RCC_GetSysClockFreq+0x168>)
  21b062:	fba3 0101 	umull	r0, r1, r3, r1
  21b066:	1853      	adds	r3, r2, r1
  21b068:	4619      	mov	r1, r3
  21b06a:	68fb      	ldr	r3, [r7, #12]
  21b06c:	f04f 0400 	mov.w	r4, #0
  21b070:	461a      	mov	r2, r3
  21b072:	4623      	mov	r3, r4
  21b074:	f7e5 fa4a 	bl	20050c <__aeabi_uldivmod>
  21b078:	4603      	mov	r3, r0
  21b07a:	460c      	mov	r4, r1
  21b07c:	617b      	str	r3, [r7, #20]
  21b07e:	e04c      	b.n	21b11a <HAL_RCC_GetSysClockFreq+0x132>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t)((((uint64_t) HSI_VALUE * ((uint64_t)((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
  21b080:	4a31      	ldr	r2, [pc, #196]	; (21b148 <HAL_RCC_GetSysClockFreq+0x160>)
  21b082:	6852      	ldr	r2, [r2, #4]
  21b084:	0992      	lsrs	r2, r2, #6
  21b086:	4611      	mov	r1, r2
  21b088:	f04f 0200 	mov.w	r2, #0
  21b08c:	f240 15ff 	movw	r5, #511	; 0x1ff
  21b090:	f04f 0600 	mov.w	r6, #0
  21b094:	ea05 0501 	and.w	r5, r5, r1
  21b098:	ea06 0602 	and.w	r6, r6, r2
  21b09c:	4629      	mov	r1, r5
  21b09e:	4632      	mov	r2, r6
  21b0a0:	ea4f 1b42 	mov.w	fp, r2, lsl #5
  21b0a4:	ea4b 6bd1 	orr.w	fp, fp, r1, lsr #27
  21b0a8:	ea4f 1a41 	mov.w	sl, r1, lsl #5
  21b0ac:	4651      	mov	r1, sl
  21b0ae:	465a      	mov	r2, fp
  21b0b0:	46aa      	mov	sl, r5
  21b0b2:	46b3      	mov	fp, r6
  21b0b4:	4655      	mov	r5, sl
  21b0b6:	465e      	mov	r6, fp
  21b0b8:	1b4d      	subs	r5, r1, r5
  21b0ba:	eb62 0606 	sbc.w	r6, r2, r6
  21b0be:	4629      	mov	r1, r5
  21b0c0:	4632      	mov	r2, r6
  21b0c2:	0194      	lsls	r4, r2, #6
  21b0c4:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
  21b0c8:	018b      	lsls	r3, r1, #6
  21b0ca:	1a5b      	subs	r3, r3, r1
  21b0cc:	eb64 0402 	sbc.w	r4, r4, r2
  21b0d0:	ea4f 09c4 	mov.w	r9, r4, lsl #3
  21b0d4:	ea49 7953 	orr.w	r9, r9, r3, lsr #29
  21b0d8:	ea4f 08c3 	mov.w	r8, r3, lsl #3
  21b0dc:	4643      	mov	r3, r8
  21b0de:	464c      	mov	r4, r9
  21b0e0:	4655      	mov	r5, sl
  21b0e2:	465e      	mov	r6, fp
  21b0e4:	18ed      	adds	r5, r5, r3
  21b0e6:	eb46 0604 	adc.w	r6, r6, r4
  21b0ea:	462b      	mov	r3, r5
  21b0ec:	4634      	mov	r4, r6
  21b0ee:	02a2      	lsls	r2, r4, #10
  21b0f0:	607a      	str	r2, [r7, #4]
  21b0f2:	687a      	ldr	r2, [r7, #4]
  21b0f4:	ea42 5293 	orr.w	r2, r2, r3, lsr #22
  21b0f8:	607a      	str	r2, [r7, #4]
  21b0fa:	029b      	lsls	r3, r3, #10
  21b0fc:	603b      	str	r3, [r7, #0]
  21b0fe:	e897 0018 	ldmia.w	r7, {r3, r4}
  21b102:	4618      	mov	r0, r3
  21b104:	4621      	mov	r1, r4
  21b106:	68fb      	ldr	r3, [r7, #12]
  21b108:	f04f 0400 	mov.w	r4, #0
  21b10c:	461a      	mov	r2, r3
  21b10e:	4623      	mov	r3, r4
  21b110:	f7e5 f9fc 	bl	20050c <__aeabi_uldivmod>
  21b114:	4603      	mov	r3, r0
  21b116:	460c      	mov	r4, r1
  21b118:	617b      	str	r3, [r7, #20]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1) * 2);
  21b11a:	4b0b      	ldr	r3, [pc, #44]	; (21b148 <HAL_RCC_GetSysClockFreq+0x160>)
  21b11c:	685b      	ldr	r3, [r3, #4]
  21b11e:	0c1b      	lsrs	r3, r3, #16
  21b120:	f003 0303 	and.w	r3, r3, #3
  21b124:	3301      	adds	r3, #1
  21b126:	005b      	lsls	r3, r3, #1
  21b128:	60bb      	str	r3, [r7, #8]

      sysclockfreq = pllvco / pllp;
  21b12a:	697a      	ldr	r2, [r7, #20]
  21b12c:	68bb      	ldr	r3, [r7, #8]
  21b12e:	fbb2 f3f3 	udiv	r3, r2, r3
  21b132:	613b      	str	r3, [r7, #16]
      break;
  21b134:	e002      	b.n	21b13c <HAL_RCC_GetSysClockFreq+0x154>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
  21b136:	4b05      	ldr	r3, [pc, #20]	; (21b14c <HAL_RCC_GetSysClockFreq+0x164>)
  21b138:	613b      	str	r3, [r7, #16]
      break;
  21b13a:	bf00      	nop
    }
  }
  return sysclockfreq;
  21b13c:	693b      	ldr	r3, [r7, #16]
}
  21b13e:	4618      	mov	r0, r3
  21b140:	371c      	adds	r7, #28
  21b142:	46bd      	mov	sp, r7
  21b144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  21b148:	40023800 	.word	0x40023800
  21b14c:	00f42400 	.word	0x00f42400
  21b150:	017d7840 	.word	0x017d7840

0021b154 <HAL_RCC_GetHCLKFreq>:
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  21b154:	b480      	push	{r7}
  21b156:	af00      	add	r7, sp, #0
  return SystemCoreClock;
  21b158:	4b03      	ldr	r3, [pc, #12]	; (21b168 <HAL_RCC_GetHCLKFreq+0x14>)
  21b15a:	681b      	ldr	r3, [r3, #0]
}
  21b15c:	4618      	mov	r0, r3
  21b15e:	46bd      	mov	sp, r7
  21b160:	f85d 7b04 	ldr.w	r7, [sp], #4
  21b164:	4770      	bx	lr
  21b166:	bf00      	nop
  21b168:	20000004 	.word	0x20000004

0021b16c <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
  21b16c:	b580      	push	{r7, lr}
  21b16e:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
  21b170:	f7ff fff0 	bl	21b154 <HAL_RCC_GetHCLKFreq>
  21b174:	4601      	mov	r1, r0
  21b176:	4b05      	ldr	r3, [pc, #20]	; (21b18c <HAL_RCC_GetPCLK1Freq+0x20>)
  21b178:	689b      	ldr	r3, [r3, #8]
  21b17a:	0a9b      	lsrs	r3, r3, #10
  21b17c:	f003 0307 	and.w	r3, r3, #7
  21b180:	4a03      	ldr	r2, [pc, #12]	; (21b190 <HAL_RCC_GetPCLK1Freq+0x24>)
  21b182:	5cd3      	ldrb	r3, [r2, r3]
  21b184:	fa21 f303 	lsr.w	r3, r1, r3
}
  21b188:	4618      	mov	r0, r3
  21b18a:	bd80      	pop	{r7, pc}
  21b18c:	40023800 	.word	0x40023800
  21b190:	00229380 	.word	0x00229380

0021b194 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  21b194:	b580      	push	{r7, lr}
  21b196:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
  21b198:	f7ff ffdc 	bl	21b154 <HAL_RCC_GetHCLKFreq>
  21b19c:	4601      	mov	r1, r0
  21b19e:	4b05      	ldr	r3, [pc, #20]	; (21b1b4 <HAL_RCC_GetPCLK2Freq+0x20>)
  21b1a0:	689b      	ldr	r3, [r3, #8]
  21b1a2:	0b5b      	lsrs	r3, r3, #13
  21b1a4:	f003 0307 	and.w	r3, r3, #7
  21b1a8:	4a03      	ldr	r2, [pc, #12]	; (21b1b8 <HAL_RCC_GetPCLK2Freq+0x24>)
  21b1aa:	5cd3      	ldrb	r3, [r2, r3]
  21b1ac:	fa21 f303 	lsr.w	r3, r1, r3
}
  21b1b0:	4618      	mov	r0, r3
  21b1b2:	bd80      	pop	{r7, pc}
  21b1b4:	40023800 	.word	0x40023800
  21b1b8:	00229380 	.word	0x00229380

0021b1bc <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
  21b1bc:	b480      	push	{r7}
  21b1be:	b083      	sub	sp, #12
  21b1c0:	af00      	add	r7, sp, #0
  21b1c2:	6078      	str	r0, [r7, #4]
  21b1c4:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  21b1c6:	687b      	ldr	r3, [r7, #4]
  21b1c8:	220f      	movs	r2, #15
  21b1ca:	601a      	str	r2, [r3, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
  21b1cc:	4b12      	ldr	r3, [pc, #72]	; (21b218 <HAL_RCC_GetClockConfig+0x5c>)
  21b1ce:	689b      	ldr	r3, [r3, #8]
  21b1d0:	f003 0203 	and.w	r2, r3, #3
  21b1d4:	687b      	ldr	r3, [r7, #4]
  21b1d6:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
  21b1d8:	4b0f      	ldr	r3, [pc, #60]	; (21b218 <HAL_RCC_GetClockConfig+0x5c>)
  21b1da:	689b      	ldr	r3, [r3, #8]
  21b1dc:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
  21b1e0:	687b      	ldr	r3, [r7, #4]
  21b1e2:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
  21b1e4:	4b0c      	ldr	r3, [pc, #48]	; (21b218 <HAL_RCC_GetClockConfig+0x5c>)
  21b1e6:	689b      	ldr	r3, [r3, #8]
  21b1e8:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
  21b1ec:	687b      	ldr	r3, [r7, #4]
  21b1ee:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
  21b1f0:	4b09      	ldr	r3, [pc, #36]	; (21b218 <HAL_RCC_GetClockConfig+0x5c>)
  21b1f2:	689b      	ldr	r3, [r3, #8]
  21b1f4:	08db      	lsrs	r3, r3, #3
  21b1f6:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
  21b1fa:	687b      	ldr	r3, [r7, #4]
  21b1fc:	611a      	str	r2, [r3, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
  21b1fe:	4b07      	ldr	r3, [pc, #28]	; (21b21c <HAL_RCC_GetClockConfig+0x60>)
  21b200:	681b      	ldr	r3, [r3, #0]
  21b202:	f003 020f 	and.w	r2, r3, #15
  21b206:	683b      	ldr	r3, [r7, #0]
  21b208:	601a      	str	r2, [r3, #0]
}
  21b20a:	bf00      	nop
  21b20c:	370c      	adds	r7, #12
  21b20e:	46bd      	mov	sp, r7
  21b210:	f85d 7b04 	ldr.w	r7, [sp], #4
  21b214:	4770      	bx	lr
  21b216:	bf00      	nop
  21b218:	40023800 	.word	0x40023800
  21b21c:	40023c00 	.word	0x40023c00

0021b220 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
  21b220:	b580      	push	{r7, lr}
  21b222:	b088      	sub	sp, #32
  21b224:	af00      	add	r7, sp, #0
  21b226:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
  21b228:	2300      	movs	r3, #0
  21b22a:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg0 = 0;
  21b22c:	2300      	movs	r3, #0
  21b22e:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg1 = 0;
  21b230:	2300      	movs	r3, #0
  21b232:	60fb      	str	r3, [r7, #12]
  uint32_t plli2sused = 0;
  21b234:	2300      	movs	r3, #0
  21b236:	61fb      	str	r3, [r7, #28]
  uint32_t pllsaiused = 0;
  21b238:	2300      	movs	r3, #0
  21b23a:	61bb      	str	r3, [r7, #24]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
  21b23c:	687b      	ldr	r3, [r7, #4]
  21b23e:	681b      	ldr	r3, [r3, #0]
  21b240:	f003 0301 	and.w	r3, r3, #1
  21b244:	2b00      	cmp	r3, #0
  21b246:	d012      	beq.n	21b26e <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
  21b248:	4a69      	ldr	r2, [pc, #420]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b24a:	4b69      	ldr	r3, [pc, #420]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b24c:	689b      	ldr	r3, [r3, #8]
  21b24e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
  21b252:	6093      	str	r3, [r2, #8]
  21b254:	4966      	ldr	r1, [pc, #408]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b256:	4b66      	ldr	r3, [pc, #408]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b258:	689a      	ldr	r2, [r3, #8]
  21b25a:	687b      	ldr	r3, [r7, #4]
  21b25c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21b25e:	4313      	orrs	r3, r2
  21b260:	608b      	str	r3, [r1, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
  21b262:	687b      	ldr	r3, [r7, #4]
  21b264:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21b266:	2b00      	cmp	r3, #0
  21b268:	d101      	bne.n	21b26e <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      plli2sused = 1;
  21b26a:	2301      	movs	r3, #1
  21b26c:	61fb      	str	r3, [r7, #28]
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
  21b26e:	687b      	ldr	r3, [r7, #4]
  21b270:	681b      	ldr	r3, [r3, #0]
  21b272:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  21b276:	2b00      	cmp	r3, #0
  21b278:	d017      	beq.n	21b2aa <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
  21b27a:	495d      	ldr	r1, [pc, #372]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b27c:	4b5c      	ldr	r3, [pc, #368]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b27e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b282:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
  21b286:	687b      	ldr	r3, [r7, #4]
  21b288:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21b28a:	4313      	orrs	r3, r2
  21b28c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
  21b290:	687b      	ldr	r3, [r7, #4]
  21b292:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21b294:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
  21b298:	d101      	bne.n	21b29e <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      plli2sused = 1;
  21b29a:	2301      	movs	r3, #1
  21b29c:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
  21b29e:	687b      	ldr	r3, [r7, #4]
  21b2a0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21b2a2:	2b00      	cmp	r3, #0
  21b2a4:	d101      	bne.n	21b2aa <HAL_RCCEx_PeriphCLKConfig+0x8a>
    {
      pllsaiused = 1;
  21b2a6:	2301      	movs	r3, #1
  21b2a8:	61bb      	str	r3, [r7, #24]
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
  21b2aa:	687b      	ldr	r3, [r7, #4]
  21b2ac:	681b      	ldr	r3, [r3, #0]
  21b2ae:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  21b2b2:	2b00      	cmp	r3, #0
  21b2b4:	d017      	beq.n	21b2e6 <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
  21b2b6:	494e      	ldr	r1, [pc, #312]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b2b8:	4b4d      	ldr	r3, [pc, #308]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b2ba:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b2be:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
  21b2c2:	687b      	ldr	r3, [r7, #4]
  21b2c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b2c6:	4313      	orrs	r3, r2
  21b2c8:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
  21b2cc:	687b      	ldr	r3, [r7, #4]
  21b2ce:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b2d0:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
  21b2d4:	d101      	bne.n	21b2da <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      plli2sused = 1;
  21b2d6:	2301      	movs	r3, #1
  21b2d8:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
  21b2da:	687b      	ldr	r3, [r7, #4]
  21b2dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b2de:	2b00      	cmp	r3, #0
  21b2e0:	d101      	bne.n	21b2e6 <HAL_RCCEx_PeriphCLKConfig+0xc6>
    {
      pllsaiused = 1;
  21b2e2:	2301      	movs	r3, #1
  21b2e4:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  21b2e6:	687b      	ldr	r3, [r7, #4]
  21b2e8:	681b      	ldr	r3, [r3, #0]
  21b2ea:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  21b2ee:	2b00      	cmp	r3, #0
  21b2f0:	d001      	beq.n	21b2f6 <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
      plli2sused = 1;
  21b2f2:	2301      	movs	r3, #1
  21b2f4:	61fb      	str	r3, [r7, #28]
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
  21b2f6:	687b      	ldr	r3, [r7, #4]
  21b2f8:	681b      	ldr	r3, [r3, #0]
  21b2fa:	f003 0320 	and.w	r3, r3, #32
  21b2fe:	2b00      	cmp	r3, #0
  21b300:	f000 808b 	beq.w	21b41a <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
  21b304:	4a3a      	ldr	r2, [pc, #232]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b306:	4b3a      	ldr	r3, [pc, #232]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b308:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b30a:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  21b30e:	6413      	str	r3, [r2, #64]	; 0x40
  21b310:	4b37      	ldr	r3, [pc, #220]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b312:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b314:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21b318:	60bb      	str	r3, [r7, #8]
  21b31a:	68bb      	ldr	r3, [r7, #8]

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
  21b31c:	4a35      	ldr	r2, [pc, #212]	; (21b3f4 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
  21b31e:	4b35      	ldr	r3, [pc, #212]	; (21b3f4 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
  21b320:	681b      	ldr	r3, [r3, #0]
  21b322:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  21b326:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  21b328:	f7fd fd82 	bl	218e30 <HAL_GetTick>
  21b32c:	6178      	str	r0, [r7, #20]

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
  21b32e:	e008      	b.n	21b342 <HAL_RCCEx_PeriphCLKConfig+0x122>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
  21b330:	f7fd fd7e 	bl	218e30 <HAL_GetTick>
  21b334:	4602      	mov	r2, r0
  21b336:	697b      	ldr	r3, [r7, #20]
  21b338:	1ad3      	subs	r3, r2, r3
  21b33a:	2b64      	cmp	r3, #100	; 0x64
  21b33c:	d901      	bls.n	21b342 <HAL_RCCEx_PeriphCLKConfig+0x122>
      {
        return HAL_TIMEOUT;
  21b33e:	2303      	movs	r3, #3
  21b340:	e38d      	b.n	21ba5e <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
  21b342:	4b2c      	ldr	r3, [pc, #176]	; (21b3f4 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
  21b344:	681b      	ldr	r3, [r3, #0]
  21b346:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21b34a:	2b00      	cmp	r3, #0
  21b34c:	d0f0      	beq.n	21b330 <HAL_RCCEx_PeriphCLKConfig+0x110>
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
  21b34e:	4b28      	ldr	r3, [pc, #160]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b350:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b352:	f403 7340 	and.w	r3, r3, #768	; 0x300
  21b356:	613b      	str	r3, [r7, #16]

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
  21b358:	693b      	ldr	r3, [r7, #16]
  21b35a:	2b00      	cmp	r3, #0
  21b35c:	d035      	beq.n	21b3ca <HAL_RCCEx_PeriphCLKConfig+0x1aa>
  21b35e:	687b      	ldr	r3, [r7, #4]
  21b360:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21b362:	f403 7240 	and.w	r2, r3, #768	; 0x300
  21b366:	693b      	ldr	r3, [r7, #16]
  21b368:	429a      	cmp	r2, r3
  21b36a:	d02e      	beq.n	21b3ca <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
  21b36c:	4b20      	ldr	r3, [pc, #128]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b36e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b370:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  21b374:	613b      	str	r3, [r7, #16]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
  21b376:	4a1e      	ldr	r2, [pc, #120]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b378:	4b1d      	ldr	r3, [pc, #116]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b37a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b37c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  21b380:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
  21b382:	4a1b      	ldr	r2, [pc, #108]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b384:	4b1a      	ldr	r3, [pc, #104]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b386:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b388:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  21b38c:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
  21b38e:	4a18      	ldr	r2, [pc, #96]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b390:	693b      	ldr	r3, [r7, #16]
  21b392:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
  21b394:	4b16      	ldr	r3, [pc, #88]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b396:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b398:	f003 0301 	and.w	r3, r3, #1
  21b39c:	2b01      	cmp	r3, #1
  21b39e:	d114      	bne.n	21b3ca <HAL_RCCEx_PeriphCLKConfig+0x1aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
  21b3a0:	f7fd fd46 	bl	218e30 <HAL_GetTick>
  21b3a4:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  21b3a6:	e00a      	b.n	21b3be <HAL_RCCEx_PeriphCLKConfig+0x19e>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
  21b3a8:	f7fd fd42 	bl	218e30 <HAL_GetTick>
  21b3ac:	4602      	mov	r2, r0
  21b3ae:	697b      	ldr	r3, [r7, #20]
  21b3b0:	1ad3      	subs	r3, r2, r3
  21b3b2:	f241 3288 	movw	r2, #5000	; 0x1388
  21b3b6:	4293      	cmp	r3, r2
  21b3b8:	d901      	bls.n	21b3be <HAL_RCCEx_PeriphCLKConfig+0x19e>
          {
            return HAL_TIMEOUT;
  21b3ba:	2303      	movs	r3, #3
  21b3bc:	e34f      	b.n	21ba5e <HAL_RCCEx_PeriphCLKConfig+0x83e>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
  21b3be:	4b0c      	ldr	r3, [pc, #48]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b3c0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b3c2:	f003 0302 	and.w	r3, r3, #2
  21b3c6:	2b00      	cmp	r3, #0
  21b3c8:	d0ee      	beq.n	21b3a8 <HAL_RCCEx_PeriphCLKConfig+0x188>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
  21b3ca:	687b      	ldr	r3, [r7, #4]
  21b3cc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21b3ce:	f403 7340 	and.w	r3, r3, #768	; 0x300
  21b3d2:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
  21b3d6:	d111      	bne.n	21b3fc <HAL_RCCEx_PeriphCLKConfig+0x1dc>
  21b3d8:	4805      	ldr	r0, [pc, #20]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b3da:	4b05      	ldr	r3, [pc, #20]	; (21b3f0 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
  21b3dc:	689b      	ldr	r3, [r3, #8]
  21b3de:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
  21b3e2:	687b      	ldr	r3, [r7, #4]
  21b3e4:	6b19      	ldr	r1, [r3, #48]	; 0x30
  21b3e6:	4b04      	ldr	r3, [pc, #16]	; (21b3f8 <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
  21b3e8:	400b      	ands	r3, r1
  21b3ea:	4313      	orrs	r3, r2
  21b3ec:	6083      	str	r3, [r0, #8]
  21b3ee:	e00b      	b.n	21b408 <HAL_RCCEx_PeriphCLKConfig+0x1e8>
  21b3f0:	40023800 	.word	0x40023800
  21b3f4:	40007000 	.word	0x40007000
  21b3f8:	0ffffcff 	.word	0x0ffffcff
  21b3fc:	4ab2      	ldr	r2, [pc, #712]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b3fe:	4bb2      	ldr	r3, [pc, #712]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b400:	689b      	ldr	r3, [r3, #8]
  21b402:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
  21b406:	6093      	str	r3, [r2, #8]
  21b408:	49af      	ldr	r1, [pc, #700]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b40a:	4baf      	ldr	r3, [pc, #700]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b40c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  21b40e:	687b      	ldr	r3, [r7, #4]
  21b410:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21b412:	f3c3 030b 	ubfx	r3, r3, #0, #12
  21b416:	4313      	orrs	r3, r2
  21b418:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
  21b41a:	687b      	ldr	r3, [r7, #4]
  21b41c:	681b      	ldr	r3, [r3, #0]
  21b41e:	f003 0310 	and.w	r3, r3, #16
  21b422:	2b00      	cmp	r3, #0
  21b424:	d010      	beq.n	21b448 <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
  21b426:	4aa8      	ldr	r2, [pc, #672]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b428:	4ba7      	ldr	r3, [pc, #668]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b42a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b42e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
  21b432:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  21b436:	49a4      	ldr	r1, [pc, #656]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b438:	4ba3      	ldr	r3, [pc, #652]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b43a:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
  21b43e:	687b      	ldr	r3, [r7, #4]
  21b440:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21b442:	4313      	orrs	r3, r2
  21b444:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
  21b448:	687b      	ldr	r3, [r7, #4]
  21b44a:	681b      	ldr	r3, [r3, #0]
  21b44c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  21b450:	2b00      	cmp	r3, #0
  21b452:	d00a      	beq.n	21b46a <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
  21b454:	499c      	ldr	r1, [pc, #624]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b456:	4b9c      	ldr	r3, [pc, #624]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b458:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b45c:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
  21b460:	687b      	ldr	r3, [r7, #4]
  21b462:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21b464:	4313      	orrs	r3, r2
  21b466:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
  21b46a:	687b      	ldr	r3, [r7, #4]
  21b46c:	681b      	ldr	r3, [r3, #0]
  21b46e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  21b472:	2b00      	cmp	r3, #0
  21b474:	d00a      	beq.n	21b48c <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
  21b476:	4994      	ldr	r1, [pc, #592]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b478:	4b93      	ldr	r3, [pc, #588]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b47a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b47e:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
  21b482:	687b      	ldr	r3, [r7, #4]
  21b484:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21b486:	4313      	orrs	r3, r2
  21b488:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
  21b48c:	687b      	ldr	r3, [r7, #4]
  21b48e:	681b      	ldr	r3, [r3, #0]
  21b490:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  21b494:	2b00      	cmp	r3, #0
  21b496:	d00a      	beq.n	21b4ae <HAL_RCCEx_PeriphCLKConfig+0x28e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
  21b498:	498b      	ldr	r1, [pc, #556]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b49a:	4b8b      	ldr	r3, [pc, #556]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b49c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b4a0:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
  21b4a4:	687b      	ldr	r3, [r7, #4]
  21b4a6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21b4a8:	4313      	orrs	r3, r2
  21b4aa:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
  21b4ae:	687b      	ldr	r3, [r7, #4]
  21b4b0:	681b      	ldr	r3, [r3, #0]
  21b4b2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21b4b6:	2b00      	cmp	r3, #0
  21b4b8:	d00a      	beq.n	21b4d0 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
  21b4ba:	4983      	ldr	r1, [pc, #524]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b4bc:	4b82      	ldr	r3, [pc, #520]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b4be:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b4c2:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
  21b4c6:	687b      	ldr	r3, [r7, #4]
  21b4c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21b4ca:	4313      	orrs	r3, r2
  21b4cc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
  21b4d0:	687b      	ldr	r3, [r7, #4]
  21b4d2:	681b      	ldr	r3, [r3, #0]
  21b4d4:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21b4d8:	2b00      	cmp	r3, #0
  21b4da:	d00a      	beq.n	21b4f2 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
  21b4dc:	497a      	ldr	r1, [pc, #488]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b4de:	4b7a      	ldr	r3, [pc, #488]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b4e0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b4e4:	f023 0203 	bic.w	r2, r3, #3
  21b4e8:	687b      	ldr	r3, [r7, #4]
  21b4ea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21b4ec:	4313      	orrs	r3, r2
  21b4ee:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
  21b4f2:	687b      	ldr	r3, [r7, #4]
  21b4f4:	681b      	ldr	r3, [r3, #0]
  21b4f6:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21b4fa:	2b00      	cmp	r3, #0
  21b4fc:	d00a      	beq.n	21b514 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
  21b4fe:	4972      	ldr	r1, [pc, #456]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b500:	4b71      	ldr	r3, [pc, #452]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b502:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b506:	f023 020c 	bic.w	r2, r3, #12
  21b50a:	687b      	ldr	r3, [r7, #4]
  21b50c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  21b50e:	4313      	orrs	r3, r2
  21b510:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
  21b514:	687b      	ldr	r3, [r7, #4]
  21b516:	681b      	ldr	r3, [r3, #0]
  21b518:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21b51c:	2b00      	cmp	r3, #0
  21b51e:	d00a      	beq.n	21b536 <HAL_RCCEx_PeriphCLKConfig+0x316>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
  21b520:	4969      	ldr	r1, [pc, #420]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b522:	4b69      	ldr	r3, [pc, #420]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b524:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b528:	f023 0230 	bic.w	r2, r3, #48	; 0x30
  21b52c:	687b      	ldr	r3, [r7, #4]
  21b52e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  21b530:	4313      	orrs	r3, r2
  21b532:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
  21b536:	687b      	ldr	r3, [r7, #4]
  21b538:	681b      	ldr	r3, [r3, #0]
  21b53a:	f403 7300 	and.w	r3, r3, #512	; 0x200
  21b53e:	2b00      	cmp	r3, #0
  21b540:	d00a      	beq.n	21b558 <HAL_RCCEx_PeriphCLKConfig+0x338>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
  21b542:	4961      	ldr	r1, [pc, #388]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b544:	4b60      	ldr	r3, [pc, #384]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b546:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b54a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
  21b54e:	687b      	ldr	r3, [r7, #4]
  21b550:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21b552:	4313      	orrs	r3, r2
  21b554:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
  21b558:	687b      	ldr	r3, [r7, #4]
  21b55a:	681b      	ldr	r3, [r3, #0]
  21b55c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
  21b560:	2b00      	cmp	r3, #0
  21b562:	d00a      	beq.n	21b57a <HAL_RCCEx_PeriphCLKConfig+0x35a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
  21b564:	4958      	ldr	r1, [pc, #352]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b566:	4b58      	ldr	r3, [pc, #352]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b568:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b56c:	f423 7240 	bic.w	r2, r3, #768	; 0x300
  21b570:	687b      	ldr	r3, [r7, #4]
  21b572:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21b574:	4313      	orrs	r3, r2
  21b576:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
  21b57a:	687b      	ldr	r3, [r7, #4]
  21b57c:	681b      	ldr	r3, [r3, #0]
  21b57e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  21b582:	2b00      	cmp	r3, #0
  21b584:	d00a      	beq.n	21b59c <HAL_RCCEx_PeriphCLKConfig+0x37c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
  21b586:	4950      	ldr	r1, [pc, #320]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b588:	4b4f      	ldr	r3, [pc, #316]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b58a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b58e:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
  21b592:	687b      	ldr	r3, [r7, #4]
  21b594:	6d9b      	ldr	r3, [r3, #88]	; 0x58
  21b596:	4313      	orrs	r3, r2
  21b598:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
  21b59c:	687b      	ldr	r3, [r7, #4]
  21b59e:	681b      	ldr	r3, [r3, #0]
  21b5a0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  21b5a4:	2b00      	cmp	r3, #0
  21b5a6:	d00a      	beq.n	21b5be <HAL_RCCEx_PeriphCLKConfig+0x39e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
  21b5a8:	4947      	ldr	r1, [pc, #284]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b5aa:	4b47      	ldr	r3, [pc, #284]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b5ac:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b5b0:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
  21b5b4:	687b      	ldr	r3, [r7, #4]
  21b5b6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  21b5b8:	4313      	orrs	r3, r2
  21b5ba:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
  21b5be:	687b      	ldr	r3, [r7, #4]
  21b5c0:	681b      	ldr	r3, [r3, #0]
  21b5c2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  21b5c6:	2b00      	cmp	r3, #0
  21b5c8:	d00a      	beq.n	21b5e0 <HAL_RCCEx_PeriphCLKConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
  21b5ca:	493f      	ldr	r1, [pc, #252]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b5cc:	4b3e      	ldr	r3, [pc, #248]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b5ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b5d2:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
  21b5d6:	687b      	ldr	r3, [r7, #4]
  21b5d8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  21b5da:	4313      	orrs	r3, r2
  21b5dc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
  21b5e0:	687b      	ldr	r3, [r7, #4]
  21b5e2:	681b      	ldr	r3, [r3, #0]
  21b5e4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  21b5e8:	2b00      	cmp	r3, #0
  21b5ea:	d00a      	beq.n	21b602 <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
  21b5ec:	4936      	ldr	r1, [pc, #216]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b5ee:	4b36      	ldr	r3, [pc, #216]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b5f0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b5f4:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
  21b5f8:	687b      	ldr	r3, [r7, #4]
  21b5fa:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  21b5fc:	4313      	orrs	r3, r2
  21b5fe:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
  21b602:	687b      	ldr	r3, [r7, #4]
  21b604:	681b      	ldr	r3, [r3, #0]
  21b606:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  21b60a:	2b00      	cmp	r3, #0
  21b60c:	d011      	beq.n	21b632 <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
  21b60e:	492e      	ldr	r1, [pc, #184]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b610:	4b2d      	ldr	r3, [pc, #180]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b612:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b616:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
  21b61a:	687b      	ldr	r3, [r7, #4]
  21b61c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  21b61e:	4313      	orrs	r3, r2
  21b620:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
  21b624:	687b      	ldr	r3, [r7, #4]
  21b626:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  21b628:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  21b62c:	d101      	bne.n	21b632 <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      pllsaiused = 1;
  21b62e:	2301      	movs	r3, #1
  21b630:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
  21b632:	687b      	ldr	r3, [r7, #4]
  21b634:	681b      	ldr	r3, [r3, #0]
  21b636:	f003 0308 	and.w	r3, r3, #8
  21b63a:	2b00      	cmp	r3, #0
  21b63c:	d001      	beq.n	21b642 <HAL_RCCEx_PeriphCLKConfig+0x422>
  {
    pllsaiused = 1;
  21b63e:	2301      	movs	r3, #1
  21b640:	61bb      	str	r3, [r7, #24]
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
  21b642:	687b      	ldr	r3, [r7, #4]
  21b644:	681b      	ldr	r3, [r3, #0]
  21b646:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  21b64a:	2b00      	cmp	r3, #0
  21b64c:	d00a      	beq.n	21b664 <HAL_RCCEx_PeriphCLKConfig+0x444>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
  21b64e:	491e      	ldr	r1, [pc, #120]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b650:	4b1d      	ldr	r3, [pc, #116]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b652:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b656:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
  21b65a:	687b      	ldr	r3, [r7, #4]
  21b65c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  21b65e:	4313      	orrs	r3, r2
  21b660:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
  21b664:	687b      	ldr	r3, [r7, #4]
  21b666:	681b      	ldr	r3, [r3, #0]
  21b668:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  21b66c:	2b00      	cmp	r3, #0
  21b66e:	d00b      	beq.n	21b688 <HAL_RCCEx_PeriphCLKConfig+0x468>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
  21b670:	4915      	ldr	r1, [pc, #84]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b672:	4b15      	ldr	r3, [pc, #84]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b674:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b678:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
  21b67c:	687b      	ldr	r3, [r7, #4]
  21b67e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21b682:	4313      	orrs	r3, r2
  21b684:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
  21b688:	687b      	ldr	r3, [r7, #4]
  21b68a:	681b      	ldr	r3, [r3, #0]
  21b68c:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  21b690:	2b00      	cmp	r3, #0
  21b692:	d00b      	beq.n	21b6ac <HAL_RCCEx_PeriphCLKConfig+0x48c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));

    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
  21b694:	490c      	ldr	r1, [pc, #48]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b696:	4b0c      	ldr	r3, [pc, #48]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b698:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21b69c:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
  21b6a0:	687b      	ldr	r3, [r7, #4]
  21b6a2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b6a6:	4313      	orrs	r3, r2
  21b6a8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
  21b6ac:	687b      	ldr	r3, [r7, #4]
  21b6ae:	681b      	ldr	r3, [r3, #0]
  21b6b0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  21b6b4:	2b00      	cmp	r3, #0
  21b6b6:	d00e      	beq.n	21b6d6 <HAL_RCCEx_PeriphCLKConfig+0x4b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
  21b6b8:	4903      	ldr	r1, [pc, #12]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b6ba:	4b03      	ldr	r3, [pc, #12]	; (21b6c8 <HAL_RCCEx_PeriphCLKConfig+0x4a8>)
  21b6bc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b6c0:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
  21b6c4:	687b      	ldr	r3, [r7, #4]
  21b6c6:	e001      	b.n	21b6cc <HAL_RCCEx_PeriphCLKConfig+0x4ac>
  21b6c8:	40023800 	.word	0x40023800
  21b6cc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b6d0:	4313      	orrs	r3, r2
  21b6d2:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
  21b6d6:	687b      	ldr	r3, [r7, #4]
  21b6d8:	681b      	ldr	r3, [r3, #0]
  21b6da:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21b6de:	2b00      	cmp	r3, #0
  21b6e0:	d00b      	beq.n	21b6fa <HAL_RCCEx_PeriphCLKConfig+0x4da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
  21b6e2:	4981      	ldr	r1, [pc, #516]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b6e4:	4b80      	ldr	r3, [pc, #512]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b6e6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b6ea:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
  21b6ee:	687b      	ldr	r3, [r7, #4]
  21b6f0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b6f4:	4313      	orrs	r3, r2
  21b6f6:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S))
  21b6fa:	69fb      	ldr	r3, [r7, #28]
  21b6fc:	2b01      	cmp	r3, #1
  21b6fe:	d006      	beq.n	21b70e <HAL_RCCEx_PeriphCLKConfig+0x4ee>
  21b700:	687b      	ldr	r3, [r7, #4]
  21b702:	681b      	ldr	r3, [r3, #0]
  21b704:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21b708:	2b00      	cmp	r3, #0
  21b70a:	f000 80d6 	beq.w	21b8ba <HAL_RCCEx_PeriphCLKConfig+0x69a>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
  21b70e:	4a76      	ldr	r2, [pc, #472]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b710:	4b75      	ldr	r3, [pc, #468]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b712:	681b      	ldr	r3, [r3, #0]
  21b714:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
  21b718:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  21b71a:	f7fd fb89 	bl	218e30 <HAL_GetTick>
  21b71e:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
  21b720:	e008      	b.n	21b734 <HAL_RCCEx_PeriphCLKConfig+0x514>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
  21b722:	f7fd fb85 	bl	218e30 <HAL_GetTick>
  21b726:	4602      	mov	r2, r0
  21b728:	697b      	ldr	r3, [r7, #20]
  21b72a:	1ad3      	subs	r3, r2, r3
  21b72c:	2b64      	cmp	r3, #100	; 0x64
  21b72e:	d901      	bls.n	21b734 <HAL_RCCEx_PeriphCLKConfig+0x514>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
  21b730:	2303      	movs	r3, #3
  21b732:	e194      	b.n	21ba5e <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
  21b734:	4b6c      	ldr	r3, [pc, #432]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b736:	681b      	ldr	r3, [r3, #0]
  21b738:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  21b73c:	2b00      	cmp	r3, #0
  21b73e:	d1f0      	bne.n	21b722 <HAL_RCCEx_PeriphCLKConfig+0x502>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
  21b740:	687b      	ldr	r3, [r7, #4]
  21b742:	681b      	ldr	r3, [r3, #0]
  21b744:	f003 0301 	and.w	r3, r3, #1
  21b748:	2b00      	cmp	r3, #0
  21b74a:	d021      	beq.n	21b790 <HAL_RCCEx_PeriphCLKConfig+0x570>
  21b74c:	687b      	ldr	r3, [r7, #4]
  21b74e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21b750:	2b00      	cmp	r3, #0
  21b752:	d11d      	bne.n	21b790 <HAL_RCCEx_PeriphCLKConfig+0x570>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
  21b754:	4b64      	ldr	r3, [pc, #400]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b756:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b75a:	0c1b      	lsrs	r3, r3, #16
  21b75c:	f003 0303 	and.w	r3, r3, #3
  21b760:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
  21b762:	4b61      	ldr	r3, [pc, #388]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b764:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b768:	0e1b      	lsrs	r3, r3, #24
  21b76a:	f003 030f 	and.w	r3, r3, #15
  21b76e:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
  21b770:	495d      	ldr	r1, [pc, #372]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b772:	687b      	ldr	r3, [r7, #4]
  21b774:	685b      	ldr	r3, [r3, #4]
  21b776:	019a      	lsls	r2, r3, #6
  21b778:	693b      	ldr	r3, [r7, #16]
  21b77a:	041b      	lsls	r3, r3, #16
  21b77c:	431a      	orrs	r2, r3
  21b77e:	68fb      	ldr	r3, [r7, #12]
  21b780:	061b      	lsls	r3, r3, #24
  21b782:	431a      	orrs	r2, r3
  21b784:	687b      	ldr	r3, [r7, #4]
  21b786:	689b      	ldr	r3, [r3, #8]
  21b788:	071b      	lsls	r3, r3, #28
  21b78a:	4313      	orrs	r3, r2
  21b78c:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
  21b790:	687b      	ldr	r3, [r7, #4]
  21b792:	681b      	ldr	r3, [r3, #0]
  21b794:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  21b798:	2b00      	cmp	r3, #0
  21b79a:	d004      	beq.n	21b7a6 <HAL_RCCEx_PeriphCLKConfig+0x586>
  21b79c:	687b      	ldr	r3, [r7, #4]
  21b79e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21b7a0:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
  21b7a4:	d00a      	beq.n	21b7bc <HAL_RCCEx_PeriphCLKConfig+0x59c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
  21b7a6:	687b      	ldr	r3, [r7, #4]
  21b7a8:	681b      	ldr	r3, [r3, #0]
  21b7aa:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
  21b7ae:	2b00      	cmp	r3, #0
  21b7b0:	d02e      	beq.n	21b810 <HAL_RCCEx_PeriphCLKConfig+0x5f0>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
  21b7b2:	687b      	ldr	r3, [r7, #4]
  21b7b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b7b6:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
  21b7ba:	d129      	bne.n	21b810 <HAL_RCCEx_PeriphCLKConfig+0x5f0>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
  21b7bc:	4b4a      	ldr	r3, [pc, #296]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b7be:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b7c2:	0c1b      	lsrs	r3, r3, #16
  21b7c4:	f003 0303 	and.w	r3, r3, #3
  21b7c8:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
  21b7ca:	4b47      	ldr	r3, [pc, #284]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b7cc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b7d0:	0f1b      	lsrs	r3, r3, #28
  21b7d2:	f003 0307 	and.w	r3, r3, #7
  21b7d6:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
  21b7d8:	4943      	ldr	r1, [pc, #268]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b7da:	687b      	ldr	r3, [r7, #4]
  21b7dc:	685b      	ldr	r3, [r3, #4]
  21b7de:	019a      	lsls	r2, r3, #6
  21b7e0:	693b      	ldr	r3, [r7, #16]
  21b7e2:	041b      	lsls	r3, r3, #16
  21b7e4:	431a      	orrs	r2, r3
  21b7e6:	687b      	ldr	r3, [r7, #4]
  21b7e8:	68db      	ldr	r3, [r3, #12]
  21b7ea:	061b      	lsls	r3, r3, #24
  21b7ec:	431a      	orrs	r2, r3
  21b7ee:	68fb      	ldr	r3, [r7, #12]
  21b7f0:	071b      	lsls	r3, r3, #28
  21b7f2:	4313      	orrs	r3, r2
  21b7f4:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
  21b7f8:	493b      	ldr	r1, [pc, #236]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b7fa:	4b3b      	ldr	r3, [pc, #236]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b7fc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b800:	f023 021f 	bic.w	r2, r3, #31
  21b804:	687b      	ldr	r3, [r7, #4]
  21b806:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21b808:	3b01      	subs	r3, #1
  21b80a:	4313      	orrs	r3, r2
  21b80c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
  21b810:	687b      	ldr	r3, [r7, #4]
  21b812:	681b      	ldr	r3, [r3, #0]
  21b814:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  21b818:	2b00      	cmp	r3, #0
  21b81a:	d01d      	beq.n	21b858 <HAL_RCCEx_PeriphCLKConfig+0x638>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
  21b81c:	4b32      	ldr	r3, [pc, #200]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b81e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b822:	0e1b      	lsrs	r3, r3, #24
  21b824:	f003 030f 	and.w	r3, r3, #15
  21b828:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
  21b82a:	4b2f      	ldr	r3, [pc, #188]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b82c:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
  21b830:	0f1b      	lsrs	r3, r3, #28
  21b832:	f003 0307 	and.w	r3, r3, #7
  21b836:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
  21b838:	492b      	ldr	r1, [pc, #172]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b83a:	687b      	ldr	r3, [r7, #4]
  21b83c:	685b      	ldr	r3, [r3, #4]
  21b83e:	019a      	lsls	r2, r3, #6
  21b840:	687b      	ldr	r3, [r7, #4]
  21b842:	691b      	ldr	r3, [r3, #16]
  21b844:	041b      	lsls	r3, r3, #16
  21b846:	431a      	orrs	r2, r3
  21b848:	693b      	ldr	r3, [r7, #16]
  21b84a:	061b      	lsls	r3, r3, #24
  21b84c:	431a      	orrs	r2, r3
  21b84e:	68fb      	ldr	r3, [r7, #12]
  21b850:	071b      	lsls	r3, r3, #28
  21b852:	4313      	orrs	r3, r2
  21b854:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
  21b858:	687b      	ldr	r3, [r7, #4]
  21b85a:	681b      	ldr	r3, [r3, #0]
  21b85c:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21b860:	2b00      	cmp	r3, #0
  21b862:	d011      	beq.n	21b888 <HAL_RCCEx_PeriphCLKConfig+0x668>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
  21b864:	4920      	ldr	r1, [pc, #128]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b866:	687b      	ldr	r3, [r7, #4]
  21b868:	685b      	ldr	r3, [r3, #4]
  21b86a:	019a      	lsls	r2, r3, #6
  21b86c:	687b      	ldr	r3, [r7, #4]
  21b86e:	691b      	ldr	r3, [r3, #16]
  21b870:	041b      	lsls	r3, r3, #16
  21b872:	431a      	orrs	r2, r3
  21b874:	687b      	ldr	r3, [r7, #4]
  21b876:	68db      	ldr	r3, [r3, #12]
  21b878:	061b      	lsls	r3, r3, #24
  21b87a:	431a      	orrs	r2, r3
  21b87c:	687b      	ldr	r3, [r7, #4]
  21b87e:	689b      	ldr	r3, [r3, #8]
  21b880:	071b      	lsls	r3, r3, #28
  21b882:	4313      	orrs	r3, r2
  21b884:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
  21b888:	4a17      	ldr	r2, [pc, #92]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b88a:	4b17      	ldr	r3, [pc, #92]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b88c:	681b      	ldr	r3, [r3, #0]
  21b88e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
  21b892:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  21b894:	f7fd facc 	bl	218e30 <HAL_GetTick>
  21b898:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
  21b89a:	e008      	b.n	21b8ae <HAL_RCCEx_PeriphCLKConfig+0x68e>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
  21b89c:	f7fd fac8 	bl	218e30 <HAL_GetTick>
  21b8a0:	4602      	mov	r2, r0
  21b8a2:	697b      	ldr	r3, [r7, #20]
  21b8a4:	1ad3      	subs	r3, r2, r3
  21b8a6:	2b64      	cmp	r3, #100	; 0x64
  21b8a8:	d901      	bls.n	21b8ae <HAL_RCCEx_PeriphCLKConfig+0x68e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
  21b8aa:	2303      	movs	r3, #3
  21b8ac:	e0d7      	b.n	21ba5e <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
  21b8ae:	4b0e      	ldr	r3, [pc, #56]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b8b0:	681b      	ldr	r3, [r3, #0]
  21b8b2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  21b8b6:	2b00      	cmp	r3, #0
  21b8b8:	d0f0      	beq.n	21b89c <HAL_RCCEx_PeriphCLKConfig+0x67c>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
  21b8ba:	69bb      	ldr	r3, [r7, #24]
  21b8bc:	2b01      	cmp	r3, #1
  21b8be:	f040 80cd 	bne.w	21ba5c <HAL_RCCEx_PeriphCLKConfig+0x83c>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
  21b8c2:	4a09      	ldr	r2, [pc, #36]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b8c4:	4b08      	ldr	r3, [pc, #32]	; (21b8e8 <HAL_RCCEx_PeriphCLKConfig+0x6c8>)
  21b8c6:	681b      	ldr	r3, [r3, #0]
  21b8c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
  21b8cc:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  21b8ce:	f7fd faaf 	bl	218e30 <HAL_GetTick>
  21b8d2:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
  21b8d4:	e00a      	b.n	21b8ec <HAL_RCCEx_PeriphCLKConfig+0x6cc>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
  21b8d6:	f7fd faab 	bl	218e30 <HAL_GetTick>
  21b8da:	4602      	mov	r2, r0
  21b8dc:	697b      	ldr	r3, [r7, #20]
  21b8de:	1ad3      	subs	r3, r2, r3
  21b8e0:	2b64      	cmp	r3, #100	; 0x64
  21b8e2:	d903      	bls.n	21b8ec <HAL_RCCEx_PeriphCLKConfig+0x6cc>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
  21b8e4:	2303      	movs	r3, #3
  21b8e6:	e0ba      	b.n	21ba5e <HAL_RCCEx_PeriphCLKConfig+0x83e>
  21b8e8:	40023800 	.word	0x40023800
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
  21b8ec:	4b5e      	ldr	r3, [pc, #376]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b8ee:	681b      	ldr	r3, [r3, #0]
  21b8f0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
  21b8f4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  21b8f8:	d0ed      	beq.n	21b8d6 <HAL_RCCEx_PeriphCLKConfig+0x6b6>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
  21b8fa:	687b      	ldr	r3, [r7, #4]
  21b8fc:	681b      	ldr	r3, [r3, #0]
  21b8fe:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  21b902:	2b00      	cmp	r3, #0
  21b904:	d003      	beq.n	21b90e <HAL_RCCEx_PeriphCLKConfig+0x6ee>
  21b906:	687b      	ldr	r3, [r7, #4]
  21b908:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21b90a:	2b00      	cmp	r3, #0
  21b90c:	d009      	beq.n	21b922 <HAL_RCCEx_PeriphCLKConfig+0x702>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
  21b90e:	687b      	ldr	r3, [r7, #4]
  21b910:	681b      	ldr	r3, [r3, #0]
  21b912:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
  21b916:	2b00      	cmp	r3, #0
  21b918:	d02e      	beq.n	21b978 <HAL_RCCEx_PeriphCLKConfig+0x758>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
  21b91a:	687b      	ldr	r3, [r7, #4]
  21b91c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21b91e:	2b00      	cmp	r3, #0
  21b920:	d12a      	bne.n	21b978 <HAL_RCCEx_PeriphCLKConfig+0x758>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
  21b922:	4b51      	ldr	r3, [pc, #324]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b924:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b928:	0c1b      	lsrs	r3, r3, #16
  21b92a:	f003 0303 	and.w	r3, r3, #3
  21b92e:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
  21b930:	4b4d      	ldr	r3, [pc, #308]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b932:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b936:	0f1b      	lsrs	r3, r3, #28
  21b938:	f003 0307 	and.w	r3, r3, #7
  21b93c:	60fb      	str	r3, [r7, #12]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
  21b93e:	494a      	ldr	r1, [pc, #296]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b940:	687b      	ldr	r3, [r7, #4]
  21b942:	695b      	ldr	r3, [r3, #20]
  21b944:	019a      	lsls	r2, r3, #6
  21b946:	693b      	ldr	r3, [r7, #16]
  21b948:	041b      	lsls	r3, r3, #16
  21b94a:	431a      	orrs	r2, r3
  21b94c:	687b      	ldr	r3, [r7, #4]
  21b94e:	699b      	ldr	r3, [r3, #24]
  21b950:	061b      	lsls	r3, r3, #24
  21b952:	431a      	orrs	r2, r3
  21b954:	68fb      	ldr	r3, [r7, #12]
  21b956:	071b      	lsls	r3, r3, #28
  21b958:	4313      	orrs	r3, r2
  21b95a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
  21b95e:	4942      	ldr	r1, [pc, #264]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b960:	4b41      	ldr	r3, [pc, #260]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b962:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21b966:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
  21b96a:	687b      	ldr	r3, [r7, #4]
  21b96c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  21b96e:	3b01      	subs	r3, #1
  21b970:	021b      	lsls	r3, r3, #8
  21b972:	4313      	orrs	r3, r2
  21b974:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
  21b978:	687b      	ldr	r3, [r7, #4]
  21b97a:	681b      	ldr	r3, [r3, #0]
  21b97c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  21b980:	2b00      	cmp	r3, #0
  21b982:	d022      	beq.n	21b9ca <HAL_RCCEx_PeriphCLKConfig+0x7aa>
  21b984:	687b      	ldr	r3, [r7, #4]
  21b986:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  21b988:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  21b98c:	d11d      	bne.n	21b9ca <HAL_RCCEx_PeriphCLKConfig+0x7aa>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
  21b98e:	4b36      	ldr	r3, [pc, #216]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b990:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b994:	0e1b      	lsrs	r3, r3, #24
  21b996:	f003 030f 	and.w	r3, r3, #15
  21b99a:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
  21b99c:	4b32      	ldr	r3, [pc, #200]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b99e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b9a2:	0f1b      	lsrs	r3, r3, #28
  21b9a4:	f003 0307 	and.w	r3, r3, #7
  21b9a8:	60fb      	str	r3, [r7, #12]

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
  21b9aa:	492f      	ldr	r1, [pc, #188]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b9ac:	687b      	ldr	r3, [r7, #4]
  21b9ae:	695b      	ldr	r3, [r3, #20]
  21b9b0:	019a      	lsls	r2, r3, #6
  21b9b2:	687b      	ldr	r3, [r7, #4]
  21b9b4:	6a1b      	ldr	r3, [r3, #32]
  21b9b6:	041b      	lsls	r3, r3, #16
  21b9b8:	431a      	orrs	r2, r3
  21b9ba:	693b      	ldr	r3, [r7, #16]
  21b9bc:	061b      	lsls	r3, r3, #24
  21b9be:	431a      	orrs	r2, r3
  21b9c0:	68fb      	ldr	r3, [r7, #12]
  21b9c2:	071b      	lsls	r3, r3, #28
  21b9c4:	4313      	orrs	r3, r2
  21b9c6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
  21b9ca:	687b      	ldr	r3, [r7, #4]
  21b9cc:	681b      	ldr	r3, [r3, #0]
  21b9ce:	f003 0308 	and.w	r3, r3, #8
  21b9d2:	2b00      	cmp	r3, #0
  21b9d4:	d028      	beq.n	21ba28 <HAL_RCCEx_PeriphCLKConfig+0x808>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
  21b9d6:	4b24      	ldr	r3, [pc, #144]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b9d8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b9dc:	0e1b      	lsrs	r3, r3, #24
  21b9de:	f003 030f 	and.w	r3, r3, #15
  21b9e2:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
  21b9e4:	4b20      	ldr	r3, [pc, #128]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b9e6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
  21b9ea:	0c1b      	lsrs	r3, r3, #16
  21b9ec:	f003 0303 	and.w	r3, r3, #3
  21b9f0:	60fb      	str	r3, [r7, #12]

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
  21b9f2:	491d      	ldr	r1, [pc, #116]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21b9f4:	687b      	ldr	r3, [r7, #4]
  21b9f6:	695b      	ldr	r3, [r3, #20]
  21b9f8:	019a      	lsls	r2, r3, #6
  21b9fa:	68fb      	ldr	r3, [r7, #12]
  21b9fc:	041b      	lsls	r3, r3, #16
  21b9fe:	431a      	orrs	r2, r3
  21ba00:	693b      	ldr	r3, [r7, #16]
  21ba02:	061b      	lsls	r3, r3, #24
  21ba04:	431a      	orrs	r2, r3
  21ba06:	687b      	ldr	r3, [r7, #4]
  21ba08:	69db      	ldr	r3, [r3, #28]
  21ba0a:	071b      	lsls	r3, r3, #28
  21ba0c:	4313      	orrs	r3, r2
  21ba0e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
  21ba12:	4915      	ldr	r1, [pc, #84]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21ba14:	4b14      	ldr	r3, [pc, #80]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21ba16:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
  21ba1a:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
  21ba1e:	687b      	ldr	r3, [r7, #4]
  21ba20:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21ba22:	4313      	orrs	r3, r2
  21ba24:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
  21ba28:	4a0f      	ldr	r2, [pc, #60]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21ba2a:	4b0f      	ldr	r3, [pc, #60]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21ba2c:	681b      	ldr	r3, [r3, #0]
  21ba2e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
  21ba32:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
  21ba34:	f7fd f9fc 	bl	218e30 <HAL_GetTick>
  21ba38:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
  21ba3a:	e008      	b.n	21ba4e <HAL_RCCEx_PeriphCLKConfig+0x82e>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
  21ba3c:	f7fd f9f8 	bl	218e30 <HAL_GetTick>
  21ba40:	4602      	mov	r2, r0
  21ba42:	697b      	ldr	r3, [r7, #20]
  21ba44:	1ad3      	subs	r3, r2, r3
  21ba46:	2b64      	cmp	r3, #100	; 0x64
  21ba48:	d901      	bls.n	21ba4e <HAL_RCCEx_PeriphCLKConfig+0x82e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
  21ba4a:	2303      	movs	r3, #3
  21ba4c:	e007      	b.n	21ba5e <HAL_RCCEx_PeriphCLKConfig+0x83e>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
  21ba4e:	4b06      	ldr	r3, [pc, #24]	; (21ba68 <HAL_RCCEx_PeriphCLKConfig+0x848>)
  21ba50:	681b      	ldr	r3, [r3, #0]
  21ba52:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
  21ba56:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  21ba5a:	d1ef      	bne.n	21ba3c <HAL_RCCEx_PeriphCLKConfig+0x81c>
      }
    }
  }
  return HAL_OK;
  21ba5c:	2300      	movs	r3, #0
}
  21ba5e:	4618      	mov	r0, r3
  21ba60:	3720      	adds	r7, #32
  21ba62:	46bd      	mov	sp, r7
  21ba64:	bd80      	pop	{r7, pc}
  21ba66:	bf00      	nop
  21ba68:	40023800 	.word	0x40023800

0021ba6c <HAL_SD_Init>:
            SD_HandleTypeDef and create the associated handle.
  * @param  hsd: Pointer to the SD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_Init(SD_HandleTypeDef *hsd)
{
  21ba6c:	b580      	push	{r7, lr}
  21ba6e:	b082      	sub	sp, #8
  21ba70:	af00      	add	r7, sp, #0
  21ba72:	6078      	str	r0, [r7, #4]
  /* Check the SD handle allocation */
  if(hsd == NULL)
  21ba74:	687b      	ldr	r3, [r7, #4]
  21ba76:	2b00      	cmp	r3, #0
  21ba78:	d101      	bne.n	21ba7e <HAL_SD_Init+0x12>
  {
    return HAL_ERROR;
  21ba7a:	2301      	movs	r3, #1
  21ba7c:	e022      	b.n	21bac4 <HAL_SD_Init+0x58>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));

  if(hsd->State == HAL_SD_STATE_RESET)
  21ba7e:	687b      	ldr	r3, [r7, #4]
  21ba80:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
  21ba84:	b2db      	uxtb	r3, r3
  21ba86:	2b00      	cmp	r3, #0
  21ba88:	d105      	bne.n	21ba96 <HAL_SD_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    hsd->Lock = HAL_UNLOCKED;
  21ba8a:	687b      	ldr	r3, [r7, #4]
  21ba8c:	2200      	movs	r2, #0
  21ba8e:	771a      	strb	r2, [r3, #28]

    /* Init the low level hardware */
    hsd->MspInitCallback(hsd);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_SD_MspInit(hsd);
  21ba90:	6878      	ldr	r0, [r7, #4]
  21ba92:	f7fc fd75 	bl	218580 <HAL_SD_MspInit>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
  }

  hsd->State = HAL_SD_STATE_BUSY;
  21ba96:	687b      	ldr	r3, [r7, #4]
  21ba98:	2203      	movs	r2, #3
  21ba9a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Initialize the Card parameters */
  if (HAL_SD_InitCard(hsd) != HAL_OK)
  21ba9e:	6878      	ldr	r0, [r7, #4]
  21baa0:	f000 f814 	bl	21bacc <HAL_SD_InitCard>
  21baa4:	4603      	mov	r3, r0
  21baa6:	2b00      	cmp	r3, #0
  21baa8:	d001      	beq.n	21baae <HAL_SD_Init+0x42>
  {
    return HAL_ERROR;
  21baaa:	2301      	movs	r3, #1
  21baac:	e00a      	b.n	21bac4 <HAL_SD_Init+0x58>
  }

  /* Initialize the error code */
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
  21baae:	687b      	ldr	r3, [r7, #4]
  21bab0:	2200      	movs	r2, #0
  21bab2:	639a      	str	r2, [r3, #56]	; 0x38

  /* Initialize the SD operation */
  hsd->Context = SD_CONTEXT_NONE;
  21bab4:	687b      	ldr	r3, [r7, #4]
  21bab6:	2200      	movs	r2, #0
  21bab8:	631a      	str	r2, [r3, #48]	; 0x30

  /* Initialize the SD state */
  hsd->State = HAL_SD_STATE_READY;
  21baba:	687b      	ldr	r3, [r7, #4]
  21babc:	2201      	movs	r2, #1
  21babe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
  21bac2:	2300      	movs	r3, #0
}
  21bac4:	4618      	mov	r0, r3
  21bac6:	3708      	adds	r7, #8
  21bac8:	46bd      	mov	sp, r7
  21baca:	bd80      	pop	{r7, pc}

0021bacc <HAL_SD_InitCard>:
  * @note   This function initializes the SD card. It could be used when a card
            re-initialization is needed.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_InitCard(SD_HandleTypeDef *hsd)
{
  21bacc:	b5b0      	push	{r4, r5, r7, lr}
  21bace:	b08e      	sub	sp, #56	; 0x38
  21bad0:	af04      	add	r7, sp, #16
  21bad2:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  HAL_StatusTypeDef status;
  SD_InitTypeDef Init;
  
  /* Default SDMMC peripheral configuration for SD card initialization */
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
  21bad4:	2300      	movs	r3, #0
  21bad6:	60bb      	str	r3, [r7, #8]
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
  21bad8:	2300      	movs	r3, #0
  21bada:	60fb      	str	r3, [r7, #12]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  21badc:	2300      	movs	r3, #0
  21bade:	613b      	str	r3, [r7, #16]
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
  21bae0:	2300      	movs	r3, #0
  21bae2:	617b      	str	r3, [r7, #20]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  21bae4:	2300      	movs	r3, #0
  21bae6:	61bb      	str	r3, [r7, #24]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
  21bae8:	2376      	movs	r3, #118	; 0x76
  21baea:	61fb      	str	r3, [r7, #28]

  /* Initialize SDMMC peripheral interface with default configuration */
  status = SDMMC_Init(hsd->Instance, Init);
  21baec:	687b      	ldr	r3, [r7, #4]
  21baee:	681d      	ldr	r5, [r3, #0]
  21baf0:	466c      	mov	r4, sp
  21baf2:	f107 0314 	add.w	r3, r7, #20
  21baf6:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  21bafa:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  21bafe:	f107 0308 	add.w	r3, r7, #8
  21bb02:	cb0e      	ldmia	r3, {r1, r2, r3}
  21bb04:	4628      	mov	r0, r5
  21bb06:	f003 fa95 	bl	21f034 <SDMMC_Init>
  21bb0a:	4603      	mov	r3, r0
  21bb0c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  if(status != HAL_OK)
  21bb10:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  21bb14:	2b00      	cmp	r3, #0
  21bb16:	d001      	beq.n	21bb1c <HAL_SD_InitCard+0x50>
  {
    return HAL_ERROR;
  21bb18:	2301      	movs	r3, #1
  21bb1a:	e056      	b.n	21bbca <HAL_SD_InitCard+0xfe>
  }

  /* Disable SDMMC Clock */
  __HAL_SD_DISABLE(hsd);
  21bb1c:	687b      	ldr	r3, [r7, #4]
  21bb1e:	681b      	ldr	r3, [r3, #0]
  21bb20:	687a      	ldr	r2, [r7, #4]
  21bb22:	6812      	ldr	r2, [r2, #0]
  21bb24:	6852      	ldr	r2, [r2, #4]
  21bb26:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  21bb2a:	605a      	str	r2, [r3, #4]

  /* Set Power State to ON */
  (void)SDMMC_PowerState_ON(hsd->Instance);
  21bb2c:	687b      	ldr	r3, [r7, #4]
  21bb2e:	681b      	ldr	r3, [r3, #0]
  21bb30:	4618      	mov	r0, r3
  21bb32:	f003 fac9 	bl	21f0c8 <SDMMC_PowerState_ON>

  /* Enable SDMMC Clock */
  __HAL_SD_ENABLE(hsd);
  21bb36:	687b      	ldr	r3, [r7, #4]
  21bb38:	681b      	ldr	r3, [r3, #0]
  21bb3a:	687a      	ldr	r2, [r7, #4]
  21bb3c:	6812      	ldr	r2, [r2, #0]
  21bb3e:	6852      	ldr	r2, [r2, #4]
  21bb40:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  21bb44:	605a      	str	r2, [r3, #4]

  /* Identify card operating voltage */
  errorstate = SD_PowerON(hsd);
  21bb46:	6878      	ldr	r0, [r7, #4]
  21bb48:	f000 fff4 	bl	21cb34 <SD_PowerON>
  21bb4c:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
  21bb4e:	6a3b      	ldr	r3, [r7, #32]
  21bb50:	2b00      	cmp	r3, #0
  21bb52:	d00b      	beq.n	21bb6c <HAL_SD_InitCard+0xa0>
  {
    hsd->State = HAL_SD_STATE_READY;
  21bb54:	687b      	ldr	r3, [r7, #4]
  21bb56:	2201      	movs	r2, #1
  21bb58:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
  21bb5c:	687b      	ldr	r3, [r7, #4]
  21bb5e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21bb60:	6a3b      	ldr	r3, [r7, #32]
  21bb62:	431a      	orrs	r2, r3
  21bb64:	687b      	ldr	r3, [r7, #4]
  21bb66:	639a      	str	r2, [r3, #56]	; 0x38
    return HAL_ERROR;
  21bb68:	2301      	movs	r3, #1
  21bb6a:	e02e      	b.n	21bbca <HAL_SD_InitCard+0xfe>
  }

  /* Card initialization */
  errorstate = SD_InitCard(hsd);
  21bb6c:	6878      	ldr	r0, [r7, #4]
  21bb6e:	f000 ff13 	bl	21c998 <SD_InitCard>
  21bb72:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
  21bb74:	6a3b      	ldr	r3, [r7, #32]
  21bb76:	2b00      	cmp	r3, #0
  21bb78:	d00b      	beq.n	21bb92 <HAL_SD_InitCard+0xc6>
  {
    hsd->State = HAL_SD_STATE_READY;
  21bb7a:	687b      	ldr	r3, [r7, #4]
  21bb7c:	2201      	movs	r2, #1
  21bb7e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
  21bb82:	687b      	ldr	r3, [r7, #4]
  21bb84:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21bb86:	6a3b      	ldr	r3, [r7, #32]
  21bb88:	431a      	orrs	r2, r3
  21bb8a:	687b      	ldr	r3, [r7, #4]
  21bb8c:	639a      	str	r2, [r3, #56]	; 0x38
    return HAL_ERROR;
  21bb8e:	2301      	movs	r3, #1
  21bb90:	e01b      	b.n	21bbca <HAL_SD_InitCard+0xfe>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
  21bb92:	687b      	ldr	r3, [r7, #4]
  21bb94:	681b      	ldr	r3, [r3, #0]
  21bb96:	f44f 7100 	mov.w	r1, #512	; 0x200
  21bb9a:	4618      	mov	r0, r3
  21bb9c:	f003 fb28 	bl	21f1f0 <SDMMC_CmdBlockLength>
  21bba0:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
  21bba2:	6a3b      	ldr	r3, [r7, #32]
  21bba4:	2b00      	cmp	r3, #0
  21bba6:	d00f      	beq.n	21bbc8 <HAL_SD_InitCard+0xfc>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21bba8:	687b      	ldr	r3, [r7, #4]
  21bbaa:	681b      	ldr	r3, [r3, #0]
  21bbac:	4a09      	ldr	r2, [pc, #36]	; (21bbd4 <HAL_SD_InitCard+0x108>)
  21bbae:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
  21bbb0:	687b      	ldr	r3, [r7, #4]
  21bbb2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21bbb4:	6a3b      	ldr	r3, [r7, #32]
  21bbb6:	431a      	orrs	r2, r3
  21bbb8:	687b      	ldr	r3, [r7, #4]
  21bbba:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
  21bbbc:	687b      	ldr	r3, [r7, #4]
  21bbbe:	2201      	movs	r2, #1
  21bbc0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
  21bbc4:	2301      	movs	r3, #1
  21bbc6:	e000      	b.n	21bbca <HAL_SD_InitCard+0xfe>
  }

  return HAL_OK;
  21bbc8:	2300      	movs	r3, #0
}
  21bbca:	4618      	mov	r0, r3
  21bbcc:	3728      	adds	r7, #40	; 0x28
  21bbce:	46bd      	mov	sp, r7
  21bbd0:	bdb0      	pop	{r4, r5, r7, pc}
  21bbd2:	bf00      	nop
  21bbd4:	004005ff 	.word	0x004005ff

0021bbd8 <HAL_SD_ReadBlocks_DMA>:
  * @param  BlockAdd: Block Address from where data is to be read
  * @param  NumberOfBlocks: Number of blocks to read.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
{
  21bbd8:	b580      	push	{r7, lr}
  21bbda:	b08c      	sub	sp, #48	; 0x30
  21bbdc:	af00      	add	r7, sp, #0
  21bbde:	60f8      	str	r0, [r7, #12]
  21bbe0:	60b9      	str	r1, [r7, #8]
  21bbe2:	607a      	str	r2, [r7, #4]
  21bbe4:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
  21bbe6:	687b      	ldr	r3, [r7, #4]
  21bbe8:	62bb      	str	r3, [r7, #40]	; 0x28

  if(NULL == pData)
  21bbea:	68bb      	ldr	r3, [r7, #8]
  21bbec:	2b00      	cmp	r3, #0
  21bbee:	d107      	bne.n	21bc00 <HAL_SD_ReadBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
  21bbf0:	68fb      	ldr	r3, [r7, #12]
  21bbf2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21bbf4:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
  21bbf8:	68fb      	ldr	r3, [r7, #12]
  21bbfa:	639a      	str	r2, [r3, #56]	; 0x38
    return HAL_ERROR;
  21bbfc:	2301      	movs	r3, #1
  21bbfe:	e0c3      	b.n	21bd88 <HAL_SD_ReadBlocks_DMA+0x1b0>
  }

  if(hsd->State == HAL_SD_STATE_READY)
  21bc00:	68fb      	ldr	r3, [r7, #12]
  21bc02:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
  21bc06:	b2db      	uxtb	r3, r3
  21bc08:	2b01      	cmp	r3, #1
  21bc0a:	f040 80bc 	bne.w	21bd86 <HAL_SD_ReadBlocks_DMA+0x1ae>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
  21bc0e:	68fb      	ldr	r3, [r7, #12]
  21bc10:	2200      	movs	r2, #0
  21bc12:	639a      	str	r2, [r3, #56]	; 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
  21bc14:	6aba      	ldr	r2, [r7, #40]	; 0x28
  21bc16:	683b      	ldr	r3, [r7, #0]
  21bc18:	441a      	add	r2, r3
  21bc1a:	68fb      	ldr	r3, [r7, #12]
  21bc1c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  21bc1e:	429a      	cmp	r2, r3
  21bc20:	d907      	bls.n	21bc32 <HAL_SD_ReadBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
  21bc22:	68fb      	ldr	r3, [r7, #12]
  21bc24:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21bc26:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
  21bc2a:	68fb      	ldr	r3, [r7, #12]
  21bc2c:	639a      	str	r2, [r3, #56]	; 0x38
      return HAL_ERROR;
  21bc2e:	2301      	movs	r3, #1
  21bc30:	e0aa      	b.n	21bd88 <HAL_SD_ReadBlocks_DMA+0x1b0>
    }

    hsd->State = HAL_SD_STATE_BUSY;
  21bc32:	68fb      	ldr	r3, [r7, #12]
  21bc34:	2203      	movs	r2, #3
  21bc36:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
  21bc3a:	68fb      	ldr	r3, [r7, #12]
  21bc3c:	681b      	ldr	r3, [r3, #0]
  21bc3e:	2200      	movs	r2, #0
  21bc40:	62da      	str	r2, [r3, #44]	; 0x2c

    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
  21bc42:	68fb      	ldr	r3, [r7, #12]
  21bc44:	681b      	ldr	r3, [r3, #0]
  21bc46:	68fa      	ldr	r2, [r7, #12]
  21bc48:	6812      	ldr	r2, [r2, #0]
  21bc4a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21bc4c:	f442 7295 	orr.w	r2, r2, #298	; 0x12a
  21bc50:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA transfer complete callback */
    hsd->hdmarx->XferCpltCallback = SD_DMAReceiveCplt;
  21bc52:	68fb      	ldr	r3, [r7, #12]
  21bc54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21bc56:	4a4e      	ldr	r2, [pc, #312]	; (21bd90 <HAL_SD_ReadBlocks_DMA+0x1b8>)
  21bc58:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA error callback */
    hsd->hdmarx->XferErrorCallback = SD_DMAError;
  21bc5a:	68fb      	ldr	r3, [r7, #12]
  21bc5c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21bc5e:	4a4d      	ldr	r2, [pc, #308]	; (21bd94 <HAL_SD_ReadBlocks_DMA+0x1bc>)
  21bc60:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA Abort callback */
    hsd->hdmarx->XferAbortCallback = NULL;
  21bc62:	68fb      	ldr	r3, [r7, #12]
  21bc64:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21bc66:	2200      	movs	r2, #0
  21bc68:	651a      	str	r2, [r3, #80]	; 0x50

    /* Force DMA Direction */
    hsd->hdmarx->Init.Direction = DMA_PERIPH_TO_MEMORY;
  21bc6a:	68fb      	ldr	r3, [r7, #12]
  21bc6c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21bc6e:	2200      	movs	r2, #0
  21bc70:	609a      	str	r2, [r3, #8]
    MODIFY_REG(hsd->hdmarx->Instance->CR, DMA_SxCR_DIR, hsd->hdmarx->Init.Direction);
  21bc72:	68fb      	ldr	r3, [r7, #12]
  21bc74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21bc76:	681b      	ldr	r3, [r3, #0]
  21bc78:	68fa      	ldr	r2, [r7, #12]
  21bc7a:	6c12      	ldr	r2, [r2, #64]	; 0x40
  21bc7c:	6812      	ldr	r2, [r2, #0]
  21bc7e:	6812      	ldr	r2, [r2, #0]
  21bc80:	f022 01c0 	bic.w	r1, r2, #192	; 0xc0
  21bc84:	68fa      	ldr	r2, [r7, #12]
  21bc86:	6c12      	ldr	r2, [r2, #64]	; 0x40
  21bc88:	6892      	ldr	r2, [r2, #8]
  21bc8a:	430a      	orrs	r2, r1
  21bc8c:	601a      	str	r2, [r3, #0]

    /* Enable the DMA Channel */
    if(HAL_DMA_Start_IT(hsd->hdmarx, (uint32_t)&hsd->Instance->FIFO, (uint32_t)pData, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
  21bc8e:	68fb      	ldr	r3, [r7, #12]
  21bc90:	6c18      	ldr	r0, [r3, #64]	; 0x40
  21bc92:	68fb      	ldr	r3, [r7, #12]
  21bc94:	681b      	ldr	r3, [r3, #0]
  21bc96:	3380      	adds	r3, #128	; 0x80
  21bc98:	4619      	mov	r1, r3
  21bc9a:	68ba      	ldr	r2, [r7, #8]
  21bc9c:	683b      	ldr	r3, [r7, #0]
  21bc9e:	025b      	lsls	r3, r3, #9
  21bca0:	089b      	lsrs	r3, r3, #2
  21bca2:	f7fd faf9 	bl	219298 <HAL_DMA_Start_IT>
  21bca6:	4603      	mov	r3, r0
  21bca8:	2b00      	cmp	r3, #0
  21bcaa:	d017      	beq.n	21bcdc <HAL_SD_ReadBlocks_DMA+0x104>
    {
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_RXOVERR | SDMMC_IT_DATAEND));
  21bcac:	68fb      	ldr	r3, [r7, #12]
  21bcae:	681b      	ldr	r3, [r3, #0]
  21bcb0:	68fa      	ldr	r2, [r7, #12]
  21bcb2:	6812      	ldr	r2, [r2, #0]
  21bcb4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21bcb6:	f422 7295 	bic.w	r2, r2, #298	; 0x12a
  21bcba:	63da      	str	r2, [r3, #60]	; 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21bcbc:	68fb      	ldr	r3, [r7, #12]
  21bcbe:	681b      	ldr	r3, [r3, #0]
  21bcc0:	4a35      	ldr	r2, [pc, #212]	; (21bd98 <HAL_SD_ReadBlocks_DMA+0x1c0>)
  21bcc2:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
  21bcc4:	68fb      	ldr	r3, [r7, #12]
  21bcc6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21bcc8:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
  21bccc:	68fb      	ldr	r3, [r7, #12]
  21bcce:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
  21bcd0:	68fb      	ldr	r3, [r7, #12]
  21bcd2:	2201      	movs	r2, #1
  21bcd4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      return HAL_ERROR;
  21bcd8:	2301      	movs	r3, #1
  21bcda:	e055      	b.n	21bd88 <HAL_SD_ReadBlocks_DMA+0x1b0>
    }
    else
    {
      /* Enable SD DMA transfer */
      __HAL_SD_DMA_ENABLE(hsd);
  21bcdc:	68fb      	ldr	r3, [r7, #12]
  21bcde:	681b      	ldr	r3, [r3, #0]
  21bce0:	68fa      	ldr	r2, [r7, #12]
  21bce2:	6812      	ldr	r2, [r2, #0]
  21bce4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21bce6:	f042 0208 	orr.w	r2, r2, #8
  21bcea:	62da      	str	r2, [r3, #44]	; 0x2c

      if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
  21bcec:	68fb      	ldr	r3, [r7, #12]
  21bcee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21bcf0:	2b01      	cmp	r3, #1
  21bcf2:	d002      	beq.n	21bcfa <HAL_SD_ReadBlocks_DMA+0x122>
      {
        add *= 512U;
  21bcf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21bcf6:	025b      	lsls	r3, r3, #9
  21bcf8:	62bb      	str	r3, [r7, #40]	; 0x28
      }

      /* Configure the SD DPSM (Data Path State Machine) */
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
  21bcfa:	f04f 33ff 	mov.w	r3, #4294967295
  21bcfe:	613b      	str	r3, [r7, #16]
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
  21bd00:	683b      	ldr	r3, [r7, #0]
  21bd02:	025b      	lsls	r3, r3, #9
  21bd04:	617b      	str	r3, [r7, #20]
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
  21bd06:	2390      	movs	r3, #144	; 0x90
  21bd08:	61bb      	str	r3, [r7, #24]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
  21bd0a:	2302      	movs	r3, #2
  21bd0c:	61fb      	str	r3, [r7, #28]
      config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  21bd0e:	2300      	movs	r3, #0
  21bd10:	623b      	str	r3, [r7, #32]
      config.DPSM          = SDMMC_DPSM_ENABLE;
  21bd12:	2301      	movs	r3, #1
  21bd14:	627b      	str	r3, [r7, #36]	; 0x24
      (void)SDMMC_ConfigData(hsd->Instance, &config);
  21bd16:	68fb      	ldr	r3, [r7, #12]
  21bd18:	681b      	ldr	r3, [r3, #0]
  21bd1a:	f107 0210 	add.w	r2, r7, #16
  21bd1e:	4611      	mov	r1, r2
  21bd20:	4618      	mov	r0, r3
  21bd22:	f003 fa39 	bl	21f198 <SDMMC_ConfigData>

      /* Read Blocks in DMA mode */
      if(NumberOfBlocks > 1U)
  21bd26:	683b      	ldr	r3, [r7, #0]
  21bd28:	2b01      	cmp	r3, #1
  21bd2a:	d90a      	bls.n	21bd42 <HAL_SD_ReadBlocks_DMA+0x16a>
      {
        hsd->Context = (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
  21bd2c:	68fb      	ldr	r3, [r7, #12]
  21bd2e:	2282      	movs	r2, #130	; 0x82
  21bd30:	631a      	str	r2, [r3, #48]	; 0x30

        /* Read Multi Block command */
        errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
  21bd32:	68fb      	ldr	r3, [r7, #12]
  21bd34:	681b      	ldr	r3, [r3, #0]
  21bd36:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  21bd38:	4618      	mov	r0, r3
  21bd3a:	f003 fa9d 	bl	21f278 <SDMMC_CmdReadMultiBlock>
  21bd3e:	62f8      	str	r0, [r7, #44]	; 0x2c
  21bd40:	e009      	b.n	21bd56 <HAL_SD_ReadBlocks_DMA+0x17e>
      }
      else
      {
        hsd->Context = (SD_CONTEXT_READ_SINGLE_BLOCK | SD_CONTEXT_DMA);
  21bd42:	68fb      	ldr	r3, [r7, #12]
  21bd44:	2281      	movs	r2, #129	; 0x81
  21bd46:	631a      	str	r2, [r3, #48]	; 0x30

        /* Read Single Block command */
        errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
  21bd48:	68fb      	ldr	r3, [r7, #12]
  21bd4a:	681b      	ldr	r3, [r3, #0]
  21bd4c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  21bd4e:	4618      	mov	r0, r3
  21bd50:	f003 fa70 	bl	21f234 <SDMMC_CmdReadSingleBlock>
  21bd54:	62f8      	str	r0, [r7, #44]	; 0x2c
      }
      if(errorstate != HAL_SD_ERROR_NONE)
  21bd56:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21bd58:	2b00      	cmp	r3, #0
  21bd5a:	d012      	beq.n	21bd82 <HAL_SD_ReadBlocks_DMA+0x1aa>
      {
        /* Clear all the static flags */
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21bd5c:	68fb      	ldr	r3, [r7, #12]
  21bd5e:	681b      	ldr	r3, [r3, #0]
  21bd60:	4a0d      	ldr	r2, [pc, #52]	; (21bd98 <HAL_SD_ReadBlocks_DMA+0x1c0>)
  21bd62:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
  21bd64:	68fb      	ldr	r3, [r7, #12]
  21bd66:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21bd68:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21bd6a:	431a      	orrs	r2, r3
  21bd6c:	68fb      	ldr	r3, [r7, #12]
  21bd6e:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
  21bd70:	68fb      	ldr	r3, [r7, #12]
  21bd72:	2201      	movs	r2, #1
  21bd74:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
  21bd78:	68fb      	ldr	r3, [r7, #12]
  21bd7a:	2200      	movs	r2, #0
  21bd7c:	631a      	str	r2, [r3, #48]	; 0x30
        return HAL_ERROR;
  21bd7e:	2301      	movs	r3, #1
  21bd80:	e002      	b.n	21bd88 <HAL_SD_ReadBlocks_DMA+0x1b0>
      }

      return HAL_OK;
  21bd82:	2300      	movs	r3, #0
  21bd84:	e000      	b.n	21bd88 <HAL_SD_ReadBlocks_DMA+0x1b0>
    }
  }
  else
  {
    return HAL_BUSY;
  21bd86:	2302      	movs	r3, #2
  }
}
  21bd88:	4618      	mov	r0, r3
  21bd8a:	3730      	adds	r7, #48	; 0x30
  21bd8c:	46bd      	mov	sp, r7
  21bd8e:	bd80      	pop	{r7, pc}
  21bd90:	0021c7a7 	.word	0x0021c7a7
  21bd94:	0021c819 	.word	0x0021c819
  21bd98:	004005ff 	.word	0x004005ff

0021bd9c <HAL_SD_WriteBlocks_DMA>:
  * @param  BlockAdd: Block Address where data will be written
  * @param  NumberOfBlocks: Number of blocks to write
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks_DMA(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks)
{
  21bd9c:	b580      	push	{r7, lr}
  21bd9e:	b08c      	sub	sp, #48	; 0x30
  21bda0:	af00      	add	r7, sp, #0
  21bda2:	60f8      	str	r0, [r7, #12]
  21bda4:	60b9      	str	r1, [r7, #8]
  21bda6:	607a      	str	r2, [r7, #4]
  21bda8:	603b      	str	r3, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t add = BlockAdd;
  21bdaa:	687b      	ldr	r3, [r7, #4]
  21bdac:	62bb      	str	r3, [r7, #40]	; 0x28

  if(NULL == pData)
  21bdae:	68bb      	ldr	r3, [r7, #8]
  21bdb0:	2b00      	cmp	r3, #0
  21bdb2:	d107      	bne.n	21bdc4 <HAL_SD_WriteBlocks_DMA+0x28>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
  21bdb4:	68fb      	ldr	r3, [r7, #12]
  21bdb6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21bdb8:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
  21bdbc:	68fb      	ldr	r3, [r7, #12]
  21bdbe:	639a      	str	r2, [r3, #56]	; 0x38
    return HAL_ERROR;
  21bdc0:	2301      	movs	r3, #1
  21bdc2:	e0c6      	b.n	21bf52 <HAL_SD_WriteBlocks_DMA+0x1b6>
  }

  if(hsd->State == HAL_SD_STATE_READY)
  21bdc4:	68fb      	ldr	r3, [r7, #12]
  21bdc6:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
  21bdca:	b2db      	uxtb	r3, r3
  21bdcc:	2b01      	cmp	r3, #1
  21bdce:	f040 80bf 	bne.w	21bf50 <HAL_SD_WriteBlocks_DMA+0x1b4>
  {
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
  21bdd2:	68fb      	ldr	r3, [r7, #12]
  21bdd4:	2200      	movs	r2, #0
  21bdd6:	639a      	str	r2, [r3, #56]	; 0x38

    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
  21bdd8:	6aba      	ldr	r2, [r7, #40]	; 0x28
  21bdda:	683b      	ldr	r3, [r7, #0]
  21bddc:	441a      	add	r2, r3
  21bdde:	68fb      	ldr	r3, [r7, #12]
  21bde0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
  21bde2:	429a      	cmp	r2, r3
  21bde4:	d907      	bls.n	21bdf6 <HAL_SD_WriteBlocks_DMA+0x5a>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
  21bde6:	68fb      	ldr	r3, [r7, #12]
  21bde8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21bdea:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
  21bdee:	68fb      	ldr	r3, [r7, #12]
  21bdf0:	639a      	str	r2, [r3, #56]	; 0x38
      return HAL_ERROR;
  21bdf2:	2301      	movs	r3, #1
  21bdf4:	e0ad      	b.n	21bf52 <HAL_SD_WriteBlocks_DMA+0x1b6>
    }

    hsd->State = HAL_SD_STATE_BUSY;
  21bdf6:	68fb      	ldr	r3, [r7, #12]
  21bdf8:	2203      	movs	r2, #3
  21bdfa:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

    /* Initialize data control register */
    hsd->Instance->DCTRL = 0U;
  21bdfe:	68fb      	ldr	r3, [r7, #12]
  21be00:	681b      	ldr	r3, [r3, #0]
  21be02:	2200      	movs	r2, #0
  21be04:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Enable SD Error interrupts */
    __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
  21be06:	68fb      	ldr	r3, [r7, #12]
  21be08:	681b      	ldr	r3, [r3, #0]
  21be0a:	68fa      	ldr	r2, [r7, #12]
  21be0c:	6812      	ldr	r2, [r2, #0]
  21be0e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21be10:	f042 021a 	orr.w	r2, r2, #26
  21be14:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA transfer complete callback */
    hsd->hdmatx->XferCpltCallback = SD_DMATransmitCplt;
  21be16:	68fb      	ldr	r3, [r7, #12]
  21be18:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21be1a:	4a50      	ldr	r2, [pc, #320]	; (21bf5c <HAL_SD_WriteBlocks_DMA+0x1c0>)
  21be1c:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the DMA error callback */
    hsd->hdmatx->XferErrorCallback = SD_DMAError;
  21be1e:	68fb      	ldr	r3, [r7, #12]
  21be20:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21be22:	4a4f      	ldr	r2, [pc, #316]	; (21bf60 <HAL_SD_WriteBlocks_DMA+0x1c4>)
  21be24:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA Abort callback */
    hsd->hdmatx->XferAbortCallback = NULL;
  21be26:	68fb      	ldr	r3, [r7, #12]
  21be28:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21be2a:	2200      	movs	r2, #0
  21be2c:	651a      	str	r2, [r3, #80]	; 0x50

    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
  21be2e:	68fb      	ldr	r3, [r7, #12]
  21be30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21be32:	2b01      	cmp	r3, #1
  21be34:	d002      	beq.n	21be3c <HAL_SD_WriteBlocks_DMA+0xa0>
    {
      add *= 512U;
  21be36:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21be38:	025b      	lsls	r3, r3, #9
  21be3a:	62bb      	str	r3, [r7, #40]	; 0x28
    }

    /* Write Blocks in Polling mode */
    if(NumberOfBlocks > 1U)
  21be3c:	683b      	ldr	r3, [r7, #0]
  21be3e:	2b01      	cmp	r3, #1
  21be40:	d90a      	bls.n	21be58 <HAL_SD_WriteBlocks_DMA+0xbc>
    {
      hsd->Context = (SD_CONTEXT_WRITE_MULTIPLE_BLOCK | SD_CONTEXT_DMA);
  21be42:	68fb      	ldr	r3, [r7, #12]
  21be44:	22a0      	movs	r2, #160	; 0xa0
  21be46:	631a      	str	r2, [r3, #48]	; 0x30

      /* Write Multi Block command */
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
  21be48:	68fb      	ldr	r3, [r7, #12]
  21be4a:	681b      	ldr	r3, [r3, #0]
  21be4c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  21be4e:	4618      	mov	r0, r3
  21be50:	f003 fa56 	bl	21f300 <SDMMC_CmdWriteMultiBlock>
  21be54:	62f8      	str	r0, [r7, #44]	; 0x2c
  21be56:	e009      	b.n	21be6c <HAL_SD_WriteBlocks_DMA+0xd0>
    }
    else
    {
      hsd->Context = (SD_CONTEXT_WRITE_SINGLE_BLOCK | SD_CONTEXT_DMA);
  21be58:	68fb      	ldr	r3, [r7, #12]
  21be5a:	2290      	movs	r2, #144	; 0x90
  21be5c:	631a      	str	r2, [r3, #48]	; 0x30

      /* Write Single Block command */
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
  21be5e:	68fb      	ldr	r3, [r7, #12]
  21be60:	681b      	ldr	r3, [r3, #0]
  21be62:	6ab9      	ldr	r1, [r7, #40]	; 0x28
  21be64:	4618      	mov	r0, r3
  21be66:	f003 fa29 	bl	21f2bc <SDMMC_CmdWriteSingleBlock>
  21be6a:	62f8      	str	r0, [r7, #44]	; 0x2c
    }
    if(errorstate != HAL_SD_ERROR_NONE)
  21be6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21be6e:	2b00      	cmp	r3, #0
  21be70:	d012      	beq.n	21be98 <HAL_SD_WriteBlocks_DMA+0xfc>
    {
      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21be72:	68fb      	ldr	r3, [r7, #12]
  21be74:	681b      	ldr	r3, [r3, #0]
  21be76:	4a3b      	ldr	r2, [pc, #236]	; (21bf64 <HAL_SD_WriteBlocks_DMA+0x1c8>)
  21be78:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
  21be7a:	68fb      	ldr	r3, [r7, #12]
  21be7c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21be7e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21be80:	431a      	orrs	r2, r3
  21be82:	68fb      	ldr	r3, [r7, #12]
  21be84:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
  21be86:	68fb      	ldr	r3, [r7, #12]
  21be88:	2201      	movs	r2, #1
  21be8a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
  21be8e:	68fb      	ldr	r3, [r7, #12]
  21be90:	2200      	movs	r2, #0
  21be92:	631a      	str	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
  21be94:	2301      	movs	r3, #1
  21be96:	e05c      	b.n	21bf52 <HAL_SD_WriteBlocks_DMA+0x1b6>
    }

    /* Enable SDMMC DMA transfer */
    __HAL_SD_DMA_ENABLE(hsd);
  21be98:	68fb      	ldr	r3, [r7, #12]
  21be9a:	681b      	ldr	r3, [r3, #0]
  21be9c:	68fa      	ldr	r2, [r7, #12]
  21be9e:	6812      	ldr	r2, [r2, #0]
  21bea0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21bea2:	f042 0208 	orr.w	r2, r2, #8
  21bea6:	62da      	str	r2, [r3, #44]	; 0x2c

    /* Force DMA Direction */
    hsd->hdmatx->Init.Direction = DMA_MEMORY_TO_PERIPH;
  21bea8:	68fb      	ldr	r3, [r7, #12]
  21beaa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21beac:	2240      	movs	r2, #64	; 0x40
  21beae:	609a      	str	r2, [r3, #8]
    MODIFY_REG(hsd->hdmatx->Instance->CR, DMA_SxCR_DIR, hsd->hdmatx->Init.Direction);
  21beb0:	68fb      	ldr	r3, [r7, #12]
  21beb2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21beb4:	681b      	ldr	r3, [r3, #0]
  21beb6:	68fa      	ldr	r2, [r7, #12]
  21beb8:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21beba:	6812      	ldr	r2, [r2, #0]
  21bebc:	6812      	ldr	r2, [r2, #0]
  21bebe:	f022 01c0 	bic.w	r1, r2, #192	; 0xc0
  21bec2:	68fa      	ldr	r2, [r7, #12]
  21bec4:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21bec6:	6892      	ldr	r2, [r2, #8]
  21bec8:	430a      	orrs	r2, r1
  21beca:	601a      	str	r2, [r3, #0]

    /* Enable the DMA Channel */
    if(HAL_DMA_Start_IT(hsd->hdmatx, (uint32_t)pData, (uint32_t)&hsd->Instance->FIFO, (uint32_t)(BLOCKSIZE * NumberOfBlocks)/4U) != HAL_OK)
  21becc:	68fb      	ldr	r3, [r7, #12]
  21bece:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
  21bed0:	68b9      	ldr	r1, [r7, #8]
  21bed2:	68fb      	ldr	r3, [r7, #12]
  21bed4:	681b      	ldr	r3, [r3, #0]
  21bed6:	3380      	adds	r3, #128	; 0x80
  21bed8:	461a      	mov	r2, r3
  21beda:	683b      	ldr	r3, [r7, #0]
  21bedc:	025b      	lsls	r3, r3, #9
  21bede:	089b      	lsrs	r3, r3, #2
  21bee0:	f7fd f9da 	bl	219298 <HAL_DMA_Start_IT>
  21bee4:	4603      	mov	r3, r0
  21bee6:	2b00      	cmp	r3, #0
  21bee8:	d01a      	beq.n	21bf20 <HAL_SD_WriteBlocks_DMA+0x184>
    {
      __HAL_SD_DISABLE_IT(hsd, (SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT | SDMMC_IT_TXUNDERR));   
  21beea:	68fb      	ldr	r3, [r7, #12]
  21beec:	681b      	ldr	r3, [r3, #0]
  21beee:	68fa      	ldr	r2, [r7, #12]
  21bef0:	6812      	ldr	r2, [r2, #0]
  21bef2:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21bef4:	f022 021a 	bic.w	r2, r2, #26
  21bef8:	63da      	str	r2, [r3, #60]	; 0x3c
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21befa:	68fb      	ldr	r3, [r7, #12]
  21befc:	681b      	ldr	r3, [r3, #0]
  21befe:	4a19      	ldr	r2, [pc, #100]	; (21bf64 <HAL_SD_WriteBlocks_DMA+0x1c8>)
  21bf00:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
  21bf02:	68fb      	ldr	r3, [r7, #12]
  21bf04:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21bf06:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
  21bf0a:	68fb      	ldr	r3, [r7, #12]
  21bf0c:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
  21bf0e:	68fb      	ldr	r3, [r7, #12]
  21bf10:	2201      	movs	r2, #1
  21bf12:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
  21bf16:	68fb      	ldr	r3, [r7, #12]
  21bf18:	2200      	movs	r2, #0
  21bf1a:	631a      	str	r2, [r3, #48]	; 0x30
      return HAL_ERROR;
  21bf1c:	2301      	movs	r3, #1
  21bf1e:	e018      	b.n	21bf52 <HAL_SD_WriteBlocks_DMA+0x1b6>
    }
    else
    {
      /* Configure the SD DPSM (Data Path State Machine) */
      config.DataTimeOut   = SDMMC_DATATIMEOUT;
  21bf20:	f04f 33ff 	mov.w	r3, #4294967295
  21bf24:	613b      	str	r3, [r7, #16]
      config.DataLength    = BLOCKSIZE * NumberOfBlocks;
  21bf26:	683b      	ldr	r3, [r7, #0]
  21bf28:	025b      	lsls	r3, r3, #9
  21bf2a:	617b      	str	r3, [r7, #20]
      config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
  21bf2c:	2390      	movs	r3, #144	; 0x90
  21bf2e:	61bb      	str	r3, [r7, #24]
      config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
  21bf30:	2300      	movs	r3, #0
  21bf32:	61fb      	str	r3, [r7, #28]
      config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  21bf34:	2300      	movs	r3, #0
  21bf36:	623b      	str	r3, [r7, #32]
      config.DPSM          = SDMMC_DPSM_ENABLE;
  21bf38:	2301      	movs	r3, #1
  21bf3a:	627b      	str	r3, [r7, #36]	; 0x24
      (void)SDMMC_ConfigData(hsd->Instance, &config);
  21bf3c:	68fb      	ldr	r3, [r7, #12]
  21bf3e:	681b      	ldr	r3, [r3, #0]
  21bf40:	f107 0210 	add.w	r2, r7, #16
  21bf44:	4611      	mov	r1, r2
  21bf46:	4618      	mov	r0, r3
  21bf48:	f003 f926 	bl	21f198 <SDMMC_ConfigData>

      return HAL_OK;
  21bf4c:	2300      	movs	r3, #0
  21bf4e:	e000      	b.n	21bf52 <HAL_SD_WriteBlocks_DMA+0x1b6>
    }
  }
  else
  {
    return HAL_BUSY;
  21bf50:	2302      	movs	r3, #2
  }
}
  21bf52:	4618      	mov	r0, r3
  21bf54:	3730      	adds	r7, #48	; 0x30
  21bf56:	46bd      	mov	sp, r7
  21bf58:	bd80      	pop	{r7, pc}
  21bf5a:	bf00      	nop
  21bf5c:	0021c77d 	.word	0x0021c77d
  21bf60:	0021c819 	.word	0x0021c819
  21bf64:	004005ff 	.word	0x004005ff

0021bf68 <HAL_SD_IRQHandler>:
  * @brief  This function handles SD card interrupt request.
  * @param  hsd: Pointer to SD handle
  * @retval None
  */
void HAL_SD_IRQHandler(SD_HandleTypeDef *hsd)
{
  21bf68:	b580      	push	{r7, lr}
  21bf6a:	b084      	sub	sp, #16
  21bf6c:	af00      	add	r7, sp, #0
  21bf6e:	6078      	str	r0, [r7, #4]
  uint32_t errorstate;
  uint32_t context = hsd->Context;
  21bf70:	687b      	ldr	r3, [r7, #4]
  21bf72:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21bf74:	60fb      	str	r3, [r7, #12]

  /* Check for SDMMC interrupt flags */
  if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
  21bf76:	687b      	ldr	r3, [r7, #4]
  21bf78:	681b      	ldr	r3, [r3, #0]
  21bf7a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21bf7c:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  21bf80:	2b00      	cmp	r3, #0
  21bf82:	d008      	beq.n	21bf96 <HAL_SD_IRQHandler+0x2e>
  21bf84:	68fb      	ldr	r3, [r7, #12]
  21bf86:	f003 0308 	and.w	r3, r3, #8
  21bf8a:	2b00      	cmp	r3, #0
  21bf8c:	d003      	beq.n	21bf96 <HAL_SD_IRQHandler+0x2e>
  {
    SD_Read_IT(hsd);
  21bf8e:	6878      	ldr	r0, [r7, #4]
  21bf90:	f000 ffef 	bl	21cf72 <SD_Read_IT>
  21bf94:	e153      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
  }

  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) != RESET)
  21bf96:	687b      	ldr	r3, [r7, #4]
  21bf98:	681b      	ldr	r3, [r3, #0]
  21bf9a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21bf9c:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21bfa0:	2b00      	cmp	r3, #0
  21bfa2:	f000 808d 	beq.w	21c0c0 <HAL_SD_IRQHandler+0x158>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DATAEND);
  21bfa6:	687b      	ldr	r3, [r7, #4]
  21bfa8:	681b      	ldr	r3, [r3, #0]
  21bfaa:	f44f 7280 	mov.w	r2, #256	; 0x100
  21bfae:	639a      	str	r2, [r3, #56]	; 0x38

    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND  | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
  21bfb0:	687b      	ldr	r3, [r7, #4]
  21bfb2:	681a      	ldr	r2, [r3, #0]
  21bfb4:	687b      	ldr	r3, [r7, #4]
  21bfb6:	681b      	ldr	r3, [r3, #0]
  21bfb8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  21bfba:	4ba3      	ldr	r3, [pc, #652]	; (21c248 <HAL_SD_IRQHandler+0x2e0>)
  21bfbc:	400b      	ands	r3, r1
  21bfbe:	63d3      	str	r3, [r2, #60]	; 0x3c
                             SDMMC_IT_TXUNDERR | SDMMC_IT_RXOVERR  | SDMMC_IT_TXFIFOHE |\
                             SDMMC_IT_RXFIFOHF);

    hsd->Instance->DCTRL &= ~(SDMMC_DCTRL_DTEN);
  21bfc0:	687b      	ldr	r3, [r7, #4]
  21bfc2:	681b      	ldr	r3, [r3, #0]
  21bfc4:	687a      	ldr	r2, [r7, #4]
  21bfc6:	6812      	ldr	r2, [r2, #0]
  21bfc8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21bfca:	f022 0201 	bic.w	r2, r2, #1
  21bfce:	62da      	str	r2, [r3, #44]	; 0x2c
    
    if((context & SD_CONTEXT_IT) != 0U)
  21bfd0:	68fb      	ldr	r3, [r7, #12]
  21bfd2:	f003 0308 	and.w	r3, r3, #8
  21bfd6:	2b00      	cmp	r3, #0
  21bfd8:	d039      	beq.n	21c04e <HAL_SD_IRQHandler+0xe6>
    {
      if(((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
  21bfda:	68fb      	ldr	r3, [r7, #12]
  21bfdc:	f003 0302 	and.w	r3, r3, #2
  21bfe0:	2b00      	cmp	r3, #0
  21bfe2:	d104      	bne.n	21bfee <HAL_SD_IRQHandler+0x86>
  21bfe4:	68fb      	ldr	r3, [r7, #12]
  21bfe6:	f003 0320 	and.w	r3, r3, #32
  21bfea:	2b00      	cmp	r3, #0
  21bfec:	d011      	beq.n	21c012 <HAL_SD_IRQHandler+0xaa>
      {
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
  21bfee:	687b      	ldr	r3, [r7, #4]
  21bff0:	681b      	ldr	r3, [r3, #0]
  21bff2:	4618      	mov	r0, r3
  21bff4:	f003 f9a6 	bl	21f344 <SDMMC_CmdStopTransfer>
  21bff8:	60b8      	str	r0, [r7, #8]
        if(errorstate != HAL_SD_ERROR_NONE)
  21bffa:	68bb      	ldr	r3, [r7, #8]
  21bffc:	2b00      	cmp	r3, #0
  21bffe:	d008      	beq.n	21c012 <HAL_SD_IRQHandler+0xaa>
        {
          hsd->ErrorCode |= errorstate;
  21c000:	687b      	ldr	r3, [r7, #4]
  21c002:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c004:	68bb      	ldr	r3, [r7, #8]
  21c006:	431a      	orrs	r2, r3
  21c008:	687b      	ldr	r3, [r7, #4]
  21c00a:	639a      	str	r2, [r3, #56]	; 0x38
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
          hsd->ErrorCallback(hsd);
#else
          HAL_SD_ErrorCallback(hsd);
  21c00c:	6878      	ldr	r0, [r7, #4]
  21c00e:	f000 f921 	bl	21c254 <HAL_SD_ErrorCallback>
#endif /* USE_HAL_SD_REGISTER_CALLBACKS */
        }
      }

      /* Clear all the static flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
  21c012:	687b      	ldr	r3, [r7, #4]
  21c014:	681b      	ldr	r3, [r3, #0]
  21c016:	f240 523a 	movw	r2, #1338	; 0x53a
  21c01a:	639a      	str	r2, [r3, #56]	; 0x38

      hsd->State = HAL_SD_STATE_READY;
  21c01c:	687b      	ldr	r3, [r7, #4]
  21c01e:	2201      	movs	r2, #1
  21c020:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
  21c024:	687b      	ldr	r3, [r7, #4]
  21c026:	2200      	movs	r2, #0
  21c028:	631a      	str	r2, [r3, #48]	; 0x30
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
  21c02a:	68fb      	ldr	r3, [r7, #12]
  21c02c:	f003 0301 	and.w	r3, r3, #1
  21c030:	2b00      	cmp	r3, #0
  21c032:	d104      	bne.n	21c03e <HAL_SD_IRQHandler+0xd6>
  21c034:	68fb      	ldr	r3, [r7, #12]
  21c036:	f003 0302 	and.w	r3, r3, #2
  21c03a:	2b00      	cmp	r3, #0
  21c03c:	d003      	beq.n	21c046 <HAL_SD_IRQHandler+0xde>
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->RxCpltCallback(hsd);
#else
        HAL_SD_RxCpltCallback(hsd);
  21c03e:	6878      	ldr	r0, [r7, #4]
  21c040:	f003 fe18 	bl	21fc74 <HAL_SD_RxCpltCallback>
  21c044:	e0fb      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
      else
      {
#if defined (USE_HAL_SD_REGISTER_CALLBACKS) && (USE_HAL_SD_REGISTER_CALLBACKS == 1U)
        hsd->TxCpltCallback(hsd);
#else
        HAL_SD_TxCpltCallback(hsd);
  21c046:	6878      	ldr	r0, [r7, #4]
  21c048:	f003 fe0a 	bl	21fc60 <HAL_SD_TxCpltCallback>
  }
  else
  {
    /* Nothing to do */
  }
}
  21c04c:	e0f7      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
    else if((context & SD_CONTEXT_DMA) != 0U)
  21c04e:	68fb      	ldr	r3, [r7, #12]
  21c050:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21c054:	2b00      	cmp	r3, #0
  21c056:	f000 80f2 	beq.w	21c23e <HAL_SD_IRQHandler+0x2d6>
      if((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U)
  21c05a:	68fb      	ldr	r3, [r7, #12]
  21c05c:	f003 0320 	and.w	r3, r3, #32
  21c060:	2b00      	cmp	r3, #0
  21c062:	d011      	beq.n	21c088 <HAL_SD_IRQHandler+0x120>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
  21c064:	687b      	ldr	r3, [r7, #4]
  21c066:	681b      	ldr	r3, [r3, #0]
  21c068:	4618      	mov	r0, r3
  21c06a:	f003 f96b 	bl	21f344 <SDMMC_CmdStopTransfer>
  21c06e:	60b8      	str	r0, [r7, #8]
        if(errorstate != HAL_SD_ERROR_NONE)
  21c070:	68bb      	ldr	r3, [r7, #8]
  21c072:	2b00      	cmp	r3, #0
  21c074:	d008      	beq.n	21c088 <HAL_SD_IRQHandler+0x120>
          hsd->ErrorCode |= errorstate;
  21c076:	687b      	ldr	r3, [r7, #4]
  21c078:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c07a:	68bb      	ldr	r3, [r7, #8]
  21c07c:	431a      	orrs	r2, r3
  21c07e:	687b      	ldr	r3, [r7, #4]
  21c080:	639a      	str	r2, [r3, #56]	; 0x38
          HAL_SD_ErrorCallback(hsd);
  21c082:	6878      	ldr	r0, [r7, #4]
  21c084:	f000 f8e6 	bl	21c254 <HAL_SD_ErrorCallback>
      if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) == 0U) && ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) == 0U))
  21c088:	68fb      	ldr	r3, [r7, #12]
  21c08a:	f003 0301 	and.w	r3, r3, #1
  21c08e:	2b00      	cmp	r3, #0
  21c090:	f040 80d5 	bne.w	21c23e <HAL_SD_IRQHandler+0x2d6>
  21c094:	68fb      	ldr	r3, [r7, #12]
  21c096:	f003 0302 	and.w	r3, r3, #2
  21c09a:	2b00      	cmp	r3, #0
  21c09c:	f040 80cf 	bne.w	21c23e <HAL_SD_IRQHandler+0x2d6>
        hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
  21c0a0:	687b      	ldr	r3, [r7, #4]
  21c0a2:	681b      	ldr	r3, [r3, #0]
  21c0a4:	687a      	ldr	r2, [r7, #4]
  21c0a6:	6812      	ldr	r2, [r2, #0]
  21c0a8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21c0aa:	f022 0208 	bic.w	r2, r2, #8
  21c0ae:	62da      	str	r2, [r3, #44]	; 0x2c
        hsd->State = HAL_SD_STATE_READY;
  21c0b0:	687b      	ldr	r3, [r7, #4]
  21c0b2:	2201      	movs	r2, #1
  21c0b4:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        HAL_SD_TxCpltCallback(hsd);
  21c0b8:	6878      	ldr	r0, [r7, #4]
  21c0ba:	f003 fdd1 	bl	21fc60 <HAL_SD_TxCpltCallback>
}
  21c0be:	e0be      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
  else if((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) != RESET) && ((context & SD_CONTEXT_IT) != 0U))
  21c0c0:	687b      	ldr	r3, [r7, #4]
  21c0c2:	681b      	ldr	r3, [r3, #0]
  21c0c4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21c0c6:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  21c0ca:	2b00      	cmp	r3, #0
  21c0cc:	d008      	beq.n	21c0e0 <HAL_SD_IRQHandler+0x178>
  21c0ce:	68fb      	ldr	r3, [r7, #12]
  21c0d0:	f003 0308 	and.w	r3, r3, #8
  21c0d4:	2b00      	cmp	r3, #0
  21c0d6:	d003      	beq.n	21c0e0 <HAL_SD_IRQHandler+0x178>
    SD_Write_IT(hsd);
  21c0d8:	6878      	ldr	r0, [r7, #4]
  21c0da:	f000 ff9b 	bl	21d014 <SD_Write_IT>
  21c0de:	e0ae      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_RXOVERR | SDMMC_FLAG_TXUNDERR) != RESET)
  21c0e0:	687b      	ldr	r3, [r7, #4]
  21c0e2:	681b      	ldr	r3, [r3, #0]
  21c0e4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21c0e6:	f003 033a 	and.w	r3, r3, #58	; 0x3a
  21c0ea:	2b00      	cmp	r3, #0
  21c0ec:	f000 80a7 	beq.w	21c23e <HAL_SD_IRQHandler+0x2d6>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL) != RESET)
  21c0f0:	687b      	ldr	r3, [r7, #4]
  21c0f2:	681b      	ldr	r3, [r3, #0]
  21c0f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21c0f6:	f003 0302 	and.w	r3, r3, #2
  21c0fa:	2b00      	cmp	r3, #0
  21c0fc:	d005      	beq.n	21c10a <HAL_SD_IRQHandler+0x1a2>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
  21c0fe:	687b      	ldr	r3, [r7, #4]
  21c100:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c102:	f043 0202 	orr.w	r2, r3, #2
  21c106:	687b      	ldr	r3, [r7, #4]
  21c108:	639a      	str	r2, [r3, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT) != RESET)
  21c10a:	687b      	ldr	r3, [r7, #4]
  21c10c:	681b      	ldr	r3, [r3, #0]
  21c10e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21c110:	f003 0308 	and.w	r3, r3, #8
  21c114:	2b00      	cmp	r3, #0
  21c116:	d005      	beq.n	21c124 <HAL_SD_IRQHandler+0x1bc>
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
  21c118:	687b      	ldr	r3, [r7, #4]
  21c11a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c11c:	f043 0208 	orr.w	r2, r3, #8
  21c120:	687b      	ldr	r3, [r7, #4]
  21c122:	639a      	str	r2, [r3, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR) != RESET)
  21c124:	687b      	ldr	r3, [r7, #4]
  21c126:	681b      	ldr	r3, [r3, #0]
  21c128:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21c12a:	f003 0320 	and.w	r3, r3, #32
  21c12e:	2b00      	cmp	r3, #0
  21c130:	d005      	beq.n	21c13e <HAL_SD_IRQHandler+0x1d6>
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
  21c132:	687b      	ldr	r3, [r7, #4]
  21c134:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c136:	f043 0220 	orr.w	r2, r3, #32
  21c13a:	687b      	ldr	r3, [r7, #4]
  21c13c:	639a      	str	r2, [r3, #56]	; 0x38
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR) != RESET)
  21c13e:	687b      	ldr	r3, [r7, #4]
  21c140:	681b      	ldr	r3, [r3, #0]
  21c142:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21c144:	f003 0310 	and.w	r3, r3, #16
  21c148:	2b00      	cmp	r3, #0
  21c14a:	d005      	beq.n	21c158 <HAL_SD_IRQHandler+0x1f0>
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
  21c14c:	687b      	ldr	r3, [r7, #4]
  21c14e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c150:	f043 0210 	orr.w	r2, r3, #16
  21c154:	687b      	ldr	r3, [r7, #4]
  21c156:	639a      	str	r2, [r3, #56]	; 0x38
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
  21c158:	687b      	ldr	r3, [r7, #4]
  21c15a:	681b      	ldr	r3, [r3, #0]
  21c15c:	f240 523a 	movw	r2, #1338	; 0x53a
  21c160:	639a      	str	r2, [r3, #56]	; 0x38
    __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
  21c162:	687b      	ldr	r3, [r7, #4]
  21c164:	681b      	ldr	r3, [r3, #0]
  21c166:	687a      	ldr	r2, [r7, #4]
  21c168:	6812      	ldr	r2, [r2, #0]
  21c16a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21c16c:	f422 729d 	bic.w	r2, r2, #314	; 0x13a
  21c170:	63da      	str	r2, [r3, #60]	; 0x3c
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
  21c172:	687b      	ldr	r3, [r7, #4]
  21c174:	681b      	ldr	r3, [r3, #0]
  21c176:	4618      	mov	r0, r3
  21c178:	f003 f8e4 	bl	21f344 <SDMMC_CmdStopTransfer>
  21c17c:	4602      	mov	r2, r0
  21c17e:	687b      	ldr	r3, [r7, #4]
  21c180:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c182:	431a      	orrs	r2, r3
  21c184:	687b      	ldr	r3, [r7, #4]
  21c186:	639a      	str	r2, [r3, #56]	; 0x38
    if((context & SD_CONTEXT_IT) != 0U)
  21c188:	68fb      	ldr	r3, [r7, #12]
  21c18a:	f003 0308 	and.w	r3, r3, #8
  21c18e:	2b00      	cmp	r3, #0
  21c190:	d00a      	beq.n	21c1a8 <HAL_SD_IRQHandler+0x240>
      hsd->State = HAL_SD_STATE_READY;
  21c192:	687b      	ldr	r3, [r7, #4]
  21c194:	2201      	movs	r2, #1
  21c196:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
  21c19a:	687b      	ldr	r3, [r7, #4]
  21c19c:	2200      	movs	r2, #0
  21c19e:	631a      	str	r2, [r3, #48]	; 0x30
      HAL_SD_ErrorCallback(hsd);
  21c1a0:	6878      	ldr	r0, [r7, #4]
  21c1a2:	f000 f857 	bl	21c254 <HAL_SD_ErrorCallback>
}
  21c1a6:	e04a      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
    else if((context & SD_CONTEXT_DMA) != 0U)
  21c1a8:	68fb      	ldr	r3, [r7, #12]
  21c1aa:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21c1ae:	2b00      	cmp	r3, #0
  21c1b0:	d045      	beq.n	21c23e <HAL_SD_IRQHandler+0x2d6>
      if(((context & SD_CONTEXT_WRITE_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_WRITE_MULTIPLE_BLOCK) != 0U))
  21c1b2:	68fb      	ldr	r3, [r7, #12]
  21c1b4:	f003 0310 	and.w	r3, r3, #16
  21c1b8:	2b00      	cmp	r3, #0
  21c1ba:	d104      	bne.n	21c1c6 <HAL_SD_IRQHandler+0x25e>
  21c1bc:	68fb      	ldr	r3, [r7, #12]
  21c1be:	f003 0320 	and.w	r3, r3, #32
  21c1c2:	2b00      	cmp	r3, #0
  21c1c4:	d011      	beq.n	21c1ea <HAL_SD_IRQHandler+0x282>
        hsd->hdmatx->XferAbortCallback = SD_DMATxAbort;
  21c1c6:	687b      	ldr	r3, [r7, #4]
  21c1c8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21c1ca:	4a20      	ldr	r2, [pc, #128]	; (21c24c <HAL_SD_IRQHandler+0x2e4>)
  21c1cc:	651a      	str	r2, [r3, #80]	; 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
  21c1ce:	687b      	ldr	r3, [r7, #4]
  21c1d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21c1d2:	4618      	mov	r0, r3
  21c1d4:	f7fd f930 	bl	219438 <HAL_DMA_Abort_IT>
  21c1d8:	4603      	mov	r3, r0
  21c1da:	2b00      	cmp	r3, #0
  21c1dc:	d02f      	beq.n	21c23e <HAL_SD_IRQHandler+0x2d6>
          SD_DMATxAbort(hsd->hdmatx);
  21c1de:	687b      	ldr	r3, [r7, #4]
  21c1e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21c1e2:	4618      	mov	r0, r3
  21c1e4:	f000 fb6a 	bl	21c8bc <SD_DMATxAbort>
        if(HAL_DMA_Abort_IT(hsd->hdmatx) != HAL_OK)
  21c1e8:	e029      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
      else if(((context & SD_CONTEXT_READ_SINGLE_BLOCK) != 0U) || ((context & SD_CONTEXT_READ_MULTIPLE_BLOCK) != 0U))
  21c1ea:	68fb      	ldr	r3, [r7, #12]
  21c1ec:	f003 0301 	and.w	r3, r3, #1
  21c1f0:	2b00      	cmp	r3, #0
  21c1f2:	d104      	bne.n	21c1fe <HAL_SD_IRQHandler+0x296>
  21c1f4:	68fb      	ldr	r3, [r7, #12]
  21c1f6:	f003 0302 	and.w	r3, r3, #2
  21c1fa:	2b00      	cmp	r3, #0
  21c1fc:	d011      	beq.n	21c222 <HAL_SD_IRQHandler+0x2ba>
        hsd->hdmarx->XferAbortCallback = SD_DMARxAbort;
  21c1fe:	687b      	ldr	r3, [r7, #4]
  21c200:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21c202:	4a13      	ldr	r2, [pc, #76]	; (21c250 <HAL_SD_IRQHandler+0x2e8>)
  21c204:	651a      	str	r2, [r3, #80]	; 0x50
        if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
  21c206:	687b      	ldr	r3, [r7, #4]
  21c208:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21c20a:	4618      	mov	r0, r3
  21c20c:	f7fd f914 	bl	219438 <HAL_DMA_Abort_IT>
  21c210:	4603      	mov	r3, r0
  21c212:	2b00      	cmp	r3, #0
  21c214:	d013      	beq.n	21c23e <HAL_SD_IRQHandler+0x2d6>
          SD_DMARxAbort(hsd->hdmarx);
  21c216:	687b      	ldr	r3, [r7, #4]
  21c218:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21c21a:	4618      	mov	r0, r3
  21c21c:	f000 fb85 	bl	21c92a <SD_DMARxAbort>
        if(HAL_DMA_Abort_IT(hsd->hdmarx) != HAL_OK)
  21c220:	e00d      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
        hsd->ErrorCode = HAL_SD_ERROR_NONE;
  21c222:	687b      	ldr	r3, [r7, #4]
  21c224:	2200      	movs	r2, #0
  21c226:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
  21c228:	687b      	ldr	r3, [r7, #4]
  21c22a:	2201      	movs	r2, #1
  21c22c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
  21c230:	687b      	ldr	r3, [r7, #4]
  21c232:	2200      	movs	r2, #0
  21c234:	631a      	str	r2, [r3, #48]	; 0x30
        HAL_SD_AbortCallback(hsd);
  21c236:	6878      	ldr	r0, [r7, #4]
  21c238:	f003 fd08 	bl	21fc4c <HAL_SD_AbortCallback>
}
  21c23c:	e7ff      	b.n	21c23e <HAL_SD_IRQHandler+0x2d6>
  21c23e:	bf00      	nop
  21c240:	3710      	adds	r7, #16
  21c242:	46bd      	mov	sp, r7
  21c244:	bd80      	pop	{r7, pc}
  21c246:	bf00      	nop
  21c248:	ffff3ec5 	.word	0xffff3ec5
  21c24c:	0021c8bd 	.word	0x0021c8bd
  21c250:	0021c92b 	.word	0x0021c92b

0021c254 <HAL_SD_ErrorCallback>:
  * @brief SD error callbacks
  * @param hsd: Pointer SD handle
  * @retval None
  */
__weak void HAL_SD_ErrorCallback(SD_HandleTypeDef *hsd)
{
  21c254:	b480      	push	{r7}
  21c256:	b083      	sub	sp, #12
  21c258:	af00      	add	r7, sp, #0
  21c25a:	6078      	str	r0, [r7, #4]
  UNUSED(hsd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_SD_ErrorCallback can be implemented in the user file
   */
}
  21c25c:	bf00      	nop
  21c25e:	370c      	adds	r7, #12
  21c260:	46bd      	mov	sp, r7
  21c262:	f85d 7b04 	ldr.w	r7, [sp], #4
  21c266:	4770      	bx	lr

0021c268 <HAL_SD_GetCardCSD>:
  * @param  pCSD: Pointer to a HAL_SD_CardCSDTypeDef structure that  
  *         contains all CSD register parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypeDef *pCSD)
{
  21c268:	b480      	push	{r7}
  21c26a:	b083      	sub	sp, #12
  21c26c:	af00      	add	r7, sp, #0
  21c26e:	6078      	str	r0, [r7, #4]
  21c270:	6039      	str	r1, [r7, #0]
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
  21c272:	687b      	ldr	r3, [r7, #4]
  21c274:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21c276:	0f9b      	lsrs	r3, r3, #30
  21c278:	b2da      	uxtb	r2, r3
  21c27a:	683b      	ldr	r3, [r7, #0]
  21c27c:	701a      	strb	r2, [r3, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
  21c27e:	687b      	ldr	r3, [r7, #4]
  21c280:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21c282:	0e9b      	lsrs	r3, r3, #26
  21c284:	b2db      	uxtb	r3, r3
  21c286:	f003 030f 	and.w	r3, r3, #15
  21c28a:	b2da      	uxtb	r2, r3
  21c28c:	683b      	ldr	r3, [r7, #0]
  21c28e:	705a      	strb	r2, [r3, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
  21c290:	687b      	ldr	r3, [r7, #4]
  21c292:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21c294:	0e1b      	lsrs	r3, r3, #24
  21c296:	b2db      	uxtb	r3, r3
  21c298:	f003 0303 	and.w	r3, r3, #3
  21c29c:	b2da      	uxtb	r2, r3
  21c29e:	683b      	ldr	r3, [r7, #0]
  21c2a0:	709a      	strb	r2, [r3, #2]

  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
  21c2a2:	687b      	ldr	r3, [r7, #4]
  21c2a4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21c2a6:	0c1b      	lsrs	r3, r3, #16
  21c2a8:	b2da      	uxtb	r2, r3
  21c2aa:	683b      	ldr	r3, [r7, #0]
  21c2ac:	70da      	strb	r2, [r3, #3]

  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
  21c2ae:	687b      	ldr	r3, [r7, #4]
  21c2b0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21c2b2:	0a1b      	lsrs	r3, r3, #8
  21c2b4:	b2da      	uxtb	r2, r3
  21c2b6:	683b      	ldr	r3, [r7, #0]
  21c2b8:	711a      	strb	r2, [r3, #4]

  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
  21c2ba:	687b      	ldr	r3, [r7, #4]
  21c2bc:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21c2be:	b2da      	uxtb	r2, r3
  21c2c0:	683b      	ldr	r3, [r7, #0]
  21c2c2:	715a      	strb	r2, [r3, #5]

  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
  21c2c4:	687b      	ldr	r3, [r7, #4]
  21c2c6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c2c8:	0d1b      	lsrs	r3, r3, #20
  21c2ca:	b29a      	uxth	r2, r3
  21c2cc:	683b      	ldr	r3, [r7, #0]
  21c2ce:	80da      	strh	r2, [r3, #6]

  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
  21c2d0:	687b      	ldr	r3, [r7, #4]
  21c2d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c2d4:	0c1b      	lsrs	r3, r3, #16
  21c2d6:	b2db      	uxtb	r3, r3
  21c2d8:	f003 030f 	and.w	r3, r3, #15
  21c2dc:	b2da      	uxtb	r2, r3
  21c2de:	683b      	ldr	r3, [r7, #0]
  21c2e0:	721a      	strb	r2, [r3, #8]

  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
  21c2e2:	687b      	ldr	r3, [r7, #4]
  21c2e4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c2e6:	0bdb      	lsrs	r3, r3, #15
  21c2e8:	b2db      	uxtb	r3, r3
  21c2ea:	f003 0301 	and.w	r3, r3, #1
  21c2ee:	b2da      	uxtb	r2, r3
  21c2f0:	683b      	ldr	r3, [r7, #0]
  21c2f2:	725a      	strb	r2, [r3, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
  21c2f4:	687b      	ldr	r3, [r7, #4]
  21c2f6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c2f8:	0b9b      	lsrs	r3, r3, #14
  21c2fa:	b2db      	uxtb	r3, r3
  21c2fc:	f003 0301 	and.w	r3, r3, #1
  21c300:	b2da      	uxtb	r2, r3
  21c302:	683b      	ldr	r3, [r7, #0]
  21c304:	729a      	strb	r2, [r3, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
  21c306:	687b      	ldr	r3, [r7, #4]
  21c308:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c30a:	0b5b      	lsrs	r3, r3, #13
  21c30c:	b2db      	uxtb	r3, r3
  21c30e:	f003 0301 	and.w	r3, r3, #1
  21c312:	b2da      	uxtb	r2, r3
  21c314:	683b      	ldr	r3, [r7, #0]
  21c316:	72da      	strb	r2, [r3, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
  21c318:	687b      	ldr	r3, [r7, #4]
  21c31a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c31c:	0b1b      	lsrs	r3, r3, #12
  21c31e:	b2db      	uxtb	r3, r3
  21c320:	f003 0301 	and.w	r3, r3, #1
  21c324:	b2da      	uxtb	r2, r3
  21c326:	683b      	ldr	r3, [r7, #0]
  21c328:	731a      	strb	r2, [r3, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
  21c32a:	683b      	ldr	r3, [r7, #0]
  21c32c:	2200      	movs	r2, #0
  21c32e:	735a      	strb	r2, [r3, #13]

  if(hsd->SdCard.CardType == CARD_SDSC)
  21c330:	687b      	ldr	r3, [r7, #4]
  21c332:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21c334:	2b00      	cmp	r3, #0
  21c336:	d162      	bne.n	21c3fe <HAL_SD_GetCardCSD+0x196>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
  21c338:	687b      	ldr	r3, [r7, #4]
  21c33a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c33c:	009a      	lsls	r2, r3, #2
  21c33e:	f640 73fc 	movw	r3, #4092	; 0xffc
  21c342:	4013      	ands	r3, r2
  21c344:	687a      	ldr	r2, [r7, #4]
  21c346:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
  21c348:	0f92      	lsrs	r2, r2, #30
  21c34a:	431a      	orrs	r2, r3
  21c34c:	683b      	ldr	r3, [r7, #0]
  21c34e:	611a      	str	r2, [r3, #16]

    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
  21c350:	687b      	ldr	r3, [r7, #4]
  21c352:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c354:	0edb      	lsrs	r3, r3, #27
  21c356:	b2db      	uxtb	r3, r3
  21c358:	f003 0307 	and.w	r3, r3, #7
  21c35c:	b2da      	uxtb	r2, r3
  21c35e:	683b      	ldr	r3, [r7, #0]
  21c360:	751a      	strb	r2, [r3, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
  21c362:	687b      	ldr	r3, [r7, #4]
  21c364:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c366:	0e1b      	lsrs	r3, r3, #24
  21c368:	b2db      	uxtb	r3, r3
  21c36a:	f003 0307 	and.w	r3, r3, #7
  21c36e:	b2da      	uxtb	r2, r3
  21c370:	683b      	ldr	r3, [r7, #0]
  21c372:	755a      	strb	r2, [r3, #21]

    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
  21c374:	687b      	ldr	r3, [r7, #4]
  21c376:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c378:	0d5b      	lsrs	r3, r3, #21
  21c37a:	b2db      	uxtb	r3, r3
  21c37c:	f003 0307 	and.w	r3, r3, #7
  21c380:	b2da      	uxtb	r2, r3
  21c382:	683b      	ldr	r3, [r7, #0]
  21c384:	759a      	strb	r2, [r3, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
  21c386:	687b      	ldr	r3, [r7, #4]
  21c388:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c38a:	0c9b      	lsrs	r3, r3, #18
  21c38c:	b2db      	uxtb	r3, r3
  21c38e:	f003 0307 	and.w	r3, r3, #7
  21c392:	b2da      	uxtb	r2, r3
  21c394:	683b      	ldr	r3, [r7, #0]
  21c396:	75da      	strb	r2, [r3, #23]

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
  21c398:	687b      	ldr	r3, [r7, #4]
  21c39a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c39c:	0bdb      	lsrs	r3, r3, #15
  21c39e:	b2db      	uxtb	r3, r3
  21c3a0:	f003 0307 	and.w	r3, r3, #7
  21c3a4:	b2da      	uxtb	r2, r3
  21c3a6:	683b      	ldr	r3, [r7, #0]
  21c3a8:	761a      	strb	r2, [r3, #24]

    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
  21c3aa:	683b      	ldr	r3, [r7, #0]
  21c3ac:	691b      	ldr	r3, [r3, #16]
  21c3ae:	1c5a      	adds	r2, r3, #1
  21c3b0:	687b      	ldr	r3, [r7, #4]
  21c3b2:	655a      	str	r2, [r3, #84]	; 0x54
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
  21c3b4:	683b      	ldr	r3, [r7, #0]
  21c3b6:	7e1b      	ldrb	r3, [r3, #24]
  21c3b8:	b2db      	uxtb	r3, r3
  21c3ba:	f003 0307 	and.w	r3, r3, #7
  21c3be:	3302      	adds	r3, #2
  21c3c0:	2201      	movs	r2, #1
  21c3c2:	409a      	lsls	r2, r3
  21c3c4:	687b      	ldr	r3, [r7, #4]
  21c3c6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21c3c8:	fb02 f203 	mul.w	r2, r2, r3
  21c3cc:	687b      	ldr	r3, [r7, #4]
  21c3ce:	655a      	str	r2, [r3, #84]	; 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
  21c3d0:	683b      	ldr	r3, [r7, #0]
  21c3d2:	7a1b      	ldrb	r3, [r3, #8]
  21c3d4:	b2db      	uxtb	r3, r3
  21c3d6:	f003 030f 	and.w	r3, r3, #15
  21c3da:	2201      	movs	r2, #1
  21c3dc:	409a      	lsls	r2, r3
  21c3de:	687b      	ldr	r3, [r7, #4]
  21c3e0:	659a      	str	r2, [r3, #88]	; 0x58

    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
  21c3e2:	687b      	ldr	r3, [r7, #4]
  21c3e4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21c3e6:	687a      	ldr	r2, [r7, #4]
  21c3e8:	6d92      	ldr	r2, [r2, #88]	; 0x58
  21c3ea:	0a52      	lsrs	r2, r2, #9
  21c3ec:	fb02 f203 	mul.w	r2, r2, r3
  21c3f0:	687b      	ldr	r3, [r7, #4]
  21c3f2:	65da      	str	r2, [r3, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = 512U;
  21c3f4:	687b      	ldr	r3, [r7, #4]
  21c3f6:	f44f 7200 	mov.w	r2, #512	; 0x200
  21c3fa:	661a      	str	r2, [r3, #96]	; 0x60
  21c3fc:	e031      	b.n	21c462 <HAL_SD_GetCardCSD+0x1fa>
  }
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
  21c3fe:	687b      	ldr	r3, [r7, #4]
  21c400:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21c402:	2b01      	cmp	r3, #1
  21c404:	d11d      	bne.n	21c442 <HAL_SD_GetCardCSD+0x1da>
  {
    /* Byte 7 */
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
  21c406:	687b      	ldr	r3, [r7, #4]
  21c408:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21c40a:	041b      	lsls	r3, r3, #16
  21c40c:	f403 127c 	and.w	r2, r3, #4128768	; 0x3f0000
  21c410:	687b      	ldr	r3, [r7, #4]
  21c412:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c414:	0c1b      	lsrs	r3, r3, #16
  21c416:	431a      	orrs	r2, r3
  21c418:	683b      	ldr	r3, [r7, #0]
  21c41a:	611a      	str	r2, [r3, #16]

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
  21c41c:	683b      	ldr	r3, [r7, #0]
  21c41e:	691b      	ldr	r3, [r3, #16]
  21c420:	3301      	adds	r3, #1
  21c422:	029a      	lsls	r2, r3, #10
  21c424:	687b      	ldr	r3, [r7, #4]
  21c426:	655a      	str	r2, [r3, #84]	; 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
  21c428:	687b      	ldr	r3, [r7, #4]
  21c42a:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  21c42c:	687b      	ldr	r3, [r7, #4]
  21c42e:	65da      	str	r2, [r3, #92]	; 0x5c
    hsd->SdCard.BlockSize = 512U;
  21c430:	687b      	ldr	r3, [r7, #4]
  21c432:	f44f 7200 	mov.w	r2, #512	; 0x200
  21c436:	659a      	str	r2, [r3, #88]	; 0x58
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
  21c438:	687b      	ldr	r3, [r7, #4]
  21c43a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  21c43c:	687b      	ldr	r3, [r7, #4]
  21c43e:	661a      	str	r2, [r3, #96]	; 0x60
  21c440:	e00f      	b.n	21c462 <HAL_SD_GetCardCSD+0x1fa>
  }
  else
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21c442:	687b      	ldr	r3, [r7, #4]
  21c444:	681b      	ldr	r3, [r3, #0]
  21c446:	4a59      	ldr	r2, [pc, #356]	; (21c5ac <HAL_SD_GetCardCSD+0x344>)
  21c448:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  21c44a:	687b      	ldr	r3, [r7, #4]
  21c44c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c44e:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
  21c452:	687b      	ldr	r3, [r7, #4]
  21c454:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
  21c456:	687b      	ldr	r3, [r7, #4]
  21c458:	2201      	movs	r2, #1
  21c45a:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    return HAL_ERROR;
  21c45e:	2301      	movs	r3, #1
  21c460:	e09d      	b.n	21c59e <HAL_SD_GetCardCSD+0x336>
  }

  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
  21c462:	687b      	ldr	r3, [r7, #4]
  21c464:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c466:	0b9b      	lsrs	r3, r3, #14
  21c468:	b2db      	uxtb	r3, r3
  21c46a:	f003 0301 	and.w	r3, r3, #1
  21c46e:	b2da      	uxtb	r2, r3
  21c470:	683b      	ldr	r3, [r7, #0]
  21c472:	765a      	strb	r2, [r3, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
  21c474:	687b      	ldr	r3, [r7, #4]
  21c476:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c478:	09db      	lsrs	r3, r3, #7
  21c47a:	b2db      	uxtb	r3, r3
  21c47c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  21c480:	b2da      	uxtb	r2, r3
  21c482:	683b      	ldr	r3, [r7, #0]
  21c484:	769a      	strb	r2, [r3, #26]

  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
  21c486:	687b      	ldr	r3, [r7, #4]
  21c488:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21c48a:	b2db      	uxtb	r3, r3
  21c48c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  21c490:	b2da      	uxtb	r2, r3
  21c492:	683b      	ldr	r3, [r7, #0]
  21c494:	76da      	strb	r2, [r3, #27]

  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
  21c496:	687b      	ldr	r3, [r7, #4]
  21c498:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c49a:	0fdb      	lsrs	r3, r3, #31
  21c49c:	b2da      	uxtb	r2, r3
  21c49e:	683b      	ldr	r3, [r7, #0]
  21c4a0:	771a      	strb	r2, [r3, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
  21c4a2:	687b      	ldr	r3, [r7, #4]
  21c4a4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c4a6:	0f5b      	lsrs	r3, r3, #29
  21c4a8:	b2db      	uxtb	r3, r3
  21c4aa:	f003 0303 	and.w	r3, r3, #3
  21c4ae:	b2da      	uxtb	r2, r3
  21c4b0:	683b      	ldr	r3, [r7, #0]
  21c4b2:	775a      	strb	r2, [r3, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
  21c4b4:	687b      	ldr	r3, [r7, #4]
  21c4b6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c4b8:	0e9b      	lsrs	r3, r3, #26
  21c4ba:	b2db      	uxtb	r3, r3
  21c4bc:	f003 0307 	and.w	r3, r3, #7
  21c4c0:	b2da      	uxtb	r2, r3
  21c4c2:	683b      	ldr	r3, [r7, #0]
  21c4c4:	779a      	strb	r2, [r3, #30]

  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
  21c4c6:	687b      	ldr	r3, [r7, #4]
  21c4c8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c4ca:	0d9b      	lsrs	r3, r3, #22
  21c4cc:	b2db      	uxtb	r3, r3
  21c4ce:	f003 030f 	and.w	r3, r3, #15
  21c4d2:	b2da      	uxtb	r2, r3
  21c4d4:	683b      	ldr	r3, [r7, #0]
  21c4d6:	77da      	strb	r2, [r3, #31]

  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
  21c4d8:	687b      	ldr	r3, [r7, #4]
  21c4da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c4dc:	0d5b      	lsrs	r3, r3, #21
  21c4de:	b2db      	uxtb	r3, r3
  21c4e0:	f003 0301 	and.w	r3, r3, #1
  21c4e4:	b2da      	uxtb	r2, r3
  21c4e6:	683b      	ldr	r3, [r7, #0]
  21c4e8:	f883 2020 	strb.w	r2, [r3, #32]

  pCSD->Reserved3 = 0;
  21c4ec:	683b      	ldr	r3, [r7, #0]
  21c4ee:	2200      	movs	r2, #0
  21c4f0:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
  21c4f4:	687b      	ldr	r3, [r7, #4]
  21c4f6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c4f8:	0c1b      	lsrs	r3, r3, #16
  21c4fa:	b2db      	uxtb	r3, r3
  21c4fc:	f003 0301 	and.w	r3, r3, #1
  21c500:	b2da      	uxtb	r2, r3
  21c502:	683b      	ldr	r3, [r7, #0]
  21c504:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22

  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
  21c508:	687b      	ldr	r3, [r7, #4]
  21c50a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c50c:	0bdb      	lsrs	r3, r3, #15
  21c50e:	b2db      	uxtb	r3, r3
  21c510:	f003 0301 	and.w	r3, r3, #1
  21c514:	b2da      	uxtb	r2, r3
  21c516:	683b      	ldr	r3, [r7, #0]
  21c518:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
  21c51c:	687b      	ldr	r3, [r7, #4]
  21c51e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c520:	0b9b      	lsrs	r3, r3, #14
  21c522:	b2db      	uxtb	r3, r3
  21c524:	f003 0301 	and.w	r3, r3, #1
  21c528:	b2da      	uxtb	r2, r3
  21c52a:	683b      	ldr	r3, [r7, #0]
  21c52c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
  21c530:	687b      	ldr	r3, [r7, #4]
  21c532:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c534:	0b5b      	lsrs	r3, r3, #13
  21c536:	b2db      	uxtb	r3, r3
  21c538:	f003 0301 	and.w	r3, r3, #1
  21c53c:	b2da      	uxtb	r2, r3
  21c53e:	683b      	ldr	r3, [r7, #0]
  21c540:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
  21c544:	687b      	ldr	r3, [r7, #4]
  21c546:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c548:	0b1b      	lsrs	r3, r3, #12
  21c54a:	b2db      	uxtb	r3, r3
  21c54c:	f003 0301 	and.w	r3, r3, #1
  21c550:	b2da      	uxtb	r2, r3
  21c552:	683b      	ldr	r3, [r7, #0]
  21c554:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
  21c558:	687b      	ldr	r3, [r7, #4]
  21c55a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c55c:	0a9b      	lsrs	r3, r3, #10
  21c55e:	b2db      	uxtb	r3, r3
  21c560:	f003 0303 	and.w	r3, r3, #3
  21c564:	b2da      	uxtb	r2, r3
  21c566:	683b      	ldr	r3, [r7, #0]
  21c568:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27

  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
  21c56c:	687b      	ldr	r3, [r7, #4]
  21c56e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c570:	0a1b      	lsrs	r3, r3, #8
  21c572:	b2db      	uxtb	r3, r3
  21c574:	f003 0303 	and.w	r3, r3, #3
  21c578:	b2da      	uxtb	r2, r3
  21c57a:	683b      	ldr	r3, [r7, #0]
  21c57c:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28

  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
  21c580:	687b      	ldr	r3, [r7, #4]
  21c582:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21c584:	085b      	lsrs	r3, r3, #1
  21c586:	b2db      	uxtb	r3, r3
  21c588:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  21c58c:	b2da      	uxtb	r2, r3
  21c58e:	683b      	ldr	r3, [r7, #0]
  21c590:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29

  pCSD->Reserved4 = 1;
  21c594:	683b      	ldr	r3, [r7, #0]
  21c596:	2201      	movs	r2, #1
  21c598:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a

  return HAL_OK;
  21c59c:	2300      	movs	r3, #0
}
  21c59e:	4618      	mov	r0, r3
  21c5a0:	370c      	adds	r7, #12
  21c5a2:	46bd      	mov	sp, r7
  21c5a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  21c5a8:	4770      	bx	lr
  21c5aa:	bf00      	nop
  21c5ac:	004005ff 	.word	0x004005ff

0021c5b0 <HAL_SD_GetCardInfo>:
  * @param  pCardInfo: Pointer to the HAL_SD_CardInfoTypeDef structure that
  *         will contain the SD card status information
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardInfo(SD_HandleTypeDef *hsd, HAL_SD_CardInfoTypeDef *pCardInfo)
{
  21c5b0:	b480      	push	{r7}
  21c5b2:	b083      	sub	sp, #12
  21c5b4:	af00      	add	r7, sp, #0
  21c5b6:	6078      	str	r0, [r7, #4]
  21c5b8:	6039      	str	r1, [r7, #0]
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
  21c5ba:	687b      	ldr	r3, [r7, #4]
  21c5bc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  21c5be:	683b      	ldr	r3, [r7, #0]
  21c5c0:	601a      	str	r2, [r3, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
  21c5c2:	687b      	ldr	r3, [r7, #4]
  21c5c4:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  21c5c6:	683b      	ldr	r3, [r7, #0]
  21c5c8:	605a      	str	r2, [r3, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
  21c5ca:	687b      	ldr	r3, [r7, #4]
  21c5cc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  21c5ce:	683b      	ldr	r3, [r7, #0]
  21c5d0:	609a      	str	r2, [r3, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
  21c5d2:	687b      	ldr	r3, [r7, #4]
  21c5d4:	6d1a      	ldr	r2, [r3, #80]	; 0x50
  21c5d6:	683b      	ldr	r3, [r7, #0]
  21c5d8:	60da      	str	r2, [r3, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
  21c5da:	687b      	ldr	r3, [r7, #4]
  21c5dc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  21c5de:	683b      	ldr	r3, [r7, #0]
  21c5e0:	611a      	str	r2, [r3, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
  21c5e2:	687b      	ldr	r3, [r7, #4]
  21c5e4:	6d9a      	ldr	r2, [r3, #88]	; 0x58
  21c5e6:	683b      	ldr	r3, [r7, #0]
  21c5e8:	615a      	str	r2, [r3, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
  21c5ea:	687b      	ldr	r3, [r7, #4]
  21c5ec:	6dda      	ldr	r2, [r3, #92]	; 0x5c
  21c5ee:	683b      	ldr	r3, [r7, #0]
  21c5f0:	619a      	str	r2, [r3, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
  21c5f2:	687b      	ldr	r3, [r7, #4]
  21c5f4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  21c5f6:	683b      	ldr	r3, [r7, #0]
  21c5f8:	61da      	str	r2, [r3, #28]

  return HAL_OK;
  21c5fa:	2300      	movs	r3, #0
}
  21c5fc:	4618      	mov	r0, r3
  21c5fe:	370c      	adds	r7, #12
  21c600:	46bd      	mov	sp, r7
  21c602:	f85d 7b04 	ldr.w	r7, [sp], #4
  21c606:	4770      	bx	lr

0021c608 <HAL_SD_ConfigWideBusOperation>:
  *            @arg SDMMC_BUS_WIDE_4B: 4-bit data transfer
  *            @arg SDMMC_BUS_WIDE_1B: 1-bit data transfer
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ConfigWideBusOperation(SD_HandleTypeDef *hsd, uint32_t WideMode)
{
  21c608:	b5b0      	push	{r4, r5, r7, lr}
  21c60a:	b08e      	sub	sp, #56	; 0x38
  21c60c:	af04      	add	r7, sp, #16
  21c60e:	6078      	str	r0, [r7, #4]
  21c610:	6039      	str	r1, [r7, #0]
  SDMMC_InitTypeDef Init;
  uint32_t errorstate;
  HAL_StatusTypeDef status = HAL_OK;
  21c612:	2300      	movs	r3, #0
  21c614:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

  /* Check the parameters */
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));

  /* Change State */
  hsd->State = HAL_SD_STATE_BUSY;
  21c618:	687b      	ldr	r3, [r7, #4]
  21c61a:	2203      	movs	r2, #3
  21c61c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(hsd->SdCard.CardType != CARD_SECURED)
  21c620:	687b      	ldr	r3, [r7, #4]
  21c622:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21c624:	2b03      	cmp	r3, #3
  21c626:	d02e      	beq.n	21c686 <HAL_SD_ConfigWideBusOperation+0x7e>
  {
    if(WideMode == SDMMC_BUS_WIDE_8B)
  21c628:	683b      	ldr	r3, [r7, #0]
  21c62a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  21c62e:	d106      	bne.n	21c63e <HAL_SD_ConfigWideBusOperation+0x36>
    {
      hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  21c630:	687b      	ldr	r3, [r7, #4]
  21c632:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c634:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
  21c638:	687b      	ldr	r3, [r7, #4]
  21c63a:	639a      	str	r2, [r3, #56]	; 0x38
  21c63c:	e029      	b.n	21c692 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if(WideMode == SDMMC_BUS_WIDE_4B)
  21c63e:	683b      	ldr	r3, [r7, #0]
  21c640:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
  21c644:	d10a      	bne.n	21c65c <HAL_SD_ConfigWideBusOperation+0x54>
    {
      errorstate = SD_WideBus_Enable(hsd);
  21c646:	6878      	ldr	r0, [r7, #4]
  21c648:	f000 fb2a 	bl	21cca0 <SD_WideBus_Enable>
  21c64c:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
  21c64e:	687b      	ldr	r3, [r7, #4]
  21c650:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c652:	6a3b      	ldr	r3, [r7, #32]
  21c654:	431a      	orrs	r2, r3
  21c656:	687b      	ldr	r3, [r7, #4]
  21c658:	639a      	str	r2, [r3, #56]	; 0x38
  21c65a:	e01a      	b.n	21c692 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else if(WideMode == SDMMC_BUS_WIDE_1B)
  21c65c:	683b      	ldr	r3, [r7, #0]
  21c65e:	2b00      	cmp	r3, #0
  21c660:	d10a      	bne.n	21c678 <HAL_SD_ConfigWideBusOperation+0x70>
    {
      errorstate = SD_WideBus_Disable(hsd);
  21c662:	6878      	ldr	r0, [r7, #4]
  21c664:	f000 fb67 	bl	21cd36 <SD_WideBus_Disable>
  21c668:	6238      	str	r0, [r7, #32]

      hsd->ErrorCode |= errorstate;
  21c66a:	687b      	ldr	r3, [r7, #4]
  21c66c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c66e:	6a3b      	ldr	r3, [r7, #32]
  21c670:	431a      	orrs	r2, r3
  21c672:	687b      	ldr	r3, [r7, #4]
  21c674:	639a      	str	r2, [r3, #56]	; 0x38
  21c676:	e00c      	b.n	21c692 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
    else
    {
      /* WideMode is not a valid argument*/
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
  21c678:	687b      	ldr	r3, [r7, #4]
  21c67a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c67c:	f043 6200 	orr.w	r2, r3, #134217728	; 0x8000000
  21c680:	687b      	ldr	r3, [r7, #4]
  21c682:	639a      	str	r2, [r3, #56]	; 0x38
  21c684:	e005      	b.n	21c692 <HAL_SD_ConfigWideBusOperation+0x8a>
    }
  }
  else
  {
    /* MMC Card does not support this feature */
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  21c686:	687b      	ldr	r3, [r7, #4]
  21c688:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c68a:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
  21c68e:	687b      	ldr	r3, [r7, #4]
  21c690:	639a      	str	r2, [r3, #56]	; 0x38
  }

  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
  21c692:	687b      	ldr	r3, [r7, #4]
  21c694:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c696:	2b00      	cmp	r3, #0
  21c698:	d00b      	beq.n	21c6b2 <HAL_SD_ConfigWideBusOperation+0xaa>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21c69a:	687b      	ldr	r3, [r7, #4]
  21c69c:	681b      	ldr	r3, [r3, #0]
  21c69e:	4a26      	ldr	r2, [pc, #152]	; (21c738 <HAL_SD_ConfigWideBusOperation+0x130>)
  21c6a0:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
  21c6a2:	687b      	ldr	r3, [r7, #4]
  21c6a4:	2201      	movs	r2, #1
  21c6a6:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    status = HAL_ERROR;
  21c6aa:	2301      	movs	r3, #1
  21c6ac:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  21c6b0:	e01f      	b.n	21c6f2 <HAL_SD_ConfigWideBusOperation+0xea>
  }
  else
  {
    /* Configure the SDMMC peripheral */
    Init.ClockEdge           = hsd->Init.ClockEdge;
  21c6b2:	687b      	ldr	r3, [r7, #4]
  21c6b4:	685b      	ldr	r3, [r3, #4]
  21c6b6:	60bb      	str	r3, [r7, #8]
    Init.ClockBypass         = hsd->Init.ClockBypass;
  21c6b8:	687b      	ldr	r3, [r7, #4]
  21c6ba:	689b      	ldr	r3, [r3, #8]
  21c6bc:	60fb      	str	r3, [r7, #12]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
  21c6be:	687b      	ldr	r3, [r7, #4]
  21c6c0:	68db      	ldr	r3, [r3, #12]
  21c6c2:	613b      	str	r3, [r7, #16]
    Init.BusWide             = WideMode;
  21c6c4:	683b      	ldr	r3, [r7, #0]
  21c6c6:	617b      	str	r3, [r7, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
  21c6c8:	687b      	ldr	r3, [r7, #4]
  21c6ca:	695b      	ldr	r3, [r3, #20]
  21c6cc:	61bb      	str	r3, [r7, #24]
    Init.ClockDiv            = hsd->Init.ClockDiv;
  21c6ce:	687b      	ldr	r3, [r7, #4]
  21c6d0:	699b      	ldr	r3, [r3, #24]
  21c6d2:	61fb      	str	r3, [r7, #28]
    (void)SDMMC_Init(hsd->Instance, Init);
  21c6d4:	687b      	ldr	r3, [r7, #4]
  21c6d6:	681d      	ldr	r5, [r3, #0]
  21c6d8:	466c      	mov	r4, sp
  21c6da:	f107 0314 	add.w	r3, r7, #20
  21c6de:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  21c6e2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  21c6e6:	f107 0308 	add.w	r3, r7, #8
  21c6ea:	cb0e      	ldmia	r3, {r1, r2, r3}
  21c6ec:	4628      	mov	r0, r5
  21c6ee:	f002 fca1 	bl	21f034 <SDMMC_Init>
  }

  /* Set Block Size for Card */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
  21c6f2:	687b      	ldr	r3, [r7, #4]
  21c6f4:	681b      	ldr	r3, [r3, #0]
  21c6f6:	f44f 7100 	mov.w	r1, #512	; 0x200
  21c6fa:	4618      	mov	r0, r3
  21c6fc:	f002 fd78 	bl	21f1f0 <SDMMC_CmdBlockLength>
  21c700:	6238      	str	r0, [r7, #32]
  if(errorstate != HAL_SD_ERROR_NONE)
  21c702:	6a3b      	ldr	r3, [r7, #32]
  21c704:	2b00      	cmp	r3, #0
  21c706:	d00c      	beq.n	21c722 <HAL_SD_ConfigWideBusOperation+0x11a>
  {
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21c708:	687b      	ldr	r3, [r7, #4]
  21c70a:	681b      	ldr	r3, [r3, #0]
  21c70c:	4a0a      	ldr	r2, [pc, #40]	; (21c738 <HAL_SD_ConfigWideBusOperation+0x130>)
  21c70e:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
  21c710:	687b      	ldr	r3, [r7, #4]
  21c712:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c714:	6a3b      	ldr	r3, [r7, #32]
  21c716:	431a      	orrs	r2, r3
  21c718:	687b      	ldr	r3, [r7, #4]
  21c71a:	639a      	str	r2, [r3, #56]	; 0x38
    status = HAL_ERROR;
  21c71c:	2301      	movs	r3, #1
  21c71e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  }

  /* Change State */
  hsd->State = HAL_SD_STATE_READY;
  21c722:	687b      	ldr	r3, [r7, #4]
  21c724:	2201      	movs	r2, #1
  21c726:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return status;
  21c72a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
  21c72e:	4618      	mov	r0, r3
  21c730:	3728      	adds	r7, #40	; 0x28
  21c732:	46bd      	mov	sp, r7
  21c734:	bdb0      	pop	{r4, r5, r7, pc}
  21c736:	bf00      	nop
  21c738:	004005ff 	.word	0x004005ff

0021c73c <HAL_SD_GetCardState>:
  * @brief  Gets the current sd card data state.
  * @param  hsd: pointer to SD handle
  * @retval Card state
  */
HAL_SD_CardStateTypeDef HAL_SD_GetCardState(SD_HandleTypeDef *hsd)
{
  21c73c:	b580      	push	{r7, lr}
  21c73e:	b086      	sub	sp, #24
  21c740:	af00      	add	r7, sp, #0
  21c742:	6078      	str	r0, [r7, #4]
  uint32_t cardstate;
  uint32_t errorstate;
  uint32_t resp1 = 0;
  21c744:	2300      	movs	r3, #0
  21c746:	60fb      	str	r3, [r7, #12]

  errorstate = SD_SendStatus(hsd, &resp1);
  21c748:	f107 030c 	add.w	r3, r7, #12
  21c74c:	4619      	mov	r1, r3
  21c74e:	6878      	ldr	r0, [r7, #4]
  21c750:	f000 fa7e 	bl	21cc50 <SD_SendStatus>
  21c754:	6178      	str	r0, [r7, #20]
  if(errorstate != HAL_SD_ERROR_NONE)
  21c756:	697b      	ldr	r3, [r7, #20]
  21c758:	2b00      	cmp	r3, #0
  21c75a:	d005      	beq.n	21c768 <HAL_SD_GetCardState+0x2c>
  {
    hsd->ErrorCode |= errorstate;
  21c75c:	687b      	ldr	r3, [r7, #4]
  21c75e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c760:	697b      	ldr	r3, [r7, #20]
  21c762:	431a      	orrs	r2, r3
  21c764:	687b      	ldr	r3, [r7, #4]
  21c766:	639a      	str	r2, [r3, #56]	; 0x38
  }

  cardstate = ((resp1 >> 9U) & 0x0FU);
  21c768:	68fb      	ldr	r3, [r7, #12]
  21c76a:	0a5b      	lsrs	r3, r3, #9
  21c76c:	f003 030f 	and.w	r3, r3, #15
  21c770:	613b      	str	r3, [r7, #16]

  return (HAL_SD_CardStateTypeDef)cardstate;
  21c772:	693b      	ldr	r3, [r7, #16]
}
  21c774:	4618      	mov	r0, r3
  21c776:	3718      	adds	r7, #24
  21c778:	46bd      	mov	sp, r7
  21c77a:	bd80      	pop	{r7, pc}

0021c77c <SD_DMATransmitCplt>:
  * @brief  DMA SD transmit process complete callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMATransmitCplt(DMA_HandleTypeDef *hdma)
{
  21c77c:	b480      	push	{r7}
  21c77e:	b085      	sub	sp, #20
  21c780:	af00      	add	r7, sp, #0
  21c782:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
  21c784:	687b      	ldr	r3, [r7, #4]
  21c786:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c788:	60fb      	str	r3, [r7, #12]

  /* Enable DATAEND Interrupt */
  __HAL_SD_ENABLE_IT(hsd, (SDMMC_IT_DATAEND));
  21c78a:	68fb      	ldr	r3, [r7, #12]
  21c78c:	681b      	ldr	r3, [r3, #0]
  21c78e:	68fa      	ldr	r2, [r7, #12]
  21c790:	6812      	ldr	r2, [r2, #0]
  21c792:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21c794:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  21c798:	63da      	str	r2, [r3, #60]	; 0x3c
}
  21c79a:	bf00      	nop
  21c79c:	3714      	adds	r7, #20
  21c79e:	46bd      	mov	sp, r7
  21c7a0:	f85d 7b04 	ldr.w	r7, [sp], #4
  21c7a4:	4770      	bx	lr

0021c7a6 <SD_DMAReceiveCplt>:
  * @brief  DMA SD receive process complete callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  21c7a6:	b580      	push	{r7, lr}
  21c7a8:	b084      	sub	sp, #16
  21c7aa:	af00      	add	r7, sp, #0
  21c7ac:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
  21c7ae:	687b      	ldr	r3, [r7, #4]
  21c7b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c7b2:	60fb      	str	r3, [r7, #12]
  uint32_t errorstate;

  /* Send stop command in multiblock write */
  if(hsd->Context == (SD_CONTEXT_READ_MULTIPLE_BLOCK | SD_CONTEXT_DMA))
  21c7b4:	68fb      	ldr	r3, [r7, #12]
  21c7b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  21c7b8:	2b82      	cmp	r3, #130	; 0x82
  21c7ba:	d111      	bne.n	21c7e0 <SD_DMAReceiveCplt+0x3a>
  {
    errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
  21c7bc:	68fb      	ldr	r3, [r7, #12]
  21c7be:	681b      	ldr	r3, [r3, #0]
  21c7c0:	4618      	mov	r0, r3
  21c7c2:	f002 fdbf 	bl	21f344 <SDMMC_CmdStopTransfer>
  21c7c6:	60b8      	str	r0, [r7, #8]
    if(errorstate != HAL_SD_ERROR_NONE)
  21c7c8:	68bb      	ldr	r3, [r7, #8]
  21c7ca:	2b00      	cmp	r3, #0
  21c7cc:	d008      	beq.n	21c7e0 <SD_DMAReceiveCplt+0x3a>
    {
      hsd->ErrorCode |= errorstate;
  21c7ce:	68fb      	ldr	r3, [r7, #12]
  21c7d0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  21c7d2:	68bb      	ldr	r3, [r7, #8]
  21c7d4:	431a      	orrs	r2, r3
  21c7d6:	68fb      	ldr	r3, [r7, #12]
  21c7d8:	639a      	str	r2, [r3, #56]	; 0x38
#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
      hsd->ErrorCallback(hsd);
#else
      HAL_SD_ErrorCallback(hsd);
  21c7da:	68f8      	ldr	r0, [r7, #12]
  21c7dc:	f7ff fd3a 	bl	21c254 <HAL_SD_ErrorCallback>
    }
  }

  /* Disable the DMA transfer for transmit request by setting the DMAEN bit
  in the SD DCTRL register */
  hsd->Instance->DCTRL &= (uint32_t)~((uint32_t)SDMMC_DCTRL_DMAEN);
  21c7e0:	68fb      	ldr	r3, [r7, #12]
  21c7e2:	681b      	ldr	r3, [r3, #0]
  21c7e4:	68fa      	ldr	r2, [r7, #12]
  21c7e6:	6812      	ldr	r2, [r2, #0]
  21c7e8:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21c7ea:	f022 0208 	bic.w	r2, r2, #8
  21c7ee:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Clear all the static flags */
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
  21c7f0:	68fb      	ldr	r3, [r7, #12]
  21c7f2:	681b      	ldr	r3, [r3, #0]
  21c7f4:	f240 523a 	movw	r2, #1338	; 0x53a
  21c7f8:	639a      	str	r2, [r3, #56]	; 0x38

  hsd->State = HAL_SD_STATE_READY;
  21c7fa:	68fb      	ldr	r3, [r7, #12]
  21c7fc:	2201      	movs	r2, #1
  21c7fe:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hsd->Context = SD_CONTEXT_NONE;
  21c802:	68fb      	ldr	r3, [r7, #12]
  21c804:	2200      	movs	r2, #0
  21c806:	631a      	str	r2, [r3, #48]	; 0x30

#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
  hsd->RxCpltCallback(hsd);
#else
  HAL_SD_RxCpltCallback(hsd);
  21c808:	68f8      	ldr	r0, [r7, #12]
  21c80a:	f003 fa33 	bl	21fc74 <HAL_SD_RxCpltCallback>
#endif
}
  21c80e:	bf00      	nop
  21c810:	3710      	adds	r7, #16
  21c812:	46bd      	mov	sp, r7
  21c814:	bd80      	pop	{r7, pc}
	...

0021c818 <SD_DMAError>:
  * @brief  DMA SD communication error callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMAError(DMA_HandleTypeDef *hdma)
{
  21c818:	b580      	push	{r7, lr}
  21c81a:	b086      	sub	sp, #24
  21c81c:	af00      	add	r7, sp, #0
  21c81e:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
  21c820:	687b      	ldr	r3, [r7, #4]
  21c822:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c824:	617b      	str	r3, [r7, #20]
  HAL_SD_CardStateTypeDef CardState;
  uint32_t RxErrorCode, TxErrorCode;

  /* if DMA error is FIFO error ignore it */
  if(HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
  21c826:	6878      	ldr	r0, [r7, #4]
  21c828:	f7fc ffb2 	bl	219790 <HAL_DMA_GetError>
  21c82c:	4603      	mov	r3, r0
  21c82e:	2b02      	cmp	r3, #2
  21c830:	d03e      	beq.n	21c8b0 <SD_DMAError+0x98>
  {
    RxErrorCode = hsd->hdmarx->ErrorCode;
  21c832:	697b      	ldr	r3, [r7, #20]
  21c834:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21c836:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21c838:	613b      	str	r3, [r7, #16]
    TxErrorCode = hsd->hdmatx->ErrorCode;  
  21c83a:	697b      	ldr	r3, [r7, #20]
  21c83c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  21c83e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21c840:	60fb      	str	r3, [r7, #12]
    if((RxErrorCode == HAL_DMA_ERROR_TE) || (TxErrorCode == HAL_DMA_ERROR_TE))
  21c842:	693b      	ldr	r3, [r7, #16]
  21c844:	2b01      	cmp	r3, #1
  21c846:	d002      	beq.n	21c84e <SD_DMAError+0x36>
  21c848:	68fb      	ldr	r3, [r7, #12]
  21c84a:	2b01      	cmp	r3, #1
  21c84c:	d12d      	bne.n	21c8aa <SD_DMAError+0x92>
    {
      /* Clear All flags */
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
  21c84e:	697b      	ldr	r3, [r7, #20]
  21c850:	681b      	ldr	r3, [r3, #0]
  21c852:	4a19      	ldr	r2, [pc, #100]	; (21c8b8 <SD_DMAError+0xa0>)
  21c854:	639a      	str	r2, [r3, #56]	; 0x38

      /* Disable All interrupts */
      __HAL_SD_DISABLE_IT(hsd, SDMMC_IT_DATAEND | SDMMC_IT_DCRCFAIL | SDMMC_IT_DTIMEOUT|\
  21c856:	697b      	ldr	r3, [r7, #20]
  21c858:	681b      	ldr	r3, [r3, #0]
  21c85a:	697a      	ldr	r2, [r7, #20]
  21c85c:	6812      	ldr	r2, [r2, #0]
  21c85e:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21c860:	f422 729d 	bic.w	r2, r2, #314	; 0x13a
  21c864:	63da      	str	r2, [r3, #60]	; 0x3c
        SDMMC_IT_TXUNDERR| SDMMC_IT_RXOVERR);

      hsd->ErrorCode |= HAL_SD_ERROR_DMA;
  21c866:	697b      	ldr	r3, [r7, #20]
  21c868:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c86a:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
  21c86e:	697b      	ldr	r3, [r7, #20]
  21c870:	639a      	str	r2, [r3, #56]	; 0x38
      CardState = HAL_SD_GetCardState(hsd);
  21c872:	6978      	ldr	r0, [r7, #20]
  21c874:	f7ff ff62 	bl	21c73c <HAL_SD_GetCardState>
  21c878:	60b8      	str	r0, [r7, #8]
      if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
  21c87a:	68bb      	ldr	r3, [r7, #8]
  21c87c:	2b06      	cmp	r3, #6
  21c87e:	d002      	beq.n	21c886 <SD_DMAError+0x6e>
  21c880:	68bb      	ldr	r3, [r7, #8]
  21c882:	2b05      	cmp	r3, #5
  21c884:	d10a      	bne.n	21c89c <SD_DMAError+0x84>
      {
        hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
  21c886:	697b      	ldr	r3, [r7, #20]
  21c888:	681b      	ldr	r3, [r3, #0]
  21c88a:	4618      	mov	r0, r3
  21c88c:	f002 fd5a 	bl	21f344 <SDMMC_CmdStopTransfer>
  21c890:	4602      	mov	r2, r0
  21c892:	697b      	ldr	r3, [r7, #20]
  21c894:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c896:	431a      	orrs	r2, r3
  21c898:	697b      	ldr	r3, [r7, #20]
  21c89a:	639a      	str	r2, [r3, #56]	; 0x38
      }

      hsd->State= HAL_SD_STATE_READY;
  21c89c:	697b      	ldr	r3, [r7, #20]
  21c89e:	2201      	movs	r2, #1
  21c8a0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
  21c8a4:	697b      	ldr	r3, [r7, #20]
  21c8a6:	2200      	movs	r2, #0
  21c8a8:	631a      	str	r2, [r3, #48]	; 0x30
    }

#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
    hsd->ErrorCallback(hsd);
#else
    HAL_SD_ErrorCallback(hsd);
  21c8aa:	6978      	ldr	r0, [r7, #20]
  21c8ac:	f7ff fcd2 	bl	21c254 <HAL_SD_ErrorCallback>
#endif
  }
}
  21c8b0:	bf00      	nop
  21c8b2:	3718      	adds	r7, #24
  21c8b4:	46bd      	mov	sp, r7
  21c8b6:	bd80      	pop	{r7, pc}
  21c8b8:	004005ff 	.word	0x004005ff

0021c8bc <SD_DMATxAbort>:
  * @brief  DMA SD Tx Abort callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMATxAbort(DMA_HandleTypeDef *hdma)
{
  21c8bc:	b580      	push	{r7, lr}
  21c8be:	b084      	sub	sp, #16
  21c8c0:	af00      	add	r7, sp, #0
  21c8c2:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
  21c8c4:	687b      	ldr	r3, [r7, #4]
  21c8c6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c8c8:	60fb      	str	r3, [r7, #12]
  HAL_SD_CardStateTypeDef CardState;

  /* Clear All flags */
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
  21c8ca:	68fb      	ldr	r3, [r7, #12]
  21c8cc:	681b      	ldr	r3, [r3, #0]
  21c8ce:	f240 523a 	movw	r2, #1338	; 0x53a
  21c8d2:	639a      	str	r2, [r3, #56]	; 0x38

  CardState = HAL_SD_GetCardState(hsd);
  21c8d4:	68f8      	ldr	r0, [r7, #12]
  21c8d6:	f7ff ff31 	bl	21c73c <HAL_SD_GetCardState>
  21c8da:	60b8      	str	r0, [r7, #8]
  hsd->State = HAL_SD_STATE_READY;
  21c8dc:	68fb      	ldr	r3, [r7, #12]
  21c8de:	2201      	movs	r2, #1
  21c8e0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hsd->Context = SD_CONTEXT_NONE;
  21c8e4:	68fb      	ldr	r3, [r7, #12]
  21c8e6:	2200      	movs	r2, #0
  21c8e8:	631a      	str	r2, [r3, #48]	; 0x30
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
  21c8ea:	68bb      	ldr	r3, [r7, #8]
  21c8ec:	2b06      	cmp	r3, #6
  21c8ee:	d002      	beq.n	21c8f6 <SD_DMATxAbort+0x3a>
  21c8f0:	68bb      	ldr	r3, [r7, #8]
  21c8f2:	2b05      	cmp	r3, #5
  21c8f4:	d10a      	bne.n	21c90c <SD_DMATxAbort+0x50>
  {
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
  21c8f6:	68fb      	ldr	r3, [r7, #12]
  21c8f8:	681b      	ldr	r3, [r3, #0]
  21c8fa:	4618      	mov	r0, r3
  21c8fc:	f002 fd22 	bl	21f344 <SDMMC_CmdStopTransfer>
  21c900:	4602      	mov	r2, r0
  21c902:	68fb      	ldr	r3, [r7, #12]
  21c904:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c906:	431a      	orrs	r2, r3
  21c908:	68fb      	ldr	r3, [r7, #12]
  21c90a:	639a      	str	r2, [r3, #56]	; 0x38
  }

  if(hsd->ErrorCode == HAL_SD_ERROR_NONE)
  21c90c:	68fb      	ldr	r3, [r7, #12]
  21c90e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c910:	2b00      	cmp	r3, #0
  21c912:	d103      	bne.n	21c91c <SD_DMATxAbort+0x60>
  {
#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
    hsd->AbortCpltCallback(hsd);
#else
    HAL_SD_AbortCallback(hsd);
  21c914:	68f8      	ldr	r0, [r7, #12]
  21c916:	f003 f999 	bl	21fc4c <HAL_SD_AbortCallback>
    hsd->ErrorCallback(hsd);
#else
    HAL_SD_ErrorCallback(hsd);
#endif
  }
}
  21c91a:	e002      	b.n	21c922 <SD_DMATxAbort+0x66>
    HAL_SD_ErrorCallback(hsd);
  21c91c:	68f8      	ldr	r0, [r7, #12]
  21c91e:	f7ff fc99 	bl	21c254 <HAL_SD_ErrorCallback>
}
  21c922:	bf00      	nop
  21c924:	3710      	adds	r7, #16
  21c926:	46bd      	mov	sp, r7
  21c928:	bd80      	pop	{r7, pc}

0021c92a <SD_DMARxAbort>:
  * @brief  DMA SD Rx Abort callback
  * @param  hdma: DMA handle
  * @retval None
  */
static void SD_DMARxAbort(DMA_HandleTypeDef *hdma)
{
  21c92a:	b580      	push	{r7, lr}
  21c92c:	b084      	sub	sp, #16
  21c92e:	af00      	add	r7, sp, #0
  21c930:	6078      	str	r0, [r7, #4]
  SD_HandleTypeDef* hsd = (SD_HandleTypeDef* )(hdma->Parent);
  21c932:	687b      	ldr	r3, [r7, #4]
  21c934:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c936:	60fb      	str	r3, [r7, #12]
  HAL_SD_CardStateTypeDef CardState;

  /* Clear All flags */
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
  21c938:	68fb      	ldr	r3, [r7, #12]
  21c93a:	681b      	ldr	r3, [r3, #0]
  21c93c:	f240 523a 	movw	r2, #1338	; 0x53a
  21c940:	639a      	str	r2, [r3, #56]	; 0x38

  CardState = HAL_SD_GetCardState(hsd);
  21c942:	68f8      	ldr	r0, [r7, #12]
  21c944:	f7ff fefa 	bl	21c73c <HAL_SD_GetCardState>
  21c948:	60b8      	str	r0, [r7, #8]
  hsd->State = HAL_SD_STATE_READY;
  21c94a:	68fb      	ldr	r3, [r7, #12]
  21c94c:	2201      	movs	r2, #1
  21c94e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hsd->Context = SD_CONTEXT_NONE;
  21c952:	68fb      	ldr	r3, [r7, #12]
  21c954:	2200      	movs	r2, #0
  21c956:	631a      	str	r2, [r3, #48]	; 0x30
  if((CardState == HAL_SD_CARD_RECEIVING) || (CardState == HAL_SD_CARD_SENDING))
  21c958:	68bb      	ldr	r3, [r7, #8]
  21c95a:	2b06      	cmp	r3, #6
  21c95c:	d002      	beq.n	21c964 <SD_DMARxAbort+0x3a>
  21c95e:	68bb      	ldr	r3, [r7, #8]
  21c960:	2b05      	cmp	r3, #5
  21c962:	d10a      	bne.n	21c97a <SD_DMARxAbort+0x50>
  {
    hsd->ErrorCode |= SDMMC_CmdStopTransfer(hsd->Instance);
  21c964:	68fb      	ldr	r3, [r7, #12]
  21c966:	681b      	ldr	r3, [r3, #0]
  21c968:	4618      	mov	r0, r3
  21c96a:	f002 fceb 	bl	21f344 <SDMMC_CmdStopTransfer>
  21c96e:	4602      	mov	r2, r0
  21c970:	68fb      	ldr	r3, [r7, #12]
  21c972:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c974:	431a      	orrs	r2, r3
  21c976:	68fb      	ldr	r3, [r7, #12]
  21c978:	639a      	str	r2, [r3, #56]	; 0x38
  }

  if(hsd->ErrorCode == HAL_SD_ERROR_NONE)
  21c97a:	68fb      	ldr	r3, [r7, #12]
  21c97c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21c97e:	2b00      	cmp	r3, #0
  21c980:	d103      	bne.n	21c98a <SD_DMARxAbort+0x60>
  {
#if (USE_HAL_SD_REGISTER_CALLBACKS == 1)
    hsd->AbortCpltCallback(hsd);
#else
    HAL_SD_AbortCallback(hsd);
  21c982:	68f8      	ldr	r0, [r7, #12]
  21c984:	f003 f962 	bl	21fc4c <HAL_SD_AbortCallback>
    hsd->ErrorCallback(hsd);
#else
    HAL_SD_ErrorCallback(hsd);
#endif
  }
}
  21c988:	e002      	b.n	21c990 <SD_DMARxAbort+0x66>
    HAL_SD_ErrorCallback(hsd);
  21c98a:	68f8      	ldr	r0, [r7, #12]
  21c98c:	f7ff fc62 	bl	21c254 <HAL_SD_ErrorCallback>
}
  21c990:	bf00      	nop
  21c992:	3710      	adds	r7, #16
  21c994:	46bd      	mov	sp, r7
  21c996:	bd80      	pop	{r7, pc}

0021c998 <SD_InitCard>:
  * @brief  Initializes the sd card.
  * @param  hsd: Pointer to SD handle
  * @retval SD Card error state
  */
static uint32_t SD_InitCard(SD_HandleTypeDef *hsd)
{
  21c998:	b5b0      	push	{r4, r5, r7, lr}
  21c99a:	b094      	sub	sp, #80	; 0x50
  21c99c:	af04      	add	r7, sp, #16
  21c99e:	6078      	str	r0, [r7, #4]
  HAL_SD_CardCSDTypeDef CSD;
  uint32_t errorstate;
  uint16_t sd_rca = 1U;
  21c9a0:	2301      	movs	r3, #1
  21c9a2:	81fb      	strh	r3, [r7, #14]

  /* Check the power State */
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
  21c9a4:	687b      	ldr	r3, [r7, #4]
  21c9a6:	681b      	ldr	r3, [r3, #0]
  21c9a8:	4618      	mov	r0, r3
  21c9aa:	f002 fb9c 	bl	21f0e6 <SDMMC_GetPowerState>
  21c9ae:	4603      	mov	r3, r0
  21c9b0:	2b00      	cmp	r3, #0
  21c9b2:	d102      	bne.n	21c9ba <SD_InitCard+0x22>
  {
    /* Power off */
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  21c9b4:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  21c9b8:	e0b7      	b.n	21cb2a <SD_InitCard+0x192>
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
  21c9ba:	687b      	ldr	r3, [r7, #4]
  21c9bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21c9be:	2b03      	cmp	r3, #3
  21c9c0:	d02f      	beq.n	21ca22 <SD_InitCard+0x8a>
  {
    /* Send CMD2 ALL_SEND_CID */
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
  21c9c2:	687b      	ldr	r3, [r7, #4]
  21c9c4:	681b      	ldr	r3, [r3, #0]
  21c9c6:	4618      	mov	r0, r3
  21c9c8:	f002 fdc7 	bl	21f55a <SDMMC_CmdSendCID>
  21c9cc:	63f8      	str	r0, [r7, #60]	; 0x3c
    if(errorstate != HAL_SD_ERROR_NONE)
  21c9ce:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21c9d0:	2b00      	cmp	r3, #0
  21c9d2:	d001      	beq.n	21c9d8 <SD_InitCard+0x40>
    {
      return errorstate;
  21c9d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21c9d6:	e0a8      	b.n	21cb2a <SD_InitCard+0x192>
    }
    else
    {
      /* Get Card identification number data */
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
  21c9d8:	687b      	ldr	r3, [r7, #4]
  21c9da:	681b      	ldr	r3, [r3, #0]
  21c9dc:	2100      	movs	r1, #0
  21c9de:	4618      	mov	r0, r3
  21c9e0:	f002 fbc7 	bl	21f172 <SDMMC_GetResponse>
  21c9e4:	4602      	mov	r2, r0
  21c9e6:	687b      	ldr	r3, [r7, #4]
  21c9e8:	675a      	str	r2, [r3, #116]	; 0x74
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
  21c9ea:	687b      	ldr	r3, [r7, #4]
  21c9ec:	681b      	ldr	r3, [r3, #0]
  21c9ee:	2104      	movs	r1, #4
  21c9f0:	4618      	mov	r0, r3
  21c9f2:	f002 fbbe 	bl	21f172 <SDMMC_GetResponse>
  21c9f6:	4602      	mov	r2, r0
  21c9f8:	687b      	ldr	r3, [r7, #4]
  21c9fa:	679a      	str	r2, [r3, #120]	; 0x78
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
  21c9fc:	687b      	ldr	r3, [r7, #4]
  21c9fe:	681b      	ldr	r3, [r3, #0]
  21ca00:	2108      	movs	r1, #8
  21ca02:	4618      	mov	r0, r3
  21ca04:	f002 fbb5 	bl	21f172 <SDMMC_GetResponse>
  21ca08:	4602      	mov	r2, r0
  21ca0a:	687b      	ldr	r3, [r7, #4]
  21ca0c:	67da      	str	r2, [r3, #124]	; 0x7c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
  21ca0e:	687b      	ldr	r3, [r7, #4]
  21ca10:	681b      	ldr	r3, [r3, #0]
  21ca12:	210c      	movs	r1, #12
  21ca14:	4618      	mov	r0, r3
  21ca16:	f002 fbac 	bl	21f172 <SDMMC_GetResponse>
  21ca1a:	4602      	mov	r2, r0
  21ca1c:	687b      	ldr	r3, [r7, #4]
  21ca1e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }
  }

  if(hsd->SdCard.CardType != CARD_SECURED)
  21ca22:	687b      	ldr	r3, [r7, #4]
  21ca24:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21ca26:	2b03      	cmp	r3, #3
  21ca28:	d00d      	beq.n	21ca46 <SD_InitCard+0xae>
  {
    /* Send CMD3 SET_REL_ADDR with argument 0 */
    /* SD Card publishes its RCA. */
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
  21ca2a:	687b      	ldr	r3, [r7, #4]
  21ca2c:	681b      	ldr	r3, [r3, #0]
  21ca2e:	f107 020e 	add.w	r2, r7, #14
  21ca32:	4611      	mov	r1, r2
  21ca34:	4618      	mov	r0, r3
  21ca36:	f002 fdcd 	bl	21f5d4 <SDMMC_CmdSetRelAdd>
  21ca3a:	63f8      	str	r0, [r7, #60]	; 0x3c
    if(errorstate != HAL_SD_ERROR_NONE)
  21ca3c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21ca3e:	2b00      	cmp	r3, #0
  21ca40:	d001      	beq.n	21ca46 <SD_InitCard+0xae>
    {
      return errorstate;
  21ca42:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21ca44:	e071      	b.n	21cb2a <SD_InitCard+0x192>
    }
  }
  if(hsd->SdCard.CardType != CARD_SECURED)
  21ca46:	687b      	ldr	r3, [r7, #4]
  21ca48:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  21ca4a:	2b03      	cmp	r3, #3
  21ca4c:	d036      	beq.n	21cabc <SD_InitCard+0x124>
  {
    /* Get the SD card RCA */
    hsd->SdCard.RelCardAdd = sd_rca;
  21ca4e:	89fb      	ldrh	r3, [r7, #14]
  21ca50:	461a      	mov	r2, r3
  21ca52:	687b      	ldr	r3, [r7, #4]
  21ca54:	651a      	str	r2, [r3, #80]	; 0x50

    /* Send CMD9 SEND_CSD with argument as card's RCA */
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
  21ca56:	687b      	ldr	r3, [r7, #4]
  21ca58:	681a      	ldr	r2, [r3, #0]
  21ca5a:	687b      	ldr	r3, [r7, #4]
  21ca5c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21ca5e:	041b      	lsls	r3, r3, #16
  21ca60:	4619      	mov	r1, r3
  21ca62:	4610      	mov	r0, r2
  21ca64:	f002 fd97 	bl	21f596 <SDMMC_CmdSendCSD>
  21ca68:	63f8      	str	r0, [r7, #60]	; 0x3c
    if(errorstate != HAL_SD_ERROR_NONE)
  21ca6a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21ca6c:	2b00      	cmp	r3, #0
  21ca6e:	d001      	beq.n	21ca74 <SD_InitCard+0xdc>
    {
      return errorstate;
  21ca70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21ca72:	e05a      	b.n	21cb2a <SD_InitCard+0x192>
    }
    else
    {
      /* Get Card Specific Data */
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
  21ca74:	687b      	ldr	r3, [r7, #4]
  21ca76:	681b      	ldr	r3, [r3, #0]
  21ca78:	2100      	movs	r1, #0
  21ca7a:	4618      	mov	r0, r3
  21ca7c:	f002 fb79 	bl	21f172 <SDMMC_GetResponse>
  21ca80:	4602      	mov	r2, r0
  21ca82:	687b      	ldr	r3, [r7, #4]
  21ca84:	665a      	str	r2, [r3, #100]	; 0x64
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
  21ca86:	687b      	ldr	r3, [r7, #4]
  21ca88:	681b      	ldr	r3, [r3, #0]
  21ca8a:	2104      	movs	r1, #4
  21ca8c:	4618      	mov	r0, r3
  21ca8e:	f002 fb70 	bl	21f172 <SDMMC_GetResponse>
  21ca92:	4602      	mov	r2, r0
  21ca94:	687b      	ldr	r3, [r7, #4]
  21ca96:	669a      	str	r2, [r3, #104]	; 0x68
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
  21ca98:	687b      	ldr	r3, [r7, #4]
  21ca9a:	681b      	ldr	r3, [r3, #0]
  21ca9c:	2108      	movs	r1, #8
  21ca9e:	4618      	mov	r0, r3
  21caa0:	f002 fb67 	bl	21f172 <SDMMC_GetResponse>
  21caa4:	4602      	mov	r2, r0
  21caa6:	687b      	ldr	r3, [r7, #4]
  21caa8:	66da      	str	r2, [r3, #108]	; 0x6c
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
  21caaa:	687b      	ldr	r3, [r7, #4]
  21caac:	681b      	ldr	r3, [r3, #0]
  21caae:	210c      	movs	r1, #12
  21cab0:	4618      	mov	r0, r3
  21cab2:	f002 fb5e 	bl	21f172 <SDMMC_GetResponse>
  21cab6:	4602      	mov	r2, r0
  21cab8:	687b      	ldr	r3, [r7, #4]
  21caba:	671a      	str	r2, [r3, #112]	; 0x70
    }
  }

  /* Get the Card Class */
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
  21cabc:	687b      	ldr	r3, [r7, #4]
  21cabe:	681b      	ldr	r3, [r3, #0]
  21cac0:	2104      	movs	r1, #4
  21cac2:	4618      	mov	r0, r3
  21cac4:	f002 fb55 	bl	21f172 <SDMMC_GetResponse>
  21cac8:	4603      	mov	r3, r0
  21caca:	0d1a      	lsrs	r2, r3, #20
  21cacc:	687b      	ldr	r3, [r7, #4]
  21cace:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Get CSD parameters */
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
  21cad0:	f107 0310 	add.w	r3, r7, #16
  21cad4:	4619      	mov	r1, r3
  21cad6:	6878      	ldr	r0, [r7, #4]
  21cad8:	f7ff fbc6 	bl	21c268 <HAL_SD_GetCardCSD>
  21cadc:	4603      	mov	r3, r0
  21cade:	2b00      	cmp	r3, #0
  21cae0:	d002      	beq.n	21cae8 <SD_InitCard+0x150>
  {
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  21cae2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  21cae6:	e020      	b.n	21cb2a <SD_InitCard+0x192>
  }

  /* Select the Card */
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
  21cae8:	687b      	ldr	r3, [r7, #4]
  21caea:	6819      	ldr	r1, [r3, #0]
  21caec:	687b      	ldr	r3, [r7, #4]
  21caee:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21caf0:	041b      	lsls	r3, r3, #16
  21caf2:	f04f 0400 	mov.w	r4, #0
  21caf6:	461a      	mov	r2, r3
  21caf8:	4623      	mov	r3, r4
  21cafa:	4608      	mov	r0, r1
  21cafc:	f002 fc44 	bl	21f388 <SDMMC_CmdSelDesel>
  21cb00:	63f8      	str	r0, [r7, #60]	; 0x3c
  if(errorstate != HAL_SD_ERROR_NONE)
  21cb02:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21cb04:	2b00      	cmp	r3, #0
  21cb06:	d001      	beq.n	21cb0c <SD_InitCard+0x174>
  {
    return errorstate;
  21cb08:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  21cb0a:	e00e      	b.n	21cb2a <SD_InitCard+0x192>
  }

  /* Configure SDMMC peripheral interface */
  (void)SDMMC_Init(hsd->Instance, hsd->Init);
  21cb0c:	687b      	ldr	r3, [r7, #4]
  21cb0e:	681d      	ldr	r5, [r3, #0]
  21cb10:	687b      	ldr	r3, [r7, #4]
  21cb12:	466c      	mov	r4, sp
  21cb14:	f103 0210 	add.w	r2, r3, #16
  21cb18:	ca07      	ldmia	r2, {r0, r1, r2}
  21cb1a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  21cb1e:	3304      	adds	r3, #4
  21cb20:	cb0e      	ldmia	r3, {r1, r2, r3}
  21cb22:	4628      	mov	r0, r5
  21cb24:	f002 fa86 	bl	21f034 <SDMMC_Init>

  /* All cards are initialized */
  return HAL_SD_ERROR_NONE;
  21cb28:	2300      	movs	r3, #0
}
  21cb2a:	4618      	mov	r0, r3
  21cb2c:	3740      	adds	r7, #64	; 0x40
  21cb2e:	46bd      	mov	sp, r7
  21cb30:	bdb0      	pop	{r4, r5, r7, pc}
	...

0021cb34 <SD_PowerON>:
  *         in the SD handle.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_PowerON(SD_HandleTypeDef *hsd)
{
  21cb34:	b580      	push	{r7, lr}
  21cb36:	b086      	sub	sp, #24
  21cb38:	af00      	add	r7, sp, #0
  21cb3a:	6078      	str	r0, [r7, #4]
  __IO uint32_t count = 0U;
  21cb3c:	2300      	movs	r3, #0
  21cb3e:	60bb      	str	r3, [r7, #8]
  uint32_t response = 0U, validvoltage = 0U;
  21cb40:	2300      	movs	r3, #0
  21cb42:	617b      	str	r3, [r7, #20]
  21cb44:	2300      	movs	r3, #0
  21cb46:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
  21cb48:	687b      	ldr	r3, [r7, #4]
  21cb4a:	681b      	ldr	r3, [r3, #0]
  21cb4c:	4618      	mov	r0, r3
  21cb4e:	f002 fc3e 	bl	21f3ce <SDMMC_CmdGoIdleState>
  21cb52:	60f8      	str	r0, [r7, #12]
  if(errorstate != HAL_SD_ERROR_NONE)
  21cb54:	68fb      	ldr	r3, [r7, #12]
  21cb56:	2b00      	cmp	r3, #0
  21cb58:	d001      	beq.n	21cb5e <SD_PowerON+0x2a>
  {
    return errorstate;
  21cb5a:	68fb      	ldr	r3, [r7, #12]
  21cb5c:	e072      	b.n	21cc44 <SD_PowerON+0x110>
  }

  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
  21cb5e:	687b      	ldr	r3, [r7, #4]
  21cb60:	681b      	ldr	r3, [r3, #0]
  21cb62:	4618      	mov	r0, r3
  21cb64:	f002 fc51 	bl	21f40a <SDMMC_CmdOperCond>
  21cb68:	60f8      	str	r0, [r7, #12]
  if(errorstate != HAL_SD_ERROR_NONE)
  21cb6a:	68fb      	ldr	r3, [r7, #12]
  21cb6c:	2b00      	cmp	r3, #0
  21cb6e:	d00d      	beq.n	21cb8c <SD_PowerON+0x58>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
  21cb70:	687b      	ldr	r3, [r7, #4]
  21cb72:	2200      	movs	r2, #0
  21cb74:	649a      	str	r2, [r3, #72]	; 0x48
    /* CMD0: GO_IDLE_STATE */
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
  21cb76:	687b      	ldr	r3, [r7, #4]
  21cb78:	681b      	ldr	r3, [r3, #0]
  21cb7a:	4618      	mov	r0, r3
  21cb7c:	f002 fc27 	bl	21f3ce <SDMMC_CmdGoIdleState>
  21cb80:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cb82:	68fb      	ldr	r3, [r7, #12]
  21cb84:	2b00      	cmp	r3, #0
  21cb86:	d004      	beq.n	21cb92 <SD_PowerON+0x5e>
    {
      return errorstate;
  21cb88:	68fb      	ldr	r3, [r7, #12]
  21cb8a:	e05b      	b.n	21cc44 <SD_PowerON+0x110>
    }

  }
  else
  {
    hsd->SdCard.CardVersion = CARD_V2_X;
  21cb8c:	687b      	ldr	r3, [r7, #4]
  21cb8e:	2201      	movs	r2, #1
  21cb90:	649a      	str	r2, [r3, #72]	; 0x48
  }

  if( hsd->SdCard.CardVersion == CARD_V2_X)
  21cb92:	687b      	ldr	r3, [r7, #4]
  21cb94:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  21cb96:	2b01      	cmp	r3, #1
  21cb98:	d137      	bne.n	21cc0a <SD_PowerON+0xd6>
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
  21cb9a:	687b      	ldr	r3, [r7, #4]
  21cb9c:	681b      	ldr	r3, [r3, #0]
  21cb9e:	2100      	movs	r1, #0
  21cba0:	4618      	mov	r0, r3
  21cba2:	f002 fc51 	bl	21f448 <SDMMC_CmdAppCommand>
  21cba6:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cba8:	68fb      	ldr	r3, [r7, #12]
  21cbaa:	2b00      	cmp	r3, #0
  21cbac:	d02d      	beq.n	21cc0a <SD_PowerON+0xd6>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  21cbae:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  21cbb2:	e047      	b.n	21cc44 <SD_PowerON+0x110>
  /* SD CARD */
  /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
  {
    /* SEND CMD55 APP_CMD with RCA as 0 */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
  21cbb4:	687b      	ldr	r3, [r7, #4]
  21cbb6:	681b      	ldr	r3, [r3, #0]
  21cbb8:	2100      	movs	r1, #0
  21cbba:	4618      	mov	r0, r3
  21cbbc:	f002 fc44 	bl	21f448 <SDMMC_CmdAppCommand>
  21cbc0:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cbc2:	68fb      	ldr	r3, [r7, #12]
  21cbc4:	2b00      	cmp	r3, #0
  21cbc6:	d001      	beq.n	21cbcc <SD_PowerON+0x98>
    {
      return errorstate;
  21cbc8:	68fb      	ldr	r3, [r7, #12]
  21cbca:	e03b      	b.n	21cc44 <SD_PowerON+0x110>
    }

    /* Send CMD41 */
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
  21cbcc:	687b      	ldr	r3, [r7, #4]
  21cbce:	681b      	ldr	r3, [r3, #0]
  21cbd0:	491e      	ldr	r1, [pc, #120]	; (21cc4c <SD_PowerON+0x118>)
  21cbd2:	4618      	mov	r0, r3
  21cbd4:	f002 fc5a 	bl	21f48c <SDMMC_CmdAppOperCommand>
  21cbd8:	60f8      	str	r0, [r7, #12]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cbda:	68fb      	ldr	r3, [r7, #12]
  21cbdc:	2b00      	cmp	r3, #0
  21cbde:	d002      	beq.n	21cbe6 <SD_PowerON+0xb2>
    {
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
  21cbe0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
  21cbe4:	e02e      	b.n	21cc44 <SD_PowerON+0x110>
    }

    /* Get command response */
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
  21cbe6:	687b      	ldr	r3, [r7, #4]
  21cbe8:	681b      	ldr	r3, [r3, #0]
  21cbea:	2100      	movs	r1, #0
  21cbec:	4618      	mov	r0, r3
  21cbee:	f002 fac0 	bl	21f172 <SDMMC_GetResponse>
  21cbf2:	6178      	str	r0, [r7, #20]

    /* Get operating voltage*/
    validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
  21cbf4:	697b      	ldr	r3, [r7, #20]
  21cbf6:	0fdb      	lsrs	r3, r3, #31
  21cbf8:	2b01      	cmp	r3, #1
  21cbfa:	d101      	bne.n	21cc00 <SD_PowerON+0xcc>
  21cbfc:	2301      	movs	r3, #1
  21cbfe:	e000      	b.n	21cc02 <SD_PowerON+0xce>
  21cc00:	2300      	movs	r3, #0
  21cc02:	613b      	str	r3, [r7, #16]

    count++;
  21cc04:	68bb      	ldr	r3, [r7, #8]
  21cc06:	3301      	adds	r3, #1
  21cc08:	60bb      	str	r3, [r7, #8]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
  21cc0a:	68bb      	ldr	r3, [r7, #8]
  21cc0c:	f64f 72fe 	movw	r2, #65534	; 0xfffe
  21cc10:	4293      	cmp	r3, r2
  21cc12:	d802      	bhi.n	21cc1a <SD_PowerON+0xe6>
  21cc14:	693b      	ldr	r3, [r7, #16]
  21cc16:	2b00      	cmp	r3, #0
  21cc18:	d0cc      	beq.n	21cbb4 <SD_PowerON+0x80>
  }

  if(count >= SDMMC_MAX_VOLT_TRIAL)
  21cc1a:	68bb      	ldr	r3, [r7, #8]
  21cc1c:	f64f 72fe 	movw	r2, #65534	; 0xfffe
  21cc20:	4293      	cmp	r3, r2
  21cc22:	d902      	bls.n	21cc2a <SD_PowerON+0xf6>
  {
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
  21cc24:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
  21cc28:	e00c      	b.n	21cc44 <SD_PowerON+0x110>
  }

  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
  21cc2a:	697b      	ldr	r3, [r7, #20]
  21cc2c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  21cc30:	2b00      	cmp	r3, #0
  21cc32:	d003      	beq.n	21cc3c <SD_PowerON+0x108>
  {
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
  21cc34:	687b      	ldr	r3, [r7, #4]
  21cc36:	2201      	movs	r2, #1
  21cc38:	645a      	str	r2, [r3, #68]	; 0x44
  21cc3a:	e002      	b.n	21cc42 <SD_PowerON+0x10e>
  }
  else
  {
    hsd->SdCard.CardType = CARD_SDSC;
  21cc3c:	687b      	ldr	r3, [r7, #4]
  21cc3e:	2200      	movs	r2, #0
  21cc40:	645a      	str	r2, [r3, #68]	; 0x44
  }


  return HAL_SD_ERROR_NONE;
  21cc42:	2300      	movs	r3, #0
}
  21cc44:	4618      	mov	r0, r3
  21cc46:	3718      	adds	r7, #24
  21cc48:	46bd      	mov	sp, r7
  21cc4a:	bd80      	pop	{r7, pc}
  21cc4c:	c1100000 	.word	0xc1100000

0021cc50 <SD_SendStatus>:
  * @param  pCardStatus: pointer to the buffer that will contain the SD card
  *         status (Card Status register)
  * @retval error state
  */
static uint32_t SD_SendStatus(SD_HandleTypeDef *hsd, uint32_t *pCardStatus)
{
  21cc50:	b580      	push	{r7, lr}
  21cc52:	b084      	sub	sp, #16
  21cc54:	af00      	add	r7, sp, #0
  21cc56:	6078      	str	r0, [r7, #4]
  21cc58:	6039      	str	r1, [r7, #0]
  uint32_t errorstate;

  if(pCardStatus == NULL)
  21cc5a:	683b      	ldr	r3, [r7, #0]
  21cc5c:	2b00      	cmp	r3, #0
  21cc5e:	d102      	bne.n	21cc66 <SD_SendStatus+0x16>
  {
    return HAL_SD_ERROR_PARAM;
  21cc60:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
  21cc64:	e018      	b.n	21cc98 <SD_SendStatus+0x48>
  }

  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
  21cc66:	687b      	ldr	r3, [r7, #4]
  21cc68:	681a      	ldr	r2, [r3, #0]
  21cc6a:	687b      	ldr	r3, [r7, #4]
  21cc6c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21cc6e:	041b      	lsls	r3, r3, #16
  21cc70:	4619      	mov	r1, r3
  21cc72:	4610      	mov	r0, r2
  21cc74:	f002 fccf 	bl	21f616 <SDMMC_CmdSendStatus>
  21cc78:	60f8      	str	r0, [r7, #12]
  if(errorstate != HAL_SD_ERROR_NONE)
  21cc7a:	68fb      	ldr	r3, [r7, #12]
  21cc7c:	2b00      	cmp	r3, #0
  21cc7e:	d001      	beq.n	21cc84 <SD_SendStatus+0x34>
  {
    return errorstate;
  21cc80:	68fb      	ldr	r3, [r7, #12]
  21cc82:	e009      	b.n	21cc98 <SD_SendStatus+0x48>
  }

  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
  21cc84:	687b      	ldr	r3, [r7, #4]
  21cc86:	681b      	ldr	r3, [r3, #0]
  21cc88:	2100      	movs	r1, #0
  21cc8a:	4618      	mov	r0, r3
  21cc8c:	f002 fa71 	bl	21f172 <SDMMC_GetResponse>
  21cc90:	4602      	mov	r2, r0
  21cc92:	683b      	ldr	r3, [r7, #0]
  21cc94:	601a      	str	r2, [r3, #0]

  return HAL_SD_ERROR_NONE;
  21cc96:	2300      	movs	r3, #0
}
  21cc98:	4618      	mov	r0, r3
  21cc9a:	3710      	adds	r7, #16
  21cc9c:	46bd      	mov	sp, r7
  21cc9e:	bd80      	pop	{r7, pc}

0021cca0 <SD_WideBus_Enable>:
  * @brief  Enables the SDMMC wide bus mode.
  * @param  hsd: pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Enable(SD_HandleTypeDef *hsd)
{
  21cca0:	b580      	push	{r7, lr}
  21cca2:	b086      	sub	sp, #24
  21cca4:	af00      	add	r7, sp, #0
  21cca6:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0U, 0U};
  21cca8:	2300      	movs	r3, #0
  21ccaa:	60fb      	str	r3, [r7, #12]
  21ccac:	2300      	movs	r3, #0
  21ccae:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
  21ccb0:	687b      	ldr	r3, [r7, #4]
  21ccb2:	681b      	ldr	r3, [r3, #0]
  21ccb4:	2100      	movs	r1, #0
  21ccb6:	4618      	mov	r0, r3
  21ccb8:	f002 fa5b 	bl	21f172 <SDMMC_GetResponse>
  21ccbc:	4603      	mov	r3, r0
  21ccbe:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21ccc2:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
  21ccc6:	d102      	bne.n	21ccce <SD_WideBus_Enable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  21ccc8:	f44f 6300 	mov.w	r3, #2048	; 0x800
  21cccc:	e02f      	b.n	21cd2e <SD_WideBus_Enable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
  21ccce:	f107 030c 	add.w	r3, r7, #12
  21ccd2:	4619      	mov	r1, r3
  21ccd4:	6878      	ldr	r0, [r7, #4]
  21ccd6:	f000 f879 	bl	21cdcc <SD_FindSCR>
  21ccda:	6178      	str	r0, [r7, #20]
  if(errorstate != HAL_SD_ERROR_NONE)
  21ccdc:	697b      	ldr	r3, [r7, #20]
  21ccde:	2b00      	cmp	r3, #0
  21cce0:	d001      	beq.n	21cce6 <SD_WideBus_Enable+0x46>
  {
    return errorstate;
  21cce2:	697b      	ldr	r3, [r7, #20]
  21cce4:	e023      	b.n	21cd2e <SD_WideBus_Enable+0x8e>
  }

  /* If requested card supports wide bus operation */
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
  21cce6:	693b      	ldr	r3, [r7, #16]
  21cce8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  21ccec:	2b00      	cmp	r3, #0
  21ccee:	d01c      	beq.n	21cd2a <SD_WideBus_Enable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA.*/
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
  21ccf0:	687b      	ldr	r3, [r7, #4]
  21ccf2:	681a      	ldr	r2, [r3, #0]
  21ccf4:	687b      	ldr	r3, [r7, #4]
  21ccf6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21ccf8:	041b      	lsls	r3, r3, #16
  21ccfa:	4619      	mov	r1, r3
  21ccfc:	4610      	mov	r0, r2
  21ccfe:	f002 fba3 	bl	21f448 <SDMMC_CmdAppCommand>
  21cd02:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cd04:	697b      	ldr	r3, [r7, #20]
  21cd06:	2b00      	cmp	r3, #0
  21cd08:	d001      	beq.n	21cd0e <SD_WideBus_Enable+0x6e>
    {
      return errorstate;
  21cd0a:	697b      	ldr	r3, [r7, #20]
  21cd0c:	e00f      	b.n	21cd2e <SD_WideBus_Enable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 2 for wide bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
  21cd0e:	687b      	ldr	r3, [r7, #4]
  21cd10:	681b      	ldr	r3, [r3, #0]
  21cd12:	2102      	movs	r1, #2
  21cd14:	4618      	mov	r0, r3
  21cd16:	f002 fbdd 	bl	21f4d4 <SDMMC_CmdBusWidth>
  21cd1a:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cd1c:	697b      	ldr	r3, [r7, #20]
  21cd1e:	2b00      	cmp	r3, #0
  21cd20:	d001      	beq.n	21cd26 <SD_WideBus_Enable+0x86>
    {
      return errorstate;
  21cd22:	697b      	ldr	r3, [r7, #20]
  21cd24:	e003      	b.n	21cd2e <SD_WideBus_Enable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
  21cd26:	2300      	movs	r3, #0
  21cd28:	e001      	b.n	21cd2e <SD_WideBus_Enable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  21cd2a:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  }
}
  21cd2e:	4618      	mov	r0, r3
  21cd30:	3718      	adds	r7, #24
  21cd32:	46bd      	mov	sp, r7
  21cd34:	bd80      	pop	{r7, pc}

0021cd36 <SD_WideBus_Disable>:
  * @brief  Disables the SDMMC wide bus mode.
  * @param  hsd: Pointer to SD handle
  * @retval error state
  */
static uint32_t SD_WideBus_Disable(SD_HandleTypeDef *hsd)
{
  21cd36:	b580      	push	{r7, lr}
  21cd38:	b086      	sub	sp, #24
  21cd3a:	af00      	add	r7, sp, #0
  21cd3c:	6078      	str	r0, [r7, #4]
  uint32_t scr[2U] = {0U, 0U};
  21cd3e:	2300      	movs	r3, #0
  21cd40:	60fb      	str	r3, [r7, #12]
  21cd42:	2300      	movs	r3, #0
  21cd44:	613b      	str	r3, [r7, #16]
  uint32_t errorstate;

  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
  21cd46:	687b      	ldr	r3, [r7, #4]
  21cd48:	681b      	ldr	r3, [r3, #0]
  21cd4a:	2100      	movs	r1, #0
  21cd4c:	4618      	mov	r0, r3
  21cd4e:	f002 fa10 	bl	21f172 <SDMMC_GetResponse>
  21cd52:	4603      	mov	r3, r0
  21cd54:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
  21cd58:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
  21cd5c:	d102      	bne.n	21cd64 <SD_WideBus_Disable+0x2e>
  {
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
  21cd5e:	f44f 6300 	mov.w	r3, #2048	; 0x800
  21cd62:	e02f      	b.n	21cdc4 <SD_WideBus_Disable+0x8e>
  }

  /* Get SCR Register */
  errorstate = SD_FindSCR(hsd, scr);
  21cd64:	f107 030c 	add.w	r3, r7, #12
  21cd68:	4619      	mov	r1, r3
  21cd6a:	6878      	ldr	r0, [r7, #4]
  21cd6c:	f000 f82e 	bl	21cdcc <SD_FindSCR>
  21cd70:	6178      	str	r0, [r7, #20]
  if(errorstate != HAL_SD_ERROR_NONE)
  21cd72:	697b      	ldr	r3, [r7, #20]
  21cd74:	2b00      	cmp	r3, #0
  21cd76:	d001      	beq.n	21cd7c <SD_WideBus_Disable+0x46>
  {
    return errorstate;
  21cd78:	697b      	ldr	r3, [r7, #20]
  21cd7a:	e023      	b.n	21cdc4 <SD_WideBus_Disable+0x8e>
  }

  /* If requested card supports 1 bit mode operation */
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
  21cd7c:	693b      	ldr	r3, [r7, #16]
  21cd7e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  21cd82:	2b00      	cmp	r3, #0
  21cd84:	d01c      	beq.n	21cdc0 <SD_WideBus_Disable+0x8a>
  {
    /* Send CMD55 APP_CMD with argument as card's RCA */
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
  21cd86:	687b      	ldr	r3, [r7, #4]
  21cd88:	681a      	ldr	r2, [r3, #0]
  21cd8a:	687b      	ldr	r3, [r7, #4]
  21cd8c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21cd8e:	041b      	lsls	r3, r3, #16
  21cd90:	4619      	mov	r1, r3
  21cd92:	4610      	mov	r0, r2
  21cd94:	f002 fb58 	bl	21f448 <SDMMC_CmdAppCommand>
  21cd98:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cd9a:	697b      	ldr	r3, [r7, #20]
  21cd9c:	2b00      	cmp	r3, #0
  21cd9e:	d001      	beq.n	21cda4 <SD_WideBus_Disable+0x6e>
    {
      return errorstate;
  21cda0:	697b      	ldr	r3, [r7, #20]
  21cda2:	e00f      	b.n	21cdc4 <SD_WideBus_Disable+0x8e>
    }

    /* Send ACMD6 APP_CMD with argument as 0 for single bus mode */
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
  21cda4:	687b      	ldr	r3, [r7, #4]
  21cda6:	681b      	ldr	r3, [r3, #0]
  21cda8:	2100      	movs	r1, #0
  21cdaa:	4618      	mov	r0, r3
  21cdac:	f002 fb92 	bl	21f4d4 <SDMMC_CmdBusWidth>
  21cdb0:	6178      	str	r0, [r7, #20]
    if(errorstate != HAL_SD_ERROR_NONE)
  21cdb2:	697b      	ldr	r3, [r7, #20]
  21cdb4:	2b00      	cmp	r3, #0
  21cdb6:	d001      	beq.n	21cdbc <SD_WideBus_Disable+0x86>
    {
      return errorstate;
  21cdb8:	697b      	ldr	r3, [r7, #20]
  21cdba:	e003      	b.n	21cdc4 <SD_WideBus_Disable+0x8e>
    }

    return HAL_SD_ERROR_NONE;
  21cdbc:	2300      	movs	r3, #0
  21cdbe:	e001      	b.n	21cdc4 <SD_WideBus_Disable+0x8e>
  }
  else
  {
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
  21cdc0:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
  }
}
  21cdc4:	4618      	mov	r0, r3
  21cdc6:	3718      	adds	r7, #24
  21cdc8:	46bd      	mov	sp, r7
  21cdca:	bd80      	pop	{r7, pc}

0021cdcc <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
  21cdcc:	b590      	push	{r4, r7, lr}
  21cdce:	b08f      	sub	sp, #60	; 0x3c
  21cdd0:	af00      	add	r7, sp, #0
  21cdd2:	6078      	str	r0, [r7, #4]
  21cdd4:	6039      	str	r1, [r7, #0]
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
  21cdd6:	f7fc f82b 	bl	218e30 <HAL_GetTick>
  21cdda:	6338      	str	r0, [r7, #48]	; 0x30
  uint32_t index = 0U;
  21cddc:	2300      	movs	r3, #0
  21cdde:	637b      	str	r3, [r7, #52]	; 0x34
  uint32_t tempscr[2U] = {0U, 0U};
  21cde0:	2300      	movs	r3, #0
  21cde2:	60bb      	str	r3, [r7, #8]
  21cde4:	2300      	movs	r3, #0
  21cde6:	60fb      	str	r3, [r7, #12]
  uint32_t *scr = pSCR;
  21cde8:	683b      	ldr	r3, [r7, #0]
  21cdea:	62fb      	str	r3, [r7, #44]	; 0x2c

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
  21cdec:	687b      	ldr	r3, [r7, #4]
  21cdee:	681b      	ldr	r3, [r3, #0]
  21cdf0:	2108      	movs	r1, #8
  21cdf2:	4618      	mov	r0, r3
  21cdf4:	f002 f9fc 	bl	21f1f0 <SDMMC_CmdBlockLength>
  21cdf8:	62b8      	str	r0, [r7, #40]	; 0x28
  if(errorstate != HAL_SD_ERROR_NONE)
  21cdfa:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21cdfc:	2b00      	cmp	r3, #0
  21cdfe:	d001      	beq.n	21ce04 <SD_FindSCR+0x38>
  {
    return errorstate;
  21ce00:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21ce02:	e0b2      	b.n	21cf6a <SD_FindSCR+0x19e>
  }

  /* Send CMD55 APP_CMD with argument as card's RCA */
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
  21ce04:	687b      	ldr	r3, [r7, #4]
  21ce06:	681a      	ldr	r2, [r3, #0]
  21ce08:	687b      	ldr	r3, [r7, #4]
  21ce0a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21ce0c:	041b      	lsls	r3, r3, #16
  21ce0e:	4619      	mov	r1, r3
  21ce10:	4610      	mov	r0, r2
  21ce12:	f002 fb19 	bl	21f448 <SDMMC_CmdAppCommand>
  21ce16:	62b8      	str	r0, [r7, #40]	; 0x28
  if(errorstate != HAL_SD_ERROR_NONE)
  21ce18:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21ce1a:	2b00      	cmp	r3, #0
  21ce1c:	d001      	beq.n	21ce22 <SD_FindSCR+0x56>
  {
    return errorstate;
  21ce1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21ce20:	e0a3      	b.n	21cf6a <SD_FindSCR+0x19e>
  }

  config.DataTimeOut   = SDMMC_DATATIMEOUT;
  21ce22:	f04f 33ff 	mov.w	r3, #4294967295
  21ce26:	613b      	str	r3, [r7, #16]
  config.DataLength    = 8U;
  21ce28:	2308      	movs	r3, #8
  21ce2a:	617b      	str	r3, [r7, #20]
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
  21ce2c:	2330      	movs	r3, #48	; 0x30
  21ce2e:	61bb      	str	r3, [r7, #24]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
  21ce30:	2302      	movs	r3, #2
  21ce32:	61fb      	str	r3, [r7, #28]
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
  21ce34:	2300      	movs	r3, #0
  21ce36:	623b      	str	r3, [r7, #32]
  config.DPSM          = SDMMC_DPSM_ENABLE;
  21ce38:	2301      	movs	r3, #1
  21ce3a:	627b      	str	r3, [r7, #36]	; 0x24
  (void)SDMMC_ConfigData(hsd->Instance, &config);
  21ce3c:	687b      	ldr	r3, [r7, #4]
  21ce3e:	681b      	ldr	r3, [r3, #0]
  21ce40:	f107 0210 	add.w	r2, r7, #16
  21ce44:	4611      	mov	r1, r2
  21ce46:	4618      	mov	r0, r3
  21ce48:	f002 f9a6 	bl	21f198 <SDMMC_ConfigData>

  /* Send ACMD51 SD_APP_SEND_SCR with argument as 0 */
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
  21ce4c:	687b      	ldr	r3, [r7, #4]
  21ce4e:	681b      	ldr	r3, [r3, #0]
  21ce50:	4618      	mov	r0, r3
  21ce52:	f002 fb61 	bl	21f518 <SDMMC_CmdSendSCR>
  21ce56:	62b8      	str	r0, [r7, #40]	; 0x28
  if(errorstate != HAL_SD_ERROR_NONE)
  21ce58:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21ce5a:	2b00      	cmp	r3, #0
  21ce5c:	d02a      	beq.n	21ceb4 <SD_FindSCR+0xe8>
  {
    return errorstate;
  21ce5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  21ce60:	e083      	b.n	21cf6a <SD_FindSCR+0x19e>
  }

  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT))
  {
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL))
  21ce62:	687b      	ldr	r3, [r7, #4]
  21ce64:	681b      	ldr	r3, [r3, #0]
  21ce66:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21ce68:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  21ce6c:	2b00      	cmp	r3, #0
  21ce6e:	d00f      	beq.n	21ce90 <SD_FindSCR+0xc4>
    {
      *(tempscr + index) = SDMMC_ReadFIFO(hsd->Instance);
  21ce70:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  21ce72:	009b      	lsls	r3, r3, #2
  21ce74:	f107 0208 	add.w	r2, r7, #8
  21ce78:	18d4      	adds	r4, r2, r3
  21ce7a:	687b      	ldr	r3, [r7, #4]
  21ce7c:	681b      	ldr	r3, [r3, #0]
  21ce7e:	4618      	mov	r0, r3
  21ce80:	f002 f904 	bl	21f08c <SDMMC_ReadFIFO>
  21ce84:	4603      	mov	r3, r0
  21ce86:	6023      	str	r3, [r4, #0]
      index++;
  21ce88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  21ce8a:	3301      	adds	r3, #1
  21ce8c:	637b      	str	r3, [r7, #52]	; 0x34
  21ce8e:	e006      	b.n	21ce9e <SD_FindSCR+0xd2>
    }
    else if(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXACT))
  21ce90:	687b      	ldr	r3, [r7, #4]
  21ce92:	681b      	ldr	r3, [r3, #0]
  21ce94:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21ce96:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  21ce9a:	2b00      	cmp	r3, #0
  21ce9c:	d012      	beq.n	21cec4 <SD_FindSCR+0xf8>
    {
      break;
    }

    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
  21ce9e:	f7fb ffc7 	bl	218e30 <HAL_GetTick>
  21cea2:	4602      	mov	r2, r0
  21cea4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  21cea6:	1ad3      	subs	r3, r2, r3
  21cea8:	f1b3 3fff 	cmp.w	r3, #4294967295
  21ceac:	d102      	bne.n	21ceb4 <SD_FindSCR+0xe8>
    {
      return HAL_SD_ERROR_TIMEOUT;
  21ceae:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21ceb2:	e05a      	b.n	21cf6a <SD_FindSCR+0x19e>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT))
  21ceb4:	687b      	ldr	r3, [r7, #4]
  21ceb6:	681b      	ldr	r3, [r3, #0]
  21ceb8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21ceba:	f003 032a 	and.w	r3, r3, #42	; 0x2a
  21cebe:	2b00      	cmp	r3, #0
  21cec0:	d0cf      	beq.n	21ce62 <SD_FindSCR+0x96>
  21cec2:	e000      	b.n	21cec6 <SD_FindSCR+0xfa>
      break;
  21cec4:	bf00      	nop
    }
  }

  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
  21cec6:	687b      	ldr	r3, [r7, #4]
  21cec8:	681b      	ldr	r3, [r3, #0]
  21ceca:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21cecc:	f003 0308 	and.w	r3, r3, #8
  21ced0:	2b00      	cmp	r3, #0
  21ced2:	d005      	beq.n	21cee0 <SD_FindSCR+0x114>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
  21ced4:	687b      	ldr	r3, [r7, #4]
  21ced6:	681b      	ldr	r3, [r3, #0]
  21ced8:	2208      	movs	r2, #8
  21ceda:	639a      	str	r2, [r3, #56]	; 0x38

    return HAL_SD_ERROR_DATA_TIMEOUT;
  21cedc:	2308      	movs	r3, #8
  21cede:	e044      	b.n	21cf6a <SD_FindSCR+0x19e>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
  21cee0:	687b      	ldr	r3, [r7, #4]
  21cee2:	681b      	ldr	r3, [r3, #0]
  21cee4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21cee6:	f003 0302 	and.w	r3, r3, #2
  21ceea:	2b00      	cmp	r3, #0
  21ceec:	d005      	beq.n	21cefa <SD_FindSCR+0x12e>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
  21ceee:	687b      	ldr	r3, [r7, #4]
  21cef0:	681b      	ldr	r3, [r3, #0]
  21cef2:	2202      	movs	r2, #2
  21cef4:	639a      	str	r2, [r3, #56]	; 0x38

    return HAL_SD_ERROR_DATA_CRC_FAIL;
  21cef6:	2302      	movs	r3, #2
  21cef8:	e037      	b.n	21cf6a <SD_FindSCR+0x19e>
  }
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
  21cefa:	687b      	ldr	r3, [r7, #4]
  21cefc:	681b      	ldr	r3, [r3, #0]
  21cefe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21cf00:	f003 0320 	and.w	r3, r3, #32
  21cf04:	2b00      	cmp	r3, #0
  21cf06:	d005      	beq.n	21cf14 <SD_FindSCR+0x148>
  {
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
  21cf08:	687b      	ldr	r3, [r7, #4]
  21cf0a:	681b      	ldr	r3, [r3, #0]
  21cf0c:	2220      	movs	r2, #32
  21cf0e:	639a      	str	r2, [r3, #56]	; 0x38

    return HAL_SD_ERROR_RX_OVERRUN;
  21cf10:	2320      	movs	r3, #32
  21cf12:	e02a      	b.n	21cf6a <SD_FindSCR+0x19e>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
  21cf14:	687b      	ldr	r3, [r7, #4]
  21cf16:	681b      	ldr	r3, [r3, #0]
  21cf18:	f240 523a 	movw	r2, #1338	; 0x53a
  21cf1c:	639a      	str	r2, [r3, #56]	; 0x38

    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
  21cf1e:	68fb      	ldr	r3, [r7, #12]
  21cf20:	061a      	lsls	r2, r3, #24
  21cf22:	68fb      	ldr	r3, [r7, #12]
  21cf24:	021b      	lsls	r3, r3, #8
  21cf26:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  21cf2a:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
  21cf2c:	68fb      	ldr	r3, [r7, #12]
  21cf2e:	0a1b      	lsrs	r3, r3, #8
  21cf30:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
  21cf34:	431a      	orrs	r2, r3
            ((tempscr[1] & SDMMC_16TO23BITS) >> 8) | ((tempscr[1] & SDMMC_24TO31BITS) >> 24));
  21cf36:	68fb      	ldr	r3, [r7, #12]
  21cf38:	0e1b      	lsrs	r3, r3, #24
  21cf3a:	431a      	orrs	r2, r3
    *scr = (((tempscr[1] & SDMMC_0TO7BITS) << 24)  | ((tempscr[1] & SDMMC_8TO15BITS) << 8) |\
  21cf3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21cf3e:	601a      	str	r2, [r3, #0]
    scr++;
  21cf40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21cf42:	3304      	adds	r3, #4
  21cf44:	62fb      	str	r3, [r7, #44]	; 0x2c
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
  21cf46:	68bb      	ldr	r3, [r7, #8]
  21cf48:	061a      	lsls	r2, r3, #24
  21cf4a:	68bb      	ldr	r3, [r7, #8]
  21cf4c:	021b      	lsls	r3, r3, #8
  21cf4e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
  21cf52:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));
  21cf54:	68bb      	ldr	r3, [r7, #8]
  21cf56:	0a1b      	lsrs	r3, r3, #8
  21cf58:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
  21cf5c:	431a      	orrs	r2, r3
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));
  21cf5e:	68bb      	ldr	r3, [r7, #8]
  21cf60:	0e1b      	lsrs	r3, r3, #24
  21cf62:	431a      	orrs	r2, r3
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
  21cf64:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21cf66:	601a      	str	r2, [r3, #0]

  }

  return HAL_SD_ERROR_NONE;
  21cf68:	2300      	movs	r3, #0
}
  21cf6a:	4618      	mov	r0, r3
  21cf6c:	373c      	adds	r7, #60	; 0x3c
  21cf6e:	46bd      	mov	sp, r7
  21cf70:	bd90      	pop	{r4, r7, pc}

0021cf72 <SD_Read_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Read_IT(SD_HandleTypeDef *hsd)
{
  21cf72:	b580      	push	{r7, lr}
  21cf74:	b086      	sub	sp, #24
  21cf76:	af00      	add	r7, sp, #0
  21cf78:	6078      	str	r0, [r7, #4]
  uint32_t count, data, dataremaining;
  uint8_t* tmp;

  tmp = hsd->pRxBuffPtr;
  21cf7a:	687b      	ldr	r3, [r7, #4]
  21cf7c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  21cf7e:	60fb      	str	r3, [r7, #12]
  dataremaining = hsd->RxXferSize;
  21cf80:	687b      	ldr	r3, [r7, #4]
  21cf82:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21cf84:	613b      	str	r3, [r7, #16]

  if (dataremaining > 0U)
  21cf86:	693b      	ldr	r3, [r7, #16]
  21cf88:	2b00      	cmp	r3, #0
  21cf8a:	d03f      	beq.n	21d00c <SD_Read_IT+0x9a>
  {
    /* Read data from SDMMC Rx FIFO */
    for(count = 0U; count < 8U; count++)
  21cf8c:	2300      	movs	r3, #0
  21cf8e:	617b      	str	r3, [r7, #20]
  21cf90:	e033      	b.n	21cffa <SD_Read_IT+0x88>
    {
      data = SDMMC_ReadFIFO(hsd->Instance);
  21cf92:	687b      	ldr	r3, [r7, #4]
  21cf94:	681b      	ldr	r3, [r3, #0]
  21cf96:	4618      	mov	r0, r3
  21cf98:	f002 f878 	bl	21f08c <SDMMC_ReadFIFO>
  21cf9c:	60b8      	str	r0, [r7, #8]
      *tmp = (uint8_t)(data & 0xFFU);
  21cf9e:	68bb      	ldr	r3, [r7, #8]
  21cfa0:	b2da      	uxtb	r2, r3
  21cfa2:	68fb      	ldr	r3, [r7, #12]
  21cfa4:	701a      	strb	r2, [r3, #0]
      tmp++;
  21cfa6:	68fb      	ldr	r3, [r7, #12]
  21cfa8:	3301      	adds	r3, #1
  21cfaa:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21cfac:	693b      	ldr	r3, [r7, #16]
  21cfae:	3b01      	subs	r3, #1
  21cfb0:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 8U) & 0xFFU);
  21cfb2:	68bb      	ldr	r3, [r7, #8]
  21cfb4:	0a1b      	lsrs	r3, r3, #8
  21cfb6:	b2da      	uxtb	r2, r3
  21cfb8:	68fb      	ldr	r3, [r7, #12]
  21cfba:	701a      	strb	r2, [r3, #0]
      tmp++;
  21cfbc:	68fb      	ldr	r3, [r7, #12]
  21cfbe:	3301      	adds	r3, #1
  21cfc0:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21cfc2:	693b      	ldr	r3, [r7, #16]
  21cfc4:	3b01      	subs	r3, #1
  21cfc6:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 16U) & 0xFFU);
  21cfc8:	68bb      	ldr	r3, [r7, #8]
  21cfca:	0c1b      	lsrs	r3, r3, #16
  21cfcc:	b2da      	uxtb	r2, r3
  21cfce:	68fb      	ldr	r3, [r7, #12]
  21cfd0:	701a      	strb	r2, [r3, #0]
      tmp++;
  21cfd2:	68fb      	ldr	r3, [r7, #12]
  21cfd4:	3301      	adds	r3, #1
  21cfd6:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21cfd8:	693b      	ldr	r3, [r7, #16]
  21cfda:	3b01      	subs	r3, #1
  21cfdc:	613b      	str	r3, [r7, #16]
      *tmp = (uint8_t)((data >> 24U) & 0xFFU);
  21cfde:	68bb      	ldr	r3, [r7, #8]
  21cfe0:	0e1b      	lsrs	r3, r3, #24
  21cfe2:	b2da      	uxtb	r2, r3
  21cfe4:	68fb      	ldr	r3, [r7, #12]
  21cfe6:	701a      	strb	r2, [r3, #0]
      tmp++;
  21cfe8:	68fb      	ldr	r3, [r7, #12]
  21cfea:	3301      	adds	r3, #1
  21cfec:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21cfee:	693b      	ldr	r3, [r7, #16]
  21cff0:	3b01      	subs	r3, #1
  21cff2:	613b      	str	r3, [r7, #16]
    for(count = 0U; count < 8U; count++)
  21cff4:	697b      	ldr	r3, [r7, #20]
  21cff6:	3301      	adds	r3, #1
  21cff8:	617b      	str	r3, [r7, #20]
  21cffa:	697b      	ldr	r3, [r7, #20]
  21cffc:	2b07      	cmp	r3, #7
  21cffe:	d9c8      	bls.n	21cf92 <SD_Read_IT+0x20>
    }

    hsd->pRxBuffPtr = tmp;
  21d000:	687b      	ldr	r3, [r7, #4]
  21d002:	68fa      	ldr	r2, [r7, #12]
  21d004:	629a      	str	r2, [r3, #40]	; 0x28
    hsd->RxXferSize = dataremaining;
  21d006:	687b      	ldr	r3, [r7, #4]
  21d008:	693a      	ldr	r2, [r7, #16]
  21d00a:	62da      	str	r2, [r3, #44]	; 0x2c
  }
}
  21d00c:	bf00      	nop
  21d00e:	3718      	adds	r7, #24
  21d010:	46bd      	mov	sp, r7
  21d012:	bd80      	pop	{r7, pc}

0021d014 <SD_Write_IT>:
  * @param  hsd: pointer to a SD_HandleTypeDef structure that contains
  *              the configuration information.
  * @retval None
  */
static void SD_Write_IT(SD_HandleTypeDef *hsd)
{
  21d014:	b580      	push	{r7, lr}
  21d016:	b086      	sub	sp, #24
  21d018:	af00      	add	r7, sp, #0
  21d01a:	6078      	str	r0, [r7, #4]
  uint32_t count, data, dataremaining;
  uint8_t* tmp;

  tmp = hsd->pTxBuffPtr;
  21d01c:	687b      	ldr	r3, [r7, #4]
  21d01e:	6a1b      	ldr	r3, [r3, #32]
  21d020:	60fb      	str	r3, [r7, #12]
  dataremaining = hsd->TxXferSize;
  21d022:	687b      	ldr	r3, [r7, #4]
  21d024:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21d026:	613b      	str	r3, [r7, #16]

  if (dataremaining > 0U)
  21d028:	693b      	ldr	r3, [r7, #16]
  21d02a:	2b00      	cmp	r3, #0
  21d02c:	d043      	beq.n	21d0b6 <SD_Write_IT+0xa2>
  {
    /* Write data to SDMMC Tx FIFO */
    for(count = 0U; count < 8U; count++)
  21d02e:	2300      	movs	r3, #0
  21d030:	617b      	str	r3, [r7, #20]
  21d032:	e037      	b.n	21d0a4 <SD_Write_IT+0x90>
    {
      data = (uint32_t)(*tmp);
  21d034:	68fb      	ldr	r3, [r7, #12]
  21d036:	781b      	ldrb	r3, [r3, #0]
  21d038:	60bb      	str	r3, [r7, #8]
      tmp++;
  21d03a:	68fb      	ldr	r3, [r7, #12]
  21d03c:	3301      	adds	r3, #1
  21d03e:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21d040:	693b      	ldr	r3, [r7, #16]
  21d042:	3b01      	subs	r3, #1
  21d044:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 8U);
  21d046:	68fb      	ldr	r3, [r7, #12]
  21d048:	781b      	ldrb	r3, [r3, #0]
  21d04a:	021a      	lsls	r2, r3, #8
  21d04c:	68bb      	ldr	r3, [r7, #8]
  21d04e:	4313      	orrs	r3, r2
  21d050:	60bb      	str	r3, [r7, #8]
      tmp++;
  21d052:	68fb      	ldr	r3, [r7, #12]
  21d054:	3301      	adds	r3, #1
  21d056:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21d058:	693b      	ldr	r3, [r7, #16]
  21d05a:	3b01      	subs	r3, #1
  21d05c:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 16U);
  21d05e:	68fb      	ldr	r3, [r7, #12]
  21d060:	781b      	ldrb	r3, [r3, #0]
  21d062:	041a      	lsls	r2, r3, #16
  21d064:	68bb      	ldr	r3, [r7, #8]
  21d066:	4313      	orrs	r3, r2
  21d068:	60bb      	str	r3, [r7, #8]
      tmp++;
  21d06a:	68fb      	ldr	r3, [r7, #12]
  21d06c:	3301      	adds	r3, #1
  21d06e:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21d070:	693b      	ldr	r3, [r7, #16]
  21d072:	3b01      	subs	r3, #1
  21d074:	613b      	str	r3, [r7, #16]
      data |= ((uint32_t)(*tmp) << 24U);
  21d076:	68fb      	ldr	r3, [r7, #12]
  21d078:	781b      	ldrb	r3, [r3, #0]
  21d07a:	061a      	lsls	r2, r3, #24
  21d07c:	68bb      	ldr	r3, [r7, #8]
  21d07e:	4313      	orrs	r3, r2
  21d080:	60bb      	str	r3, [r7, #8]
      tmp++;
  21d082:	68fb      	ldr	r3, [r7, #12]
  21d084:	3301      	adds	r3, #1
  21d086:	60fb      	str	r3, [r7, #12]
      dataremaining--;
  21d088:	693b      	ldr	r3, [r7, #16]
  21d08a:	3b01      	subs	r3, #1
  21d08c:	613b      	str	r3, [r7, #16]
      (void)SDMMC_WriteFIFO(hsd->Instance, &data);
  21d08e:	687b      	ldr	r3, [r7, #4]
  21d090:	681b      	ldr	r3, [r3, #0]
  21d092:	f107 0208 	add.w	r2, r7, #8
  21d096:	4611      	mov	r1, r2
  21d098:	4618      	mov	r0, r3
  21d09a:	f002 f804 	bl	21f0a6 <SDMMC_WriteFIFO>
    for(count = 0U; count < 8U; count++)
  21d09e:	697b      	ldr	r3, [r7, #20]
  21d0a0:	3301      	adds	r3, #1
  21d0a2:	617b      	str	r3, [r7, #20]
  21d0a4:	697b      	ldr	r3, [r7, #20]
  21d0a6:	2b07      	cmp	r3, #7
  21d0a8:	d9c4      	bls.n	21d034 <SD_Write_IT+0x20>
    }

    hsd->pTxBuffPtr = tmp;
  21d0aa:	687b      	ldr	r3, [r7, #4]
  21d0ac:	68fa      	ldr	r2, [r7, #12]
  21d0ae:	621a      	str	r2, [r3, #32]
    hsd->TxXferSize = dataremaining;
  21d0b0:	687b      	ldr	r3, [r7, #4]
  21d0b2:	693a      	ldr	r2, [r7, #16]
  21d0b4:	625a      	str	r2, [r3, #36]	; 0x24
  }
}
  21d0b6:	bf00      	nop
  21d0b8:	3718      	adds	r7, #24
  21d0ba:	46bd      	mov	sp, r7
  21d0bc:	bd80      	pop	{r7, pc}

0021d0be <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
  21d0be:	b580      	push	{r7, lr}
  21d0c0:	b082      	sub	sp, #8
  21d0c2:	af00      	add	r7, sp, #0
  21d0c4:	6078      	str	r0, [r7, #4]
  21d0c6:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
  21d0c8:	687b      	ldr	r3, [r7, #4]
  21d0ca:	2b00      	cmp	r3, #0
  21d0cc:	d101      	bne.n	21d0d2 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
  21d0ce:	2301      	movs	r3, #1
  21d0d0:	e025      	b.n	21d11e <HAL_SDRAM_Init+0x60>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
  21d0d2:	687b      	ldr	r3, [r7, #4]
  21d0d4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
  21d0d8:	b2db      	uxtb	r3, r3
  21d0da:	2b00      	cmp	r3, #0
  21d0dc:	d106      	bne.n	21d0ec <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
  21d0de:	687b      	ldr	r3, [r7, #4]
  21d0e0:	2200      	movs	r2, #0
  21d0e2:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
  21d0e6:	6878      	ldr	r0, [r7, #4]
  21d0e8:	f7fa fcfa 	bl	217ae0 <HAL_SDRAM_MspInit>
#endif
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
  21d0ec:	687b      	ldr	r3, [r7, #4]
  21d0ee:	2202      	movs	r2, #2
  21d0f0:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
  21d0f4:	687b      	ldr	r3, [r7, #4]
  21d0f6:	681a      	ldr	r2, [r3, #0]
  21d0f8:	687b      	ldr	r3, [r7, #4]
  21d0fa:	3304      	adds	r3, #4
  21d0fc:	4619      	mov	r1, r3
  21d0fe:	4610      	mov	r0, r2
  21d100:	f001 fe82 	bl	21ee08 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
  21d104:	687b      	ldr	r3, [r7, #4]
  21d106:	6818      	ldr	r0, [r3, #0]
  21d108:	687b      	ldr	r3, [r7, #4]
  21d10a:	685b      	ldr	r3, [r3, #4]
  21d10c:	461a      	mov	r2, r3
  21d10e:	6839      	ldr	r1, [r7, #0]
  21d110:	f001 feec 	bl	21eeec <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
  21d114:	687b      	ldr	r3, [r7, #4]
  21d116:	2201      	movs	r2, #1
  21d118:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
  21d11c:	2300      	movs	r3, #0
}
  21d11e:	4618      	mov	r0, r3
  21d120:	3708      	adds	r7, #8
  21d122:	46bd      	mov	sp, r7
  21d124:	bd80      	pop	{r7, pc}

0021d126 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  21d126:	b580      	push	{r7, lr}
  21d128:	b084      	sub	sp, #16
  21d12a:	af00      	add	r7, sp, #0
  21d12c:	60f8      	str	r0, [r7, #12]
  21d12e:	60b9      	str	r1, [r7, #8]
  21d130:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
  21d132:	68fb      	ldr	r3, [r7, #12]
  21d134:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
  21d138:	b2db      	uxtb	r3, r3
  21d13a:	2b02      	cmp	r3, #2
  21d13c:	d101      	bne.n	21d142 <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
  21d13e:	2302      	movs	r3, #2
  21d140:	e018      	b.n	21d174 <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
  21d142:	68fb      	ldr	r3, [r7, #12]
  21d144:	2202      	movs	r2, #2
  21d146:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
  21d14a:	68fb      	ldr	r3, [r7, #12]
  21d14c:	681b      	ldr	r3, [r3, #0]
  21d14e:	687a      	ldr	r2, [r7, #4]
  21d150:	68b9      	ldr	r1, [r7, #8]
  21d152:	4618      	mov	r0, r3
  21d154:	f001 ff4a 	bl	21efec <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
  21d158:	68bb      	ldr	r3, [r7, #8]
  21d15a:	681b      	ldr	r3, [r3, #0]
  21d15c:	2b02      	cmp	r3, #2
  21d15e:	d104      	bne.n	21d16a <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
  21d160:	68fb      	ldr	r3, [r7, #12]
  21d162:	2205      	movs	r2, #5
  21d164:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  21d168:	e003      	b.n	21d172 <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
  21d16a:	68fb      	ldr	r3, [r7, #12]
  21d16c:	2201      	movs	r2, #1
  21d16e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
  21d172:	2300      	movs	r3, #0
}
  21d174:	4618      	mov	r0, r3
  21d176:	3710      	adds	r7, #16
  21d178:	46bd      	mov	sp, r7
  21d17a:	bd80      	pop	{r7, pc}

0021d17c <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
  21d17c:	b580      	push	{r7, lr}
  21d17e:	b082      	sub	sp, #8
  21d180:	af00      	add	r7, sp, #0
  21d182:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
  21d184:	687b      	ldr	r3, [r7, #4]
  21d186:	2b00      	cmp	r3, #0
  21d188:	d101      	bne.n	21d18e <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
  21d18a:	2301      	movs	r3, #1
  21d18c:	e049      	b.n	21d222 <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
  21d18e:	687b      	ldr	r3, [r7, #4]
  21d190:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
  21d194:	b2db      	uxtb	r3, r3
  21d196:	2b00      	cmp	r3, #0
  21d198:	d106      	bne.n	21d1a8 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
  21d19a:	687b      	ldr	r3, [r7, #4]
  21d19c:	2200      	movs	r2, #0
  21d19e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
  21d1a2:	6878      	ldr	r0, [r7, #4]
  21d1a4:	f7fb fc28 	bl	2189f8 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
  21d1a8:	687b      	ldr	r3, [r7, #4]
  21d1aa:	2202      	movs	r2, #2
  21d1ac:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
  21d1b0:	687b      	ldr	r3, [r7, #4]
  21d1b2:	681a      	ldr	r2, [r3, #0]
  21d1b4:	687b      	ldr	r3, [r7, #4]
  21d1b6:	3304      	adds	r3, #4
  21d1b8:	4619      	mov	r1, r3
  21d1ba:	4610      	mov	r0, r2
  21d1bc:	f000 fb48 	bl	21d850 <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
  21d1c0:	687b      	ldr	r3, [r7, #4]
  21d1c2:	2201      	movs	r2, #1
  21d1c4:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  21d1c8:	687b      	ldr	r3, [r7, #4]
  21d1ca:	2201      	movs	r2, #1
  21d1cc:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
  21d1d0:	687b      	ldr	r3, [r7, #4]
  21d1d2:	2201      	movs	r2, #1
  21d1d4:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
  21d1d8:	687b      	ldr	r3, [r7, #4]
  21d1da:	2201      	movs	r2, #1
  21d1dc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
  21d1e0:	687b      	ldr	r3, [r7, #4]
  21d1e2:	2201      	movs	r2, #1
  21d1e4:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  21d1e8:	687b      	ldr	r3, [r7, #4]
  21d1ea:	2201      	movs	r2, #1
  21d1ec:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
  21d1f0:	687b      	ldr	r3, [r7, #4]
  21d1f2:	2201      	movs	r2, #1
  21d1f4:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
  21d1f8:	687b      	ldr	r3, [r7, #4]
  21d1fa:	2201      	movs	r2, #1
  21d1fc:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  21d200:	687b      	ldr	r3, [r7, #4]
  21d202:	2201      	movs	r2, #1
  21d204:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  21d208:	687b      	ldr	r3, [r7, #4]
  21d20a:	2201      	movs	r2, #1
  21d20c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
  21d210:	687b      	ldr	r3, [r7, #4]
  21d212:	2201      	movs	r2, #1
  21d214:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
  21d218:	687b      	ldr	r3, [r7, #4]
  21d21a:	2201      	movs	r2, #1
  21d21c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
  21d220:	2300      	movs	r3, #0
}
  21d222:	4618      	mov	r0, r3
  21d224:	3708      	adds	r7, #8
  21d226:	46bd      	mov	sp, r7
  21d228:	bd80      	pop	{r7, pc}
	...

0021d22c <HAL_TIM_Base_Start>:
  * @brief  Starts the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
{
  21d22c:	b480      	push	{r7}
  21d22e:	b085      	sub	sp, #20
  21d230:	af00      	add	r7, sp, #0
  21d232:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
  21d234:	687b      	ldr	r3, [r7, #4]
  21d236:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
  21d23a:	b2db      	uxtb	r3, r3
  21d23c:	2b01      	cmp	r3, #1
  21d23e:	d001      	beq.n	21d244 <HAL_TIM_Base_Start+0x18>
  {
    return HAL_ERROR;
  21d240:	2301      	movs	r3, #1
  21d242:	e04c      	b.n	21d2de <HAL_TIM_Base_Start+0xb2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
  21d244:	687b      	ldr	r3, [r7, #4]
  21d246:	2202      	movs	r2, #2
  21d248:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
  21d24c:	687b      	ldr	r3, [r7, #4]
  21d24e:	681b      	ldr	r3, [r3, #0]
  21d250:	4a26      	ldr	r2, [pc, #152]	; (21d2ec <HAL_TIM_Base_Start+0xc0>)
  21d252:	4293      	cmp	r3, r2
  21d254:	d022      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d256:	687b      	ldr	r3, [r7, #4]
  21d258:	681b      	ldr	r3, [r3, #0]
  21d25a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  21d25e:	d01d      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d260:	687b      	ldr	r3, [r7, #4]
  21d262:	681b      	ldr	r3, [r3, #0]
  21d264:	4a22      	ldr	r2, [pc, #136]	; (21d2f0 <HAL_TIM_Base_Start+0xc4>)
  21d266:	4293      	cmp	r3, r2
  21d268:	d018      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d26a:	687b      	ldr	r3, [r7, #4]
  21d26c:	681b      	ldr	r3, [r3, #0]
  21d26e:	4a21      	ldr	r2, [pc, #132]	; (21d2f4 <HAL_TIM_Base_Start+0xc8>)
  21d270:	4293      	cmp	r3, r2
  21d272:	d013      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d274:	687b      	ldr	r3, [r7, #4]
  21d276:	681b      	ldr	r3, [r3, #0]
  21d278:	4a1f      	ldr	r2, [pc, #124]	; (21d2f8 <HAL_TIM_Base_Start+0xcc>)
  21d27a:	4293      	cmp	r3, r2
  21d27c:	d00e      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d27e:	687b      	ldr	r3, [r7, #4]
  21d280:	681b      	ldr	r3, [r3, #0]
  21d282:	4a1e      	ldr	r2, [pc, #120]	; (21d2fc <HAL_TIM_Base_Start+0xd0>)
  21d284:	4293      	cmp	r3, r2
  21d286:	d009      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d288:	687b      	ldr	r3, [r7, #4]
  21d28a:	681b      	ldr	r3, [r3, #0]
  21d28c:	4a1c      	ldr	r2, [pc, #112]	; (21d300 <HAL_TIM_Base_Start+0xd4>)
  21d28e:	4293      	cmp	r3, r2
  21d290:	d004      	beq.n	21d29c <HAL_TIM_Base_Start+0x70>
  21d292:	687b      	ldr	r3, [r7, #4]
  21d294:	681b      	ldr	r3, [r3, #0]
  21d296:	4a1b      	ldr	r2, [pc, #108]	; (21d304 <HAL_TIM_Base_Start+0xd8>)
  21d298:	4293      	cmp	r3, r2
  21d29a:	d115      	bne.n	21d2c8 <HAL_TIM_Base_Start+0x9c>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
  21d29c:	687b      	ldr	r3, [r7, #4]
  21d29e:	681b      	ldr	r3, [r3, #0]
  21d2a0:	689a      	ldr	r2, [r3, #8]
  21d2a2:	4b19      	ldr	r3, [pc, #100]	; (21d308 <HAL_TIM_Base_Start+0xdc>)
  21d2a4:	4013      	ands	r3, r2
  21d2a6:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  21d2a8:	68fb      	ldr	r3, [r7, #12]
  21d2aa:	2b06      	cmp	r3, #6
  21d2ac:	d015      	beq.n	21d2da <HAL_TIM_Base_Start+0xae>
  21d2ae:	68fb      	ldr	r3, [r7, #12]
  21d2b0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  21d2b4:	d011      	beq.n	21d2da <HAL_TIM_Base_Start+0xae>
    {
      __HAL_TIM_ENABLE(htim);
  21d2b6:	687b      	ldr	r3, [r7, #4]
  21d2b8:	681b      	ldr	r3, [r3, #0]
  21d2ba:	687a      	ldr	r2, [r7, #4]
  21d2bc:	6812      	ldr	r2, [r2, #0]
  21d2be:	6812      	ldr	r2, [r2, #0]
  21d2c0:	f042 0201 	orr.w	r2, r2, #1
  21d2c4:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  21d2c6:	e008      	b.n	21d2da <HAL_TIM_Base_Start+0xae>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
  21d2c8:	687b      	ldr	r3, [r7, #4]
  21d2ca:	681b      	ldr	r3, [r3, #0]
  21d2cc:	687a      	ldr	r2, [r7, #4]
  21d2ce:	6812      	ldr	r2, [r2, #0]
  21d2d0:	6812      	ldr	r2, [r2, #0]
  21d2d2:	f042 0201 	orr.w	r2, r2, #1
  21d2d6:	601a      	str	r2, [r3, #0]
  21d2d8:	e000      	b.n	21d2dc <HAL_TIM_Base_Start+0xb0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  21d2da:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
  21d2dc:	2300      	movs	r3, #0
}
  21d2de:	4618      	mov	r0, r3
  21d2e0:	3714      	adds	r7, #20
  21d2e2:	46bd      	mov	sp, r7
  21d2e4:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d2e8:	4770      	bx	lr
  21d2ea:	bf00      	nop
  21d2ec:	40010000 	.word	0x40010000
  21d2f0:	40000400 	.word	0x40000400
  21d2f4:	40000800 	.word	0x40000800
  21d2f8:	40000c00 	.word	0x40000c00
  21d2fc:	40010400 	.word	0x40010400
  21d300:	40014000 	.word	0x40014000
  21d304:	40001800 	.word	0x40001800
  21d308:	00010007 	.word	0x00010007

0021d30c <HAL_TIM_Base_Stop>:
  * @brief  Stops the TIM Base generation.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
{
  21d30c:	b480      	push	{r7}
  21d30e:	b083      	sub	sp, #12
  21d310:	af00      	add	r7, sp, #0
  21d312:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Disable the Peripheral */
  __HAL_TIM_DISABLE(htim);
  21d314:	687b      	ldr	r3, [r7, #4]
  21d316:	681b      	ldr	r3, [r3, #0]
  21d318:	6a1a      	ldr	r2, [r3, #32]
  21d31a:	f241 1311 	movw	r3, #4369	; 0x1111
  21d31e:	4013      	ands	r3, r2
  21d320:	2b00      	cmp	r3, #0
  21d322:	d10f      	bne.n	21d344 <HAL_TIM_Base_Stop+0x38>
  21d324:	687b      	ldr	r3, [r7, #4]
  21d326:	681b      	ldr	r3, [r3, #0]
  21d328:	6a1a      	ldr	r2, [r3, #32]
  21d32a:	f240 4344 	movw	r3, #1092	; 0x444
  21d32e:	4013      	ands	r3, r2
  21d330:	2b00      	cmp	r3, #0
  21d332:	d107      	bne.n	21d344 <HAL_TIM_Base_Stop+0x38>
  21d334:	687b      	ldr	r3, [r7, #4]
  21d336:	681b      	ldr	r3, [r3, #0]
  21d338:	687a      	ldr	r2, [r7, #4]
  21d33a:	6812      	ldr	r2, [r2, #0]
  21d33c:	6812      	ldr	r2, [r2, #0]
  21d33e:	f022 0201 	bic.w	r2, r2, #1
  21d342:	601a      	str	r2, [r3, #0]

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_READY;
  21d344:	687b      	ldr	r3, [r7, #4]
  21d346:	2201      	movs	r2, #1
  21d348:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Return function status */
  return HAL_OK;
  21d34c:	2300      	movs	r3, #0
}
  21d34e:	4618      	mov	r0, r3
  21d350:	370c      	adds	r7, #12
  21d352:	46bd      	mov	sp, r7
  21d354:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d358:	4770      	bx	lr
	...

0021d35c <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
  21d35c:	b480      	push	{r7}
  21d35e:	b085      	sub	sp, #20
  21d360:	af00      	add	r7, sp, #0
  21d362:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
  21d364:	687b      	ldr	r3, [r7, #4]
  21d366:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
  21d36a:	b2db      	uxtb	r3, r3
  21d36c:	2b01      	cmp	r3, #1
  21d36e:	d001      	beq.n	21d374 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
  21d370:	2301      	movs	r3, #1
  21d372:	e054      	b.n	21d41e <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
  21d374:	687b      	ldr	r3, [r7, #4]
  21d376:	2202      	movs	r2, #2
  21d378:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
  21d37c:	687b      	ldr	r3, [r7, #4]
  21d37e:	681b      	ldr	r3, [r3, #0]
  21d380:	687a      	ldr	r2, [r7, #4]
  21d382:	6812      	ldr	r2, [r2, #0]
  21d384:	68d2      	ldr	r2, [r2, #12]
  21d386:	f042 0201 	orr.w	r2, r2, #1
  21d38a:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
  21d38c:	687b      	ldr	r3, [r7, #4]
  21d38e:	681b      	ldr	r3, [r3, #0]
  21d390:	4a26      	ldr	r2, [pc, #152]	; (21d42c <HAL_TIM_Base_Start_IT+0xd0>)
  21d392:	4293      	cmp	r3, r2
  21d394:	d022      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d396:	687b      	ldr	r3, [r7, #4]
  21d398:	681b      	ldr	r3, [r3, #0]
  21d39a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  21d39e:	d01d      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d3a0:	687b      	ldr	r3, [r7, #4]
  21d3a2:	681b      	ldr	r3, [r3, #0]
  21d3a4:	4a22      	ldr	r2, [pc, #136]	; (21d430 <HAL_TIM_Base_Start_IT+0xd4>)
  21d3a6:	4293      	cmp	r3, r2
  21d3a8:	d018      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d3aa:	687b      	ldr	r3, [r7, #4]
  21d3ac:	681b      	ldr	r3, [r3, #0]
  21d3ae:	4a21      	ldr	r2, [pc, #132]	; (21d434 <HAL_TIM_Base_Start_IT+0xd8>)
  21d3b0:	4293      	cmp	r3, r2
  21d3b2:	d013      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d3b4:	687b      	ldr	r3, [r7, #4]
  21d3b6:	681b      	ldr	r3, [r3, #0]
  21d3b8:	4a1f      	ldr	r2, [pc, #124]	; (21d438 <HAL_TIM_Base_Start_IT+0xdc>)
  21d3ba:	4293      	cmp	r3, r2
  21d3bc:	d00e      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d3be:	687b      	ldr	r3, [r7, #4]
  21d3c0:	681b      	ldr	r3, [r3, #0]
  21d3c2:	4a1e      	ldr	r2, [pc, #120]	; (21d43c <HAL_TIM_Base_Start_IT+0xe0>)
  21d3c4:	4293      	cmp	r3, r2
  21d3c6:	d009      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d3c8:	687b      	ldr	r3, [r7, #4]
  21d3ca:	681b      	ldr	r3, [r3, #0]
  21d3cc:	4a1c      	ldr	r2, [pc, #112]	; (21d440 <HAL_TIM_Base_Start_IT+0xe4>)
  21d3ce:	4293      	cmp	r3, r2
  21d3d0:	d004      	beq.n	21d3dc <HAL_TIM_Base_Start_IT+0x80>
  21d3d2:	687b      	ldr	r3, [r7, #4]
  21d3d4:	681b      	ldr	r3, [r3, #0]
  21d3d6:	4a1b      	ldr	r2, [pc, #108]	; (21d444 <HAL_TIM_Base_Start_IT+0xe8>)
  21d3d8:	4293      	cmp	r3, r2
  21d3da:	d115      	bne.n	21d408 <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
  21d3dc:	687b      	ldr	r3, [r7, #4]
  21d3de:	681b      	ldr	r3, [r3, #0]
  21d3e0:	689a      	ldr	r2, [r3, #8]
  21d3e2:	4b19      	ldr	r3, [pc, #100]	; (21d448 <HAL_TIM_Base_Start_IT+0xec>)
  21d3e4:	4013      	ands	r3, r2
  21d3e6:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  21d3e8:	68fb      	ldr	r3, [r7, #12]
  21d3ea:	2b06      	cmp	r3, #6
  21d3ec:	d015      	beq.n	21d41a <HAL_TIM_Base_Start_IT+0xbe>
  21d3ee:	68fb      	ldr	r3, [r7, #12]
  21d3f0:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  21d3f4:	d011      	beq.n	21d41a <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
  21d3f6:	687b      	ldr	r3, [r7, #4]
  21d3f8:	681b      	ldr	r3, [r3, #0]
  21d3fa:	687a      	ldr	r2, [r7, #4]
  21d3fc:	6812      	ldr	r2, [r2, #0]
  21d3fe:	6812      	ldr	r2, [r2, #0]
  21d400:	f042 0201 	orr.w	r2, r2, #1
  21d404:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  21d406:	e008      	b.n	21d41a <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
  21d408:	687b      	ldr	r3, [r7, #4]
  21d40a:	681b      	ldr	r3, [r3, #0]
  21d40c:	687a      	ldr	r2, [r7, #4]
  21d40e:	6812      	ldr	r2, [r2, #0]
  21d410:	6812      	ldr	r2, [r2, #0]
  21d412:	f042 0201 	orr.w	r2, r2, #1
  21d416:	601a      	str	r2, [r3, #0]
  21d418:	e000      	b.n	21d41c <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
  21d41a:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
  21d41c:	2300      	movs	r3, #0
}
  21d41e:	4618      	mov	r0, r3
  21d420:	3714      	adds	r7, #20
  21d422:	46bd      	mov	sp, r7
  21d424:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d428:	4770      	bx	lr
  21d42a:	bf00      	nop
  21d42c:	40010000 	.word	0x40010000
  21d430:	40000400 	.word	0x40000400
  21d434:	40000800 	.word	0x40000800
  21d438:	40000c00 	.word	0x40000c00
  21d43c:	40010400 	.word	0x40010400
  21d440:	40014000 	.word	0x40014000
  21d444:	40001800 	.word	0x40001800
  21d448:	00010007 	.word	0x00010007

0021d44c <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  21d44c:	b580      	push	{r7, lr}
  21d44e:	b082      	sub	sp, #8
  21d450:	af00      	add	r7, sp, #0
  21d452:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
  21d454:	687b      	ldr	r3, [r7, #4]
  21d456:	681b      	ldr	r3, [r3, #0]
  21d458:	691b      	ldr	r3, [r3, #16]
  21d45a:	f003 0302 	and.w	r3, r3, #2
  21d45e:	2b02      	cmp	r3, #2
  21d460:	d122      	bne.n	21d4a8 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
  21d462:	687b      	ldr	r3, [r7, #4]
  21d464:	681b      	ldr	r3, [r3, #0]
  21d466:	68db      	ldr	r3, [r3, #12]
  21d468:	f003 0302 	and.w	r3, r3, #2
  21d46c:	2b02      	cmp	r3, #2
  21d46e:	d11b      	bne.n	21d4a8 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
  21d470:	687b      	ldr	r3, [r7, #4]
  21d472:	681b      	ldr	r3, [r3, #0]
  21d474:	f06f 0202 	mvn.w	r2, #2
  21d478:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
  21d47a:	687b      	ldr	r3, [r7, #4]
  21d47c:	2201      	movs	r2, #1
  21d47e:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
  21d480:	687b      	ldr	r3, [r7, #4]
  21d482:	681b      	ldr	r3, [r3, #0]
  21d484:	699b      	ldr	r3, [r3, #24]
  21d486:	f003 0303 	and.w	r3, r3, #3
  21d48a:	2b00      	cmp	r3, #0
  21d48c:	d003      	beq.n	21d496 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
  21d48e:	6878      	ldr	r0, [r7, #4]
  21d490:	f000 f9c0 	bl	21d814 <HAL_TIM_IC_CaptureCallback>
  21d494:	e005      	b.n	21d4a2 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
  21d496:	6878      	ldr	r0, [r7, #4]
  21d498:	f000 f9b2 	bl	21d800 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
  21d49c:	6878      	ldr	r0, [r7, #4]
  21d49e:	f000 f9c3 	bl	21d828 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  21d4a2:	687b      	ldr	r3, [r7, #4]
  21d4a4:	2200      	movs	r2, #0
  21d4a6:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
  21d4a8:	687b      	ldr	r3, [r7, #4]
  21d4aa:	681b      	ldr	r3, [r3, #0]
  21d4ac:	691b      	ldr	r3, [r3, #16]
  21d4ae:	f003 0304 	and.w	r3, r3, #4
  21d4b2:	2b04      	cmp	r3, #4
  21d4b4:	d122      	bne.n	21d4fc <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
  21d4b6:	687b      	ldr	r3, [r7, #4]
  21d4b8:	681b      	ldr	r3, [r3, #0]
  21d4ba:	68db      	ldr	r3, [r3, #12]
  21d4bc:	f003 0304 	and.w	r3, r3, #4
  21d4c0:	2b04      	cmp	r3, #4
  21d4c2:	d11b      	bne.n	21d4fc <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
  21d4c4:	687b      	ldr	r3, [r7, #4]
  21d4c6:	681b      	ldr	r3, [r3, #0]
  21d4c8:	f06f 0204 	mvn.w	r2, #4
  21d4cc:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
  21d4ce:	687b      	ldr	r3, [r7, #4]
  21d4d0:	2202      	movs	r2, #2
  21d4d2:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
  21d4d4:	687b      	ldr	r3, [r7, #4]
  21d4d6:	681b      	ldr	r3, [r3, #0]
  21d4d8:	699b      	ldr	r3, [r3, #24]
  21d4da:	f403 7340 	and.w	r3, r3, #768	; 0x300
  21d4de:	2b00      	cmp	r3, #0
  21d4e0:	d003      	beq.n	21d4ea <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
  21d4e2:	6878      	ldr	r0, [r7, #4]
  21d4e4:	f000 f996 	bl	21d814 <HAL_TIM_IC_CaptureCallback>
  21d4e8:	e005      	b.n	21d4f6 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
  21d4ea:	6878      	ldr	r0, [r7, #4]
  21d4ec:	f000 f988 	bl	21d800 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
  21d4f0:	6878      	ldr	r0, [r7, #4]
  21d4f2:	f000 f999 	bl	21d828 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  21d4f6:	687b      	ldr	r3, [r7, #4]
  21d4f8:	2200      	movs	r2, #0
  21d4fa:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
  21d4fc:	687b      	ldr	r3, [r7, #4]
  21d4fe:	681b      	ldr	r3, [r3, #0]
  21d500:	691b      	ldr	r3, [r3, #16]
  21d502:	f003 0308 	and.w	r3, r3, #8
  21d506:	2b08      	cmp	r3, #8
  21d508:	d122      	bne.n	21d550 <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
  21d50a:	687b      	ldr	r3, [r7, #4]
  21d50c:	681b      	ldr	r3, [r3, #0]
  21d50e:	68db      	ldr	r3, [r3, #12]
  21d510:	f003 0308 	and.w	r3, r3, #8
  21d514:	2b08      	cmp	r3, #8
  21d516:	d11b      	bne.n	21d550 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
  21d518:	687b      	ldr	r3, [r7, #4]
  21d51a:	681b      	ldr	r3, [r3, #0]
  21d51c:	f06f 0208 	mvn.w	r2, #8
  21d520:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
  21d522:	687b      	ldr	r3, [r7, #4]
  21d524:	2204      	movs	r2, #4
  21d526:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
  21d528:	687b      	ldr	r3, [r7, #4]
  21d52a:	681b      	ldr	r3, [r3, #0]
  21d52c:	69db      	ldr	r3, [r3, #28]
  21d52e:	f003 0303 	and.w	r3, r3, #3
  21d532:	2b00      	cmp	r3, #0
  21d534:	d003      	beq.n	21d53e <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
  21d536:	6878      	ldr	r0, [r7, #4]
  21d538:	f000 f96c 	bl	21d814 <HAL_TIM_IC_CaptureCallback>
  21d53c:	e005      	b.n	21d54a <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
  21d53e:	6878      	ldr	r0, [r7, #4]
  21d540:	f000 f95e 	bl	21d800 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
  21d544:	6878      	ldr	r0, [r7, #4]
  21d546:	f000 f96f 	bl	21d828 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  21d54a:	687b      	ldr	r3, [r7, #4]
  21d54c:	2200      	movs	r2, #0
  21d54e:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
  21d550:	687b      	ldr	r3, [r7, #4]
  21d552:	681b      	ldr	r3, [r3, #0]
  21d554:	691b      	ldr	r3, [r3, #16]
  21d556:	f003 0310 	and.w	r3, r3, #16
  21d55a:	2b10      	cmp	r3, #16
  21d55c:	d122      	bne.n	21d5a4 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
  21d55e:	687b      	ldr	r3, [r7, #4]
  21d560:	681b      	ldr	r3, [r3, #0]
  21d562:	68db      	ldr	r3, [r3, #12]
  21d564:	f003 0310 	and.w	r3, r3, #16
  21d568:	2b10      	cmp	r3, #16
  21d56a:	d11b      	bne.n	21d5a4 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
  21d56c:	687b      	ldr	r3, [r7, #4]
  21d56e:	681b      	ldr	r3, [r3, #0]
  21d570:	f06f 0210 	mvn.w	r2, #16
  21d574:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
  21d576:	687b      	ldr	r3, [r7, #4]
  21d578:	2208      	movs	r2, #8
  21d57a:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
  21d57c:	687b      	ldr	r3, [r7, #4]
  21d57e:	681b      	ldr	r3, [r3, #0]
  21d580:	69db      	ldr	r3, [r3, #28]
  21d582:	f403 7340 	and.w	r3, r3, #768	; 0x300
  21d586:	2b00      	cmp	r3, #0
  21d588:	d003      	beq.n	21d592 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
  21d58a:	6878      	ldr	r0, [r7, #4]
  21d58c:	f000 f942 	bl	21d814 <HAL_TIM_IC_CaptureCallback>
  21d590:	e005      	b.n	21d59e <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
  21d592:	6878      	ldr	r0, [r7, #4]
  21d594:	f000 f934 	bl	21d800 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
  21d598:	6878      	ldr	r0, [r7, #4]
  21d59a:	f000 f945 	bl	21d828 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
  21d59e:	687b      	ldr	r3, [r7, #4]
  21d5a0:	2200      	movs	r2, #0
  21d5a2:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
  21d5a4:	687b      	ldr	r3, [r7, #4]
  21d5a6:	681b      	ldr	r3, [r3, #0]
  21d5a8:	691b      	ldr	r3, [r3, #16]
  21d5aa:	f003 0301 	and.w	r3, r3, #1
  21d5ae:	2b01      	cmp	r3, #1
  21d5b0:	d10e      	bne.n	21d5d0 <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
  21d5b2:	687b      	ldr	r3, [r7, #4]
  21d5b4:	681b      	ldr	r3, [r3, #0]
  21d5b6:	68db      	ldr	r3, [r3, #12]
  21d5b8:	f003 0301 	and.w	r3, r3, #1
  21d5bc:	2b01      	cmp	r3, #1
  21d5be:	d107      	bne.n	21d5d0 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
  21d5c0:	687b      	ldr	r3, [r7, #4]
  21d5c2:	681b      	ldr	r3, [r3, #0]
  21d5c4:	f06f 0201 	mvn.w	r2, #1
  21d5c8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
  21d5ca:	6878      	ldr	r0, [r7, #4]
  21d5cc:	f7fa ffa2 	bl	218514 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
  21d5d0:	687b      	ldr	r3, [r7, #4]
  21d5d2:	681b      	ldr	r3, [r3, #0]
  21d5d4:	691b      	ldr	r3, [r3, #16]
  21d5d6:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21d5da:	2b80      	cmp	r3, #128	; 0x80
  21d5dc:	d10e      	bne.n	21d5fc <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
  21d5de:	687b      	ldr	r3, [r7, #4]
  21d5e0:	681b      	ldr	r3, [r3, #0]
  21d5e2:	68db      	ldr	r3, [r3, #12]
  21d5e4:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21d5e8:	2b80      	cmp	r3, #128	; 0x80
  21d5ea:	d107      	bne.n	21d5fc <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
  21d5ec:	687b      	ldr	r3, [r7, #4]
  21d5ee:	681b      	ldr	r3, [r3, #0]
  21d5f0:	f06f 0280 	mvn.w	r2, #128	; 0x80
  21d5f4:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
  21d5f6:	6878      	ldr	r0, [r7, #4]
  21d5f8:	f000 fafc 	bl	21dbf4 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
  21d5fc:	687b      	ldr	r3, [r7, #4]
  21d5fe:	681b      	ldr	r3, [r3, #0]
  21d600:	691b      	ldr	r3, [r3, #16]
  21d602:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21d606:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  21d60a:	d10e      	bne.n	21d62a <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
  21d60c:	687b      	ldr	r3, [r7, #4]
  21d60e:	681b      	ldr	r3, [r3, #0]
  21d610:	68db      	ldr	r3, [r3, #12]
  21d612:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21d616:	2b80      	cmp	r3, #128	; 0x80
  21d618:	d107      	bne.n	21d62a <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
  21d61a:	687b      	ldr	r3, [r7, #4]
  21d61c:	681b      	ldr	r3, [r3, #0]
  21d61e:	f46f 7280 	mvn.w	r2, #256	; 0x100
  21d622:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
  21d624:	6878      	ldr	r0, [r7, #4]
  21d626:	f000 faef 	bl	21dc08 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
  21d62a:	687b      	ldr	r3, [r7, #4]
  21d62c:	681b      	ldr	r3, [r3, #0]
  21d62e:	691b      	ldr	r3, [r3, #16]
  21d630:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21d634:	2b40      	cmp	r3, #64	; 0x40
  21d636:	d10e      	bne.n	21d656 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
  21d638:	687b      	ldr	r3, [r7, #4]
  21d63a:	681b      	ldr	r3, [r3, #0]
  21d63c:	68db      	ldr	r3, [r3, #12]
  21d63e:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21d642:	2b40      	cmp	r3, #64	; 0x40
  21d644:	d107      	bne.n	21d656 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
  21d646:	687b      	ldr	r3, [r7, #4]
  21d648:	681b      	ldr	r3, [r3, #0]
  21d64a:	f06f 0240 	mvn.w	r2, #64	; 0x40
  21d64e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
  21d650:	6878      	ldr	r0, [r7, #4]
  21d652:	f000 f8f3 	bl	21d83c <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
  21d656:	687b      	ldr	r3, [r7, #4]
  21d658:	681b      	ldr	r3, [r3, #0]
  21d65a:	691b      	ldr	r3, [r3, #16]
  21d65c:	f003 0320 	and.w	r3, r3, #32
  21d660:	2b20      	cmp	r3, #32
  21d662:	d10e      	bne.n	21d682 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
  21d664:	687b      	ldr	r3, [r7, #4]
  21d666:	681b      	ldr	r3, [r3, #0]
  21d668:	68db      	ldr	r3, [r3, #12]
  21d66a:	f003 0320 	and.w	r3, r3, #32
  21d66e:	2b20      	cmp	r3, #32
  21d670:	d107      	bne.n	21d682 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
  21d672:	687b      	ldr	r3, [r7, #4]
  21d674:	681b      	ldr	r3, [r3, #0]
  21d676:	f06f 0220 	mvn.w	r2, #32
  21d67a:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
  21d67c:	6878      	ldr	r0, [r7, #4]
  21d67e:	f000 faaf 	bl	21dbe0 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
  21d682:	bf00      	nop
  21d684:	3708      	adds	r7, #8
  21d686:	46bd      	mov	sp, r7
  21d688:	bd80      	pop	{r7, pc}
	...

0021d68c <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
  21d68c:	b580      	push	{r7, lr}
  21d68e:	b084      	sub	sp, #16
  21d690:	af00      	add	r7, sp, #0
  21d692:	6078      	str	r0, [r7, #4]
  21d694:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
  21d696:	687b      	ldr	r3, [r7, #4]
  21d698:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
  21d69c:	2b01      	cmp	r3, #1
  21d69e:	d101      	bne.n	21d6a4 <HAL_TIM_ConfigClockSource+0x18>
  21d6a0:	2302      	movs	r3, #2
  21d6a2:	e0a6      	b.n	21d7f2 <HAL_TIM_ConfigClockSource+0x166>
  21d6a4:	687b      	ldr	r3, [r7, #4]
  21d6a6:	2201      	movs	r2, #1
  21d6a8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
  21d6ac:	687b      	ldr	r3, [r7, #4]
  21d6ae:	2202      	movs	r2, #2
  21d6b0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
  21d6b4:	687b      	ldr	r3, [r7, #4]
  21d6b6:	681b      	ldr	r3, [r3, #0]
  21d6b8:	689b      	ldr	r3, [r3, #8]
  21d6ba:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
  21d6bc:	68fa      	ldr	r2, [r7, #12]
  21d6be:	4b4f      	ldr	r3, [pc, #316]	; (21d7fc <HAL_TIM_ConfigClockSource+0x170>)
  21d6c0:	4013      	ands	r3, r2
  21d6c2:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  21d6c4:	68fb      	ldr	r3, [r7, #12]
  21d6c6:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
  21d6ca:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
  21d6cc:	687b      	ldr	r3, [r7, #4]
  21d6ce:	681b      	ldr	r3, [r3, #0]
  21d6d0:	68fa      	ldr	r2, [r7, #12]
  21d6d2:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
  21d6d4:	683b      	ldr	r3, [r7, #0]
  21d6d6:	681b      	ldr	r3, [r3, #0]
  21d6d8:	2b40      	cmp	r3, #64	; 0x40
  21d6da:	d067      	beq.n	21d7ac <HAL_TIM_ConfigClockSource+0x120>
  21d6dc:	2b40      	cmp	r3, #64	; 0x40
  21d6de:	d80b      	bhi.n	21d6f8 <HAL_TIM_ConfigClockSource+0x6c>
  21d6e0:	2b10      	cmp	r3, #16
  21d6e2:	d073      	beq.n	21d7cc <HAL_TIM_ConfigClockSource+0x140>
  21d6e4:	2b10      	cmp	r3, #16
  21d6e6:	d802      	bhi.n	21d6ee <HAL_TIM_ConfigClockSource+0x62>
  21d6e8:	2b00      	cmp	r3, #0
  21d6ea:	d06f      	beq.n	21d7cc <HAL_TIM_ConfigClockSource+0x140>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
        break;
      }

    default:
      break;
  21d6ec:	e078      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
  21d6ee:	2b20      	cmp	r3, #32
  21d6f0:	d06c      	beq.n	21d7cc <HAL_TIM_ConfigClockSource+0x140>
  21d6f2:	2b30      	cmp	r3, #48	; 0x30
  21d6f4:	d06a      	beq.n	21d7cc <HAL_TIM_ConfigClockSource+0x140>
      break;
  21d6f6:	e073      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
  21d6f8:	2b70      	cmp	r3, #112	; 0x70
  21d6fa:	d00d      	beq.n	21d718 <HAL_TIM_ConfigClockSource+0x8c>
  21d6fc:	2b70      	cmp	r3, #112	; 0x70
  21d6fe:	d804      	bhi.n	21d70a <HAL_TIM_ConfigClockSource+0x7e>
  21d700:	2b50      	cmp	r3, #80	; 0x50
  21d702:	d033      	beq.n	21d76c <HAL_TIM_ConfigClockSource+0xe0>
  21d704:	2b60      	cmp	r3, #96	; 0x60
  21d706:	d041      	beq.n	21d78c <HAL_TIM_ConfigClockSource+0x100>
      break;
  21d708:	e06a      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
  21d70a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  21d70e:	d066      	beq.n	21d7de <HAL_TIM_ConfigClockSource+0x152>
  21d710:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  21d714:	d017      	beq.n	21d746 <HAL_TIM_ConfigClockSource+0xba>
      break;
  21d716:	e063      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
  21d718:	687b      	ldr	r3, [r7, #4]
  21d71a:	6818      	ldr	r0, [r3, #0]
  21d71c:	683b      	ldr	r3, [r7, #0]
  21d71e:	6899      	ldr	r1, [r3, #8]
  21d720:	683b      	ldr	r3, [r7, #0]
  21d722:	685a      	ldr	r2, [r3, #4]
  21d724:	683b      	ldr	r3, [r7, #0]
  21d726:	68db      	ldr	r3, [r3, #12]
  21d728:	f000 f9ac 	bl	21da84 <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
  21d72c:	687b      	ldr	r3, [r7, #4]
  21d72e:	681b      	ldr	r3, [r3, #0]
  21d730:	689b      	ldr	r3, [r3, #8]
  21d732:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
  21d734:	68fb      	ldr	r3, [r7, #12]
  21d736:	f043 0377 	orr.w	r3, r3, #119	; 0x77
  21d73a:	60fb      	str	r3, [r7, #12]
      htim->Instance->SMCR = tmpsmcr;
  21d73c:	687b      	ldr	r3, [r7, #4]
  21d73e:	681b      	ldr	r3, [r3, #0]
  21d740:	68fa      	ldr	r2, [r7, #12]
  21d742:	609a      	str	r2, [r3, #8]
      break;
  21d744:	e04c      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
  21d746:	687b      	ldr	r3, [r7, #4]
  21d748:	6818      	ldr	r0, [r3, #0]
  21d74a:	683b      	ldr	r3, [r7, #0]
  21d74c:	6899      	ldr	r1, [r3, #8]
  21d74e:	683b      	ldr	r3, [r7, #0]
  21d750:	685a      	ldr	r2, [r3, #4]
  21d752:	683b      	ldr	r3, [r7, #0]
  21d754:	68db      	ldr	r3, [r3, #12]
  21d756:	f000 f995 	bl	21da84 <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
  21d75a:	687b      	ldr	r3, [r7, #4]
  21d75c:	681b      	ldr	r3, [r3, #0]
  21d75e:	687a      	ldr	r2, [r7, #4]
  21d760:	6812      	ldr	r2, [r2, #0]
  21d762:	6892      	ldr	r2, [r2, #8]
  21d764:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
  21d768:	609a      	str	r2, [r3, #8]
      break;
  21d76a:	e039      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
  21d76c:	687b      	ldr	r3, [r7, #4]
  21d76e:	6818      	ldr	r0, [r3, #0]
  21d770:	683b      	ldr	r3, [r7, #0]
  21d772:	6859      	ldr	r1, [r3, #4]
  21d774:	683b      	ldr	r3, [r7, #0]
  21d776:	68db      	ldr	r3, [r3, #12]
  21d778:	461a      	mov	r2, r3
  21d77a:	f000 f909 	bl	21d990 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
  21d77e:	687b      	ldr	r3, [r7, #4]
  21d780:	681b      	ldr	r3, [r3, #0]
  21d782:	2150      	movs	r1, #80	; 0x50
  21d784:	4618      	mov	r0, r3
  21d786:	f000 f962 	bl	21da4e <TIM_ITRx_SetConfig>
      break;
  21d78a:	e029      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI2_ConfigInputStage(htim->Instance,
  21d78c:	687b      	ldr	r3, [r7, #4]
  21d78e:	6818      	ldr	r0, [r3, #0]
  21d790:	683b      	ldr	r3, [r7, #0]
  21d792:	6859      	ldr	r1, [r3, #4]
  21d794:	683b      	ldr	r3, [r7, #0]
  21d796:	68db      	ldr	r3, [r3, #12]
  21d798:	461a      	mov	r2, r3
  21d79a:	f000 f928 	bl	21d9ee <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
  21d79e:	687b      	ldr	r3, [r7, #4]
  21d7a0:	681b      	ldr	r3, [r3, #0]
  21d7a2:	2160      	movs	r1, #96	; 0x60
  21d7a4:	4618      	mov	r0, r3
  21d7a6:	f000 f952 	bl	21da4e <TIM_ITRx_SetConfig>
      break;
  21d7aa:	e019      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
  21d7ac:	687b      	ldr	r3, [r7, #4]
  21d7ae:	6818      	ldr	r0, [r3, #0]
  21d7b0:	683b      	ldr	r3, [r7, #0]
  21d7b2:	6859      	ldr	r1, [r3, #4]
  21d7b4:	683b      	ldr	r3, [r7, #0]
  21d7b6:	68db      	ldr	r3, [r3, #12]
  21d7b8:	461a      	mov	r2, r3
  21d7ba:	f000 f8e9 	bl	21d990 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
  21d7be:	687b      	ldr	r3, [r7, #4]
  21d7c0:	681b      	ldr	r3, [r3, #0]
  21d7c2:	2140      	movs	r1, #64	; 0x40
  21d7c4:	4618      	mov	r0, r3
  21d7c6:	f000 f942 	bl	21da4e <TIM_ITRx_SetConfig>
      break;
  21d7ca:	e009      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
        TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
  21d7cc:	687b      	ldr	r3, [r7, #4]
  21d7ce:	681a      	ldr	r2, [r3, #0]
  21d7d0:	683b      	ldr	r3, [r7, #0]
  21d7d2:	681b      	ldr	r3, [r3, #0]
  21d7d4:	4619      	mov	r1, r3
  21d7d6:	4610      	mov	r0, r2
  21d7d8:	f000 f939 	bl	21da4e <TIM_ITRx_SetConfig>
        break;
  21d7dc:	e000      	b.n	21d7e0 <HAL_TIM_ConfigClockSource+0x154>
      break;
  21d7de:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
  21d7e0:	687b      	ldr	r3, [r7, #4]
  21d7e2:	2201      	movs	r2, #1
  21d7e4:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
  21d7e8:	687b      	ldr	r3, [r7, #4]
  21d7ea:	2200      	movs	r2, #0
  21d7ec:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
  21d7f0:	2300      	movs	r3, #0
}
  21d7f2:	4618      	mov	r0, r3
  21d7f4:	3710      	adds	r7, #16
  21d7f6:	46bd      	mov	sp, r7
  21d7f8:	bd80      	pop	{r7, pc}
  21d7fa:	bf00      	nop
  21d7fc:	fffeff88 	.word	0xfffeff88

0021d800 <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
  21d800:	b480      	push	{r7}
  21d802:	b083      	sub	sp, #12
  21d804:	af00      	add	r7, sp, #0
  21d806:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
  21d808:	bf00      	nop
  21d80a:	370c      	adds	r7, #12
  21d80c:	46bd      	mov	sp, r7
  21d80e:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d812:	4770      	bx	lr

0021d814 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
  21d814:	b480      	push	{r7}
  21d816:	b083      	sub	sp, #12
  21d818:	af00      	add	r7, sp, #0
  21d81a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
  21d81c:	bf00      	nop
  21d81e:	370c      	adds	r7, #12
  21d820:	46bd      	mov	sp, r7
  21d822:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d826:	4770      	bx	lr

0021d828 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
  21d828:	b480      	push	{r7}
  21d82a:	b083      	sub	sp, #12
  21d82c:	af00      	add	r7, sp, #0
  21d82e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
  21d830:	bf00      	nop
  21d832:	370c      	adds	r7, #12
  21d834:	46bd      	mov	sp, r7
  21d836:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d83a:	4770      	bx	lr

0021d83c <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
  21d83c:	b480      	push	{r7}
  21d83e:	b083      	sub	sp, #12
  21d840:	af00      	add	r7, sp, #0
  21d842:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
  21d844:	bf00      	nop
  21d846:	370c      	adds	r7, #12
  21d848:	46bd      	mov	sp, r7
  21d84a:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d84e:	4770      	bx	lr

0021d850 <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
  21d850:	b480      	push	{r7}
  21d852:	b085      	sub	sp, #20
  21d854:	af00      	add	r7, sp, #0
  21d856:	6078      	str	r0, [r7, #4]
  21d858:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
  21d85a:	687b      	ldr	r3, [r7, #4]
  21d85c:	681b      	ldr	r3, [r3, #0]
  21d85e:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
  21d860:	687b      	ldr	r3, [r7, #4]
  21d862:	4a40      	ldr	r2, [pc, #256]	; (21d964 <TIM_Base_SetConfig+0x114>)
  21d864:	4293      	cmp	r3, r2
  21d866:	d013      	beq.n	21d890 <TIM_Base_SetConfig+0x40>
  21d868:	687b      	ldr	r3, [r7, #4]
  21d86a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  21d86e:	d00f      	beq.n	21d890 <TIM_Base_SetConfig+0x40>
  21d870:	687b      	ldr	r3, [r7, #4]
  21d872:	4a3d      	ldr	r2, [pc, #244]	; (21d968 <TIM_Base_SetConfig+0x118>)
  21d874:	4293      	cmp	r3, r2
  21d876:	d00b      	beq.n	21d890 <TIM_Base_SetConfig+0x40>
  21d878:	687b      	ldr	r3, [r7, #4]
  21d87a:	4a3c      	ldr	r2, [pc, #240]	; (21d96c <TIM_Base_SetConfig+0x11c>)
  21d87c:	4293      	cmp	r3, r2
  21d87e:	d007      	beq.n	21d890 <TIM_Base_SetConfig+0x40>
  21d880:	687b      	ldr	r3, [r7, #4]
  21d882:	4a3b      	ldr	r2, [pc, #236]	; (21d970 <TIM_Base_SetConfig+0x120>)
  21d884:	4293      	cmp	r3, r2
  21d886:	d003      	beq.n	21d890 <TIM_Base_SetConfig+0x40>
  21d888:	687b      	ldr	r3, [r7, #4]
  21d88a:	4a3a      	ldr	r2, [pc, #232]	; (21d974 <TIM_Base_SetConfig+0x124>)
  21d88c:	4293      	cmp	r3, r2
  21d88e:	d108      	bne.n	21d8a2 <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
  21d890:	68fb      	ldr	r3, [r7, #12]
  21d892:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  21d896:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
  21d898:	683b      	ldr	r3, [r7, #0]
  21d89a:	685b      	ldr	r3, [r3, #4]
  21d89c:	68fa      	ldr	r2, [r7, #12]
  21d89e:	4313      	orrs	r3, r2
  21d8a0:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
  21d8a2:	687b      	ldr	r3, [r7, #4]
  21d8a4:	4a2f      	ldr	r2, [pc, #188]	; (21d964 <TIM_Base_SetConfig+0x114>)
  21d8a6:	4293      	cmp	r3, r2
  21d8a8:	d02b      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8aa:	687b      	ldr	r3, [r7, #4]
  21d8ac:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  21d8b0:	d027      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8b2:	687b      	ldr	r3, [r7, #4]
  21d8b4:	4a2c      	ldr	r2, [pc, #176]	; (21d968 <TIM_Base_SetConfig+0x118>)
  21d8b6:	4293      	cmp	r3, r2
  21d8b8:	d023      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8ba:	687b      	ldr	r3, [r7, #4]
  21d8bc:	4a2b      	ldr	r2, [pc, #172]	; (21d96c <TIM_Base_SetConfig+0x11c>)
  21d8be:	4293      	cmp	r3, r2
  21d8c0:	d01f      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8c2:	687b      	ldr	r3, [r7, #4]
  21d8c4:	4a2a      	ldr	r2, [pc, #168]	; (21d970 <TIM_Base_SetConfig+0x120>)
  21d8c6:	4293      	cmp	r3, r2
  21d8c8:	d01b      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8ca:	687b      	ldr	r3, [r7, #4]
  21d8cc:	4a29      	ldr	r2, [pc, #164]	; (21d974 <TIM_Base_SetConfig+0x124>)
  21d8ce:	4293      	cmp	r3, r2
  21d8d0:	d017      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8d2:	687b      	ldr	r3, [r7, #4]
  21d8d4:	4a28      	ldr	r2, [pc, #160]	; (21d978 <TIM_Base_SetConfig+0x128>)
  21d8d6:	4293      	cmp	r3, r2
  21d8d8:	d013      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8da:	687b      	ldr	r3, [r7, #4]
  21d8dc:	4a27      	ldr	r2, [pc, #156]	; (21d97c <TIM_Base_SetConfig+0x12c>)
  21d8de:	4293      	cmp	r3, r2
  21d8e0:	d00f      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8e2:	687b      	ldr	r3, [r7, #4]
  21d8e4:	4a26      	ldr	r2, [pc, #152]	; (21d980 <TIM_Base_SetConfig+0x130>)
  21d8e6:	4293      	cmp	r3, r2
  21d8e8:	d00b      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8ea:	687b      	ldr	r3, [r7, #4]
  21d8ec:	4a25      	ldr	r2, [pc, #148]	; (21d984 <TIM_Base_SetConfig+0x134>)
  21d8ee:	4293      	cmp	r3, r2
  21d8f0:	d007      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8f2:	687b      	ldr	r3, [r7, #4]
  21d8f4:	4a24      	ldr	r2, [pc, #144]	; (21d988 <TIM_Base_SetConfig+0x138>)
  21d8f6:	4293      	cmp	r3, r2
  21d8f8:	d003      	beq.n	21d902 <TIM_Base_SetConfig+0xb2>
  21d8fa:	687b      	ldr	r3, [r7, #4]
  21d8fc:	4a23      	ldr	r2, [pc, #140]	; (21d98c <TIM_Base_SetConfig+0x13c>)
  21d8fe:	4293      	cmp	r3, r2
  21d900:	d108      	bne.n	21d914 <TIM_Base_SetConfig+0xc4>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
  21d902:	68fb      	ldr	r3, [r7, #12]
  21d904:	f423 7340 	bic.w	r3, r3, #768	; 0x300
  21d908:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  21d90a:	683b      	ldr	r3, [r7, #0]
  21d90c:	68db      	ldr	r3, [r3, #12]
  21d90e:	68fa      	ldr	r2, [r7, #12]
  21d910:	4313      	orrs	r3, r2
  21d912:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
  21d914:	68fb      	ldr	r3, [r7, #12]
  21d916:	f023 0280 	bic.w	r2, r3, #128	; 0x80
  21d91a:	683b      	ldr	r3, [r7, #0]
  21d91c:	695b      	ldr	r3, [r3, #20]
  21d91e:	4313      	orrs	r3, r2
  21d920:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
  21d922:	687b      	ldr	r3, [r7, #4]
  21d924:	68fa      	ldr	r2, [r7, #12]
  21d926:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
  21d928:	683b      	ldr	r3, [r7, #0]
  21d92a:	689a      	ldr	r2, [r3, #8]
  21d92c:	687b      	ldr	r3, [r7, #4]
  21d92e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
  21d930:	683b      	ldr	r3, [r7, #0]
  21d932:	681a      	ldr	r2, [r3, #0]
  21d934:	687b      	ldr	r3, [r7, #4]
  21d936:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
  21d938:	687b      	ldr	r3, [r7, #4]
  21d93a:	4a0a      	ldr	r2, [pc, #40]	; (21d964 <TIM_Base_SetConfig+0x114>)
  21d93c:	4293      	cmp	r3, r2
  21d93e:	d003      	beq.n	21d948 <TIM_Base_SetConfig+0xf8>
  21d940:	687b      	ldr	r3, [r7, #4]
  21d942:	4a0c      	ldr	r2, [pc, #48]	; (21d974 <TIM_Base_SetConfig+0x124>)
  21d944:	4293      	cmp	r3, r2
  21d946:	d103      	bne.n	21d950 <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
  21d948:	683b      	ldr	r3, [r7, #0]
  21d94a:	691a      	ldr	r2, [r3, #16]
  21d94c:	687b      	ldr	r3, [r7, #4]
  21d94e:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
  21d950:	687b      	ldr	r3, [r7, #4]
  21d952:	2201      	movs	r2, #1
  21d954:	615a      	str	r2, [r3, #20]
}
  21d956:	bf00      	nop
  21d958:	3714      	adds	r7, #20
  21d95a:	46bd      	mov	sp, r7
  21d95c:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d960:	4770      	bx	lr
  21d962:	bf00      	nop
  21d964:	40010000 	.word	0x40010000
  21d968:	40000400 	.word	0x40000400
  21d96c:	40000800 	.word	0x40000800
  21d970:	40000c00 	.word	0x40000c00
  21d974:	40010400 	.word	0x40010400
  21d978:	40014000 	.word	0x40014000
  21d97c:	40014400 	.word	0x40014400
  21d980:	40014800 	.word	0x40014800
  21d984:	40001800 	.word	0x40001800
  21d988:	40001c00 	.word	0x40001c00
  21d98c:	40002000 	.word	0x40002000

0021d990 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
  21d990:	b480      	push	{r7}
  21d992:	b087      	sub	sp, #28
  21d994:	af00      	add	r7, sp, #0
  21d996:	60f8      	str	r0, [r7, #12]
  21d998:	60b9      	str	r1, [r7, #8]
  21d99a:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
  21d99c:	68fb      	ldr	r3, [r7, #12]
  21d99e:	6a1b      	ldr	r3, [r3, #32]
  21d9a0:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
  21d9a2:	68fb      	ldr	r3, [r7, #12]
  21d9a4:	6a1b      	ldr	r3, [r3, #32]
  21d9a6:	f023 0201 	bic.w	r2, r3, #1
  21d9aa:	68fb      	ldr	r3, [r7, #12]
  21d9ac:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
  21d9ae:	68fb      	ldr	r3, [r7, #12]
  21d9b0:	699b      	ldr	r3, [r3, #24]
  21d9b2:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
  21d9b4:	693b      	ldr	r3, [r7, #16]
  21d9b6:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
  21d9ba:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
  21d9bc:	687b      	ldr	r3, [r7, #4]
  21d9be:	011b      	lsls	r3, r3, #4
  21d9c0:	693a      	ldr	r2, [r7, #16]
  21d9c2:	4313      	orrs	r3, r2
  21d9c4:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
  21d9c6:	697b      	ldr	r3, [r7, #20]
  21d9c8:	f023 030a 	bic.w	r3, r3, #10
  21d9cc:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
  21d9ce:	697a      	ldr	r2, [r7, #20]
  21d9d0:	68bb      	ldr	r3, [r7, #8]
  21d9d2:	4313      	orrs	r3, r2
  21d9d4:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
  21d9d6:	68fb      	ldr	r3, [r7, #12]
  21d9d8:	693a      	ldr	r2, [r7, #16]
  21d9da:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
  21d9dc:	68fb      	ldr	r3, [r7, #12]
  21d9de:	697a      	ldr	r2, [r7, #20]
  21d9e0:	621a      	str	r2, [r3, #32]
}
  21d9e2:	bf00      	nop
  21d9e4:	371c      	adds	r7, #28
  21d9e6:	46bd      	mov	sp, r7
  21d9e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  21d9ec:	4770      	bx	lr

0021d9ee <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
  21d9ee:	b480      	push	{r7}
  21d9f0:	b087      	sub	sp, #28
  21d9f2:	af00      	add	r7, sp, #0
  21d9f4:	60f8      	str	r0, [r7, #12]
  21d9f6:	60b9      	str	r1, [r7, #8]
  21d9f8:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
  21d9fa:	68fb      	ldr	r3, [r7, #12]
  21d9fc:	6a1b      	ldr	r3, [r3, #32]
  21d9fe:	f023 0210 	bic.w	r2, r3, #16
  21da02:	68fb      	ldr	r3, [r7, #12]
  21da04:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
  21da06:	68fb      	ldr	r3, [r7, #12]
  21da08:	699b      	ldr	r3, [r3, #24]
  21da0a:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
  21da0c:	68fb      	ldr	r3, [r7, #12]
  21da0e:	6a1b      	ldr	r3, [r3, #32]
  21da10:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
  21da12:	697b      	ldr	r3, [r7, #20]
  21da14:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
  21da18:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
  21da1a:	687b      	ldr	r3, [r7, #4]
  21da1c:	031b      	lsls	r3, r3, #12
  21da1e:	697a      	ldr	r2, [r7, #20]
  21da20:	4313      	orrs	r3, r2
  21da22:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
  21da24:	693b      	ldr	r3, [r7, #16]
  21da26:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
  21da2a:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
  21da2c:	68bb      	ldr	r3, [r7, #8]
  21da2e:	011b      	lsls	r3, r3, #4
  21da30:	693a      	ldr	r2, [r7, #16]
  21da32:	4313      	orrs	r3, r2
  21da34:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
  21da36:	68fb      	ldr	r3, [r7, #12]
  21da38:	697a      	ldr	r2, [r7, #20]
  21da3a:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
  21da3c:	68fb      	ldr	r3, [r7, #12]
  21da3e:	693a      	ldr	r2, [r7, #16]
  21da40:	621a      	str	r2, [r3, #32]
}
  21da42:	bf00      	nop
  21da44:	371c      	adds	r7, #28
  21da46:	46bd      	mov	sp, r7
  21da48:	f85d 7b04 	ldr.w	r7, [sp], #4
  21da4c:	4770      	bx	lr

0021da4e <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
  21da4e:	b480      	push	{r7}
  21da50:	b085      	sub	sp, #20
  21da52:	af00      	add	r7, sp, #0
  21da54:	6078      	str	r0, [r7, #4]
  21da56:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
  21da58:	687b      	ldr	r3, [r7, #4]
  21da5a:	689b      	ldr	r3, [r3, #8]
  21da5c:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
  21da5e:	68fb      	ldr	r3, [r7, #12]
  21da60:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  21da64:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
  21da66:	683a      	ldr	r2, [r7, #0]
  21da68:	68fb      	ldr	r3, [r7, #12]
  21da6a:	4313      	orrs	r3, r2
  21da6c:	f043 0307 	orr.w	r3, r3, #7
  21da70:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
  21da72:	687b      	ldr	r3, [r7, #4]
  21da74:	68fa      	ldr	r2, [r7, #12]
  21da76:	609a      	str	r2, [r3, #8]
}
  21da78:	bf00      	nop
  21da7a:	3714      	adds	r7, #20
  21da7c:	46bd      	mov	sp, r7
  21da7e:	f85d 7b04 	ldr.w	r7, [sp], #4
  21da82:	4770      	bx	lr

0021da84 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
  21da84:	b480      	push	{r7}
  21da86:	b087      	sub	sp, #28
  21da88:	af00      	add	r7, sp, #0
  21da8a:	60f8      	str	r0, [r7, #12]
  21da8c:	60b9      	str	r1, [r7, #8]
  21da8e:	607a      	str	r2, [r7, #4]
  21da90:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
  21da92:	68fb      	ldr	r3, [r7, #12]
  21da94:	689b      	ldr	r3, [r3, #8]
  21da96:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
  21da98:	697b      	ldr	r3, [r7, #20]
  21da9a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
  21da9e:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
  21daa0:	683b      	ldr	r3, [r7, #0]
  21daa2:	021a      	lsls	r2, r3, #8
  21daa4:	687b      	ldr	r3, [r7, #4]
  21daa6:	431a      	orrs	r2, r3
  21daa8:	68bb      	ldr	r3, [r7, #8]
  21daaa:	4313      	orrs	r3, r2
  21daac:	697a      	ldr	r2, [r7, #20]
  21daae:	4313      	orrs	r3, r2
  21dab0:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
  21dab2:	68fb      	ldr	r3, [r7, #12]
  21dab4:	697a      	ldr	r2, [r7, #20]
  21dab6:	609a      	str	r2, [r3, #8]
}
  21dab8:	bf00      	nop
  21daba:	371c      	adds	r7, #28
  21dabc:	46bd      	mov	sp, r7
  21dabe:	f85d 7b04 	ldr.w	r7, [sp], #4
  21dac2:	4770      	bx	lr

0021dac4 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
  21dac4:	b480      	push	{r7}
  21dac6:	b085      	sub	sp, #20
  21dac8:	af00      	add	r7, sp, #0
  21daca:	6078      	str	r0, [r7, #4]
  21dacc:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
  21dace:	687b      	ldr	r3, [r7, #4]
  21dad0:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
  21dad4:	2b01      	cmp	r3, #1
  21dad6:	d101      	bne.n	21dadc <HAL_TIMEx_MasterConfigSynchronization+0x18>
  21dad8:	2302      	movs	r3, #2
  21dada:	e06d      	b.n	21dbb8 <HAL_TIMEx_MasterConfigSynchronization+0xf4>
  21dadc:	687b      	ldr	r3, [r7, #4]
  21dade:	2201      	movs	r2, #1
  21dae0:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
  21dae4:	687b      	ldr	r3, [r7, #4]
  21dae6:	2202      	movs	r2, #2
  21dae8:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
  21daec:	687b      	ldr	r3, [r7, #4]
  21daee:	681b      	ldr	r3, [r3, #0]
  21daf0:	685b      	ldr	r3, [r3, #4]
  21daf2:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
  21daf4:	687b      	ldr	r3, [r7, #4]
  21daf6:	681b      	ldr	r3, [r3, #0]
  21daf8:	689b      	ldr	r3, [r3, #8]
  21dafa:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
  21dafc:	687b      	ldr	r3, [r7, #4]
  21dafe:	681b      	ldr	r3, [r3, #0]
  21db00:	4a30      	ldr	r2, [pc, #192]	; (21dbc4 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
  21db02:	4293      	cmp	r3, r2
  21db04:	d004      	beq.n	21db10 <HAL_TIMEx_MasterConfigSynchronization+0x4c>
  21db06:	687b      	ldr	r3, [r7, #4]
  21db08:	681b      	ldr	r3, [r3, #0]
  21db0a:	4a2f      	ldr	r2, [pc, #188]	; (21dbc8 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
  21db0c:	4293      	cmp	r3, r2
  21db0e:	d108      	bne.n	21db22 <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
  21db10:	68fb      	ldr	r3, [r7, #12]
  21db12:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
  21db16:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
  21db18:	683b      	ldr	r3, [r7, #0]
  21db1a:	685b      	ldr	r3, [r3, #4]
  21db1c:	68fa      	ldr	r2, [r7, #12]
  21db1e:	4313      	orrs	r3, r2
  21db20:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  21db22:	68fb      	ldr	r3, [r7, #12]
  21db24:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  21db28:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
  21db2a:	683b      	ldr	r3, [r7, #0]
  21db2c:	681b      	ldr	r3, [r3, #0]
  21db2e:	68fa      	ldr	r2, [r7, #12]
  21db30:	4313      	orrs	r3, r2
  21db32:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
  21db34:	687b      	ldr	r3, [r7, #4]
  21db36:	681b      	ldr	r3, [r3, #0]
  21db38:	68fa      	ldr	r2, [r7, #12]
  21db3a:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
  21db3c:	687b      	ldr	r3, [r7, #4]
  21db3e:	681b      	ldr	r3, [r3, #0]
  21db40:	4a20      	ldr	r2, [pc, #128]	; (21dbc4 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
  21db42:	4293      	cmp	r3, r2
  21db44:	d022      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db46:	687b      	ldr	r3, [r7, #4]
  21db48:	681b      	ldr	r3, [r3, #0]
  21db4a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  21db4e:	d01d      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db50:	687b      	ldr	r3, [r7, #4]
  21db52:	681b      	ldr	r3, [r3, #0]
  21db54:	4a1d      	ldr	r2, [pc, #116]	; (21dbcc <HAL_TIMEx_MasterConfigSynchronization+0x108>)
  21db56:	4293      	cmp	r3, r2
  21db58:	d018      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db5a:	687b      	ldr	r3, [r7, #4]
  21db5c:	681b      	ldr	r3, [r3, #0]
  21db5e:	4a1c      	ldr	r2, [pc, #112]	; (21dbd0 <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
  21db60:	4293      	cmp	r3, r2
  21db62:	d013      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db64:	687b      	ldr	r3, [r7, #4]
  21db66:	681b      	ldr	r3, [r3, #0]
  21db68:	4a1a      	ldr	r2, [pc, #104]	; (21dbd4 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
  21db6a:	4293      	cmp	r3, r2
  21db6c:	d00e      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db6e:	687b      	ldr	r3, [r7, #4]
  21db70:	681b      	ldr	r3, [r3, #0]
  21db72:	4a15      	ldr	r2, [pc, #84]	; (21dbc8 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
  21db74:	4293      	cmp	r3, r2
  21db76:	d009      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db78:	687b      	ldr	r3, [r7, #4]
  21db7a:	681b      	ldr	r3, [r3, #0]
  21db7c:	4a16      	ldr	r2, [pc, #88]	; (21dbd8 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
  21db7e:	4293      	cmp	r3, r2
  21db80:	d004      	beq.n	21db8c <HAL_TIMEx_MasterConfigSynchronization+0xc8>
  21db82:	687b      	ldr	r3, [r7, #4]
  21db84:	681b      	ldr	r3, [r3, #0]
  21db86:	4a15      	ldr	r2, [pc, #84]	; (21dbdc <HAL_TIMEx_MasterConfigSynchronization+0x118>)
  21db88:	4293      	cmp	r3, r2
  21db8a:	d10c      	bne.n	21dba6 <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
  21db8c:	68bb      	ldr	r3, [r7, #8]
  21db8e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
  21db92:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
  21db94:	683b      	ldr	r3, [r7, #0]
  21db96:	689b      	ldr	r3, [r3, #8]
  21db98:	68ba      	ldr	r2, [r7, #8]
  21db9a:	4313      	orrs	r3, r2
  21db9c:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
  21db9e:	687b      	ldr	r3, [r7, #4]
  21dba0:	681b      	ldr	r3, [r3, #0]
  21dba2:	68ba      	ldr	r2, [r7, #8]
  21dba4:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
  21dba6:	687b      	ldr	r3, [r7, #4]
  21dba8:	2201      	movs	r2, #1
  21dbaa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
  21dbae:	687b      	ldr	r3, [r7, #4]
  21dbb0:	2200      	movs	r2, #0
  21dbb2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
  21dbb6:	2300      	movs	r3, #0
}
  21dbb8:	4618      	mov	r0, r3
  21dbba:	3714      	adds	r7, #20
  21dbbc:	46bd      	mov	sp, r7
  21dbbe:	f85d 7b04 	ldr.w	r7, [sp], #4
  21dbc2:	4770      	bx	lr
  21dbc4:	40010000 	.word	0x40010000
  21dbc8:	40010400 	.word	0x40010400
  21dbcc:	40000400 	.word	0x40000400
  21dbd0:	40000800 	.word	0x40000800
  21dbd4:	40000c00 	.word	0x40000c00
  21dbd8:	40014000 	.word	0x40014000
  21dbdc:	40001800 	.word	0x40001800

0021dbe0 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
  21dbe0:	b480      	push	{r7}
  21dbe2:	b083      	sub	sp, #12
  21dbe4:	af00      	add	r7, sp, #0
  21dbe6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
  21dbe8:	bf00      	nop
  21dbea:	370c      	adds	r7, #12
  21dbec:	46bd      	mov	sp, r7
  21dbee:	f85d 7b04 	ldr.w	r7, [sp], #4
  21dbf2:	4770      	bx	lr

0021dbf4 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
  21dbf4:	b480      	push	{r7}
  21dbf6:	b083      	sub	sp, #12
  21dbf8:	af00      	add	r7, sp, #0
  21dbfa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
  21dbfc:	bf00      	nop
  21dbfe:	370c      	adds	r7, #12
  21dc00:	46bd      	mov	sp, r7
  21dc02:	f85d 7b04 	ldr.w	r7, [sp], #4
  21dc06:	4770      	bx	lr

0021dc08 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
  21dc08:	b480      	push	{r7}
  21dc0a:	b083      	sub	sp, #12
  21dc0c:	af00      	add	r7, sp, #0
  21dc0e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
  21dc10:	bf00      	nop
  21dc12:	370c      	adds	r7, #12
  21dc14:	46bd      	mov	sp, r7
  21dc16:	f85d 7b04 	ldr.w	r7, [sp], #4
  21dc1a:	4770      	bx	lr

0021dc1c <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  21dc1c:	b580      	push	{r7, lr}
  21dc1e:	b082      	sub	sp, #8
  21dc20:	af00      	add	r7, sp, #0
  21dc22:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
  21dc24:	687b      	ldr	r3, [r7, #4]
  21dc26:	2b00      	cmp	r3, #0
  21dc28:	d101      	bne.n	21dc2e <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
  21dc2a:	2301      	movs	r3, #1
  21dc2c:	e040      	b.n	21dcb0 <HAL_UART_Init+0x94>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
  21dc2e:	687b      	ldr	r3, [r7, #4]
  21dc30:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  21dc32:	2b00      	cmp	r3, #0
  21dc34:	d106      	bne.n	21dc44 <HAL_UART_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
  21dc36:	687b      	ldr	r3, [r7, #4]
  21dc38:	2200      	movs	r2, #0
  21dc3a:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
  21dc3e:	6878      	ldr	r0, [r7, #4]
  21dc40:	f7fa ffa4 	bl	218b8c <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
  21dc44:	687b      	ldr	r3, [r7, #4]
  21dc46:	2224      	movs	r2, #36	; 0x24
  21dc48:	679a      	str	r2, [r3, #120]	; 0x78

  __HAL_UART_DISABLE(huart);
  21dc4a:	687b      	ldr	r3, [r7, #4]
  21dc4c:	681b      	ldr	r3, [r3, #0]
  21dc4e:	687a      	ldr	r2, [r7, #4]
  21dc50:	6812      	ldr	r2, [r2, #0]
  21dc52:	6812      	ldr	r2, [r2, #0]
  21dc54:	f022 0201 	bic.w	r2, r2, #1
  21dc58:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
  21dc5a:	6878      	ldr	r0, [r7, #4]
  21dc5c:	f000 fb88 	bl	21e370 <UART_SetConfig>
  21dc60:	4603      	mov	r3, r0
  21dc62:	2b01      	cmp	r3, #1
  21dc64:	d101      	bne.n	21dc6a <HAL_UART_Init+0x4e>
  {
    return HAL_ERROR;
  21dc66:	2301      	movs	r3, #1
  21dc68:	e022      	b.n	21dcb0 <HAL_UART_Init+0x94>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
  21dc6a:	687b      	ldr	r3, [r7, #4]
  21dc6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21dc6e:	2b00      	cmp	r3, #0
  21dc70:	d002      	beq.n	21dc78 <HAL_UART_Init+0x5c>
  {
    UART_AdvFeatureConfig(huart);
  21dc72:	6878      	ldr	r0, [r7, #4]
  21dc74:	f000 fddc 	bl	21e830 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
  21dc78:	687b      	ldr	r3, [r7, #4]
  21dc7a:	681b      	ldr	r3, [r3, #0]
  21dc7c:	687a      	ldr	r2, [r7, #4]
  21dc7e:	6812      	ldr	r2, [r2, #0]
  21dc80:	6852      	ldr	r2, [r2, #4]
  21dc82:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
  21dc86:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
  21dc88:	687b      	ldr	r3, [r7, #4]
  21dc8a:	681b      	ldr	r3, [r3, #0]
  21dc8c:	687a      	ldr	r2, [r7, #4]
  21dc8e:	6812      	ldr	r2, [r2, #0]
  21dc90:	6892      	ldr	r2, [r2, #8]
  21dc92:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
  21dc96:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
  21dc98:	687b      	ldr	r3, [r7, #4]
  21dc9a:	681b      	ldr	r3, [r3, #0]
  21dc9c:	687a      	ldr	r2, [r7, #4]
  21dc9e:	6812      	ldr	r2, [r2, #0]
  21dca0:	6812      	ldr	r2, [r2, #0]
  21dca2:	f042 0201 	orr.w	r2, r2, #1
  21dca6:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
  21dca8:	6878      	ldr	r0, [r7, #4]
  21dcaa:	f000 fe63 	bl	21e974 <UART_CheckIdleState>
  21dcae:	4603      	mov	r3, r0
}
  21dcb0:	4618      	mov	r0, r3
  21dcb2:	3708      	adds	r7, #8
  21dcb4:	46bd      	mov	sp, r7
  21dcb6:	bd80      	pop	{r7, pc}

0021dcb8 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  21dcb8:	b580      	push	{r7, lr}
  21dcba:	b08a      	sub	sp, #40	; 0x28
  21dcbc:	af02      	add	r7, sp, #8
  21dcbe:	60f8      	str	r0, [r7, #12]
  21dcc0:	60b9      	str	r1, [r7, #8]
  21dcc2:	603b      	str	r3, [r7, #0]
  21dcc4:	4613      	mov	r3, r2
  21dcc6:	80fb      	strh	r3, [r7, #6]
  uint8_t  *pdata8bits;
  uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
  21dcc8:	68fb      	ldr	r3, [r7, #12]
  21dcca:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  21dccc:	2b20      	cmp	r3, #32
  21dcce:	d17f      	bne.n	21ddd0 <HAL_UART_Transmit+0x118>
  {
    if ((pData == NULL) || (Size == 0U))
  21dcd0:	68bb      	ldr	r3, [r7, #8]
  21dcd2:	2b00      	cmp	r3, #0
  21dcd4:	d002      	beq.n	21dcdc <HAL_UART_Transmit+0x24>
  21dcd6:	88fb      	ldrh	r3, [r7, #6]
  21dcd8:	2b00      	cmp	r3, #0
  21dcda:	d101      	bne.n	21dce0 <HAL_UART_Transmit+0x28>
    {
      return  HAL_ERROR;
  21dcdc:	2301      	movs	r3, #1
  21dcde:	e078      	b.n	21ddd2 <HAL_UART_Transmit+0x11a>
    }

    __HAL_LOCK(huart);
  21dce0:	68fb      	ldr	r3, [r7, #12]
  21dce2:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
  21dce6:	2b01      	cmp	r3, #1
  21dce8:	d101      	bne.n	21dcee <HAL_UART_Transmit+0x36>
  21dcea:	2302      	movs	r3, #2
  21dcec:	e071      	b.n	21ddd2 <HAL_UART_Transmit+0x11a>
  21dcee:	68fb      	ldr	r3, [r7, #12]
  21dcf0:	2201      	movs	r2, #1
  21dcf2:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    huart->ErrorCode = HAL_UART_ERROR_NONE;
  21dcf6:	68fb      	ldr	r3, [r7, #12]
  21dcf8:	2200      	movs	r2, #0
  21dcfa:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    huart->gState = HAL_UART_STATE_BUSY_TX;
  21dcfe:	68fb      	ldr	r3, [r7, #12]
  21dd00:	2221      	movs	r2, #33	; 0x21
  21dd02:	679a      	str	r2, [r3, #120]	; 0x78

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
  21dd04:	f7fb f894 	bl	218e30 <HAL_GetTick>
  21dd08:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
  21dd0a:	68fb      	ldr	r3, [r7, #12]
  21dd0c:	88fa      	ldrh	r2, [r7, #6]
  21dd0e:	f8a3 2050 	strh.w	r2, [r3, #80]	; 0x50
    huart->TxXferCount = Size;
  21dd12:	68fb      	ldr	r3, [r7, #12]
  21dd14:	88fa      	ldrh	r2, [r7, #6]
  21dd16:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
  21dd1a:	68fb      	ldr	r3, [r7, #12]
  21dd1c:	689b      	ldr	r3, [r3, #8]
  21dd1e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  21dd22:	d108      	bne.n	21dd36 <HAL_UART_Transmit+0x7e>
  21dd24:	68fb      	ldr	r3, [r7, #12]
  21dd26:	691b      	ldr	r3, [r3, #16]
  21dd28:	2b00      	cmp	r3, #0
  21dd2a:	d104      	bne.n	21dd36 <HAL_UART_Transmit+0x7e>
    {
      pdata8bits  = NULL;
  21dd2c:	2300      	movs	r3, #0
  21dd2e:	61fb      	str	r3, [r7, #28]
      pdata16bits = (uint16_t *) pData;
  21dd30:	68bb      	ldr	r3, [r7, #8]
  21dd32:	61bb      	str	r3, [r7, #24]
  21dd34:	e003      	b.n	21dd3e <HAL_UART_Transmit+0x86>
    }
    else
    {
      pdata8bits  = pData;
  21dd36:	68bb      	ldr	r3, [r7, #8]
  21dd38:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
  21dd3a:	2300      	movs	r3, #0
  21dd3c:	61bb      	str	r3, [r7, #24]
    }

    __HAL_UNLOCK(huart);
  21dd3e:	68fb      	ldr	r3, [r7, #12]
  21dd40:	2200      	movs	r2, #0
  21dd42:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    while (huart->TxXferCount > 0U)
  21dd46:	e02b      	b.n	21dda0 <HAL_UART_Transmit+0xe8>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
  21dd48:	683b      	ldr	r3, [r7, #0]
  21dd4a:	9300      	str	r3, [sp, #0]
  21dd4c:	697b      	ldr	r3, [r7, #20]
  21dd4e:	2200      	movs	r2, #0
  21dd50:	2180      	movs	r1, #128	; 0x80
  21dd52:	68f8      	ldr	r0, [r7, #12]
  21dd54:	f000 fe57 	bl	21ea06 <UART_WaitOnFlagUntilTimeout>
  21dd58:	4603      	mov	r3, r0
  21dd5a:	2b00      	cmp	r3, #0
  21dd5c:	d001      	beq.n	21dd62 <HAL_UART_Transmit+0xaa>
      {
        return HAL_TIMEOUT;
  21dd5e:	2303      	movs	r3, #3
  21dd60:	e037      	b.n	21ddd2 <HAL_UART_Transmit+0x11a>
      }
      if (pdata8bits == NULL)
  21dd62:	69fb      	ldr	r3, [r7, #28]
  21dd64:	2b00      	cmp	r3, #0
  21dd66:	d10a      	bne.n	21dd7e <HAL_UART_Transmit+0xc6>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
  21dd68:	68fb      	ldr	r3, [r7, #12]
  21dd6a:	681b      	ldr	r3, [r3, #0]
  21dd6c:	69ba      	ldr	r2, [r7, #24]
  21dd6e:	8812      	ldrh	r2, [r2, #0]
  21dd70:	f3c2 0208 	ubfx	r2, r2, #0, #9
  21dd74:	629a      	str	r2, [r3, #40]	; 0x28
        pdata16bits++;
  21dd76:	69bb      	ldr	r3, [r7, #24]
  21dd78:	3302      	adds	r3, #2
  21dd7a:	61bb      	str	r3, [r7, #24]
  21dd7c:	e007      	b.n	21dd8e <HAL_UART_Transmit+0xd6>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
  21dd7e:	68fb      	ldr	r3, [r7, #12]
  21dd80:	681b      	ldr	r3, [r3, #0]
  21dd82:	69fa      	ldr	r2, [r7, #28]
  21dd84:	7812      	ldrb	r2, [r2, #0]
  21dd86:	629a      	str	r2, [r3, #40]	; 0x28
        pdata8bits++;
  21dd88:	69fb      	ldr	r3, [r7, #28]
  21dd8a:	3301      	adds	r3, #1
  21dd8c:	61fb      	str	r3, [r7, #28]
      }
      huart->TxXferCount--;
  21dd8e:	68fb      	ldr	r3, [r7, #12]
  21dd90:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
  21dd94:	b29b      	uxth	r3, r3
  21dd96:	3b01      	subs	r3, #1
  21dd98:	b29a      	uxth	r2, r3
  21dd9a:	68fb      	ldr	r3, [r7, #12]
  21dd9c:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    while (huart->TxXferCount > 0U)
  21dda0:	68fb      	ldr	r3, [r7, #12]
  21dda2:	f8b3 3052 	ldrh.w	r3, [r3, #82]	; 0x52
  21dda6:	b29b      	uxth	r3, r3
  21dda8:	2b00      	cmp	r3, #0
  21ddaa:	d1cd      	bne.n	21dd48 <HAL_UART_Transmit+0x90>
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
  21ddac:	683b      	ldr	r3, [r7, #0]
  21ddae:	9300      	str	r3, [sp, #0]
  21ddb0:	697b      	ldr	r3, [r7, #20]
  21ddb2:	2200      	movs	r2, #0
  21ddb4:	2140      	movs	r1, #64	; 0x40
  21ddb6:	68f8      	ldr	r0, [r7, #12]
  21ddb8:	f000 fe25 	bl	21ea06 <UART_WaitOnFlagUntilTimeout>
  21ddbc:	4603      	mov	r3, r0
  21ddbe:	2b00      	cmp	r3, #0
  21ddc0:	d001      	beq.n	21ddc6 <HAL_UART_Transmit+0x10e>
    {
      return HAL_TIMEOUT;
  21ddc2:	2303      	movs	r3, #3
  21ddc4:	e005      	b.n	21ddd2 <HAL_UART_Transmit+0x11a>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
  21ddc6:	68fb      	ldr	r3, [r7, #12]
  21ddc8:	2220      	movs	r2, #32
  21ddca:	679a      	str	r2, [r3, #120]	; 0x78

    return HAL_OK;
  21ddcc:	2300      	movs	r3, #0
  21ddce:	e000      	b.n	21ddd2 <HAL_UART_Transmit+0x11a>
  }
  else
  {
    return HAL_BUSY;
  21ddd0:	2302      	movs	r3, #2
  }
}
  21ddd2:	4618      	mov	r0, r3
  21ddd4:	3720      	adds	r7, #32
  21ddd6:	46bd      	mov	sp, r7
  21ddd8:	bd80      	pop	{r7, pc}

0021ddda <HAL_UART_Receive_DMA>:
  * @param pData Pointer to data buffer (u8 or u16 data elements).
  * @param Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  21ddda:	b580      	push	{r7, lr}
  21dddc:	b084      	sub	sp, #16
  21ddde:	af00      	add	r7, sp, #0
  21dde0:	60f8      	str	r0, [r7, #12]
  21dde2:	60b9      	str	r1, [r7, #8]
  21dde4:	4613      	mov	r3, r2
  21dde6:	80fb      	strh	r3, [r7, #6]
  /* Check that a Rx process is not already ongoing */
  if (huart->RxState == HAL_UART_STATE_READY)
  21dde8:	68fb      	ldr	r3, [r7, #12]
  21ddea:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  21ddec:	2b20      	cmp	r3, #32
  21ddee:	d12c      	bne.n	21de4a <HAL_UART_Receive_DMA+0x70>
  {
    if ((pData == NULL) || (Size == 0U))
  21ddf0:	68bb      	ldr	r3, [r7, #8]
  21ddf2:	2b00      	cmp	r3, #0
  21ddf4:	d002      	beq.n	21ddfc <HAL_UART_Receive_DMA+0x22>
  21ddf6:	88fb      	ldrh	r3, [r7, #6]
  21ddf8:	2b00      	cmp	r3, #0
  21ddfa:	d101      	bne.n	21de00 <HAL_UART_Receive_DMA+0x26>
    {
      return HAL_ERROR;
  21ddfc:	2301      	movs	r3, #1
  21ddfe:	e025      	b.n	21de4c <HAL_UART_Receive_DMA+0x72>
    }

    __HAL_LOCK(huart);
  21de00:	68fb      	ldr	r3, [r7, #12]
  21de02:	f893 3074 	ldrb.w	r3, [r3, #116]	; 0x74
  21de06:	2b01      	cmp	r3, #1
  21de08:	d101      	bne.n	21de0e <HAL_UART_Receive_DMA+0x34>
  21de0a:	2302      	movs	r3, #2
  21de0c:	e01e      	b.n	21de4c <HAL_UART_Receive_DMA+0x72>
  21de0e:	68fb      	ldr	r3, [r7, #12]
  21de10:	2201      	movs	r2, #1
  21de12:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

    /* Set Reception type to Standard reception */
    huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  21de16:	68fb      	ldr	r3, [r7, #12]
  21de18:	2200      	movs	r2, #0
  21de1a:	661a      	str	r2, [r3, #96]	; 0x60

    /* Check that USART RTOEN bit is set */
    if (READ_BIT(huart->Instance->CR2, USART_CR2_RTOEN) != 0U)
  21de1c:	68fb      	ldr	r3, [r7, #12]
  21de1e:	681b      	ldr	r3, [r3, #0]
  21de20:	685b      	ldr	r3, [r3, #4]
  21de22:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  21de26:	2b00      	cmp	r3, #0
  21de28:	d007      	beq.n	21de3a <HAL_UART_Receive_DMA+0x60>
    {
      /* Enable the UART Receiver Timeout Interrupt */
      SET_BIT(huart->Instance->CR1, USART_CR1_RTOIE);
  21de2a:	68fb      	ldr	r3, [r7, #12]
  21de2c:	681b      	ldr	r3, [r3, #0]
  21de2e:	68fa      	ldr	r2, [r7, #12]
  21de30:	6812      	ldr	r2, [r2, #0]
  21de32:	6812      	ldr	r2, [r2, #0]
  21de34:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
  21de38:	601a      	str	r2, [r3, #0]
    }

    return (UART_Start_Receive_DMA(huart, pData, Size));
  21de3a:	88fb      	ldrh	r3, [r7, #6]
  21de3c:	461a      	mov	r2, r3
  21de3e:	68b9      	ldr	r1, [r7, #8]
  21de40:	68f8      	ldr	r0, [r7, #12]
  21de42:	f000 fe5d 	bl	21eb00 <UART_Start_Receive_DMA>
  21de46:	4603      	mov	r3, r0
  21de48:	e000      	b.n	21de4c <HAL_UART_Receive_DMA+0x72>
  }
  else
  {
    return HAL_BUSY;
  21de4a:	2302      	movs	r3, #2
  }
}
  21de4c:	4618      	mov	r0, r3
  21de4e:	3710      	adds	r7, #16
  21de50:	46bd      	mov	sp, r7
  21de52:	bd80      	pop	{r7, pc}

0021de54 <HAL_UART_DMAStop>:
  * @brief Stop the DMA Transfer.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DMAStop(UART_HandleTypeDef *huart)
{
  21de54:	b580      	push	{r7, lr}
  21de56:	b084      	sub	sp, #16
  21de58:	af00      	add	r7, sp, #0
  21de5a:	6078      	str	r0, [r7, #4]
     HAL_UART_TxHalfCpltCallback / HAL_UART_RxHalfCpltCallback:
     indeed, when HAL_DMA_Abort() API is called, the DMA TX/RX Transfer or Half Transfer complete
     interrupt is generated if the DMA transfer interruption occurs at the middle or at the end of
     the stream and the corresponding call back is executed. */

  const HAL_UART_StateTypeDef gstate = huart->gState;
  21de5c:	687b      	ldr	r3, [r7, #4]
  21de5e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  21de60:	60fb      	str	r3, [r7, #12]
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
  21de62:	687b      	ldr	r3, [r7, #4]
  21de64:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  21de66:	60bb      	str	r3, [r7, #8]

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
  21de68:	687b      	ldr	r3, [r7, #4]
  21de6a:	681b      	ldr	r3, [r3, #0]
  21de6c:	689b      	ldr	r3, [r3, #8]
  21de6e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21de72:	2b80      	cmp	r3, #128	; 0x80
  21de74:	d127      	bne.n	21dec6 <HAL_UART_DMAStop+0x72>
  21de76:	68fb      	ldr	r3, [r7, #12]
  21de78:	2b21      	cmp	r3, #33	; 0x21
  21de7a:	d124      	bne.n	21dec6 <HAL_UART_DMAStop+0x72>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAT);
  21de7c:	687b      	ldr	r3, [r7, #4]
  21de7e:	681b      	ldr	r3, [r3, #0]
  21de80:	687a      	ldr	r2, [r7, #4]
  21de82:	6812      	ldr	r2, [r2, #0]
  21de84:	6892      	ldr	r2, [r2, #8]
  21de86:	f022 0280 	bic.w	r2, r2, #128	; 0x80
  21de8a:	609a      	str	r2, [r3, #8]

    /* Abort the UART DMA Tx channel */
    if (huart->hdmatx != NULL)
  21de8c:	687b      	ldr	r3, [r7, #4]
  21de8e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21de90:	2b00      	cmp	r3, #0
  21de92:	d015      	beq.n	21dec0 <HAL_UART_DMAStop+0x6c>
    {
      if (HAL_DMA_Abort(huart->hdmatx) != HAL_OK)
  21de94:	687b      	ldr	r3, [r7, #4]
  21de96:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21de98:	4618      	mov	r0, r3
  21de9a:	f7fb fa5d 	bl	219358 <HAL_DMA_Abort>
  21de9e:	4603      	mov	r3, r0
  21dea0:	2b00      	cmp	r3, #0
  21dea2:	d00d      	beq.n	21dec0 <HAL_UART_DMAStop+0x6c>
      {
        if (HAL_DMA_GetError(huart->hdmatx) == HAL_DMA_ERROR_TIMEOUT)
  21dea4:	687b      	ldr	r3, [r7, #4]
  21dea6:	6edb      	ldr	r3, [r3, #108]	; 0x6c
  21dea8:	4618      	mov	r0, r3
  21deaa:	f7fb fc71 	bl	219790 <HAL_DMA_GetError>
  21deae:	4603      	mov	r3, r0
  21deb0:	2b20      	cmp	r3, #32
  21deb2:	d105      	bne.n	21dec0 <HAL_UART_DMAStop+0x6c>
        {
          /* Set error code to DMA */
          huart->ErrorCode = HAL_UART_ERROR_DMA;
  21deb4:	687b      	ldr	r3, [r7, #4]
  21deb6:	2210      	movs	r2, #16
  21deb8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

          return HAL_TIMEOUT;
  21debc:	2303      	movs	r3, #3
  21debe:	e032      	b.n	21df26 <HAL_UART_DMAStop+0xd2>
        }
      }
    }

    UART_EndTxTransfer(huart);
  21dec0:	6878      	ldr	r0, [r7, #4]
  21dec2:	f000 fe89 	bl	21ebd8 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
  21dec6:	687b      	ldr	r3, [r7, #4]
  21dec8:	681b      	ldr	r3, [r3, #0]
  21deca:	689b      	ldr	r3, [r3, #8]
  21decc:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21ded0:	2b40      	cmp	r3, #64	; 0x40
  21ded2:	d127      	bne.n	21df24 <HAL_UART_DMAStop+0xd0>
  21ded4:	68bb      	ldr	r3, [r7, #8]
  21ded6:	2b22      	cmp	r3, #34	; 0x22
  21ded8:	d124      	bne.n	21df24 <HAL_UART_DMAStop+0xd0>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  21deda:	687b      	ldr	r3, [r7, #4]
  21dedc:	681b      	ldr	r3, [r3, #0]
  21dede:	687a      	ldr	r2, [r7, #4]
  21dee0:	6812      	ldr	r2, [r2, #0]
  21dee2:	6892      	ldr	r2, [r2, #8]
  21dee4:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  21dee8:	609a      	str	r2, [r3, #8]

    /* Abort the UART DMA Rx channel */
    if (huart->hdmarx != NULL)
  21deea:	687b      	ldr	r3, [r7, #4]
  21deec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21deee:	2b00      	cmp	r3, #0
  21def0:	d015      	beq.n	21df1e <HAL_UART_DMAStop+0xca>
    {
      if (HAL_DMA_Abort(huart->hdmarx) != HAL_OK)
  21def2:	687b      	ldr	r3, [r7, #4]
  21def4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21def6:	4618      	mov	r0, r3
  21def8:	f7fb fa2e 	bl	219358 <HAL_DMA_Abort>
  21defc:	4603      	mov	r3, r0
  21defe:	2b00      	cmp	r3, #0
  21df00:	d00d      	beq.n	21df1e <HAL_UART_DMAStop+0xca>
      {
        if (HAL_DMA_GetError(huart->hdmarx) == HAL_DMA_ERROR_TIMEOUT)
  21df02:	687b      	ldr	r3, [r7, #4]
  21df04:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21df06:	4618      	mov	r0, r3
  21df08:	f7fb fc42 	bl	219790 <HAL_DMA_GetError>
  21df0c:	4603      	mov	r3, r0
  21df0e:	2b20      	cmp	r3, #32
  21df10:	d105      	bne.n	21df1e <HAL_UART_DMAStop+0xca>
        {
          /* Set error code to DMA */
          huart->ErrorCode = HAL_UART_ERROR_DMA;
  21df12:	687b      	ldr	r3, [r7, #4]
  21df14:	2210      	movs	r2, #16
  21df16:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

          return HAL_TIMEOUT;
  21df1a:	2303      	movs	r3, #3
  21df1c:	e003      	b.n	21df26 <HAL_UART_DMAStop+0xd2>
        }
      }
    }

    UART_EndRxTransfer(huart);
  21df1e:	6878      	ldr	r0, [r7, #4]
  21df20:	f000 fe6f 	bl	21ec02 <UART_EndRxTransfer>
  }

  return HAL_OK;
  21df24:	2300      	movs	r3, #0
}
  21df26:	4618      	mov	r0, r3
  21df28:	3710      	adds	r7, #16
  21df2a:	46bd      	mov	sp, r7
  21df2c:	bd80      	pop	{r7, pc}
	...

0021df30 <HAL_UART_IRQHandler>:
  * @brief Handle UART interrupt request.
  * @param huart UART handle.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
  21df30:	b580      	push	{r7, lr}
  21df32:	b088      	sub	sp, #32
  21df34:	af00      	add	r7, sp, #0
  21df36:	6078      	str	r0, [r7, #4]
  uint32_t isrflags   = READ_REG(huart->Instance->ISR);
  21df38:	687b      	ldr	r3, [r7, #4]
  21df3a:	681b      	ldr	r3, [r3, #0]
  21df3c:	69db      	ldr	r3, [r3, #28]
  21df3e:	61fb      	str	r3, [r7, #28]
  uint32_t cr1its     = READ_REG(huart->Instance->CR1);
  21df40:	687b      	ldr	r3, [r7, #4]
  21df42:	681b      	ldr	r3, [r3, #0]
  21df44:	681b      	ldr	r3, [r3, #0]
  21df46:	61bb      	str	r3, [r7, #24]
  uint32_t cr3its     = READ_REG(huart->Instance->CR3);
  21df48:	687b      	ldr	r3, [r7, #4]
  21df4a:	681b      	ldr	r3, [r3, #0]
  21df4c:	689b      	ldr	r3, [r3, #8]
  21df4e:	617b      	str	r3, [r7, #20]

  uint32_t errorflags;
  uint32_t errorcode;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE | USART_ISR_RTOF));
  21df50:	69fa      	ldr	r2, [r7, #28]
  21df52:	f640 030f 	movw	r3, #2063	; 0x80f
  21df56:	4013      	ands	r3, r2
  21df58:	613b      	str	r3, [r7, #16]
  if (errorflags == 0U)
  21df5a:	693b      	ldr	r3, [r7, #16]
  21df5c:	2b00      	cmp	r3, #0
  21df5e:	d113      	bne.n	21df88 <HAL_UART_IRQHandler+0x58>
  {
    /* UART in mode Receiver ---------------------------------------------------*/
    if (((isrflags & USART_ISR_RXNE) != 0U)
  21df60:	69fb      	ldr	r3, [r7, #28]
  21df62:	f003 0320 	and.w	r3, r3, #32
  21df66:	2b00      	cmp	r3, #0
  21df68:	d00e      	beq.n	21df88 <HAL_UART_IRQHandler+0x58>
        && ((cr1its & USART_CR1_RXNEIE) != 0U))
  21df6a:	69bb      	ldr	r3, [r7, #24]
  21df6c:	f003 0320 	and.w	r3, r3, #32
  21df70:	2b00      	cmp	r3, #0
  21df72:	d009      	beq.n	21df88 <HAL_UART_IRQHandler+0x58>
    {
      if (huart->RxISR != NULL)
  21df74:	687b      	ldr	r3, [r7, #4]
  21df76:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21df78:	2b00      	cmp	r3, #0
  21df7a:	f000 81cd 	beq.w	21e318 <HAL_UART_IRQHandler+0x3e8>
      {
        huart->RxISR(huart);
  21df7e:	687b      	ldr	r3, [r7, #4]
  21df80:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21df82:	6878      	ldr	r0, [r7, #4]
  21df84:	4798      	blx	r3
      }
      return;
  21df86:	e1c7      	b.n	21e318 <HAL_UART_IRQHandler+0x3e8>
    }
  }

  /* If some errors occur */
  if ((errorflags != 0U)
  21df88:	693b      	ldr	r3, [r7, #16]
  21df8a:	2b00      	cmp	r3, #0
  21df8c:	f000 80e3 	beq.w	21e156 <HAL_UART_IRQHandler+0x226>
      && (((cr3its & USART_CR3_EIE) != 0U)
  21df90:	697b      	ldr	r3, [r7, #20]
  21df92:	f003 0301 	and.w	r3, r3, #1
  21df96:	2b00      	cmp	r3, #0
  21df98:	d105      	bne.n	21dfa6 <HAL_UART_IRQHandler+0x76>
          || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_RTOIE)) != 0U)))
  21df9a:	69ba      	ldr	r2, [r7, #24]
  21df9c:	4ba5      	ldr	r3, [pc, #660]	; (21e234 <HAL_UART_IRQHandler+0x304>)
  21df9e:	4013      	ands	r3, r2
  21dfa0:	2b00      	cmp	r3, #0
  21dfa2:	f000 80d8 	beq.w	21e156 <HAL_UART_IRQHandler+0x226>
  {
    /* UART parity error interrupt occurred -------------------------------------*/
    if (((isrflags & USART_ISR_PE) != 0U) && ((cr1its & USART_CR1_PEIE) != 0U))
  21dfa6:	69fb      	ldr	r3, [r7, #28]
  21dfa8:	f003 0301 	and.w	r3, r3, #1
  21dfac:	2b00      	cmp	r3, #0
  21dfae:	d010      	beq.n	21dfd2 <HAL_UART_IRQHandler+0xa2>
  21dfb0:	69bb      	ldr	r3, [r7, #24]
  21dfb2:	f403 7380 	and.w	r3, r3, #256	; 0x100
  21dfb6:	2b00      	cmp	r3, #0
  21dfb8:	d00b      	beq.n	21dfd2 <HAL_UART_IRQHandler+0xa2>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_PEF);
  21dfba:	687b      	ldr	r3, [r7, #4]
  21dfbc:	681b      	ldr	r3, [r3, #0]
  21dfbe:	2201      	movs	r2, #1
  21dfc0:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_PE;
  21dfc2:	687b      	ldr	r3, [r7, #4]
  21dfc4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21dfc8:	f043 0201 	orr.w	r2, r3, #1
  21dfcc:	687b      	ldr	r3, [r7, #4]
  21dfce:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }

    /* UART frame error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_FE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
  21dfd2:	69fb      	ldr	r3, [r7, #28]
  21dfd4:	f003 0302 	and.w	r3, r3, #2
  21dfd8:	2b00      	cmp	r3, #0
  21dfda:	d010      	beq.n	21dffe <HAL_UART_IRQHandler+0xce>
  21dfdc:	697b      	ldr	r3, [r7, #20]
  21dfde:	f003 0301 	and.w	r3, r3, #1
  21dfe2:	2b00      	cmp	r3, #0
  21dfe4:	d00b      	beq.n	21dffe <HAL_UART_IRQHandler+0xce>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_FEF);
  21dfe6:	687b      	ldr	r3, [r7, #4]
  21dfe8:	681b      	ldr	r3, [r3, #0]
  21dfea:	2202      	movs	r2, #2
  21dfec:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_FE;
  21dfee:	687b      	ldr	r3, [r7, #4]
  21dff0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21dff4:	f043 0204 	orr.w	r2, r3, #4
  21dff8:	687b      	ldr	r3, [r7, #4]
  21dffa:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }

    /* UART noise error interrupt occurred --------------------------------------*/
    if (((isrflags & USART_ISR_NE) != 0U) && ((cr3its & USART_CR3_EIE) != 0U))
  21dffe:	69fb      	ldr	r3, [r7, #28]
  21e000:	f003 0304 	and.w	r3, r3, #4
  21e004:	2b00      	cmp	r3, #0
  21e006:	d010      	beq.n	21e02a <HAL_UART_IRQHandler+0xfa>
  21e008:	697b      	ldr	r3, [r7, #20]
  21e00a:	f003 0301 	and.w	r3, r3, #1
  21e00e:	2b00      	cmp	r3, #0
  21e010:	d00b      	beq.n	21e02a <HAL_UART_IRQHandler+0xfa>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_NEF);
  21e012:	687b      	ldr	r3, [r7, #4]
  21e014:	681b      	ldr	r3, [r3, #0]
  21e016:	2204      	movs	r2, #4
  21e018:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_NE;
  21e01a:	687b      	ldr	r3, [r7, #4]
  21e01c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21e020:	f043 0202 	orr.w	r2, r3, #2
  21e024:	687b      	ldr	r3, [r7, #4]
  21e026:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }

    /* UART Over-Run interrupt occurred -----------------------------------------*/
    if (((isrflags & USART_ISR_ORE) != 0U)
  21e02a:	69fb      	ldr	r3, [r7, #28]
  21e02c:	f003 0308 	and.w	r3, r3, #8
  21e030:	2b00      	cmp	r3, #0
  21e032:	d015      	beq.n	21e060 <HAL_UART_IRQHandler+0x130>
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
  21e034:	69bb      	ldr	r3, [r7, #24]
  21e036:	f003 0320 	and.w	r3, r3, #32
  21e03a:	2b00      	cmp	r3, #0
  21e03c:	d104      	bne.n	21e048 <HAL_UART_IRQHandler+0x118>
            ((cr3its & USART_CR3_EIE) != 0U)))
  21e03e:	697b      	ldr	r3, [r7, #20]
  21e040:	f003 0301 	and.w	r3, r3, #1
        && (((cr1its & USART_CR1_RXNEIE) != 0U) ||
  21e044:	2b00      	cmp	r3, #0
  21e046:	d00b      	beq.n	21e060 <HAL_UART_IRQHandler+0x130>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
  21e048:	687b      	ldr	r3, [r7, #4]
  21e04a:	681b      	ldr	r3, [r3, #0]
  21e04c:	2208      	movs	r2, #8
  21e04e:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_ORE;
  21e050:	687b      	ldr	r3, [r7, #4]
  21e052:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21e056:	f043 0208 	orr.w	r2, r3, #8
  21e05a:	687b      	ldr	r3, [r7, #4]
  21e05c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }

    /* UART Receiver Timeout interrupt occurred ---------------------------------*/
    if (((isrflags & USART_ISR_RTOF) != 0U) && ((cr1its & USART_CR1_RTOIE) != 0U))
  21e060:	69fb      	ldr	r3, [r7, #28]
  21e062:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  21e066:	2b00      	cmp	r3, #0
  21e068:	d011      	beq.n	21e08e <HAL_UART_IRQHandler+0x15e>
  21e06a:	69bb      	ldr	r3, [r7, #24]
  21e06c:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  21e070:	2b00      	cmp	r3, #0
  21e072:	d00c      	beq.n	21e08e <HAL_UART_IRQHandler+0x15e>
    {
      __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
  21e074:	687b      	ldr	r3, [r7, #4]
  21e076:	681b      	ldr	r3, [r3, #0]
  21e078:	f44f 6200 	mov.w	r2, #2048	; 0x800
  21e07c:	621a      	str	r2, [r3, #32]

      huart->ErrorCode |= HAL_UART_ERROR_RTO;
  21e07e:	687b      	ldr	r3, [r7, #4]
  21e080:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21e084:	f043 0220 	orr.w	r2, r3, #32
  21e088:	687b      	ldr	r3, [r7, #4]
  21e08a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    }

    /* Call UART Error Call back function if need be ----------------------------*/
    if (huart->ErrorCode != HAL_UART_ERROR_NONE)
  21e08e:	687b      	ldr	r3, [r7, #4]
  21e090:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21e094:	2b00      	cmp	r3, #0
  21e096:	f000 8141 	beq.w	21e31c <HAL_UART_IRQHandler+0x3ec>
    {
      /* UART in mode Receiver --------------------------------------------------*/
      if (((isrflags & USART_ISR_RXNE) != 0U)
  21e09a:	69fb      	ldr	r3, [r7, #28]
  21e09c:	f003 0320 	and.w	r3, r3, #32
  21e0a0:	2b00      	cmp	r3, #0
  21e0a2:	d00c      	beq.n	21e0be <HAL_UART_IRQHandler+0x18e>
          && ((cr1its & USART_CR1_RXNEIE) != 0U))
  21e0a4:	69bb      	ldr	r3, [r7, #24]
  21e0a6:	f003 0320 	and.w	r3, r3, #32
  21e0aa:	2b00      	cmp	r3, #0
  21e0ac:	d007      	beq.n	21e0be <HAL_UART_IRQHandler+0x18e>
      {
        if (huart->RxISR != NULL)
  21e0ae:	687b      	ldr	r3, [r7, #4]
  21e0b0:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21e0b2:	2b00      	cmp	r3, #0
  21e0b4:	d003      	beq.n	21e0be <HAL_UART_IRQHandler+0x18e>
        {
          huart->RxISR(huart);
  21e0b6:	687b      	ldr	r3, [r7, #4]
  21e0b8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
  21e0ba:	6878      	ldr	r0, [r7, #4]
  21e0bc:	4798      	blx	r3
      /* If Error is to be considered as blocking :
          - Receiver Timeout error in Reception
          - Overrun error in Reception
          - any error occurs in DMA mode reception
      */
      errorcode = huart->ErrorCode;
  21e0be:	687b      	ldr	r3, [r7, #4]
  21e0c0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21e0c4:	60fb      	str	r3, [r7, #12]
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
  21e0c6:	687b      	ldr	r3, [r7, #4]
  21e0c8:	681b      	ldr	r3, [r3, #0]
  21e0ca:	689b      	ldr	r3, [r3, #8]
  21e0cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21e0d0:	2b40      	cmp	r3, #64	; 0x40
  21e0d2:	d004      	beq.n	21e0de <HAL_UART_IRQHandler+0x1ae>
          ((errorcode & (HAL_UART_ERROR_RTO | HAL_UART_ERROR_ORE)) != 0U))
  21e0d4:	68fb      	ldr	r3, [r7, #12]
  21e0d6:	f003 0328 	and.w	r3, r3, #40	; 0x28
      if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) ||
  21e0da:	2b00      	cmp	r3, #0
  21e0dc:	d031      	beq.n	21e142 <HAL_UART_IRQHandler+0x212>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
  21e0de:	6878      	ldr	r0, [r7, #4]
  21e0e0:	f000 fd8f 	bl	21ec02 <UART_EndRxTransfer>

        /* Disable the UART DMA Rx request if enabled */
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  21e0e4:	687b      	ldr	r3, [r7, #4]
  21e0e6:	681b      	ldr	r3, [r3, #0]
  21e0e8:	689b      	ldr	r3, [r3, #8]
  21e0ea:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21e0ee:	2b40      	cmp	r3, #64	; 0x40
  21e0f0:	d123      	bne.n	21e13a <HAL_UART_IRQHandler+0x20a>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  21e0f2:	687b      	ldr	r3, [r7, #4]
  21e0f4:	681b      	ldr	r3, [r3, #0]
  21e0f6:	687a      	ldr	r2, [r7, #4]
  21e0f8:	6812      	ldr	r2, [r2, #0]
  21e0fa:	6892      	ldr	r2, [r2, #8]
  21e0fc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  21e100:	609a      	str	r2, [r3, #8]

          /* Abort the UART DMA Rx channel */
          if (huart->hdmarx != NULL)
  21e102:	687b      	ldr	r3, [r7, #4]
  21e104:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e106:	2b00      	cmp	r3, #0
  21e108:	d013      	beq.n	21e132 <HAL_UART_IRQHandler+0x202>
          {
            /* Set the UART DMA Abort callback :
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
  21e10a:	687b      	ldr	r3, [r7, #4]
  21e10c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e10e:	4a4a      	ldr	r2, [pc, #296]	; (21e238 <HAL_UART_IRQHandler+0x308>)
  21e110:	651a      	str	r2, [r3, #80]	; 0x50

            /* Abort DMA RX */
            if (HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
  21e112:	687b      	ldr	r3, [r7, #4]
  21e114:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e116:	4618      	mov	r0, r3
  21e118:	f7fb f98e 	bl	219438 <HAL_DMA_Abort_IT>
  21e11c:	4603      	mov	r3, r0
  21e11e:	2b00      	cmp	r3, #0
  21e120:	d017      	beq.n	21e152 <HAL_UART_IRQHandler+0x222>
            {
              /* Call Directly huart->hdmarx->XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
  21e122:	687b      	ldr	r3, [r7, #4]
  21e124:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e126:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  21e128:	687a      	ldr	r2, [r7, #4]
  21e12a:	6f12      	ldr	r2, [r2, #112]	; 0x70
  21e12c:	4610      	mov	r0, r2
  21e12e:	4798      	blx	r3
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  21e130:	e00f      	b.n	21e152 <HAL_UART_IRQHandler+0x222>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
            /*Call registered error callback*/
            huart->ErrorCallback(huart);
#else
            /*Call legacy weak error callback*/
            HAL_UART_ErrorCallback(huart);
  21e132:	6878      	ldr	r0, [r7, #4]
  21e134:	f7fa fdf8 	bl	218d28 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  21e138:	e00b      	b.n	21e152 <HAL_UART_IRQHandler+0x222>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
          /*Call registered error callback*/
          huart->ErrorCallback(huart);
#else
          /*Call legacy weak error callback*/
          HAL_UART_ErrorCallback(huart);
  21e13a:	6878      	ldr	r0, [r7, #4]
  21e13c:	f7fa fdf4 	bl	218d28 <HAL_UART_ErrorCallback>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  21e140:	e007      	b.n	21e152 <HAL_UART_IRQHandler+0x222>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered error callback*/
        huart->ErrorCallback(huart);
#else
        /*Call legacy weak error callback*/
        HAL_UART_ErrorCallback(huart);
  21e142:	6878      	ldr	r0, [r7, #4]
  21e144:	f7fa fdf0 	bl	218d28 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
        huart->ErrorCode = HAL_UART_ERROR_NONE;
  21e148:	687b      	ldr	r3, [r7, #4]
  21e14a:	2200      	movs	r2, #0
  21e14c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      }
    }
    return;
  21e150:	e0e4      	b.n	21e31c <HAL_UART_IRQHandler+0x3ec>
        if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  21e152:	bf00      	nop
    return;
  21e154:	e0e2      	b.n	21e31c <HAL_UART_IRQHandler+0x3ec>

  } /* End if some error occurs */

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : */
  if ((huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  21e156:	687b      	ldr	r3, [r7, #4]
  21e158:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  21e15a:	2b01      	cmp	r3, #1
  21e15c:	f040 80a7 	bne.w	21e2ae <HAL_UART_IRQHandler+0x37e>
      && ((isrflags & USART_ISR_IDLE) != 0U)
  21e160:	69fb      	ldr	r3, [r7, #28]
  21e162:	f003 0310 	and.w	r3, r3, #16
  21e166:	2b00      	cmp	r3, #0
  21e168:	f000 80a1 	beq.w	21e2ae <HAL_UART_IRQHandler+0x37e>
      && ((cr1its & USART_ISR_IDLE) != 0U))
  21e16c:	69bb      	ldr	r3, [r7, #24]
  21e16e:	f003 0310 	and.w	r3, r3, #16
  21e172:	2b00      	cmp	r3, #0
  21e174:	f000 809b 	beq.w	21e2ae <HAL_UART_IRQHandler+0x37e>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_IDLEF);
  21e178:	687b      	ldr	r3, [r7, #4]
  21e17a:	681b      	ldr	r3, [r3, #0]
  21e17c:	2210      	movs	r2, #16
  21e17e:	621a      	str	r2, [r3, #32]

    /* Check if DMA mode is enabled in UART */
    if (HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
  21e180:	687b      	ldr	r3, [r7, #4]
  21e182:	681b      	ldr	r3, [r3, #0]
  21e184:	689b      	ldr	r3, [r3, #8]
  21e186:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21e18a:	2b40      	cmp	r3, #64	; 0x40
  21e18c:	d156      	bne.n	21e23c <HAL_UART_IRQHandler+0x30c>
    {
      /* DMA mode enabled */
      /* Check received length : If all expected data are received, do nothing,
         (DMA cplt callback will be called).
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_remaining_rx_data = (uint16_t) __HAL_DMA_GET_COUNTER(huart->hdmarx);
  21e18e:	687b      	ldr	r3, [r7, #4]
  21e190:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e192:	681b      	ldr	r3, [r3, #0]
  21e194:	685b      	ldr	r3, [r3, #4]
  21e196:	817b      	strh	r3, [r7, #10]
      if ((nb_remaining_rx_data > 0U)
  21e198:	897b      	ldrh	r3, [r7, #10]
  21e19a:	2b00      	cmp	r3, #0
  21e19c:	f000 80c0 	beq.w	21e320 <HAL_UART_IRQHandler+0x3f0>
          && (nb_remaining_rx_data < huart->RxXferSize))
  21e1a0:	687b      	ldr	r3, [r7, #4]
  21e1a2:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
  21e1a6:	897a      	ldrh	r2, [r7, #10]
  21e1a8:	429a      	cmp	r2, r3
  21e1aa:	f080 80b9 	bcs.w	21e320 <HAL_UART_IRQHandler+0x3f0>
      {
        /* Reception is not complete */
        huart->RxXferCount = nb_remaining_rx_data;
  21e1ae:	687b      	ldr	r3, [r7, #4]
  21e1b0:	897a      	ldrh	r2, [r7, #10]
  21e1b2:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a

        /* In Normal mode, end DMA xfer and HAL UART Rx process*/
        if (huart->hdmarx->Init.Mode != DMA_CIRCULAR)
  21e1b6:	687b      	ldr	r3, [r7, #4]
  21e1b8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e1ba:	69db      	ldr	r3, [r3, #28]
  21e1bc:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  21e1c0:	d02a      	beq.n	21e218 <HAL_UART_IRQHandler+0x2e8>
        {
          /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
          CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  21e1c2:	687b      	ldr	r3, [r7, #4]
  21e1c4:	681b      	ldr	r3, [r3, #0]
  21e1c6:	687a      	ldr	r2, [r7, #4]
  21e1c8:	6812      	ldr	r2, [r2, #0]
  21e1ca:	6812      	ldr	r2, [r2, #0]
  21e1cc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  21e1d0:	601a      	str	r2, [r3, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21e1d2:	687b      	ldr	r3, [r7, #4]
  21e1d4:	681b      	ldr	r3, [r3, #0]
  21e1d6:	687a      	ldr	r2, [r7, #4]
  21e1d8:	6812      	ldr	r2, [r2, #0]
  21e1da:	6892      	ldr	r2, [r2, #8]
  21e1dc:	f022 0201 	bic.w	r2, r2, #1
  21e1e0:	609a      	str	r2, [r3, #8]

          /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
             in the UART CR3 register */
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  21e1e2:	687b      	ldr	r3, [r7, #4]
  21e1e4:	681b      	ldr	r3, [r3, #0]
  21e1e6:	687a      	ldr	r2, [r7, #4]
  21e1e8:	6812      	ldr	r2, [r2, #0]
  21e1ea:	6892      	ldr	r2, [r2, #8]
  21e1ec:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  21e1f0:	609a      	str	r2, [r3, #8]

          /* At end of Rx process, restore huart->RxState to Ready */
          huart->RxState = HAL_UART_STATE_READY;
  21e1f2:	687b      	ldr	r3, [r7, #4]
  21e1f4:	2220      	movs	r2, #32
  21e1f6:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  21e1f8:	687b      	ldr	r3, [r7, #4]
  21e1fa:	2200      	movs	r2, #0
  21e1fc:	661a      	str	r2, [r3, #96]	; 0x60

          CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  21e1fe:	687b      	ldr	r3, [r7, #4]
  21e200:	681b      	ldr	r3, [r3, #0]
  21e202:	687a      	ldr	r2, [r7, #4]
  21e204:	6812      	ldr	r2, [r2, #0]
  21e206:	6812      	ldr	r2, [r2, #0]
  21e208:	f022 0210 	bic.w	r2, r2, #16
  21e20c:	601a      	str	r2, [r3, #0]

          /* Last bytes received, so no need as the abort is immediate */
          (void)HAL_DMA_Abort(huart->hdmarx);
  21e20e:	687b      	ldr	r3, [r7, #4]
  21e210:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21e212:	4618      	mov	r0, r3
  21e214:	f7fb f8a0 	bl	219358 <HAL_DMA_Abort>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx Event callback*/
        huart->RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, (huart->RxXferSize - huart->RxXferCount));
  21e218:	687b      	ldr	r3, [r7, #4]
  21e21a:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
  21e21e:	687b      	ldr	r3, [r7, #4]
  21e220:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
  21e224:	b29b      	uxth	r3, r3
  21e226:	1ad3      	subs	r3, r2, r3
  21e228:	b29b      	uxth	r3, r3
  21e22a:	4619      	mov	r1, r3
  21e22c:	6878      	ldr	r0, [r7, #4]
  21e22e:	f000 f889 	bl	21e344 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
  21e232:	e075      	b.n	21e320 <HAL_UART_IRQHandler+0x3f0>
  21e234:	04000120 	.word	0x04000120
  21e238:	0021eda9 	.word	0x0021eda9
    else
    {
      /* DMA mode not enabled */
      /* Check received length : If all expected data are received, do nothing.
         Otherwise, if at least one data has already been received, IDLE event is to be notified to user */
      uint16_t nb_rx_data = huart->RxXferSize - huart->RxXferCount;
  21e23c:	687b      	ldr	r3, [r7, #4]
  21e23e:	f8b3 2058 	ldrh.w	r2, [r3, #88]	; 0x58
  21e242:	687b      	ldr	r3, [r7, #4]
  21e244:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
  21e248:	b29b      	uxth	r3, r3
  21e24a:	1ad3      	subs	r3, r2, r3
  21e24c:	813b      	strh	r3, [r7, #8]
      if ((huart->RxXferCount > 0U)
  21e24e:	687b      	ldr	r3, [r7, #4]
  21e250:	f8b3 305a 	ldrh.w	r3, [r3, #90]	; 0x5a
  21e254:	b29b      	uxth	r3, r3
  21e256:	2b00      	cmp	r3, #0
  21e258:	d064      	beq.n	21e324 <HAL_UART_IRQHandler+0x3f4>
          && (nb_rx_data > 0U))
  21e25a:	893b      	ldrh	r3, [r7, #8]
  21e25c:	2b00      	cmp	r3, #0
  21e25e:	d061      	beq.n	21e324 <HAL_UART_IRQHandler+0x3f4>
      {
        /* Disable the UART Parity Error Interrupt and RXNE interrupts */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  21e260:	687b      	ldr	r3, [r7, #4]
  21e262:	681b      	ldr	r3, [r3, #0]
  21e264:	687a      	ldr	r2, [r7, #4]
  21e266:	6812      	ldr	r2, [r2, #0]
  21e268:	6812      	ldr	r2, [r2, #0]
  21e26a:	f422 7290 	bic.w	r2, r2, #288	; 0x120
  21e26e:	601a      	str	r2, [r3, #0]

        /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21e270:	687b      	ldr	r3, [r7, #4]
  21e272:	681b      	ldr	r3, [r3, #0]
  21e274:	687a      	ldr	r2, [r7, #4]
  21e276:	6812      	ldr	r2, [r2, #0]
  21e278:	6892      	ldr	r2, [r2, #8]
  21e27a:	f022 0201 	bic.w	r2, r2, #1
  21e27e:	609a      	str	r2, [r3, #8]

        /* Rx process is completed, restore huart->RxState to Ready */
        huart->RxState = HAL_UART_STATE_READY;
  21e280:	687b      	ldr	r3, [r7, #4]
  21e282:	2220      	movs	r2, #32
  21e284:	67da      	str	r2, [r3, #124]	; 0x7c
        huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  21e286:	687b      	ldr	r3, [r7, #4]
  21e288:	2200      	movs	r2, #0
  21e28a:	661a      	str	r2, [r3, #96]	; 0x60

        /* Clear RxISR function pointer */
        huart->RxISR = NULL;
  21e28c:	687b      	ldr	r3, [r7, #4]
  21e28e:	2200      	movs	r2, #0
  21e290:	665a      	str	r2, [r3, #100]	; 0x64

        CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  21e292:	687b      	ldr	r3, [r7, #4]
  21e294:	681b      	ldr	r3, [r3, #0]
  21e296:	687a      	ldr	r2, [r7, #4]
  21e298:	6812      	ldr	r2, [r2, #0]
  21e29a:	6812      	ldr	r2, [r2, #0]
  21e29c:	f022 0210 	bic.w	r2, r2, #16
  21e2a0:	601a      	str	r2, [r3, #0]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
        /*Call registered Rx complete callback*/
        huart->RxEventCallback(huart, nb_rx_data);
#else
        /*Call legacy weak Rx Event callback*/
        HAL_UARTEx_RxEventCallback(huart, nb_rx_data);
  21e2a2:	893b      	ldrh	r3, [r7, #8]
  21e2a4:	4619      	mov	r1, r3
  21e2a6:	6878      	ldr	r0, [r7, #4]
  21e2a8:	f000 f84c 	bl	21e344 <HAL_UARTEx_RxEventCallback>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
      }
      return;
  21e2ac:	e03a      	b.n	21e324 <HAL_UART_IRQHandler+0x3f4>
  }
#if defined(USART_CR1_UESM)
#if defined(USART_CR3_WUFIE)

  /* UART wakeup from Stop mode interrupt occurred ---------------------------*/
  if (((isrflags & USART_ISR_WUF) != 0U) && ((cr3its & USART_CR3_WUFIE) != 0U))
  21e2ae:	69fb      	ldr	r3, [r7, #28]
  21e2b0:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  21e2b4:	2b00      	cmp	r3, #0
  21e2b6:	d00d      	beq.n	21e2d4 <HAL_UART_IRQHandler+0x3a4>
  21e2b8:	697b      	ldr	r3, [r7, #20]
  21e2ba:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  21e2be:	2b00      	cmp	r3, #0
  21e2c0:	d008      	beq.n	21e2d4 <HAL_UART_IRQHandler+0x3a4>
  {
    __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_WUF);
  21e2c2:	687b      	ldr	r3, [r7, #4]
  21e2c4:	681b      	ldr	r3, [r3, #0]
  21e2c6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
  21e2ca:	621a      	str	r2, [r3, #32]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /* Call registered Wakeup Callback */
    huart->WakeupCallback(huart);
#else
    /* Call legacy weak Wakeup Callback */
    HAL_UARTEx_WakeupCallback(huart);
  21e2cc:	6878      	ldr	r0, [r7, #4]
  21e2ce:	f000 f845 	bl	21e35c <HAL_UARTEx_WakeupCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
    return;
  21e2d2:	e02a      	b.n	21e32a <HAL_UART_IRQHandler+0x3fa>
  }
#endif /* USART_CR3_WUFIE */
#endif /* USART_CR1_UESM */

  /* UART in mode Transmitter ------------------------------------------------*/
  if (((isrflags & USART_ISR_TXE) != 0U)
  21e2d4:	69fb      	ldr	r3, [r7, #28]
  21e2d6:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21e2da:	2b00      	cmp	r3, #0
  21e2dc:	d00d      	beq.n	21e2fa <HAL_UART_IRQHandler+0x3ca>
      && ((cr1its & USART_CR1_TXEIE) != 0U))
  21e2de:	69bb      	ldr	r3, [r7, #24]
  21e2e0:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21e2e4:	2b00      	cmp	r3, #0
  21e2e6:	d008      	beq.n	21e2fa <HAL_UART_IRQHandler+0x3ca>
  {
    if (huart->TxISR != NULL)
  21e2e8:	687b      	ldr	r3, [r7, #4]
  21e2ea:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21e2ec:	2b00      	cmp	r3, #0
  21e2ee:	d01b      	beq.n	21e328 <HAL_UART_IRQHandler+0x3f8>
    {
      huart->TxISR(huart);
  21e2f0:	687b      	ldr	r3, [r7, #4]
  21e2f2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  21e2f4:	6878      	ldr	r0, [r7, #4]
  21e2f6:	4798      	blx	r3
    }
    return;
  21e2f8:	e016      	b.n	21e328 <HAL_UART_IRQHandler+0x3f8>
  }

  /* UART in mode Transmitter (transmission end) -----------------------------*/
  if (((isrflags & USART_ISR_TC) != 0U) && ((cr1its & USART_CR1_TCIE) != 0U))
  21e2fa:	69fb      	ldr	r3, [r7, #28]
  21e2fc:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21e300:	2b00      	cmp	r3, #0
  21e302:	d012      	beq.n	21e32a <HAL_UART_IRQHandler+0x3fa>
  21e304:	69bb      	ldr	r3, [r7, #24]
  21e306:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21e30a:	2b00      	cmp	r3, #0
  21e30c:	d00d      	beq.n	21e32a <HAL_UART_IRQHandler+0x3fa>
  {
    UART_EndTransmit_IT(huart);
  21e30e:	6878      	ldr	r0, [r7, #4]
  21e310:	f000 fd60 	bl	21edd4 <UART_EndTransmit_IT>
    return;
  21e314:	bf00      	nop
  21e316:	e008      	b.n	21e32a <HAL_UART_IRQHandler+0x3fa>
      return;
  21e318:	bf00      	nop
  21e31a:	e006      	b.n	21e32a <HAL_UART_IRQHandler+0x3fa>
    return;
  21e31c:	bf00      	nop
  21e31e:	e004      	b.n	21e32a <HAL_UART_IRQHandler+0x3fa>
      return;
  21e320:	bf00      	nop
  21e322:	e002      	b.n	21e32a <HAL_UART_IRQHandler+0x3fa>
      return;
  21e324:	bf00      	nop
  21e326:	e000      	b.n	21e32a <HAL_UART_IRQHandler+0x3fa>
    return;
  21e328:	bf00      	nop
  }

}
  21e32a:	3720      	adds	r7, #32
  21e32c:	46bd      	mov	sp, r7
  21e32e:	bd80      	pop	{r7, pc}

0021e330 <HAL_UART_RxHalfCpltCallback>:
  * @brief  Rx Half Transfer completed callback.
  * @param  huart UART handle.
  * @retval None
  */
__weak void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
{
  21e330:	b480      	push	{r7}
  21e332:	b083      	sub	sp, #12
  21e334:	af00      	add	r7, sp, #0
  21e336:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_UART_RxHalfCpltCallback can be implemented in the user file.
   */
}
  21e338:	bf00      	nop
  21e33a:	370c      	adds	r7, #12
  21e33c:	46bd      	mov	sp, r7
  21e33e:	f85d 7b04 	ldr.w	r7, [sp], #4
  21e342:	4770      	bx	lr

0021e344 <HAL_UARTEx_RxEventCallback>:
  * @param  Size  Number of data available in application reception buffer (indicates a position in
  *               reception buffer until which, data are available)
  * @retval None
  */
__weak void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
{
  21e344:	b480      	push	{r7}
  21e346:	b083      	sub	sp, #12
  21e348:	af00      	add	r7, sp, #0
  21e34a:	6078      	str	r0, [r7, #4]
  21e34c:	460b      	mov	r3, r1
  21e34e:	807b      	strh	r3, [r7, #2]
  UNUSED(Size);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_RxEventCallback can be implemented in the user file.
   */
}
  21e350:	bf00      	nop
  21e352:	370c      	adds	r7, #12
  21e354:	46bd      	mov	sp, r7
  21e356:	f85d 7b04 	ldr.w	r7, [sp], #4
  21e35a:	4770      	bx	lr

0021e35c <HAL_UARTEx_WakeupCallback>:
  * @brief UART wakeup from Stop mode callback.
  * @param huart UART handle.
  * @retval None
  */
__weak void HAL_UARTEx_WakeupCallback(UART_HandleTypeDef *huart)
{
  21e35c:	b480      	push	{r7}
  21e35e:	b083      	sub	sp, #12
  21e360:	af00      	add	r7, sp, #0
  21e362:	6078      	str	r0, [r7, #4]
  UNUSED(huart);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_UARTEx_WakeupCallback can be implemented in the user file.
   */
}
  21e364:	bf00      	nop
  21e366:	370c      	adds	r7, #12
  21e368:	46bd      	mov	sp, r7
  21e36a:	f85d 7b04 	ldr.w	r7, [sp], #4
  21e36e:	4770      	bx	lr

0021e370 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
  21e370:	b580      	push	{r7, lr}
  21e372:	b088      	sub	sp, #32
  21e374:	af00      	add	r7, sp, #0
  21e376:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
  21e378:	2300      	movs	r3, #0
  21e37a:	77bb      	strb	r3, [r7, #30]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
  21e37c:	687b      	ldr	r3, [r7, #4]
  21e37e:	689a      	ldr	r2, [r3, #8]
  21e380:	687b      	ldr	r3, [r7, #4]
  21e382:	691b      	ldr	r3, [r3, #16]
  21e384:	431a      	orrs	r2, r3
  21e386:	687b      	ldr	r3, [r7, #4]
  21e388:	695b      	ldr	r3, [r3, #20]
  21e38a:	431a      	orrs	r2, r3
  21e38c:	687b      	ldr	r3, [r7, #4]
  21e38e:	69db      	ldr	r3, [r3, #28]
  21e390:	4313      	orrs	r3, r2
  21e392:	617b      	str	r3, [r7, #20]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
  21e394:	687b      	ldr	r3, [r7, #4]
  21e396:	681a      	ldr	r2, [r3, #0]
  21e398:	687b      	ldr	r3, [r7, #4]
  21e39a:	681b      	ldr	r3, [r3, #0]
  21e39c:	6819      	ldr	r1, [r3, #0]
  21e39e:	4bb3      	ldr	r3, [pc, #716]	; (21e66c <UART_SetConfig+0x2fc>)
  21e3a0:	400b      	ands	r3, r1
  21e3a2:	6979      	ldr	r1, [r7, #20]
  21e3a4:	430b      	orrs	r3, r1
  21e3a6:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
  21e3a8:	687b      	ldr	r3, [r7, #4]
  21e3aa:	681b      	ldr	r3, [r3, #0]
  21e3ac:	687a      	ldr	r2, [r7, #4]
  21e3ae:	6812      	ldr	r2, [r2, #0]
  21e3b0:	6852      	ldr	r2, [r2, #4]
  21e3b2:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
  21e3b6:	687a      	ldr	r2, [r7, #4]
  21e3b8:	68d2      	ldr	r2, [r2, #12]
  21e3ba:	430a      	orrs	r2, r1
  21e3bc:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
  21e3be:	687b      	ldr	r3, [r7, #4]
  21e3c0:	699b      	ldr	r3, [r3, #24]
  21e3c2:	617b      	str	r3, [r7, #20]

  tmpreg |= huart->Init.OneBitSampling;
  21e3c4:	687b      	ldr	r3, [r7, #4]
  21e3c6:	6a1b      	ldr	r3, [r3, #32]
  21e3c8:	697a      	ldr	r2, [r7, #20]
  21e3ca:	4313      	orrs	r3, r2
  21e3cc:	617b      	str	r3, [r7, #20]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
  21e3ce:	687b      	ldr	r3, [r7, #4]
  21e3d0:	681b      	ldr	r3, [r3, #0]
  21e3d2:	687a      	ldr	r2, [r7, #4]
  21e3d4:	6812      	ldr	r2, [r2, #0]
  21e3d6:	6892      	ldr	r2, [r2, #8]
  21e3d8:	f422 6130 	bic.w	r1, r2, #2816	; 0xb00
  21e3dc:	697a      	ldr	r2, [r7, #20]
  21e3de:	430a      	orrs	r2, r1
  21e3e0:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
  21e3e2:	687b      	ldr	r3, [r7, #4]
  21e3e4:	681b      	ldr	r3, [r3, #0]
  21e3e6:	4aa2      	ldr	r2, [pc, #648]	; (21e670 <UART_SetConfig+0x300>)
  21e3e8:	4293      	cmp	r3, r2
  21e3ea:	d121      	bne.n	21e430 <UART_SetConfig+0xc0>
  21e3ec:	4ba1      	ldr	r3, [pc, #644]	; (21e674 <UART_SetConfig+0x304>)
  21e3ee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e3f2:	f003 0303 	and.w	r3, r3, #3
  21e3f6:	2b03      	cmp	r3, #3
  21e3f8:	d816      	bhi.n	21e428 <UART_SetConfig+0xb8>
  21e3fa:	a201      	add	r2, pc, #4	; (adr r2, 21e400 <UART_SetConfig+0x90>)
  21e3fc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  21e400:	0021e411 	.word	0x0021e411
  21e404:	0021e41d 	.word	0x0021e41d
  21e408:	0021e417 	.word	0x0021e417
  21e40c:	0021e423 	.word	0x0021e423
  21e410:	2301      	movs	r3, #1
  21e412:	77fb      	strb	r3, [r7, #31]
  21e414:	e150      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e416:	2302      	movs	r3, #2
  21e418:	77fb      	strb	r3, [r7, #31]
  21e41a:	e14d      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e41c:	2304      	movs	r3, #4
  21e41e:	77fb      	strb	r3, [r7, #31]
  21e420:	e14a      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e422:	2308      	movs	r3, #8
  21e424:	77fb      	strb	r3, [r7, #31]
  21e426:	e147      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e428:	2310      	movs	r3, #16
  21e42a:	77fb      	strb	r3, [r7, #31]
  21e42c:	bf00      	nop
  21e42e:	e143      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e430:	687b      	ldr	r3, [r7, #4]
  21e432:	681b      	ldr	r3, [r3, #0]
  21e434:	4a90      	ldr	r2, [pc, #576]	; (21e678 <UART_SetConfig+0x308>)
  21e436:	4293      	cmp	r3, r2
  21e438:	d134      	bne.n	21e4a4 <UART_SetConfig+0x134>
  21e43a:	4b8e      	ldr	r3, [pc, #568]	; (21e674 <UART_SetConfig+0x304>)
  21e43c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e440:	f003 030c 	and.w	r3, r3, #12
  21e444:	2b0c      	cmp	r3, #12
  21e446:	d829      	bhi.n	21e49c <UART_SetConfig+0x12c>
  21e448:	a201      	add	r2, pc, #4	; (adr r2, 21e450 <UART_SetConfig+0xe0>)
  21e44a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  21e44e:	bf00      	nop
  21e450:	0021e485 	.word	0x0021e485
  21e454:	0021e49d 	.word	0x0021e49d
  21e458:	0021e49d 	.word	0x0021e49d
  21e45c:	0021e49d 	.word	0x0021e49d
  21e460:	0021e491 	.word	0x0021e491
  21e464:	0021e49d 	.word	0x0021e49d
  21e468:	0021e49d 	.word	0x0021e49d
  21e46c:	0021e49d 	.word	0x0021e49d
  21e470:	0021e48b 	.word	0x0021e48b
  21e474:	0021e49d 	.word	0x0021e49d
  21e478:	0021e49d 	.word	0x0021e49d
  21e47c:	0021e49d 	.word	0x0021e49d
  21e480:	0021e497 	.word	0x0021e497
  21e484:	2300      	movs	r3, #0
  21e486:	77fb      	strb	r3, [r7, #31]
  21e488:	e116      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e48a:	2302      	movs	r3, #2
  21e48c:	77fb      	strb	r3, [r7, #31]
  21e48e:	e113      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e490:	2304      	movs	r3, #4
  21e492:	77fb      	strb	r3, [r7, #31]
  21e494:	e110      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e496:	2308      	movs	r3, #8
  21e498:	77fb      	strb	r3, [r7, #31]
  21e49a:	e10d      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e49c:	2310      	movs	r3, #16
  21e49e:	77fb      	strb	r3, [r7, #31]
  21e4a0:	bf00      	nop
  21e4a2:	e109      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e4a4:	687b      	ldr	r3, [r7, #4]
  21e4a6:	681b      	ldr	r3, [r3, #0]
  21e4a8:	4a74      	ldr	r2, [pc, #464]	; (21e67c <UART_SetConfig+0x30c>)
  21e4aa:	4293      	cmp	r3, r2
  21e4ac:	d120      	bne.n	21e4f0 <UART_SetConfig+0x180>
  21e4ae:	4b71      	ldr	r3, [pc, #452]	; (21e674 <UART_SetConfig+0x304>)
  21e4b0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e4b4:	f003 0330 	and.w	r3, r3, #48	; 0x30
  21e4b8:	2b10      	cmp	r3, #16
  21e4ba:	d00f      	beq.n	21e4dc <UART_SetConfig+0x16c>
  21e4bc:	2b10      	cmp	r3, #16
  21e4be:	d802      	bhi.n	21e4c6 <UART_SetConfig+0x156>
  21e4c0:	2b00      	cmp	r3, #0
  21e4c2:	d005      	beq.n	21e4d0 <UART_SetConfig+0x160>
  21e4c4:	e010      	b.n	21e4e8 <UART_SetConfig+0x178>
  21e4c6:	2b20      	cmp	r3, #32
  21e4c8:	d005      	beq.n	21e4d6 <UART_SetConfig+0x166>
  21e4ca:	2b30      	cmp	r3, #48	; 0x30
  21e4cc:	d009      	beq.n	21e4e2 <UART_SetConfig+0x172>
  21e4ce:	e00b      	b.n	21e4e8 <UART_SetConfig+0x178>
  21e4d0:	2300      	movs	r3, #0
  21e4d2:	77fb      	strb	r3, [r7, #31]
  21e4d4:	e0f0      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e4d6:	2302      	movs	r3, #2
  21e4d8:	77fb      	strb	r3, [r7, #31]
  21e4da:	e0ed      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e4dc:	2304      	movs	r3, #4
  21e4de:	77fb      	strb	r3, [r7, #31]
  21e4e0:	e0ea      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e4e2:	2308      	movs	r3, #8
  21e4e4:	77fb      	strb	r3, [r7, #31]
  21e4e6:	e0e7      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e4e8:	2310      	movs	r3, #16
  21e4ea:	77fb      	strb	r3, [r7, #31]
  21e4ec:	bf00      	nop
  21e4ee:	e0e3      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e4f0:	687b      	ldr	r3, [r7, #4]
  21e4f2:	681b      	ldr	r3, [r3, #0]
  21e4f4:	4a62      	ldr	r2, [pc, #392]	; (21e680 <UART_SetConfig+0x310>)
  21e4f6:	4293      	cmp	r3, r2
  21e4f8:	d120      	bne.n	21e53c <UART_SetConfig+0x1cc>
  21e4fa:	4b5e      	ldr	r3, [pc, #376]	; (21e674 <UART_SetConfig+0x304>)
  21e4fc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e500:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  21e504:	2b40      	cmp	r3, #64	; 0x40
  21e506:	d00f      	beq.n	21e528 <UART_SetConfig+0x1b8>
  21e508:	2b40      	cmp	r3, #64	; 0x40
  21e50a:	d802      	bhi.n	21e512 <UART_SetConfig+0x1a2>
  21e50c:	2b00      	cmp	r3, #0
  21e50e:	d005      	beq.n	21e51c <UART_SetConfig+0x1ac>
  21e510:	e010      	b.n	21e534 <UART_SetConfig+0x1c4>
  21e512:	2b80      	cmp	r3, #128	; 0x80
  21e514:	d005      	beq.n	21e522 <UART_SetConfig+0x1b2>
  21e516:	2bc0      	cmp	r3, #192	; 0xc0
  21e518:	d009      	beq.n	21e52e <UART_SetConfig+0x1be>
  21e51a:	e00b      	b.n	21e534 <UART_SetConfig+0x1c4>
  21e51c:	2300      	movs	r3, #0
  21e51e:	77fb      	strb	r3, [r7, #31]
  21e520:	e0ca      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e522:	2302      	movs	r3, #2
  21e524:	77fb      	strb	r3, [r7, #31]
  21e526:	e0c7      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e528:	2304      	movs	r3, #4
  21e52a:	77fb      	strb	r3, [r7, #31]
  21e52c:	e0c4      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e52e:	2308      	movs	r3, #8
  21e530:	77fb      	strb	r3, [r7, #31]
  21e532:	e0c1      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e534:	2310      	movs	r3, #16
  21e536:	77fb      	strb	r3, [r7, #31]
  21e538:	bf00      	nop
  21e53a:	e0bd      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e53c:	687b      	ldr	r3, [r7, #4]
  21e53e:	681b      	ldr	r3, [r3, #0]
  21e540:	4a50      	ldr	r2, [pc, #320]	; (21e684 <UART_SetConfig+0x314>)
  21e542:	4293      	cmp	r3, r2
  21e544:	d124      	bne.n	21e590 <UART_SetConfig+0x220>
  21e546:	4b4b      	ldr	r3, [pc, #300]	; (21e674 <UART_SetConfig+0x304>)
  21e548:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e54c:	f403 7340 	and.w	r3, r3, #768	; 0x300
  21e550:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  21e554:	d012      	beq.n	21e57c <UART_SetConfig+0x20c>
  21e556:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  21e55a:	d802      	bhi.n	21e562 <UART_SetConfig+0x1f2>
  21e55c:	2b00      	cmp	r3, #0
  21e55e:	d007      	beq.n	21e570 <UART_SetConfig+0x200>
  21e560:	e012      	b.n	21e588 <UART_SetConfig+0x218>
  21e562:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  21e566:	d006      	beq.n	21e576 <UART_SetConfig+0x206>
  21e568:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
  21e56c:	d009      	beq.n	21e582 <UART_SetConfig+0x212>
  21e56e:	e00b      	b.n	21e588 <UART_SetConfig+0x218>
  21e570:	2300      	movs	r3, #0
  21e572:	77fb      	strb	r3, [r7, #31]
  21e574:	e0a0      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e576:	2302      	movs	r3, #2
  21e578:	77fb      	strb	r3, [r7, #31]
  21e57a:	e09d      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e57c:	2304      	movs	r3, #4
  21e57e:	77fb      	strb	r3, [r7, #31]
  21e580:	e09a      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e582:	2308      	movs	r3, #8
  21e584:	77fb      	strb	r3, [r7, #31]
  21e586:	e097      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e588:	2310      	movs	r3, #16
  21e58a:	77fb      	strb	r3, [r7, #31]
  21e58c:	bf00      	nop
  21e58e:	e093      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e590:	687b      	ldr	r3, [r7, #4]
  21e592:	681b      	ldr	r3, [r3, #0]
  21e594:	4a3c      	ldr	r2, [pc, #240]	; (21e688 <UART_SetConfig+0x318>)
  21e596:	4293      	cmp	r3, r2
  21e598:	d124      	bne.n	21e5e4 <UART_SetConfig+0x274>
  21e59a:	4b36      	ldr	r3, [pc, #216]	; (21e674 <UART_SetConfig+0x304>)
  21e59c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e5a0:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
  21e5a4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  21e5a8:	d012      	beq.n	21e5d0 <UART_SetConfig+0x260>
  21e5aa:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  21e5ae:	d802      	bhi.n	21e5b6 <UART_SetConfig+0x246>
  21e5b0:	2b00      	cmp	r3, #0
  21e5b2:	d007      	beq.n	21e5c4 <UART_SetConfig+0x254>
  21e5b4:	e012      	b.n	21e5dc <UART_SetConfig+0x26c>
  21e5b6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
  21e5ba:	d006      	beq.n	21e5ca <UART_SetConfig+0x25a>
  21e5bc:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
  21e5c0:	d009      	beq.n	21e5d6 <UART_SetConfig+0x266>
  21e5c2:	e00b      	b.n	21e5dc <UART_SetConfig+0x26c>
  21e5c4:	2301      	movs	r3, #1
  21e5c6:	77fb      	strb	r3, [r7, #31]
  21e5c8:	e076      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e5ca:	2302      	movs	r3, #2
  21e5cc:	77fb      	strb	r3, [r7, #31]
  21e5ce:	e073      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e5d0:	2304      	movs	r3, #4
  21e5d2:	77fb      	strb	r3, [r7, #31]
  21e5d4:	e070      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e5d6:	2308      	movs	r3, #8
  21e5d8:	77fb      	strb	r3, [r7, #31]
  21e5da:	e06d      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e5dc:	2310      	movs	r3, #16
  21e5de:	77fb      	strb	r3, [r7, #31]
  21e5e0:	bf00      	nop
  21e5e2:	e069      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e5e4:	687b      	ldr	r3, [r7, #4]
  21e5e6:	681b      	ldr	r3, [r3, #0]
  21e5e8:	4a28      	ldr	r2, [pc, #160]	; (21e68c <UART_SetConfig+0x31c>)
  21e5ea:	4293      	cmp	r3, r2
  21e5ec:	d124      	bne.n	21e638 <UART_SetConfig+0x2c8>
  21e5ee:	4b21      	ldr	r3, [pc, #132]	; (21e674 <UART_SetConfig+0x304>)
  21e5f0:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e5f4:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
  21e5f8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  21e5fc:	d012      	beq.n	21e624 <UART_SetConfig+0x2b4>
  21e5fe:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  21e602:	d802      	bhi.n	21e60a <UART_SetConfig+0x29a>
  21e604:	2b00      	cmp	r3, #0
  21e606:	d007      	beq.n	21e618 <UART_SetConfig+0x2a8>
  21e608:	e012      	b.n	21e630 <UART_SetConfig+0x2c0>
  21e60a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
  21e60e:	d006      	beq.n	21e61e <UART_SetConfig+0x2ae>
  21e610:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
  21e614:	d009      	beq.n	21e62a <UART_SetConfig+0x2ba>
  21e616:	e00b      	b.n	21e630 <UART_SetConfig+0x2c0>
  21e618:	2300      	movs	r3, #0
  21e61a:	77fb      	strb	r3, [r7, #31]
  21e61c:	e04c      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e61e:	2302      	movs	r3, #2
  21e620:	77fb      	strb	r3, [r7, #31]
  21e622:	e049      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e624:	2304      	movs	r3, #4
  21e626:	77fb      	strb	r3, [r7, #31]
  21e628:	e046      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e62a:	2308      	movs	r3, #8
  21e62c:	77fb      	strb	r3, [r7, #31]
  21e62e:	e043      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e630:	2310      	movs	r3, #16
  21e632:	77fb      	strb	r3, [r7, #31]
  21e634:	bf00      	nop
  21e636:	e03f      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e638:	687b      	ldr	r3, [r7, #4]
  21e63a:	681b      	ldr	r3, [r3, #0]
  21e63c:	4a14      	ldr	r2, [pc, #80]	; (21e690 <UART_SetConfig+0x320>)
  21e63e:	4293      	cmp	r3, r2
  21e640:	d138      	bne.n	21e6b4 <UART_SetConfig+0x344>
  21e642:	4b0c      	ldr	r3, [pc, #48]	; (21e674 <UART_SetConfig+0x304>)
  21e644:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  21e648:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
  21e64c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
  21e650:	d026      	beq.n	21e6a0 <UART_SetConfig+0x330>
  21e652:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
  21e656:	d802      	bhi.n	21e65e <UART_SetConfig+0x2ee>
  21e658:	2b00      	cmp	r3, #0
  21e65a:	d01b      	beq.n	21e694 <UART_SetConfig+0x324>
  21e65c:	e026      	b.n	21e6ac <UART_SetConfig+0x33c>
  21e65e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  21e662:	d01a      	beq.n	21e69a <UART_SetConfig+0x32a>
  21e664:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
  21e668:	d01d      	beq.n	21e6a6 <UART_SetConfig+0x336>
  21e66a:	e01f      	b.n	21e6ac <UART_SetConfig+0x33c>
  21e66c:	efff69f3 	.word	0xefff69f3
  21e670:	40011000 	.word	0x40011000
  21e674:	40023800 	.word	0x40023800
  21e678:	40004400 	.word	0x40004400
  21e67c:	40004800 	.word	0x40004800
  21e680:	40004c00 	.word	0x40004c00
  21e684:	40005000 	.word	0x40005000
  21e688:	40011400 	.word	0x40011400
  21e68c:	40007800 	.word	0x40007800
  21e690:	40007c00 	.word	0x40007c00
  21e694:	2300      	movs	r3, #0
  21e696:	77fb      	strb	r3, [r7, #31]
  21e698:	e00e      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e69a:	2302      	movs	r3, #2
  21e69c:	77fb      	strb	r3, [r7, #31]
  21e69e:	e00b      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e6a0:	2304      	movs	r3, #4
  21e6a2:	77fb      	strb	r3, [r7, #31]
  21e6a4:	e008      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e6a6:	2308      	movs	r3, #8
  21e6a8:	77fb      	strb	r3, [r7, #31]
  21e6aa:	e005      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e6ac:	2310      	movs	r3, #16
  21e6ae:	77fb      	strb	r3, [r7, #31]
  21e6b0:	bf00      	nop
  21e6b2:	e001      	b.n	21e6b8 <UART_SetConfig+0x348>
  21e6b4:	2310      	movs	r3, #16
  21e6b6:	77fb      	strb	r3, [r7, #31]

  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
  21e6b8:	687b      	ldr	r3, [r7, #4]
  21e6ba:	69db      	ldr	r3, [r3, #28]
  21e6bc:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
  21e6c0:	d15c      	bne.n	21e77c <UART_SetConfig+0x40c>
  {
    switch (clocksource)
  21e6c2:	7ffb      	ldrb	r3, [r7, #31]
  21e6c4:	2b08      	cmp	r3, #8
  21e6c6:	d828      	bhi.n	21e71a <UART_SetConfig+0x3aa>
  21e6c8:	a201      	add	r2, pc, #4	; (adr r2, 21e6d0 <UART_SetConfig+0x360>)
  21e6ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  21e6ce:	bf00      	nop
  21e6d0:	0021e6f5 	.word	0x0021e6f5
  21e6d4:	0021e6fd 	.word	0x0021e6fd
  21e6d8:	0021e705 	.word	0x0021e705
  21e6dc:	0021e71b 	.word	0x0021e71b
  21e6e0:	0021e70b 	.word	0x0021e70b
  21e6e4:	0021e71b 	.word	0x0021e71b
  21e6e8:	0021e71b 	.word	0x0021e71b
  21e6ec:	0021e71b 	.word	0x0021e71b
  21e6f0:	0021e713 	.word	0x0021e713
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
  21e6f4:	f7fc fd3a 	bl	21b16c <HAL_RCC_GetPCLK1Freq>
  21e6f8:	61b8      	str	r0, [r7, #24]
        break;
  21e6fa:	e013      	b.n	21e724 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
  21e6fc:	f7fc fd4a 	bl	21b194 <HAL_RCC_GetPCLK2Freq>
  21e700:	61b8      	str	r0, [r7, #24]
        break;
  21e702:	e00f      	b.n	21e724 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
  21e704:	4b49      	ldr	r3, [pc, #292]	; (21e82c <UART_SetConfig+0x4bc>)
  21e706:	61bb      	str	r3, [r7, #24]
        break;
  21e708:	e00c      	b.n	21e724 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
  21e70a:	f7fc fc6d 	bl	21afe8 <HAL_RCC_GetSysClockFreq>
  21e70e:	61b8      	str	r0, [r7, #24]
        break;
  21e710:	e008      	b.n	21e724 <UART_SetConfig+0x3b4>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
  21e712:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  21e716:	61bb      	str	r3, [r7, #24]
        break;
  21e718:	e004      	b.n	21e724 <UART_SetConfig+0x3b4>
      default:
        pclk = 0U;
  21e71a:	2300      	movs	r3, #0
  21e71c:	61bb      	str	r3, [r7, #24]
        ret = HAL_ERROR;
  21e71e:	2301      	movs	r3, #1
  21e720:	77bb      	strb	r3, [r7, #30]
        break;
  21e722:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
  21e724:	69bb      	ldr	r3, [r7, #24]
  21e726:	2b00      	cmp	r3, #0
  21e728:	d074      	beq.n	21e814 <UART_SetConfig+0x4a4>
    {
      usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate));
  21e72a:	69bb      	ldr	r3, [r7, #24]
  21e72c:	005a      	lsls	r2, r3, #1
  21e72e:	687b      	ldr	r3, [r7, #4]
  21e730:	685b      	ldr	r3, [r3, #4]
  21e732:	085b      	lsrs	r3, r3, #1
  21e734:	441a      	add	r2, r3
  21e736:	687b      	ldr	r3, [r7, #4]
  21e738:	685b      	ldr	r3, [r3, #4]
  21e73a:	fbb2 f3f3 	udiv	r3, r2, r3
  21e73e:	b29b      	uxth	r3, r3
  21e740:	613b      	str	r3, [r7, #16]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
  21e742:	693b      	ldr	r3, [r7, #16]
  21e744:	2b0f      	cmp	r3, #15
  21e746:	d916      	bls.n	21e776 <UART_SetConfig+0x406>
  21e748:	693b      	ldr	r3, [r7, #16]
  21e74a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  21e74e:	d212      	bcs.n	21e776 <UART_SetConfig+0x406>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
  21e750:	693b      	ldr	r3, [r7, #16]
  21e752:	b29b      	uxth	r3, r3
  21e754:	f023 030f 	bic.w	r3, r3, #15
  21e758:	81fb      	strh	r3, [r7, #14]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
  21e75a:	693b      	ldr	r3, [r7, #16]
  21e75c:	085b      	lsrs	r3, r3, #1
  21e75e:	b29b      	uxth	r3, r3
  21e760:	f003 0307 	and.w	r3, r3, #7
  21e764:	b29a      	uxth	r2, r3
  21e766:	89fb      	ldrh	r3, [r7, #14]
  21e768:	4313      	orrs	r3, r2
  21e76a:	81fb      	strh	r3, [r7, #14]
        huart->Instance->BRR = brrtemp;
  21e76c:	687b      	ldr	r3, [r7, #4]
  21e76e:	681b      	ldr	r3, [r3, #0]
  21e770:	89fa      	ldrh	r2, [r7, #14]
  21e772:	60da      	str	r2, [r3, #12]
  21e774:	e04e      	b.n	21e814 <UART_SetConfig+0x4a4>
      }
      else
      {
        ret = HAL_ERROR;
  21e776:	2301      	movs	r3, #1
  21e778:	77bb      	strb	r3, [r7, #30]
  21e77a:	e04b      	b.n	21e814 <UART_SetConfig+0x4a4>
      }
    }
  }
  else
  {
    switch (clocksource)
  21e77c:	7ffb      	ldrb	r3, [r7, #31]
  21e77e:	2b08      	cmp	r3, #8
  21e780:	d827      	bhi.n	21e7d2 <UART_SetConfig+0x462>
  21e782:	a201      	add	r2, pc, #4	; (adr r2, 21e788 <UART_SetConfig+0x418>)
  21e784:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  21e788:	0021e7ad 	.word	0x0021e7ad
  21e78c:	0021e7b5 	.word	0x0021e7b5
  21e790:	0021e7bd 	.word	0x0021e7bd
  21e794:	0021e7d3 	.word	0x0021e7d3
  21e798:	0021e7c3 	.word	0x0021e7c3
  21e79c:	0021e7d3 	.word	0x0021e7d3
  21e7a0:	0021e7d3 	.word	0x0021e7d3
  21e7a4:	0021e7d3 	.word	0x0021e7d3
  21e7a8:	0021e7cb 	.word	0x0021e7cb
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
  21e7ac:	f7fc fcde 	bl	21b16c <HAL_RCC_GetPCLK1Freq>
  21e7b0:	61b8      	str	r0, [r7, #24]
        break;
  21e7b2:	e013      	b.n	21e7dc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
  21e7b4:	f7fc fcee 	bl	21b194 <HAL_RCC_GetPCLK2Freq>
  21e7b8:	61b8      	str	r0, [r7, #24]
        break;
  21e7ba:	e00f      	b.n	21e7dc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_HSI:
        pclk = (uint32_t) HSI_VALUE;
  21e7bc:	4b1b      	ldr	r3, [pc, #108]	; (21e82c <UART_SetConfig+0x4bc>)
  21e7be:	61bb      	str	r3, [r7, #24]
        break;
  21e7c0:	e00c      	b.n	21e7dc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_SYSCLK:
        pclk = HAL_RCC_GetSysClockFreq();
  21e7c2:	f7fc fc11 	bl	21afe8 <HAL_RCC_GetSysClockFreq>
  21e7c6:	61b8      	str	r0, [r7, #24]
        break;
  21e7c8:	e008      	b.n	21e7dc <UART_SetConfig+0x46c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
  21e7ca:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  21e7ce:	61bb      	str	r3, [r7, #24]
        break;
  21e7d0:	e004      	b.n	21e7dc <UART_SetConfig+0x46c>
      default:
        pclk = 0U;
  21e7d2:	2300      	movs	r3, #0
  21e7d4:	61bb      	str	r3, [r7, #24]
        ret = HAL_ERROR;
  21e7d6:	2301      	movs	r3, #1
  21e7d8:	77bb      	strb	r3, [r7, #30]
        break;
  21e7da:	bf00      	nop
    }

    if (pclk != 0U)
  21e7dc:	69bb      	ldr	r3, [r7, #24]
  21e7de:	2b00      	cmp	r3, #0
  21e7e0:	d018      	beq.n	21e814 <UART_SetConfig+0x4a4>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate));
  21e7e2:	687b      	ldr	r3, [r7, #4]
  21e7e4:	685b      	ldr	r3, [r3, #4]
  21e7e6:	085a      	lsrs	r2, r3, #1
  21e7e8:	69bb      	ldr	r3, [r7, #24]
  21e7ea:	441a      	add	r2, r3
  21e7ec:	687b      	ldr	r3, [r7, #4]
  21e7ee:	685b      	ldr	r3, [r3, #4]
  21e7f0:	fbb2 f3f3 	udiv	r3, r2, r3
  21e7f4:	b29b      	uxth	r3, r3
  21e7f6:	613b      	str	r3, [r7, #16]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
  21e7f8:	693b      	ldr	r3, [r7, #16]
  21e7fa:	2b0f      	cmp	r3, #15
  21e7fc:	d908      	bls.n	21e810 <UART_SetConfig+0x4a0>
  21e7fe:	693b      	ldr	r3, [r7, #16]
  21e800:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  21e804:	d204      	bcs.n	21e810 <UART_SetConfig+0x4a0>
      {
        huart->Instance->BRR = usartdiv;
  21e806:	687b      	ldr	r3, [r7, #4]
  21e808:	681b      	ldr	r3, [r3, #0]
  21e80a:	693a      	ldr	r2, [r7, #16]
  21e80c:	60da      	str	r2, [r3, #12]
  21e80e:	e001      	b.n	21e814 <UART_SetConfig+0x4a4>
      }
      else
      {
        ret = HAL_ERROR;
  21e810:	2301      	movs	r3, #1
  21e812:	77bb      	strb	r3, [r7, #30]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
  21e814:	687b      	ldr	r3, [r7, #4]
  21e816:	2200      	movs	r2, #0
  21e818:	665a      	str	r2, [r3, #100]	; 0x64
  huart->TxISR = NULL;
  21e81a:	687b      	ldr	r3, [r7, #4]
  21e81c:	2200      	movs	r2, #0
  21e81e:	669a      	str	r2, [r3, #104]	; 0x68

  return ret;
  21e820:	7fbb      	ldrb	r3, [r7, #30]
}
  21e822:	4618      	mov	r0, r3
  21e824:	3720      	adds	r7, #32
  21e826:	46bd      	mov	sp, r7
  21e828:	bd80      	pop	{r7, pc}
  21e82a:	bf00      	nop
  21e82c:	00f42400 	.word	0x00f42400

0021e830 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
  21e830:	b480      	push	{r7}
  21e832:	b083      	sub	sp, #12
  21e834:	af00      	add	r7, sp, #0
  21e836:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
  21e838:	687b      	ldr	r3, [r7, #4]
  21e83a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e83c:	f003 0301 	and.w	r3, r3, #1
  21e840:	2b00      	cmp	r3, #0
  21e842:	d00a      	beq.n	21e85a <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
  21e844:	687b      	ldr	r3, [r7, #4]
  21e846:	681b      	ldr	r3, [r3, #0]
  21e848:	687a      	ldr	r2, [r7, #4]
  21e84a:	6812      	ldr	r2, [r2, #0]
  21e84c:	6852      	ldr	r2, [r2, #4]
  21e84e:	f422 3100 	bic.w	r1, r2, #131072	; 0x20000
  21e852:	687a      	ldr	r2, [r7, #4]
  21e854:	6a92      	ldr	r2, [r2, #40]	; 0x28
  21e856:	430a      	orrs	r2, r1
  21e858:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
  21e85a:	687b      	ldr	r3, [r7, #4]
  21e85c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e85e:	f003 0302 	and.w	r3, r3, #2
  21e862:	2b00      	cmp	r3, #0
  21e864:	d00a      	beq.n	21e87c <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
  21e866:	687b      	ldr	r3, [r7, #4]
  21e868:	681b      	ldr	r3, [r3, #0]
  21e86a:	687a      	ldr	r2, [r7, #4]
  21e86c:	6812      	ldr	r2, [r2, #0]
  21e86e:	6852      	ldr	r2, [r2, #4]
  21e870:	f422 3180 	bic.w	r1, r2, #65536	; 0x10000
  21e874:	687a      	ldr	r2, [r7, #4]
  21e876:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  21e878:	430a      	orrs	r2, r1
  21e87a:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
  21e87c:	687b      	ldr	r3, [r7, #4]
  21e87e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e880:	f003 0304 	and.w	r3, r3, #4
  21e884:	2b00      	cmp	r3, #0
  21e886:	d00a      	beq.n	21e89e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
  21e888:	687b      	ldr	r3, [r7, #4]
  21e88a:	681b      	ldr	r3, [r3, #0]
  21e88c:	687a      	ldr	r2, [r7, #4]
  21e88e:	6812      	ldr	r2, [r2, #0]
  21e890:	6852      	ldr	r2, [r2, #4]
  21e892:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
  21e896:	687a      	ldr	r2, [r7, #4]
  21e898:	6b12      	ldr	r2, [r2, #48]	; 0x30
  21e89a:	430a      	orrs	r2, r1
  21e89c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
  21e89e:	687b      	ldr	r3, [r7, #4]
  21e8a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e8a2:	f003 0308 	and.w	r3, r3, #8
  21e8a6:	2b00      	cmp	r3, #0
  21e8a8:	d00a      	beq.n	21e8c0 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
  21e8aa:	687b      	ldr	r3, [r7, #4]
  21e8ac:	681b      	ldr	r3, [r3, #0]
  21e8ae:	687a      	ldr	r2, [r7, #4]
  21e8b0:	6812      	ldr	r2, [r2, #0]
  21e8b2:	6852      	ldr	r2, [r2, #4]
  21e8b4:	f422 4100 	bic.w	r1, r2, #32768	; 0x8000
  21e8b8:	687a      	ldr	r2, [r7, #4]
  21e8ba:	6b52      	ldr	r2, [r2, #52]	; 0x34
  21e8bc:	430a      	orrs	r2, r1
  21e8be:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
  21e8c0:	687b      	ldr	r3, [r7, #4]
  21e8c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e8c4:	f003 0310 	and.w	r3, r3, #16
  21e8c8:	2b00      	cmp	r3, #0
  21e8ca:	d00a      	beq.n	21e8e2 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
  21e8cc:	687b      	ldr	r3, [r7, #4]
  21e8ce:	681b      	ldr	r3, [r3, #0]
  21e8d0:	687a      	ldr	r2, [r7, #4]
  21e8d2:	6812      	ldr	r2, [r2, #0]
  21e8d4:	6892      	ldr	r2, [r2, #8]
  21e8d6:	f422 5180 	bic.w	r1, r2, #4096	; 0x1000
  21e8da:	687a      	ldr	r2, [r7, #4]
  21e8dc:	6b92      	ldr	r2, [r2, #56]	; 0x38
  21e8de:	430a      	orrs	r2, r1
  21e8e0:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
  21e8e2:	687b      	ldr	r3, [r7, #4]
  21e8e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e8e6:	f003 0320 	and.w	r3, r3, #32
  21e8ea:	2b00      	cmp	r3, #0
  21e8ec:	d00a      	beq.n	21e904 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
  21e8ee:	687b      	ldr	r3, [r7, #4]
  21e8f0:	681b      	ldr	r3, [r3, #0]
  21e8f2:	687a      	ldr	r2, [r7, #4]
  21e8f4:	6812      	ldr	r2, [r2, #0]
  21e8f6:	6892      	ldr	r2, [r2, #8]
  21e8f8:	f422 5100 	bic.w	r1, r2, #8192	; 0x2000
  21e8fc:	687a      	ldr	r2, [r7, #4]
  21e8fe:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
  21e900:	430a      	orrs	r2, r1
  21e902:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
  21e904:	687b      	ldr	r3, [r7, #4]
  21e906:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e908:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21e90c:	2b00      	cmp	r3, #0
  21e90e:	d01a      	beq.n	21e946 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
  21e910:	687b      	ldr	r3, [r7, #4]
  21e912:	681b      	ldr	r3, [r3, #0]
  21e914:	687a      	ldr	r2, [r7, #4]
  21e916:	6812      	ldr	r2, [r2, #0]
  21e918:	6852      	ldr	r2, [r2, #4]
  21e91a:	f422 1180 	bic.w	r1, r2, #1048576	; 0x100000
  21e91e:	687a      	ldr	r2, [r7, #4]
  21e920:	6c12      	ldr	r2, [r2, #64]	; 0x40
  21e922:	430a      	orrs	r2, r1
  21e924:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
  21e926:	687b      	ldr	r3, [r7, #4]
  21e928:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  21e92a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
  21e92e:	d10a      	bne.n	21e946 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
  21e930:	687b      	ldr	r3, [r7, #4]
  21e932:	681b      	ldr	r3, [r3, #0]
  21e934:	687a      	ldr	r2, [r7, #4]
  21e936:	6812      	ldr	r2, [r2, #0]
  21e938:	6852      	ldr	r2, [r2, #4]
  21e93a:	f422 01c0 	bic.w	r1, r2, #6291456	; 0x600000
  21e93e:	687a      	ldr	r2, [r7, #4]
  21e940:	6c52      	ldr	r2, [r2, #68]	; 0x44
  21e942:	430a      	orrs	r2, r1
  21e944:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
  21e946:	687b      	ldr	r3, [r7, #4]
  21e948:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  21e94a:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21e94e:	2b00      	cmp	r3, #0
  21e950:	d00a      	beq.n	21e968 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
  21e952:	687b      	ldr	r3, [r7, #4]
  21e954:	681b      	ldr	r3, [r3, #0]
  21e956:	687a      	ldr	r2, [r7, #4]
  21e958:	6812      	ldr	r2, [r2, #0]
  21e95a:	6852      	ldr	r2, [r2, #4]
  21e95c:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
  21e960:	687a      	ldr	r2, [r7, #4]
  21e962:	6c92      	ldr	r2, [r2, #72]	; 0x48
  21e964:	430a      	orrs	r2, r1
  21e966:	605a      	str	r2, [r3, #4]
  }
}
  21e968:	bf00      	nop
  21e96a:	370c      	adds	r7, #12
  21e96c:	46bd      	mov	sp, r7
  21e96e:	f85d 7b04 	ldr.w	r7, [sp], #4
  21e972:	4770      	bx	lr

0021e974 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
  21e974:	b580      	push	{r7, lr}
  21e976:	b086      	sub	sp, #24
  21e978:	af02      	add	r7, sp, #8
  21e97a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  21e97c:	687b      	ldr	r3, [r7, #4]
  21e97e:	2200      	movs	r2, #0
  21e980:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
  21e984:	f7fa fa54 	bl	218e30 <HAL_GetTick>
  21e988:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
  21e98a:	687b      	ldr	r3, [r7, #4]
  21e98c:	681b      	ldr	r3, [r3, #0]
  21e98e:	681b      	ldr	r3, [r3, #0]
  21e990:	f003 0308 	and.w	r3, r3, #8
  21e994:	2b08      	cmp	r3, #8
  21e996:	d10e      	bne.n	21e9b6 <UART_CheckIdleState+0x42>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
  21e998:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
  21e99c:	9300      	str	r3, [sp, #0]
  21e99e:	68fb      	ldr	r3, [r7, #12]
  21e9a0:	2200      	movs	r2, #0
  21e9a2:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  21e9a6:	6878      	ldr	r0, [r7, #4]
  21e9a8:	f000 f82d 	bl	21ea06 <UART_WaitOnFlagUntilTimeout>
  21e9ac:	4603      	mov	r3, r0
  21e9ae:	2b00      	cmp	r3, #0
  21e9b0:	d001      	beq.n	21e9b6 <UART_CheckIdleState+0x42>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
  21e9b2:	2303      	movs	r3, #3
  21e9b4:	e023      	b.n	21e9fe <UART_CheckIdleState+0x8a>
    }
  }
#if defined(USART_ISR_REACK)

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
  21e9b6:	687b      	ldr	r3, [r7, #4]
  21e9b8:	681b      	ldr	r3, [r3, #0]
  21e9ba:	681b      	ldr	r3, [r3, #0]
  21e9bc:	f003 0304 	and.w	r3, r3, #4
  21e9c0:	2b04      	cmp	r3, #4
  21e9c2:	d10e      	bne.n	21e9e2 <UART_CheckIdleState+0x6e>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
  21e9c4:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
  21e9c8:	9300      	str	r3, [sp, #0]
  21e9ca:	68fb      	ldr	r3, [r7, #12]
  21e9cc:	2200      	movs	r2, #0
  21e9ce:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  21e9d2:	6878      	ldr	r0, [r7, #4]
  21e9d4:	f000 f817 	bl	21ea06 <UART_WaitOnFlagUntilTimeout>
  21e9d8:	4603      	mov	r3, r0
  21e9da:	2b00      	cmp	r3, #0
  21e9dc:	d001      	beq.n	21e9e2 <UART_CheckIdleState+0x6e>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
  21e9de:	2303      	movs	r3, #3
  21e9e0:	e00d      	b.n	21e9fe <UART_CheckIdleState+0x8a>
    }
  }
#endif

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
  21e9e2:	687b      	ldr	r3, [r7, #4]
  21e9e4:	2220      	movs	r2, #32
  21e9e6:	679a      	str	r2, [r3, #120]	; 0x78
  huart->RxState = HAL_UART_STATE_READY;
  21e9e8:	687b      	ldr	r3, [r7, #4]
  21e9ea:	2220      	movs	r2, #32
  21e9ec:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  21e9ee:	687b      	ldr	r3, [r7, #4]
  21e9f0:	2200      	movs	r2, #0
  21e9f2:	661a      	str	r2, [r3, #96]	; 0x60

  __HAL_UNLOCK(huart);
  21e9f4:	687b      	ldr	r3, [r7, #4]
  21e9f6:	2200      	movs	r2, #0
  21e9f8:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

  return HAL_OK;
  21e9fc:	2300      	movs	r3, #0
}
  21e9fe:	4618      	mov	r0, r3
  21ea00:	3710      	adds	r7, #16
  21ea02:	46bd      	mov	sp, r7
  21ea04:	bd80      	pop	{r7, pc}

0021ea06 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
  21ea06:	b580      	push	{r7, lr}
  21ea08:	b084      	sub	sp, #16
  21ea0a:	af00      	add	r7, sp, #0
  21ea0c:	60f8      	str	r0, [r7, #12]
  21ea0e:	60b9      	str	r1, [r7, #8]
  21ea10:	603b      	str	r3, [r7, #0]
  21ea12:	4613      	mov	r3, r2
  21ea14:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  21ea16:	e05e      	b.n	21ead6 <UART_WaitOnFlagUntilTimeout+0xd0>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
  21ea18:	69bb      	ldr	r3, [r7, #24]
  21ea1a:	f1b3 3fff 	cmp.w	r3, #4294967295
  21ea1e:	d05a      	beq.n	21ead6 <UART_WaitOnFlagUntilTimeout+0xd0>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
  21ea20:	f7fa fa06 	bl	218e30 <HAL_GetTick>
  21ea24:	4602      	mov	r2, r0
  21ea26:	683b      	ldr	r3, [r7, #0]
  21ea28:	1ad2      	subs	r2, r2, r3
  21ea2a:	69bb      	ldr	r3, [r7, #24]
  21ea2c:	429a      	cmp	r2, r3
  21ea2e:	d802      	bhi.n	21ea36 <UART_WaitOnFlagUntilTimeout+0x30>
  21ea30:	69bb      	ldr	r3, [r7, #24]
  21ea32:	2b00      	cmp	r3, #0
  21ea34:	d11b      	bne.n	21ea6e <UART_WaitOnFlagUntilTimeout+0x68>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
           interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
  21ea36:	68fb      	ldr	r3, [r7, #12]
  21ea38:	681b      	ldr	r3, [r3, #0]
  21ea3a:	68fa      	ldr	r2, [r7, #12]
  21ea3c:	6812      	ldr	r2, [r2, #0]
  21ea3e:	6812      	ldr	r2, [r2, #0]
  21ea40:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
  21ea44:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21ea46:	68fb      	ldr	r3, [r7, #12]
  21ea48:	681b      	ldr	r3, [r3, #0]
  21ea4a:	68fa      	ldr	r2, [r7, #12]
  21ea4c:	6812      	ldr	r2, [r2, #0]
  21ea4e:	6892      	ldr	r2, [r2, #8]
  21ea50:	f022 0201 	bic.w	r2, r2, #1
  21ea54:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
  21ea56:	68fb      	ldr	r3, [r7, #12]
  21ea58:	2220      	movs	r2, #32
  21ea5a:	679a      	str	r2, [r3, #120]	; 0x78
        huart->RxState = HAL_UART_STATE_READY;
  21ea5c:	68fb      	ldr	r3, [r7, #12]
  21ea5e:	2220      	movs	r2, #32
  21ea60:	67da      	str	r2, [r3, #124]	; 0x7c

        __HAL_UNLOCK(huart);
  21ea62:	68fb      	ldr	r3, [r7, #12]
  21ea64:	2200      	movs	r2, #0
  21ea66:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

        return HAL_TIMEOUT;
  21ea6a:	2303      	movs	r3, #3
  21ea6c:	e043      	b.n	21eaf6 <UART_WaitOnFlagUntilTimeout+0xf0>
      }

      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
  21ea6e:	68fb      	ldr	r3, [r7, #12]
  21ea70:	681b      	ldr	r3, [r3, #0]
  21ea72:	681b      	ldr	r3, [r3, #0]
  21ea74:	f003 0304 	and.w	r3, r3, #4
  21ea78:	2b00      	cmp	r3, #0
  21ea7a:	d02c      	beq.n	21ead6 <UART_WaitOnFlagUntilTimeout+0xd0>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
  21ea7c:	68fb      	ldr	r3, [r7, #12]
  21ea7e:	681b      	ldr	r3, [r3, #0]
  21ea80:	69db      	ldr	r3, [r3, #28]
  21ea82:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  21ea86:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
  21ea8a:	d124      	bne.n	21ead6 <UART_WaitOnFlagUntilTimeout+0xd0>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
  21ea8c:	68fb      	ldr	r3, [r7, #12]
  21ea8e:	681b      	ldr	r3, [r3, #0]
  21ea90:	f44f 6200 	mov.w	r2, #2048	; 0x800
  21ea94:	621a      	str	r2, [r3, #32]

          /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error)
             interrupts for the interrupt process */
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
  21ea96:	68fb      	ldr	r3, [r7, #12]
  21ea98:	681b      	ldr	r3, [r3, #0]
  21ea9a:	68fa      	ldr	r2, [r7, #12]
  21ea9c:	6812      	ldr	r2, [r2, #0]
  21ea9e:	6812      	ldr	r2, [r2, #0]
  21eaa0:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
  21eaa4:	601a      	str	r2, [r3, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21eaa6:	68fb      	ldr	r3, [r7, #12]
  21eaa8:	681b      	ldr	r3, [r3, #0]
  21eaaa:	68fa      	ldr	r2, [r7, #12]
  21eaac:	6812      	ldr	r2, [r2, #0]
  21eaae:	6892      	ldr	r2, [r2, #8]
  21eab0:	f022 0201 	bic.w	r2, r2, #1
  21eab4:	609a      	str	r2, [r3, #8]

          huart->gState = HAL_UART_STATE_READY;
  21eab6:	68fb      	ldr	r3, [r7, #12]
  21eab8:	2220      	movs	r2, #32
  21eaba:	679a      	str	r2, [r3, #120]	; 0x78
          huart->RxState = HAL_UART_STATE_READY;
  21eabc:	68fb      	ldr	r3, [r7, #12]
  21eabe:	2220      	movs	r2, #32
  21eac0:	67da      	str	r2, [r3, #124]	; 0x7c
          huart->ErrorCode = HAL_UART_ERROR_RTO;
  21eac2:	68fb      	ldr	r3, [r7, #12]
  21eac4:	2220      	movs	r2, #32
  21eac6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
  21eaca:	68fb      	ldr	r3, [r7, #12]
  21eacc:	2200      	movs	r2, #0
  21eace:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

          return HAL_TIMEOUT;
  21ead2:	2303      	movs	r3, #3
  21ead4:	e00f      	b.n	21eaf6 <UART_WaitOnFlagUntilTimeout+0xf0>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
  21ead6:	68fb      	ldr	r3, [r7, #12]
  21ead8:	681b      	ldr	r3, [r3, #0]
  21eada:	69da      	ldr	r2, [r3, #28]
  21eadc:	68bb      	ldr	r3, [r7, #8]
  21eade:	401a      	ands	r2, r3
  21eae0:	68bb      	ldr	r3, [r7, #8]
  21eae2:	429a      	cmp	r2, r3
  21eae4:	bf0c      	ite	eq
  21eae6:	2301      	moveq	r3, #1
  21eae8:	2300      	movne	r3, #0
  21eaea:	b2db      	uxtb	r3, r3
  21eaec:	461a      	mov	r2, r3
  21eaee:	79fb      	ldrb	r3, [r7, #7]
  21eaf0:	429a      	cmp	r2, r3
  21eaf2:	d091      	beq.n	21ea18 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
  21eaf4:	2300      	movs	r3, #0
}
  21eaf6:	4618      	mov	r0, r3
  21eaf8:	3710      	adds	r7, #16
  21eafa:	46bd      	mov	sp, r7
  21eafc:	bd80      	pop	{r7, pc}
	...

0021eb00 <UART_Start_Receive_DMA>:
  * @param  pData Pointer to data buffer (u8 or u16 data elements).
  * @param  Size  Amount of data elements (u8 or u16) to be received.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_Start_Receive_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  21eb00:	b580      	push	{r7, lr}
  21eb02:	b084      	sub	sp, #16
  21eb04:	af00      	add	r7, sp, #0
  21eb06:	60f8      	str	r0, [r7, #12]
  21eb08:	60b9      	str	r1, [r7, #8]
  21eb0a:	4613      	mov	r3, r2
  21eb0c:	80fb      	strh	r3, [r7, #6]
  huart->pRxBuffPtr = pData;
  21eb0e:	68fb      	ldr	r3, [r7, #12]
  21eb10:	68ba      	ldr	r2, [r7, #8]
  21eb12:	655a      	str	r2, [r3, #84]	; 0x54
  huart->RxXferSize = Size;
  21eb14:	68fb      	ldr	r3, [r7, #12]
  21eb16:	88fa      	ldrh	r2, [r7, #6]
  21eb18:	f8a3 2058 	strh.w	r2, [r3, #88]	; 0x58

  huart->ErrorCode = HAL_UART_ERROR_NONE;
  21eb1c:	68fb      	ldr	r3, [r7, #12]
  21eb1e:	2200      	movs	r2, #0
  21eb20:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  huart->RxState = HAL_UART_STATE_BUSY_RX;
  21eb24:	68fb      	ldr	r3, [r7, #12]
  21eb26:	2222      	movs	r2, #34	; 0x22
  21eb28:	67da      	str	r2, [r3, #124]	; 0x7c

  if (huart->hdmarx != NULL)
  21eb2a:	68fb      	ldr	r3, [r7, #12]
  21eb2c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21eb2e:	2b00      	cmp	r3, #0
  21eb30:	d02b      	beq.n	21eb8a <UART_Start_Receive_DMA+0x8a>
  {
    /* Set the UART DMA transfer complete callback */
    huart->hdmarx->XferCpltCallback = UART_DMAReceiveCplt;
  21eb32:	68fb      	ldr	r3, [r7, #12]
  21eb34:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21eb36:	4a25      	ldr	r2, [pc, #148]	; (21ebcc <UART_Start_Receive_DMA+0xcc>)
  21eb38:	63da      	str	r2, [r3, #60]	; 0x3c

    /* Set the UART DMA Half transfer complete callback */
    huart->hdmarx->XferHalfCpltCallback = UART_DMARxHalfCplt;
  21eb3a:	68fb      	ldr	r3, [r7, #12]
  21eb3c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21eb3e:	4a24      	ldr	r2, [pc, #144]	; (21ebd0 <UART_Start_Receive_DMA+0xd0>)
  21eb40:	641a      	str	r2, [r3, #64]	; 0x40

    /* Set the DMA error callback */
    huart->hdmarx->XferErrorCallback = UART_DMAError;
  21eb42:	68fb      	ldr	r3, [r7, #12]
  21eb44:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21eb46:	4a23      	ldr	r2, [pc, #140]	; (21ebd4 <UART_Start_Receive_DMA+0xd4>)
  21eb48:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Set the DMA abort callback */
    huart->hdmarx->XferAbortCallback = NULL;
  21eb4a:	68fb      	ldr	r3, [r7, #12]
  21eb4c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  21eb4e:	2200      	movs	r2, #0
  21eb50:	651a      	str	r2, [r3, #80]	; 0x50

    /* Enable the DMA channel */
    if (HAL_DMA_Start_IT(huart->hdmarx, (uint32_t)&huart->Instance->RDR, (uint32_t)huart->pRxBuffPtr, Size) != HAL_OK)
  21eb52:	68fb      	ldr	r3, [r7, #12]
  21eb54:	6f18      	ldr	r0, [r3, #112]	; 0x70
  21eb56:	68fb      	ldr	r3, [r7, #12]
  21eb58:	681b      	ldr	r3, [r3, #0]
  21eb5a:	3324      	adds	r3, #36	; 0x24
  21eb5c:	4619      	mov	r1, r3
  21eb5e:	68fb      	ldr	r3, [r7, #12]
  21eb60:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  21eb62:	461a      	mov	r2, r3
  21eb64:	88fb      	ldrh	r3, [r7, #6]
  21eb66:	f7fa fb97 	bl	219298 <HAL_DMA_Start_IT>
  21eb6a:	4603      	mov	r3, r0
  21eb6c:	2b00      	cmp	r3, #0
  21eb6e:	d00c      	beq.n	21eb8a <UART_Start_Receive_DMA+0x8a>
    {
      /* Set error code to DMA */
      huart->ErrorCode = HAL_UART_ERROR_DMA;
  21eb70:	68fb      	ldr	r3, [r7, #12]
  21eb72:	2210      	movs	r2, #16
  21eb74:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

      __HAL_UNLOCK(huart);
  21eb78:	68fb      	ldr	r3, [r7, #12]
  21eb7a:	2200      	movs	r2, #0
  21eb7c:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

      /* Restore huart->gState to ready */
      huart->gState = HAL_UART_STATE_READY;
  21eb80:	68fb      	ldr	r3, [r7, #12]
  21eb82:	2220      	movs	r2, #32
  21eb84:	679a      	str	r2, [r3, #120]	; 0x78

      return HAL_ERROR;
  21eb86:	2301      	movs	r3, #1
  21eb88:	e01c      	b.n	21ebc4 <UART_Start_Receive_DMA+0xc4>
    }
  }
  __HAL_UNLOCK(huart);
  21eb8a:	68fb      	ldr	r3, [r7, #12]
  21eb8c:	2200      	movs	r2, #0
  21eb8e:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74

  /* Enable the UART Parity Error Interrupt */
  SET_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  21eb92:	68fb      	ldr	r3, [r7, #12]
  21eb94:	681b      	ldr	r3, [r3, #0]
  21eb96:	68fa      	ldr	r2, [r7, #12]
  21eb98:	6812      	ldr	r2, [r2, #0]
  21eb9a:	6812      	ldr	r2, [r2, #0]
  21eb9c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  21eba0:	601a      	str	r2, [r3, #0]

  /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
  SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21eba2:	68fb      	ldr	r3, [r7, #12]
  21eba4:	681b      	ldr	r3, [r3, #0]
  21eba6:	68fa      	ldr	r2, [r7, #12]
  21eba8:	6812      	ldr	r2, [r2, #0]
  21ebaa:	6892      	ldr	r2, [r2, #8]
  21ebac:	f042 0201 	orr.w	r2, r2, #1
  21ebb0:	609a      	str	r2, [r3, #8]

  /* Enable the DMA transfer for the receiver request by setting the DMAR bit
  in the UART CR3 register */
  SET_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  21ebb2:	68fb      	ldr	r3, [r7, #12]
  21ebb4:	681b      	ldr	r3, [r3, #0]
  21ebb6:	68fa      	ldr	r2, [r7, #12]
  21ebb8:	6812      	ldr	r2, [r2, #0]
  21ebba:	6892      	ldr	r2, [r2, #8]
  21ebbc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
  21ebc0:	609a      	str	r2, [r3, #8]

  return HAL_OK;
  21ebc2:	2300      	movs	r3, #0
}
  21ebc4:	4618      	mov	r0, r3
  21ebc6:	3710      	adds	r7, #16
  21ebc8:	46bd      	mov	sp, r7
  21ebca:	bd80      	pop	{r7, pc}
  21ebcc:	0021ec61 	.word	0x0021ec61
  21ebd0:	0021ecf5 	.word	0x0021ecf5
  21ebd4:	0021ed2d 	.word	0x0021ed2d

0021ebd8 <UART_EndTxTransfer>:
  * @brief  End ongoing Tx transfer on UART peripheral (following error detection or Transmit completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndTxTransfer(UART_HandleTypeDef *huart)
{
  21ebd8:	b480      	push	{r7}
  21ebda:	b083      	sub	sp, #12
  21ebdc:	af00      	add	r7, sp, #0
  21ebde:	6078      	str	r0, [r7, #4]
  /* Disable TXEIE and TCIE interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE | USART_CR1_TCIE));
  21ebe0:	687b      	ldr	r3, [r7, #4]
  21ebe2:	681b      	ldr	r3, [r3, #0]
  21ebe4:	687a      	ldr	r2, [r7, #4]
  21ebe6:	6812      	ldr	r2, [r2, #0]
  21ebe8:	6812      	ldr	r2, [r2, #0]
  21ebea:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
  21ebee:	601a      	str	r2, [r3, #0]

  /* At end of Tx process, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
  21ebf0:	687b      	ldr	r3, [r7, #4]
  21ebf2:	2220      	movs	r2, #32
  21ebf4:	679a      	str	r2, [r3, #120]	; 0x78
}
  21ebf6:	bf00      	nop
  21ebf8:	370c      	adds	r7, #12
  21ebfa:	46bd      	mov	sp, r7
  21ebfc:	f85d 7b04 	ldr.w	r7, [sp], #4
  21ec00:	4770      	bx	lr

0021ec02 <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  21ec02:	b480      	push	{r7}
  21ec04:	b083      	sub	sp, #12
  21ec06:	af00      	add	r7, sp, #0
  21ec08:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
  21ec0a:	687b      	ldr	r3, [r7, #4]
  21ec0c:	681b      	ldr	r3, [r3, #0]
  21ec0e:	687a      	ldr	r2, [r7, #4]
  21ec10:	6812      	ldr	r2, [r2, #0]
  21ec12:	6812      	ldr	r2, [r2, #0]
  21ec14:	f422 7290 	bic.w	r2, r2, #288	; 0x120
  21ec18:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21ec1a:	687b      	ldr	r3, [r7, #4]
  21ec1c:	681b      	ldr	r3, [r3, #0]
  21ec1e:	687a      	ldr	r2, [r7, #4]
  21ec20:	6812      	ldr	r2, [r2, #0]
  21ec22:	6892      	ldr	r2, [r2, #8]
  21ec24:	f022 0201 	bic.w	r2, r2, #1
  21ec28:	609a      	str	r2, [r3, #8]

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  21ec2a:	687b      	ldr	r3, [r7, #4]
  21ec2c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  21ec2e:	2b01      	cmp	r3, #1
  21ec30:	d107      	bne.n	21ec42 <UART_EndRxTransfer+0x40>
  {
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  21ec32:	687b      	ldr	r3, [r7, #4]
  21ec34:	681b      	ldr	r3, [r3, #0]
  21ec36:	687a      	ldr	r2, [r7, #4]
  21ec38:	6812      	ldr	r2, [r2, #0]
  21ec3a:	6812      	ldr	r2, [r2, #0]
  21ec3c:	f022 0210 	bic.w	r2, r2, #16
  21ec40:	601a      	str	r2, [r3, #0]
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
  21ec42:	687b      	ldr	r3, [r7, #4]
  21ec44:	2220      	movs	r2, #32
  21ec46:	67da      	str	r2, [r3, #124]	; 0x7c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
  21ec48:	687b      	ldr	r3, [r7, #4]
  21ec4a:	2200      	movs	r2, #0
  21ec4c:	661a      	str	r2, [r3, #96]	; 0x60

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
  21ec4e:	687b      	ldr	r3, [r7, #4]
  21ec50:	2200      	movs	r2, #0
  21ec52:	665a      	str	r2, [r3, #100]	; 0x64
}
  21ec54:	bf00      	nop
  21ec56:	370c      	adds	r7, #12
  21ec58:	46bd      	mov	sp, r7
  21ec5a:	f85d 7b04 	ldr.w	r7, [sp], #4
  21ec5e:	4770      	bx	lr

0021ec60 <UART_DMAReceiveCplt>:
  * @brief DMA UART receive process complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAReceiveCplt(DMA_HandleTypeDef *hdma)
{
  21ec60:	b580      	push	{r7, lr}
  21ec62:	b084      	sub	sp, #16
  21ec64:	af00      	add	r7, sp, #0
  21ec66:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
  21ec68:	687b      	ldr	r3, [r7, #4]
  21ec6a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21ec6c:	60fb      	str	r3, [r7, #12]

  /* DMA Normal mode */
  if (hdma->Init.Mode != DMA_CIRCULAR)
  21ec6e:	687b      	ldr	r3, [r7, #4]
  21ec70:	69db      	ldr	r3, [r3, #28]
  21ec72:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  21ec76:	d02a      	beq.n	21ecce <UART_DMAReceiveCplt+0x6e>
  {
    huart->RxXferCount = 0U;
  21ec78:	68fb      	ldr	r3, [r7, #12]
  21ec7a:	2200      	movs	r2, #0
  21ec7c:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a

    /* Disable PE and ERR (Frame error, noise error, overrun error) interrupts */
    CLEAR_BIT(huart->Instance->CR1, USART_CR1_PEIE);
  21ec80:	68fb      	ldr	r3, [r7, #12]
  21ec82:	681b      	ldr	r3, [r3, #0]
  21ec84:	68fa      	ldr	r2, [r7, #12]
  21ec86:	6812      	ldr	r2, [r2, #0]
  21ec88:	6812      	ldr	r2, [r2, #0]
  21ec8a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
  21ec8e:	601a      	str	r2, [r3, #0]
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
  21ec90:	68fb      	ldr	r3, [r7, #12]
  21ec92:	681b      	ldr	r3, [r3, #0]
  21ec94:	68fa      	ldr	r2, [r7, #12]
  21ec96:	6812      	ldr	r2, [r2, #0]
  21ec98:	6892      	ldr	r2, [r2, #8]
  21ec9a:	f022 0201 	bic.w	r2, r2, #1
  21ec9e:	609a      	str	r2, [r3, #8]

    /* Disable the DMA transfer for the receiver request by resetting the DMAR bit
       in the UART CR3 register */
    CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
  21eca0:	68fb      	ldr	r3, [r7, #12]
  21eca2:	681b      	ldr	r3, [r3, #0]
  21eca4:	68fa      	ldr	r2, [r7, #12]
  21eca6:	6812      	ldr	r2, [r2, #0]
  21eca8:	6892      	ldr	r2, [r2, #8]
  21ecaa:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  21ecae:	609a      	str	r2, [r3, #8]

    /* At end of Rx process, restore huart->RxState to Ready */
    huart->RxState = HAL_UART_STATE_READY;
  21ecb0:	68fb      	ldr	r3, [r7, #12]
  21ecb2:	2220      	movs	r2, #32
  21ecb4:	67da      	str	r2, [r3, #124]	; 0x7c

    /* If Reception till IDLE event has been selected, Disable IDLE Interrupt */
    if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  21ecb6:	68fb      	ldr	r3, [r7, #12]
  21ecb8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  21ecba:	2b01      	cmp	r3, #1
  21ecbc:	d107      	bne.n	21ecce <UART_DMAReceiveCplt+0x6e>
    {
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
  21ecbe:	68fb      	ldr	r3, [r7, #12]
  21ecc0:	681b      	ldr	r3, [r3, #0]
  21ecc2:	68fa      	ldr	r2, [r7, #12]
  21ecc4:	6812      	ldr	r2, [r2, #0]
  21ecc6:	6812      	ldr	r2, [r2, #0]
  21ecc8:	f022 0210 	bic.w	r2, r2, #16
  21eccc:	601a      	str	r2, [r3, #0]
    }
  }

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  21ecce:	68fb      	ldr	r3, [r7, #12]
  21ecd0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  21ecd2:	2b01      	cmp	r3, #1
  21ecd4:	d107      	bne.n	21ece6 <UART_DMAReceiveCplt+0x86>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize);
  21ecd6:	68fb      	ldr	r3, [r7, #12]
  21ecd8:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
  21ecdc:	4619      	mov	r1, r3
  21ecde:	68f8      	ldr	r0, [r7, #12]
  21ece0:	f7ff fb30 	bl	21e344 <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx complete callback*/
    HAL_UART_RxCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
  21ece4:	e002      	b.n	21ecec <UART_DMAReceiveCplt+0x8c>
    HAL_UART_RxCpltCallback(huart);
  21ece6:	68f8      	ldr	r0, [r7, #12]
  21ece8:	f7fa f80c 	bl	218d04 <HAL_UART_RxCpltCallback>
}
  21ecec:	bf00      	nop
  21ecee:	3710      	adds	r7, #16
  21ecf0:	46bd      	mov	sp, r7
  21ecf2:	bd80      	pop	{r7, pc}

0021ecf4 <UART_DMARxHalfCplt>:
  * @brief DMA UART receive process half complete callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
  21ecf4:	b580      	push	{r7, lr}
  21ecf6:	b084      	sub	sp, #16
  21ecf8:	af00      	add	r7, sp, #0
  21ecfa:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
  21ecfc:	687b      	ldr	r3, [r7, #4]
  21ecfe:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21ed00:	60fb      	str	r3, [r7, #12]

  /* Check current reception Mode :
     If Reception till IDLE event has been selected : use Rx Event callback */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
  21ed02:	68fb      	ldr	r3, [r7, #12]
  21ed04:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  21ed06:	2b01      	cmp	r3, #1
  21ed08:	d109      	bne.n	21ed1e <UART_DMARxHalfCplt+0x2a>
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    /*Call registered Rx Event callback*/
    huart->RxEventCallback(huart, huart->RxXferSize / 2U);
#else
    /*Call legacy weak Rx Event callback*/
    HAL_UARTEx_RxEventCallback(huart, huart->RxXferSize / 2U);
  21ed0a:	68fb      	ldr	r3, [r7, #12]
  21ed0c:	f8b3 3058 	ldrh.w	r3, [r3, #88]	; 0x58
  21ed10:	085b      	lsrs	r3, r3, #1
  21ed12:	b29b      	uxth	r3, r3
  21ed14:	4619      	mov	r1, r3
  21ed16:	68f8      	ldr	r0, [r7, #12]
  21ed18:	f7ff fb14 	bl	21e344 <HAL_UARTEx_RxEventCallback>
#else
    /*Call legacy weak Rx Half complete callback*/
    HAL_UART_RxHalfCpltCallback(huart);
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }
}
  21ed1c:	e002      	b.n	21ed24 <UART_DMARxHalfCplt+0x30>
    HAL_UART_RxHalfCpltCallback(huart);
  21ed1e:	68f8      	ldr	r0, [r7, #12]
  21ed20:	f7ff fb06 	bl	21e330 <HAL_UART_RxHalfCpltCallback>
}
  21ed24:	bf00      	nop
  21ed26:	3710      	adds	r7, #16
  21ed28:	46bd      	mov	sp, r7
  21ed2a:	bd80      	pop	{r7, pc}

0021ed2c <UART_DMAError>:
  * @brief DMA UART communication error callback.
  * @param hdma DMA handle.
  * @retval None
  */
static void UART_DMAError(DMA_HandleTypeDef *hdma)
{
  21ed2c:	b580      	push	{r7, lr}
  21ed2e:	b086      	sub	sp, #24
  21ed30:	af00      	add	r7, sp, #0
  21ed32:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
  21ed34:	687b      	ldr	r3, [r7, #4]
  21ed36:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21ed38:	617b      	str	r3, [r7, #20]

  const HAL_UART_StateTypeDef gstate = huart->gState;
  21ed3a:	697b      	ldr	r3, [r7, #20]
  21ed3c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  21ed3e:	613b      	str	r3, [r7, #16]
  const HAL_UART_StateTypeDef rxstate = huart->RxState;
  21ed40:	697b      	ldr	r3, [r7, #20]
  21ed42:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
  21ed44:	60fb      	str	r3, [r7, #12]

  /* Stop UART DMA Tx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAT)) &&
  21ed46:	697b      	ldr	r3, [r7, #20]
  21ed48:	681b      	ldr	r3, [r3, #0]
  21ed4a:	689b      	ldr	r3, [r3, #8]
  21ed4c:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21ed50:	2b80      	cmp	r3, #128	; 0x80
  21ed52:	d109      	bne.n	21ed68 <UART_DMAError+0x3c>
  21ed54:	693b      	ldr	r3, [r7, #16]
  21ed56:	2b21      	cmp	r3, #33	; 0x21
  21ed58:	d106      	bne.n	21ed68 <UART_DMAError+0x3c>
      (gstate == HAL_UART_STATE_BUSY_TX))
  {
    huart->TxXferCount = 0U;
  21ed5a:	697b      	ldr	r3, [r7, #20]
  21ed5c:	2200      	movs	r2, #0
  21ed5e:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
    UART_EndTxTransfer(huart);
  21ed62:	6978      	ldr	r0, [r7, #20]
  21ed64:	f7ff ff38 	bl	21ebd8 <UART_EndTxTransfer>
  }

  /* Stop UART DMA Rx request if ongoing */
  if ((HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR)) &&
  21ed68:	697b      	ldr	r3, [r7, #20]
  21ed6a:	681b      	ldr	r3, [r3, #0]
  21ed6c:	689b      	ldr	r3, [r3, #8]
  21ed6e:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21ed72:	2b40      	cmp	r3, #64	; 0x40
  21ed74:	d109      	bne.n	21ed8a <UART_DMAError+0x5e>
  21ed76:	68fb      	ldr	r3, [r7, #12]
  21ed78:	2b22      	cmp	r3, #34	; 0x22
  21ed7a:	d106      	bne.n	21ed8a <UART_DMAError+0x5e>
      (rxstate == HAL_UART_STATE_BUSY_RX))
  {
    huart->RxXferCount = 0U;
  21ed7c:	697b      	ldr	r3, [r7, #20]
  21ed7e:	2200      	movs	r2, #0
  21ed80:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
    UART_EndRxTransfer(huart);
  21ed84:	6978      	ldr	r0, [r7, #20]
  21ed86:	f7ff ff3c 	bl	21ec02 <UART_EndRxTransfer>
  }

  huart->ErrorCode |= HAL_UART_ERROR_DMA;
  21ed8a:	697b      	ldr	r3, [r7, #20]
  21ed8c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
  21ed90:	f043 0210 	orr.w	r2, r3, #16
  21ed94:	697b      	ldr	r3, [r7, #20]
  21ed96:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
  21ed9a:	6978      	ldr	r0, [r7, #20]
  21ed9c:	f7f9 ffc4 	bl	218d28 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
  21eda0:	bf00      	nop
  21eda2:	3718      	adds	r7, #24
  21eda4:	46bd      	mov	sp, r7
  21eda6:	bd80      	pop	{r7, pc}

0021eda8 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
  21eda8:	b580      	push	{r7, lr}
  21edaa:	b084      	sub	sp, #16
  21edac:	af00      	add	r7, sp, #0
  21edae:	6078      	str	r0, [r7, #4]
  UART_HandleTypeDef *huart = (UART_HandleTypeDef *)(hdma->Parent);
  21edb0:	687b      	ldr	r3, [r7, #4]
  21edb2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  21edb4:	60fb      	str	r3, [r7, #12]
  huart->RxXferCount = 0U;
  21edb6:	68fb      	ldr	r3, [r7, #12]
  21edb8:	2200      	movs	r2, #0
  21edba:	f8a3 205a 	strh.w	r2, [r3, #90]	; 0x5a
  huart->TxXferCount = 0U;
  21edbe:	68fb      	ldr	r3, [r7, #12]
  21edc0:	2200      	movs	r2, #0
  21edc2:	f8a3 2052 	strh.w	r2, [r3, #82]	; 0x52
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered error callback*/
  huart->ErrorCallback(huart);
#else
  /*Call legacy weak error callback*/
  HAL_UART_ErrorCallback(huart);
  21edc6:	68f8      	ldr	r0, [r7, #12]
  21edc8:	f7f9 ffae 	bl	218d28 <HAL_UART_ErrorCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
  21edcc:	bf00      	nop
  21edce:	3710      	adds	r7, #16
  21edd0:	46bd      	mov	sp, r7
  21edd2:	bd80      	pop	{r7, pc}

0021edd4 <UART_EndTransmit_IT>:
  * @param  huart pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  21edd4:	b580      	push	{r7, lr}
  21edd6:	b082      	sub	sp, #8
  21edd8:	af00      	add	r7, sp, #0
  21edda:	6078      	str	r0, [r7, #4]
  /* Disable the UART Transmit Complete Interrupt */
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
  21eddc:	687b      	ldr	r3, [r7, #4]
  21edde:	681b      	ldr	r3, [r3, #0]
  21ede0:	687a      	ldr	r2, [r7, #4]
  21ede2:	6812      	ldr	r2, [r2, #0]
  21ede4:	6812      	ldr	r2, [r2, #0]
  21ede6:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  21edea:	601a      	str	r2, [r3, #0]

  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
  21edec:	687b      	ldr	r3, [r7, #4]
  21edee:	2220      	movs	r2, #32
  21edf0:	679a      	str	r2, [r3, #120]	; 0x78

  /* Cleat TxISR function pointer */
  huart->TxISR = NULL;
  21edf2:	687b      	ldr	r3, [r7, #4]
  21edf4:	2200      	movs	r2, #0
  21edf6:	669a      	str	r2, [r3, #104]	; 0x68
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
  /*Call registered Tx complete callback*/
  huart->TxCpltCallback(huart);
#else
  /*Call legacy weak Tx complete callback*/
  HAL_UART_TxCpltCallback(huart);
  21edf8:	6878      	ldr	r0, [r7, #4]
  21edfa:	f7f9 ff55 	bl	218ca8 <HAL_UART_TxCpltCallback>
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
}
  21edfe:	bf00      	nop
  21ee00:	3708      	adds	r7, #8
  21ee02:	46bd      	mov	sp, r7
  21ee04:	bd80      	pop	{r7, pc}
	...

0021ee08 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
  21ee08:	b480      	push	{r7}
  21ee0a:	b085      	sub	sp, #20
  21ee0c:	af00      	add	r7, sp, #0
  21ee0e:	6078      	str	r0, [r7, #4]
  21ee10:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
  21ee12:	2300      	movs	r3, #0
  21ee14:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
  21ee16:	2300      	movs	r3, #0
  21ee18:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
  21ee1a:	683b      	ldr	r3, [r7, #0]
  21ee1c:	681b      	ldr	r3, [r3, #0]
  21ee1e:	2b01      	cmp	r3, #1
  21ee20:	d027      	beq.n	21ee72 <FMC_SDRAM_Init+0x6a>
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
  21ee22:	687b      	ldr	r3, [r7, #4]
  21ee24:	681b      	ldr	r3, [r3, #0]
  21ee26:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
  21ee28:	68fa      	ldr	r2, [r7, #12]
  21ee2a:	4b2f      	ldr	r3, [pc, #188]	; (21eee8 <FMC_SDRAM_Init+0xe0>)
  21ee2c:	4013      	ands	r3, r2
  21ee2e:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
  21ee30:	683b      	ldr	r3, [r7, #0]
  21ee32:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
  21ee34:	683b      	ldr	r3, [r7, #0]
  21ee36:	689b      	ldr	r3, [r3, #8]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
  21ee38:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
  21ee3a:	683b      	ldr	r3, [r7, #0]
  21ee3c:	68db      	ldr	r3, [r3, #12]
                        Init->RowBitsNumber      |\
  21ee3e:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
  21ee40:	683b      	ldr	r3, [r7, #0]
  21ee42:	691b      	ldr	r3, [r3, #16]
                        Init->MemoryDataWidth    |\
  21ee44:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
  21ee46:	683b      	ldr	r3, [r7, #0]
  21ee48:	695b      	ldr	r3, [r3, #20]
                        Init->InternalBankNumber |\
  21ee4a:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
  21ee4c:	683b      	ldr	r3, [r7, #0]
  21ee4e:	699b      	ldr	r3, [r3, #24]
                        Init->CASLatency         |\
  21ee50:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
  21ee52:	683b      	ldr	r3, [r7, #0]
  21ee54:	69db      	ldr	r3, [r3, #28]
                        Init->WriteProtection    |\
  21ee56:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
  21ee58:	683b      	ldr	r3, [r7, #0]
  21ee5a:	6a1b      	ldr	r3, [r3, #32]
                        Init->SDClockPeriod      |\
  21ee5c:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay
  21ee5e:	683b      	ldr	r3, [r7, #0]
  21ee60:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
  21ee62:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
  21ee64:	68fa      	ldr	r2, [r7, #12]
  21ee66:	4313      	orrs	r3, r2
  21ee68:	60fb      	str	r3, [r7, #12]
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
  21ee6a:	687b      	ldr	r3, [r7, #4]
  21ee6c:	68fa      	ldr	r2, [r7, #12]
  21ee6e:	601a      	str	r2, [r3, #0]
  21ee70:	e032      	b.n	21eed8 <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
  21ee72:	687b      	ldr	r3, [r7, #4]
  21ee74:	681b      	ldr	r3, [r3, #0]
  21ee76:	60fb      	str	r3, [r7, #12]
    
    /* Clear SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
  21ee78:	68fb      	ldr	r3, [r7, #12]
  21ee7a:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
  21ee7e:	60fb      	str	r3, [r7, #12]
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
  21ee80:	683b      	ldr	r3, [r7, #0]
  21ee82:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
  21ee84:	683b      	ldr	r3, [r7, #0]
  21ee86:	6a1b      	ldr	r3, [r3, #32]
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
  21ee88:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay);
  21ee8a:	683b      	ldr	r3, [r7, #0]
  21ee8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
  21ee8e:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
  21ee90:	68fa      	ldr	r2, [r7, #12]
  21ee92:	4313      	orrs	r3, r2
  21ee94:	60fb      	str	r3, [r7, #12]
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
  21ee96:	687b      	ldr	r3, [r7, #4]
  21ee98:	685b      	ldr	r3, [r3, #4]
  21ee9a:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
  21ee9c:	68ba      	ldr	r2, [r7, #8]
  21ee9e:	4b12      	ldr	r3, [pc, #72]	; (21eee8 <FMC_SDRAM_Init+0xe0>)
  21eea0:	4013      	ands	r3, r2
  21eea2:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
  21eea4:	683b      	ldr	r3, [r7, #0]
  21eea6:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber       |\
  21eea8:	683b      	ldr	r3, [r7, #0]
  21eeaa:	689b      	ldr	r3, [r3, #8]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
  21eeac:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth     |\
  21eeae:	683b      	ldr	r3, [r7, #0]
  21eeb0:	68db      	ldr	r3, [r3, #12]
                       Init->RowBitsNumber       |\
  21eeb2:	431a      	orrs	r2, r3
                       Init->InternalBankNumber  |\
  21eeb4:	683b      	ldr	r3, [r7, #0]
  21eeb6:	691b      	ldr	r3, [r3, #16]
                       Init->MemoryDataWidth     |\
  21eeb8:	431a      	orrs	r2, r3
                       Init->CASLatency          |\
  21eeba:	683b      	ldr	r3, [r7, #0]
  21eebc:	695b      	ldr	r3, [r3, #20]
                       Init->InternalBankNumber  |\
  21eebe:	431a      	orrs	r2, r3
                       Init->WriteProtection);
  21eec0:	683b      	ldr	r3, [r7, #0]
  21eec2:	699b      	ldr	r3, [r3, #24]
                       Init->CASLatency          |\
  21eec4:	4313      	orrs	r3, r2
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
  21eec6:	68ba      	ldr	r2, [r7, #8]
  21eec8:	4313      	orrs	r3, r2
  21eeca:	60bb      	str	r3, [r7, #8]

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
  21eecc:	687b      	ldr	r3, [r7, #4]
  21eece:	68fa      	ldr	r2, [r7, #12]
  21eed0:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
  21eed2:	687b      	ldr	r3, [r7, #4]
  21eed4:	68ba      	ldr	r2, [r7, #8]
  21eed6:	605a      	str	r2, [r3, #4]
  }
  
  return HAL_OK;
  21eed8:	2300      	movs	r3, #0
}
  21eeda:	4618      	mov	r0, r3
  21eedc:	3714      	adds	r7, #20
  21eede:	46bd      	mov	sp, r7
  21eee0:	f85d 7b04 	ldr.w	r7, [sp], #4
  21eee4:	4770      	bx	lr
  21eee6:	bf00      	nop
  21eee8:	ffff8000 	.word	0xffff8000

0021eeec <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
  21eeec:	b480      	push	{r7}
  21eeee:	b087      	sub	sp, #28
  21eef0:	af00      	add	r7, sp, #0
  21eef2:	60f8      	str	r0, [r7, #12]
  21eef4:	60b9      	str	r1, [r7, #8]
  21eef6:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
  21eef8:	2300      	movs	r3, #0
  21eefa:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
  21eefc:	2300      	movs	r3, #0
  21eefe:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
  21ef00:	687b      	ldr	r3, [r7, #4]
  21ef02:	2b01      	cmp	r3, #1
  21ef04:	d02e      	beq.n	21ef64 <FMC_SDRAM_Timing_Init+0x78>
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
  21ef06:	68fb      	ldr	r3, [r7, #12]
  21ef08:	689b      	ldr	r3, [r3, #8]
  21ef0a:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
  21ef0c:	697b      	ldr	r3, [r7, #20]
  21ef0e:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
  21ef12:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
  21ef14:	68bb      	ldr	r3, [r7, #8]
  21ef16:	681b      	ldr	r3, [r3, #0]
  21ef18:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
  21ef1a:	68bb      	ldr	r3, [r7, #8]
  21ef1c:	685b      	ldr	r3, [r3, #4]
  21ef1e:	3b01      	subs	r3, #1
  21ef20:	011b      	lsls	r3, r3, #4
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
  21ef22:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
  21ef24:	68bb      	ldr	r3, [r7, #8]
  21ef26:	689b      	ldr	r3, [r3, #8]
  21ef28:	3b01      	subs	r3, #1
  21ef2a:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
  21ef2c:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
  21ef2e:	68bb      	ldr	r3, [r7, #8]
  21ef30:	68db      	ldr	r3, [r3, #12]
  21ef32:	3b01      	subs	r3, #1
  21ef34:	031b      	lsls	r3, r3, #12
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
  21ef36:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
  21ef38:	68bb      	ldr	r3, [r7, #8]
  21ef3a:	691b      	ldr	r3, [r3, #16]
  21ef3c:	3b01      	subs	r3, #1
  21ef3e:	041b      	lsls	r3, r3, #16
                       (((Timing->RowCycleDelay)-1) << 12)       |\
  21ef40:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
  21ef42:	68bb      	ldr	r3, [r7, #8]
  21ef44:	695b      	ldr	r3, [r3, #20]
  21ef46:	3b01      	subs	r3, #1
  21ef48:	051b      	lsls	r3, r3, #20
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
  21ef4a:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1) << 24));
  21ef4c:	68bb      	ldr	r3, [r7, #8]
  21ef4e:	699b      	ldr	r3, [r3, #24]
  21ef50:	3b01      	subs	r3, #1
  21ef52:	061b      	lsls	r3, r3, #24
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
  21ef54:	4313      	orrs	r3, r2
  21ef56:	697a      	ldr	r2, [r7, #20]
  21ef58:	4313      	orrs	r3, r2
  21ef5a:	617b      	str	r3, [r7, #20]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
  21ef5c:	68fb      	ldr	r3, [r7, #12]
  21ef5e:	697a      	ldr	r2, [r7, #20]
  21ef60:	609a      	str	r2, [r3, #8]
  21ef62:	e039      	b.n	21efd8 <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
  21ef64:	68fb      	ldr	r3, [r7, #12]
  21ef66:	689b      	ldr	r3, [r3, #8]
  21ef68:	617b      	str	r3, [r7, #20]
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
  21ef6a:	697a      	ldr	r2, [r7, #20]
  21ef6c:	4b1e      	ldr	r3, [pc, #120]	; (21efe8 <FMC_SDRAM_Timing_Init+0xfc>)
  21ef6e:	4013      	ands	r3, r2
  21ef70:	617b      	str	r3, [r7, #20]
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
  21ef72:	68bb      	ldr	r3, [r7, #8]
  21ef74:	68db      	ldr	r3, [r3, #12]
  21ef76:	3b01      	subs	r3, #1
  21ef78:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
  21ef7a:	68bb      	ldr	r3, [r7, #8]
  21ef7c:	695b      	ldr	r3, [r3, #20]
  21ef7e:	3b01      	subs	r3, #1
  21ef80:	051b      	lsls	r3, r3, #20
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
  21ef82:	4313      	orrs	r3, r2
  21ef84:	697a      	ldr	r2, [r7, #20]
  21ef86:	4313      	orrs	r3, r2
  21ef88:	617b      	str	r3, [r7, #20]
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
  21ef8a:	68fb      	ldr	r3, [r7, #12]
  21ef8c:	68db      	ldr	r3, [r3, #12]
  21ef8e:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
  21ef90:	693b      	ldr	r3, [r7, #16]
  21ef92:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
  21ef96:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
  21ef98:	68bb      	ldr	r3, [r7, #8]
  21ef9a:	681b      	ldr	r3, [r3, #0]
  21ef9c:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
  21ef9e:	68bb      	ldr	r3, [r7, #8]
  21efa0:	685b      	ldr	r3, [r3, #4]
  21efa2:	3b01      	subs	r3, #1
  21efa4:	011b      	lsls	r3, r3, #4
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
  21efa6:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
  21efa8:	68bb      	ldr	r3, [r7, #8]
  21efaa:	689b      	ldr	r3, [r3, #8]
  21efac:	3b01      	subs	r3, #1
  21efae:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
  21efb0:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
  21efb2:	68bb      	ldr	r3, [r7, #8]
  21efb4:	691b      	ldr	r3, [r3, #16]
  21efb6:	3b01      	subs	r3, #1
  21efb8:	041b      	lsls	r3, r3, #16
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
  21efba:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1) << 24));   
  21efbc:	68bb      	ldr	r3, [r7, #8]
  21efbe:	699b      	ldr	r3, [r3, #24]
  21efc0:	3b01      	subs	r3, #1
  21efc2:	061b      	lsls	r3, r3, #24
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
  21efc4:	4313      	orrs	r3, r2
  21efc6:	693a      	ldr	r2, [r7, #16]
  21efc8:	4313      	orrs	r3, r2
  21efca:	613b      	str	r3, [r7, #16]

    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
  21efcc:	68fb      	ldr	r3, [r7, #12]
  21efce:	697a      	ldr	r2, [r7, #20]
  21efd0:	609a      	str	r2, [r3, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
  21efd2:	68fb      	ldr	r3, [r7, #12]
  21efd4:	693a      	ldr	r2, [r7, #16]
  21efd6:	60da      	str	r2, [r3, #12]
  }
  
  return HAL_OK;
  21efd8:	2300      	movs	r3, #0
}
  21efda:	4618      	mov	r0, r3
  21efdc:	371c      	adds	r7, #28
  21efde:	46bd      	mov	sp, r7
  21efe0:	f85d 7b04 	ldr.w	r7, [sp], #4
  21efe4:	4770      	bx	lr
  21efe6:	bf00      	nop
  21efe8:	ff0f0fff 	.word	0xff0f0fff

0021efec <FMC_SDRAM_SendCommand>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{ 
  21efec:	b480      	push	{r7}
  21efee:	b085      	sub	sp, #20
  21eff0:	af00      	add	r7, sp, #0
  21eff2:	60f8      	str	r0, [r7, #12]
  21eff4:	60b9      	str	r1, [r7, #8]
  21eff6:	607a      	str	r2, [r7, #4]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  MODIFY_REG(Device->SDCMR, (FMC_SDCMR_MODE | FMC_SDCMR_CTB2 | FMC_SDCMR_CTB1 | 
  21eff8:	68fb      	ldr	r3, [r7, #12]
  21effa:	691a      	ldr	r2, [r3, #16]
  21effc:	4b0c      	ldr	r3, [pc, #48]	; (21f030 <FMC_SDRAM_SendCommand+0x44>)
  21effe:	4013      	ands	r3, r2
  21f000:	68ba      	ldr	r2, [r7, #8]
  21f002:	6811      	ldr	r1, [r2, #0]
  21f004:	68ba      	ldr	r2, [r7, #8]
  21f006:	6852      	ldr	r2, [r2, #4]
  21f008:	4311      	orrs	r1, r2
  21f00a:	68ba      	ldr	r2, [r7, #8]
  21f00c:	6892      	ldr	r2, [r2, #8]
  21f00e:	3a01      	subs	r2, #1
  21f010:	0152      	lsls	r2, r2, #5
  21f012:	4311      	orrs	r1, r2
  21f014:	68ba      	ldr	r2, [r7, #8]
  21f016:	68d2      	ldr	r2, [r2, #12]
  21f018:	0252      	lsls	r2, r2, #9
  21f01a:	430a      	orrs	r2, r1
  21f01c:	431a      	orrs	r2, r3
  21f01e:	68fb      	ldr	r3, [r7, #12]
  21f020:	611a      	str	r2, [r3, #16]
             FMC_SDCMR_NRFS | FMC_SDCMR_MRD), ((Command->CommandMode) | 
             (Command->CommandTarget) | (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos) |
             ((Command->ModeRegisterDefinition) << FMC_SDCMR_MRD_Pos)));
  
  return HAL_OK;  
  21f022:	2300      	movs	r3, #0
}
  21f024:	4618      	mov	r0, r3
  21f026:	3714      	adds	r7, #20
  21f028:	46bd      	mov	sp, r7
  21f02a:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f02e:	4770      	bx	lr
  21f030:	ffc00000 	.word	0xffc00000

0021f034 <SDMMC_Init>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  Init: SDMMC initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_Init(SDMMC_TypeDef *SDMMCx, SDMMC_InitTypeDef Init)
{
  21f034:	b084      	sub	sp, #16
  21f036:	b480      	push	{r7}
  21f038:	b085      	sub	sp, #20
  21f03a:	af00      	add	r7, sp, #0
  21f03c:	6078      	str	r0, [r7, #4]
  21f03e:	f107 001c 	add.w	r0, r7, #28
  21f042:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t tmpreg = 0;
  21f046:	2300      	movs	r3, #0
  21f048:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
  
  /* Set SDMMC configuration parameters */
  tmpreg |= (Init.ClockEdge           |\
  21f04a:	69fa      	ldr	r2, [r7, #28]
             Init.ClockBypass         |\
  21f04c:	6a3b      	ldr	r3, [r7, #32]
  tmpreg |= (Init.ClockEdge           |\
  21f04e:	431a      	orrs	r2, r3
             Init.ClockPowerSave      |\
  21f050:	6a7b      	ldr	r3, [r7, #36]	; 0x24
             Init.ClockBypass         |\
  21f052:	431a      	orrs	r2, r3
             Init.BusWide             |\
  21f054:	6abb      	ldr	r3, [r7, #40]	; 0x28
             Init.ClockPowerSave      |\
  21f056:	431a      	orrs	r2, r3
             Init.HardwareFlowControl |\
  21f058:	6afb      	ldr	r3, [r7, #44]	; 0x2c
             Init.BusWide             |\
  21f05a:	431a      	orrs	r2, r3
             Init.ClockDiv
  21f05c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
             Init.HardwareFlowControl |\
  21f05e:	4313      	orrs	r3, r2
  tmpreg |= (Init.ClockEdge           |\
  21f060:	68fa      	ldr	r2, [r7, #12]
  21f062:	4313      	orrs	r3, r2
  21f064:	60fb      	str	r3, [r7, #12]
             ); 
  
  /* Write to SDMMC CLKCR */
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);  
  21f066:	687b      	ldr	r3, [r7, #4]
  21f068:	685a      	ldr	r2, [r3, #4]
  21f06a:	4b07      	ldr	r3, [pc, #28]	; (21f088 <SDMMC_Init+0x54>)
  21f06c:	4013      	ands	r3, r2
  21f06e:	68fa      	ldr	r2, [r7, #12]
  21f070:	431a      	orrs	r2, r3
  21f072:	687b      	ldr	r3, [r7, #4]
  21f074:	605a      	str	r2, [r3, #4]

  return HAL_OK;
  21f076:	2300      	movs	r3, #0
}
  21f078:	4618      	mov	r0, r3
  21f07a:	3714      	adds	r7, #20
  21f07c:	46bd      	mov	sp, r7
  21f07e:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f082:	b004      	add	sp, #16
  21f084:	4770      	bx	lr
  21f086:	bf00      	nop
  21f088:	ffff8100 	.word	0xffff8100

0021f08c <SDMMC_ReadFIFO>:
  * @brief  Read data (word) from Rx FIFO in blocking mode (polling) 
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
uint32_t SDMMC_ReadFIFO(SDMMC_TypeDef *SDMMCx)
{
  21f08c:	b480      	push	{r7}
  21f08e:	b083      	sub	sp, #12
  21f090:	af00      	add	r7, sp, #0
  21f092:	6078      	str	r0, [r7, #4]
  /* Read data from Rx FIFO */ 
  return (SDMMCx->FIFO);
  21f094:	687b      	ldr	r3, [r7, #4]
  21f096:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
}
  21f09a:	4618      	mov	r0, r3
  21f09c:	370c      	adds	r7, #12
  21f09e:	46bd      	mov	sp, r7
  21f0a0:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f0a4:	4770      	bx	lr

0021f0a6 <SDMMC_WriteFIFO>:
  * @param  SDMMCx: Pointer to SDMMC register base
  * @param  pWriteData: pointer to data to write
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_WriteFIFO(SDMMC_TypeDef *SDMMCx, uint32_t *pWriteData)
{ 
  21f0a6:	b480      	push	{r7}
  21f0a8:	b083      	sub	sp, #12
  21f0aa:	af00      	add	r7, sp, #0
  21f0ac:	6078      	str	r0, [r7, #4]
  21f0ae:	6039      	str	r1, [r7, #0]
  /* Write data to FIFO */ 
  SDMMCx->FIFO = *pWriteData;
  21f0b0:	683b      	ldr	r3, [r7, #0]
  21f0b2:	681a      	ldr	r2, [r3, #0]
  21f0b4:	687b      	ldr	r3, [r7, #4]
  21f0b6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  return HAL_OK;
  21f0ba:	2300      	movs	r3, #0
}
  21f0bc:	4618      	mov	r0, r3
  21f0be:	370c      	adds	r7, #12
  21f0c0:	46bd      	mov	sp, r7
  21f0c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f0c6:	4770      	bx	lr

0021f0c8 <SDMMC_PowerState_ON>:
  * @brief  Set SDMMC Power state to ON. 
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_PowerState_ON(SDMMC_TypeDef *SDMMCx)
{  
  21f0c8:	b580      	push	{r7, lr}
  21f0ca:	b082      	sub	sp, #8
  21f0cc:	af00      	add	r7, sp, #0
  21f0ce:	6078      	str	r0, [r7, #4]
  /* Set power state to ON */ 
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
  21f0d0:	687b      	ldr	r3, [r7, #4]
  21f0d2:	2203      	movs	r2, #3
  21f0d4:	601a      	str	r2, [r3, #0]

  /* 1ms: required power up waiting time before starting the SD initialization
  sequence */
  HAL_Delay(2);
  21f0d6:	2002      	movs	r0, #2
  21f0d8:	f7f9 feb6 	bl	218e48 <HAL_Delay>
  
  return HAL_OK;
  21f0dc:	2300      	movs	r3, #0
}
  21f0de:	4618      	mov	r0, r3
  21f0e0:	3708      	adds	r7, #8
  21f0e2:	46bd      	mov	sp, r7
  21f0e4:	bd80      	pop	{r7, pc}

0021f0e6 <SDMMC_GetPowerState>:
  *            - 0x00: Power OFF
  *            - 0x02: Power UP
  *            - 0x03: Power ON 
  */
uint32_t SDMMC_GetPowerState(SDMMC_TypeDef *SDMMCx)  
{
  21f0e6:	b480      	push	{r7}
  21f0e8:	b083      	sub	sp, #12
  21f0ea:	af00      	add	r7, sp, #0
  21f0ec:	6078      	str	r0, [r7, #4]
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
  21f0ee:	687b      	ldr	r3, [r7, #4]
  21f0f0:	681b      	ldr	r3, [r3, #0]
  21f0f2:	f003 0303 	and.w	r3, r3, #3
}
  21f0f6:	4618      	mov	r0, r3
  21f0f8:	370c      	adds	r7, #12
  21f0fa:	46bd      	mov	sp, r7
  21f0fc:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f100:	4770      	bx	lr
	...

0021f104 <SDMMC_SendCommand>:
  * @param  Command: pointer to a SDMMC_CmdInitTypeDef structure that contains 
  *         the configuration information for the SDMMC command
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_SendCommand(SDMMC_TypeDef *SDMMCx, SDMMC_CmdInitTypeDef *Command)
{
  21f104:	b480      	push	{r7}
  21f106:	b085      	sub	sp, #20
  21f108:	af00      	add	r7, sp, #0
  21f10a:	6078      	str	r0, [r7, #4]
  21f10c:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
  21f10e:	2300      	movs	r3, #0
  21f110:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_RESPONSE(Command->Response));
  assert_param(IS_SDMMC_WAIT(Command->WaitForInterrupt));
  assert_param(IS_SDMMC_CPSM(Command->CPSM));

  /* Set the SDMMC Argument value */
  SDMMCx->ARG = Command->Argument;
  21f112:	683b      	ldr	r3, [r7, #0]
  21f114:	681a      	ldr	r2, [r3, #0]
  21f116:	687b      	ldr	r3, [r7, #4]
  21f118:	609a      	str	r2, [r3, #8]

  /* Set SDMMC command parameters */
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
  21f11a:	683b      	ldr	r3, [r7, #0]
  21f11c:	685a      	ldr	r2, [r3, #4]
                       Command->Response         |\
  21f11e:	683b      	ldr	r3, [r7, #0]
  21f120:	689b      	ldr	r3, [r3, #8]
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
  21f122:	431a      	orrs	r2, r3
                       Command->WaitForInterrupt |\
  21f124:	683b      	ldr	r3, [r7, #0]
  21f126:	68db      	ldr	r3, [r3, #12]
                       Command->Response         |\
  21f128:	431a      	orrs	r2, r3
                       Command->CPSM);
  21f12a:	683b      	ldr	r3, [r7, #0]
  21f12c:	691b      	ldr	r3, [r3, #16]
                       Command->WaitForInterrupt |\
  21f12e:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Command->CmdIndex         |\
  21f130:	68fa      	ldr	r2, [r7, #12]
  21f132:	4313      	orrs	r3, r2
  21f134:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDMMC CMD register */
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg); 
  21f136:	687b      	ldr	r3, [r7, #4]
  21f138:	68da      	ldr	r2, [r3, #12]
  21f13a:	4b06      	ldr	r3, [pc, #24]	; (21f154 <SDMMC_SendCommand+0x50>)
  21f13c:	4013      	ands	r3, r2
  21f13e:	68fa      	ldr	r2, [r7, #12]
  21f140:	431a      	orrs	r2, r3
  21f142:	687b      	ldr	r3, [r7, #4]
  21f144:	60da      	str	r2, [r3, #12]
  
  return HAL_OK;  
  21f146:	2300      	movs	r3, #0
}
  21f148:	4618      	mov	r0, r3
  21f14a:	3714      	adds	r7, #20
  21f14c:	46bd      	mov	sp, r7
  21f14e:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f152:	4770      	bx	lr
  21f154:	fffff000 	.word	0xfffff000

0021f158 <SDMMC_GetCommandResponse>:
  * @brief  Return the command index of last command for which response received
  * @param  SDMMCx: Pointer to SDMMC register base
  * @retval Command index of the last command response received
  */
uint8_t SDMMC_GetCommandResponse(SDMMC_TypeDef *SDMMCx)
{
  21f158:	b480      	push	{r7}
  21f15a:	b083      	sub	sp, #12
  21f15c:	af00      	add	r7, sp, #0
  21f15e:	6078      	str	r0, [r7, #4]
  return (uint8_t)(SDMMCx->RESPCMD);
  21f160:	687b      	ldr	r3, [r7, #4]
  21f162:	691b      	ldr	r3, [r3, #16]
  21f164:	b2db      	uxtb	r3, r3
}
  21f166:	4618      	mov	r0, r3
  21f168:	370c      	adds	r7, #12
  21f16a:	46bd      	mov	sp, r7
  21f16c:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f170:	4770      	bx	lr

0021f172 <SDMMC_GetResponse>:
  *            @arg SDMMC_RESP3: Response Register 3
  *            @arg SDMMC_RESP4: Response Register 4  
  * @retval The Corresponding response register value
  */
uint32_t SDMMC_GetResponse(SDMMC_TypeDef *SDMMCx, uint32_t Response)
{
  21f172:	b480      	push	{r7}
  21f174:	b085      	sub	sp, #20
  21f176:	af00      	add	r7, sp, #0
  21f178:	6078      	str	r0, [r7, #4]
  21f17a:	6039      	str	r1, [r7, #0]

  /* Check the parameters */
  assert_param(IS_SDMMC_RESP(Response));
  
  /* Get the response */
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
  21f17c:	687b      	ldr	r3, [r7, #4]
  21f17e:	3314      	adds	r3, #20
  21f180:	461a      	mov	r2, r3
  21f182:	683b      	ldr	r3, [r7, #0]
  21f184:	4413      	add	r3, r2
  21f186:	60fb      	str	r3, [r7, #12]
  
  return (*(__IO uint32_t *) tmp);
  21f188:	68fb      	ldr	r3, [r7, #12]
  21f18a:	681b      	ldr	r3, [r3, #0]
}  
  21f18c:	4618      	mov	r0, r3
  21f18e:	3714      	adds	r7, #20
  21f190:	46bd      	mov	sp, r7
  21f192:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f196:	4770      	bx	lr

0021f198 <SDMMC_ConfigData>:
  * @param  Data : pointer to a SDMMC_DataInitTypeDef structure 
  *         that contains the configuration information for the SDMMC data.
  * @retval HAL status
  */
HAL_StatusTypeDef SDMMC_ConfigData(SDMMC_TypeDef *SDMMCx, SDMMC_DataInitTypeDef* Data)
{
  21f198:	b480      	push	{r7}
  21f19a:	b085      	sub	sp, #20
  21f19c:	af00      	add	r7, sp, #0
  21f19e:	6078      	str	r0, [r7, #4]
  21f1a0:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
  21f1a2:	2300      	movs	r3, #0
  21f1a4:	60fb      	str	r3, [r7, #12]
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
  assert_param(IS_SDMMC_DPSM(Data->DPSM));

  /* Set the SDMMC Data TimeOut value */
  SDMMCx->DTIMER = Data->DataTimeOut;
  21f1a6:	683b      	ldr	r3, [r7, #0]
  21f1a8:	681a      	ldr	r2, [r3, #0]
  21f1aa:	687b      	ldr	r3, [r7, #4]
  21f1ac:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set the SDMMC DataLength value */
  SDMMCx->DLEN = Data->DataLength;
  21f1ae:	683b      	ldr	r3, [r7, #0]
  21f1b0:	685a      	ldr	r2, [r3, #4]
  21f1b2:	687b      	ldr	r3, [r7, #4]
  21f1b4:	629a      	str	r2, [r3, #40]	; 0x28

  /* Set the SDMMC data configuration parameters */
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
  21f1b6:	683b      	ldr	r3, [r7, #0]
  21f1b8:	689a      	ldr	r2, [r3, #8]
                       Data->TransferDir   |\
  21f1ba:	683b      	ldr	r3, [r7, #0]
  21f1bc:	68db      	ldr	r3, [r3, #12]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
  21f1be:	431a      	orrs	r2, r3
                       Data->TransferMode  |\
  21f1c0:	683b      	ldr	r3, [r7, #0]
  21f1c2:	691b      	ldr	r3, [r3, #16]
                       Data->TransferDir   |\
  21f1c4:	431a      	orrs	r2, r3
                       Data->DPSM);
  21f1c6:	683b      	ldr	r3, [r7, #0]
  21f1c8:	695b      	ldr	r3, [r3, #20]
                       Data->TransferMode  |\
  21f1ca:	4313      	orrs	r3, r2
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
  21f1cc:	68fa      	ldr	r2, [r7, #12]
  21f1ce:	4313      	orrs	r3, r2
  21f1d0:	60fb      	str	r3, [r7, #12]
  
  /* Write to SDMMC DCTRL */
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
  21f1d2:	687b      	ldr	r3, [r7, #4]
  21f1d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  21f1d6:	f023 02f7 	bic.w	r2, r3, #247	; 0xf7
  21f1da:	68fb      	ldr	r3, [r7, #12]
  21f1dc:	431a      	orrs	r2, r3
  21f1de:	687b      	ldr	r3, [r7, #4]
  21f1e0:	62da      	str	r2, [r3, #44]	; 0x2c

  return HAL_OK;
  21f1e2:	2300      	movs	r3, #0

}
  21f1e4:	4618      	mov	r0, r3
  21f1e6:	3714      	adds	r7, #20
  21f1e8:	46bd      	mov	sp, r7
  21f1ea:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f1ee:	4770      	bx	lr

0021f1f0 <SDMMC_CmdBlockLength>:
  * @brief  Send the Data Block Length command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdBlockLength(SDMMC_TypeDef *SDMMCx, uint32_t BlockSize)
{
  21f1f0:	b580      	push	{r7, lr}
  21f1f2:	b088      	sub	sp, #32
  21f1f4:	af00      	add	r7, sp, #0
  21f1f6:	6078      	str	r0, [r7, #4]
  21f1f8:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
  21f1fa:	683b      	ldr	r3, [r7, #0]
  21f1fc:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
  21f1fe:	2310      	movs	r3, #16
  21f200:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f202:	2340      	movs	r3, #64	; 0x40
  21f204:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f206:	2300      	movs	r3, #0
  21f208:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f20a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f20e:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f210:	f107 0308 	add.w	r3, r7, #8
  21f214:	4619      	mov	r1, r3
  21f216:	6878      	ldr	r0, [r7, #4]
  21f218:	f7ff ff74 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
  21f21c:	f241 3288 	movw	r2, #5000	; 0x1388
  21f220:	2110      	movs	r1, #16
  21f222:	6878      	ldr	r0, [r7, #4]
  21f224:	f000 fa46 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f228:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f22a:	69fb      	ldr	r3, [r7, #28]
}
  21f22c:	4618      	mov	r0, r3
  21f22e:	3720      	adds	r7, #32
  21f230:	46bd      	mov	sp, r7
  21f232:	bd80      	pop	{r7, pc}

0021f234 <SDMMC_CmdReadSingleBlock>:
  * @brief  Send the Read Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
  21f234:	b580      	push	{r7, lr}
  21f236:	b088      	sub	sp, #32
  21f238:	af00      	add	r7, sp, #0
  21f23a:	6078      	str	r0, [r7, #4]
  21f23c:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  21f23e:	683b      	ldr	r3, [r7, #0]
  21f240:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
  21f242:	2311      	movs	r3, #17
  21f244:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f246:	2340      	movs	r3, #64	; 0x40
  21f248:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f24a:	2300      	movs	r3, #0
  21f24c:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f24e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f252:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f254:	f107 0308 	add.w	r3, r7, #8
  21f258:	4619      	mov	r1, r3
  21f25a:	6878      	ldr	r0, [r7, #4]
  21f25c:	f7ff ff52 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
  21f260:	f241 3288 	movw	r2, #5000	; 0x1388
  21f264:	2111      	movs	r1, #17
  21f266:	6878      	ldr	r0, [r7, #4]
  21f268:	f000 fa24 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f26c:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f26e:	69fb      	ldr	r3, [r7, #28]
}
  21f270:	4618      	mov	r0, r3
  21f272:	3720      	adds	r7, #32
  21f274:	46bd      	mov	sp, r7
  21f276:	bd80      	pop	{r7, pc}

0021f278 <SDMMC_CmdReadMultiBlock>:
  * @brief  Send the Read Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdReadMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t ReadAdd)
{
  21f278:	b580      	push	{r7, lr}
  21f27a:	b088      	sub	sp, #32
  21f27c:	af00      	add	r7, sp, #0
  21f27e:	6078      	str	r0, [r7, #4]
  21f280:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
  21f282:	683b      	ldr	r3, [r7, #0]
  21f284:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
  21f286:	2312      	movs	r3, #18
  21f288:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f28a:	2340      	movs	r3, #64	; 0x40
  21f28c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f28e:	2300      	movs	r3, #0
  21f290:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f292:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f296:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f298:	f107 0308 	add.w	r3, r7, #8
  21f29c:	4619      	mov	r1, r3
  21f29e:	6878      	ldr	r0, [r7, #4]
  21f2a0:	f7ff ff30 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
  21f2a4:	f241 3288 	movw	r2, #5000	; 0x1388
  21f2a8:	2112      	movs	r1, #18
  21f2aa:	6878      	ldr	r0, [r7, #4]
  21f2ac:	f000 fa02 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f2b0:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f2b2:	69fb      	ldr	r3, [r7, #28]
}
  21f2b4:	4618      	mov	r0, r3
  21f2b6:	3720      	adds	r7, #32
  21f2b8:	46bd      	mov	sp, r7
  21f2ba:	bd80      	pop	{r7, pc}

0021f2bc <SDMMC_CmdWriteSingleBlock>:
  * @brief  Send the Write Single Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteSingleBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
  21f2bc:	b580      	push	{r7, lr}
  21f2be:	b088      	sub	sp, #32
  21f2c0:	af00      	add	r7, sp, #0
  21f2c2:	6078      	str	r0, [r7, #4]
  21f2c4:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  21f2c6:	683b      	ldr	r3, [r7, #0]
  21f2c8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
  21f2ca:	2318      	movs	r3, #24
  21f2cc:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f2ce:	2340      	movs	r3, #64	; 0x40
  21f2d0:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f2d2:	2300      	movs	r3, #0
  21f2d4:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f2d6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f2da:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f2dc:	f107 0308 	add.w	r3, r7, #8
  21f2e0:	4619      	mov	r1, r3
  21f2e2:	6878      	ldr	r0, [r7, #4]
  21f2e4:	f7ff ff0e 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
  21f2e8:	f241 3288 	movw	r2, #5000	; 0x1388
  21f2ec:	2118      	movs	r1, #24
  21f2ee:	6878      	ldr	r0, [r7, #4]
  21f2f0:	f000 f9e0 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f2f4:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f2f6:	69fb      	ldr	r3, [r7, #28]
}
  21f2f8:	4618      	mov	r0, r3
  21f2fa:	3720      	adds	r7, #32
  21f2fc:	46bd      	mov	sp, r7
  21f2fe:	bd80      	pop	{r7, pc}

0021f300 <SDMMC_CmdWriteMultiBlock>:
  * @brief  Send the Write Multi Block command and check the response
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdWriteMultiBlock(SDMMC_TypeDef *SDMMCx, uint32_t WriteAdd)
{
  21f300:	b580      	push	{r7, lr}
  21f302:	b088      	sub	sp, #32
  21f304:	af00      	add	r7, sp, #0
  21f306:	6078      	str	r0, [r7, #4]
  21f308:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Set Block Size for Card */ 
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
  21f30a:	683b      	ldr	r3, [r7, #0]
  21f30c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
  21f30e:	2319      	movs	r3, #25
  21f310:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f312:	2340      	movs	r3, #64	; 0x40
  21f314:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f316:	2300      	movs	r3, #0
  21f318:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f31a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f31e:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f320:	f107 0308 	add.w	r3, r7, #8
  21f324:	4619      	mov	r1, r3
  21f326:	6878      	ldr	r0, [r7, #4]
  21f328:	f7ff feec 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
  21f32c:	f241 3288 	movw	r2, #5000	; 0x1388
  21f330:	2119      	movs	r1, #25
  21f332:	6878      	ldr	r0, [r7, #4]
  21f334:	f000 f9be 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f338:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f33a:	69fb      	ldr	r3, [r7, #28]
}
  21f33c:	4618      	mov	r0, r3
  21f33e:	3720      	adds	r7, #32
  21f340:	46bd      	mov	sp, r7
  21f342:	bd80      	pop	{r7, pc}

0021f344 <SDMMC_CmdStopTransfer>:
  * @brief  Send the Stop Transfer command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdStopTransfer(SDMMC_TypeDef *SDMMCx)
{
  21f344:	b580      	push	{r7, lr}
  21f346:	b088      	sub	sp, #32
  21f348:	af00      	add	r7, sp, #0
  21f34a:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD12 STOP_TRANSMISSION  */
  sdmmc_cmdinit.Argument         = 0U;
  21f34c:	2300      	movs	r3, #0
  21f34e:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
  21f350:	230c      	movs	r3, #12
  21f352:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f354:	2340      	movs	r3, #64	; 0x40
  21f356:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f358:	2300      	movs	r3, #0
  21f35a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f35c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f360:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f362:	f107 0308 	add.w	r3, r7, #8
  21f366:	4619      	mov	r1, r3
  21f368:	6878      	ldr	r0, [r7, #4]
  21f36a:	f7ff fecb 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
  21f36e:	4a05      	ldr	r2, [pc, #20]	; (21f384 <SDMMC_CmdStopTransfer+0x40>)
  21f370:	210c      	movs	r1, #12
  21f372:	6878      	ldr	r0, [r7, #4]
  21f374:	f000 f99e 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f378:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f37a:	69fb      	ldr	r3, [r7, #28]
}
  21f37c:	4618      	mov	r0, r3
  21f37e:	3720      	adds	r7, #32
  21f380:	46bd      	mov	sp, r7
  21f382:	bd80      	pop	{r7, pc}
  21f384:	05f5e100 	.word	0x05f5e100

0021f388 <SDMMC_CmdSelDesel>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  addr: Address of the card to be selected  
  * @retval HAL status
  */
uint32_t SDMMC_CmdSelDesel(SDMMC_TypeDef *SDMMCx, uint64_t Addr)
{
  21f388:	b580      	push	{r7, lr}
  21f38a:	b08a      	sub	sp, #40	; 0x28
  21f38c:	af00      	add	r7, sp, #0
  21f38e:	60f8      	str	r0, [r7, #12]
  21f390:	e9c7 2300 	strd	r2, r3, [r7]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD7 SDMMC_SEL_DESEL_CARD */
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
  21f394:	683b      	ldr	r3, [r7, #0]
  21f396:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
  21f398:	2307      	movs	r3, #7
  21f39a:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f39c:	2340      	movs	r3, #64	; 0x40
  21f39e:	61bb      	str	r3, [r7, #24]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f3a0:	2300      	movs	r3, #0
  21f3a2:	61fb      	str	r3, [r7, #28]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f3a4:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f3a8:	623b      	str	r3, [r7, #32]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f3aa:	f107 0310 	add.w	r3, r7, #16
  21f3ae:	4619      	mov	r1, r3
  21f3b0:	68f8      	ldr	r0, [r7, #12]
  21f3b2:	f7ff fea7 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
  21f3b6:	f241 3288 	movw	r2, #5000	; 0x1388
  21f3ba:	2107      	movs	r1, #7
  21f3bc:	68f8      	ldr	r0, [r7, #12]
  21f3be:	f000 f979 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f3c2:	6278      	str	r0, [r7, #36]	; 0x24

  return errorstate;
  21f3c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
  21f3c6:	4618      	mov	r0, r3
  21f3c8:	3728      	adds	r7, #40	; 0x28
  21f3ca:	46bd      	mov	sp, r7
  21f3cc:	bd80      	pop	{r7, pc}

0021f3ce <SDMMC_CmdGoIdleState>:
  * @brief  Send the Go Idle State command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdGoIdleState(SDMMC_TypeDef *SDMMCx)
{
  21f3ce:	b580      	push	{r7, lr}
  21f3d0:	b088      	sub	sp, #32
  21f3d2:	af00      	add	r7, sp, #0
  21f3d4:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = 0U;
  21f3d6:	2300      	movs	r3, #0
  21f3d8:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
  21f3da:	2300      	movs	r3, #0
  21f3dc:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
  21f3de:	2300      	movs	r3, #0
  21f3e0:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f3e2:	2300      	movs	r3, #0
  21f3e4:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f3e6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f3ea:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f3ec:	f107 0308 	add.w	r3, r7, #8
  21f3f0:	4619      	mov	r1, r3
  21f3f2:	6878      	ldr	r0, [r7, #4]
  21f3f4:	f7ff fe86 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdError(SDMMCx);
  21f3f8:	6878      	ldr	r0, [r7, #4]
  21f3fa:	f000 f92f 	bl	21f65c <SDMMC_GetCmdError>
  21f3fe:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f400:	69fb      	ldr	r3, [r7, #28]
}
  21f402:	4618      	mov	r0, r3
  21f404:	3720      	adds	r7, #32
  21f406:	46bd      	mov	sp, r7
  21f408:	bd80      	pop	{r7, pc}

0021f40a <SDMMC_CmdOperCond>:
  * @brief  Send the Operating Condition command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdOperCond(SDMMC_TypeDef *SDMMCx)
{
  21f40a:	b580      	push	{r7, lr}
  21f40c:	b088      	sub	sp, #32
  21f40e:	af00      	add	r7, sp, #0
  21f410:	6078      	str	r0, [r7, #4]
  /* Send CMD8 to verify SD card interface operating condition */
  /* Argument: - [31:12]: Reserved (shall be set to '0')
  - [11:8]: Supply Voltage (VHS) 0x1 (Range: 2.7-3.6 V)
  - [7:0]: Check Pattern (recommended 0xAA) */
  /* CMD Response: R7 */
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
  21f412:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
  21f416:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
  21f418:	2308      	movs	r3, #8
  21f41a:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f41c:	2340      	movs	r3, #64	; 0x40
  21f41e:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f420:	2300      	movs	r3, #0
  21f422:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f424:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f428:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f42a:	f107 0308 	add.w	r3, r7, #8
  21f42e:	4619      	mov	r1, r3
  21f430:	6878      	ldr	r0, [r7, #4]
  21f432:	f7ff fe67 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp7(SDMMCx);
  21f436:	6878      	ldr	r0, [r7, #4]
  21f438:	f000 fb26 	bl	21fa88 <SDMMC_GetCmdResp7>
  21f43c:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f43e:	69fb      	ldr	r3, [r7, #28]
}
  21f440:	4618      	mov	r0, r3
  21f442:	3720      	adds	r7, #32
  21f444:	46bd      	mov	sp, r7
  21f446:	bd80      	pop	{r7, pc}

0021f448 <SDMMC_CmdAppCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  Argument: Command Argument 
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
  21f448:	b580      	push	{r7, lr}
  21f44a:	b088      	sub	sp, #32
  21f44c:	af00      	add	r7, sp, #0
  21f44e:	6078      	str	r0, [r7, #4]
  21f450:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
  21f452:	683b      	ldr	r3, [r7, #0]
  21f454:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
  21f456:	2337      	movs	r3, #55	; 0x37
  21f458:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f45a:	2340      	movs	r3, #64	; 0x40
  21f45c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f45e:	2300      	movs	r3, #0
  21f460:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f462:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f466:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f468:	f107 0308 	add.w	r3, r7, #8
  21f46c:	4619      	mov	r1, r3
  21f46e:	6878      	ldr	r0, [r7, #4]
  21f470:	f7ff fe48 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  /* If there is a HAL_ERROR, it is a MMC card, else
  it is a SD card: SD card 2.0 (voltage range mismatch)
     or SD card 1.x */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
  21f474:	f241 3288 	movw	r2, #5000	; 0x1388
  21f478:	2137      	movs	r1, #55	; 0x37
  21f47a:	6878      	ldr	r0, [r7, #4]
  21f47c:	f000 f91a 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f480:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f482:	69fb      	ldr	r3, [r7, #28]
}
  21f484:	4618      	mov	r0, r3
  21f486:	3720      	adds	r7, #32
  21f488:	46bd      	mov	sp, r7
  21f48a:	bd80      	pop	{r7, pc}

0021f48c <SDMMC_CmdAppOperCommand>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdAppOperCommand(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
  21f48c:	b580      	push	{r7, lr}
  21f48e:	b088      	sub	sp, #32
  21f490:	af00      	add	r7, sp, #0
  21f492:	6078      	str	r0, [r7, #4]
  21f494:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
  21f496:	683a      	ldr	r2, [r7, #0]
  21f498:	4b0d      	ldr	r3, [pc, #52]	; (21f4d0 <SDMMC_CmdAppOperCommand+0x44>)
  21f49a:	4313      	orrs	r3, r2
  21f49c:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
  21f49e:	2329      	movs	r3, #41	; 0x29
  21f4a0:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f4a2:	2340      	movs	r3, #64	; 0x40
  21f4a4:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f4a6:	2300      	movs	r3, #0
  21f4a8:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f4aa:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f4ae:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f4b0:	f107 0308 	add.w	r3, r7, #8
  21f4b4:	4619      	mov	r1, r3
  21f4b6:	6878      	ldr	r0, [r7, #4]
  21f4b8:	f7ff fe24 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
  21f4bc:	6878      	ldr	r0, [r7, #4]
  21f4be:	f000 fa2f 	bl	21f920 <SDMMC_GetCmdResp3>
  21f4c2:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f4c4:	69fb      	ldr	r3, [r7, #28]
}
  21f4c6:	4618      	mov	r0, r3
  21f4c8:	3720      	adds	r7, #32
  21f4ca:	46bd      	mov	sp, r7
  21f4cc:	bd80      	pop	{r7, pc}
  21f4ce:	bf00      	nop
  21f4d0:	80100000 	.word	0x80100000

0021f4d4 <SDMMC_CmdBusWidth>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  BusWidth: BusWidth
  * @retval HAL status
  */
uint32_t SDMMC_CmdBusWidth(SDMMC_TypeDef *SDMMCx, uint32_t BusWidth)
{
  21f4d4:	b580      	push	{r7, lr}
  21f4d6:	b088      	sub	sp, #32
  21f4d8:	af00      	add	r7, sp, #0
  21f4da:	6078      	str	r0, [r7, #4]
  21f4dc:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = (uint32_t)BusWidth;
  21f4de:	683b      	ldr	r3, [r7, #0]
  21f4e0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_SD_SET_BUSWIDTH;
  21f4e2:	2306      	movs	r3, #6
  21f4e4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f4e6:	2340      	movs	r3, #64	; 0x40
  21f4e8:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f4ea:	2300      	movs	r3, #0
  21f4ec:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f4ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f4f2:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f4f4:	f107 0308 	add.w	r3, r7, #8
  21f4f8:	4619      	mov	r1, r3
  21f4fa:	6878      	ldr	r0, [r7, #4]
  21f4fc:	f7ff fe02 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_SD_SET_BUSWIDTH, SDMMC_CMDTIMEOUT);
  21f500:	f241 3288 	movw	r2, #5000	; 0x1388
  21f504:	2106      	movs	r1, #6
  21f506:	6878      	ldr	r0, [r7, #4]
  21f508:	f000 f8d4 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f50c:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f50e:	69fb      	ldr	r3, [r7, #28]
}
  21f510:	4618      	mov	r0, r3
  21f512:	3720      	adds	r7, #32
  21f514:	46bd      	mov	sp, r7
  21f516:	bd80      	pop	{r7, pc}

0021f518 <SDMMC_CmdSendSCR>:
  * @brief  Send the Send SCR command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendSCR(SDMMC_TypeDef *SDMMCx)
{
  21f518:	b580      	push	{r7, lr}
  21f51a:	b088      	sub	sp, #32
  21f51c:	af00      	add	r7, sp, #0
  21f51e:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD51 SD_APP_SEND_SCR */
  sdmmc_cmdinit.Argument         = 0U;
  21f520:	2300      	movs	r3, #0
  21f522:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_SEND_SCR;
  21f524:	2333      	movs	r3, #51	; 0x33
  21f526:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f528:	2340      	movs	r3, #64	; 0x40
  21f52a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f52c:	2300      	movs	r3, #0
  21f52e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f530:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f534:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f536:	f107 0308 	add.w	r3, r7, #8
  21f53a:	4619      	mov	r1, r3
  21f53c:	6878      	ldr	r0, [r7, #4]
  21f53e:	f7ff fde1 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SD_APP_SEND_SCR, SDMMC_CMDTIMEOUT);
  21f542:	f241 3288 	movw	r2, #5000	; 0x1388
  21f546:	2133      	movs	r1, #51	; 0x33
  21f548:	6878      	ldr	r0, [r7, #4]
  21f54a:	f000 f8b3 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f54e:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f550:	69fb      	ldr	r3, [r7, #28]
}
  21f552:	4618      	mov	r0, r3
  21f554:	3720      	adds	r7, #32
  21f556:	46bd      	mov	sp, r7
  21f558:	bd80      	pop	{r7, pc}

0021f55a <SDMMC_CmdSendCID>:
  * @brief  Send the Send CID command and check the response.
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCID(SDMMC_TypeDef *SDMMCx)
{
  21f55a:	b580      	push	{r7, lr}
  21f55c:	b088      	sub	sp, #32
  21f55e:	af00      	add	r7, sp, #0
  21f560:	6078      	str	r0, [r7, #4]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD2 ALL_SEND_CID */
  sdmmc_cmdinit.Argument         = 0U;
  21f562:	2300      	movs	r3, #0
  21f564:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
  21f566:	2302      	movs	r3, #2
  21f568:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  21f56a:	23c0      	movs	r3, #192	; 0xc0
  21f56c:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f56e:	2300      	movs	r3, #0
  21f570:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f572:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f576:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f578:	f107 0308 	add.w	r3, r7, #8
  21f57c:	4619      	mov	r1, r3
  21f57e:	6878      	ldr	r0, [r7, #4]
  21f580:	f7ff fdc0 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
  21f584:	6878      	ldr	r0, [r7, #4]
  21f586:	f000 f983 	bl	21f890 <SDMMC_GetCmdResp2>
  21f58a:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f58c:	69fb      	ldr	r3, [r7, #28]
}
  21f58e:	4618      	mov	r0, r3
  21f590:	3720      	adds	r7, #32
  21f592:	46bd      	mov	sp, r7
  21f594:	bd80      	pop	{r7, pc}

0021f596 <SDMMC_CmdSendCSD>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendCSD(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
  21f596:	b580      	push	{r7, lr}
  21f598:	b088      	sub	sp, #32
  21f59a:	af00      	add	r7, sp, #0
  21f59c:	6078      	str	r0, [r7, #4]
  21f59e:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD9 SEND_CSD */
  sdmmc_cmdinit.Argument         = Argument;
  21f5a0:	683b      	ldr	r3, [r7, #0]
  21f5a2:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
  21f5a4:	2309      	movs	r3, #9
  21f5a6:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
  21f5a8:	23c0      	movs	r3, #192	; 0xc0
  21f5aa:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f5ac:	2300      	movs	r3, #0
  21f5ae:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f5b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f5b4:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f5b6:	f107 0308 	add.w	r3, r7, #8
  21f5ba:	4619      	mov	r1, r3
  21f5bc:	6878      	ldr	r0, [r7, #4]
  21f5be:	f7ff fda1 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
  21f5c2:	6878      	ldr	r0, [r7, #4]
  21f5c4:	f000 f964 	bl	21f890 <SDMMC_GetCmdResp2>
  21f5c8:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f5ca:	69fb      	ldr	r3, [r7, #28]
}
  21f5cc:	4618      	mov	r0, r3
  21f5ce:	3720      	adds	r7, #32
  21f5d0:	46bd      	mov	sp, r7
  21f5d2:	bd80      	pop	{r7, pc}

0021f5d4 <SDMMC_CmdSetRelAdd>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  pRCA: Card RCA  
  * @retval HAL status
  */
uint32_t SDMMC_CmdSetRelAdd(SDMMC_TypeDef *SDMMCx, uint16_t *pRCA)
{
  21f5d4:	b580      	push	{r7, lr}
  21f5d6:	b088      	sub	sp, #32
  21f5d8:	af00      	add	r7, sp, #0
  21f5da:	6078      	str	r0, [r7, #4]
  21f5dc:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  /* Send CMD3 SD_CMD_SET_REL_ADDR */
  sdmmc_cmdinit.Argument         = 0U;
  21f5de:	2300      	movs	r3, #0
  21f5e0:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
  21f5e2:	2303      	movs	r3, #3
  21f5e4:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f5e6:	2340      	movs	r3, #64	; 0x40
  21f5e8:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f5ea:	2300      	movs	r3, #0
  21f5ec:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f5ee:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f5f2:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f5f4:	f107 0308 	add.w	r3, r7, #8
  21f5f8:	4619      	mov	r1, r3
  21f5fa:	6878      	ldr	r0, [r7, #4]
  21f5fc:	f7ff fd82 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp6(SDMMCx, SDMMC_CMD_SET_REL_ADDR, pRCA);
  21f600:	683a      	ldr	r2, [r7, #0]
  21f602:	2103      	movs	r1, #3
  21f604:	6878      	ldr	r0, [r7, #4]
  21f606:	f000 f9c9 	bl	21f99c <SDMMC_GetCmdResp6>
  21f60a:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f60c:	69fb      	ldr	r3, [r7, #28]
}
  21f60e:	4618      	mov	r0, r3
  21f610:	3720      	adds	r7, #32
  21f612:	46bd      	mov	sp, r7
  21f614:	bd80      	pop	{r7, pc}

0021f616 <SDMMC_CmdSendStatus>:
  * @param  SDMMCx: Pointer to SDMMC register base 
  * @param  Argument: Command Argument
  * @retval HAL status
  */
uint32_t SDMMC_CmdSendStatus(SDMMC_TypeDef *SDMMCx, uint32_t Argument)
{
  21f616:	b580      	push	{r7, lr}
  21f618:	b088      	sub	sp, #32
  21f61a:	af00      	add	r7, sp, #0
  21f61c:	6078      	str	r0, [r7, #4]
  21f61e:	6039      	str	r1, [r7, #0]
  SDMMC_CmdInitTypeDef  sdmmc_cmdinit;
  uint32_t errorstate;
  
  sdmmc_cmdinit.Argument         = Argument;
  21f620:	683b      	ldr	r3, [r7, #0]
  21f622:	60bb      	str	r3, [r7, #8]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
  21f624:	230d      	movs	r3, #13
  21f626:	60fb      	str	r3, [r7, #12]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
  21f628:	2340      	movs	r3, #64	; 0x40
  21f62a:	613b      	str	r3, [r7, #16]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
  21f62c:	2300      	movs	r3, #0
  21f62e:	617b      	str	r3, [r7, #20]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
  21f630:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f634:	61bb      	str	r3, [r7, #24]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
  21f636:	f107 0308 	add.w	r3, r7, #8
  21f63a:	4619      	mov	r1, r3
  21f63c:	6878      	ldr	r0, [r7, #4]
  21f63e:	f7ff fd61 	bl	21f104 <SDMMC_SendCommand>
  
  /* Check for error conditions */
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
  21f642:	f241 3288 	movw	r2, #5000	; 0x1388
  21f646:	210d      	movs	r1, #13
  21f648:	6878      	ldr	r0, [r7, #4]
  21f64a:	f000 f833 	bl	21f6b4 <SDMMC_GetCmdResp1>
  21f64e:	61f8      	str	r0, [r7, #28]

  return errorstate;
  21f650:	69fb      	ldr	r3, [r7, #28]
}
  21f652:	4618      	mov	r0, r3
  21f654:	3720      	adds	r7, #32
  21f656:	46bd      	mov	sp, r7
  21f658:	bd80      	pop	{r7, pc}
	...

0021f65c <SDMMC_GetCmdError>:
  * @brief  Checks for error conditions for CMD0.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdError(SDMMC_TypeDef *SDMMCx)
{
  21f65c:	b480      	push	{r7}
  21f65e:	b085      	sub	sp, #20
  21f660:	af00      	add	r7, sp, #0
  21f662:	6078      	str	r0, [r7, #4]
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
  21f664:	4b11      	ldr	r3, [pc, #68]	; (21f6ac <SDMMC_GetCmdError+0x50>)
  21f666:	681b      	ldr	r3, [r3, #0]
  21f668:	4a11      	ldr	r2, [pc, #68]	; (21f6b0 <SDMMC_GetCmdError+0x54>)
  21f66a:	fba2 2303 	umull	r2, r3, r2, r3
  21f66e:	0a5b      	lsrs	r3, r3, #9
  21f670:	f241 3288 	movw	r2, #5000	; 0x1388
  21f674:	fb02 f303 	mul.w	r3, r2, r3
  21f678:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
  21f67a:	68fb      	ldr	r3, [r7, #12]
  21f67c:	1e5a      	subs	r2, r3, #1
  21f67e:	60fa      	str	r2, [r7, #12]
  21f680:	2b00      	cmp	r3, #0
  21f682:	d102      	bne.n	21f68a <SDMMC_GetCmdError+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
  21f684:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21f688:	e009      	b.n	21f69e <SDMMC_GetCmdError+0x42>
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
  21f68a:	687b      	ldr	r3, [r7, #4]
  21f68c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f68e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  21f692:	2b00      	cmp	r3, #0
  21f694:	d0f1      	beq.n	21f67a <SDMMC_GetCmdError+0x1e>
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  21f696:	687b      	ldr	r3, [r7, #4]
  21f698:	22c5      	movs	r2, #197	; 0xc5
  21f69a:	639a      	str	r2, [r3, #56]	; 0x38
  
  return SDMMC_ERROR_NONE;
  21f69c:	2300      	movs	r3, #0
}
  21f69e:	4618      	mov	r0, r3
  21f6a0:	3714      	adds	r7, #20
  21f6a2:	46bd      	mov	sp, r7
  21f6a4:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f6a8:	4770      	bx	lr
  21f6aa:	bf00      	nop
  21f6ac:	20000004 	.word	0x20000004
  21f6b0:	10624dd3 	.word	0x10624dd3

0021f6b4 <SDMMC_GetCmdResp1>:
  * @param  hsd: SD handle
  * @param  SD_CMD: The sent command index  
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp1(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint32_t Timeout)
{
  21f6b4:	b580      	push	{r7, lr}
  21f6b6:	b088      	sub	sp, #32
  21f6b8:	af00      	add	r7, sp, #0
  21f6ba:	60f8      	str	r0, [r7, #12]
  21f6bc:	460b      	mov	r3, r1
  21f6be:	607a      	str	r2, [r7, #4]
  21f6c0:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;
  
  /* 8 is the number of required instructions cycles for the below loop statement.
  The Timeout is expressed in ms */
  uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
  21f6c2:	4b70      	ldr	r3, [pc, #448]	; (21f884 <SDMMC_GetCmdResp1+0x1d0>)
  21f6c4:	681b      	ldr	r3, [r3, #0]
  21f6c6:	4a70      	ldr	r2, [pc, #448]	; (21f888 <SDMMC_GetCmdResp1+0x1d4>)
  21f6c8:	fba2 2303 	umull	r2, r3, r2, r3
  21f6cc:	0a5b      	lsrs	r3, r3, #9
  21f6ce:	687a      	ldr	r2, [r7, #4]
  21f6d0:	fb02 f303 	mul.w	r3, r2, r3
  21f6d4:	61fb      	str	r3, [r7, #28]
  
  do
  {
    if (count-- == 0U)
  21f6d6:	69fb      	ldr	r3, [r7, #28]
  21f6d8:	1e5a      	subs	r2, r3, #1
  21f6da:	61fa      	str	r2, [r7, #28]
  21f6dc:	2b00      	cmp	r3, #0
  21f6de:	d102      	bne.n	21f6e6 <SDMMC_GetCmdResp1+0x32>
    {
      return SDMMC_ERROR_TIMEOUT;
  21f6e0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21f6e4:	e0c9      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
    }
    sta_reg = SDMMCx->STA;
  21f6e6:	68fb      	ldr	r3, [r7, #12]
  21f6e8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f6ea:	61bb      	str	r3, [r7, #24]
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f6ec:	69bb      	ldr	r3, [r7, #24]
  21f6ee:	f003 0345 	and.w	r3, r3, #69	; 0x45
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
  21f6f2:	2b00      	cmp	r3, #0
  21f6f4:	d0ef      	beq.n	21f6d6 <SDMMC_GetCmdResp1+0x22>
  21f6f6:	69bb      	ldr	r3, [r7, #24]
  21f6f8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f6fc:	2b00      	cmp	r3, #0
  21f6fe:	d1ea      	bne.n	21f6d6 <SDMMC_GetCmdResp1+0x22>
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  21f700:	68fb      	ldr	r3, [r7, #12]
  21f702:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f704:	f003 0304 	and.w	r3, r3, #4
  21f708:	2b00      	cmp	r3, #0
  21f70a:	d004      	beq.n	21f716 <SDMMC_GetCmdResp1+0x62>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
  21f70c:	68fb      	ldr	r3, [r7, #12]
  21f70e:	2204      	movs	r2, #4
  21f710:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  21f712:	2304      	movs	r3, #4
  21f714:	e0b1      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
  21f716:	68fb      	ldr	r3, [r7, #12]
  21f718:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f71a:	f003 0301 	and.w	r3, r3, #1
  21f71e:	2b00      	cmp	r3, #0
  21f720:	d004      	beq.n	21f72c <SDMMC_GetCmdResp1+0x78>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
  21f722:	68fb      	ldr	r3, [r7, #12]
  21f724:	2201      	movs	r2, #1
  21f726:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
  21f728:	2301      	movs	r3, #1
  21f72a:	e0a6      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  {
    /* Nothing to do */
  }
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  21f72c:	68fb      	ldr	r3, [r7, #12]
  21f72e:	22c5      	movs	r2, #197	; 0xc5
  21f730:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
  21f732:	68f8      	ldr	r0, [r7, #12]
  21f734:	f7ff fd10 	bl	21f158 <SDMMC_GetCommandResponse>
  21f738:	4603      	mov	r3, r0
  21f73a:	461a      	mov	r2, r3
  21f73c:	7afb      	ldrb	r3, [r7, #11]
  21f73e:	4293      	cmp	r3, r2
  21f740:	d001      	beq.n	21f746 <SDMMC_GetCmdResp1+0x92>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
  21f742:	2301      	movs	r3, #1
  21f744:	e099      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  
  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
  21f746:	2100      	movs	r1, #0
  21f748:	68f8      	ldr	r0, [r7, #12]
  21f74a:	f7ff fd12 	bl	21f172 <SDMMC_GetResponse>
  21f74e:	6178      	str	r0, [r7, #20]
  
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
  21f750:	697a      	ldr	r2, [r7, #20]
  21f752:	4b4e      	ldr	r3, [pc, #312]	; (21f88c <SDMMC_GetCmdResp1+0x1d8>)
  21f754:	4013      	ands	r3, r2
  21f756:	2b00      	cmp	r3, #0
  21f758:	d101      	bne.n	21f75e <SDMMC_GetCmdResp1+0xaa>
  {
    return SDMMC_ERROR_NONE;
  21f75a:	2300      	movs	r3, #0
  21f75c:	e08d      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
  21f75e:	697b      	ldr	r3, [r7, #20]
  21f760:	2b00      	cmp	r3, #0
  21f762:	da02      	bge.n	21f76a <SDMMC_GetCmdResp1+0xb6>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  21f764:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
  21f768:	e087      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
  21f76a:	697b      	ldr	r3, [r7, #20]
  21f76c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  21f770:	2b00      	cmp	r3, #0
  21f772:	d001      	beq.n	21f778 <SDMMC_GetCmdResp1+0xc4>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  21f774:	2340      	movs	r3, #64	; 0x40
  21f776:	e080      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
  21f778:	697b      	ldr	r3, [r7, #20]
  21f77a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
  21f77e:	2b00      	cmp	r3, #0
  21f780:	d001      	beq.n	21f786 <SDMMC_GetCmdResp1+0xd2>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  21f782:	2380      	movs	r3, #128	; 0x80
  21f784:	e079      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
  21f786:	697b      	ldr	r3, [r7, #20]
  21f788:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
  21f78c:	2b00      	cmp	r3, #0
  21f78e:	d002      	beq.n	21f796 <SDMMC_GetCmdResp1+0xe2>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  21f790:	f44f 7380 	mov.w	r3, #256	; 0x100
  21f794:	e071      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
  21f796:	697b      	ldr	r3, [r7, #20]
  21f798:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  21f79c:	2b00      	cmp	r3, #0
  21f79e:	d002      	beq.n	21f7a6 <SDMMC_GetCmdResp1+0xf2>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  21f7a0:	f44f 7300 	mov.w	r3, #512	; 0x200
  21f7a4:	e069      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
  21f7a6:	697b      	ldr	r3, [r7, #20]
  21f7a8:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
  21f7ac:	2b00      	cmp	r3, #0
  21f7ae:	d002      	beq.n	21f7b6 <SDMMC_GetCmdResp1+0x102>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  21f7b0:	f44f 6380 	mov.w	r3, #1024	; 0x400
  21f7b4:	e061      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
  21f7b6:	697b      	ldr	r3, [r7, #20]
  21f7b8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  21f7bc:	2b00      	cmp	r3, #0
  21f7be:	d002      	beq.n	21f7c6 <SDMMC_GetCmdResp1+0x112>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  21f7c0:	f44f 6300 	mov.w	r3, #2048	; 0x800
  21f7c4:	e059      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
  21f7c6:	697b      	ldr	r3, [r7, #20]
  21f7c8:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  21f7cc:	2b00      	cmp	r3, #0
  21f7ce:	d002      	beq.n	21f7d6 <SDMMC_GetCmdResp1+0x122>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  21f7d0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  21f7d4:	e051      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
  21f7d6:	697b      	ldr	r3, [r7, #20]
  21f7d8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
  21f7dc:	2b00      	cmp	r3, #0
  21f7de:	d002      	beq.n	21f7e6 <SDMMC_GetCmdResp1+0x132>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  21f7e0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  21f7e4:	e049      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
  21f7e6:	697b      	ldr	r3, [r7, #20]
  21f7e8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  21f7ec:	2b00      	cmp	r3, #0
  21f7ee:	d002      	beq.n	21f7f6 <SDMMC_GetCmdResp1+0x142>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  21f7f0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  21f7f4:	e041      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
  21f7f6:	697b      	ldr	r3, [r7, #20]
  21f7f8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  21f7fc:	2b00      	cmp	r3, #0
  21f7fe:	d002      	beq.n	21f806 <SDMMC_GetCmdResp1+0x152>
  {
    return SDMMC_ERROR_CC_ERR;
  21f800:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  21f804:	e039      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
  21f806:	697b      	ldr	r3, [r7, #20]
  21f808:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  21f80c:	2b00      	cmp	r3, #0
  21f80e:	d002      	beq.n	21f816 <SDMMC_GetCmdResp1+0x162>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  21f810:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  21f814:	e031      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
  21f816:	697b      	ldr	r3, [r7, #20]
  21f818:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  21f81c:	2b00      	cmp	r3, #0
  21f81e:	d002      	beq.n	21f826 <SDMMC_GetCmdResp1+0x172>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  21f820:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  21f824:	e029      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
  21f826:	697b      	ldr	r3, [r7, #20]
  21f828:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  21f82c:	2b00      	cmp	r3, #0
  21f82e:	d002      	beq.n	21f836 <SDMMC_GetCmdResp1+0x182>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  21f830:	f44f 2300 	mov.w	r3, #524288	; 0x80000
  21f834:	e021      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
  21f836:	697b      	ldr	r3, [r7, #20]
  21f838:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  21f83c:	2b00      	cmp	r3, #0
  21f83e:	d002      	beq.n	21f846 <SDMMC_GetCmdResp1+0x192>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  21f840:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  21f844:	e019      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
  21f846:	697b      	ldr	r3, [r7, #20]
  21f848:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  21f84c:	2b00      	cmp	r3, #0
  21f84e:	d002      	beq.n	21f856 <SDMMC_GetCmdResp1+0x1a2>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  21f850:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
  21f854:	e011      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
  21f856:	697b      	ldr	r3, [r7, #20]
  21f858:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  21f85c:	2b00      	cmp	r3, #0
  21f85e:	d002      	beq.n	21f866 <SDMMC_GetCmdResp1+0x1b2>
  {
    return SDMMC_ERROR_ERASE_RESET;
  21f860:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
  21f864:	e009      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
  21f866:	697b      	ldr	r3, [r7, #20]
  21f868:	f003 0308 	and.w	r3, r3, #8
  21f86c:	2b00      	cmp	r3, #0
  21f86e:	d002      	beq.n	21f876 <SDMMC_GetCmdResp1+0x1c2>
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  21f870:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
  21f874:	e001      	b.n	21f87a <SDMMC_GetCmdResp1+0x1c6>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
  21f876:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  }
}
  21f87a:	4618      	mov	r0, r3
  21f87c:	3720      	adds	r7, #32
  21f87e:	46bd      	mov	sp, r7
  21f880:	bd80      	pop	{r7, pc}
  21f882:	bf00      	nop
  21f884:	20000004 	.word	0x20000004
  21f888:	10624dd3 	.word	0x10624dd3
  21f88c:	fdffe008 	.word	0xfdffe008

0021f890 <SDMMC_GetCmdResp2>:
  * @brief  Checks for error conditions for R2 (CID or CSD) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
  21f890:	b480      	push	{r7}
  21f892:	b085      	sub	sp, #20
  21f894:	af00      	add	r7, sp, #0
  21f896:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
  21f898:	4b1f      	ldr	r3, [pc, #124]	; (21f918 <SDMMC_GetCmdResp2+0x88>)
  21f89a:	681b      	ldr	r3, [r3, #0]
  21f89c:	4a1f      	ldr	r2, [pc, #124]	; (21f91c <SDMMC_GetCmdResp2+0x8c>)
  21f89e:	fba2 2303 	umull	r2, r3, r2, r3
  21f8a2:	0a5b      	lsrs	r3, r3, #9
  21f8a4:	f241 3288 	movw	r2, #5000	; 0x1388
  21f8a8:	fb02 f303 	mul.w	r3, r2, r3
  21f8ac:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
  21f8ae:	68fb      	ldr	r3, [r7, #12]
  21f8b0:	1e5a      	subs	r2, r3, #1
  21f8b2:	60fa      	str	r2, [r7, #12]
  21f8b4:	2b00      	cmp	r3, #0
  21f8b6:	d102      	bne.n	21f8be <SDMMC_GetCmdResp2+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
  21f8b8:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21f8bc:	e026      	b.n	21f90c <SDMMC_GetCmdResp2+0x7c>
    }
    sta_reg = SDMMCx->STA;
  21f8be:	687b      	ldr	r3, [r7, #4]
  21f8c0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f8c2:	60bb      	str	r3, [r7, #8]
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f8c4:	68bb      	ldr	r3, [r7, #8]
  21f8c6:	f003 0345 	and.w	r3, r3, #69	; 0x45
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
  21f8ca:	2b00      	cmp	r3, #0
  21f8cc:	d0ef      	beq.n	21f8ae <SDMMC_GetCmdResp2+0x1e>
  21f8ce:	68bb      	ldr	r3, [r7, #8]
  21f8d0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f8d4:	2b00      	cmp	r3, #0
  21f8d6:	d1ea      	bne.n	21f8ae <SDMMC_GetCmdResp2+0x1e>
    
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  21f8d8:	687b      	ldr	r3, [r7, #4]
  21f8da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f8dc:	f003 0304 	and.w	r3, r3, #4
  21f8e0:	2b00      	cmp	r3, #0
  21f8e2:	d004      	beq.n	21f8ee <SDMMC_GetCmdResp2+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
  21f8e4:	687b      	ldr	r3, [r7, #4]
  21f8e6:	2204      	movs	r2, #4
  21f8e8:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  21f8ea:	2304      	movs	r3, #4
  21f8ec:	e00e      	b.n	21f90c <SDMMC_GetCmdResp2+0x7c>
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
  21f8ee:	687b      	ldr	r3, [r7, #4]
  21f8f0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f8f2:	f003 0301 	and.w	r3, r3, #1
  21f8f6:	2b00      	cmp	r3, #0
  21f8f8:	d004      	beq.n	21f904 <SDMMC_GetCmdResp2+0x74>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
  21f8fa:	687b      	ldr	r3, [r7, #4]
  21f8fc:	2201      	movs	r2, #1
  21f8fe:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
  21f900:	2301      	movs	r3, #1
  21f902:	e003      	b.n	21f90c <SDMMC_GetCmdResp2+0x7c>
  }
  else
  {
    /* No error flag set */
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  21f904:	687b      	ldr	r3, [r7, #4]
  21f906:	22c5      	movs	r2, #197	; 0xc5
  21f908:	639a      	str	r2, [r3, #56]	; 0x38
  }

  return SDMMC_ERROR_NONE;
  21f90a:	2300      	movs	r3, #0
}
  21f90c:	4618      	mov	r0, r3
  21f90e:	3714      	adds	r7, #20
  21f910:	46bd      	mov	sp, r7
  21f912:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f916:	4770      	bx	lr
  21f918:	20000004 	.word	0x20000004
  21f91c:	10624dd3 	.word	0x10624dd3

0021f920 <SDMMC_GetCmdResp3>:
  * @brief  Checks for error conditions for R3 (OCR) response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
  21f920:	b480      	push	{r7}
  21f922:	b085      	sub	sp, #20
  21f924:	af00      	add	r7, sp, #0
  21f926:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
  21f928:	4b1a      	ldr	r3, [pc, #104]	; (21f994 <SDMMC_GetCmdResp3+0x74>)
  21f92a:	681b      	ldr	r3, [r3, #0]
  21f92c:	4a1a      	ldr	r2, [pc, #104]	; (21f998 <SDMMC_GetCmdResp3+0x78>)
  21f92e:	fba2 2303 	umull	r2, r3, r2, r3
  21f932:	0a5b      	lsrs	r3, r3, #9
  21f934:	f241 3288 	movw	r2, #5000	; 0x1388
  21f938:	fb02 f303 	mul.w	r3, r2, r3
  21f93c:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
  21f93e:	68fb      	ldr	r3, [r7, #12]
  21f940:	1e5a      	subs	r2, r3, #1
  21f942:	60fa      	str	r2, [r7, #12]
  21f944:	2b00      	cmp	r3, #0
  21f946:	d102      	bne.n	21f94e <SDMMC_GetCmdResp3+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
  21f948:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21f94c:	e01b      	b.n	21f986 <SDMMC_GetCmdResp3+0x66>
    }
    sta_reg = SDMMCx->STA;
  21f94e:	687b      	ldr	r3, [r7, #4]
  21f950:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f952:	60bb      	str	r3, [r7, #8]
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f954:	68bb      	ldr	r3, [r7, #8]
  21f956:	f003 0345 	and.w	r3, r3, #69	; 0x45
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
  21f95a:	2b00      	cmp	r3, #0
  21f95c:	d0ef      	beq.n	21f93e <SDMMC_GetCmdResp3+0x1e>
  21f95e:	68bb      	ldr	r3, [r7, #8]
  21f960:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f964:	2b00      	cmp	r3, #0
  21f966:	d1ea      	bne.n	21f93e <SDMMC_GetCmdResp3+0x1e>
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  21f968:	687b      	ldr	r3, [r7, #4]
  21f96a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f96c:	f003 0304 	and.w	r3, r3, #4
  21f970:	2b00      	cmp	r3, #0
  21f972:	d004      	beq.n	21f97e <SDMMC_GetCmdResp3+0x5e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
  21f974:	687b      	ldr	r3, [r7, #4]
  21f976:	2204      	movs	r2, #4
  21f978:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  21f97a:	2304      	movs	r3, #4
  21f97c:	e003      	b.n	21f986 <SDMMC_GetCmdResp3+0x66>
  }
  else
  {  
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  21f97e:	687b      	ldr	r3, [r7, #4]
  21f980:	22c5      	movs	r2, #197	; 0xc5
  21f982:	639a      	str	r2, [r3, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
  21f984:	2300      	movs	r3, #0
}
  21f986:	4618      	mov	r0, r3
  21f988:	3714      	adds	r7, #20
  21f98a:	46bd      	mov	sp, r7
  21f98c:	f85d 7b04 	ldr.w	r7, [sp], #4
  21f990:	4770      	bx	lr
  21f992:	bf00      	nop
  21f994:	20000004 	.word	0x20000004
  21f998:	10624dd3 	.word	0x10624dd3

0021f99c <SDMMC_GetCmdResp6>:
  * @param  pRCA: Pointer to the variable that will contain the SD card relative 
  *         address RCA   
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp6(SDMMC_TypeDef *SDMMCx, uint8_t SD_CMD, uint16_t *pRCA)
{
  21f99c:	b580      	push	{r7, lr}
  21f99e:	b088      	sub	sp, #32
  21f9a0:	af00      	add	r7, sp, #0
  21f9a2:	60f8      	str	r0, [r7, #12]
  21f9a4:	460b      	mov	r3, r1
  21f9a6:	607a      	str	r2, [r7, #4]
  21f9a8:	72fb      	strb	r3, [r7, #11]
  uint32_t response_r1;
  uint32_t sta_reg;

  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
  21f9aa:	4b35      	ldr	r3, [pc, #212]	; (21fa80 <SDMMC_GetCmdResp6+0xe4>)
  21f9ac:	681b      	ldr	r3, [r3, #0]
  21f9ae:	4a35      	ldr	r2, [pc, #212]	; (21fa84 <SDMMC_GetCmdResp6+0xe8>)
  21f9b0:	fba2 2303 	umull	r2, r3, r2, r3
  21f9b4:	0a5b      	lsrs	r3, r3, #9
  21f9b6:	f241 3288 	movw	r2, #5000	; 0x1388
  21f9ba:	fb02 f303 	mul.w	r3, r2, r3
  21f9be:	61fb      	str	r3, [r7, #28]
  
  do
  {
    if (count-- == 0U)
  21f9c0:	69fb      	ldr	r3, [r7, #28]
  21f9c2:	1e5a      	subs	r2, r3, #1
  21f9c4:	61fa      	str	r2, [r7, #28]
  21f9c6:	2b00      	cmp	r3, #0
  21f9c8:	d102      	bne.n	21f9d0 <SDMMC_GetCmdResp6+0x34>
    {
      return SDMMC_ERROR_TIMEOUT;
  21f9ca:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21f9ce:	e052      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
    }
    sta_reg = SDMMCx->STA;
  21f9d0:	68fb      	ldr	r3, [r7, #12]
  21f9d2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f9d4:	61bb      	str	r3, [r7, #24]
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f9d6:	69bb      	ldr	r3, [r7, #24]
  21f9d8:	f003 0345 	and.w	r3, r3, #69	; 0x45
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
  21f9dc:	2b00      	cmp	r3, #0
  21f9de:	d0ef      	beq.n	21f9c0 <SDMMC_GetCmdResp6+0x24>
  21f9e0:	69bb      	ldr	r3, [r7, #24]
  21f9e2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21f9e6:	2b00      	cmp	r3, #0
  21f9e8:	d1ea      	bne.n	21f9c0 <SDMMC_GetCmdResp6+0x24>
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  21f9ea:	68fb      	ldr	r3, [r7, #12]
  21f9ec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21f9ee:	f003 0304 	and.w	r3, r3, #4
  21f9f2:	2b00      	cmp	r3, #0
  21f9f4:	d004      	beq.n	21fa00 <SDMMC_GetCmdResp6+0x64>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
  21f9f6:	68fb      	ldr	r3, [r7, #12]
  21f9f8:	2204      	movs	r2, #4
  21f9fa:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  21f9fc:	2304      	movs	r3, #4
  21f9fe:	e03a      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
  21fa00:	68fb      	ldr	r3, [r7, #12]
  21fa02:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21fa04:	f003 0301 	and.w	r3, r3, #1
  21fa08:	2b00      	cmp	r3, #0
  21fa0a:	d004      	beq.n	21fa16 <SDMMC_GetCmdResp6+0x7a>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
  21fa0c:	68fb      	ldr	r3, [r7, #12]
  21fa0e:	2201      	movs	r2, #1
  21fa10:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
  21fa12:	2301      	movs	r3, #1
  21fa14:	e02f      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
  {
    /* Nothing to do */
  }
  
  /* Check response received is of desired command */
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
  21fa16:	68f8      	ldr	r0, [r7, #12]
  21fa18:	f7ff fb9e 	bl	21f158 <SDMMC_GetCommandResponse>
  21fa1c:	4603      	mov	r3, r0
  21fa1e:	461a      	mov	r2, r3
  21fa20:	7afb      	ldrb	r3, [r7, #11]
  21fa22:	4293      	cmp	r3, r2
  21fa24:	d001      	beq.n	21fa2a <SDMMC_GetCmdResp6+0x8e>
  {
    return SDMMC_ERROR_CMD_CRC_FAIL;
  21fa26:	2301      	movs	r3, #1
  21fa28:	e025      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
  }
  
  /* Clear all the static flags */
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  21fa2a:	68fb      	ldr	r3, [r7, #12]
  21fa2c:	22c5      	movs	r2, #197	; 0xc5
  21fa2e:	639a      	str	r2, [r3, #56]	; 0x38
  
  /* We have received response, retrieve it.  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);
  21fa30:	2100      	movs	r1, #0
  21fa32:	68f8      	ldr	r0, [r7, #12]
  21fa34:	f7ff fb9d 	bl	21f172 <SDMMC_GetResponse>
  21fa38:	6178      	str	r0, [r7, #20]
  
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
  21fa3a:	697b      	ldr	r3, [r7, #20]
  21fa3c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
  21fa40:	2b00      	cmp	r3, #0
  21fa42:	d106      	bne.n	21fa52 <SDMMC_GetCmdResp6+0xb6>
  {
    *pRCA = (uint16_t) (response_r1 >> 16);
  21fa44:	697b      	ldr	r3, [r7, #20]
  21fa46:	0c1b      	lsrs	r3, r3, #16
  21fa48:	b29a      	uxth	r2, r3
  21fa4a:	687b      	ldr	r3, [r7, #4]
  21fa4c:	801a      	strh	r2, [r3, #0]
    
    return SDMMC_ERROR_NONE;
  21fa4e:	2300      	movs	r3, #0
  21fa50:	e011      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
  }
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
  21fa52:	697b      	ldr	r3, [r7, #20]
  21fa54:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  21fa58:	2b00      	cmp	r3, #0
  21fa5a:	d002      	beq.n	21fa62 <SDMMC_GetCmdResp6+0xc6>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  21fa5c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  21fa60:	e009      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
  }
  else if((response_r1 & SDMMC_R6_COM_CRC_FAILED) == SDMMC_R6_COM_CRC_FAILED)
  21fa62:	697b      	ldr	r3, [r7, #20]
  21fa64:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  21fa68:	2b00      	cmp	r3, #0
  21fa6a:	d002      	beq.n	21fa72 <SDMMC_GetCmdResp6+0xd6>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  21fa6c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  21fa70:	e001      	b.n	21fa76 <SDMMC_GetCmdResp6+0xda>
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
  21fa72:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  }
}
  21fa76:	4618      	mov	r0, r3
  21fa78:	3720      	adds	r7, #32
  21fa7a:	46bd      	mov	sp, r7
  21fa7c:	bd80      	pop	{r7, pc}
  21fa7e:	bf00      	nop
  21fa80:	20000004 	.word	0x20000004
  21fa84:	10624dd3 	.word	0x10624dd3

0021fa88 <SDMMC_GetCmdResp7>:
  * @brief  Checks for error conditions for R7 response.
  * @param  hsd: SD handle
  * @retval SD Card error state
  */
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  21fa88:	b480      	push	{r7}
  21fa8a:	b085      	sub	sp, #20
  21fa8c:	af00      	add	r7, sp, #0
  21fa8e:	6078      	str	r0, [r7, #4]
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
  21fa90:	4b22      	ldr	r3, [pc, #136]	; (21fb1c <SDMMC_GetCmdResp7+0x94>)
  21fa92:	681b      	ldr	r3, [r3, #0]
  21fa94:	4a22      	ldr	r2, [pc, #136]	; (21fb20 <SDMMC_GetCmdResp7+0x98>)
  21fa96:	fba2 2303 	umull	r2, r3, r2, r3
  21fa9a:	0a5b      	lsrs	r3, r3, #9
  21fa9c:	f241 3288 	movw	r2, #5000	; 0x1388
  21faa0:	fb02 f303 	mul.w	r3, r2, r3
  21faa4:	60fb      	str	r3, [r7, #12]
  
  do
  {
    if (count-- == 0U)
  21faa6:	68fb      	ldr	r3, [r7, #12]
  21faa8:	1e5a      	subs	r2, r3, #1
  21faaa:	60fa      	str	r2, [r7, #12]
  21faac:	2b00      	cmp	r3, #0
  21faae:	d102      	bne.n	21fab6 <SDMMC_GetCmdResp7+0x2e>
    {
      return SDMMC_ERROR_TIMEOUT;
  21fab0:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
  21fab4:	e02c      	b.n	21fb10 <SDMMC_GetCmdResp7+0x88>
    }
    sta_reg = SDMMCx->STA;
  21fab6:	687b      	ldr	r3, [r7, #4]
  21fab8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21faba:	60bb      	str	r3, [r7, #8]
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21fabc:	68bb      	ldr	r3, [r7, #8]
  21fabe:	f003 0345 	and.w	r3, r3, #69	; 0x45
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
  21fac2:	2b00      	cmp	r3, #0
  21fac4:	d0ef      	beq.n	21faa6 <SDMMC_GetCmdResp7+0x1e>
  21fac6:	68bb      	ldr	r3, [r7, #8]
  21fac8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
  21facc:	2b00      	cmp	r3, #0
  21face:	d1ea      	bne.n	21faa6 <SDMMC_GetCmdResp7+0x1e>
    
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
  21fad0:	687b      	ldr	r3, [r7, #4]
  21fad2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21fad4:	f003 0304 	and.w	r3, r3, #4
  21fad8:	2b00      	cmp	r3, #0
  21fada:	d004      	beq.n	21fae6 <SDMMC_GetCmdResp7+0x5e>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
  21fadc:	687b      	ldr	r3, [r7, #4]
  21fade:	2204      	movs	r2, #4
  21fae0:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  21fae2:	2304      	movs	r3, #4
  21fae4:	e014      	b.n	21fb10 <SDMMC_GetCmdResp7+0x88>
  }
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
  21fae6:	687b      	ldr	r3, [r7, #4]
  21fae8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21faea:	f003 0301 	and.w	r3, r3, #1
  21faee:	2b00      	cmp	r3, #0
  21faf0:	d004      	beq.n	21fafc <SDMMC_GetCmdResp7+0x74>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
  21faf2:	687b      	ldr	r3, [r7, #4]
  21faf4:	2201      	movs	r2, #1
  21faf6:	639a      	str	r2, [r3, #56]	; 0x38
    
    return SDMMC_ERROR_CMD_CRC_FAIL;
  21faf8:	2301      	movs	r3, #1
  21fafa:	e009      	b.n	21fb10 <SDMMC_GetCmdResp7+0x88>
  else
  {
    /* Nothing to do */
  }
  
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
  21fafc:	687b      	ldr	r3, [r7, #4]
  21fafe:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  21fb00:	f003 0340 	and.w	r3, r3, #64	; 0x40
  21fb04:	2b00      	cmp	r3, #0
  21fb06:	d002      	beq.n	21fb0e <SDMMC_GetCmdResp7+0x86>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
  21fb08:	687b      	ldr	r3, [r7, #4]
  21fb0a:	2240      	movs	r2, #64	; 0x40
  21fb0c:	639a      	str	r2, [r3, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
  21fb0e:	2300      	movs	r3, #0
  
}
  21fb10:	4618      	mov	r0, r3
  21fb12:	3714      	adds	r7, #20
  21fb14:	46bd      	mov	sp, r7
  21fb16:	f85d 7b04 	ldr.w	r7, [sp], #4
  21fb1a:	4770      	bx	lr
  21fb1c:	20000004 	.word	0x20000004
  21fb20:	10624dd3 	.word	0x10624dd3

0021fb24 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */
#include "sd_card.h"
/* USER CODE END Variables */

void MX_FATFS_Init(void)
{
  21fb24:	b580      	push	{r7, lr}
  21fb26:	af00      	add	r7, sp, #0
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
  21fb28:	4905      	ldr	r1, [pc, #20]	; (21fb40 <MX_FATFS_Init+0x1c>)
  21fb2a:	4806      	ldr	r0, [pc, #24]	; (21fb44 <MX_FATFS_Init+0x20>)
  21fb2c:	f003 fc9e 	bl	22346c <FATFS_LinkDriver>
  21fb30:	4603      	mov	r3, r0
  21fb32:	461a      	mov	r2, r3
  21fb34:	4b04      	ldr	r3, [pc, #16]	; (21fb48 <MX_FATFS_Init+0x24>)
  21fb36:	701a      	strb	r2, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */
  SDCard_Init();
  21fb38:	f7e1 fcca 	bl	2014d0 <SDCard_Init>
  /* USER CODE END Init */
}
  21fb3c:	bf00      	nop
  21fb3e:	bd80      	pop	{r7, pc}
  21fb40:	20014e64 	.word	0x20014e64
  21fb44:	00229390 	.word	0x00229390
  21fb48:	20014e60 	.word	0x20014e60

0021fb4c <get_fattime>:
  * @brief  Gets Time from RTC
  * @param  None
  * @retval Time in DWORD
  */
DWORD get_fattime(void)
{
  21fb4c:	b480      	push	{r7}
  21fb4e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN get_fattime */
  return 0;
  21fb50:	2300      	movs	r3, #0
  /* USER CODE END get_fattime */
}
  21fb52:	4618      	mov	r0, r3
  21fb54:	46bd      	mov	sp, r7
  21fb56:	f85d 7b04 	ldr.w	r7, [sp], #4
  21fb5a:	4770      	bx	lr

0021fb5c <BSP_SD_Init>:
/**
  * @brief  Initializes the SD card device.
  * @retval SD status
  */
__weak uint8_t BSP_SD_Init(void)
{
  21fb5c:	b580      	push	{r7, lr}
  21fb5e:	b082      	sub	sp, #8
  21fb60:	af00      	add	r7, sp, #0
  uint8_t sd_state = MSD_OK;
  21fb62:	2300      	movs	r3, #0
  21fb64:	71fb      	strb	r3, [r7, #7]
  /* Check if the SD card is plugged in the slot */
  if (BSP_SD_IsDetected() != SD_PRESENT)
  21fb66:	f000 f896 	bl	21fc96 <BSP_SD_IsDetected>
  21fb6a:	4603      	mov	r3, r0
  21fb6c:	2b01      	cmp	r3, #1
  21fb6e:	d001      	beq.n	21fb74 <BSP_SD_Init+0x18>
  {
    return MSD_ERROR_SD_NOT_PRESENT;
  21fb70:	2302      	movs	r3, #2
  21fb72:	e012      	b.n	21fb9a <BSP_SD_Init+0x3e>
  }
  /* HAL SD initialization */
  sd_state = HAL_SD_Init(&hsd1);
  21fb74:	480b      	ldr	r0, [pc, #44]	; (21fba4 <BSP_SD_Init+0x48>)
  21fb76:	f7fb ff79 	bl	21ba6c <HAL_SD_Init>
  21fb7a:	4603      	mov	r3, r0
  21fb7c:	71fb      	strb	r3, [r7, #7]
  /* Configure SD Bus width (4 bits mode selected) */
  if (sd_state == MSD_OK)
  21fb7e:	79fb      	ldrb	r3, [r7, #7]
  21fb80:	2b00      	cmp	r3, #0
  21fb82:	d109      	bne.n	21fb98 <BSP_SD_Init+0x3c>
  {
    /* Enable wide operation */
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
  21fb84:	f44f 6100 	mov.w	r1, #2048	; 0x800
  21fb88:	4806      	ldr	r0, [pc, #24]	; (21fba4 <BSP_SD_Init+0x48>)
  21fb8a:	f7fc fd3d 	bl	21c608 <HAL_SD_ConfigWideBusOperation>
  21fb8e:	4603      	mov	r3, r0
  21fb90:	2b00      	cmp	r3, #0
  21fb92:	d001      	beq.n	21fb98 <BSP_SD_Init+0x3c>
    {
      sd_state = MSD_ERROR;
  21fb94:	2301      	movs	r3, #1
  21fb96:	71fb      	strb	r3, [r7, #7]
    }
  }

  return sd_state;
  21fb98:	79fb      	ldrb	r3, [r7, #7]
}
  21fb9a:	4618      	mov	r0, r3
  21fb9c:	3708      	adds	r7, #8
  21fb9e:	46bd      	mov	sp, r7
  21fba0:	bd80      	pop	{r7, pc}
  21fba2:	bf00      	nop
  21fba4:	20014b9c 	.word	0x20014b9c

0021fba8 <BSP_SD_ReadBlocks_DMA>:
  * @param  ReadAddr: Address from where data is to be read
  * @param  NumOfBlocks: Number of SD blocks to read
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks_DMA(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks)
{
  21fba8:	b580      	push	{r7, lr}
  21fbaa:	b086      	sub	sp, #24
  21fbac:	af00      	add	r7, sp, #0
  21fbae:	60f8      	str	r0, [r7, #12]
  21fbb0:	60b9      	str	r1, [r7, #8]
  21fbb2:	607a      	str	r2, [r7, #4]
  uint8_t sd_state = MSD_OK;
  21fbb4:	2300      	movs	r3, #0
  21fbb6:	75fb      	strb	r3, [r7, #23]

  /* Read block(s) in DMA transfer mode */
  if (HAL_SD_ReadBlocks_DMA(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks) != HAL_OK)
  21fbb8:	687b      	ldr	r3, [r7, #4]
  21fbba:	68ba      	ldr	r2, [r7, #8]
  21fbbc:	68f9      	ldr	r1, [r7, #12]
  21fbbe:	4806      	ldr	r0, [pc, #24]	; (21fbd8 <BSP_SD_ReadBlocks_DMA+0x30>)
  21fbc0:	f7fc f80a 	bl	21bbd8 <HAL_SD_ReadBlocks_DMA>
  21fbc4:	4603      	mov	r3, r0
  21fbc6:	2b00      	cmp	r3, #0
  21fbc8:	d001      	beq.n	21fbce <BSP_SD_ReadBlocks_DMA+0x26>
  {
    sd_state = MSD_ERROR;
  21fbca:	2301      	movs	r3, #1
  21fbcc:	75fb      	strb	r3, [r7, #23]
  }

  return sd_state;
  21fbce:	7dfb      	ldrb	r3, [r7, #23]
}
  21fbd0:	4618      	mov	r0, r3
  21fbd2:	3718      	adds	r7, #24
  21fbd4:	46bd      	mov	sp, r7
  21fbd6:	bd80      	pop	{r7, pc}
  21fbd8:	20014b9c 	.word	0x20014b9c

0021fbdc <BSP_SD_WriteBlocks_DMA>:
  * @param  WriteAddr: Address from where data is to be written
  * @param  NumOfBlocks: Number of SD blocks to write
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks_DMA(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks)
{
  21fbdc:	b580      	push	{r7, lr}
  21fbde:	b086      	sub	sp, #24
  21fbe0:	af00      	add	r7, sp, #0
  21fbe2:	60f8      	str	r0, [r7, #12]
  21fbe4:	60b9      	str	r1, [r7, #8]
  21fbe6:	607a      	str	r2, [r7, #4]
  uint8_t sd_state = MSD_OK;
  21fbe8:	2300      	movs	r3, #0
  21fbea:	75fb      	strb	r3, [r7, #23]

  /* Write block(s) in DMA transfer mode */
  if (HAL_SD_WriteBlocks_DMA(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks) != HAL_OK)
  21fbec:	687b      	ldr	r3, [r7, #4]
  21fbee:	68ba      	ldr	r2, [r7, #8]
  21fbf0:	68f9      	ldr	r1, [r7, #12]
  21fbf2:	4806      	ldr	r0, [pc, #24]	; (21fc0c <BSP_SD_WriteBlocks_DMA+0x30>)
  21fbf4:	f7fc f8d2 	bl	21bd9c <HAL_SD_WriteBlocks_DMA>
  21fbf8:	4603      	mov	r3, r0
  21fbfa:	2b00      	cmp	r3, #0
  21fbfc:	d001      	beq.n	21fc02 <BSP_SD_WriteBlocks_DMA+0x26>
  {
    sd_state = MSD_ERROR;
  21fbfe:	2301      	movs	r3, #1
  21fc00:	75fb      	strb	r3, [r7, #23]
  }

  return sd_state;
  21fc02:	7dfb      	ldrb	r3, [r7, #23]
}
  21fc04:	4618      	mov	r0, r3
  21fc06:	3718      	adds	r7, #24
  21fc08:	46bd      	mov	sp, r7
  21fc0a:	bd80      	pop	{r7, pc}
  21fc0c:	20014b9c 	.word	0x20014b9c

0021fc10 <BSP_SD_GetCardState>:
  *          This value can be one of the following values:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
  21fc10:	b580      	push	{r7, lr}
  21fc12:	af00      	add	r7, sp, #0
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
  21fc14:	4805      	ldr	r0, [pc, #20]	; (21fc2c <BSP_SD_GetCardState+0x1c>)
  21fc16:	f7fc fd91 	bl	21c73c <HAL_SD_GetCardState>
  21fc1a:	4603      	mov	r3, r0
  21fc1c:	2b04      	cmp	r3, #4
  21fc1e:	bf14      	ite	ne
  21fc20:	2301      	movne	r3, #1
  21fc22:	2300      	moveq	r3, #0
  21fc24:	b2db      	uxtb	r3, r3
}
  21fc26:	4618      	mov	r0, r3
  21fc28:	bd80      	pop	{r7, pc}
  21fc2a:	bf00      	nop
  21fc2c:	20014b9c 	.word	0x20014b9c

0021fc30 <BSP_SD_GetCardInfo>:
  * @brief  Get SD information about specific SD card.
  * @param  CardInfo: Pointer to HAL_SD_CardInfoTypedef structure
  * @retval None
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  21fc30:	b580      	push	{r7, lr}
  21fc32:	b082      	sub	sp, #8
  21fc34:	af00      	add	r7, sp, #0
  21fc36:	6078      	str	r0, [r7, #4]
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
  21fc38:	6879      	ldr	r1, [r7, #4]
  21fc3a:	4803      	ldr	r0, [pc, #12]	; (21fc48 <BSP_SD_GetCardInfo+0x18>)
  21fc3c:	f7fc fcb8 	bl	21c5b0 <HAL_SD_GetCardInfo>
}
  21fc40:	bf00      	nop
  21fc42:	3708      	adds	r7, #8
  21fc44:	46bd      	mov	sp, r7
  21fc46:	bd80      	pop	{r7, pc}
  21fc48:	20014b9c 	.word	0x20014b9c

0021fc4c <HAL_SD_AbortCallback>:
  * @brief SD Abort callbacks
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_AbortCallback(SD_HandleTypeDef *hsd)
{
  21fc4c:	b580      	push	{r7, lr}
  21fc4e:	b082      	sub	sp, #8
  21fc50:	af00      	add	r7, sp, #0
  21fc52:	6078      	str	r0, [r7, #4]
  BSP_SD_AbortCallback();
  21fc54:	f000 f818 	bl	21fc88 <BSP_SD_AbortCallback>
}
  21fc58:	bf00      	nop
  21fc5a:	3708      	adds	r7, #8
  21fc5c:	46bd      	mov	sp, r7
  21fc5e:	bd80      	pop	{r7, pc}

0021fc60 <HAL_SD_TxCpltCallback>:
  * @brief Tx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsd)
{
  21fc60:	b580      	push	{r7, lr}
  21fc62:	b082      	sub	sp, #8
  21fc64:	af00      	add	r7, sp, #0
  21fc66:	6078      	str	r0, [r7, #4]
  BSP_SD_WriteCpltCallback();
  21fc68:	f000 fb00 	bl	22026c <BSP_SD_WriteCpltCallback>
}
  21fc6c:	bf00      	nop
  21fc6e:	3708      	adds	r7, #8
  21fc70:	46bd      	mov	sp, r7
  21fc72:	bd80      	pop	{r7, pc}

0021fc74 <HAL_SD_RxCpltCallback>:
  * @brief Rx Transfer completed callback
  * @param hsd: SD handle
  * @retval None
  */
void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsd)
{
  21fc74:	b580      	push	{r7, lr}
  21fc76:	b082      	sub	sp, #8
  21fc78:	af00      	add	r7, sp, #0
  21fc7a:	6078      	str	r0, [r7, #4]
  BSP_SD_ReadCpltCallback();
  21fc7c:	f000 fb04 	bl	220288 <BSP_SD_ReadCpltCallback>
}
  21fc80:	bf00      	nop
  21fc82:	3708      	adds	r7, #8
  21fc84:	46bd      	mov	sp, r7
  21fc86:	bd80      	pop	{r7, pc}

0021fc88 <BSP_SD_AbortCallback>:
  * @brief BSP SD Abort callback
  * @retval None
  * @note empty (up to the user to fill it in or to remove it if useless)
  */
__weak void BSP_SD_AbortCallback(void)
{
  21fc88:	b480      	push	{r7}
  21fc8a:	af00      	add	r7, sp, #0

}
  21fc8c:	bf00      	nop
  21fc8e:	46bd      	mov	sp, r7
  21fc90:	f85d 7b04 	ldr.w	r7, [sp], #4
  21fc94:	4770      	bx	lr

0021fc96 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
  21fc96:	b480      	push	{r7}
  21fc98:	b083      	sub	sp, #12
  21fc9a:	af00      	add	r7, sp, #0
  __IO uint8_t status = SD_PRESENT;
  21fc9c:	2301      	movs	r3, #1
  21fc9e:	71fb      	strb	r3, [r7, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */

  return status;
  21fca0:	79fb      	ldrb	r3, [r7, #7]
  21fca2:	b2db      	uxtb	r3, r3
}
  21fca4:	4618      	mov	r0, r3
  21fca6:	370c      	adds	r7, #12
  21fca8:	46bd      	mov	sp, r7
  21fcaa:	f85d 7b04 	ldr.w	r7, [sp], #4
  21fcae:	4770      	bx	lr

0021fcb0 <SCB_InvalidateDCache_by_Addr>:
{
  21fcb0:	b480      	push	{r7}
  21fcb2:	b087      	sub	sp, #28
  21fcb4:	af00      	add	r7, sp, #0
  21fcb6:	6078      	str	r0, [r7, #4]
  21fcb8:	6039      	str	r1, [r7, #0]
     int32_t op_size = dsize;
  21fcba:	683b      	ldr	r3, [r7, #0]
  21fcbc:	617b      	str	r3, [r7, #20]
    uint32_t op_addr = (uint32_t)addr;
  21fcbe:	687b      	ldr	r3, [r7, #4]
  21fcc0:	613b      	str	r3, [r7, #16]
     int32_t linesize = 32;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
  21fcc2:	2320      	movs	r3, #32
  21fcc4:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("dsb 0xF":::"memory");
  21fcc6:	f3bf 8f4f 	dsb	sy
    while (op_size > 0) {
  21fcca:	e00b      	b.n	21fce4 <SCB_InvalidateDCache_by_Addr+0x34>
      SCB->DCIMVAC = op_addr;
  21fccc:	4a0c      	ldr	r2, [pc, #48]	; (21fd00 <SCB_InvalidateDCache_by_Addr+0x50>)
  21fcce:	693b      	ldr	r3, [r7, #16]
  21fcd0:	f8c2 325c 	str.w	r3, [r2, #604]	; 0x25c
      op_addr += (uint32_t)linesize;
  21fcd4:	68fb      	ldr	r3, [r7, #12]
  21fcd6:	693a      	ldr	r2, [r7, #16]
  21fcd8:	4413      	add	r3, r2
  21fcda:	613b      	str	r3, [r7, #16]
      op_size -=           linesize;
  21fcdc:	697a      	ldr	r2, [r7, #20]
  21fcde:	68fb      	ldr	r3, [r7, #12]
  21fce0:	1ad3      	subs	r3, r2, r3
  21fce2:	617b      	str	r3, [r7, #20]
    while (op_size > 0) {
  21fce4:	697b      	ldr	r3, [r7, #20]
  21fce6:	2b00      	cmp	r3, #0
  21fce8:	dcf0      	bgt.n	21fccc <SCB_InvalidateDCache_by_Addr+0x1c>
  21fcea:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  21fcee:	f3bf 8f6f 	isb	sy
}
  21fcf2:	bf00      	nop
  21fcf4:	371c      	adds	r7, #28
  21fcf6:	46bd      	mov	sp, r7
  21fcf8:	f85d 7b04 	ldr.w	r7, [sp], #4
  21fcfc:	4770      	bx	lr
  21fcfe:	bf00      	nop
  21fd00:	e000ed00 	.word	0xe000ed00

0021fd04 <SCB_CleanDCache_by_Addr>:
  \details Cleans D-Cache for the given address
  \param[in]   addr    address (aligned to 32-byte boundary)
  \param[in]   dsize   size of memory block (in number of bytes)
*/
__STATIC_INLINE void SCB_CleanDCache_by_Addr (uint32_t *addr, int32_t dsize)
{
  21fd04:	b480      	push	{r7}
  21fd06:	b087      	sub	sp, #28
  21fd08:	af00      	add	r7, sp, #0
  21fd0a:	6078      	str	r0, [r7, #4]
  21fd0c:	6039      	str	r1, [r7, #0]
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
     int32_t op_size = dsize;
  21fd0e:	683b      	ldr	r3, [r7, #0]
  21fd10:	617b      	str	r3, [r7, #20]
    uint32_t op_addr = (uint32_t) addr;
  21fd12:	687b      	ldr	r3, [r7, #4]
  21fd14:	613b      	str	r3, [r7, #16]
     int32_t linesize = 32;                /* in Cortex-M7 size of cache line is fixed to 8 words (32 bytes) */
  21fd16:	2320      	movs	r3, #32
  21fd18:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("dsb 0xF":::"memory");
  21fd1a:	f3bf 8f4f 	dsb	sy

    __DSB();

    while (op_size > 0) {
  21fd1e:	e00b      	b.n	21fd38 <SCB_CleanDCache_by_Addr+0x34>
      SCB->DCCMVAC = op_addr;
  21fd20:	4a0c      	ldr	r2, [pc, #48]	; (21fd54 <SCB_CleanDCache_by_Addr+0x50>)
  21fd22:	693b      	ldr	r3, [r7, #16]
  21fd24:	f8c2 3268 	str.w	r3, [r2, #616]	; 0x268
      op_addr += (uint32_t)linesize;
  21fd28:	68fb      	ldr	r3, [r7, #12]
  21fd2a:	693a      	ldr	r2, [r7, #16]
  21fd2c:	4413      	add	r3, r2
  21fd2e:	613b      	str	r3, [r7, #16]
      op_size -=           linesize;
  21fd30:	697a      	ldr	r2, [r7, #20]
  21fd32:	68fb      	ldr	r3, [r7, #12]
  21fd34:	1ad3      	subs	r3, r2, r3
  21fd36:	617b      	str	r3, [r7, #20]
    while (op_size > 0) {
  21fd38:	697b      	ldr	r3, [r7, #20]
  21fd3a:	2b00      	cmp	r3, #0
  21fd3c:	dcf0      	bgt.n	21fd20 <SCB_CleanDCache_by_Addr+0x1c>
  21fd3e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  21fd42:	f3bf 8f6f 	isb	sy
    }

    __DSB();
    __ISB();
  #endif
}
  21fd46:	bf00      	nop
  21fd48:	371c      	adds	r7, #28
  21fd4a:	46bd      	mov	sp, r7
  21fd4c:	f85d 7b04 	ldr.w	r7, [sp], #4
  21fd50:	4770      	bx	lr
  21fd52:	bf00      	nop
  21fd54:	e000ed00 	.word	0xe000ed00

0021fd58 <SD_CheckStatusWithTimeout>:
/* USER CODE END beforeFunctionSection */

/* Private functions ---------------------------------------------------------*/

static int SD_CheckStatusWithTimeout(uint32_t timeout)
{
  21fd58:	b580      	push	{r7, lr}
  21fd5a:	b084      	sub	sp, #16
  21fd5c:	af00      	add	r7, sp, #0
  21fd5e:	6078      	str	r0, [r7, #4]
  uint32_t timer;
  /* block until SDIO peripheral is ready again or a timeout occur */
#if (osCMSIS <= 0x20000U)
  timer = osKernelSysTick();
  21fd60:	f003 fcfa 	bl	223758 <osKernelSysTick>
  21fd64:	60f8      	str	r0, [r7, #12]
  while( osKernelSysTick() - timer < timeout)
  21fd66:	e006      	b.n	21fd76 <SD_CheckStatusWithTimeout+0x1e>
#else
  timer = osKernelGetTickCount();
  while( osKernelGetTickCount() - timer < timeout)
#endif
  {
    if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
  21fd68:	f7ff ff52 	bl	21fc10 <BSP_SD_GetCardState>
  21fd6c:	4603      	mov	r3, r0
  21fd6e:	2b00      	cmp	r3, #0
  21fd70:	d101      	bne.n	21fd76 <SD_CheckStatusWithTimeout+0x1e>
    {
      return 0;
  21fd72:	2300      	movs	r3, #0
  21fd74:	e009      	b.n	21fd8a <SD_CheckStatusWithTimeout+0x32>
  while( osKernelSysTick() - timer < timeout)
  21fd76:	f003 fcef 	bl	223758 <osKernelSysTick>
  21fd7a:	4602      	mov	r2, r0
  21fd7c:	68fb      	ldr	r3, [r7, #12]
  21fd7e:	1ad2      	subs	r2, r2, r3
  21fd80:	687b      	ldr	r3, [r7, #4]
  21fd82:	429a      	cmp	r2, r3
  21fd84:	d3f0      	bcc.n	21fd68 <SD_CheckStatusWithTimeout+0x10>
    }
  }

  return -1;
  21fd86:	f04f 33ff 	mov.w	r3, #4294967295
}
  21fd8a:	4618      	mov	r0, r3
  21fd8c:	3710      	adds	r7, #16
  21fd8e:	46bd      	mov	sp, r7
  21fd90:	bd80      	pop	{r7, pc}
	...

0021fd94 <SD_CheckStatus>:

static DSTATUS SD_CheckStatus(BYTE lun)
{
  21fd94:	b580      	push	{r7, lr}
  21fd96:	b082      	sub	sp, #8
  21fd98:	af00      	add	r7, sp, #0
  21fd9a:	4603      	mov	r3, r0
  21fd9c:	71fb      	strb	r3, [r7, #7]
  Stat = STA_NOINIT;
  21fd9e:	4b0b      	ldr	r3, [pc, #44]	; (21fdcc <SD_CheckStatus+0x38>)
  21fda0:	2201      	movs	r2, #1
  21fda2:	701a      	strb	r2, [r3, #0]

  if(BSP_SD_GetCardState() == SD_TRANSFER_OK)
  21fda4:	f7ff ff34 	bl	21fc10 <BSP_SD_GetCardState>
  21fda8:	4603      	mov	r3, r0
  21fdaa:	2b00      	cmp	r3, #0
  21fdac:	d107      	bne.n	21fdbe <SD_CheckStatus+0x2a>
  {
    Stat &= ~STA_NOINIT;
  21fdae:	4b07      	ldr	r3, [pc, #28]	; (21fdcc <SD_CheckStatus+0x38>)
  21fdb0:	781b      	ldrb	r3, [r3, #0]
  21fdb2:	b2db      	uxtb	r3, r3
  21fdb4:	f023 0301 	bic.w	r3, r3, #1
  21fdb8:	b2da      	uxtb	r2, r3
  21fdba:	4b04      	ldr	r3, [pc, #16]	; (21fdcc <SD_CheckStatus+0x38>)
  21fdbc:	701a      	strb	r2, [r3, #0]
  }

  return Stat;
  21fdbe:	4b03      	ldr	r3, [pc, #12]	; (21fdcc <SD_CheckStatus+0x38>)
  21fdc0:	781b      	ldrb	r3, [r3, #0]
  21fdc2:	b2db      	uxtb	r3, r3
}
  21fdc4:	4618      	mov	r0, r3
  21fdc6:	3708      	adds	r7, #8
  21fdc8:	46bd      	mov	sp, r7
  21fdca:	bd80      	pop	{r7, pc}
  21fdcc:	2000000d 	.word	0x2000000d

0021fdd0 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
  21fdd0:	b590      	push	{r4, r7, lr}
  21fdd2:	b087      	sub	sp, #28
  21fdd4:	af00      	add	r7, sp, #0
  21fdd6:	4603      	mov	r3, r0
  21fdd8:	71fb      	strb	r3, [r7, #7]
Stat = STA_NOINIT;
  21fdda:	4b20      	ldr	r3, [pc, #128]	; (21fe5c <SD_initialize+0x8c>)
  21fddc:	2201      	movs	r2, #1
  21fdde:	701a      	strb	r2, [r3, #0]
  /*
   * check that the kernel has been started before continuing
   * as the osMessage API will fail otherwise
   */
#if (osCMSIS <= 0x20000U)
  if(osKernelRunning())
  21fde0:	f003 fcae 	bl	223740 <osKernelRunning>
  21fde4:	4603      	mov	r3, r0
  21fde6:	2b00      	cmp	r3, #0
  21fde8:	d030      	beq.n	21fe4c <SD_initialize+0x7c>
  if(osKernelGetState() == osKernelRunning)
#endif
  {
#if !defined(DISABLE_SD_INIT)

    if(BSP_SD_Init() == MSD_OK)
  21fdea:	f7ff feb7 	bl	21fb5c <BSP_SD_Init>
  21fdee:	4603      	mov	r3, r0
  21fdf0:	2b00      	cmp	r3, #0
  21fdf2:	d107      	bne.n	21fe04 <SD_initialize+0x34>
    {
      Stat = SD_CheckStatus(lun);
  21fdf4:	79fb      	ldrb	r3, [r7, #7]
  21fdf6:	4618      	mov	r0, r3
  21fdf8:	f7ff ffcc 	bl	21fd94 <SD_CheckStatus>
  21fdfc:	4603      	mov	r3, r0
  21fdfe:	461a      	mov	r2, r3
  21fe00:	4b16      	ldr	r3, [pc, #88]	; (21fe5c <SD_initialize+0x8c>)
  21fe02:	701a      	strb	r2, [r3, #0]
    /*
    * if the SD is correctly initialized, create the operation queue
    * if not already created
    */

    if (Stat != STA_NOINIT)
  21fe04:	4b15      	ldr	r3, [pc, #84]	; (21fe5c <SD_initialize+0x8c>)
  21fe06:	781b      	ldrb	r3, [r3, #0]
  21fe08:	b2db      	uxtb	r3, r3
  21fe0a:	2b01      	cmp	r3, #1
  21fe0c:	d01e      	beq.n	21fe4c <SD_initialize+0x7c>
    {
      if (SDQueueID == NULL)
  21fe0e:	4b14      	ldr	r3, [pc, #80]	; (21fe60 <SD_initialize+0x90>)
  21fe10:	681b      	ldr	r3, [r3, #0]
  21fe12:	2b00      	cmp	r3, #0
  21fe14:	d10e      	bne.n	21fe34 <SD_initialize+0x64>
      {
 #if (osCMSIS <= 0x20000U)
      osMessageQDef(SD_Queue, QUEUE_SIZE, uint16_t);
  21fe16:	4b13      	ldr	r3, [pc, #76]	; (21fe64 <SD_initialize+0x94>)
  21fe18:	f107 0408 	add.w	r4, r7, #8
  21fe1c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
  21fe1e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
      SDQueueID = osMessageCreate (osMessageQ(SD_Queue), NULL);
  21fe22:	f107 0308 	add.w	r3, r7, #8
  21fe26:	2100      	movs	r1, #0
  21fe28:	4618      	mov	r0, r3
  21fe2a:	f003 fdbc 	bl	2239a6 <osMessageCreate>
  21fe2e:	4602      	mov	r2, r0
  21fe30:	4b0b      	ldr	r3, [pc, #44]	; (21fe60 <SD_initialize+0x90>)
  21fe32:	601a      	str	r2, [r3, #0]
#else
      SDQueueID = osMessageQueueNew(QUEUE_SIZE, 2, NULL);
#endif
      }

      if (SDQueueID == NULL)
  21fe34:	4b0a      	ldr	r3, [pc, #40]	; (21fe60 <SD_initialize+0x90>)
  21fe36:	681b      	ldr	r3, [r3, #0]
  21fe38:	2b00      	cmp	r3, #0
  21fe3a:	d107      	bne.n	21fe4c <SD_initialize+0x7c>
      {
        Stat |= STA_NOINIT;
  21fe3c:	4b07      	ldr	r3, [pc, #28]	; (21fe5c <SD_initialize+0x8c>)
  21fe3e:	781b      	ldrb	r3, [r3, #0]
  21fe40:	b2db      	uxtb	r3, r3
  21fe42:	f043 0301 	orr.w	r3, r3, #1
  21fe46:	b2da      	uxtb	r2, r3
  21fe48:	4b04      	ldr	r3, [pc, #16]	; (21fe5c <SD_initialize+0x8c>)
  21fe4a:	701a      	strb	r2, [r3, #0]
      }
    }
  }

  return Stat;
  21fe4c:	4b03      	ldr	r3, [pc, #12]	; (21fe5c <SD_initialize+0x8c>)
  21fe4e:	781b      	ldrb	r3, [r3, #0]
  21fe50:	b2db      	uxtb	r3, r3
}
  21fe52:	4618      	mov	r0, r3
  21fe54:	371c      	adds	r7, #28
  21fe56:	46bd      	mov	sp, r7
  21fe58:	bd90      	pop	{r4, r7, pc}
  21fe5a:	bf00      	nop
  21fe5c:	2000000d 	.word	0x2000000d
  21fe60:	20010ba0 	.word	0x20010ba0
  21fe64:	00229200 	.word	0x00229200

0021fe68 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
  21fe68:	b580      	push	{r7, lr}
  21fe6a:	b082      	sub	sp, #8
  21fe6c:	af00      	add	r7, sp, #0
  21fe6e:	4603      	mov	r3, r0
  21fe70:	71fb      	strb	r3, [r7, #7]
  return SD_CheckStatus(lun);
  21fe72:	79fb      	ldrb	r3, [r7, #7]
  21fe74:	4618      	mov	r0, r3
  21fe76:	f7ff ff8d 	bl	21fd94 <SD_CheckStatus>
  21fe7a:	4603      	mov	r3, r0
}
  21fe7c:	4618      	mov	r0, r3
  21fe7e:	3708      	adds	r7, #8
  21fe80:	46bd      	mov	sp, r7
  21fe82:	bd80      	pop	{r7, pc}

0021fe84 <SD_read>:
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */

DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
  21fe84:	b580      	push	{r7, lr}
  21fe86:	b090      	sub	sp, #64	; 0x40
  21fe88:	af00      	add	r7, sp, #0
  21fe8a:	61b9      	str	r1, [r7, #24]
  21fe8c:	617a      	str	r2, [r7, #20]
  21fe8e:	613b      	str	r3, [r7, #16]
  21fe90:	4603      	mov	r3, r0
  21fe92:	77fb      	strb	r3, [r7, #31]
  DRESULT res = RES_ERROR;
  21fe94:	2301      	movs	r3, #1
  21fe96:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
#endif
  /*
  * ensure the SDCard is ready for a new operation
  */

  if (SD_CheckStatusWithTimeout(SD_TIMEOUT) < 0)
  21fe9a:	f247 5030 	movw	r0, #30000	; 0x7530
  21fe9e:	f7ff ff5b 	bl	21fd58 <SD_CheckStatusWithTimeout>
  21fea2:	4603      	mov	r3, r0
  21fea4:	2b00      	cmp	r3, #0
  21fea6:	da02      	bge.n	21feae <SD_read+0x2a>
  {
    return res;
  21fea8:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  21feac:	e0b5      	b.n	22001a <SD_read+0x196>
  }

#if defined(ENABLE_SCRATCH_BUFFER)
  if (!((uint32_t)buff & 0x3))
  21feae:	69bb      	ldr	r3, [r7, #24]
  21feb0:	f003 0303 	and.w	r3, r3, #3
  21feb4:	2b00      	cmp	r3, #0
  21feb6:	d142      	bne.n	21ff3e <SD_read+0xba>
  {
#endif
    /* Fast path cause destination buffer is correctly aligned */
    uint8_t ret = BSP_SD_ReadBlocks_DMA((uint32_t*)buff, (uint32_t)(sector), count);
  21feb8:	693a      	ldr	r2, [r7, #16]
  21feba:	6979      	ldr	r1, [r7, #20]
  21febc:	69b8      	ldr	r0, [r7, #24]
  21febe:	f7ff fe73 	bl	21fba8 <BSP_SD_ReadBlocks_DMA>
  21fec2:	4603      	mov	r3, r0
  21fec4:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37

    if (ret == MSD_OK) {
  21fec8:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  21fecc:	2b00      	cmp	r3, #0
  21fece:	f040 80a2 	bne.w	220016 <SD_read+0x192>
#if (osCMSIS < 0x20000U)
    /* wait for a message from the queue or a timeout */
    event = osMessageGet(SDQueueID, SD_TIMEOUT);
  21fed2:	4b54      	ldr	r3, [pc, #336]	; (220024 <SD_read+0x1a0>)
  21fed4:	6819      	ldr	r1, [r3, #0]
  21fed6:	f107 0320 	add.w	r3, r7, #32
  21feda:	f247 5230 	movw	r2, #30000	; 0x7530
  21fede:	4618      	mov	r0, r3
  21fee0:	f003 fdca 	bl	223a78 <osMessageGet>

    if (event.status == osEventMessage)
  21fee4:	6a3b      	ldr	r3, [r7, #32]
  21fee6:	2b10      	cmp	r3, #16
  21fee8:	f040 8095 	bne.w	220016 <SD_read+0x192>
    {
      if (event.value.v == READ_CPLT_MSG)
  21feec:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  21feee:	2b01      	cmp	r3, #1
  21fef0:	f040 8091 	bne.w	220016 <SD_read+0x192>
      {
        timer = osKernelSysTick();
  21fef4:	f003 fc30 	bl	223758 <osKernelSysTick>
  21fef8:	6338      	str	r0, [r7, #48]	; 0x30
        /* block until SDIO IP is ready or a timeout occur */
        while(osKernelSysTick() - timer <SD_TIMEOUT)
  21fefa:	e016      	b.n	21ff2a <SD_read+0xa6>
            timer = osKernelGetTickCount();
            /* block until SDIO IP is ready or a timeout occur */
            while(osKernelGetTickCount() - timer <SD_TIMEOUT)
#endif
            {
              if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
  21fefc:	f7ff fe88 	bl	21fc10 <BSP_SD_GetCardState>
  21ff00:	4603      	mov	r3, r0
  21ff02:	2b00      	cmp	r3, #0
  21ff04:	d111      	bne.n	21ff2a <SD_read+0xa6>
              {
                res = RES_OK;
  21ff06:	2300      	movs	r3, #0
  21ff08:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
#if (ENABLE_SD_DMA_CACHE_MAINTENANCE == 1)
                /*
                the SCB_InvalidateDCache_by_Addr() requires a 32-Byte aligned address,
                adjust the address and the D-Cache size to invalidate accordingly.
                */
                alignedAddr = (uint32_t)buff & ~0x1F;
  21ff0c:	69bb      	ldr	r3, [r7, #24]
  21ff0e:	f023 031f 	bic.w	r3, r3, #31
  21ff12:	62fb      	str	r3, [r7, #44]	; 0x2c
                SCB_InvalidateDCache_by_Addr((uint32_t*)alignedAddr, count*BLOCKSIZE + ((uint32_t)buff - alignedAddr));
  21ff14:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  21ff16:	693b      	ldr	r3, [r7, #16]
  21ff18:	025a      	lsls	r2, r3, #9
  21ff1a:	69b9      	ldr	r1, [r7, #24]
  21ff1c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  21ff1e:	1acb      	subs	r3, r1, r3
  21ff20:	4413      	add	r3, r2
  21ff22:	4619      	mov	r1, r3
  21ff24:	f7ff fec4 	bl	21fcb0 <SCB_InvalidateDCache_by_Addr>
#endif
                break;
  21ff28:	e075      	b.n	220016 <SD_read+0x192>
        while(osKernelSysTick() - timer <SD_TIMEOUT)
  21ff2a:	f003 fc15 	bl	223758 <osKernelSysTick>
  21ff2e:	4602      	mov	r2, r0
  21ff30:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  21ff32:	1ad3      	subs	r3, r2, r3
  21ff34:	f247 522f 	movw	r2, #29999	; 0x752f
  21ff38:	4293      	cmp	r3, r2
  21ff3a:	d9df      	bls.n	21fefc <SD_read+0x78>
  21ff3c:	e06b      	b.n	220016 <SD_read+0x192>
    else
    {
      /* Slow path, fetch each sector a part and memcpy to destination buffer */
      int i;

      for (i = 0; i < count; i++)
  21ff3e:	2300      	movs	r3, #0
  21ff40:	63bb      	str	r3, [r7, #56]	; 0x38
  21ff42:	e055      	b.n	21fff0 <SD_read+0x16c>
      {
        ret = BSP_SD_ReadBlocks_DMA((uint32_t*)scratch, (uint32_t)sector++, 1);
  21ff44:	697b      	ldr	r3, [r7, #20]
  21ff46:	1c5a      	adds	r2, r3, #1
  21ff48:	617a      	str	r2, [r7, #20]
  21ff4a:	2201      	movs	r2, #1
  21ff4c:	4619      	mov	r1, r3
  21ff4e:	4836      	ldr	r0, [pc, #216]	; (220028 <SD_read+0x1a4>)
  21ff50:	f7ff fe2a 	bl	21fba8 <BSP_SD_ReadBlocks_DMA>
  21ff54:	4603      	mov	r3, r0
  21ff56:	461a      	mov	r2, r3
  21ff58:	4b34      	ldr	r3, [pc, #208]	; (22002c <SD_read+0x1a8>)
  21ff5a:	601a      	str	r2, [r3, #0]
        if (ret == MSD_OK )
  21ff5c:	4b33      	ldr	r3, [pc, #204]	; (22002c <SD_read+0x1a8>)
  21ff5e:	681b      	ldr	r3, [r3, #0]
  21ff60:	2b00      	cmp	r3, #0
  21ff62:	d14a      	bne.n	21fffa <SD_read+0x176>
        {
          /* wait until the read is successful or a timeout occurs */
#if (osCMSIS < 0x20000U)
          /* wait for a message from the queue or a timeout */
          event = osMessageGet(SDQueueID, SD_TIMEOUT);
  21ff64:	4b2f      	ldr	r3, [pc, #188]	; (220024 <SD_read+0x1a0>)
  21ff66:	6819      	ldr	r1, [r3, #0]
  21ff68:	463b      	mov	r3, r7
  21ff6a:	f247 5230 	movw	r2, #30000	; 0x7530
  21ff6e:	4618      	mov	r0, r3
  21ff70:	f003 fd82 	bl	223a78 <osMessageGet>
  21ff74:	f107 0320 	add.w	r3, r7, #32
  21ff78:	463a      	mov	r2, r7
  21ff7a:	ca07      	ldmia	r2, {r0, r1, r2}
  21ff7c:	e883 0007 	stmia.w	r3, {r0, r1, r2}

          if (event.status == osEventMessage)
  21ff80:	6a3b      	ldr	r3, [r7, #32]
  21ff82:	2b10      	cmp	r3, #16
  21ff84:	d11f      	bne.n	21ffc6 <SD_read+0x142>
          {
            if (event.value.v == READ_CPLT_MSG)
  21ff86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  21ff88:	2b01      	cmp	r3, #1
  21ff8a:	d11c      	bne.n	21ffc6 <SD_read+0x142>
            {
              timer = osKernelSysTick();
  21ff8c:	f003 fbe4 	bl	223758 <osKernelSysTick>
  21ff90:	6338      	str	r0, [r7, #48]	; 0x30
              /* block until SDIO IP is ready or a timeout occur */
              while(osKernelSysTick() - timer <SD_TIMEOUT)
  21ff92:	e009      	b.n	21ffa8 <SD_read+0x124>
                /* block until SDIO IP is ready or a timeout occur */
                ret = MSD_ERROR;
                while(osKernelGetTickCount() - timer < SD_TIMEOUT)
#endif
                {
                  ret = BSP_SD_GetCardState();
  21ff94:	f7ff fe3c 	bl	21fc10 <BSP_SD_GetCardState>
  21ff98:	4603      	mov	r3, r0
  21ff9a:	461a      	mov	r2, r3
  21ff9c:	4b23      	ldr	r3, [pc, #140]	; (22002c <SD_read+0x1a8>)
  21ff9e:	601a      	str	r2, [r3, #0]

                  if (ret == MSD_OK)
  21ffa0:	4b22      	ldr	r3, [pc, #136]	; (22002c <SD_read+0x1a8>)
  21ffa2:	681b      	ldr	r3, [r3, #0]
  21ffa4:	2b00      	cmp	r3, #0
  21ffa6:	d009      	beq.n	21ffbc <SD_read+0x138>
              while(osKernelSysTick() - timer <SD_TIMEOUT)
  21ffa8:	f003 fbd6 	bl	223758 <osKernelSysTick>
  21ffac:	4602      	mov	r2, r0
  21ffae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  21ffb0:	1ad3      	subs	r3, r2, r3
  21ffb2:	f247 522f 	movw	r2, #29999	; 0x752f
  21ffb6:	4293      	cmp	r3, r2
  21ffb8:	d9ec      	bls.n	21ff94 <SD_read+0x110>
  21ffba:	e000      	b.n	21ffbe <SD_read+0x13a>
                  {
                    break;
  21ffbc:	bf00      	nop
                  }
                }

                if (ret != MSD_OK)
  21ffbe:	4b1b      	ldr	r3, [pc, #108]	; (22002c <SD_read+0x1a8>)
  21ffc0:	681b      	ldr	r3, [r3, #0]
  21ffc2:	2b00      	cmp	r3, #0
  21ffc4:	d11b      	bne.n	21fffe <SD_read+0x17a>
#if (ENABLE_SD_DMA_CACHE_MAINTENANCE == 1)
          /*
          *
          * invalidate the scratch buffer before the next read to get the actual data instead of the cached one
          */
          SCB_InvalidateDCache_by_Addr((uint32_t*)scratch, BLOCKSIZE);
  21ffc6:	f44f 7100 	mov.w	r1, #512	; 0x200
  21ffca:	4817      	ldr	r0, [pc, #92]	; (220028 <SD_read+0x1a4>)
  21ffcc:	f7ff fe70 	bl	21fcb0 <SCB_InvalidateDCache_by_Addr>
#endif
          memcpy(buff, scratch, BLOCKSIZE);
  21ffd0:	69bb      	ldr	r3, [r7, #24]
  21ffd2:	4a15      	ldr	r2, [pc, #84]	; (220028 <SD_read+0x1a4>)
  21ffd4:	4618      	mov	r0, r3
  21ffd6:	4611      	mov	r1, r2
  21ffd8:	f44f 7300 	mov.w	r3, #512	; 0x200
  21ffdc:	461a      	mov	r2, r3
  21ffde:	f006 fa9d 	bl	22651c <memcpy>
          buff += BLOCKSIZE;
  21ffe2:	69bb      	ldr	r3, [r7, #24]
  21ffe4:	f503 7300 	add.w	r3, r3, #512	; 0x200
  21ffe8:	61bb      	str	r3, [r7, #24]
      for (i = 0; i < count; i++)
  21ffea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  21ffec:	3301      	adds	r3, #1
  21ffee:	63bb      	str	r3, [r7, #56]	; 0x38
  21fff0:	6bba      	ldr	r2, [r7, #56]	; 0x38
  21fff2:	693b      	ldr	r3, [r7, #16]
  21fff4:	429a      	cmp	r2, r3
  21fff6:	d3a5      	bcc.n	21ff44 <SD_read+0xc0>
  21fff8:	e002      	b.n	220000 <SD_read+0x17c>
        }
        else
        {
          break;
  21fffa:	bf00      	nop
  21fffc:	e000      	b.n	220000 <SD_read+0x17c>
                  break;
  21fffe:	bf00      	nop
        }
      }

      if ((i == count) && (ret == MSD_OK ))
  220000:	6bba      	ldr	r2, [r7, #56]	; 0x38
  220002:	693b      	ldr	r3, [r7, #16]
  220004:	429a      	cmp	r2, r3
  220006:	d106      	bne.n	220016 <SD_read+0x192>
  220008:	4b08      	ldr	r3, [pc, #32]	; (22002c <SD_read+0x1a8>)
  22000a:	681b      	ldr	r3, [r3, #0]
  22000c:	2b00      	cmp	r3, #0
  22000e:	d102      	bne.n	220016 <SD_read+0x192>
        res = RES_OK;
  220010:	2300      	movs	r3, #0
  220012:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    }
#endif
  return res;
  220016:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
}
  22001a:	4618      	mov	r0, r3
  22001c:	3740      	adds	r7, #64	; 0x40
  22001e:	46bd      	mov	sp, r7
  220020:	bd80      	pop	{r7, pc}
  220022:	bf00      	nop
  220024:	20010ba0 	.word	0x20010ba0
  220028:	200109a0 	.word	0x200109a0
  22002c:	200152d0 	.word	0x200152d0

00220030 <SD_write>:
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1

DRESULT SD_write(BYTE lun, const BYTE *buff, DWORD sector, UINT count)
{
  220030:	b580      	push	{r7, lr}
  220032:	b090      	sub	sp, #64	; 0x40
  220034:	af00      	add	r7, sp, #0
  220036:	61b9      	str	r1, [r7, #24]
  220038:	617a      	str	r2, [r7, #20]
  22003a:	613b      	str	r3, [r7, #16]
  22003c:	4603      	mov	r3, r0
  22003e:	77fb      	strb	r3, [r7, #31]
  DRESULT res = RES_ERROR;
  220040:	2301      	movs	r3, #1
  220042:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f

  /*
  * ensure the SDCard is ready for a new operation
  */

  if (SD_CheckStatusWithTimeout(SD_TIMEOUT) < 0)
  220046:	f247 5030 	movw	r0, #30000	; 0x7530
  22004a:	f7ff fe85 	bl	21fd58 <SD_CheckStatusWithTimeout>
  22004e:	4603      	mov	r3, r0
  220050:	2b00      	cmp	r3, #0
  220052:	da02      	bge.n	22005a <SD_write+0x2a>
  {
    return res;
  220054:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
  220058:	e0a7      	b.n	2201aa <SD_write+0x17a>
  }

#if defined(ENABLE_SCRATCH_BUFFER)
  if (!((uint32_t)buff & 0x3))
  22005a:	69bb      	ldr	r3, [r7, #24]
  22005c:	f003 0303 	and.w	r3, r3, #3
  220060:	2b00      	cmp	r3, #0
  220062:	f040 80a0 	bne.w	2201a6 <SD_write+0x176>
  uint32_t alignedAddr;
  /*
    the SCB_CleanDCache_by_Addr() requires a 32-Byte aligned address
    adjust the address and the D-Cache size to clean accordingly.
  */
  alignedAddr = (uint32_t)buff & ~0x1F;
  220066:	69bb      	ldr	r3, [r7, #24]
  220068:	f023 031f 	bic.w	r3, r3, #31
  22006c:	633b      	str	r3, [r7, #48]	; 0x30
  SCB_CleanDCache_by_Addr((uint32_t*)alignedAddr, count*BLOCKSIZE + ((uint32_t)buff - alignedAddr));
  22006e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  220070:	693b      	ldr	r3, [r7, #16]
  220072:	025a      	lsls	r2, r3, #9
  220074:	69b9      	ldr	r1, [r7, #24]
  220076:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  220078:	1acb      	subs	r3, r1, r3
  22007a:	4413      	add	r3, r2
  22007c:	4619      	mov	r1, r3
  22007e:	f7ff fe41 	bl	21fd04 <SCB_CleanDCache_by_Addr>
#endif

  if(BSP_SD_WriteBlocks_DMA((uint32_t*)buff,
  220082:	693a      	ldr	r2, [r7, #16]
  220084:	6979      	ldr	r1, [r7, #20]
  220086:	69b8      	ldr	r0, [r7, #24]
  220088:	f7ff fda8 	bl	21fbdc <BSP_SD_WriteBlocks_DMA>
  22008c:	4603      	mov	r3, r0
  22008e:	2b00      	cmp	r3, #0
  220090:	d125      	bne.n	2200de <SD_write+0xae>
                           (uint32_t) (sector),
                           count) == MSD_OK)
  {
#if (osCMSIS < 0x20000U)
    /* Get the message from the queue */
    event = osMessageGet(SDQueueID, SD_TIMEOUT);
  220092:	4b48      	ldr	r3, [pc, #288]	; (2201b4 <SD_write+0x184>)
  220094:	6819      	ldr	r1, [r3, #0]
  220096:	f107 0320 	add.w	r3, r7, #32
  22009a:	f247 5230 	movw	r2, #30000	; 0x7530
  22009e:	4618      	mov	r0, r3
  2200a0:	f003 fcea 	bl	223a78 <osMessageGet>

    if (event.status == osEventMessage)
  2200a4:	6a3b      	ldr	r3, [r7, #32]
  2200a6:	2b10      	cmp	r3, #16
  2200a8:	d17d      	bne.n	2201a6 <SD_write+0x176>
    {
      if (event.value.v == WRITE_CPLT_MSG)
  2200aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2200ac:	2b02      	cmp	r3, #2
  2200ae:	d17a      	bne.n	2201a6 <SD_write+0x176>
    status = osMessageQueueGet(SDQueueID, (void *)&event, NULL, SD_TIMEOUT);
    if ((status == osOK) && (event == WRITE_CPLT_MSG))
    {
#endif
 #if (osCMSIS < 0x20000U)
        timer = osKernelSysTick();
  2200b0:	f003 fb52 	bl	223758 <osKernelSysTick>
  2200b4:	62f8      	str	r0, [r7, #44]	; 0x2c
        /* block until SDIO IP is ready or a timeout occur */
        while(osKernelSysTick() - timer  < SD_TIMEOUT)
  2200b6:	e008      	b.n	2200ca <SD_write+0x9a>
        timer = osKernelGetTickCount();
        /* block until SDIO IP is ready or a timeout occur */
        while(osKernelGetTickCount() - timer  < SD_TIMEOUT)
#endif
        {
          if (BSP_SD_GetCardState() == SD_TRANSFER_OK)
  2200b8:	f7ff fdaa 	bl	21fc10 <BSP_SD_GetCardState>
  2200bc:	4603      	mov	r3, r0
  2200be:	2b00      	cmp	r3, #0
  2200c0:	d103      	bne.n	2200ca <SD_write+0x9a>
          {
            res = RES_OK;
  2200c2:	2300      	movs	r3, #0
  2200c4:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
            break;
  2200c8:	e06d      	b.n	2201a6 <SD_write+0x176>
        while(osKernelSysTick() - timer  < SD_TIMEOUT)
  2200ca:	f003 fb45 	bl	223758 <osKernelSysTick>
  2200ce:	4602      	mov	r2, r0
  2200d0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2200d2:	1ad3      	subs	r3, r2, r3
  2200d4:	f247 522f 	movw	r2, #29999	; 0x752f
  2200d8:	4293      	cmp	r3, r2
  2200da:	d9ed      	bls.n	2200b8 <SD_write+0x88>
  2200dc:	e063      	b.n	2201a6 <SD_write+0x176>

#if (ENABLE_SD_DMA_CACHE_MAINTENANCE == 1)
    /*
     * invalidate the scratch buffer before the next write to get the actual data instead of the cached one
     */
     SCB_InvalidateDCache_by_Addr((uint32_t*)scratch, BLOCKSIZE);
  2200de:	f44f 7100 	mov.w	r1, #512	; 0x200
  2200e2:	4835      	ldr	r0, [pc, #212]	; (2201b8 <SD_write+0x188>)
  2200e4:	f7ff fde4 	bl	21fcb0 <SCB_InvalidateDCache_by_Addr>
#endif
      for (i = 0; i < count; i++)
  2200e8:	2300      	movs	r3, #0
  2200ea:	637b      	str	r3, [r7, #52]	; 0x34
  2200ec:	e049      	b.n	220182 <SD_write+0x152>
      {
        memcpy((void *)scratch, buff, BLOCKSIZE);
  2200ee:	4a32      	ldr	r2, [pc, #200]	; (2201b8 <SD_write+0x188>)
  2200f0:	69bb      	ldr	r3, [r7, #24]
  2200f2:	4610      	mov	r0, r2
  2200f4:	4619      	mov	r1, r3
  2200f6:	f44f 7300 	mov.w	r3, #512	; 0x200
  2200fa:	461a      	mov	r2, r3
  2200fc:	f006 fa0e 	bl	22651c <memcpy>
        buff += BLOCKSIZE;
  220100:	69bb      	ldr	r3, [r7, #24]
  220102:	f503 7300 	add.w	r3, r3, #512	; 0x200
  220106:	61bb      	str	r3, [r7, #24]

        ret = BSP_SD_WriteBlocks_DMA((uint32_t*)scratch, (uint32_t)sector++, 1);
  220108:	697b      	ldr	r3, [r7, #20]
  22010a:	1c5a      	adds	r2, r3, #1
  22010c:	617a      	str	r2, [r7, #20]
  22010e:	2201      	movs	r2, #1
  220110:	4619      	mov	r1, r3
  220112:	4829      	ldr	r0, [pc, #164]	; (2201b8 <SD_write+0x188>)
  220114:	f7ff fd62 	bl	21fbdc <BSP_SD_WriteBlocks_DMA>
  220118:	4603      	mov	r3, r0
  22011a:	63bb      	str	r3, [r7, #56]	; 0x38
        if (ret == MSD_OK )
  22011c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22011e:	2b00      	cmp	r3, #0
  220120:	d134      	bne.n	22018c <SD_write+0x15c>
        {
          /* wait until the read is successful or a timeout occurs */
#if (osCMSIS < 0x20000U)
          /* wait for a message from the queue or a timeout */
          event = osMessageGet(SDQueueID, SD_TIMEOUT);
  220122:	4b24      	ldr	r3, [pc, #144]	; (2201b4 <SD_write+0x184>)
  220124:	6819      	ldr	r1, [r3, #0]
  220126:	463b      	mov	r3, r7
  220128:	f247 5230 	movw	r2, #30000	; 0x7530
  22012c:	4618      	mov	r0, r3
  22012e:	f003 fca3 	bl	223a78 <osMessageGet>
  220132:	f107 0320 	add.w	r3, r7, #32
  220136:	463a      	mov	r2, r7
  220138:	ca07      	ldmia	r2, {r0, r1, r2}
  22013a:	e883 0007 	stmia.w	r3, {r0, r1, r2}

          if (event.status == osEventMessage)
  22013e:	6a3b      	ldr	r3, [r7, #32]
  220140:	2b10      	cmp	r3, #16
  220142:	d11b      	bne.n	22017c <SD_write+0x14c>
          {
            if (event.value.v == READ_CPLT_MSG)
  220144:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  220146:	2b01      	cmp	r3, #1
  220148:	d118      	bne.n	22017c <SD_write+0x14c>
            {
              timer = osKernelSysTick();
  22014a:	f003 fb05 	bl	223758 <osKernelSysTick>
  22014e:	62f8      	str	r0, [r7, #44]	; 0x2c
              /* block until SDIO IP is ready or a timeout occur */
              while(osKernelSysTick() - timer <SD_TIMEOUT)
  220150:	e006      	b.n	220160 <SD_write+0x130>
                /* block until SDIO IP is ready or a timeout occur */
                ret = MSD_ERROR;
                while(osKernelGetTickCount() - timer < SD_TIMEOUT)
#endif
                {
                  ret = BSP_SD_GetCardState();
  220152:	f7ff fd5d 	bl	21fc10 <BSP_SD_GetCardState>
  220156:	4603      	mov	r3, r0
  220158:	63bb      	str	r3, [r7, #56]	; 0x38

                  if (ret == MSD_OK)
  22015a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22015c:	2b00      	cmp	r3, #0
  22015e:	d009      	beq.n	220174 <SD_write+0x144>
              while(osKernelSysTick() - timer <SD_TIMEOUT)
  220160:	f003 fafa 	bl	223758 <osKernelSysTick>
  220164:	4602      	mov	r2, r0
  220166:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  220168:	1ad3      	subs	r3, r2, r3
  22016a:	f247 522f 	movw	r2, #29999	; 0x752f
  22016e:	4293      	cmp	r3, r2
  220170:	d9ef      	bls.n	220152 <SD_write+0x122>
  220172:	e000      	b.n	220176 <SD_write+0x146>
                  {
                    break;
  220174:	bf00      	nop
                  }
                }

                if (ret != MSD_OK)
  220176:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  220178:	2b00      	cmp	r3, #0
  22017a:	d109      	bne.n	220190 <SD_write+0x160>
      for (i = 0; i < count; i++)
  22017c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  22017e:	3301      	adds	r3, #1
  220180:	637b      	str	r3, [r7, #52]	; 0x34
  220182:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  220184:	693b      	ldr	r3, [r7, #16]
  220186:	429a      	cmp	r2, r3
  220188:	d3b1      	bcc.n	2200ee <SD_write+0xbe>
  22018a:	e002      	b.n	220192 <SD_write+0x162>
          }
#endif
        }
        else
        {
          break;
  22018c:	bf00      	nop
  22018e:	e000      	b.n	220192 <SD_write+0x162>
                  break;
  220190:	bf00      	nop
        }
      }

      if ((i == count) && (ret == MSD_OK ))
  220192:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  220194:	693b      	ldr	r3, [r7, #16]
  220196:	429a      	cmp	r2, r3
  220198:	d105      	bne.n	2201a6 <SD_write+0x176>
  22019a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22019c:	2b00      	cmp	r3, #0
  22019e:	d102      	bne.n	2201a6 <SD_write+0x176>
        res = RES_OK;
  2201a0:	2300      	movs	r3, #0
  2201a2:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    }

  }
#endif

  return res;
  2201a6:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
}
  2201aa:	4618      	mov	r0, r3
  2201ac:	3740      	adds	r7, #64	; 0x40
  2201ae:	46bd      	mov	sp, r7
  2201b0:	bd80      	pop	{r7, pc}
  2201b2:	bf00      	nop
  2201b4:	20010ba0 	.word	0x20010ba0
  2201b8:	200109a0 	.word	0x200109a0

002201bc <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  2201bc:	b580      	push	{r7, lr}
  2201be:	b08c      	sub	sp, #48	; 0x30
  2201c0:	af00      	add	r7, sp, #0
  2201c2:	4603      	mov	r3, r0
  2201c4:	603a      	str	r2, [r7, #0]
  2201c6:	71fb      	strb	r3, [r7, #7]
  2201c8:	460b      	mov	r3, r1
  2201ca:	71bb      	strb	r3, [r7, #6]
  DRESULT res = RES_ERROR;
  2201cc:	2301      	movs	r3, #1
  2201ce:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
  2201d2:	4b25      	ldr	r3, [pc, #148]	; (220268 <SD_ioctl+0xac>)
  2201d4:	781b      	ldrb	r3, [r3, #0]
  2201d6:	b2db      	uxtb	r3, r3
  2201d8:	f003 0301 	and.w	r3, r3, #1
  2201dc:	2b00      	cmp	r3, #0
  2201de:	d001      	beq.n	2201e4 <SD_ioctl+0x28>
  2201e0:	2303      	movs	r3, #3
  2201e2:	e03c      	b.n	22025e <SD_ioctl+0xa2>

  switch (cmd)
  2201e4:	79bb      	ldrb	r3, [r7, #6]
  2201e6:	2b03      	cmp	r3, #3
  2201e8:	d834      	bhi.n	220254 <SD_ioctl+0x98>
  2201ea:	a201      	add	r2, pc, #4	; (adr r2, 2201f0 <SD_ioctl+0x34>)
  2201ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  2201f0:	00220201 	.word	0x00220201
  2201f4:	00220209 	.word	0x00220209
  2201f8:	00220221 	.word	0x00220221
  2201fc:	0022023b 	.word	0x0022023b
  {
  /* Make sure that no pending write process */
  case CTRL_SYNC :
    res = RES_OK;
  220200:	2300      	movs	r3, #0
  220202:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    break;
  220206:	e028      	b.n	22025a <SD_ioctl+0x9e>

  /* Get number of sectors on the disk (DWORD) */
  case GET_SECTOR_COUNT :
    BSP_SD_GetCardInfo(&CardInfo);
  220208:	f107 030c 	add.w	r3, r7, #12
  22020c:	4618      	mov	r0, r3
  22020e:	f7ff fd0f 	bl	21fc30 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
  220212:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  220214:	683b      	ldr	r3, [r7, #0]
  220216:	601a      	str	r2, [r3, #0]
    res = RES_OK;
  220218:	2300      	movs	r3, #0
  22021a:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    break;
  22021e:	e01c      	b.n	22025a <SD_ioctl+0x9e>

  /* Get R/W sector size (WORD) */
  case GET_SECTOR_SIZE :
    BSP_SD_GetCardInfo(&CardInfo);
  220220:	f107 030c 	add.w	r3, r7, #12
  220224:	4618      	mov	r0, r3
  220226:	f7ff fd03 	bl	21fc30 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
  22022a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  22022c:	b29a      	uxth	r2, r3
  22022e:	683b      	ldr	r3, [r7, #0]
  220230:	801a      	strh	r2, [r3, #0]
    res = RES_OK;
  220232:	2300      	movs	r3, #0
  220234:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    break;
  220238:	e00f      	b.n	22025a <SD_ioctl+0x9e>

  /* Get erase block size in unit of sector (DWORD) */
  case GET_BLOCK_SIZE :
    BSP_SD_GetCardInfo(&CardInfo);
  22023a:	f107 030c 	add.w	r3, r7, #12
  22023e:	4618      	mov	r0, r3
  220240:	f7ff fcf6 	bl	21fc30 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
  220244:	6abb      	ldr	r3, [r7, #40]	; 0x28
  220246:	0a5a      	lsrs	r2, r3, #9
  220248:	683b      	ldr	r3, [r7, #0]
  22024a:	601a      	str	r2, [r3, #0]
    res = RES_OK;
  22024c:	2300      	movs	r3, #0
  22024e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
    break;
  220252:	e002      	b.n	22025a <SD_ioctl+0x9e>

  default:
    res = RES_PARERR;
  220254:	2304      	movs	r3, #4
  220256:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  }

  return res;
  22025a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
  22025e:	4618      	mov	r0, r3
  220260:	3730      	adds	r7, #48	; 0x30
  220262:	46bd      	mov	sp, r7
  220264:	bd80      	pop	{r7, pc}
  220266:	bf00      	nop
  220268:	2000000d 	.word	0x2000000d

0022026c <BSP_SD_WriteCpltCallback>:
  * @brief Tx Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
void BSP_SD_WriteCpltCallback(void)
{
  22026c:	b580      	push	{r7, lr}
  22026e:	af00      	add	r7, sp, #0
  /*
   * No need to add an "osKernelRunning()" check here, as the SD_initialize()
   * is always called before any SD_Read()/SD_Write() call
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, WRITE_CPLT_MSG, 0);
  220270:	4b04      	ldr	r3, [pc, #16]	; (220284 <BSP_SD_WriteCpltCallback+0x18>)
  220272:	681b      	ldr	r3, [r3, #0]
  220274:	2200      	movs	r2, #0
  220276:	2102      	movs	r1, #2
  220278:	4618      	mov	r0, r3
  22027a:	f003 fbbd 	bl	2239f8 <osMessagePut>
#else
   const uint16_t msg = WRITE_CPLT_MSG;
   osMessageQueuePut(SDQueueID, (const void *)&msg, NULL, 0);
#endif
}
  22027e:	bf00      	nop
  220280:	bd80      	pop	{r7, pc}
  220282:	bf00      	nop
  220284:	20010ba0 	.word	0x20010ba0

00220288 <BSP_SD_ReadCpltCallback>:
  * @brief Rx Transfer completed callbacks
  * @param hsd: SD handle
  * @retval None
  */
void BSP_SD_ReadCpltCallback(void)
{
  220288:	b580      	push	{r7, lr}
  22028a:	af00      	add	r7, sp, #0
  /*
   * No need to add an "osKernelRunning()" check here, as the SD_initialize()
   * is always called before any SD_Read()/SD_Write() call
   */
#if (osCMSIS < 0x20000U)
   osMessagePut(SDQueueID, READ_CPLT_MSG, 0);
  22028c:	4b04      	ldr	r3, [pc, #16]	; (2202a0 <BSP_SD_ReadCpltCallback+0x18>)
  22028e:	681b      	ldr	r3, [r3, #0]
  220290:	2200      	movs	r2, #0
  220292:	2101      	movs	r1, #1
  220294:	4618      	mov	r0, r3
  220296:	f003 fbaf 	bl	2239f8 <osMessagePut>
#else
   const uint16_t msg = READ_CPLT_MSG;
   osMessageQueuePut(SDQueueID, (const void *)&msg, NULL, 0);
#endif
}
  22029a:	bf00      	nop
  22029c:	bd80      	pop	{r7, pc}
  22029e:	bf00      	nop
  2202a0:	20010ba0 	.word	0x20010ba0

002202a4 <disk_status>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_status (
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  2202a4:	b580      	push	{r7, lr}
  2202a6:	b084      	sub	sp, #16
  2202a8:	af00      	add	r7, sp, #0
  2202aa:	4603      	mov	r3, r0
  2202ac:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
  2202ae:	79fb      	ldrb	r3, [r7, #7]
  2202b0:	4a08      	ldr	r2, [pc, #32]	; (2202d4 <disk_status+0x30>)
  2202b2:	009b      	lsls	r3, r3, #2
  2202b4:	4413      	add	r3, r2
  2202b6:	685b      	ldr	r3, [r3, #4]
  2202b8:	685b      	ldr	r3, [r3, #4]
  2202ba:	79fa      	ldrb	r2, [r7, #7]
  2202bc:	4905      	ldr	r1, [pc, #20]	; (2202d4 <disk_status+0x30>)
  2202be:	440a      	add	r2, r1
  2202c0:	7a12      	ldrb	r2, [r2, #8]
  2202c2:	4610      	mov	r0, r2
  2202c4:	4798      	blx	r3
  2202c6:	4603      	mov	r3, r0
  2202c8:	73fb      	strb	r3, [r7, #15]
  return stat;
  2202ca:	7bfb      	ldrb	r3, [r7, #15]
}
  2202cc:	4618      	mov	r0, r3
  2202ce:	3710      	adds	r7, #16
  2202d0:	46bd      	mov	sp, r7
  2202d2:	bd80      	pop	{r7, pc}
  2202d4:	20010c4c 	.word	0x20010c4c

002202d8 <disk_initialize>:
  * @retval DSTATUS: Operation status
  */
DSTATUS disk_initialize (
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  2202d8:	b580      	push	{r7, lr}
  2202da:	b084      	sub	sp, #16
  2202dc:	af00      	add	r7, sp, #0
  2202de:	4603      	mov	r3, r0
  2202e0:	71fb      	strb	r3, [r7, #7]
  DSTATUS stat = RES_OK;
  2202e2:	2300      	movs	r3, #0
  2202e4:	73fb      	strb	r3, [r7, #15]

  if(disk.is_initialized[pdrv] == 0)
  2202e6:	79fb      	ldrb	r3, [r7, #7]
  2202e8:	4a0d      	ldr	r2, [pc, #52]	; (220320 <disk_initialize+0x48>)
  2202ea:	5cd3      	ldrb	r3, [r2, r3]
  2202ec:	2b00      	cmp	r3, #0
  2202ee:	d111      	bne.n	220314 <disk_initialize+0x3c>
  {
    disk.is_initialized[pdrv] = 1;
  2202f0:	79fb      	ldrb	r3, [r7, #7]
  2202f2:	4a0b      	ldr	r2, [pc, #44]	; (220320 <disk_initialize+0x48>)
  2202f4:	2101      	movs	r1, #1
  2202f6:	54d1      	strb	r1, [r2, r3]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
  2202f8:	79fb      	ldrb	r3, [r7, #7]
  2202fa:	4a09      	ldr	r2, [pc, #36]	; (220320 <disk_initialize+0x48>)
  2202fc:	009b      	lsls	r3, r3, #2
  2202fe:	4413      	add	r3, r2
  220300:	685b      	ldr	r3, [r3, #4]
  220302:	681b      	ldr	r3, [r3, #0]
  220304:	79fa      	ldrb	r2, [r7, #7]
  220306:	4906      	ldr	r1, [pc, #24]	; (220320 <disk_initialize+0x48>)
  220308:	440a      	add	r2, r1
  22030a:	7a12      	ldrb	r2, [r2, #8]
  22030c:	4610      	mov	r0, r2
  22030e:	4798      	blx	r3
  220310:	4603      	mov	r3, r0
  220312:	73fb      	strb	r3, [r7, #15]
  }
  return stat;
  220314:	7bfb      	ldrb	r3, [r7, #15]
}
  220316:	4618      	mov	r0, r3
  220318:	3710      	adds	r7, #16
  22031a:	46bd      	mov	sp, r7
  22031c:	bd80      	pop	{r7, pc}
  22031e:	bf00      	nop
  220320:	20010c4c 	.word	0x20010c4c

00220324 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
  220324:	b590      	push	{r4, r7, lr}
  220326:	b087      	sub	sp, #28
  220328:	af00      	add	r7, sp, #0
  22032a:	60b9      	str	r1, [r7, #8]
  22032c:	607a      	str	r2, [r7, #4]
  22032e:	603b      	str	r3, [r7, #0]
  220330:	4603      	mov	r3, r0
  220332:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
  220334:	7bfb      	ldrb	r3, [r7, #15]
  220336:	4a0a      	ldr	r2, [pc, #40]	; (220360 <disk_read+0x3c>)
  220338:	009b      	lsls	r3, r3, #2
  22033a:	4413      	add	r3, r2
  22033c:	685b      	ldr	r3, [r3, #4]
  22033e:	689c      	ldr	r4, [r3, #8]
  220340:	7bfb      	ldrb	r3, [r7, #15]
  220342:	4a07      	ldr	r2, [pc, #28]	; (220360 <disk_read+0x3c>)
  220344:	4413      	add	r3, r2
  220346:	7a18      	ldrb	r0, [r3, #8]
  220348:	683b      	ldr	r3, [r7, #0]
  22034a:	687a      	ldr	r2, [r7, #4]
  22034c:	68b9      	ldr	r1, [r7, #8]
  22034e:	47a0      	blx	r4
  220350:	4603      	mov	r3, r0
  220352:	75fb      	strb	r3, [r7, #23]
  return res;
  220354:	7dfb      	ldrb	r3, [r7, #23]
}
  220356:	4618      	mov	r0, r3
  220358:	371c      	adds	r7, #28
  22035a:	46bd      	mov	sp, r7
  22035c:	bd90      	pop	{r4, r7, pc}
  22035e:	bf00      	nop
  220360:	20010c4c 	.word	0x20010c4c

00220364 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
  220364:	b590      	push	{r4, r7, lr}
  220366:	b087      	sub	sp, #28
  220368:	af00      	add	r7, sp, #0
  22036a:	60b9      	str	r1, [r7, #8]
  22036c:	607a      	str	r2, [r7, #4]
  22036e:	603b      	str	r3, [r7, #0]
  220370:	4603      	mov	r3, r0
  220372:	73fb      	strb	r3, [r7, #15]
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
  220374:	7bfb      	ldrb	r3, [r7, #15]
  220376:	4a0a      	ldr	r2, [pc, #40]	; (2203a0 <disk_write+0x3c>)
  220378:	009b      	lsls	r3, r3, #2
  22037a:	4413      	add	r3, r2
  22037c:	685b      	ldr	r3, [r3, #4]
  22037e:	68dc      	ldr	r4, [r3, #12]
  220380:	7bfb      	ldrb	r3, [r7, #15]
  220382:	4a07      	ldr	r2, [pc, #28]	; (2203a0 <disk_write+0x3c>)
  220384:	4413      	add	r3, r2
  220386:	7a18      	ldrb	r0, [r3, #8]
  220388:	683b      	ldr	r3, [r7, #0]
  22038a:	687a      	ldr	r2, [r7, #4]
  22038c:	68b9      	ldr	r1, [r7, #8]
  22038e:	47a0      	blx	r4
  220390:	4603      	mov	r3, r0
  220392:	75fb      	strb	r3, [r7, #23]
  return res;
  220394:	7dfb      	ldrb	r3, [r7, #23]
}
  220396:	4618      	mov	r0, r3
  220398:	371c      	adds	r7, #28
  22039a:	46bd      	mov	sp, r7
  22039c:	bd90      	pop	{r4, r7, pc}
  22039e:	bf00      	nop
  2203a0:	20010c4c 	.word	0x20010c4c

002203a4 <disk_ioctl>:
DRESULT disk_ioctl (
	BYTE pdrv,		/* Physical drive nmuber (0..) */
	BYTE cmd,		/* Control code */
	void *buff		/* Buffer to send/receive control data */
)
{
  2203a4:	b580      	push	{r7, lr}
  2203a6:	b084      	sub	sp, #16
  2203a8:	af00      	add	r7, sp, #0
  2203aa:	4603      	mov	r3, r0
  2203ac:	603a      	str	r2, [r7, #0]
  2203ae:	71fb      	strb	r3, [r7, #7]
  2203b0:	460b      	mov	r3, r1
  2203b2:	71bb      	strb	r3, [r7, #6]
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
  2203b4:	79fb      	ldrb	r3, [r7, #7]
  2203b6:	4a09      	ldr	r2, [pc, #36]	; (2203dc <disk_ioctl+0x38>)
  2203b8:	009b      	lsls	r3, r3, #2
  2203ba:	4413      	add	r3, r2
  2203bc:	685b      	ldr	r3, [r3, #4]
  2203be:	691b      	ldr	r3, [r3, #16]
  2203c0:	79fa      	ldrb	r2, [r7, #7]
  2203c2:	4906      	ldr	r1, [pc, #24]	; (2203dc <disk_ioctl+0x38>)
  2203c4:	440a      	add	r2, r1
  2203c6:	7a10      	ldrb	r0, [r2, #8]
  2203c8:	79b9      	ldrb	r1, [r7, #6]
  2203ca:	683a      	ldr	r2, [r7, #0]
  2203cc:	4798      	blx	r3
  2203ce:	4603      	mov	r3, r0
  2203d0:	73fb      	strb	r3, [r7, #15]
  return res;
  2203d2:	7bfb      	ldrb	r3, [r7, #15]
}
  2203d4:	4618      	mov	r0, r3
  2203d6:	3710      	adds	r7, #16
  2203d8:	46bd      	mov	sp, r7
  2203da:	bd80      	pop	{r7, pc}
  2203dc:	20010c4c 	.word	0x20010c4c

002203e0 <ld_word>:
/* Load/Store multi-byte word in the FAT structure                       */
/*-----------------------------------------------------------------------*/

static
WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
{
  2203e0:	b480      	push	{r7}
  2203e2:	b085      	sub	sp, #20
  2203e4:	af00      	add	r7, sp, #0
  2203e6:	6078      	str	r0, [r7, #4]
	WORD rv;

	rv = ptr[1];
  2203e8:	687b      	ldr	r3, [r7, #4]
  2203ea:	3301      	adds	r3, #1
  2203ec:	781b      	ldrb	r3, [r3, #0]
  2203ee:	81fb      	strh	r3, [r7, #14]
	rv = rv << 8 | ptr[0];
  2203f0:	89fb      	ldrh	r3, [r7, #14]
  2203f2:	021b      	lsls	r3, r3, #8
  2203f4:	b21a      	sxth	r2, r3
  2203f6:	687b      	ldr	r3, [r7, #4]
  2203f8:	781b      	ldrb	r3, [r3, #0]
  2203fa:	b21b      	sxth	r3, r3
  2203fc:	4313      	orrs	r3, r2
  2203fe:	b21b      	sxth	r3, r3
  220400:	81fb      	strh	r3, [r7, #14]
	return rv;
  220402:	89fb      	ldrh	r3, [r7, #14]
}
  220404:	4618      	mov	r0, r3
  220406:	3714      	adds	r7, #20
  220408:	46bd      	mov	sp, r7
  22040a:	f85d 7b04 	ldr.w	r7, [sp], #4
  22040e:	4770      	bx	lr

00220410 <ld_dword>:

static
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
  220410:	b480      	push	{r7}
  220412:	b085      	sub	sp, #20
  220414:	af00      	add	r7, sp, #0
  220416:	6078      	str	r0, [r7, #4]
	DWORD rv;

	rv = ptr[3];
  220418:	687b      	ldr	r3, [r7, #4]
  22041a:	3303      	adds	r3, #3
  22041c:	781b      	ldrb	r3, [r3, #0]
  22041e:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[2];
  220420:	68fb      	ldr	r3, [r7, #12]
  220422:	021b      	lsls	r3, r3, #8
  220424:	687a      	ldr	r2, [r7, #4]
  220426:	3202      	adds	r2, #2
  220428:	7812      	ldrb	r2, [r2, #0]
  22042a:	4313      	orrs	r3, r2
  22042c:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[1];
  22042e:	68fb      	ldr	r3, [r7, #12]
  220430:	021b      	lsls	r3, r3, #8
  220432:	687a      	ldr	r2, [r7, #4]
  220434:	3201      	adds	r2, #1
  220436:	7812      	ldrb	r2, [r2, #0]
  220438:	4313      	orrs	r3, r2
  22043a:	60fb      	str	r3, [r7, #12]
	rv = rv << 8 | ptr[0];
  22043c:	68fb      	ldr	r3, [r7, #12]
  22043e:	021b      	lsls	r3, r3, #8
  220440:	687a      	ldr	r2, [r7, #4]
  220442:	7812      	ldrb	r2, [r2, #0]
  220444:	4313      	orrs	r3, r2
  220446:	60fb      	str	r3, [r7, #12]
	return rv;
  220448:	68fb      	ldr	r3, [r7, #12]
}
  22044a:	4618      	mov	r0, r3
  22044c:	3714      	adds	r7, #20
  22044e:	46bd      	mov	sp, r7
  220450:	f85d 7b04 	ldr.w	r7, [sp], #4
  220454:	4770      	bx	lr

00220456 <st_word>:
#endif

#if !_FS_READONLY
static
void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
{
  220456:	b480      	push	{r7}
  220458:	b083      	sub	sp, #12
  22045a:	af00      	add	r7, sp, #0
  22045c:	6078      	str	r0, [r7, #4]
  22045e:	460b      	mov	r3, r1
  220460:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val; val >>= 8;
  220462:	687b      	ldr	r3, [r7, #4]
  220464:	1c5a      	adds	r2, r3, #1
  220466:	607a      	str	r2, [r7, #4]
  220468:	887a      	ldrh	r2, [r7, #2]
  22046a:	b2d2      	uxtb	r2, r2
  22046c:	701a      	strb	r2, [r3, #0]
  22046e:	887b      	ldrh	r3, [r7, #2]
  220470:	0a1b      	lsrs	r3, r3, #8
  220472:	807b      	strh	r3, [r7, #2]
	*ptr++ = (BYTE)val;
  220474:	687b      	ldr	r3, [r7, #4]
  220476:	1c5a      	adds	r2, r3, #1
  220478:	607a      	str	r2, [r7, #4]
  22047a:	887a      	ldrh	r2, [r7, #2]
  22047c:	b2d2      	uxtb	r2, r2
  22047e:	701a      	strb	r2, [r3, #0]
}
  220480:	bf00      	nop
  220482:	370c      	adds	r7, #12
  220484:	46bd      	mov	sp, r7
  220486:	f85d 7b04 	ldr.w	r7, [sp], #4
  22048a:	4770      	bx	lr

0022048c <st_dword>:

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
  22048c:	b480      	push	{r7}
  22048e:	b083      	sub	sp, #12
  220490:	af00      	add	r7, sp, #0
  220492:	6078      	str	r0, [r7, #4]
  220494:	6039      	str	r1, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
  220496:	687b      	ldr	r3, [r7, #4]
  220498:	1c5a      	adds	r2, r3, #1
  22049a:	607a      	str	r2, [r7, #4]
  22049c:	683a      	ldr	r2, [r7, #0]
  22049e:	b2d2      	uxtb	r2, r2
  2204a0:	701a      	strb	r2, [r3, #0]
  2204a2:	683b      	ldr	r3, [r7, #0]
  2204a4:	0a1b      	lsrs	r3, r3, #8
  2204a6:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
  2204a8:	687b      	ldr	r3, [r7, #4]
  2204aa:	1c5a      	adds	r2, r3, #1
  2204ac:	607a      	str	r2, [r7, #4]
  2204ae:	683a      	ldr	r2, [r7, #0]
  2204b0:	b2d2      	uxtb	r2, r2
  2204b2:	701a      	strb	r2, [r3, #0]
  2204b4:	683b      	ldr	r3, [r7, #0]
  2204b6:	0a1b      	lsrs	r3, r3, #8
  2204b8:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val; val >>= 8;
  2204ba:	687b      	ldr	r3, [r7, #4]
  2204bc:	1c5a      	adds	r2, r3, #1
  2204be:	607a      	str	r2, [r7, #4]
  2204c0:	683a      	ldr	r2, [r7, #0]
  2204c2:	b2d2      	uxtb	r2, r2
  2204c4:	701a      	strb	r2, [r3, #0]
  2204c6:	683b      	ldr	r3, [r7, #0]
  2204c8:	0a1b      	lsrs	r3, r3, #8
  2204ca:	603b      	str	r3, [r7, #0]
	*ptr++ = (BYTE)val;
  2204cc:	687b      	ldr	r3, [r7, #4]
  2204ce:	1c5a      	adds	r2, r3, #1
  2204d0:	607a      	str	r2, [r7, #4]
  2204d2:	683a      	ldr	r2, [r7, #0]
  2204d4:	b2d2      	uxtb	r2, r2
  2204d6:	701a      	strb	r2, [r3, #0]
}
  2204d8:	bf00      	nop
  2204da:	370c      	adds	r7, #12
  2204dc:	46bd      	mov	sp, r7
  2204de:	f85d 7b04 	ldr.w	r7, [sp], #4
  2204e2:	4770      	bx	lr

002204e4 <mem_cpy>:
/* String functions                                                      */
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
  2204e4:	b480      	push	{r7}
  2204e6:	b087      	sub	sp, #28
  2204e8:	af00      	add	r7, sp, #0
  2204ea:	60f8      	str	r0, [r7, #12]
  2204ec:	60b9      	str	r1, [r7, #8]
  2204ee:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
  2204f0:	68fb      	ldr	r3, [r7, #12]
  2204f2:	617b      	str	r3, [r7, #20]
	const BYTE *s = (const BYTE*)src;
  2204f4:	68bb      	ldr	r3, [r7, #8]
  2204f6:	613b      	str	r3, [r7, #16]

	if (cnt) {
  2204f8:	687b      	ldr	r3, [r7, #4]
  2204fa:	2b00      	cmp	r3, #0
  2204fc:	d00d      	beq.n	22051a <mem_cpy+0x36>
		do {
			*d++ = *s++;
  2204fe:	697b      	ldr	r3, [r7, #20]
  220500:	1c5a      	adds	r2, r3, #1
  220502:	617a      	str	r2, [r7, #20]
  220504:	693a      	ldr	r2, [r7, #16]
  220506:	1c51      	adds	r1, r2, #1
  220508:	6139      	str	r1, [r7, #16]
  22050a:	7812      	ldrb	r2, [r2, #0]
  22050c:	701a      	strb	r2, [r3, #0]
		} while (--cnt);
  22050e:	687b      	ldr	r3, [r7, #4]
  220510:	3b01      	subs	r3, #1
  220512:	607b      	str	r3, [r7, #4]
  220514:	687b      	ldr	r3, [r7, #4]
  220516:	2b00      	cmp	r3, #0
  220518:	d1f1      	bne.n	2204fe <mem_cpy+0x1a>
	}
}
  22051a:	bf00      	nop
  22051c:	371c      	adds	r7, #28
  22051e:	46bd      	mov	sp, r7
  220520:	f85d 7b04 	ldr.w	r7, [sp], #4
  220524:	4770      	bx	lr

00220526 <mem_set>:

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
  220526:	b480      	push	{r7}
  220528:	b087      	sub	sp, #28
  22052a:	af00      	add	r7, sp, #0
  22052c:	60f8      	str	r0, [r7, #12]
  22052e:	60b9      	str	r1, [r7, #8]
  220530:	607a      	str	r2, [r7, #4]
	BYTE *d = (BYTE*)dst;
  220532:	68fb      	ldr	r3, [r7, #12]
  220534:	617b      	str	r3, [r7, #20]

	do {
		*d++ = (BYTE)val;
  220536:	697b      	ldr	r3, [r7, #20]
  220538:	1c5a      	adds	r2, r3, #1
  22053a:	617a      	str	r2, [r7, #20]
  22053c:	68ba      	ldr	r2, [r7, #8]
  22053e:	b2d2      	uxtb	r2, r2
  220540:	701a      	strb	r2, [r3, #0]
	} while (--cnt);
  220542:	687b      	ldr	r3, [r7, #4]
  220544:	3b01      	subs	r3, #1
  220546:	607b      	str	r3, [r7, #4]
  220548:	687b      	ldr	r3, [r7, #4]
  22054a:	2b00      	cmp	r3, #0
  22054c:	d1f3      	bne.n	220536 <mem_set+0x10>
}
  22054e:	bf00      	nop
  220550:	371c      	adds	r7, #28
  220552:	46bd      	mov	sp, r7
  220554:	f85d 7b04 	ldr.w	r7, [sp], #4
  220558:	4770      	bx	lr

0022055a <mem_cmp>:

/* Compare memory block */
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
  22055a:	b480      	push	{r7}
  22055c:	b089      	sub	sp, #36	; 0x24
  22055e:	af00      	add	r7, sp, #0
  220560:	60f8      	str	r0, [r7, #12]
  220562:	60b9      	str	r1, [r7, #8]
  220564:	607a      	str	r2, [r7, #4]
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
  220566:	68fb      	ldr	r3, [r7, #12]
  220568:	61fb      	str	r3, [r7, #28]
  22056a:	68bb      	ldr	r3, [r7, #8]
  22056c:	61bb      	str	r3, [r7, #24]
	int r = 0;
  22056e:	2300      	movs	r3, #0
  220570:	617b      	str	r3, [r7, #20]

	do {
		r = *d++ - *s++;
  220572:	69fb      	ldr	r3, [r7, #28]
  220574:	1c5a      	adds	r2, r3, #1
  220576:	61fa      	str	r2, [r7, #28]
  220578:	781b      	ldrb	r3, [r3, #0]
  22057a:	4619      	mov	r1, r3
  22057c:	69bb      	ldr	r3, [r7, #24]
  22057e:	1c5a      	adds	r2, r3, #1
  220580:	61ba      	str	r2, [r7, #24]
  220582:	781b      	ldrb	r3, [r3, #0]
  220584:	1acb      	subs	r3, r1, r3
  220586:	617b      	str	r3, [r7, #20]
	} while (--cnt && r == 0);
  220588:	687b      	ldr	r3, [r7, #4]
  22058a:	3b01      	subs	r3, #1
  22058c:	607b      	str	r3, [r7, #4]
  22058e:	687b      	ldr	r3, [r7, #4]
  220590:	2b00      	cmp	r3, #0
  220592:	d002      	beq.n	22059a <mem_cmp+0x40>
  220594:	697b      	ldr	r3, [r7, #20]
  220596:	2b00      	cmp	r3, #0
  220598:	d0eb      	beq.n	220572 <mem_cmp+0x18>

	return r;
  22059a:	697b      	ldr	r3, [r7, #20]
}
  22059c:	4618      	mov	r0, r3
  22059e:	3724      	adds	r7, #36	; 0x24
  2205a0:	46bd      	mov	sp, r7
  2205a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  2205a6:	4770      	bx	lr

002205a8 <chk_chr>:

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
  2205a8:	b480      	push	{r7}
  2205aa:	b083      	sub	sp, #12
  2205ac:	af00      	add	r7, sp, #0
  2205ae:	6078      	str	r0, [r7, #4]
  2205b0:	6039      	str	r1, [r7, #0]
	while (*str && *str != chr) str++;
  2205b2:	e002      	b.n	2205ba <chk_chr+0x12>
  2205b4:	687b      	ldr	r3, [r7, #4]
  2205b6:	3301      	adds	r3, #1
  2205b8:	607b      	str	r3, [r7, #4]
  2205ba:	687b      	ldr	r3, [r7, #4]
  2205bc:	781b      	ldrb	r3, [r3, #0]
  2205be:	2b00      	cmp	r3, #0
  2205c0:	d005      	beq.n	2205ce <chk_chr+0x26>
  2205c2:	687b      	ldr	r3, [r7, #4]
  2205c4:	781b      	ldrb	r3, [r3, #0]
  2205c6:	461a      	mov	r2, r3
  2205c8:	683b      	ldr	r3, [r7, #0]
  2205ca:	429a      	cmp	r2, r3
  2205cc:	d1f2      	bne.n	2205b4 <chk_chr+0xc>
	return *str;
  2205ce:	687b      	ldr	r3, [r7, #4]
  2205d0:	781b      	ldrb	r3, [r3, #0]
}
  2205d2:	4618      	mov	r0, r3
  2205d4:	370c      	adds	r7, #12
  2205d6:	46bd      	mov	sp, r7
  2205d8:	f85d 7b04 	ldr.w	r7, [sp], #4
  2205dc:	4770      	bx	lr

002205de <lock_fs>:
/*-----------------------------------------------------------------------*/
static
int lock_fs (
	FATFS* fs		/* File system object */
)
{
  2205de:	b580      	push	{r7, lr}
  2205e0:	b082      	sub	sp, #8
  2205e2:	af00      	add	r7, sp, #0
  2205e4:	6078      	str	r0, [r7, #4]
	return (fs && ff_req_grant(fs->sobj)) ? 1 : 0;
  2205e6:	687b      	ldr	r3, [r7, #4]
  2205e8:	2b00      	cmp	r3, #0
  2205ea:	d009      	beq.n	220600 <lock_fs+0x22>
  2205ec:	687b      	ldr	r3, [r7, #4]
  2205ee:	691b      	ldr	r3, [r3, #16]
  2205f0:	4618      	mov	r0, r3
  2205f2:	f003 f83d 	bl	223670 <ff_req_grant>
  2205f6:	4603      	mov	r3, r0
  2205f8:	2b00      	cmp	r3, #0
  2205fa:	d001      	beq.n	220600 <lock_fs+0x22>
  2205fc:	2301      	movs	r3, #1
  2205fe:	e000      	b.n	220602 <lock_fs+0x24>
  220600:	2300      	movs	r3, #0
}
  220602:	4618      	mov	r0, r3
  220604:	3708      	adds	r7, #8
  220606:	46bd      	mov	sp, r7
  220608:	bd80      	pop	{r7, pc}

0022060a <unlock_fs>:
static
void unlock_fs (
	FATFS* fs,		/* File system object */
	FRESULT res		/* Result code to be returned */
)
{
  22060a:	b580      	push	{r7, lr}
  22060c:	b082      	sub	sp, #8
  22060e:	af00      	add	r7, sp, #0
  220610:	6078      	str	r0, [r7, #4]
  220612:	460b      	mov	r3, r1
  220614:	70fb      	strb	r3, [r7, #3]
	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
  220616:	687b      	ldr	r3, [r7, #4]
  220618:	2b00      	cmp	r3, #0
  22061a:	d00d      	beq.n	220638 <unlock_fs+0x2e>
  22061c:	78fb      	ldrb	r3, [r7, #3]
  22061e:	2b0c      	cmp	r3, #12
  220620:	d00a      	beq.n	220638 <unlock_fs+0x2e>
  220622:	78fb      	ldrb	r3, [r7, #3]
  220624:	2b0b      	cmp	r3, #11
  220626:	d007      	beq.n	220638 <unlock_fs+0x2e>
  220628:	78fb      	ldrb	r3, [r7, #3]
  22062a:	2b0f      	cmp	r3, #15
  22062c:	d004      	beq.n	220638 <unlock_fs+0x2e>
		ff_rel_grant(fs->sobj);
  22062e:	687b      	ldr	r3, [r7, #4]
  220630:	691b      	ldr	r3, [r3, #16]
  220632:	4618      	mov	r0, r3
  220634:	f003 f831 	bl	22369a <ff_rel_grant>
	}
}
  220638:	bf00      	nop
  22063a:	3708      	adds	r7, #8
  22063c:	46bd      	mov	sp, r7
  22063e:	bd80      	pop	{r7, pc}

00220640 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  220640:	b480      	push	{r7}
  220642:	b085      	sub	sp, #20
  220644:	af00      	add	r7, sp, #0
  220646:	6078      	str	r0, [r7, #4]
  220648:	6039      	str	r1, [r7, #0]
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
  22064a:	2300      	movs	r3, #0
  22064c:	60bb      	str	r3, [r7, #8]
  22064e:	68bb      	ldr	r3, [r7, #8]
  220650:	60fb      	str	r3, [r7, #12]
  220652:	e029      	b.n	2206a8 <chk_lock+0x68>
		if (Files[i].fs) {	/* Existing entry */
  220654:	4a27      	ldr	r2, [pc, #156]	; (2206f4 <chk_lock+0xb4>)
  220656:	68fb      	ldr	r3, [r7, #12]
  220658:	011b      	lsls	r3, r3, #4
  22065a:	4413      	add	r3, r2
  22065c:	681b      	ldr	r3, [r3, #0]
  22065e:	2b00      	cmp	r3, #0
  220660:	d01d      	beq.n	22069e <chk_lock+0x5e>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
  220662:	4a24      	ldr	r2, [pc, #144]	; (2206f4 <chk_lock+0xb4>)
  220664:	68fb      	ldr	r3, [r7, #12]
  220666:	011b      	lsls	r3, r3, #4
  220668:	4413      	add	r3, r2
  22066a:	681a      	ldr	r2, [r3, #0]
  22066c:	687b      	ldr	r3, [r7, #4]
  22066e:	681b      	ldr	r3, [r3, #0]
  220670:	429a      	cmp	r2, r3
  220672:	d116      	bne.n	2206a2 <chk_lock+0x62>
				Files[i].clu == dp->obj.sclust &&
  220674:	4a1f      	ldr	r2, [pc, #124]	; (2206f4 <chk_lock+0xb4>)
  220676:	68fb      	ldr	r3, [r7, #12]
  220678:	011b      	lsls	r3, r3, #4
  22067a:	4413      	add	r3, r2
  22067c:	3304      	adds	r3, #4
  22067e:	681a      	ldr	r2, [r3, #0]
  220680:	687b      	ldr	r3, [r7, #4]
  220682:	689b      	ldr	r3, [r3, #8]
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
  220684:	429a      	cmp	r2, r3
  220686:	d10c      	bne.n	2206a2 <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
  220688:	4a1a      	ldr	r2, [pc, #104]	; (2206f4 <chk_lock+0xb4>)
  22068a:	68fb      	ldr	r3, [r7, #12]
  22068c:	011b      	lsls	r3, r3, #4
  22068e:	4413      	add	r3, r2
  220690:	3308      	adds	r3, #8
  220692:	681a      	ldr	r2, [r3, #0]
  220694:	687b      	ldr	r3, [r7, #4]
  220696:	695b      	ldr	r3, [r3, #20]
				Files[i].clu == dp->obj.sclust &&
  220698:	429a      	cmp	r2, r3
  22069a:	d102      	bne.n	2206a2 <chk_lock+0x62>
				Files[i].ofs == dp->dptr) break;
  22069c:	e007      	b.n	2206ae <chk_lock+0x6e>
		} else {			/* Blank entry */
			be = 1;
  22069e:	2301      	movs	r3, #1
  2206a0:	60bb      	str	r3, [r7, #8]
	for (i = be = 0; i < _FS_LOCK; i++) {
  2206a2:	68fb      	ldr	r3, [r7, #12]
  2206a4:	3301      	adds	r3, #1
  2206a6:	60fb      	str	r3, [r7, #12]
  2206a8:	68fb      	ldr	r3, [r7, #12]
  2206aa:	2b09      	cmp	r3, #9
  2206ac:	d9d2      	bls.n	220654 <chk_lock+0x14>
		}
	}
	if (i == _FS_LOCK) {	/* The object is not opened */
  2206ae:	68fb      	ldr	r3, [r7, #12]
  2206b0:	2b0a      	cmp	r3, #10
  2206b2:	d109      	bne.n	2206c8 <chk_lock+0x88>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
  2206b4:	68bb      	ldr	r3, [r7, #8]
  2206b6:	2b00      	cmp	r3, #0
  2206b8:	d102      	bne.n	2206c0 <chk_lock+0x80>
  2206ba:	683b      	ldr	r3, [r7, #0]
  2206bc:	2b02      	cmp	r3, #2
  2206be:	d101      	bne.n	2206c4 <chk_lock+0x84>
  2206c0:	2300      	movs	r3, #0
  2206c2:	e010      	b.n	2206e6 <chk_lock+0xa6>
  2206c4:	2312      	movs	r3, #18
  2206c6:	e00e      	b.n	2206e6 <chk_lock+0xa6>
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  2206c8:	683b      	ldr	r3, [r7, #0]
  2206ca:	2b00      	cmp	r3, #0
  2206cc:	d108      	bne.n	2206e0 <chk_lock+0xa0>
  2206ce:	4a09      	ldr	r2, [pc, #36]	; (2206f4 <chk_lock+0xb4>)
  2206d0:	68fb      	ldr	r3, [r7, #12]
  2206d2:	011b      	lsls	r3, r3, #4
  2206d4:	4413      	add	r3, r2
  2206d6:	330c      	adds	r3, #12
  2206d8:	881b      	ldrh	r3, [r3, #0]
  2206da:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  2206de:	d101      	bne.n	2206e4 <chk_lock+0xa4>
  2206e0:	2310      	movs	r3, #16
  2206e2:	e000      	b.n	2206e6 <chk_lock+0xa6>
  2206e4:	2300      	movs	r3, #0
}
  2206e6:	4618      	mov	r0, r3
  2206e8:	3714      	adds	r7, #20
  2206ea:	46bd      	mov	sp, r7
  2206ec:	f85d 7b04 	ldr.w	r7, [sp], #4
  2206f0:	4770      	bx	lr
  2206f2:	bf00      	nop
  2206f4:	20010bac 	.word	0x20010bac

002206f8 <enq_lock>:


static
int enq_lock (void)	/* Check if an entry is available for a new object */
{
  2206f8:	b480      	push	{r7}
  2206fa:	b083      	sub	sp, #12
  2206fc:	af00      	add	r7, sp, #0
	UINT i;

	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
  2206fe:	2300      	movs	r3, #0
  220700:	607b      	str	r3, [r7, #4]
  220702:	e002      	b.n	22070a <enq_lock+0x12>
  220704:	687b      	ldr	r3, [r7, #4]
  220706:	3301      	adds	r3, #1
  220708:	607b      	str	r3, [r7, #4]
  22070a:	687b      	ldr	r3, [r7, #4]
  22070c:	2b09      	cmp	r3, #9
  22070e:	d806      	bhi.n	22071e <enq_lock+0x26>
  220710:	4a09      	ldr	r2, [pc, #36]	; (220738 <enq_lock+0x40>)
  220712:	687b      	ldr	r3, [r7, #4]
  220714:	011b      	lsls	r3, r3, #4
  220716:	4413      	add	r3, r2
  220718:	681b      	ldr	r3, [r3, #0]
  22071a:	2b00      	cmp	r3, #0
  22071c:	d1f2      	bne.n	220704 <enq_lock+0xc>
	return (i == _FS_LOCK) ? 0 : 1;
  22071e:	687b      	ldr	r3, [r7, #4]
  220720:	2b0a      	cmp	r3, #10
  220722:	bf14      	ite	ne
  220724:	2301      	movne	r3, #1
  220726:	2300      	moveq	r3, #0
  220728:	b2db      	uxtb	r3, r3
}
  22072a:	4618      	mov	r0, r3
  22072c:	370c      	adds	r7, #12
  22072e:	46bd      	mov	sp, r7
  220730:	f85d 7b04 	ldr.w	r7, [sp], #4
  220734:	4770      	bx	lr
  220736:	bf00      	nop
  220738:	20010bac 	.word	0x20010bac

0022073c <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  22073c:	b480      	push	{r7}
  22073e:	b085      	sub	sp, #20
  220740:	af00      	add	r7, sp, #0
  220742:	6078      	str	r0, [r7, #4]
  220744:	6039      	str	r1, [r7, #0]
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
  220746:	2300      	movs	r3, #0
  220748:	60fb      	str	r3, [r7, #12]
  22074a:	e01f      	b.n	22078c <inc_lock+0x50>
		if (Files[i].fs == dp->obj.fs &&
  22074c:	4a41      	ldr	r2, [pc, #260]	; (220854 <inc_lock+0x118>)
  22074e:	68fb      	ldr	r3, [r7, #12]
  220750:	011b      	lsls	r3, r3, #4
  220752:	4413      	add	r3, r2
  220754:	681a      	ldr	r2, [r3, #0]
  220756:	687b      	ldr	r3, [r7, #4]
  220758:	681b      	ldr	r3, [r3, #0]
  22075a:	429a      	cmp	r2, r3
  22075c:	d113      	bne.n	220786 <inc_lock+0x4a>
			Files[i].clu == dp->obj.sclust &&
  22075e:	4a3d      	ldr	r2, [pc, #244]	; (220854 <inc_lock+0x118>)
  220760:	68fb      	ldr	r3, [r7, #12]
  220762:	011b      	lsls	r3, r3, #4
  220764:	4413      	add	r3, r2
  220766:	3304      	adds	r3, #4
  220768:	681a      	ldr	r2, [r3, #0]
  22076a:	687b      	ldr	r3, [r7, #4]
  22076c:	689b      	ldr	r3, [r3, #8]
		if (Files[i].fs == dp->obj.fs &&
  22076e:	429a      	cmp	r2, r3
  220770:	d109      	bne.n	220786 <inc_lock+0x4a>
			Files[i].ofs == dp->dptr) break;
  220772:	4a38      	ldr	r2, [pc, #224]	; (220854 <inc_lock+0x118>)
  220774:	68fb      	ldr	r3, [r7, #12]
  220776:	011b      	lsls	r3, r3, #4
  220778:	4413      	add	r3, r2
  22077a:	3308      	adds	r3, #8
  22077c:	681a      	ldr	r2, [r3, #0]
  22077e:	687b      	ldr	r3, [r7, #4]
  220780:	695b      	ldr	r3, [r3, #20]
			Files[i].clu == dp->obj.sclust &&
  220782:	429a      	cmp	r2, r3
  220784:	d006      	beq.n	220794 <inc_lock+0x58>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
  220786:	68fb      	ldr	r3, [r7, #12]
  220788:	3301      	adds	r3, #1
  22078a:	60fb      	str	r3, [r7, #12]
  22078c:	68fb      	ldr	r3, [r7, #12]
  22078e:	2b09      	cmp	r3, #9
  220790:	d9dc      	bls.n	22074c <inc_lock+0x10>
  220792:	e000      	b.n	220796 <inc_lock+0x5a>
			Files[i].ofs == dp->dptr) break;
  220794:	bf00      	nop
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
  220796:	68fb      	ldr	r3, [r7, #12]
  220798:	2b0a      	cmp	r3, #10
  22079a:	d132      	bne.n	220802 <inc_lock+0xc6>
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
  22079c:	2300      	movs	r3, #0
  22079e:	60fb      	str	r3, [r7, #12]
  2207a0:	e002      	b.n	2207a8 <inc_lock+0x6c>
  2207a2:	68fb      	ldr	r3, [r7, #12]
  2207a4:	3301      	adds	r3, #1
  2207a6:	60fb      	str	r3, [r7, #12]
  2207a8:	68fb      	ldr	r3, [r7, #12]
  2207aa:	2b09      	cmp	r3, #9
  2207ac:	d806      	bhi.n	2207bc <inc_lock+0x80>
  2207ae:	4a29      	ldr	r2, [pc, #164]	; (220854 <inc_lock+0x118>)
  2207b0:	68fb      	ldr	r3, [r7, #12]
  2207b2:	011b      	lsls	r3, r3, #4
  2207b4:	4413      	add	r3, r2
  2207b6:	681b      	ldr	r3, [r3, #0]
  2207b8:	2b00      	cmp	r3, #0
  2207ba:	d1f2      	bne.n	2207a2 <inc_lock+0x66>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
  2207bc:	68fb      	ldr	r3, [r7, #12]
  2207be:	2b0a      	cmp	r3, #10
  2207c0:	d101      	bne.n	2207c6 <inc_lock+0x8a>
  2207c2:	2300      	movs	r3, #0
  2207c4:	e040      	b.n	220848 <inc_lock+0x10c>
		Files[i].fs = dp->obj.fs;
  2207c6:	687b      	ldr	r3, [r7, #4]
  2207c8:	681a      	ldr	r2, [r3, #0]
  2207ca:	4922      	ldr	r1, [pc, #136]	; (220854 <inc_lock+0x118>)
  2207cc:	68fb      	ldr	r3, [r7, #12]
  2207ce:	011b      	lsls	r3, r3, #4
  2207d0:	440b      	add	r3, r1
  2207d2:	601a      	str	r2, [r3, #0]
		Files[i].clu = dp->obj.sclust;
  2207d4:	687b      	ldr	r3, [r7, #4]
  2207d6:	689a      	ldr	r2, [r3, #8]
  2207d8:	491e      	ldr	r1, [pc, #120]	; (220854 <inc_lock+0x118>)
  2207da:	68fb      	ldr	r3, [r7, #12]
  2207dc:	011b      	lsls	r3, r3, #4
  2207de:	440b      	add	r3, r1
  2207e0:	3304      	adds	r3, #4
  2207e2:	601a      	str	r2, [r3, #0]
		Files[i].ofs = dp->dptr;
  2207e4:	687b      	ldr	r3, [r7, #4]
  2207e6:	695a      	ldr	r2, [r3, #20]
  2207e8:	491a      	ldr	r1, [pc, #104]	; (220854 <inc_lock+0x118>)
  2207ea:	68fb      	ldr	r3, [r7, #12]
  2207ec:	011b      	lsls	r3, r3, #4
  2207ee:	440b      	add	r3, r1
  2207f0:	3308      	adds	r3, #8
  2207f2:	601a      	str	r2, [r3, #0]
		Files[i].ctr = 0;
  2207f4:	4a17      	ldr	r2, [pc, #92]	; (220854 <inc_lock+0x118>)
  2207f6:	68fb      	ldr	r3, [r7, #12]
  2207f8:	011b      	lsls	r3, r3, #4
  2207fa:	4413      	add	r3, r2
  2207fc:	330c      	adds	r3, #12
  2207fe:	2200      	movs	r2, #0
  220800:	801a      	strh	r2, [r3, #0]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  220802:	683b      	ldr	r3, [r7, #0]
  220804:	2b00      	cmp	r3, #0
  220806:	d009      	beq.n	22081c <inc_lock+0xe0>
  220808:	4a12      	ldr	r2, [pc, #72]	; (220854 <inc_lock+0x118>)
  22080a:	68fb      	ldr	r3, [r7, #12]
  22080c:	011b      	lsls	r3, r3, #4
  22080e:	4413      	add	r3, r2
  220810:	330c      	adds	r3, #12
  220812:	881b      	ldrh	r3, [r3, #0]
  220814:	2b00      	cmp	r3, #0
  220816:	d001      	beq.n	22081c <inc_lock+0xe0>
  220818:	2300      	movs	r3, #0
  22081a:	e015      	b.n	220848 <inc_lock+0x10c>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  22081c:	683b      	ldr	r3, [r7, #0]
  22081e:	2b00      	cmp	r3, #0
  220820:	d108      	bne.n	220834 <inc_lock+0xf8>
  220822:	4a0c      	ldr	r2, [pc, #48]	; (220854 <inc_lock+0x118>)
  220824:	68fb      	ldr	r3, [r7, #12]
  220826:	011b      	lsls	r3, r3, #4
  220828:	4413      	add	r3, r2
  22082a:	330c      	adds	r3, #12
  22082c:	881b      	ldrh	r3, [r3, #0]
  22082e:	3301      	adds	r3, #1
  220830:	b29a      	uxth	r2, r3
  220832:	e001      	b.n	220838 <inc_lock+0xfc>
  220834:	f44f 7280 	mov.w	r2, #256	; 0x100
  220838:	4906      	ldr	r1, [pc, #24]	; (220854 <inc_lock+0x118>)
  22083a:	68fb      	ldr	r3, [r7, #12]
  22083c:	011b      	lsls	r3, r3, #4
  22083e:	440b      	add	r3, r1
  220840:	330c      	adds	r3, #12
  220842:	801a      	strh	r2, [r3, #0]

	return i + 1;
  220844:	68fb      	ldr	r3, [r7, #12]
  220846:	3301      	adds	r3, #1
}
  220848:	4618      	mov	r0, r3
  22084a:	3714      	adds	r7, #20
  22084c:	46bd      	mov	sp, r7
  22084e:	f85d 7b04 	ldr.w	r7, [sp], #4
  220852:	4770      	bx	lr
  220854:	20010bac 	.word	0x20010bac

00220858 <dec_lock>:

static
FRESULT dec_lock (	/* Decrement object open counter */
	UINT i			/* Semaphore index (1..) */
)
{
  220858:	b480      	push	{r7}
  22085a:	b085      	sub	sp, #20
  22085c:	af00      	add	r7, sp, #0
  22085e:	6078      	str	r0, [r7, #4]
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
  220860:	687b      	ldr	r3, [r7, #4]
  220862:	3b01      	subs	r3, #1
  220864:	607b      	str	r3, [r7, #4]
  220866:	687b      	ldr	r3, [r7, #4]
  220868:	2b09      	cmp	r3, #9
  22086a:	d825      	bhi.n	2208b8 <dec_lock+0x60>
		n = Files[i].ctr;
  22086c:	4a17      	ldr	r2, [pc, #92]	; (2208cc <dec_lock+0x74>)
  22086e:	687b      	ldr	r3, [r7, #4]
  220870:	011b      	lsls	r3, r3, #4
  220872:	4413      	add	r3, r2
  220874:	330c      	adds	r3, #12
  220876:	881b      	ldrh	r3, [r3, #0]
  220878:	81fb      	strh	r3, [r7, #14]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
  22087a:	89fb      	ldrh	r3, [r7, #14]
  22087c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  220880:	d101      	bne.n	220886 <dec_lock+0x2e>
  220882:	2300      	movs	r3, #0
  220884:	81fb      	strh	r3, [r7, #14]
		if (n > 0) n--;				/* Decrement read mode open count */
  220886:	89fb      	ldrh	r3, [r7, #14]
  220888:	2b00      	cmp	r3, #0
  22088a:	d002      	beq.n	220892 <dec_lock+0x3a>
  22088c:	89fb      	ldrh	r3, [r7, #14]
  22088e:	3b01      	subs	r3, #1
  220890:	81fb      	strh	r3, [r7, #14]
		Files[i].ctr = n;
  220892:	4a0e      	ldr	r2, [pc, #56]	; (2208cc <dec_lock+0x74>)
  220894:	687b      	ldr	r3, [r7, #4]
  220896:	011b      	lsls	r3, r3, #4
  220898:	4413      	add	r3, r2
  22089a:	330c      	adds	r3, #12
  22089c:	89fa      	ldrh	r2, [r7, #14]
  22089e:	801a      	strh	r2, [r3, #0]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
  2208a0:	89fb      	ldrh	r3, [r7, #14]
  2208a2:	2b00      	cmp	r3, #0
  2208a4:	d105      	bne.n	2208b2 <dec_lock+0x5a>
  2208a6:	4a09      	ldr	r2, [pc, #36]	; (2208cc <dec_lock+0x74>)
  2208a8:	687b      	ldr	r3, [r7, #4]
  2208aa:	011b      	lsls	r3, r3, #4
  2208ac:	4413      	add	r3, r2
  2208ae:	2200      	movs	r2, #0
  2208b0:	601a      	str	r2, [r3, #0]
		res = FR_OK;
  2208b2:	2300      	movs	r3, #0
  2208b4:	737b      	strb	r3, [r7, #13]
  2208b6:	e001      	b.n	2208bc <dec_lock+0x64>
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
  2208b8:	2302      	movs	r3, #2
  2208ba:	737b      	strb	r3, [r7, #13]
	}
	return res;
  2208bc:	7b7b      	ldrb	r3, [r7, #13]
}
  2208be:	4618      	mov	r0, r3
  2208c0:	3714      	adds	r7, #20
  2208c2:	46bd      	mov	sp, r7
  2208c4:	f85d 7b04 	ldr.w	r7, [sp], #4
  2208c8:	4770      	bx	lr
  2208ca:	bf00      	nop
  2208cc:	20010bac 	.word	0x20010bac

002208d0 <clear_lock>:

static
void clear_lock (	/* Clear lock entries of the volume */
	FATFS *fs
)
{
  2208d0:	b480      	push	{r7}
  2208d2:	b085      	sub	sp, #20
  2208d4:	af00      	add	r7, sp, #0
  2208d6:	6078      	str	r0, [r7, #4]
	UINT i;

	for (i = 0; i < _FS_LOCK; i++) {
  2208d8:	2300      	movs	r3, #0
  2208da:	60fb      	str	r3, [r7, #12]
  2208dc:	e010      	b.n	220900 <clear_lock+0x30>
		if (Files[i].fs == fs) Files[i].fs = 0;
  2208de:	4a0d      	ldr	r2, [pc, #52]	; (220914 <clear_lock+0x44>)
  2208e0:	68fb      	ldr	r3, [r7, #12]
  2208e2:	011b      	lsls	r3, r3, #4
  2208e4:	4413      	add	r3, r2
  2208e6:	681a      	ldr	r2, [r3, #0]
  2208e8:	687b      	ldr	r3, [r7, #4]
  2208ea:	429a      	cmp	r2, r3
  2208ec:	d105      	bne.n	2208fa <clear_lock+0x2a>
  2208ee:	4a09      	ldr	r2, [pc, #36]	; (220914 <clear_lock+0x44>)
  2208f0:	68fb      	ldr	r3, [r7, #12]
  2208f2:	011b      	lsls	r3, r3, #4
  2208f4:	4413      	add	r3, r2
  2208f6:	2200      	movs	r2, #0
  2208f8:	601a      	str	r2, [r3, #0]
	for (i = 0; i < _FS_LOCK; i++) {
  2208fa:	68fb      	ldr	r3, [r7, #12]
  2208fc:	3301      	adds	r3, #1
  2208fe:	60fb      	str	r3, [r7, #12]
  220900:	68fb      	ldr	r3, [r7, #12]
  220902:	2b09      	cmp	r3, #9
  220904:	d9eb      	bls.n	2208de <clear_lock+0xe>
	}
}
  220906:	bf00      	nop
  220908:	3714      	adds	r7, #20
  22090a:	46bd      	mov	sp, r7
  22090c:	f85d 7b04 	ldr.w	r7, [sp], #4
  220910:	4770      	bx	lr
  220912:	bf00      	nop
  220914:	20010bac 	.word	0x20010bac

00220918 <sync_window>:
#if !_FS_READONLY
static
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs			/* File system object */
)
{
  220918:	b580      	push	{r7, lr}
  22091a:	b086      	sub	sp, #24
  22091c:	af00      	add	r7, sp, #0
  22091e:	6078      	str	r0, [r7, #4]
	DWORD wsect;
	UINT nf;
	FRESULT res = FR_OK;
  220920:	2300      	movs	r3, #0
  220922:	73fb      	strb	r3, [r7, #15]


	if (fs->wflag) {	/* Write back the sector if it is dirty */
  220924:	687b      	ldr	r3, [r7, #4]
  220926:	78db      	ldrb	r3, [r3, #3]
  220928:	2b00      	cmp	r3, #0
  22092a:	d034      	beq.n	220996 <sync_window+0x7e>
		wsect = fs->winsect;	/* Current sector number */
  22092c:	687b      	ldr	r3, [r7, #4]
  22092e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  220930:	617b      	str	r3, [r7, #20]
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
  220932:	687b      	ldr	r3, [r7, #4]
  220934:	7858      	ldrb	r0, [r3, #1]
  220936:	687b      	ldr	r3, [r7, #4]
  220938:	f103 0138 	add.w	r1, r3, #56	; 0x38
  22093c:	2301      	movs	r3, #1
  22093e:	697a      	ldr	r2, [r7, #20]
  220940:	f7ff fd10 	bl	220364 <disk_write>
  220944:	4603      	mov	r3, r0
  220946:	2b00      	cmp	r3, #0
  220948:	d002      	beq.n	220950 <sync_window+0x38>
			res = FR_DISK_ERR;
  22094a:	2301      	movs	r3, #1
  22094c:	73fb      	strb	r3, [r7, #15]
  22094e:	e022      	b.n	220996 <sync_window+0x7e>
		} else {
			fs->wflag = 0;
  220950:	687b      	ldr	r3, [r7, #4]
  220952:	2200      	movs	r2, #0
  220954:	70da      	strb	r2, [r3, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
  220956:	687b      	ldr	r3, [r7, #4]
  220958:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  22095a:	697a      	ldr	r2, [r7, #20]
  22095c:	1ad2      	subs	r2, r2, r3
  22095e:	687b      	ldr	r3, [r7, #4]
  220960:	6a1b      	ldr	r3, [r3, #32]
  220962:	429a      	cmp	r2, r3
  220964:	d217      	bcs.n	220996 <sync_window+0x7e>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
  220966:	687b      	ldr	r3, [r7, #4]
  220968:	789b      	ldrb	r3, [r3, #2]
  22096a:	613b      	str	r3, [r7, #16]
  22096c:	e010      	b.n	220990 <sync_window+0x78>
					wsect += fs->fsize;
  22096e:	687b      	ldr	r3, [r7, #4]
  220970:	6a1b      	ldr	r3, [r3, #32]
  220972:	697a      	ldr	r2, [r7, #20]
  220974:	4413      	add	r3, r2
  220976:	617b      	str	r3, [r7, #20]
					disk_write(fs->drv, fs->win, wsect, 1);
  220978:	687b      	ldr	r3, [r7, #4]
  22097a:	7858      	ldrb	r0, [r3, #1]
  22097c:	687b      	ldr	r3, [r7, #4]
  22097e:	f103 0138 	add.w	r1, r3, #56	; 0x38
  220982:	2301      	movs	r3, #1
  220984:	697a      	ldr	r2, [r7, #20]
  220986:	f7ff fced 	bl	220364 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
  22098a:	693b      	ldr	r3, [r7, #16]
  22098c:	3b01      	subs	r3, #1
  22098e:	613b      	str	r3, [r7, #16]
  220990:	693b      	ldr	r3, [r7, #16]
  220992:	2b01      	cmp	r3, #1
  220994:	d8eb      	bhi.n	22096e <sync_window+0x56>
				}
			}
		}
	}
	return res;
  220996:	7bfb      	ldrb	r3, [r7, #15]
}
  220998:	4618      	mov	r0, r3
  22099a:	3718      	adds	r7, #24
  22099c:	46bd      	mov	sp, r7
  22099e:	bd80      	pop	{r7, pc}

002209a0 <move_window>:
static
FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
	FATFS* fs,			/* File system object */
	DWORD sector		/* Sector number to make appearance in the fs->win[] */
)
{
  2209a0:	b580      	push	{r7, lr}
  2209a2:	b084      	sub	sp, #16
  2209a4:	af00      	add	r7, sp, #0
  2209a6:	6078      	str	r0, [r7, #4]
  2209a8:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_OK;
  2209aa:	2300      	movs	r3, #0
  2209ac:	73fb      	strb	r3, [r7, #15]


	if (sector != fs->winsect) {	/* Window offset changed? */
  2209ae:	687b      	ldr	r3, [r7, #4]
  2209b0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  2209b2:	683b      	ldr	r3, [r7, #0]
  2209b4:	429a      	cmp	r2, r3
  2209b6:	d01b      	beq.n	2209f0 <move_window+0x50>
#if !_FS_READONLY
		res = sync_window(fs);		/* Write-back changes */
  2209b8:	6878      	ldr	r0, [r7, #4]
  2209ba:	f7ff ffad 	bl	220918 <sync_window>
  2209be:	4603      	mov	r3, r0
  2209c0:	73fb      	strb	r3, [r7, #15]
#endif
		if (res == FR_OK) {			/* Fill sector window with new data */
  2209c2:	7bfb      	ldrb	r3, [r7, #15]
  2209c4:	2b00      	cmp	r3, #0
  2209c6:	d113      	bne.n	2209f0 <move_window+0x50>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
  2209c8:	687b      	ldr	r3, [r7, #4]
  2209ca:	7858      	ldrb	r0, [r3, #1]
  2209cc:	687b      	ldr	r3, [r7, #4]
  2209ce:	f103 0138 	add.w	r1, r3, #56	; 0x38
  2209d2:	2301      	movs	r3, #1
  2209d4:	683a      	ldr	r2, [r7, #0]
  2209d6:	f7ff fca5 	bl	220324 <disk_read>
  2209da:	4603      	mov	r3, r0
  2209dc:	2b00      	cmp	r3, #0
  2209de:	d004      	beq.n	2209ea <move_window+0x4a>
				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
  2209e0:	f04f 33ff 	mov.w	r3, #4294967295
  2209e4:	603b      	str	r3, [r7, #0]
				res = FR_DISK_ERR;
  2209e6:	2301      	movs	r3, #1
  2209e8:	73fb      	strb	r3, [r7, #15]
			}
			fs->winsect = sector;
  2209ea:	687b      	ldr	r3, [r7, #4]
  2209ec:	683a      	ldr	r2, [r7, #0]
  2209ee:	635a      	str	r2, [r3, #52]	; 0x34
		}
	}
	return res;
  2209f0:	7bfb      	ldrb	r3, [r7, #15]
}
  2209f2:	4618      	mov	r0, r3
  2209f4:	3710      	adds	r7, #16
  2209f6:	46bd      	mov	sp, r7
  2209f8:	bd80      	pop	{r7, pc}
	...

002209fc <sync_fs>:

static
FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
	FATFS* fs		/* File system object */
)
{
  2209fc:	b580      	push	{r7, lr}
  2209fe:	b084      	sub	sp, #16
  220a00:	af00      	add	r7, sp, #0
  220a02:	6078      	str	r0, [r7, #4]
	FRESULT res;


	res = sync_window(fs);
  220a04:	6878      	ldr	r0, [r7, #4]
  220a06:	f7ff ff87 	bl	220918 <sync_window>
  220a0a:	4603      	mov	r3, r0
  220a0c:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK) {
  220a0e:	7bfb      	ldrb	r3, [r7, #15]
  220a10:	2b00      	cmp	r3, #0
  220a12:	d158      	bne.n	220ac6 <sync_fs+0xca>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
  220a14:	687b      	ldr	r3, [r7, #4]
  220a16:	781b      	ldrb	r3, [r3, #0]
  220a18:	2b03      	cmp	r3, #3
  220a1a:	d148      	bne.n	220aae <sync_fs+0xb2>
  220a1c:	687b      	ldr	r3, [r7, #4]
  220a1e:	791b      	ldrb	r3, [r3, #4]
  220a20:	2b01      	cmp	r3, #1
  220a22:	d144      	bne.n	220aae <sync_fs+0xb2>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, SS(fs));
  220a24:	687b      	ldr	r3, [r7, #4]
  220a26:	3338      	adds	r3, #56	; 0x38
  220a28:	f44f 7200 	mov.w	r2, #512	; 0x200
  220a2c:	2100      	movs	r1, #0
  220a2e:	4618      	mov	r0, r3
  220a30:	f7ff fd79 	bl	220526 <mem_set>
			st_word(fs->win + BS_55AA, 0xAA55);
  220a34:	687b      	ldr	r3, [r7, #4]
  220a36:	3338      	adds	r3, #56	; 0x38
  220a38:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
  220a3c:	f64a 2155 	movw	r1, #43605	; 0xaa55
  220a40:	4618      	mov	r0, r3
  220a42:	f7ff fd08 	bl	220456 <st_word>
			st_dword(fs->win + FSI_LeadSig, 0x41615252);
  220a46:	687b      	ldr	r3, [r7, #4]
  220a48:	3338      	adds	r3, #56	; 0x38
  220a4a:	4921      	ldr	r1, [pc, #132]	; (220ad0 <sync_fs+0xd4>)
  220a4c:	4618      	mov	r0, r3
  220a4e:	f7ff fd1d 	bl	22048c <st_dword>
			st_dword(fs->win + FSI_StrucSig, 0x61417272);
  220a52:	687b      	ldr	r3, [r7, #4]
  220a54:	3338      	adds	r3, #56	; 0x38
  220a56:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
  220a5a:	491e      	ldr	r1, [pc, #120]	; (220ad4 <sync_fs+0xd8>)
  220a5c:	4618      	mov	r0, r3
  220a5e:	f7ff fd15 	bl	22048c <st_dword>
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
  220a62:	687b      	ldr	r3, [r7, #4]
  220a64:	3338      	adds	r3, #56	; 0x38
  220a66:	f503 72f4 	add.w	r2, r3, #488	; 0x1e8
  220a6a:	687b      	ldr	r3, [r7, #4]
  220a6c:	699b      	ldr	r3, [r3, #24]
  220a6e:	4619      	mov	r1, r3
  220a70:	4610      	mov	r0, r2
  220a72:	f7ff fd0b 	bl	22048c <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
  220a76:	687b      	ldr	r3, [r7, #4]
  220a78:	3338      	adds	r3, #56	; 0x38
  220a7a:	f503 72f6 	add.w	r2, r3, #492	; 0x1ec
  220a7e:	687b      	ldr	r3, [r7, #4]
  220a80:	695b      	ldr	r3, [r3, #20]
  220a82:	4619      	mov	r1, r3
  220a84:	4610      	mov	r0, r2
  220a86:	f7ff fd01 	bl	22048c <st_dword>
			/* Write it into the FSInfo sector */
			fs->winsect = fs->volbase + 1;
  220a8a:	687b      	ldr	r3, [r7, #4]
  220a8c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  220a8e:	1c5a      	adds	r2, r3, #1
  220a90:	687b      	ldr	r3, [r7, #4]
  220a92:	635a      	str	r2, [r3, #52]	; 0x34
			disk_write(fs->drv, fs->win, fs->winsect, 1);
  220a94:	687b      	ldr	r3, [r7, #4]
  220a96:	7858      	ldrb	r0, [r3, #1]
  220a98:	687b      	ldr	r3, [r7, #4]
  220a9a:	f103 0138 	add.w	r1, r3, #56	; 0x38
  220a9e:	687b      	ldr	r3, [r7, #4]
  220aa0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  220aa2:	2301      	movs	r3, #1
  220aa4:	f7ff fc5e 	bl	220364 <disk_write>
			fs->fsi_flag = 0;
  220aa8:	687b      	ldr	r3, [r7, #4]
  220aaa:	2200      	movs	r2, #0
  220aac:	711a      	strb	r2, [r3, #4]
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
  220aae:	687b      	ldr	r3, [r7, #4]
  220ab0:	785b      	ldrb	r3, [r3, #1]
  220ab2:	2200      	movs	r2, #0
  220ab4:	2100      	movs	r1, #0
  220ab6:	4618      	mov	r0, r3
  220ab8:	f7ff fc74 	bl	2203a4 <disk_ioctl>
  220abc:	4603      	mov	r3, r0
  220abe:	2b00      	cmp	r3, #0
  220ac0:	d001      	beq.n	220ac6 <sync_fs+0xca>
  220ac2:	2301      	movs	r3, #1
  220ac4:	73fb      	strb	r3, [r7, #15]
	}

	return res;
  220ac6:	7bfb      	ldrb	r3, [r7, #15]
}
  220ac8:	4618      	mov	r0, r3
  220aca:	3710      	adds	r7, #16
  220acc:	46bd      	mov	sp, r7
  220ace:	bd80      	pop	{r7, pc}
  220ad0:	41615252 	.word	0x41615252
  220ad4:	61417272 	.word	0x61417272

00220ad8 <clust2sect>:
static
DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
  220ad8:	b480      	push	{r7}
  220ada:	b083      	sub	sp, #12
  220adc:	af00      	add	r7, sp, #0
  220ade:	6078      	str	r0, [r7, #4]
  220ae0:	6039      	str	r1, [r7, #0]
	clst -= 2;
  220ae2:	683b      	ldr	r3, [r7, #0]
  220ae4:	3b02      	subs	r3, #2
  220ae6:	603b      	str	r3, [r7, #0]
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
  220ae8:	687b      	ldr	r3, [r7, #4]
  220aea:	69db      	ldr	r3, [r3, #28]
  220aec:	1e9a      	subs	r2, r3, #2
  220aee:	683b      	ldr	r3, [r7, #0]
  220af0:	429a      	cmp	r2, r3
  220af2:	d801      	bhi.n	220af8 <clust2sect+0x20>
  220af4:	2300      	movs	r3, #0
  220af6:	e008      	b.n	220b0a <clust2sect+0x32>
	return clst * fs->csize + fs->database;
  220af8:	687b      	ldr	r3, [r7, #4]
  220afa:	895b      	ldrh	r3, [r3, #10]
  220afc:	461a      	mov	r2, r3
  220afe:	683b      	ldr	r3, [r7, #0]
  220b00:	fb03 f202 	mul.w	r2, r3, r2
  220b04:	687b      	ldr	r3, [r7, #4]
  220b06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  220b08:	4413      	add	r3, r2
}
  220b0a:	4618      	mov	r0, r3
  220b0c:	370c      	adds	r7, #12
  220b0e:	46bd      	mov	sp, r7
  220b10:	f85d 7b04 	ldr.w	r7, [sp], #4
  220b14:	4770      	bx	lr

00220b16 <get_fat>:
static
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
	_FDID* obj,	/* Corresponding object */
	DWORD clst	/* Cluster number to get the value */
)
{
  220b16:	b580      	push	{r7, lr}
  220b18:	b086      	sub	sp, #24
  220b1a:	af00      	add	r7, sp, #0
  220b1c:	6078      	str	r0, [r7, #4]
  220b1e:	6039      	str	r1, [r7, #0]
	UINT wc, bc;
	DWORD val;
	FATFS *fs = obj->fs;
  220b20:	687b      	ldr	r3, [r7, #4]
  220b22:	681b      	ldr	r3, [r3, #0]
  220b24:	613b      	str	r3, [r7, #16]


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
  220b26:	683b      	ldr	r3, [r7, #0]
  220b28:	2b01      	cmp	r3, #1
  220b2a:	d904      	bls.n	220b36 <get_fat+0x20>
  220b2c:	693b      	ldr	r3, [r7, #16]
  220b2e:	69da      	ldr	r2, [r3, #28]
  220b30:	683b      	ldr	r3, [r7, #0]
  220b32:	429a      	cmp	r2, r3
  220b34:	d802      	bhi.n	220b3c <get_fat+0x26>
		val = 1;	/* Internal error */
  220b36:	2301      	movs	r3, #1
  220b38:	617b      	str	r3, [r7, #20]
  220b3a:	e08c      	b.n	220c56 <get_fat+0x140>

	} else {
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
  220b3c:	f04f 33ff 	mov.w	r3, #4294967295
  220b40:	617b      	str	r3, [r7, #20]

		switch (fs->fs_type) {
  220b42:	693b      	ldr	r3, [r7, #16]
  220b44:	781b      	ldrb	r3, [r3, #0]
  220b46:	2b02      	cmp	r3, #2
  220b48:	d045      	beq.n	220bd6 <get_fat+0xc0>
  220b4a:	2b03      	cmp	r3, #3
  220b4c:	d05d      	beq.n	220c0a <get_fat+0xf4>
  220b4e:	2b01      	cmp	r3, #1
  220b50:	d177      	bne.n	220c42 <get_fat+0x12c>
		case FS_FAT12 :
			bc = (UINT)clst; bc += bc / 2;
  220b52:	683b      	ldr	r3, [r7, #0]
  220b54:	60fb      	str	r3, [r7, #12]
  220b56:	68fb      	ldr	r3, [r7, #12]
  220b58:	085b      	lsrs	r3, r3, #1
  220b5a:	68fa      	ldr	r2, [r7, #12]
  220b5c:	4413      	add	r3, r2
  220b5e:	60fb      	str	r3, [r7, #12]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  220b60:	693b      	ldr	r3, [r7, #16]
  220b62:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220b64:	68fb      	ldr	r3, [r7, #12]
  220b66:	0a5b      	lsrs	r3, r3, #9
  220b68:	4413      	add	r3, r2
  220b6a:	4619      	mov	r1, r3
  220b6c:	6938      	ldr	r0, [r7, #16]
  220b6e:	f7ff ff17 	bl	2209a0 <move_window>
  220b72:	4603      	mov	r3, r0
  220b74:	2b00      	cmp	r3, #0
  220b76:	d167      	bne.n	220c48 <get_fat+0x132>
			wc = fs->win[bc++ % SS(fs)];
  220b78:	68fb      	ldr	r3, [r7, #12]
  220b7a:	1c5a      	adds	r2, r3, #1
  220b7c:	60fa      	str	r2, [r7, #12]
  220b7e:	f3c3 0308 	ubfx	r3, r3, #0, #9
  220b82:	693a      	ldr	r2, [r7, #16]
  220b84:	4413      	add	r3, r2
  220b86:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
  220b8a:	60bb      	str	r3, [r7, #8]
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  220b8c:	693b      	ldr	r3, [r7, #16]
  220b8e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220b90:	68fb      	ldr	r3, [r7, #12]
  220b92:	0a5b      	lsrs	r3, r3, #9
  220b94:	4413      	add	r3, r2
  220b96:	4619      	mov	r1, r3
  220b98:	6938      	ldr	r0, [r7, #16]
  220b9a:	f7ff ff01 	bl	2209a0 <move_window>
  220b9e:	4603      	mov	r3, r0
  220ba0:	2b00      	cmp	r3, #0
  220ba2:	d153      	bne.n	220c4c <get_fat+0x136>
			wc |= fs->win[bc % SS(fs)] << 8;
  220ba4:	68fb      	ldr	r3, [r7, #12]
  220ba6:	f3c3 0308 	ubfx	r3, r3, #0, #9
  220baa:	693a      	ldr	r2, [r7, #16]
  220bac:	4413      	add	r3, r2
  220bae:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
  220bb2:	021b      	lsls	r3, r3, #8
  220bb4:	461a      	mov	r2, r3
  220bb6:	68bb      	ldr	r3, [r7, #8]
  220bb8:	4313      	orrs	r3, r2
  220bba:	60bb      	str	r3, [r7, #8]
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  220bbc:	683b      	ldr	r3, [r7, #0]
  220bbe:	f003 0301 	and.w	r3, r3, #1
  220bc2:	2b00      	cmp	r3, #0
  220bc4:	d002      	beq.n	220bcc <get_fat+0xb6>
  220bc6:	68bb      	ldr	r3, [r7, #8]
  220bc8:	091b      	lsrs	r3, r3, #4
  220bca:	e002      	b.n	220bd2 <get_fat+0xbc>
  220bcc:	68bb      	ldr	r3, [r7, #8]
  220bce:	f3c3 030b 	ubfx	r3, r3, #0, #12
  220bd2:	617b      	str	r3, [r7, #20]
			break;
  220bd4:	e03f      	b.n	220c56 <get_fat+0x140>

		case FS_FAT16 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
  220bd6:	693b      	ldr	r3, [r7, #16]
  220bd8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220bda:	683b      	ldr	r3, [r7, #0]
  220bdc:	0a1b      	lsrs	r3, r3, #8
  220bde:	4413      	add	r3, r2
  220be0:	4619      	mov	r1, r3
  220be2:	6938      	ldr	r0, [r7, #16]
  220be4:	f7ff fedc 	bl	2209a0 <move_window>
  220be8:	4603      	mov	r3, r0
  220bea:	2b00      	cmp	r3, #0
  220bec:	d130      	bne.n	220c50 <get_fat+0x13a>
			val = ld_word(fs->win + clst * 2 % SS(fs));
  220bee:	693b      	ldr	r3, [r7, #16]
  220bf0:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220bf4:	683b      	ldr	r3, [r7, #0]
  220bf6:	005b      	lsls	r3, r3, #1
  220bf8:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
  220bfc:	4413      	add	r3, r2
  220bfe:	4618      	mov	r0, r3
  220c00:	f7ff fbee 	bl	2203e0 <ld_word>
  220c04:	4603      	mov	r3, r0
  220c06:	617b      	str	r3, [r7, #20]
			break;
  220c08:	e025      	b.n	220c56 <get_fat+0x140>

		case FS_FAT32 :
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
  220c0a:	693b      	ldr	r3, [r7, #16]
  220c0c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220c0e:	683b      	ldr	r3, [r7, #0]
  220c10:	09db      	lsrs	r3, r3, #7
  220c12:	4413      	add	r3, r2
  220c14:	4619      	mov	r1, r3
  220c16:	6938      	ldr	r0, [r7, #16]
  220c18:	f7ff fec2 	bl	2209a0 <move_window>
  220c1c:	4603      	mov	r3, r0
  220c1e:	2b00      	cmp	r3, #0
  220c20:	d118      	bne.n	220c54 <get_fat+0x13e>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
  220c22:	693b      	ldr	r3, [r7, #16]
  220c24:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220c28:	683b      	ldr	r3, [r7, #0]
  220c2a:	009b      	lsls	r3, r3, #2
  220c2c:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
  220c30:	4413      	add	r3, r2
  220c32:	4618      	mov	r0, r3
  220c34:	f7ff fbec 	bl	220410 <ld_dword>
  220c38:	4603      	mov	r3, r0
  220c3a:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
  220c3e:	617b      	str	r3, [r7, #20]
			break;
  220c40:	e009      	b.n	220c56 <get_fat+0x140>
				}
			}
			/* go to default */
#endif
		default:
			val = 1;	/* Internal error */
  220c42:	2301      	movs	r3, #1
  220c44:	617b      	str	r3, [r7, #20]
  220c46:	e006      	b.n	220c56 <get_fat+0x140>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  220c48:	bf00      	nop
  220c4a:	e004      	b.n	220c56 <get_fat+0x140>
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
  220c4c:	bf00      	nop
  220c4e:	e002      	b.n	220c56 <get_fat+0x140>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
  220c50:	bf00      	nop
  220c52:	e000      	b.n	220c56 <get_fat+0x140>
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
  220c54:	bf00      	nop
		}
	}

	return val;
  220c56:	697b      	ldr	r3, [r7, #20]
}
  220c58:	4618      	mov	r0, r3
  220c5a:	3718      	adds	r7, #24
  220c5c:	46bd      	mov	sp, r7
  220c5e:	bd80      	pop	{r7, pc}

00220c60 <put_fat>:
FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
	FATFS* fs,		/* Corresponding file system object */
	DWORD clst,		/* FAT index number (cluster number) to be changed */
	DWORD val		/* New value to be set to the entry */
)
{
  220c60:	b590      	push	{r4, r7, lr}
  220c62:	b089      	sub	sp, #36	; 0x24
  220c64:	af00      	add	r7, sp, #0
  220c66:	60f8      	str	r0, [r7, #12]
  220c68:	60b9      	str	r1, [r7, #8]
  220c6a:	607a      	str	r2, [r7, #4]
	UINT bc;
	BYTE *p;
	FRESULT res = FR_INT_ERR;
  220c6c:	2302      	movs	r3, #2
  220c6e:	77fb      	strb	r3, [r7, #31]

	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
  220c70:	68bb      	ldr	r3, [r7, #8]
  220c72:	2b01      	cmp	r3, #1
  220c74:	f240 80d6 	bls.w	220e24 <put_fat+0x1c4>
  220c78:	68fb      	ldr	r3, [r7, #12]
  220c7a:	69da      	ldr	r2, [r3, #28]
  220c7c:	68bb      	ldr	r3, [r7, #8]
  220c7e:	429a      	cmp	r2, r3
  220c80:	f240 80d0 	bls.w	220e24 <put_fat+0x1c4>
		switch (fs->fs_type) {
  220c84:	68fb      	ldr	r3, [r7, #12]
  220c86:	781b      	ldrb	r3, [r3, #0]
  220c88:	2b02      	cmp	r3, #2
  220c8a:	d073      	beq.n	220d74 <put_fat+0x114>
  220c8c:	2b03      	cmp	r3, #3
  220c8e:	f000 8091 	beq.w	220db4 <put_fat+0x154>
  220c92:	2b01      	cmp	r3, #1
  220c94:	f040 80c6 	bne.w	220e24 <put_fat+0x1c4>
		case FS_FAT12 :	/* Bitfield items */
			bc = (UINT)clst; bc += bc / 2;
  220c98:	68bb      	ldr	r3, [r7, #8]
  220c9a:	61bb      	str	r3, [r7, #24]
  220c9c:	69bb      	ldr	r3, [r7, #24]
  220c9e:	085b      	lsrs	r3, r3, #1
  220ca0:	69ba      	ldr	r2, [r7, #24]
  220ca2:	4413      	add	r3, r2
  220ca4:	61bb      	str	r3, [r7, #24]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  220ca6:	68fb      	ldr	r3, [r7, #12]
  220ca8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220caa:	69bb      	ldr	r3, [r7, #24]
  220cac:	0a5b      	lsrs	r3, r3, #9
  220cae:	4413      	add	r3, r2
  220cb0:	4619      	mov	r1, r3
  220cb2:	68f8      	ldr	r0, [r7, #12]
  220cb4:	f7ff fe74 	bl	2209a0 <move_window>
  220cb8:	4603      	mov	r3, r0
  220cba:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
  220cbc:	7ffb      	ldrb	r3, [r7, #31]
  220cbe:	2b00      	cmp	r3, #0
  220cc0:	f040 80a9 	bne.w	220e16 <put_fat+0x1b6>
			p = fs->win + bc++ % SS(fs);
  220cc4:	68fb      	ldr	r3, [r7, #12]
  220cc6:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220cca:	69bb      	ldr	r3, [r7, #24]
  220ccc:	1c59      	adds	r1, r3, #1
  220cce:	61b9      	str	r1, [r7, #24]
  220cd0:	f3c3 0308 	ubfx	r3, r3, #0, #9
  220cd4:	4413      	add	r3, r2
  220cd6:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  220cd8:	68bb      	ldr	r3, [r7, #8]
  220cda:	f003 0301 	and.w	r3, r3, #1
  220cde:	2b00      	cmp	r3, #0
  220ce0:	d00d      	beq.n	220cfe <put_fat+0x9e>
  220ce2:	697b      	ldr	r3, [r7, #20]
  220ce4:	781b      	ldrb	r3, [r3, #0]
  220ce6:	b25b      	sxtb	r3, r3
  220ce8:	f003 030f 	and.w	r3, r3, #15
  220cec:	b25a      	sxtb	r2, r3
  220cee:	687b      	ldr	r3, [r7, #4]
  220cf0:	b2db      	uxtb	r3, r3
  220cf2:	011b      	lsls	r3, r3, #4
  220cf4:	b25b      	sxtb	r3, r3
  220cf6:	4313      	orrs	r3, r2
  220cf8:	b25b      	sxtb	r3, r3
  220cfa:	b2db      	uxtb	r3, r3
  220cfc:	e001      	b.n	220d02 <put_fat+0xa2>
  220cfe:	687b      	ldr	r3, [r7, #4]
  220d00:	b2db      	uxtb	r3, r3
  220d02:	697a      	ldr	r2, [r7, #20]
  220d04:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
  220d06:	68fb      	ldr	r3, [r7, #12]
  220d08:	2201      	movs	r2, #1
  220d0a:	70da      	strb	r2, [r3, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  220d0c:	68fb      	ldr	r3, [r7, #12]
  220d0e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220d10:	69bb      	ldr	r3, [r7, #24]
  220d12:	0a5b      	lsrs	r3, r3, #9
  220d14:	4413      	add	r3, r2
  220d16:	4619      	mov	r1, r3
  220d18:	68f8      	ldr	r0, [r7, #12]
  220d1a:	f7ff fe41 	bl	2209a0 <move_window>
  220d1e:	4603      	mov	r3, r0
  220d20:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
  220d22:	7ffb      	ldrb	r3, [r7, #31]
  220d24:	2b00      	cmp	r3, #0
  220d26:	d178      	bne.n	220e1a <put_fat+0x1ba>
			p = fs->win + bc % SS(fs);
  220d28:	68fb      	ldr	r3, [r7, #12]
  220d2a:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220d2e:	69bb      	ldr	r3, [r7, #24]
  220d30:	f3c3 0308 	ubfx	r3, r3, #0, #9
  220d34:	4413      	add	r3, r2
  220d36:	617b      	str	r3, [r7, #20]
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  220d38:	68bb      	ldr	r3, [r7, #8]
  220d3a:	f003 0301 	and.w	r3, r3, #1
  220d3e:	2b00      	cmp	r3, #0
  220d40:	d003      	beq.n	220d4a <put_fat+0xea>
  220d42:	687b      	ldr	r3, [r7, #4]
  220d44:	091b      	lsrs	r3, r3, #4
  220d46:	b2db      	uxtb	r3, r3
  220d48:	e00e      	b.n	220d68 <put_fat+0x108>
  220d4a:	697b      	ldr	r3, [r7, #20]
  220d4c:	781b      	ldrb	r3, [r3, #0]
  220d4e:	b25b      	sxtb	r3, r3
  220d50:	f023 030f 	bic.w	r3, r3, #15
  220d54:	b25a      	sxtb	r2, r3
  220d56:	687b      	ldr	r3, [r7, #4]
  220d58:	0a1b      	lsrs	r3, r3, #8
  220d5a:	b25b      	sxtb	r3, r3
  220d5c:	f003 030f 	and.w	r3, r3, #15
  220d60:	b25b      	sxtb	r3, r3
  220d62:	4313      	orrs	r3, r2
  220d64:	b25b      	sxtb	r3, r3
  220d66:	b2db      	uxtb	r3, r3
  220d68:	697a      	ldr	r2, [r7, #20]
  220d6a:	7013      	strb	r3, [r2, #0]
			fs->wflag = 1;
  220d6c:	68fb      	ldr	r3, [r7, #12]
  220d6e:	2201      	movs	r2, #1
  220d70:	70da      	strb	r2, [r3, #3]
			break;
  220d72:	e057      	b.n	220e24 <put_fat+0x1c4>

		case FS_FAT16 :	/* WORD aligned items */
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  220d74:	68fb      	ldr	r3, [r7, #12]
  220d76:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220d78:	68bb      	ldr	r3, [r7, #8]
  220d7a:	0a1b      	lsrs	r3, r3, #8
  220d7c:	4413      	add	r3, r2
  220d7e:	4619      	mov	r1, r3
  220d80:	68f8      	ldr	r0, [r7, #12]
  220d82:	f7ff fe0d 	bl	2209a0 <move_window>
  220d86:	4603      	mov	r3, r0
  220d88:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
  220d8a:	7ffb      	ldrb	r3, [r7, #31]
  220d8c:	2b00      	cmp	r3, #0
  220d8e:	d146      	bne.n	220e1e <put_fat+0x1be>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
  220d90:	68fb      	ldr	r3, [r7, #12]
  220d92:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220d96:	68bb      	ldr	r3, [r7, #8]
  220d98:	005b      	lsls	r3, r3, #1
  220d9a:	f403 73ff 	and.w	r3, r3, #510	; 0x1fe
  220d9e:	4413      	add	r3, r2
  220da0:	687a      	ldr	r2, [r7, #4]
  220da2:	b292      	uxth	r2, r2
  220da4:	4611      	mov	r1, r2
  220da6:	4618      	mov	r0, r3
  220da8:	f7ff fb55 	bl	220456 <st_word>
			fs->wflag = 1;
  220dac:	68fb      	ldr	r3, [r7, #12]
  220dae:	2201      	movs	r2, #1
  220db0:	70da      	strb	r2, [r3, #3]
			break;
  220db2:	e037      	b.n	220e24 <put_fat+0x1c4>

		case FS_FAT32 :	/* DWORD aligned items */
#if _FS_EXFAT
		case FS_EXFAT :
#endif
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  220db4:	68fb      	ldr	r3, [r7, #12]
  220db6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  220db8:	68bb      	ldr	r3, [r7, #8]
  220dba:	09db      	lsrs	r3, r3, #7
  220dbc:	4413      	add	r3, r2
  220dbe:	4619      	mov	r1, r3
  220dc0:	68f8      	ldr	r0, [r7, #12]
  220dc2:	f7ff fded 	bl	2209a0 <move_window>
  220dc6:	4603      	mov	r3, r0
  220dc8:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) break;
  220dca:	7ffb      	ldrb	r3, [r7, #31]
  220dcc:	2b00      	cmp	r3, #0
  220dce:	d128      	bne.n	220e22 <put_fat+0x1c2>
			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
  220dd0:	687b      	ldr	r3, [r7, #4]
  220dd2:	f023 4470 	bic.w	r4, r3, #4026531840	; 0xf0000000
  220dd6:	68fb      	ldr	r3, [r7, #12]
  220dd8:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220ddc:	68bb      	ldr	r3, [r7, #8]
  220dde:	009b      	lsls	r3, r3, #2
  220de0:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
  220de4:	4413      	add	r3, r2
  220de6:	4618      	mov	r0, r3
  220de8:	f7ff fb12 	bl	220410 <ld_dword>
  220dec:	4603      	mov	r3, r0
  220dee:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
  220df2:	4323      	orrs	r3, r4
  220df4:	607b      	str	r3, [r7, #4]
			}
			st_dword(fs->win + clst * 4 % SS(fs), val);
  220df6:	68fb      	ldr	r3, [r7, #12]
  220df8:	f103 0238 	add.w	r2, r3, #56	; 0x38
  220dfc:	68bb      	ldr	r3, [r7, #8]
  220dfe:	009b      	lsls	r3, r3, #2
  220e00:	f403 73fe 	and.w	r3, r3, #508	; 0x1fc
  220e04:	4413      	add	r3, r2
  220e06:	6879      	ldr	r1, [r7, #4]
  220e08:	4618      	mov	r0, r3
  220e0a:	f7ff fb3f 	bl	22048c <st_dword>
			fs->wflag = 1;
  220e0e:	68fb      	ldr	r3, [r7, #12]
  220e10:	2201      	movs	r2, #1
  220e12:	70da      	strb	r2, [r3, #3]
			break;
  220e14:	e006      	b.n	220e24 <put_fat+0x1c4>
			if (res != FR_OK) break;
  220e16:	bf00      	nop
  220e18:	e004      	b.n	220e24 <put_fat+0x1c4>
			if (res != FR_OK) break;
  220e1a:	bf00      	nop
  220e1c:	e002      	b.n	220e24 <put_fat+0x1c4>
			if (res != FR_OK) break;
  220e1e:	bf00      	nop
  220e20:	e000      	b.n	220e24 <put_fat+0x1c4>
			if (res != FR_OK) break;
  220e22:	bf00      	nop
		}
	}
	return res;
  220e24:	7ffb      	ldrb	r3, [r7, #31]
}
  220e26:	4618      	mov	r0, r3
  220e28:	3724      	adds	r7, #36	; 0x24
  220e2a:	46bd      	mov	sp, r7
  220e2c:	bd90      	pop	{r4, r7, pc}

00220e2e <remove_chain>:
FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
	_FDID* obj,			/* Corresponding object */
	DWORD clst,			/* Cluster to remove a chain from */
	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
)
{
  220e2e:	b580      	push	{r7, lr}
  220e30:	b088      	sub	sp, #32
  220e32:	af00      	add	r7, sp, #0
  220e34:	60f8      	str	r0, [r7, #12]
  220e36:	60b9      	str	r1, [r7, #8]
  220e38:	607a      	str	r2, [r7, #4]
	FRESULT res = FR_OK;
  220e3a:	2300      	movs	r3, #0
  220e3c:	77fb      	strb	r3, [r7, #31]
	DWORD nxt;
	FATFS *fs = obj->fs;
  220e3e:	68fb      	ldr	r3, [r7, #12]
  220e40:	681b      	ldr	r3, [r3, #0]
  220e42:	61bb      	str	r3, [r7, #24]
#endif
#if _USE_TRIM
	DWORD rt[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
  220e44:	68bb      	ldr	r3, [r7, #8]
  220e46:	2b01      	cmp	r3, #1
  220e48:	d904      	bls.n	220e54 <remove_chain+0x26>
  220e4a:	69bb      	ldr	r3, [r7, #24]
  220e4c:	69da      	ldr	r2, [r3, #28]
  220e4e:	68bb      	ldr	r3, [r7, #8]
  220e50:	429a      	cmp	r2, r3
  220e52:	d801      	bhi.n	220e58 <remove_chain+0x2a>
  220e54:	2302      	movs	r3, #2
  220e56:	e04b      	b.n	220ef0 <remove_chain+0xc2>

	/* Mark the previous cluster 'EOC' on the FAT if it exists */
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
  220e58:	687b      	ldr	r3, [r7, #4]
  220e5a:	2b00      	cmp	r3, #0
  220e5c:	d00c      	beq.n	220e78 <remove_chain+0x4a>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
  220e5e:	f04f 32ff 	mov.w	r2, #4294967295
  220e62:	6879      	ldr	r1, [r7, #4]
  220e64:	69b8      	ldr	r0, [r7, #24]
  220e66:	f7ff fefb 	bl	220c60 <put_fat>
  220e6a:	4603      	mov	r3, r0
  220e6c:	77fb      	strb	r3, [r7, #31]
		if (res != FR_OK) return res;
  220e6e:	7ffb      	ldrb	r3, [r7, #31]
  220e70:	2b00      	cmp	r3, #0
  220e72:	d001      	beq.n	220e78 <remove_chain+0x4a>
  220e74:	7ffb      	ldrb	r3, [r7, #31]
  220e76:	e03b      	b.n	220ef0 <remove_chain+0xc2>
	}

	/* Remove the chain */
	do {
		nxt = get_fat(obj, clst);			/* Get cluster status */
  220e78:	68b9      	ldr	r1, [r7, #8]
  220e7a:	68f8      	ldr	r0, [r7, #12]
  220e7c:	f7ff fe4b 	bl	220b16 <get_fat>
  220e80:	6178      	str	r0, [r7, #20]
		if (nxt == 0) break;				/* Empty cluster? */
  220e82:	697b      	ldr	r3, [r7, #20]
  220e84:	2b00      	cmp	r3, #0
  220e86:	d031      	beq.n	220eec <remove_chain+0xbe>
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
  220e88:	697b      	ldr	r3, [r7, #20]
  220e8a:	2b01      	cmp	r3, #1
  220e8c:	d101      	bne.n	220e92 <remove_chain+0x64>
  220e8e:	2302      	movs	r3, #2
  220e90:	e02e      	b.n	220ef0 <remove_chain+0xc2>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
  220e92:	697b      	ldr	r3, [r7, #20]
  220e94:	f1b3 3fff 	cmp.w	r3, #4294967295
  220e98:	d101      	bne.n	220e9e <remove_chain+0x70>
  220e9a:	2301      	movs	r3, #1
  220e9c:	e028      	b.n	220ef0 <remove_chain+0xc2>
		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
  220e9e:	2200      	movs	r2, #0
  220ea0:	68b9      	ldr	r1, [r7, #8]
  220ea2:	69b8      	ldr	r0, [r7, #24]
  220ea4:	f7ff fedc 	bl	220c60 <put_fat>
  220ea8:	4603      	mov	r3, r0
  220eaa:	77fb      	strb	r3, [r7, #31]
			if (res != FR_OK) return res;
  220eac:	7ffb      	ldrb	r3, [r7, #31]
  220eae:	2b00      	cmp	r3, #0
  220eb0:	d001      	beq.n	220eb6 <remove_chain+0x88>
  220eb2:	7ffb      	ldrb	r3, [r7, #31]
  220eb4:	e01c      	b.n	220ef0 <remove_chain+0xc2>
		}
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
  220eb6:	69bb      	ldr	r3, [r7, #24]
  220eb8:	699a      	ldr	r2, [r3, #24]
  220eba:	69bb      	ldr	r3, [r7, #24]
  220ebc:	69db      	ldr	r3, [r3, #28]
  220ebe:	3b02      	subs	r3, #2
  220ec0:	429a      	cmp	r2, r3
  220ec2:	d20b      	bcs.n	220edc <remove_chain+0xae>
			fs->free_clst++;
  220ec4:	69bb      	ldr	r3, [r7, #24]
  220ec6:	699b      	ldr	r3, [r3, #24]
  220ec8:	1c5a      	adds	r2, r3, #1
  220eca:	69bb      	ldr	r3, [r7, #24]
  220ecc:	619a      	str	r2, [r3, #24]
			fs->fsi_flag |= 1;
  220ece:	69bb      	ldr	r3, [r7, #24]
  220ed0:	791b      	ldrb	r3, [r3, #4]
  220ed2:	f043 0301 	orr.w	r3, r3, #1
  220ed6:	b2da      	uxtb	r2, r3
  220ed8:	69bb      	ldr	r3, [r7, #24]
  220eda:	711a      	strb	r2, [r3, #4]
			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
#endif
			scl = ecl = nxt;
		}
#endif
		clst = nxt;					/* Next cluster */
  220edc:	697b      	ldr	r3, [r7, #20]
  220ede:	60bb      	str	r3, [r7, #8]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
  220ee0:	69bb      	ldr	r3, [r7, #24]
  220ee2:	69da      	ldr	r2, [r3, #28]
  220ee4:	68bb      	ldr	r3, [r7, #8]
  220ee6:	429a      	cmp	r2, r3
  220ee8:	d8c6      	bhi.n	220e78 <remove_chain+0x4a>
  220eea:	e000      	b.n	220eee <remove_chain+0xc0>
		if (nxt == 0) break;				/* Empty cluster? */
  220eec:	bf00      	nop
				obj->stat = 2;	/* Change the object status 'contiguous' */
			}
		}
	}
#endif
	return FR_OK;
  220eee:	2300      	movs	r3, #0
}
  220ef0:	4618      	mov	r0, r3
  220ef2:	3720      	adds	r7, #32
  220ef4:	46bd      	mov	sp, r7
  220ef6:	bd80      	pop	{r7, pc}

00220ef8 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	_FDID* obj,			/* Corresponding object */
	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
)
{
  220ef8:	b580      	push	{r7, lr}
  220efa:	b088      	sub	sp, #32
  220efc:	af00      	add	r7, sp, #0
  220efe:	6078      	str	r0, [r7, #4]
  220f00:	6039      	str	r1, [r7, #0]
	DWORD cs, ncl, scl;
	FRESULT res;
	FATFS *fs = obj->fs;
  220f02:	687b      	ldr	r3, [r7, #4]
  220f04:	681b      	ldr	r3, [r3, #0]
  220f06:	613b      	str	r3, [r7, #16]


	if (clst == 0) {	/* Create a new chain */
  220f08:	683b      	ldr	r3, [r7, #0]
  220f0a:	2b00      	cmp	r3, #0
  220f0c:	d10d      	bne.n	220f2a <create_chain+0x32>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
  220f0e:	693b      	ldr	r3, [r7, #16]
  220f10:	695b      	ldr	r3, [r3, #20]
  220f12:	61bb      	str	r3, [r7, #24]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
  220f14:	69bb      	ldr	r3, [r7, #24]
  220f16:	2b00      	cmp	r3, #0
  220f18:	d004      	beq.n	220f24 <create_chain+0x2c>
  220f1a:	693b      	ldr	r3, [r7, #16]
  220f1c:	69da      	ldr	r2, [r3, #28]
  220f1e:	69bb      	ldr	r3, [r7, #24]
  220f20:	429a      	cmp	r2, r3
  220f22:	d81b      	bhi.n	220f5c <create_chain+0x64>
  220f24:	2301      	movs	r3, #1
  220f26:	61bb      	str	r3, [r7, #24]
  220f28:	e018      	b.n	220f5c <create_chain+0x64>
	}
	else {				/* Stretch current chain */
		cs = get_fat(obj, clst);			/* Check the cluster status */
  220f2a:	6839      	ldr	r1, [r7, #0]
  220f2c:	6878      	ldr	r0, [r7, #4]
  220f2e:	f7ff fdf2 	bl	220b16 <get_fat>
  220f32:	60f8      	str	r0, [r7, #12]
		if (cs < 2) return 1;				/* Invalid FAT value */
  220f34:	68fb      	ldr	r3, [r7, #12]
  220f36:	2b01      	cmp	r3, #1
  220f38:	d801      	bhi.n	220f3e <create_chain+0x46>
  220f3a:	2301      	movs	r3, #1
  220f3c:	e070      	b.n	221020 <create_chain+0x128>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
  220f3e:	68fb      	ldr	r3, [r7, #12]
  220f40:	f1b3 3fff 	cmp.w	r3, #4294967295
  220f44:	d101      	bne.n	220f4a <create_chain+0x52>
  220f46:	68fb      	ldr	r3, [r7, #12]
  220f48:	e06a      	b.n	221020 <create_chain+0x128>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  220f4a:	693b      	ldr	r3, [r7, #16]
  220f4c:	69da      	ldr	r2, [r3, #28]
  220f4e:	68fb      	ldr	r3, [r7, #12]
  220f50:	429a      	cmp	r2, r3
  220f52:	d901      	bls.n	220f58 <create_chain+0x60>
  220f54:	68fb      	ldr	r3, [r7, #12]
  220f56:	e063      	b.n	221020 <create_chain+0x128>
		scl = clst;
  220f58:	683b      	ldr	r3, [r7, #0]
  220f5a:	61bb      	str	r3, [r7, #24]
			}
		}
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		ncl = scl;	/* Start cluster */
  220f5c:	69bb      	ldr	r3, [r7, #24]
  220f5e:	61fb      	str	r3, [r7, #28]
		for (;;) {
			ncl++;							/* Next cluster */
  220f60:	69fb      	ldr	r3, [r7, #28]
  220f62:	3301      	adds	r3, #1
  220f64:	61fb      	str	r3, [r7, #28]
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
  220f66:	693b      	ldr	r3, [r7, #16]
  220f68:	69da      	ldr	r2, [r3, #28]
  220f6a:	69fb      	ldr	r3, [r7, #28]
  220f6c:	429a      	cmp	r2, r3
  220f6e:	d807      	bhi.n	220f80 <create_chain+0x88>
				ncl = 2;
  220f70:	2302      	movs	r3, #2
  220f72:	61fb      	str	r3, [r7, #28]
				if (ncl > scl) return 0;	/* No free cluster */
  220f74:	69fa      	ldr	r2, [r7, #28]
  220f76:	69bb      	ldr	r3, [r7, #24]
  220f78:	429a      	cmp	r2, r3
  220f7a:	d901      	bls.n	220f80 <create_chain+0x88>
  220f7c:	2300      	movs	r3, #0
  220f7e:	e04f      	b.n	221020 <create_chain+0x128>
			}
			cs = get_fat(obj, ncl);			/* Get the cluster status */
  220f80:	69f9      	ldr	r1, [r7, #28]
  220f82:	6878      	ldr	r0, [r7, #4]
  220f84:	f7ff fdc7 	bl	220b16 <get_fat>
  220f88:	60f8      	str	r0, [r7, #12]
			if (cs == 0) break;				/* Found a free cluster */
  220f8a:	68fb      	ldr	r3, [r7, #12]
  220f8c:	2b00      	cmp	r3, #0
  220f8e:	d00e      	beq.n	220fae <create_chain+0xb6>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
  220f90:	68fb      	ldr	r3, [r7, #12]
  220f92:	2b01      	cmp	r3, #1
  220f94:	d003      	beq.n	220f9e <create_chain+0xa6>
  220f96:	68fb      	ldr	r3, [r7, #12]
  220f98:	f1b3 3fff 	cmp.w	r3, #4294967295
  220f9c:	d101      	bne.n	220fa2 <create_chain+0xaa>
  220f9e:	68fb      	ldr	r3, [r7, #12]
  220fa0:	e03e      	b.n	221020 <create_chain+0x128>
			if (ncl == scl) return 0;		/* No free cluster */
  220fa2:	69fa      	ldr	r2, [r7, #28]
  220fa4:	69bb      	ldr	r3, [r7, #24]
  220fa6:	429a      	cmp	r2, r3
  220fa8:	d1da      	bne.n	220f60 <create_chain+0x68>
  220faa:	2300      	movs	r3, #0
  220fac:	e038      	b.n	221020 <create_chain+0x128>
			if (cs == 0) break;				/* Found a free cluster */
  220fae:	bf00      	nop
		}
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
  220fb0:	f04f 32ff 	mov.w	r2, #4294967295
  220fb4:	69f9      	ldr	r1, [r7, #28]
  220fb6:	6938      	ldr	r0, [r7, #16]
  220fb8:	f7ff fe52 	bl	220c60 <put_fat>
  220fbc:	4603      	mov	r3, r0
  220fbe:	75fb      	strb	r3, [r7, #23]
		if (res == FR_OK && clst != 0) {
  220fc0:	7dfb      	ldrb	r3, [r7, #23]
  220fc2:	2b00      	cmp	r3, #0
  220fc4:	d109      	bne.n	220fda <create_chain+0xe2>
  220fc6:	683b      	ldr	r3, [r7, #0]
  220fc8:	2b00      	cmp	r3, #0
  220fca:	d006      	beq.n	220fda <create_chain+0xe2>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
  220fcc:	69fa      	ldr	r2, [r7, #28]
  220fce:	6839      	ldr	r1, [r7, #0]
  220fd0:	6938      	ldr	r0, [r7, #16]
  220fd2:	f7ff fe45 	bl	220c60 <put_fat>
  220fd6:	4603      	mov	r3, r0
  220fd8:	75fb      	strb	r3, [r7, #23]
		}
	}

	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
  220fda:	7dfb      	ldrb	r3, [r7, #23]
  220fdc:	2b00      	cmp	r3, #0
  220fde:	d116      	bne.n	22100e <create_chain+0x116>
		fs->last_clst = ncl;
  220fe0:	693b      	ldr	r3, [r7, #16]
  220fe2:	69fa      	ldr	r2, [r7, #28]
  220fe4:	615a      	str	r2, [r3, #20]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
  220fe6:	693b      	ldr	r3, [r7, #16]
  220fe8:	699a      	ldr	r2, [r3, #24]
  220fea:	693b      	ldr	r3, [r7, #16]
  220fec:	69db      	ldr	r3, [r3, #28]
  220fee:	3b02      	subs	r3, #2
  220ff0:	429a      	cmp	r2, r3
  220ff2:	d804      	bhi.n	220ffe <create_chain+0x106>
  220ff4:	693b      	ldr	r3, [r7, #16]
  220ff6:	699b      	ldr	r3, [r3, #24]
  220ff8:	1e5a      	subs	r2, r3, #1
  220ffa:	693b      	ldr	r3, [r7, #16]
  220ffc:	619a      	str	r2, [r3, #24]
		fs->fsi_flag |= 1;
  220ffe:	693b      	ldr	r3, [r7, #16]
  221000:	791b      	ldrb	r3, [r3, #4]
  221002:	f043 0301 	orr.w	r3, r3, #1
  221006:	b2da      	uxtb	r2, r3
  221008:	693b      	ldr	r3, [r7, #16]
  22100a:	711a      	strb	r2, [r3, #4]
  22100c:	e007      	b.n	22101e <create_chain+0x126>
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
  22100e:	7dfb      	ldrb	r3, [r7, #23]
  221010:	2b01      	cmp	r3, #1
  221012:	d102      	bne.n	22101a <create_chain+0x122>
  221014:	f04f 33ff 	mov.w	r3, #4294967295
  221018:	e000      	b.n	22101c <create_chain+0x124>
  22101a:	2301      	movs	r3, #1
  22101c:	61fb      	str	r3, [r7, #28]
	}

	return ncl;		/* Return new cluster number or error status */
  22101e:	69fb      	ldr	r3, [r7, #28]
}
  221020:	4618      	mov	r0, r3
  221022:	3720      	adds	r7, #32
  221024:	46bd      	mov	sp, r7
  221026:	bd80      	pop	{r7, pc}

00221028 <clmt_clust>:
static
DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File offset to be converted to cluster# */
)
{
  221028:	b480      	push	{r7}
  22102a:	b087      	sub	sp, #28
  22102c:	af00      	add	r7, sp, #0
  22102e:	6078      	str	r0, [r7, #4]
  221030:	6039      	str	r1, [r7, #0]
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;
  221032:	687b      	ldr	r3, [r7, #4]
  221034:	681b      	ldr	r3, [r3, #0]
  221036:	60fb      	str	r3, [r7, #12]


	tbl = fp->cltbl + 1;	/* Top of CLMT */
  221038:	687b      	ldr	r3, [r7, #4]
  22103a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22103c:	3304      	adds	r3, #4
  22103e:	613b      	str	r3, [r7, #16]
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
  221040:	683b      	ldr	r3, [r7, #0]
  221042:	0a5b      	lsrs	r3, r3, #9
  221044:	68fa      	ldr	r2, [r7, #12]
  221046:	8952      	ldrh	r2, [r2, #10]
  221048:	fbb3 f3f2 	udiv	r3, r3, r2
  22104c:	617b      	str	r3, [r7, #20]
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
  22104e:	693b      	ldr	r3, [r7, #16]
  221050:	1d1a      	adds	r2, r3, #4
  221052:	613a      	str	r2, [r7, #16]
  221054:	681b      	ldr	r3, [r3, #0]
  221056:	60bb      	str	r3, [r7, #8]
		if (ncl == 0) return 0;	/* End of table? (error) */
  221058:	68bb      	ldr	r3, [r7, #8]
  22105a:	2b00      	cmp	r3, #0
  22105c:	d101      	bne.n	221062 <clmt_clust+0x3a>
  22105e:	2300      	movs	r3, #0
  221060:	e010      	b.n	221084 <clmt_clust+0x5c>
		if (cl < ncl) break;	/* In this fragment? */
  221062:	697a      	ldr	r2, [r7, #20]
  221064:	68bb      	ldr	r3, [r7, #8]
  221066:	429a      	cmp	r2, r3
  221068:	d307      	bcc.n	22107a <clmt_clust+0x52>
		cl -= ncl; tbl++;		/* Next fragment */
  22106a:	697a      	ldr	r2, [r7, #20]
  22106c:	68bb      	ldr	r3, [r7, #8]
  22106e:	1ad3      	subs	r3, r2, r3
  221070:	617b      	str	r3, [r7, #20]
  221072:	693b      	ldr	r3, [r7, #16]
  221074:	3304      	adds	r3, #4
  221076:	613b      	str	r3, [r7, #16]
		ncl = *tbl++;			/* Number of cluters in the fragment */
  221078:	e7e9      	b.n	22104e <clmt_clust+0x26>
		if (cl < ncl) break;	/* In this fragment? */
  22107a:	bf00      	nop
	}
	return cl + *tbl;	/* Return the cluster number */
  22107c:	693b      	ldr	r3, [r7, #16]
  22107e:	681a      	ldr	r2, [r3, #0]
  221080:	697b      	ldr	r3, [r7, #20]
  221082:	4413      	add	r3, r2
}
  221084:	4618      	mov	r0, r3
  221086:	371c      	adds	r7, #28
  221088:	46bd      	mov	sp, r7
  22108a:	f85d 7b04 	ldr.w	r7, [sp], #4
  22108e:	4770      	bx	lr

00221090 <dir_sdi>:
static
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to directory object */
	DWORD ofs		/* Offset of directory table */
)
{
  221090:	b580      	push	{r7, lr}
  221092:	b086      	sub	sp, #24
  221094:	af00      	add	r7, sp, #0
  221096:	6078      	str	r0, [r7, #4]
  221098:	6039      	str	r1, [r7, #0]
	DWORD csz, clst;
	FATFS *fs = dp->obj.fs;
  22109a:	687b      	ldr	r3, [r7, #4]
  22109c:	681b      	ldr	r3, [r3, #0]
  22109e:	613b      	str	r3, [r7, #16]


	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
  2210a0:	683b      	ldr	r3, [r7, #0]
  2210a2:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
  2210a6:	d204      	bcs.n	2210b2 <dir_sdi+0x22>
  2210a8:	683b      	ldr	r3, [r7, #0]
  2210aa:	f003 031f 	and.w	r3, r3, #31
  2210ae:	2b00      	cmp	r3, #0
  2210b0:	d001      	beq.n	2210b6 <dir_sdi+0x26>
		return FR_INT_ERR;
  2210b2:	2302      	movs	r3, #2
  2210b4:	e063      	b.n	22117e <dir_sdi+0xee>
	}
	dp->dptr = ofs;				/* Set current offset */
  2210b6:	687b      	ldr	r3, [r7, #4]
  2210b8:	683a      	ldr	r2, [r7, #0]
  2210ba:	615a      	str	r2, [r3, #20]
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
  2210bc:	687b      	ldr	r3, [r7, #4]
  2210be:	689b      	ldr	r3, [r3, #8]
  2210c0:	617b      	str	r3, [r7, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
  2210c2:	697b      	ldr	r3, [r7, #20]
  2210c4:	2b00      	cmp	r3, #0
  2210c6:	d106      	bne.n	2210d6 <dir_sdi+0x46>
  2210c8:	693b      	ldr	r3, [r7, #16]
  2210ca:	781b      	ldrb	r3, [r3, #0]
  2210cc:	2b02      	cmp	r3, #2
  2210ce:	d902      	bls.n	2210d6 <dir_sdi+0x46>
		clst = fs->dirbase;
  2210d0:	693b      	ldr	r3, [r7, #16]
  2210d2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2210d4:	617b      	str	r3, [r7, #20]
		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
	}

	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
  2210d6:	697b      	ldr	r3, [r7, #20]
  2210d8:	2b00      	cmp	r3, #0
  2210da:	d10c      	bne.n	2210f6 <dir_sdi+0x66>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
  2210dc:	683b      	ldr	r3, [r7, #0]
  2210de:	095b      	lsrs	r3, r3, #5
  2210e0:	693a      	ldr	r2, [r7, #16]
  2210e2:	8912      	ldrh	r2, [r2, #8]
  2210e4:	4293      	cmp	r3, r2
  2210e6:	d301      	bcc.n	2210ec <dir_sdi+0x5c>
  2210e8:	2302      	movs	r3, #2
  2210ea:	e048      	b.n	22117e <dir_sdi+0xee>
		dp->sect = fs->dirbase;
  2210ec:	693b      	ldr	r3, [r7, #16]
  2210ee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2210f0:	687b      	ldr	r3, [r7, #4]
  2210f2:	61da      	str	r2, [r3, #28]
  2210f4:	e029      	b.n	22114a <dir_sdi+0xba>

	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
  2210f6:	693b      	ldr	r3, [r7, #16]
  2210f8:	895b      	ldrh	r3, [r3, #10]
  2210fa:	025b      	lsls	r3, r3, #9
  2210fc:	60fb      	str	r3, [r7, #12]
		while (ofs >= csz) {				/* Follow cluster chain */
  2210fe:	e019      	b.n	221134 <dir_sdi+0xa4>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
  221100:	687b      	ldr	r3, [r7, #4]
  221102:	6979      	ldr	r1, [r7, #20]
  221104:	4618      	mov	r0, r3
  221106:	f7ff fd06 	bl	220b16 <get_fat>
  22110a:	6178      	str	r0, [r7, #20]
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  22110c:	697b      	ldr	r3, [r7, #20]
  22110e:	f1b3 3fff 	cmp.w	r3, #4294967295
  221112:	d101      	bne.n	221118 <dir_sdi+0x88>
  221114:	2301      	movs	r3, #1
  221116:	e032      	b.n	22117e <dir_sdi+0xee>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
  221118:	697b      	ldr	r3, [r7, #20]
  22111a:	2b01      	cmp	r3, #1
  22111c:	d904      	bls.n	221128 <dir_sdi+0x98>
  22111e:	693b      	ldr	r3, [r7, #16]
  221120:	69da      	ldr	r2, [r3, #28]
  221122:	697b      	ldr	r3, [r7, #20]
  221124:	429a      	cmp	r2, r3
  221126:	d801      	bhi.n	22112c <dir_sdi+0x9c>
  221128:	2302      	movs	r3, #2
  22112a:	e028      	b.n	22117e <dir_sdi+0xee>
			ofs -= csz;
  22112c:	683a      	ldr	r2, [r7, #0]
  22112e:	68fb      	ldr	r3, [r7, #12]
  221130:	1ad3      	subs	r3, r2, r3
  221132:	603b      	str	r3, [r7, #0]
		while (ofs >= csz) {				/* Follow cluster chain */
  221134:	683a      	ldr	r2, [r7, #0]
  221136:	68fb      	ldr	r3, [r7, #12]
  221138:	429a      	cmp	r2, r3
  22113a:	d2e1      	bcs.n	221100 <dir_sdi+0x70>
		}
		dp->sect = clust2sect(fs, clst);
  22113c:	6979      	ldr	r1, [r7, #20]
  22113e:	6938      	ldr	r0, [r7, #16]
  221140:	f7ff fcca 	bl	220ad8 <clust2sect>
  221144:	4602      	mov	r2, r0
  221146:	687b      	ldr	r3, [r7, #4]
  221148:	61da      	str	r2, [r3, #28]
	}
	dp->clust = clst;					/* Current cluster# */
  22114a:	687b      	ldr	r3, [r7, #4]
  22114c:	697a      	ldr	r2, [r7, #20]
  22114e:	619a      	str	r2, [r3, #24]
	if (!dp->sect) return FR_INT_ERR;
  221150:	687b      	ldr	r3, [r7, #4]
  221152:	69db      	ldr	r3, [r3, #28]
  221154:	2b00      	cmp	r3, #0
  221156:	d101      	bne.n	22115c <dir_sdi+0xcc>
  221158:	2302      	movs	r3, #2
  22115a:	e010      	b.n	22117e <dir_sdi+0xee>
	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
  22115c:	687b      	ldr	r3, [r7, #4]
  22115e:	69da      	ldr	r2, [r3, #28]
  221160:	683b      	ldr	r3, [r7, #0]
  221162:	0a5b      	lsrs	r3, r3, #9
  221164:	441a      	add	r2, r3
  221166:	687b      	ldr	r3, [r7, #4]
  221168:	61da      	str	r2, [r3, #28]
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
  22116a:	693b      	ldr	r3, [r7, #16]
  22116c:	f103 0238 	add.w	r2, r3, #56	; 0x38
  221170:	683b      	ldr	r3, [r7, #0]
  221172:	f3c3 0308 	ubfx	r3, r3, #0, #9
  221176:	441a      	add	r2, r3
  221178:	687b      	ldr	r3, [r7, #4]
  22117a:	621a      	str	r2, [r3, #32]

	return FR_OK;
  22117c:	2300      	movs	r3, #0
}
  22117e:	4618      	mov	r0, r3
  221180:	3718      	adds	r7, #24
  221182:	46bd      	mov	sp, r7
  221184:	bd80      	pop	{r7, pc}

00221186 <dir_next>:
static
FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
	DIR* dp,		/* Pointer to the directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  221186:	b580      	push	{r7, lr}
  221188:	b086      	sub	sp, #24
  22118a:	af00      	add	r7, sp, #0
  22118c:	6078      	str	r0, [r7, #4]
  22118e:	6039      	str	r1, [r7, #0]
	DWORD ofs, clst;
	FATFS *fs = dp->obj.fs;
  221190:	687b      	ldr	r3, [r7, #4]
  221192:	681b      	ldr	r3, [r3, #0]
  221194:	60fb      	str	r3, [r7, #12]
#if !_FS_READONLY
	UINT n;
#endif

	ofs = dp->dptr + SZDIRE;	/* Next entry */
  221196:	687b      	ldr	r3, [r7, #4]
  221198:	695b      	ldr	r3, [r3, #20]
  22119a:	3320      	adds	r3, #32
  22119c:	60bb      	str	r3, [r7, #8]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
  22119e:	687b      	ldr	r3, [r7, #4]
  2211a0:	69db      	ldr	r3, [r3, #28]
  2211a2:	2b00      	cmp	r3, #0
  2211a4:	d003      	beq.n	2211ae <dir_next+0x28>
  2211a6:	68bb      	ldr	r3, [r7, #8]
  2211a8:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
  2211ac:	d301      	bcc.n	2211b2 <dir_next+0x2c>
  2211ae:	2304      	movs	r3, #4
  2211b0:	e0aa      	b.n	221308 <dir_next+0x182>

	if (ofs % SS(fs) == 0) {	/* Sector changed? */
  2211b2:	68bb      	ldr	r3, [r7, #8]
  2211b4:	f3c3 0308 	ubfx	r3, r3, #0, #9
  2211b8:	2b00      	cmp	r3, #0
  2211ba:	f040 8098 	bne.w	2212ee <dir_next+0x168>
		dp->sect++;				/* Next sector */
  2211be:	687b      	ldr	r3, [r7, #4]
  2211c0:	69db      	ldr	r3, [r3, #28]
  2211c2:	1c5a      	adds	r2, r3, #1
  2211c4:	687b      	ldr	r3, [r7, #4]
  2211c6:	61da      	str	r2, [r3, #28]

		if (!dp->clust) {		/* Static table */
  2211c8:	687b      	ldr	r3, [r7, #4]
  2211ca:	699b      	ldr	r3, [r3, #24]
  2211cc:	2b00      	cmp	r3, #0
  2211ce:	d10b      	bne.n	2211e8 <dir_next+0x62>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
  2211d0:	68bb      	ldr	r3, [r7, #8]
  2211d2:	095b      	lsrs	r3, r3, #5
  2211d4:	68fa      	ldr	r2, [r7, #12]
  2211d6:	8912      	ldrh	r2, [r2, #8]
  2211d8:	4293      	cmp	r3, r2
  2211da:	f0c0 8088 	bcc.w	2212ee <dir_next+0x168>
				dp->sect = 0; return FR_NO_FILE;
  2211de:	687b      	ldr	r3, [r7, #4]
  2211e0:	2200      	movs	r2, #0
  2211e2:	61da      	str	r2, [r3, #28]
  2211e4:	2304      	movs	r3, #4
  2211e6:	e08f      	b.n	221308 <dir_next+0x182>
			}
		}
		else {					/* Dynamic table */
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
  2211e8:	68bb      	ldr	r3, [r7, #8]
  2211ea:	0a5b      	lsrs	r3, r3, #9
  2211ec:	68fa      	ldr	r2, [r7, #12]
  2211ee:	8952      	ldrh	r2, [r2, #10]
  2211f0:	3a01      	subs	r2, #1
  2211f2:	4013      	ands	r3, r2
  2211f4:	2b00      	cmp	r3, #0
  2211f6:	d17a      	bne.n	2212ee <dir_next+0x168>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
  2211f8:	687a      	ldr	r2, [r7, #4]
  2211fa:	687b      	ldr	r3, [r7, #4]
  2211fc:	699b      	ldr	r3, [r3, #24]
  2211fe:	4619      	mov	r1, r3
  221200:	4610      	mov	r0, r2
  221202:	f7ff fc88 	bl	220b16 <get_fat>
  221206:	6178      	str	r0, [r7, #20]
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
  221208:	697b      	ldr	r3, [r7, #20]
  22120a:	2b01      	cmp	r3, #1
  22120c:	d801      	bhi.n	221212 <dir_next+0x8c>
  22120e:	2302      	movs	r3, #2
  221210:	e07a      	b.n	221308 <dir_next+0x182>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
  221212:	697b      	ldr	r3, [r7, #20]
  221214:	f1b3 3fff 	cmp.w	r3, #4294967295
  221218:	d101      	bne.n	22121e <dir_next+0x98>
  22121a:	2301      	movs	r3, #1
  22121c:	e074      	b.n	221308 <dir_next+0x182>
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
  22121e:	68fb      	ldr	r3, [r7, #12]
  221220:	69da      	ldr	r2, [r3, #28]
  221222:	697b      	ldr	r3, [r7, #20]
  221224:	429a      	cmp	r2, r3
  221226:	d858      	bhi.n	2212da <dir_next+0x154>
#if !_FS_READONLY
					if (!stretch) {								/* If no stretch, report EOT */
  221228:	683b      	ldr	r3, [r7, #0]
  22122a:	2b00      	cmp	r3, #0
  22122c:	d104      	bne.n	221238 <dir_next+0xb2>
						dp->sect = 0; return FR_NO_FILE;
  22122e:	687b      	ldr	r3, [r7, #4]
  221230:	2200      	movs	r2, #0
  221232:	61da      	str	r2, [r3, #28]
  221234:	2304      	movs	r3, #4
  221236:	e067      	b.n	221308 <dir_next+0x182>
					}
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
  221238:	687a      	ldr	r2, [r7, #4]
  22123a:	687b      	ldr	r3, [r7, #4]
  22123c:	699b      	ldr	r3, [r3, #24]
  22123e:	4619      	mov	r1, r3
  221240:	4610      	mov	r0, r2
  221242:	f7ff fe59 	bl	220ef8 <create_chain>
  221246:	6178      	str	r0, [r7, #20]
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  221248:	697b      	ldr	r3, [r7, #20]
  22124a:	2b00      	cmp	r3, #0
  22124c:	d101      	bne.n	221252 <dir_next+0xcc>
  22124e:	2307      	movs	r3, #7
  221250:	e05a      	b.n	221308 <dir_next+0x182>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
  221252:	697b      	ldr	r3, [r7, #20]
  221254:	2b01      	cmp	r3, #1
  221256:	d101      	bne.n	22125c <dir_next+0xd6>
  221258:	2302      	movs	r3, #2
  22125a:	e055      	b.n	221308 <dir_next+0x182>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  22125c:	697b      	ldr	r3, [r7, #20]
  22125e:	f1b3 3fff 	cmp.w	r3, #4294967295
  221262:	d101      	bne.n	221268 <dir_next+0xe2>
  221264:	2301      	movs	r3, #1
  221266:	e04f      	b.n	221308 <dir_next+0x182>
					/* Clean-up the stretched table */
					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
  221268:	68f8      	ldr	r0, [r7, #12]
  22126a:	f7ff fb55 	bl	220918 <sync_window>
  22126e:	4603      	mov	r3, r0
  221270:	2b00      	cmp	r3, #0
  221272:	d001      	beq.n	221278 <dir_next+0xf2>
  221274:	2301      	movs	r3, #1
  221276:	e047      	b.n	221308 <dir_next+0x182>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
  221278:	68fb      	ldr	r3, [r7, #12]
  22127a:	3338      	adds	r3, #56	; 0x38
  22127c:	f44f 7200 	mov.w	r2, #512	; 0x200
  221280:	2100      	movs	r1, #0
  221282:	4618      	mov	r0, r3
  221284:	f7ff f94f 	bl	220526 <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
  221288:	2300      	movs	r3, #0
  22128a:	613b      	str	r3, [r7, #16]
  22128c:	6979      	ldr	r1, [r7, #20]
  22128e:	68f8      	ldr	r0, [r7, #12]
  221290:	f7ff fc22 	bl	220ad8 <clust2sect>
  221294:	4602      	mov	r2, r0
  221296:	68fb      	ldr	r3, [r7, #12]
  221298:	635a      	str	r2, [r3, #52]	; 0x34
  22129a:	e012      	b.n	2212c2 <dir_next+0x13c>
						fs->wflag = 1;
  22129c:	68fb      	ldr	r3, [r7, #12]
  22129e:	2201      	movs	r2, #1
  2212a0:	70da      	strb	r2, [r3, #3]
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
  2212a2:	68f8      	ldr	r0, [r7, #12]
  2212a4:	f7ff fb38 	bl	220918 <sync_window>
  2212a8:	4603      	mov	r3, r0
  2212aa:	2b00      	cmp	r3, #0
  2212ac:	d001      	beq.n	2212b2 <dir_next+0x12c>
  2212ae:	2301      	movs	r3, #1
  2212b0:	e02a      	b.n	221308 <dir_next+0x182>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
  2212b2:	693b      	ldr	r3, [r7, #16]
  2212b4:	3301      	adds	r3, #1
  2212b6:	613b      	str	r3, [r7, #16]
  2212b8:	68fb      	ldr	r3, [r7, #12]
  2212ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  2212bc:	1c5a      	adds	r2, r3, #1
  2212be:	68fb      	ldr	r3, [r7, #12]
  2212c0:	635a      	str	r2, [r3, #52]	; 0x34
  2212c2:	68fb      	ldr	r3, [r7, #12]
  2212c4:	895b      	ldrh	r3, [r3, #10]
  2212c6:	461a      	mov	r2, r3
  2212c8:	693b      	ldr	r3, [r7, #16]
  2212ca:	429a      	cmp	r2, r3
  2212cc:	d8e6      	bhi.n	22129c <dir_next+0x116>
					}
					fs->winsect -= n;							/* Restore window offset */
  2212ce:	68fb      	ldr	r3, [r7, #12]
  2212d0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  2212d2:	693b      	ldr	r3, [r7, #16]
  2212d4:	1ad2      	subs	r2, r2, r3
  2212d6:	68fb      	ldr	r3, [r7, #12]
  2212d8:	635a      	str	r2, [r3, #52]	; 0x34
#else
					if (!stretch) dp->sect = 0;					/* (this line is to suppress compiler warning) */
					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dp->clust = clst;		/* Initialize data for new cluster */
  2212da:	687b      	ldr	r3, [r7, #4]
  2212dc:	697a      	ldr	r2, [r7, #20]
  2212de:	619a      	str	r2, [r3, #24]
				dp->sect = clust2sect(fs, clst);
  2212e0:	6979      	ldr	r1, [r7, #20]
  2212e2:	68f8      	ldr	r0, [r7, #12]
  2212e4:	f7ff fbf8 	bl	220ad8 <clust2sect>
  2212e8:	4602      	mov	r2, r0
  2212ea:	687b      	ldr	r3, [r7, #4]
  2212ec:	61da      	str	r2, [r3, #28]
			}
		}
	}
	dp->dptr = ofs;						/* Current entry */
  2212ee:	687b      	ldr	r3, [r7, #4]
  2212f0:	68ba      	ldr	r2, [r7, #8]
  2212f2:	615a      	str	r2, [r3, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
  2212f4:	68fb      	ldr	r3, [r7, #12]
  2212f6:	f103 0238 	add.w	r2, r3, #56	; 0x38
  2212fa:	68bb      	ldr	r3, [r7, #8]
  2212fc:	f3c3 0308 	ubfx	r3, r3, #0, #9
  221300:	441a      	add	r2, r3
  221302:	687b      	ldr	r3, [r7, #4]
  221304:	621a      	str	r2, [r3, #32]

	return FR_OK;
  221306:	2300      	movs	r3, #0
}
  221308:	4618      	mov	r0, r3
  22130a:	3718      	adds	r7, #24
  22130c:	46bd      	mov	sp, r7
  22130e:	bd80      	pop	{r7, pc}

00221310 <dir_alloc>:
static
FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp,		/* Pointer to the directory object */
	UINT nent		/* Number of contiguous entries to allocate */
)
{
  221310:	b580      	push	{r7, lr}
  221312:	b086      	sub	sp, #24
  221314:	af00      	add	r7, sp, #0
  221316:	6078      	str	r0, [r7, #4]
  221318:	6039      	str	r1, [r7, #0]
	FRESULT res;
	UINT n;
	FATFS *fs = dp->obj.fs;
  22131a:	687b      	ldr	r3, [r7, #4]
  22131c:	681b      	ldr	r3, [r3, #0]
  22131e:	60fb      	str	r3, [r7, #12]


	res = dir_sdi(dp, 0);
  221320:	2100      	movs	r1, #0
  221322:	6878      	ldr	r0, [r7, #4]
  221324:	f7ff feb4 	bl	221090 <dir_sdi>
  221328:	4603      	mov	r3, r0
  22132a:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
  22132c:	7dfb      	ldrb	r3, [r7, #23]
  22132e:	2b00      	cmp	r3, #0
  221330:	d12b      	bne.n	22138a <dir_alloc+0x7a>
		n = 0;
  221332:	2300      	movs	r3, #0
  221334:	613b      	str	r3, [r7, #16]
		do {
			res = move_window(fs, dp->sect);
  221336:	687b      	ldr	r3, [r7, #4]
  221338:	69db      	ldr	r3, [r3, #28]
  22133a:	4619      	mov	r1, r3
  22133c:	68f8      	ldr	r0, [r7, #12]
  22133e:	f7ff fb2f 	bl	2209a0 <move_window>
  221342:	4603      	mov	r3, r0
  221344:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
  221346:	7dfb      	ldrb	r3, [r7, #23]
  221348:	2b00      	cmp	r3, #0
  22134a:	d11d      	bne.n	221388 <dir_alloc+0x78>
#if _FS_EXFAT
			if ((fs->fs_type == FS_EXFAT) ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
#else
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
  22134c:	687b      	ldr	r3, [r7, #4]
  22134e:	6a1b      	ldr	r3, [r3, #32]
  221350:	781b      	ldrb	r3, [r3, #0]
  221352:	2be5      	cmp	r3, #229	; 0xe5
  221354:	d004      	beq.n	221360 <dir_alloc+0x50>
  221356:	687b      	ldr	r3, [r7, #4]
  221358:	6a1b      	ldr	r3, [r3, #32]
  22135a:	781b      	ldrb	r3, [r3, #0]
  22135c:	2b00      	cmp	r3, #0
  22135e:	d107      	bne.n	221370 <dir_alloc+0x60>
#endif
				if (++n == nent) break;	/* A block of contiguous free entries is found */
  221360:	693b      	ldr	r3, [r7, #16]
  221362:	3301      	adds	r3, #1
  221364:	613b      	str	r3, [r7, #16]
  221366:	693a      	ldr	r2, [r7, #16]
  221368:	683b      	ldr	r3, [r7, #0]
  22136a:	429a      	cmp	r2, r3
  22136c:	d102      	bne.n	221374 <dir_alloc+0x64>
  22136e:	e00c      	b.n	22138a <dir_alloc+0x7a>
			} else {
				n = 0;					/* Not a blank entry. Restart to search */
  221370:	2300      	movs	r3, #0
  221372:	613b      	str	r3, [r7, #16]
			}
			res = dir_next(dp, 1);
  221374:	2101      	movs	r1, #1
  221376:	6878      	ldr	r0, [r7, #4]
  221378:	f7ff ff05 	bl	221186 <dir_next>
  22137c:	4603      	mov	r3, r0
  22137e:	75fb      	strb	r3, [r7, #23]
		} while (res == FR_OK);	/* Next entry with table stretch enabled */
  221380:	7dfb      	ldrb	r3, [r7, #23]
  221382:	2b00      	cmp	r3, #0
  221384:	d0d7      	beq.n	221336 <dir_alloc+0x26>
  221386:	e000      	b.n	22138a <dir_alloc+0x7a>
			if (res != FR_OK) break;
  221388:	bf00      	nop
	}

	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
  22138a:	7dfb      	ldrb	r3, [r7, #23]
  22138c:	2b04      	cmp	r3, #4
  22138e:	d101      	bne.n	221394 <dir_alloc+0x84>
  221390:	2307      	movs	r3, #7
  221392:	75fb      	strb	r3, [r7, #23]
	return res;
  221394:	7dfb      	ldrb	r3, [r7, #23]
}
  221396:	4618      	mov	r0, r3
  221398:	3718      	adds	r7, #24
  22139a:	46bd      	mov	sp, r7
  22139c:	bd80      	pop	{r7, pc}

0022139e <ld_clust>:
static
DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
	FATFS* fs,		/* Pointer to the fs object */
	const BYTE* dir	/* Pointer to the key entry */
)
{
  22139e:	b580      	push	{r7, lr}
  2213a0:	b084      	sub	sp, #16
  2213a2:	af00      	add	r7, sp, #0
  2213a4:	6078      	str	r0, [r7, #4]
  2213a6:	6039      	str	r1, [r7, #0]
	DWORD cl;

	cl = ld_word(dir + DIR_FstClusLO);
  2213a8:	683b      	ldr	r3, [r7, #0]
  2213aa:	331a      	adds	r3, #26
  2213ac:	4618      	mov	r0, r3
  2213ae:	f7ff f817 	bl	2203e0 <ld_word>
  2213b2:	4603      	mov	r3, r0
  2213b4:	60fb      	str	r3, [r7, #12]
	if (fs->fs_type == FS_FAT32) {
  2213b6:	687b      	ldr	r3, [r7, #4]
  2213b8:	781b      	ldrb	r3, [r3, #0]
  2213ba:	2b03      	cmp	r3, #3
  2213bc:	d109      	bne.n	2213d2 <ld_clust+0x34>
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
  2213be:	683b      	ldr	r3, [r7, #0]
  2213c0:	3314      	adds	r3, #20
  2213c2:	4618      	mov	r0, r3
  2213c4:	f7ff f80c 	bl	2203e0 <ld_word>
  2213c8:	4603      	mov	r3, r0
  2213ca:	041b      	lsls	r3, r3, #16
  2213cc:	68fa      	ldr	r2, [r7, #12]
  2213ce:	4313      	orrs	r3, r2
  2213d0:	60fb      	str	r3, [r7, #12]
	}

	return cl;
  2213d2:	68fb      	ldr	r3, [r7, #12]
}
  2213d4:	4618      	mov	r0, r3
  2213d6:	3710      	adds	r7, #16
  2213d8:	46bd      	mov	sp, r7
  2213da:	bd80      	pop	{r7, pc}

002213dc <st_clust>:
void st_clust (
	FATFS* fs,	/* Pointer to the fs object */
	BYTE* dir,	/* Pointer to the key entry */
	DWORD cl	/* Value to be set */
)
{
  2213dc:	b580      	push	{r7, lr}
  2213de:	b084      	sub	sp, #16
  2213e0:	af00      	add	r7, sp, #0
  2213e2:	60f8      	str	r0, [r7, #12]
  2213e4:	60b9      	str	r1, [r7, #8]
  2213e6:	607a      	str	r2, [r7, #4]
	st_word(dir + DIR_FstClusLO, (WORD)cl);
  2213e8:	68bb      	ldr	r3, [r7, #8]
  2213ea:	331a      	adds	r3, #26
  2213ec:	687a      	ldr	r2, [r7, #4]
  2213ee:	b292      	uxth	r2, r2
  2213f0:	4611      	mov	r1, r2
  2213f2:	4618      	mov	r0, r3
  2213f4:	f7ff f82f 	bl	220456 <st_word>
	if (fs->fs_type == FS_FAT32) {
  2213f8:	68fb      	ldr	r3, [r7, #12]
  2213fa:	781b      	ldrb	r3, [r3, #0]
  2213fc:	2b03      	cmp	r3, #3
  2213fe:	d109      	bne.n	221414 <st_clust+0x38>
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
  221400:	68bb      	ldr	r3, [r7, #8]
  221402:	f103 0214 	add.w	r2, r3, #20
  221406:	687b      	ldr	r3, [r7, #4]
  221408:	0c1b      	lsrs	r3, r3, #16
  22140a:	b29b      	uxth	r3, r3
  22140c:	4619      	mov	r1, r3
  22140e:	4610      	mov	r0, r2
  221410:	f7ff f821 	bl	220456 <st_word>
	}
}
  221414:	bf00      	nop
  221416:	3710      	adds	r7, #16
  221418:	46bd      	mov	sp, r7
  22141a:	bd80      	pop	{r7, pc}

0022141c <cmp_lfn>:
static
int cmp_lfn (				/* 1:matched, 0:not matched */
	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
)
{
  22141c:	b590      	push	{r4, r7, lr}
  22141e:	b087      	sub	sp, #28
  221420:	af00      	add	r7, sp, #0
  221422:	6078      	str	r0, [r7, #4]
  221424:	6039      	str	r1, [r7, #0]
	UINT i, s;
	WCHAR wc, uc;


	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
  221426:	683b      	ldr	r3, [r7, #0]
  221428:	331a      	adds	r3, #26
  22142a:	4618      	mov	r0, r3
  22142c:	f7fe ffd8 	bl	2203e0 <ld_word>
  221430:	4603      	mov	r3, r0
  221432:	2b00      	cmp	r3, #0
  221434:	d001      	beq.n	22143a <cmp_lfn+0x1e>
  221436:	2300      	movs	r3, #0
  221438:	e059      	b.n	2214ee <cmp_lfn+0xd2>

	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
  22143a:	683b      	ldr	r3, [r7, #0]
  22143c:	781b      	ldrb	r3, [r3, #0]
  22143e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  221442:	1e5a      	subs	r2, r3, #1
  221444:	4613      	mov	r3, r2
  221446:	005b      	lsls	r3, r3, #1
  221448:	4413      	add	r3, r2
  22144a:	009b      	lsls	r3, r3, #2
  22144c:	4413      	add	r3, r2
  22144e:	617b      	str	r3, [r7, #20]

	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
  221450:	2301      	movs	r3, #1
  221452:	81fb      	strh	r3, [r7, #14]
  221454:	2300      	movs	r3, #0
  221456:	613b      	str	r3, [r7, #16]
  221458:	e033      	b.n	2214c2 <cmp_lfn+0xa6>
		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
  22145a:	4a27      	ldr	r2, [pc, #156]	; (2214f8 <cmp_lfn+0xdc>)
  22145c:	693b      	ldr	r3, [r7, #16]
  22145e:	4413      	add	r3, r2
  221460:	781b      	ldrb	r3, [r3, #0]
  221462:	461a      	mov	r2, r3
  221464:	683b      	ldr	r3, [r7, #0]
  221466:	4413      	add	r3, r2
  221468:	4618      	mov	r0, r3
  22146a:	f7fe ffb9 	bl	2203e0 <ld_word>
  22146e:	4603      	mov	r3, r0
  221470:	81bb      	strh	r3, [r7, #12]
		if (wc) {
  221472:	89fb      	ldrh	r3, [r7, #14]
  221474:	2b00      	cmp	r3, #0
  221476:	d01a      	beq.n	2214ae <cmp_lfn+0x92>
			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
  221478:	697b      	ldr	r3, [r7, #20]
  22147a:	2bfe      	cmp	r3, #254	; 0xfe
  22147c:	d812      	bhi.n	2214a4 <cmp_lfn+0x88>
  22147e:	89bb      	ldrh	r3, [r7, #12]
  221480:	4618      	mov	r0, r3
  221482:	f002 f83f 	bl	223504 <ff_wtoupper>
  221486:	4603      	mov	r3, r0
  221488:	461c      	mov	r4, r3
  22148a:	697b      	ldr	r3, [r7, #20]
  22148c:	1c5a      	adds	r2, r3, #1
  22148e:	617a      	str	r2, [r7, #20]
  221490:	005b      	lsls	r3, r3, #1
  221492:	687a      	ldr	r2, [r7, #4]
  221494:	4413      	add	r3, r2
  221496:	881b      	ldrh	r3, [r3, #0]
  221498:	4618      	mov	r0, r3
  22149a:	f002 f833 	bl	223504 <ff_wtoupper>
  22149e:	4603      	mov	r3, r0
  2214a0:	429c      	cmp	r4, r3
  2214a2:	d001      	beq.n	2214a8 <cmp_lfn+0x8c>
				return 0;					/* Not matched */
  2214a4:	2300      	movs	r3, #0
  2214a6:	e022      	b.n	2214ee <cmp_lfn+0xd2>
			}
			wc = uc;
  2214a8:	89bb      	ldrh	r3, [r7, #12]
  2214aa:	81fb      	strh	r3, [r7, #14]
  2214ac:	e006      	b.n	2214bc <cmp_lfn+0xa0>
		} else {
			if (uc != 0xFFFF) return 0;		/* Check filler */
  2214ae:	89bb      	ldrh	r3, [r7, #12]
  2214b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  2214b4:	4293      	cmp	r3, r2
  2214b6:	d001      	beq.n	2214bc <cmp_lfn+0xa0>
  2214b8:	2300      	movs	r3, #0
  2214ba:	e018      	b.n	2214ee <cmp_lfn+0xd2>
	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
  2214bc:	693b      	ldr	r3, [r7, #16]
  2214be:	3301      	adds	r3, #1
  2214c0:	613b      	str	r3, [r7, #16]
  2214c2:	693b      	ldr	r3, [r7, #16]
  2214c4:	2b0c      	cmp	r3, #12
  2214c6:	d9c8      	bls.n	22145a <cmp_lfn+0x3e>
		}
	}

	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
  2214c8:	683b      	ldr	r3, [r7, #0]
  2214ca:	781b      	ldrb	r3, [r3, #0]
  2214cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
  2214d0:	2b00      	cmp	r3, #0
  2214d2:	d00b      	beq.n	2214ec <cmp_lfn+0xd0>
  2214d4:	89fb      	ldrh	r3, [r7, #14]
  2214d6:	2b00      	cmp	r3, #0
  2214d8:	d008      	beq.n	2214ec <cmp_lfn+0xd0>
  2214da:	697b      	ldr	r3, [r7, #20]
  2214dc:	005b      	lsls	r3, r3, #1
  2214de:	687a      	ldr	r2, [r7, #4]
  2214e0:	4413      	add	r3, r2
  2214e2:	881b      	ldrh	r3, [r3, #0]
  2214e4:	2b00      	cmp	r3, #0
  2214e6:	d001      	beq.n	2214ec <cmp_lfn+0xd0>
  2214e8:	2300      	movs	r3, #0
  2214ea:	e000      	b.n	2214ee <cmp_lfn+0xd2>

	return 1;		/* The part of LFN matched */
  2214ec:	2301      	movs	r3, #1
}
  2214ee:	4618      	mov	r0, r3
  2214f0:	371c      	adds	r7, #28
  2214f2:	46bd      	mov	sp, r7
  2214f4:	bd90      	pop	{r4, r7, pc}
  2214f6:	bf00      	nop
  2214f8:	00229424 	.word	0x00229424

002214fc <put_lfn>:
	const WCHAR* lfn,	/* Pointer to the LFN */
	BYTE* dir,			/* Pointer to the LFN entry to be created */
	BYTE ord,			/* LFN order (1-20) */
	BYTE sum			/* Checksum of the corresponding SFN */
)
{
  2214fc:	b580      	push	{r7, lr}
  2214fe:	b088      	sub	sp, #32
  221500:	af00      	add	r7, sp, #0
  221502:	60f8      	str	r0, [r7, #12]
  221504:	60b9      	str	r1, [r7, #8]
  221506:	4611      	mov	r1, r2
  221508:	461a      	mov	r2, r3
  22150a:	460b      	mov	r3, r1
  22150c:	71fb      	strb	r3, [r7, #7]
  22150e:	4613      	mov	r3, r2
  221510:	71bb      	strb	r3, [r7, #6]
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set checksum */
  221512:	68bb      	ldr	r3, [r7, #8]
  221514:	330d      	adds	r3, #13
  221516:	79ba      	ldrb	r2, [r7, #6]
  221518:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  22151a:	68bb      	ldr	r3, [r7, #8]
  22151c:	330b      	adds	r3, #11
  22151e:	220f      	movs	r2, #15
  221520:	701a      	strb	r2, [r3, #0]
	dir[LDIR_Type] = 0;
  221522:	68bb      	ldr	r3, [r7, #8]
  221524:	330c      	adds	r3, #12
  221526:	2200      	movs	r2, #0
  221528:	701a      	strb	r2, [r3, #0]
	st_word(dir + LDIR_FstClusLO, 0);
  22152a:	68bb      	ldr	r3, [r7, #8]
  22152c:	331a      	adds	r3, #26
  22152e:	2100      	movs	r1, #0
  221530:	4618      	mov	r0, r3
  221532:	f7fe ff90 	bl	220456 <st_word>

	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
  221536:	79fb      	ldrb	r3, [r7, #7]
  221538:	1e5a      	subs	r2, r3, #1
  22153a:	4613      	mov	r3, r2
  22153c:	005b      	lsls	r3, r3, #1
  22153e:	4413      	add	r3, r2
  221540:	009b      	lsls	r3, r3, #2
  221542:	4413      	add	r3, r2
  221544:	61fb      	str	r3, [r7, #28]
	s = wc = 0;
  221546:	2300      	movs	r3, #0
  221548:	82fb      	strh	r3, [r7, #22]
  22154a:	2300      	movs	r3, #0
  22154c:	61bb      	str	r3, [r7, #24]
	do {
		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
  22154e:	8afb      	ldrh	r3, [r7, #22]
  221550:	f64f 72ff 	movw	r2, #65535	; 0xffff
  221554:	4293      	cmp	r3, r2
  221556:	d007      	beq.n	221568 <put_lfn+0x6c>
  221558:	69fb      	ldr	r3, [r7, #28]
  22155a:	1c5a      	adds	r2, r3, #1
  22155c:	61fa      	str	r2, [r7, #28]
  22155e:	005b      	lsls	r3, r3, #1
  221560:	68fa      	ldr	r2, [r7, #12]
  221562:	4413      	add	r3, r2
  221564:	881b      	ldrh	r3, [r3, #0]
  221566:	82fb      	strh	r3, [r7, #22]
		st_word(dir + LfnOfs[s], wc);		/* Put it */
  221568:	4a17      	ldr	r2, [pc, #92]	; (2215c8 <put_lfn+0xcc>)
  22156a:	69bb      	ldr	r3, [r7, #24]
  22156c:	4413      	add	r3, r2
  22156e:	781b      	ldrb	r3, [r3, #0]
  221570:	461a      	mov	r2, r3
  221572:	68bb      	ldr	r3, [r7, #8]
  221574:	4413      	add	r3, r2
  221576:	8afa      	ldrh	r2, [r7, #22]
  221578:	4611      	mov	r1, r2
  22157a:	4618      	mov	r0, r3
  22157c:	f7fe ff6b 	bl	220456 <st_word>
		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
  221580:	8afb      	ldrh	r3, [r7, #22]
  221582:	2b00      	cmp	r3, #0
  221584:	d102      	bne.n	22158c <put_lfn+0x90>
  221586:	f64f 73ff 	movw	r3, #65535	; 0xffff
  22158a:	82fb      	strh	r3, [r7, #22]
	} while (++s < 13);
  22158c:	69bb      	ldr	r3, [r7, #24]
  22158e:	3301      	adds	r3, #1
  221590:	61bb      	str	r3, [r7, #24]
  221592:	69bb      	ldr	r3, [r7, #24]
  221594:	2b0c      	cmp	r3, #12
  221596:	d9da      	bls.n	22154e <put_lfn+0x52>
	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
  221598:	8afb      	ldrh	r3, [r7, #22]
  22159a:	f64f 72ff 	movw	r2, #65535	; 0xffff
  22159e:	4293      	cmp	r3, r2
  2215a0:	d006      	beq.n	2215b0 <put_lfn+0xb4>
  2215a2:	69fb      	ldr	r3, [r7, #28]
  2215a4:	005b      	lsls	r3, r3, #1
  2215a6:	68fa      	ldr	r2, [r7, #12]
  2215a8:	4413      	add	r3, r2
  2215aa:	881b      	ldrh	r3, [r3, #0]
  2215ac:	2b00      	cmp	r3, #0
  2215ae:	d103      	bne.n	2215b8 <put_lfn+0xbc>
  2215b0:	79fb      	ldrb	r3, [r7, #7]
  2215b2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  2215b6:	71fb      	strb	r3, [r7, #7]
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  2215b8:	68bb      	ldr	r3, [r7, #8]
  2215ba:	79fa      	ldrb	r2, [r7, #7]
  2215bc:	701a      	strb	r2, [r3, #0]
}
  2215be:	bf00      	nop
  2215c0:	3720      	adds	r7, #32
  2215c2:	46bd      	mov	sp, r7
  2215c4:	bd80      	pop	{r7, pc}
  2215c6:	bf00      	nop
  2215c8:	00229424 	.word	0x00229424

002215cc <gen_numname>:
	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
	const BYTE* src,	/* Pointer to SFN */
	const WCHAR* lfn,	/* Pointer to LFN */
	UINT seq			/* Sequence number */
)
{
  2215cc:	b580      	push	{r7, lr}
  2215ce:	b08c      	sub	sp, #48	; 0x30
  2215d0:	af00      	add	r7, sp, #0
  2215d2:	60f8      	str	r0, [r7, #12]
  2215d4:	60b9      	str	r1, [r7, #8]
  2215d6:	607a      	str	r2, [r7, #4]
  2215d8:	603b      	str	r3, [r7, #0]
	UINT i, j;
	WCHAR wc;
	DWORD sr;


	mem_cpy(dst, src, 11);
  2215da:	220b      	movs	r2, #11
  2215dc:	68b9      	ldr	r1, [r7, #8]
  2215de:	68f8      	ldr	r0, [r7, #12]
  2215e0:	f7fe ff80 	bl	2204e4 <mem_cpy>

	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
  2215e4:	683b      	ldr	r3, [r7, #0]
  2215e6:	2b05      	cmp	r3, #5
  2215e8:	d929      	bls.n	22163e <gen_numname+0x72>
		sr = seq;
  2215ea:	683b      	ldr	r3, [r7, #0]
  2215ec:	61fb      	str	r3, [r7, #28]
		while (*lfn) {	/* Create a CRC */
  2215ee:	e020      	b.n	221632 <gen_numname+0x66>
			wc = *lfn++;
  2215f0:	687b      	ldr	r3, [r7, #4]
  2215f2:	1c9a      	adds	r2, r3, #2
  2215f4:	607a      	str	r2, [r7, #4]
  2215f6:	881b      	ldrh	r3, [r3, #0]
  2215f8:	847b      	strh	r3, [r7, #34]	; 0x22
			for (i = 0; i < 16; i++) {
  2215fa:	2300      	movs	r3, #0
  2215fc:	62bb      	str	r3, [r7, #40]	; 0x28
  2215fe:	e015      	b.n	22162c <gen_numname+0x60>
				sr = (sr << 1) + (wc & 1);
  221600:	69fb      	ldr	r3, [r7, #28]
  221602:	005a      	lsls	r2, r3, #1
  221604:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  221606:	f003 0301 	and.w	r3, r3, #1
  22160a:	4413      	add	r3, r2
  22160c:	61fb      	str	r3, [r7, #28]
				wc >>= 1;
  22160e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
  221610:	085b      	lsrs	r3, r3, #1
  221612:	847b      	strh	r3, [r7, #34]	; 0x22
				if (sr & 0x10000) sr ^= 0x11021;
  221614:	69fb      	ldr	r3, [r7, #28]
  221616:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  22161a:	2b00      	cmp	r3, #0
  22161c:	d003      	beq.n	221626 <gen_numname+0x5a>
  22161e:	69fa      	ldr	r2, [r7, #28]
  221620:	4b30      	ldr	r3, [pc, #192]	; (2216e4 <gen_numname+0x118>)
  221622:	4053      	eors	r3, r2
  221624:	61fb      	str	r3, [r7, #28]
			for (i = 0; i < 16; i++) {
  221626:	6abb      	ldr	r3, [r7, #40]	; 0x28
  221628:	3301      	adds	r3, #1
  22162a:	62bb      	str	r3, [r7, #40]	; 0x28
  22162c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  22162e:	2b0f      	cmp	r3, #15
  221630:	d9e6      	bls.n	221600 <gen_numname+0x34>
		while (*lfn) {	/* Create a CRC */
  221632:	687b      	ldr	r3, [r7, #4]
  221634:	881b      	ldrh	r3, [r3, #0]
  221636:	2b00      	cmp	r3, #0
  221638:	d1da      	bne.n	2215f0 <gen_numname+0x24>
			}
		}
		seq = (UINT)sr;
  22163a:	69fb      	ldr	r3, [r7, #28]
  22163c:	603b      	str	r3, [r7, #0]
	}

	/* itoa (hexdecimal) */
	i = 7;
  22163e:	2307      	movs	r3, #7
  221640:	62bb      	str	r3, [r7, #40]	; 0x28
	do {
		c = (BYTE)((seq % 16) + '0');
  221642:	683b      	ldr	r3, [r7, #0]
  221644:	b2db      	uxtb	r3, r3
  221646:	f003 030f 	and.w	r3, r3, #15
  22164a:	b2db      	uxtb	r3, r3
  22164c:	3330      	adds	r3, #48	; 0x30
  22164e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (c > '9') c += 7;
  221652:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221656:	2b39      	cmp	r3, #57	; 0x39
  221658:	d904      	bls.n	221664 <gen_numname+0x98>
  22165a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  22165e:	3307      	adds	r3, #7
  221660:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		ns[i--] = c;
  221664:	6abb      	ldr	r3, [r7, #40]	; 0x28
  221666:	1e5a      	subs	r2, r3, #1
  221668:	62ba      	str	r2, [r7, #40]	; 0x28
  22166a:	f107 0230 	add.w	r2, r7, #48	; 0x30
  22166e:	4413      	add	r3, r2
  221670:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
  221674:	f803 2c1c 	strb.w	r2, [r3, #-28]
		seq /= 16;
  221678:	683b      	ldr	r3, [r7, #0]
  22167a:	091b      	lsrs	r3, r3, #4
  22167c:	603b      	str	r3, [r7, #0]
	} while (seq);
  22167e:	683b      	ldr	r3, [r7, #0]
  221680:	2b00      	cmp	r3, #0
  221682:	d1de      	bne.n	221642 <gen_numname+0x76>
	ns[i] = '~';
  221684:	f107 0214 	add.w	r2, r7, #20
  221688:	6abb      	ldr	r3, [r7, #40]	; 0x28
  22168a:	4413      	add	r3, r2
  22168c:	227e      	movs	r2, #126	; 0x7e
  22168e:	701a      	strb	r2, [r3, #0]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  221690:	2300      	movs	r3, #0
  221692:	627b      	str	r3, [r7, #36]	; 0x24
  221694:	e002      	b.n	22169c <gen_numname+0xd0>
  221696:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  221698:	3301      	adds	r3, #1
  22169a:	627b      	str	r3, [r7, #36]	; 0x24
  22169c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  22169e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2216a0:	429a      	cmp	r2, r3
  2216a2:	d205      	bcs.n	2216b0 <gen_numname+0xe4>
  2216a4:	68fa      	ldr	r2, [r7, #12]
  2216a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2216a8:	4413      	add	r3, r2
  2216aa:	781b      	ldrb	r3, [r3, #0]
  2216ac:	2b20      	cmp	r3, #32
  2216ae:	d1f2      	bne.n	221696 <gen_numname+0xca>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  2216b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2216b2:	1c5a      	adds	r2, r3, #1
  2216b4:	627a      	str	r2, [r7, #36]	; 0x24
  2216b6:	68fa      	ldr	r2, [r7, #12]
  2216b8:	441a      	add	r2, r3
  2216ba:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2216bc:	2b07      	cmp	r3, #7
  2216be:	d808      	bhi.n	2216d2 <gen_numname+0x106>
  2216c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2216c2:	1c59      	adds	r1, r3, #1
  2216c4:	62b9      	str	r1, [r7, #40]	; 0x28
  2216c6:	f107 0130 	add.w	r1, r7, #48	; 0x30
  2216ca:	440b      	add	r3, r1
  2216cc:	f813 3c1c 	ldrb.w	r3, [r3, #-28]
  2216d0:	e000      	b.n	2216d4 <gen_numname+0x108>
  2216d2:	2320      	movs	r3, #32
  2216d4:	7013      	strb	r3, [r2, #0]
	} while (j < 8);
  2216d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2216d8:	2b07      	cmp	r3, #7
  2216da:	d9e9      	bls.n	2216b0 <gen_numname+0xe4>
}
  2216dc:	bf00      	nop
  2216de:	3730      	adds	r7, #48	; 0x30
  2216e0:	46bd      	mov	sp, r7
  2216e2:	bd80      	pop	{r7, pc}
  2216e4:	00011021 	.word	0x00011021

002216e8 <sum_sfn>:

static
BYTE sum_sfn (
	const BYTE* dir		/* Pointer to the SFN entry */
)
{
  2216e8:	b480      	push	{r7}
  2216ea:	b085      	sub	sp, #20
  2216ec:	af00      	add	r7, sp, #0
  2216ee:	6078      	str	r0, [r7, #4]
	BYTE sum = 0;
  2216f0:	2300      	movs	r3, #0
  2216f2:	73fb      	strb	r3, [r7, #15]
	UINT n = 11;
  2216f4:	230b      	movs	r3, #11
  2216f6:	60bb      	str	r3, [r7, #8]

	do {
		sum = (sum >> 1) + (sum << 7) + *dir++;
  2216f8:	7bfb      	ldrb	r3, [r7, #15]
  2216fa:	b2da      	uxtb	r2, r3
  2216fc:	0852      	lsrs	r2, r2, #1
  2216fe:	01db      	lsls	r3, r3, #7
  221700:	4313      	orrs	r3, r2
  221702:	b2da      	uxtb	r2, r3
  221704:	687b      	ldr	r3, [r7, #4]
  221706:	1c59      	adds	r1, r3, #1
  221708:	6079      	str	r1, [r7, #4]
  22170a:	781b      	ldrb	r3, [r3, #0]
  22170c:	4413      	add	r3, r2
  22170e:	73fb      	strb	r3, [r7, #15]
	} while (--n);
  221710:	68bb      	ldr	r3, [r7, #8]
  221712:	3b01      	subs	r3, #1
  221714:	60bb      	str	r3, [r7, #8]
  221716:	68bb      	ldr	r3, [r7, #8]
  221718:	2b00      	cmp	r3, #0
  22171a:	d1ed      	bne.n	2216f8 <sum_sfn+0x10>
	return sum;
  22171c:	7bfb      	ldrb	r3, [r7, #15]
}
  22171e:	4618      	mov	r0, r3
  221720:	3714      	adds	r7, #20
  221722:	46bd      	mov	sp, r7
  221724:	f85d 7b04 	ldr.w	r7, [sp], #4
  221728:	4770      	bx	lr

0022172a <dir_find>:

static
FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
	DIR* dp			/* Pointer to the directory object with the file name */
)
{
  22172a:	b580      	push	{r7, lr}
  22172c:	b086      	sub	sp, #24
  22172e:	af00      	add	r7, sp, #0
  221730:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
  221732:	687b      	ldr	r3, [r7, #4]
  221734:	681b      	ldr	r3, [r3, #0]
  221736:	613b      	str	r3, [r7, #16]
	BYTE c;
#if _USE_LFN != 0
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dp, 0);			/* Rewind directory object */
  221738:	2100      	movs	r1, #0
  22173a:	6878      	ldr	r0, [r7, #4]
  22173c:	f7ff fca8 	bl	221090 <dir_sdi>
  221740:	4603      	mov	r3, r0
  221742:	75fb      	strb	r3, [r7, #23]
	if (res != FR_OK) return res;
  221744:	7dfb      	ldrb	r3, [r7, #23]
  221746:	2b00      	cmp	r3, #0
  221748:	d001      	beq.n	22174e <dir_find+0x24>
  22174a:	7dfb      	ldrb	r3, [r7, #23]
  22174c:	e0a9      	b.n	2218a2 <dir_find+0x178>
		return res;
	}
#endif
	/* On the FAT12/16/32 volume */
#if _USE_LFN != 0
	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
  22174e:	23ff      	movs	r3, #255	; 0xff
  221750:	753b      	strb	r3, [r7, #20]
  221752:	7d3b      	ldrb	r3, [r7, #20]
  221754:	757b      	strb	r3, [r7, #21]
  221756:	687b      	ldr	r3, [r7, #4]
  221758:	f04f 32ff 	mov.w	r2, #4294967295
  22175c:	631a      	str	r2, [r3, #48]	; 0x30
#endif
	do {
		res = move_window(fs, dp->sect);
  22175e:	687b      	ldr	r3, [r7, #4]
  221760:	69db      	ldr	r3, [r3, #28]
  221762:	4619      	mov	r1, r3
  221764:	6938      	ldr	r0, [r7, #16]
  221766:	f7ff f91b 	bl	2209a0 <move_window>
  22176a:	4603      	mov	r3, r0
  22176c:	75fb      	strb	r3, [r7, #23]
		if (res != FR_OK) break;
  22176e:	7dfb      	ldrb	r3, [r7, #23]
  221770:	2b00      	cmp	r3, #0
  221772:	f040 8090 	bne.w	221896 <dir_find+0x16c>
		c = dp->dir[DIR_Name];
  221776:	687b      	ldr	r3, [r7, #4]
  221778:	6a1b      	ldr	r3, [r3, #32]
  22177a:	781b      	ldrb	r3, [r3, #0]
  22177c:	75bb      	strb	r3, [r7, #22]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  22177e:	7dbb      	ldrb	r3, [r7, #22]
  221780:	2b00      	cmp	r3, #0
  221782:	d102      	bne.n	22178a <dir_find+0x60>
  221784:	2304      	movs	r3, #4
  221786:	75fb      	strb	r3, [r7, #23]
  221788:	e08a      	b.n	2218a0 <dir_find+0x176>
#if _USE_LFN != 0	/* LFN configuration */
		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
  22178a:	687b      	ldr	r3, [r7, #4]
  22178c:	6a1b      	ldr	r3, [r3, #32]
  22178e:	330b      	adds	r3, #11
  221790:	781b      	ldrb	r3, [r3, #0]
  221792:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  221796:	73fb      	strb	r3, [r7, #15]
  221798:	687b      	ldr	r3, [r7, #4]
  22179a:	7bfa      	ldrb	r2, [r7, #15]
  22179c:	719a      	strb	r2, [r3, #6]
		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  22179e:	7dbb      	ldrb	r3, [r7, #22]
  2217a0:	2be5      	cmp	r3, #229	; 0xe5
  2217a2:	d007      	beq.n	2217b4 <dir_find+0x8a>
  2217a4:	7bfb      	ldrb	r3, [r7, #15]
  2217a6:	f003 0308 	and.w	r3, r3, #8
  2217aa:	2b00      	cmp	r3, #0
  2217ac:	d009      	beq.n	2217c2 <dir_find+0x98>
  2217ae:	7bfb      	ldrb	r3, [r7, #15]
  2217b0:	2b0f      	cmp	r3, #15
  2217b2:	d006      	beq.n	2217c2 <dir_find+0x98>
			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
  2217b4:	23ff      	movs	r3, #255	; 0xff
  2217b6:	757b      	strb	r3, [r7, #21]
  2217b8:	687b      	ldr	r3, [r7, #4]
  2217ba:	f04f 32ff 	mov.w	r2, #4294967295
  2217be:	631a      	str	r2, [r3, #48]	; 0x30
  2217c0:	e05e      	b.n	221880 <dir_find+0x156>
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  2217c2:	7bfb      	ldrb	r3, [r7, #15]
  2217c4:	2b0f      	cmp	r3, #15
  2217c6:	d136      	bne.n	221836 <dir_find+0x10c>
				if (!(dp->fn[NSFLAG] & NS_NOLFN)) {
  2217c8:	687b      	ldr	r3, [r7, #4]
  2217ca:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  2217ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
  2217d2:	2b00      	cmp	r3, #0
  2217d4:	d154      	bne.n	221880 <dir_find+0x156>
					if (c & LLEF) {		/* Is it start of LFN sequence? */
  2217d6:	7dbb      	ldrb	r3, [r7, #22]
  2217d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
  2217dc:	2b00      	cmp	r3, #0
  2217de:	d00d      	beq.n	2217fc <dir_find+0xd2>
						sum = dp->dir[LDIR_Chksum];
  2217e0:	687b      	ldr	r3, [r7, #4]
  2217e2:	6a1b      	ldr	r3, [r3, #32]
  2217e4:	7b5b      	ldrb	r3, [r3, #13]
  2217e6:	753b      	strb	r3, [r7, #20]
						c &= (BYTE)~LLEF; ord = c;	/* LFN start order */
  2217e8:	7dbb      	ldrb	r3, [r7, #22]
  2217ea:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  2217ee:	75bb      	strb	r3, [r7, #22]
  2217f0:	7dbb      	ldrb	r3, [r7, #22]
  2217f2:	757b      	strb	r3, [r7, #21]
						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
  2217f4:	687b      	ldr	r3, [r7, #4]
  2217f6:	695a      	ldr	r2, [r3, #20]
  2217f8:	687b      	ldr	r3, [r7, #4]
  2217fa:	631a      	str	r2, [r3, #48]	; 0x30
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
  2217fc:	7dba      	ldrb	r2, [r7, #22]
  2217fe:	7d7b      	ldrb	r3, [r7, #21]
  221800:	429a      	cmp	r2, r3
  221802:	d115      	bne.n	221830 <dir_find+0x106>
  221804:	687b      	ldr	r3, [r7, #4]
  221806:	6a1b      	ldr	r3, [r3, #32]
  221808:	330d      	adds	r3, #13
  22180a:	781b      	ldrb	r3, [r3, #0]
  22180c:	7d3a      	ldrb	r2, [r7, #20]
  22180e:	429a      	cmp	r2, r3
  221810:	d10e      	bne.n	221830 <dir_find+0x106>
  221812:	693b      	ldr	r3, [r7, #16]
  221814:	68da      	ldr	r2, [r3, #12]
  221816:	687b      	ldr	r3, [r7, #4]
  221818:	6a1b      	ldr	r3, [r3, #32]
  22181a:	4619      	mov	r1, r3
  22181c:	4610      	mov	r0, r2
  22181e:	f7ff fdfd 	bl	22141c <cmp_lfn>
  221822:	4603      	mov	r3, r0
  221824:	2b00      	cmp	r3, #0
  221826:	d003      	beq.n	221830 <dir_find+0x106>
  221828:	7d7b      	ldrb	r3, [r7, #21]
  22182a:	3b01      	subs	r3, #1
  22182c:	b2db      	uxtb	r3, r3
  22182e:	e000      	b.n	221832 <dir_find+0x108>
  221830:	23ff      	movs	r3, #255	; 0xff
  221832:	757b      	strb	r3, [r7, #21]
  221834:	e024      	b.n	221880 <dir_find+0x156>
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
  221836:	7d7b      	ldrb	r3, [r7, #21]
  221838:	2b00      	cmp	r3, #0
  22183a:	d109      	bne.n	221850 <dir_find+0x126>
  22183c:	687b      	ldr	r3, [r7, #4]
  22183e:	6a1b      	ldr	r3, [r3, #32]
  221840:	4618      	mov	r0, r3
  221842:	f7ff ff51 	bl	2216e8 <sum_sfn>
  221846:	4603      	mov	r3, r0
  221848:	461a      	mov	r2, r3
  22184a:	7d3b      	ldrb	r3, [r7, #20]
  22184c:	4293      	cmp	r3, r2
  22184e:	d024      	beq.n	22189a <dir_find+0x170>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
  221850:	687b      	ldr	r3, [r7, #4]
  221852:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  221856:	f003 0301 	and.w	r3, r3, #1
  22185a:	2b00      	cmp	r3, #0
  22185c:	d10a      	bne.n	221874 <dir_find+0x14a>
  22185e:	687b      	ldr	r3, [r7, #4]
  221860:	6a18      	ldr	r0, [r3, #32]
  221862:	687b      	ldr	r3, [r7, #4]
  221864:	3324      	adds	r3, #36	; 0x24
  221866:	220b      	movs	r2, #11
  221868:	4619      	mov	r1, r3
  22186a:	f7fe fe76 	bl	22055a <mem_cmp>
  22186e:	4603      	mov	r3, r0
  221870:	2b00      	cmp	r3, #0
  221872:	d014      	beq.n	22189e <dir_find+0x174>
				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
  221874:	23ff      	movs	r3, #255	; 0xff
  221876:	757b      	strb	r3, [r7, #21]
  221878:	687b      	ldr	r3, [r7, #4]
  22187a:	f04f 32ff 	mov.w	r2, #4294967295
  22187e:	631a      	str	r2, [r3, #48]	; 0x30
		}
#else		/* Non LFN configuration */
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
#endif
		res = dir_next(dp, 0);	/* Next entry */
  221880:	2100      	movs	r1, #0
  221882:	6878      	ldr	r0, [r7, #4]
  221884:	f7ff fc7f 	bl	221186 <dir_next>
  221888:	4603      	mov	r3, r0
  22188a:	75fb      	strb	r3, [r7, #23]
	} while (res == FR_OK);
  22188c:	7dfb      	ldrb	r3, [r7, #23]
  22188e:	2b00      	cmp	r3, #0
  221890:	f43f af65 	beq.w	22175e <dir_find+0x34>
  221894:	e004      	b.n	2218a0 <dir_find+0x176>
		if (res != FR_OK) break;
  221896:	bf00      	nop
  221898:	e002      	b.n	2218a0 <dir_find+0x176>
				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
  22189a:	bf00      	nop
  22189c:	e000      	b.n	2218a0 <dir_find+0x176>
				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
  22189e:	bf00      	nop

	return res;
  2218a0:	7dfb      	ldrb	r3, [r7, #23]
}
  2218a2:	4618      	mov	r0, r3
  2218a4:	3718      	adds	r7, #24
  2218a6:	46bd      	mov	sp, r7
  2218a8:	bd80      	pop	{r7, pc}
	...

002218ac <dir_register>:

static
FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
	DIR* dp				/* Target directory with object name to be created */
)
{
  2218ac:	b580      	push	{r7, lr}
  2218ae:	b08c      	sub	sp, #48	; 0x30
  2218b0:	af00      	add	r7, sp, #0
  2218b2:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs = dp->obj.fs;
  2218b4:	687b      	ldr	r3, [r7, #4]
  2218b6:	681b      	ldr	r3, [r3, #0]
  2218b8:	61fb      	str	r3, [r7, #28]
#if _USE_LFN != 0	/* LFN configuration */
	UINT n, nlen, nent;
	BYTE sn[12], sum;


	if (dp->fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
  2218ba:	687b      	ldr	r3, [r7, #4]
  2218bc:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  2218c0:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
  2218c4:	2b00      	cmp	r3, #0
  2218c6:	d001      	beq.n	2218cc <dir_register+0x20>
  2218c8:	2306      	movs	r3, #6
  2218ca:	e0e0      	b.n	221a8e <dir_register+0x1e2>
	for (nlen = 0; fs->lfnbuf[nlen]; nlen++) ;	/* Get lfn length */
  2218cc:	2300      	movs	r3, #0
  2218ce:	627b      	str	r3, [r7, #36]	; 0x24
  2218d0:	e002      	b.n	2218d8 <dir_register+0x2c>
  2218d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2218d4:	3301      	adds	r3, #1
  2218d6:	627b      	str	r3, [r7, #36]	; 0x24
  2218d8:	69fb      	ldr	r3, [r7, #28]
  2218da:	68da      	ldr	r2, [r3, #12]
  2218dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2218de:	005b      	lsls	r3, r3, #1
  2218e0:	4413      	add	r3, r2
  2218e2:	881b      	ldrh	r3, [r3, #0]
  2218e4:	2b00      	cmp	r3, #0
  2218e6:	d1f4      	bne.n	2218d2 <dir_register+0x26>
		create_xdir(fs->dirbuf, fs->lfnbuf);	/* Create on-memory directory block to be written later */
		return FR_OK;
	}
#endif
	/* On the FAT12/16/32 volume */
	mem_cpy(sn, dp->fn, 12);
  2218e8:	687b      	ldr	r3, [r7, #4]
  2218ea:	f103 0124 	add.w	r1, r3, #36	; 0x24
  2218ee:	f107 030c 	add.w	r3, r7, #12
  2218f2:	220c      	movs	r2, #12
  2218f4:	4618      	mov	r0, r3
  2218f6:	f7fe fdf5 	bl	2204e4 <mem_cpy>
	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  2218fa:	7dfb      	ldrb	r3, [r7, #23]
  2218fc:	f003 0301 	and.w	r3, r3, #1
  221900:	2b00      	cmp	r3, #0
  221902:	d032      	beq.n	22196a <dir_register+0xbe>
		dp->fn[NSFLAG] = NS_NOLFN;		/* Find only SFN */
  221904:	687b      	ldr	r3, [r7, #4]
  221906:	2240      	movs	r2, #64	; 0x40
  221908:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		for (n = 1; n < 100; n++) {
  22190c:	2301      	movs	r3, #1
  22190e:	62bb      	str	r3, [r7, #40]	; 0x28
  221910:	e016      	b.n	221940 <dir_register+0x94>
			gen_numname(dp->fn, sn, fs->lfnbuf, n);	/* Generate a numbered name */
  221912:	687b      	ldr	r3, [r7, #4]
  221914:	f103 0024 	add.w	r0, r3, #36	; 0x24
  221918:	69fb      	ldr	r3, [r7, #28]
  22191a:	68da      	ldr	r2, [r3, #12]
  22191c:	f107 010c 	add.w	r1, r7, #12
  221920:	6abb      	ldr	r3, [r7, #40]	; 0x28
  221922:	f7ff fe53 	bl	2215cc <gen_numname>
			res = dir_find(dp);				/* Check if the name collides with existing SFN */
  221926:	6878      	ldr	r0, [r7, #4]
  221928:	f7ff feff 	bl	22172a <dir_find>
  22192c:	4603      	mov	r3, r0
  22192e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			if (res != FR_OK) break;
  221932:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221936:	2b00      	cmp	r3, #0
  221938:	d106      	bne.n	221948 <dir_register+0x9c>
		for (n = 1; n < 100; n++) {
  22193a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  22193c:	3301      	adds	r3, #1
  22193e:	62bb      	str	r3, [r7, #40]	; 0x28
  221940:	6abb      	ldr	r3, [r7, #40]	; 0x28
  221942:	2b63      	cmp	r3, #99	; 0x63
  221944:	d9e5      	bls.n	221912 <dir_register+0x66>
  221946:	e000      	b.n	22194a <dir_register+0x9e>
			if (res != FR_OK) break;
  221948:	bf00      	nop
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  22194a:	6abb      	ldr	r3, [r7, #40]	; 0x28
  22194c:	2b64      	cmp	r3, #100	; 0x64
  22194e:	d101      	bne.n	221954 <dir_register+0xa8>
  221950:	2307      	movs	r3, #7
  221952:	e09c      	b.n	221a8e <dir_register+0x1e2>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  221954:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221958:	2b04      	cmp	r3, #4
  22195a:	d002      	beq.n	221962 <dir_register+0xb6>
  22195c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221960:	e095      	b.n	221a8e <dir_register+0x1e2>
		dp->fn[NSFLAG] = sn[NSFLAG];
  221962:	7dfa      	ldrb	r2, [r7, #23]
  221964:	687b      	ldr	r3, [r7, #4]
  221966:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
	}

	/* Create an SFN with/without LFNs. */
	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
  22196a:	7dfb      	ldrb	r3, [r7, #23]
  22196c:	f003 0302 	and.w	r3, r3, #2
  221970:	2b00      	cmp	r3, #0
  221972:	d007      	beq.n	221984 <dir_register+0xd8>
  221974:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  221976:	330c      	adds	r3, #12
  221978:	4a47      	ldr	r2, [pc, #284]	; (221a98 <dir_register+0x1ec>)
  22197a:	fba2 2303 	umull	r2, r3, r2, r3
  22197e:	089b      	lsrs	r3, r3, #2
  221980:	3301      	adds	r3, #1
  221982:	e000      	b.n	221986 <dir_register+0xda>
  221984:	2301      	movs	r3, #1
  221986:	623b      	str	r3, [r7, #32]
	res = dir_alloc(dp, nent);		/* Allocate entries */
  221988:	6a39      	ldr	r1, [r7, #32]
  22198a:	6878      	ldr	r0, [r7, #4]
  22198c:	f7ff fcc0 	bl	221310 <dir_alloc>
  221990:	4603      	mov	r3, r0
  221992:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
  221996:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  22199a:	2b00      	cmp	r3, #0
  22199c:	d148      	bne.n	221a30 <dir_register+0x184>
  22199e:	6a3b      	ldr	r3, [r7, #32]
  2219a0:	3b01      	subs	r3, #1
  2219a2:	623b      	str	r3, [r7, #32]
  2219a4:	6a3b      	ldr	r3, [r7, #32]
  2219a6:	2b00      	cmp	r3, #0
  2219a8:	d042      	beq.n	221a30 <dir_register+0x184>
		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
  2219aa:	687b      	ldr	r3, [r7, #4]
  2219ac:	695a      	ldr	r2, [r3, #20]
  2219ae:	6a3b      	ldr	r3, [r7, #32]
  2219b0:	015b      	lsls	r3, r3, #5
  2219b2:	1ad3      	subs	r3, r2, r3
  2219b4:	4619      	mov	r1, r3
  2219b6:	6878      	ldr	r0, [r7, #4]
  2219b8:	f7ff fb6a 	bl	221090 <dir_sdi>
  2219bc:	4603      	mov	r3, r0
  2219be:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (res == FR_OK) {
  2219c2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  2219c6:	2b00      	cmp	r3, #0
  2219c8:	d132      	bne.n	221a30 <dir_register+0x184>
			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
  2219ca:	687b      	ldr	r3, [r7, #4]
  2219cc:	3324      	adds	r3, #36	; 0x24
  2219ce:	4618      	mov	r0, r3
  2219d0:	f7ff fe8a 	bl	2216e8 <sum_sfn>
  2219d4:	4603      	mov	r3, r0
  2219d6:	76fb      	strb	r3, [r7, #27]
			do {					/* Store LFN entries in bottom first */
				res = move_window(fs, dp->sect);
  2219d8:	687b      	ldr	r3, [r7, #4]
  2219da:	69db      	ldr	r3, [r3, #28]
  2219dc:	4619      	mov	r1, r3
  2219de:	69f8      	ldr	r0, [r7, #28]
  2219e0:	f7fe ffde 	bl	2209a0 <move_window>
  2219e4:	4603      	mov	r3, r0
  2219e6:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
				if (res != FR_OK) break;
  2219ea:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  2219ee:	2b00      	cmp	r3, #0
  2219f0:	d11d      	bne.n	221a2e <dir_register+0x182>
				put_lfn(fs->lfnbuf, dp->dir, (BYTE)nent, sum);
  2219f2:	69fb      	ldr	r3, [r7, #28]
  2219f4:	68d8      	ldr	r0, [r3, #12]
  2219f6:	687b      	ldr	r3, [r7, #4]
  2219f8:	6a19      	ldr	r1, [r3, #32]
  2219fa:	6a3b      	ldr	r3, [r7, #32]
  2219fc:	b2da      	uxtb	r2, r3
  2219fe:	7efb      	ldrb	r3, [r7, #27]
  221a00:	f7ff fd7c 	bl	2214fc <put_lfn>
				fs->wflag = 1;
  221a04:	69fb      	ldr	r3, [r7, #28]
  221a06:	2201      	movs	r2, #1
  221a08:	70da      	strb	r2, [r3, #3]
				res = dir_next(dp, 0);	/* Next entry */
  221a0a:	2100      	movs	r1, #0
  221a0c:	6878      	ldr	r0, [r7, #4]
  221a0e:	f7ff fbba 	bl	221186 <dir_next>
  221a12:	4603      	mov	r3, r0
  221a14:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			} while (res == FR_OK && --nent);
  221a18:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221a1c:	2b00      	cmp	r3, #0
  221a1e:	d107      	bne.n	221a30 <dir_register+0x184>
  221a20:	6a3b      	ldr	r3, [r7, #32]
  221a22:	3b01      	subs	r3, #1
  221a24:	623b      	str	r3, [r7, #32]
  221a26:	6a3b      	ldr	r3, [r7, #32]
  221a28:	2b00      	cmp	r3, #0
  221a2a:	d1d5      	bne.n	2219d8 <dir_register+0x12c>
  221a2c:	e000      	b.n	221a30 <dir_register+0x184>
				if (res != FR_OK) break;
  221a2e:	bf00      	nop
	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */

#endif

	/* Set SFN entry */
	if (res == FR_OK) {
  221a30:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221a34:	2b00      	cmp	r3, #0
  221a36:	d128      	bne.n	221a8a <dir_register+0x1de>
		res = move_window(fs, dp->sect);
  221a38:	687b      	ldr	r3, [r7, #4]
  221a3a:	69db      	ldr	r3, [r3, #28]
  221a3c:	4619      	mov	r1, r3
  221a3e:	69f8      	ldr	r0, [r7, #28]
  221a40:	f7fe ffae 	bl	2209a0 <move_window>
  221a44:	4603      	mov	r3, r0
  221a46:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
		if (res == FR_OK) {
  221a4a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  221a4e:	2b00      	cmp	r3, #0
  221a50:	d11b      	bne.n	221a8a <dir_register+0x1de>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
  221a52:	687b      	ldr	r3, [r7, #4]
  221a54:	6a1b      	ldr	r3, [r3, #32]
  221a56:	2220      	movs	r2, #32
  221a58:	2100      	movs	r1, #0
  221a5a:	4618      	mov	r0, r3
  221a5c:	f7fe fd63 	bl	220526 <mem_set>
			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
  221a60:	687b      	ldr	r3, [r7, #4]
  221a62:	6a18      	ldr	r0, [r3, #32]
  221a64:	687b      	ldr	r3, [r7, #4]
  221a66:	3324      	adds	r3, #36	; 0x24
  221a68:	220b      	movs	r2, #11
  221a6a:	4619      	mov	r1, r3
  221a6c:	f7fe fd3a 	bl	2204e4 <mem_cpy>
#if _USE_LFN != 0
			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
  221a70:	687b      	ldr	r3, [r7, #4]
  221a72:	6a1b      	ldr	r3, [r3, #32]
  221a74:	330c      	adds	r3, #12
  221a76:	687a      	ldr	r2, [r7, #4]
  221a78:	f892 202f 	ldrb.w	r2, [r2, #47]	; 0x2f
  221a7c:	f002 0218 	and.w	r2, r2, #24
  221a80:	b2d2      	uxtb	r2, r2
  221a82:	701a      	strb	r2, [r3, #0]
#endif
			fs->wflag = 1;
  221a84:	69fb      	ldr	r3, [r7, #28]
  221a86:	2201      	movs	r2, #1
  221a88:	70da      	strb	r2, [r3, #3]
		}
	}

	return res;
  221a8a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
  221a8e:	4618      	mov	r0, r3
  221a90:	3730      	adds	r7, #48	; 0x30
  221a92:	46bd      	mov	sp, r7
  221a94:	bd80      	pop	{r7, pc}
  221a96:	bf00      	nop
  221a98:	4ec4ec4f 	.word	0x4ec4ec4f

00221a9c <get_fileinfo>:
static
void get_fileinfo (		/* No return code */
	DIR* dp,			/* Pointer to the directory object */
	FILINFO* fno	 	/* Pointer to the file information to be filled */
)
{
  221a9c:	b580      	push	{r7, lr}
  221a9e:	b088      	sub	sp, #32
  221aa0:	af00      	add	r7, sp, #0
  221aa2:	6078      	str	r0, [r7, #4]
  221aa4:	6039      	str	r1, [r7, #0]
	UINT i, j;
	TCHAR c;
	DWORD tm;
#if _USE_LFN != 0
	WCHAR w, lfv;
	FATFS *fs = dp->obj.fs;
  221aa6:	687b      	ldr	r3, [r7, #4]
  221aa8:	681b      	ldr	r3, [r3, #0]
  221aaa:	613b      	str	r3, [r7, #16]
#endif


	fno->fname[0] = 0;		/* Invaidate file info */
  221aac:	683b      	ldr	r3, [r7, #0]
  221aae:	2200      	movs	r2, #0
  221ab0:	759a      	strb	r2, [r3, #22]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
  221ab2:	687b      	ldr	r3, [r7, #4]
  221ab4:	69db      	ldr	r3, [r3, #28]
  221ab6:	2b00      	cmp	r3, #0
  221ab8:	f000 80c9 	beq.w	221c4e <get_fileinfo+0x1b2>
		get_xdir_info(fs->dirbuf, fno);
		return;
	} else
#endif
	{	/* On the FAT12/16/32 volume */
		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
  221abc:	687b      	ldr	r3, [r7, #4]
  221abe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  221ac0:	f1b3 3fff 	cmp.w	r3, #4294967295
  221ac4:	d032      	beq.n	221b2c <get_fileinfo+0x90>
			i = j = 0;
  221ac6:	2300      	movs	r3, #0
  221ac8:	61bb      	str	r3, [r7, #24]
  221aca:	69bb      	ldr	r3, [r7, #24]
  221acc:	61fb      	str	r3, [r7, #28]
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
  221ace:	e01b      	b.n	221b08 <get_fileinfo+0x6c>
#if !_LFN_UNICODE
				w = ff_convert(w, 0);		/* Unicode -> OEM */
  221ad0:	89fb      	ldrh	r3, [r7, #14]
  221ad2:	2100      	movs	r1, #0
  221ad4:	4618      	mov	r0, r3
  221ad6:	f001 fcd9 	bl	22348c <ff_convert>
  221ada:	4603      	mov	r3, r0
  221adc:	81fb      	strh	r3, [r7, #14]
				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
  221ade:	89fb      	ldrh	r3, [r7, #14]
  221ae0:	2b00      	cmp	r3, #0
  221ae2:	d102      	bne.n	221aea <get_fileinfo+0x4e>
  221ae4:	2300      	movs	r3, #0
  221ae6:	61fb      	str	r3, [r7, #28]
  221ae8:	e01a      	b.n	221b20 <get_fileinfo+0x84>
				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
					fno->fname[i++] = (char)(w >> 8);
				}
#endif
				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
  221aea:	69fb      	ldr	r3, [r7, #28]
  221aec:	2bfe      	cmp	r3, #254	; 0xfe
  221aee:	d902      	bls.n	221af6 <get_fileinfo+0x5a>
  221af0:	2300      	movs	r3, #0
  221af2:	61fb      	str	r3, [r7, #28]
  221af4:	e014      	b.n	221b20 <get_fileinfo+0x84>
				fno->fname[i++] = (TCHAR)w;
  221af6:	69fb      	ldr	r3, [r7, #28]
  221af8:	1c5a      	adds	r2, r3, #1
  221afa:	61fa      	str	r2, [r7, #28]
  221afc:	89fa      	ldrh	r2, [r7, #14]
  221afe:	b2d1      	uxtb	r1, r2
  221b00:	683a      	ldr	r2, [r7, #0]
  221b02:	4413      	add	r3, r2
  221b04:	460a      	mov	r2, r1
  221b06:	759a      	strb	r2, [r3, #22]
			while ((w = fs->lfnbuf[j++]) != 0) {	/* Get an LFN character */
  221b08:	693b      	ldr	r3, [r7, #16]
  221b0a:	68da      	ldr	r2, [r3, #12]
  221b0c:	69bb      	ldr	r3, [r7, #24]
  221b0e:	1c59      	adds	r1, r3, #1
  221b10:	61b9      	str	r1, [r7, #24]
  221b12:	005b      	lsls	r3, r3, #1
  221b14:	4413      	add	r3, r2
  221b16:	881b      	ldrh	r3, [r3, #0]
  221b18:	81fb      	strh	r3, [r7, #14]
  221b1a:	89fb      	ldrh	r3, [r7, #14]
  221b1c:	2b00      	cmp	r3, #0
  221b1e:	d1d7      	bne.n	221ad0 <get_fileinfo+0x34>
			}
			fno->fname[i] = 0;	/* Terminate the LFN */
  221b20:	683a      	ldr	r2, [r7, #0]
  221b22:	69fb      	ldr	r3, [r7, #28]
  221b24:	4413      	add	r3, r2
  221b26:	3316      	adds	r3, #22
  221b28:	2200      	movs	r2, #0
  221b2a:	701a      	strb	r2, [r3, #0]
		}
	}

	i = j = 0;
  221b2c:	2300      	movs	r3, #0
  221b2e:	61bb      	str	r3, [r7, #24]
  221b30:	69bb      	ldr	r3, [r7, #24]
  221b32:	61fb      	str	r3, [r7, #28]
	lfv = fno->fname[i];	/* LFN is exist if non-zero */
  221b34:	683a      	ldr	r2, [r7, #0]
  221b36:	69fb      	ldr	r3, [r7, #28]
  221b38:	4413      	add	r3, r2
  221b3a:	3316      	adds	r3, #22
  221b3c:	781b      	ldrb	r3, [r3, #0]
  221b3e:	81bb      	strh	r3, [r7, #12]
	while (i < 11) {		/* Copy name body and extension */
  221b40:	e04c      	b.n	221bdc <get_fileinfo+0x140>
		c = (TCHAR)dp->dir[i++];
  221b42:	687b      	ldr	r3, [r7, #4]
  221b44:	6a1a      	ldr	r2, [r3, #32]
  221b46:	69fb      	ldr	r3, [r7, #28]
  221b48:	1c59      	adds	r1, r3, #1
  221b4a:	61f9      	str	r1, [r7, #28]
  221b4c:	4413      	add	r3, r2
  221b4e:	781b      	ldrb	r3, [r3, #0]
  221b50:	75fb      	strb	r3, [r7, #23]
		if (c == ' ') continue;				/* Skip padding spaces */
  221b52:	7dfb      	ldrb	r3, [r7, #23]
  221b54:	2b20      	cmp	r3, #32
  221b56:	d100      	bne.n	221b5a <get_fileinfo+0xbe>
  221b58:	e040      	b.n	221bdc <get_fileinfo+0x140>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
  221b5a:	7dfb      	ldrb	r3, [r7, #23]
  221b5c:	2b05      	cmp	r3, #5
  221b5e:	d101      	bne.n	221b64 <get_fileinfo+0xc8>
  221b60:	23e5      	movs	r3, #229	; 0xe5
  221b62:	75fb      	strb	r3, [r7, #23]
		if (i == 9) {						/* Insert a . if extension is exist */
  221b64:	69fb      	ldr	r3, [r7, #28]
  221b66:	2b09      	cmp	r3, #9
  221b68:	d10f      	bne.n	221b8a <get_fileinfo+0xee>
			if (!lfv) fno->fname[j] = '.';
  221b6a:	89bb      	ldrh	r3, [r7, #12]
  221b6c:	2b00      	cmp	r3, #0
  221b6e:	d105      	bne.n	221b7c <get_fileinfo+0xe0>
  221b70:	683a      	ldr	r2, [r7, #0]
  221b72:	69bb      	ldr	r3, [r7, #24]
  221b74:	4413      	add	r3, r2
  221b76:	3316      	adds	r3, #22
  221b78:	222e      	movs	r2, #46	; 0x2e
  221b7a:	701a      	strb	r2, [r3, #0]
			fno->altname[j++] = '.';
  221b7c:	69bb      	ldr	r3, [r7, #24]
  221b7e:	1c5a      	adds	r2, r3, #1
  221b80:	61ba      	str	r2, [r7, #24]
  221b82:	683a      	ldr	r2, [r7, #0]
  221b84:	4413      	add	r3, r2
  221b86:	222e      	movs	r2, #46	; 0x2e
  221b88:	725a      	strb	r2, [r3, #9]
			c = c << 8 | dp->dir[i++];
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
		fno->altname[j] = c;
  221b8a:	683a      	ldr	r2, [r7, #0]
  221b8c:	69bb      	ldr	r3, [r7, #24]
  221b8e:	4413      	add	r3, r2
  221b90:	3309      	adds	r3, #9
  221b92:	7dfa      	ldrb	r2, [r7, #23]
  221b94:	701a      	strb	r2, [r3, #0]
		if (!lfv) {
  221b96:	89bb      	ldrh	r3, [r7, #12]
  221b98:	2b00      	cmp	r3, #0
  221b9a:	d11c      	bne.n	221bd6 <get_fileinfo+0x13a>
			if (IsUpper(c) && (dp->dir[DIR_NTres] & ((i >= 9) ? NS_EXT : NS_BODY))) {
  221b9c:	7dfb      	ldrb	r3, [r7, #23]
  221b9e:	2b40      	cmp	r3, #64	; 0x40
  221ba0:	d913      	bls.n	221bca <get_fileinfo+0x12e>
  221ba2:	7dfb      	ldrb	r3, [r7, #23]
  221ba4:	2b5a      	cmp	r3, #90	; 0x5a
  221ba6:	d810      	bhi.n	221bca <get_fileinfo+0x12e>
  221ba8:	687b      	ldr	r3, [r7, #4]
  221baa:	6a1b      	ldr	r3, [r3, #32]
  221bac:	330c      	adds	r3, #12
  221bae:	781b      	ldrb	r3, [r3, #0]
  221bb0:	461a      	mov	r2, r3
  221bb2:	69fb      	ldr	r3, [r7, #28]
  221bb4:	2b08      	cmp	r3, #8
  221bb6:	d901      	bls.n	221bbc <get_fileinfo+0x120>
  221bb8:	2310      	movs	r3, #16
  221bba:	e000      	b.n	221bbe <get_fileinfo+0x122>
  221bbc:	2308      	movs	r3, #8
  221bbe:	4013      	ands	r3, r2
  221bc0:	2b00      	cmp	r3, #0
  221bc2:	d002      	beq.n	221bca <get_fileinfo+0x12e>
				c += 0x20;			/* To lower */
  221bc4:	7dfb      	ldrb	r3, [r7, #23]
  221bc6:	3320      	adds	r3, #32
  221bc8:	75fb      	strb	r3, [r7, #23]
			}
			fno->fname[j] = c;
  221bca:	683a      	ldr	r2, [r7, #0]
  221bcc:	69bb      	ldr	r3, [r7, #24]
  221bce:	4413      	add	r3, r2
  221bd0:	3316      	adds	r3, #22
  221bd2:	7dfa      	ldrb	r2, [r7, #23]
  221bd4:	701a      	strb	r2, [r3, #0]
		}
		j++;
  221bd6:	69bb      	ldr	r3, [r7, #24]
  221bd8:	3301      	adds	r3, #1
  221bda:	61bb      	str	r3, [r7, #24]
	while (i < 11) {		/* Copy name body and extension */
  221bdc:	69fb      	ldr	r3, [r7, #28]
  221bde:	2b0a      	cmp	r3, #10
  221be0:	d9af      	bls.n	221b42 <get_fileinfo+0xa6>
	}
	if (!lfv) {
  221be2:	89bb      	ldrh	r3, [r7, #12]
  221be4:	2b00      	cmp	r3, #0
  221be6:	d10d      	bne.n	221c04 <get_fileinfo+0x168>
		fno->fname[j] = 0;
  221be8:	683a      	ldr	r2, [r7, #0]
  221bea:	69bb      	ldr	r3, [r7, #24]
  221bec:	4413      	add	r3, r2
  221bee:	3316      	adds	r3, #22
  221bf0:	2200      	movs	r2, #0
  221bf2:	701a      	strb	r2, [r3, #0]
		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
  221bf4:	687b      	ldr	r3, [r7, #4]
  221bf6:	6a1b      	ldr	r3, [r3, #32]
  221bf8:	330c      	adds	r3, #12
  221bfa:	781b      	ldrb	r3, [r3, #0]
  221bfc:	2b00      	cmp	r3, #0
  221bfe:	d101      	bne.n	221c04 <get_fileinfo+0x168>
  221c00:	2300      	movs	r3, #0
  221c02:	61bb      	str	r3, [r7, #24]
	}
	fno->altname[j] = 0;	/* Terminate the SFN */
  221c04:	683a      	ldr	r2, [r7, #0]
  221c06:	69bb      	ldr	r3, [r7, #24]
  221c08:	4413      	add	r3, r2
  221c0a:	3309      	adds	r3, #9
  221c0c:	2200      	movs	r2, #0
  221c0e:	701a      	strb	r2, [r3, #0]
		fno->fname[j++] = c;
	}
	fno->fname[j] = 0;
#endif

	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
  221c10:	687b      	ldr	r3, [r7, #4]
  221c12:	6a1b      	ldr	r3, [r3, #32]
  221c14:	7ada      	ldrb	r2, [r3, #11]
  221c16:	683b      	ldr	r3, [r7, #0]
  221c18:	721a      	strb	r2, [r3, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
  221c1a:	687b      	ldr	r3, [r7, #4]
  221c1c:	6a1b      	ldr	r3, [r3, #32]
  221c1e:	331c      	adds	r3, #28
  221c20:	4618      	mov	r0, r3
  221c22:	f7fe fbf5 	bl	220410 <ld_dword>
  221c26:	4602      	mov	r2, r0
  221c28:	683b      	ldr	r3, [r7, #0]
  221c2a:	601a      	str	r2, [r3, #0]
	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
  221c2c:	687b      	ldr	r3, [r7, #4]
  221c2e:	6a1b      	ldr	r3, [r3, #32]
  221c30:	3316      	adds	r3, #22
  221c32:	4618      	mov	r0, r3
  221c34:	f7fe fbec 	bl	220410 <ld_dword>
  221c38:	60b8      	str	r0, [r7, #8]
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
  221c3a:	68bb      	ldr	r3, [r7, #8]
  221c3c:	b29a      	uxth	r2, r3
  221c3e:	683b      	ldr	r3, [r7, #0]
  221c40:	80da      	strh	r2, [r3, #6]
  221c42:	68bb      	ldr	r3, [r7, #8]
  221c44:	0c1b      	lsrs	r3, r3, #16
  221c46:	b29a      	uxth	r2, r3
  221c48:	683b      	ldr	r3, [r7, #0]
  221c4a:	809a      	strh	r2, [r3, #4]
  221c4c:	e000      	b.n	221c50 <get_fileinfo+0x1b4>
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
  221c4e:	bf00      	nop
}
  221c50:	3720      	adds	r7, #32
  221c52:	46bd      	mov	sp, r7
  221c54:	bd80      	pop	{r7, pc}
	...

00221c58 <create_name>:
static
FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
	DIR* dp,			/* Pointer to the directory object */
	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
)
{
  221c58:	b580      	push	{r7, lr}
  221c5a:	b08a      	sub	sp, #40	; 0x28
  221c5c:	af00      	add	r7, sp, #0
  221c5e:	6078      	str	r0, [r7, #4]
  221c60:	6039      	str	r1, [r7, #0]
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	p = *path; lfn = dp->obj.fs->lfnbuf; si = di = 0;
  221c62:	683b      	ldr	r3, [r7, #0]
  221c64:	681b      	ldr	r3, [r3, #0]
  221c66:	613b      	str	r3, [r7, #16]
  221c68:	687b      	ldr	r3, [r7, #4]
  221c6a:	681b      	ldr	r3, [r3, #0]
  221c6c:	68db      	ldr	r3, [r3, #12]
  221c6e:	60fb      	str	r3, [r7, #12]
  221c70:	2300      	movs	r3, #0
  221c72:	617b      	str	r3, [r7, #20]
  221c74:	697b      	ldr	r3, [r7, #20]
  221c76:	61bb      	str	r3, [r7, #24]
	for (;;) {
		w = p[si++];					/* Get a character */
  221c78:	69bb      	ldr	r3, [r7, #24]
  221c7a:	1c5a      	adds	r2, r3, #1
  221c7c:	61ba      	str	r2, [r7, #24]
  221c7e:	693a      	ldr	r2, [r7, #16]
  221c80:	4413      	add	r3, r2
  221c82:	781b      	ldrb	r3, [r3, #0]
  221c84:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (w < ' ') break;				/* Break if end of the path name */
  221c86:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221c88:	2b1f      	cmp	r3, #31
  221c8a:	d940      	bls.n	221d0e <create_name+0xb6>
		if (w == '/' || w == '\\') {	/* Break if a separator is found */
  221c8c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221c8e:	2b2f      	cmp	r3, #47	; 0x2f
  221c90:	d006      	beq.n	221ca0 <create_name+0x48>
  221c92:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221c94:	2b5c      	cmp	r3, #92	; 0x5c
  221c96:	d110      	bne.n	221cba <create_name+0x62>
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
  221c98:	e002      	b.n	221ca0 <create_name+0x48>
  221c9a:	69bb      	ldr	r3, [r7, #24]
  221c9c:	3301      	adds	r3, #1
  221c9e:	61bb      	str	r3, [r7, #24]
  221ca0:	693a      	ldr	r2, [r7, #16]
  221ca2:	69bb      	ldr	r3, [r7, #24]
  221ca4:	4413      	add	r3, r2
  221ca6:	781b      	ldrb	r3, [r3, #0]
  221ca8:	2b2f      	cmp	r3, #47	; 0x2f
  221caa:	d0f6      	beq.n	221c9a <create_name+0x42>
  221cac:	693a      	ldr	r2, [r7, #16]
  221cae:	69bb      	ldr	r3, [r7, #24]
  221cb0:	4413      	add	r3, r2
  221cb2:	781b      	ldrb	r3, [r3, #0]
  221cb4:	2b5c      	cmp	r3, #92	; 0x5c
  221cb6:	d0f0      	beq.n	221c9a <create_name+0x42>
			break;
  221cb8:	e02a      	b.n	221d10 <create_name+0xb8>
		}
		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
  221cba:	697b      	ldr	r3, [r7, #20]
  221cbc:	2bfe      	cmp	r3, #254	; 0xfe
  221cbe:	d901      	bls.n	221cc4 <create_name+0x6c>
  221cc0:	2306      	movs	r3, #6
  221cc2:	e177      	b.n	221fb4 <create_name+0x35c>
#if !_LFN_UNICODE
		w &= 0xFF;
  221cc4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221cc6:	b2db      	uxtb	r3, r3
  221cc8:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			b = (BYTE)p[si++];			/* Get 2nd byte */
			w = (w << 8) + b;			/* Create a DBC */
			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  221cca:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221ccc:	2101      	movs	r1, #1
  221cce:	4618      	mov	r0, r3
  221cd0:	f001 fbdc 	bl	22348c <ff_convert>
  221cd4:	4603      	mov	r3, r0
  221cd6:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  221cd8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221cda:	2b00      	cmp	r3, #0
  221cdc:	d101      	bne.n	221ce2 <create_name+0x8a>
  221cde:	2306      	movs	r3, #6
  221ce0:	e168      	b.n	221fb4 <create_name+0x35c>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
  221ce2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221ce4:	2b7f      	cmp	r3, #127	; 0x7f
  221ce6:	d809      	bhi.n	221cfc <create_name+0xa4>
  221ce8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221cea:	4619      	mov	r1, r3
  221cec:	48b3      	ldr	r0, [pc, #716]	; (221fbc <create_name+0x364>)
  221cee:	f7fe fc5b 	bl	2205a8 <chk_chr>
  221cf2:	4603      	mov	r3, r0
  221cf4:	2b00      	cmp	r3, #0
  221cf6:	d001      	beq.n	221cfc <create_name+0xa4>
  221cf8:	2306      	movs	r3, #6
  221cfa:	e15b      	b.n	221fb4 <create_name+0x35c>
		lfn[di++] = w;					/* Store the Unicode character */
  221cfc:	697b      	ldr	r3, [r7, #20]
  221cfe:	1c5a      	adds	r2, r3, #1
  221d00:	617a      	str	r2, [r7, #20]
  221d02:	005b      	lsls	r3, r3, #1
  221d04:	68fa      	ldr	r2, [r7, #12]
  221d06:	4413      	add	r3, r2
  221d08:	8cba      	ldrh	r2, [r7, #36]	; 0x24
  221d0a:	801a      	strh	r2, [r3, #0]
		w = p[si++];					/* Get a character */
  221d0c:	e7b4      	b.n	221c78 <create_name+0x20>
		if (w < ' ') break;				/* Break if end of the path name */
  221d0e:	bf00      	nop
	}
	*path = &p[si];						/* Return pointer to the next segment */
  221d10:	693a      	ldr	r2, [r7, #16]
  221d12:	69bb      	ldr	r3, [r7, #24]
  221d14:	441a      	add	r2, r3
  221d16:	683b      	ldr	r3, [r7, #0]
  221d18:	601a      	str	r2, [r3, #0]
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
  221d1a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221d1c:	2b1f      	cmp	r3, #31
  221d1e:	d801      	bhi.n	221d24 <create_name+0xcc>
  221d20:	2304      	movs	r3, #4
  221d22:	e000      	b.n	221d26 <create_name+0xce>
  221d24:	2300      	movs	r3, #0
  221d26:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			dp->fn[i] = (i < di) ? '.' : ' ';
		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Snip off trailing spaces and dots if exist */
  221d2a:	e011      	b.n	221d50 <create_name+0xf8>
		w = lfn[di - 1];
  221d2c:	697a      	ldr	r2, [r7, #20]
  221d2e:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  221d32:	4413      	add	r3, r2
  221d34:	005b      	lsls	r3, r3, #1
  221d36:	68fa      	ldr	r2, [r7, #12]
  221d38:	4413      	add	r3, r2
  221d3a:	881b      	ldrh	r3, [r3, #0]
  221d3c:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (w != ' ' && w != '.') break;
  221d3e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221d40:	2b20      	cmp	r3, #32
  221d42:	d002      	beq.n	221d4a <create_name+0xf2>
  221d44:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221d46:	2b2e      	cmp	r3, #46	; 0x2e
  221d48:	d106      	bne.n	221d58 <create_name+0x100>
		di--;
  221d4a:	697b      	ldr	r3, [r7, #20]
  221d4c:	3b01      	subs	r3, #1
  221d4e:	617b      	str	r3, [r7, #20]
	while (di) {						/* Snip off trailing spaces and dots if exist */
  221d50:	697b      	ldr	r3, [r7, #20]
  221d52:	2b00      	cmp	r3, #0
  221d54:	d1ea      	bne.n	221d2c <create_name+0xd4>
  221d56:	e000      	b.n	221d5a <create_name+0x102>
		if (w != ' ' && w != '.') break;
  221d58:	bf00      	nop
	}
	lfn[di] = 0;						/* LFN is created */
  221d5a:	697b      	ldr	r3, [r7, #20]
  221d5c:	005b      	lsls	r3, r3, #1
  221d5e:	68fa      	ldr	r2, [r7, #12]
  221d60:	4413      	add	r3, r2
  221d62:	2200      	movs	r2, #0
  221d64:	801a      	strh	r2, [r3, #0]
	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
  221d66:	697b      	ldr	r3, [r7, #20]
  221d68:	2b00      	cmp	r3, #0
  221d6a:	d101      	bne.n	221d70 <create_name+0x118>
  221d6c:	2306      	movs	r3, #6
  221d6e:	e121      	b.n	221fb4 <create_name+0x35c>

	/* Create SFN in directory form */
	mem_set(dp->fn, ' ', 11);
  221d70:	687b      	ldr	r3, [r7, #4]
  221d72:	3324      	adds	r3, #36	; 0x24
  221d74:	220b      	movs	r2, #11
  221d76:	2120      	movs	r1, #32
  221d78:	4618      	mov	r0, r3
  221d7a:	f7fe fbd4 	bl	220526 <mem_set>
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  221d7e:	2300      	movs	r3, #0
  221d80:	61bb      	str	r3, [r7, #24]
  221d82:	e002      	b.n	221d8a <create_name+0x132>
  221d84:	69bb      	ldr	r3, [r7, #24]
  221d86:	3301      	adds	r3, #1
  221d88:	61bb      	str	r3, [r7, #24]
  221d8a:	69bb      	ldr	r3, [r7, #24]
  221d8c:	005b      	lsls	r3, r3, #1
  221d8e:	68fa      	ldr	r2, [r7, #12]
  221d90:	4413      	add	r3, r2
  221d92:	881b      	ldrh	r3, [r3, #0]
  221d94:	2b20      	cmp	r3, #32
  221d96:	d0f5      	beq.n	221d84 <create_name+0x12c>
  221d98:	69bb      	ldr	r3, [r7, #24]
  221d9a:	005b      	lsls	r3, r3, #1
  221d9c:	68fa      	ldr	r2, [r7, #12]
  221d9e:	4413      	add	r3, r2
  221da0:	881b      	ldrh	r3, [r3, #0]
  221da2:	2b2e      	cmp	r3, #46	; 0x2e
  221da4:	d0ee      	beq.n	221d84 <create_name+0x12c>
	if (si) cf |= NS_LOSS | NS_LFN;
  221da6:	69bb      	ldr	r3, [r7, #24]
  221da8:	2b00      	cmp	r3, #0
  221daa:	d009      	beq.n	221dc0 <create_name+0x168>
  221dac:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221db0:	f043 0303 	orr.w	r3, r3, #3
  221db4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  221db8:	e002      	b.n	221dc0 <create_name+0x168>
  221dba:	697b      	ldr	r3, [r7, #20]
  221dbc:	3b01      	subs	r3, #1
  221dbe:	617b      	str	r3, [r7, #20]
  221dc0:	697b      	ldr	r3, [r7, #20]
  221dc2:	2b00      	cmp	r3, #0
  221dc4:	d009      	beq.n	221dda <create_name+0x182>
  221dc6:	697a      	ldr	r2, [r7, #20]
  221dc8:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
  221dcc:	4413      	add	r3, r2
  221dce:	005b      	lsls	r3, r3, #1
  221dd0:	68fa      	ldr	r2, [r7, #12]
  221dd2:	4413      	add	r3, r2
  221dd4:	881b      	ldrh	r3, [r3, #0]
  221dd6:	2b2e      	cmp	r3, #46	; 0x2e
  221dd8:	d1ef      	bne.n	221dba <create_name+0x162>

	i = b = 0; ni = 8;
  221dda:	2300      	movs	r3, #0
  221ddc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  221de0:	2300      	movs	r3, #0
  221de2:	623b      	str	r3, [r7, #32]
  221de4:	2308      	movs	r3, #8
  221de6:	61fb      	str	r3, [r7, #28]
	for (;;) {
		w = lfn[si++];					/* Get an LFN character */
  221de8:	69bb      	ldr	r3, [r7, #24]
  221dea:	1c5a      	adds	r2, r3, #1
  221dec:	61ba      	str	r2, [r7, #24]
  221dee:	005b      	lsls	r3, r3, #1
  221df0:	68fa      	ldr	r2, [r7, #12]
  221df2:	4413      	add	r3, r2
  221df4:	881b      	ldrh	r3, [r3, #0]
  221df6:	84bb      	strh	r3, [r7, #36]	; 0x24
		if (!w) break;					/* Break on end of the LFN */
  221df8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221dfa:	2b00      	cmp	r3, #0
  221dfc:	f000 8090 	beq.w	221f20 <create_name+0x2c8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  221e00:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221e02:	2b20      	cmp	r3, #32
  221e04:	d006      	beq.n	221e14 <create_name+0x1bc>
  221e06:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221e08:	2b2e      	cmp	r3, #46	; 0x2e
  221e0a:	d10a      	bne.n	221e22 <create_name+0x1ca>
  221e0c:	69ba      	ldr	r2, [r7, #24]
  221e0e:	697b      	ldr	r3, [r7, #20]
  221e10:	429a      	cmp	r2, r3
  221e12:	d006      	beq.n	221e22 <create_name+0x1ca>
			cf |= NS_LOSS | NS_LFN; continue;
  221e14:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221e18:	f043 0303 	orr.w	r3, r3, #3
  221e1c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  221e20:	e07d      	b.n	221f1e <create_name+0x2c6>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  221e22:	6a3a      	ldr	r2, [r7, #32]
  221e24:	69fb      	ldr	r3, [r7, #28]
  221e26:	429a      	cmp	r2, r3
  221e28:	d203      	bcs.n	221e32 <create_name+0x1da>
  221e2a:	69ba      	ldr	r2, [r7, #24]
  221e2c:	697b      	ldr	r3, [r7, #20]
  221e2e:	429a      	cmp	r2, r3
  221e30:	d123      	bne.n	221e7a <create_name+0x222>
			if (ni == 11) {				/* Long extension */
  221e32:	69fb      	ldr	r3, [r7, #28]
  221e34:	2b0b      	cmp	r3, #11
  221e36:	d106      	bne.n	221e46 <create_name+0x1ee>
				cf |= NS_LOSS | NS_LFN; break;
  221e38:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221e3c:	f043 0303 	orr.w	r3, r3, #3
  221e40:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  221e44:	e06f      	b.n	221f26 <create_name+0x2ce>
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  221e46:	69ba      	ldr	r2, [r7, #24]
  221e48:	697b      	ldr	r3, [r7, #20]
  221e4a:	429a      	cmp	r2, r3
  221e4c:	d005      	beq.n	221e5a <create_name+0x202>
  221e4e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221e52:	f043 0303 	orr.w	r3, r3, #3
  221e56:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			if (si > di) break;			/* No extension */
  221e5a:	69ba      	ldr	r2, [r7, #24]
  221e5c:	697b      	ldr	r3, [r7, #20]
  221e5e:	429a      	cmp	r2, r3
  221e60:	d860      	bhi.n	221f24 <create_name+0x2cc>
			si = di; i = 8; ni = 11;	/* Enter extension section */
  221e62:	697b      	ldr	r3, [r7, #20]
  221e64:	61bb      	str	r3, [r7, #24]
  221e66:	2308      	movs	r3, #8
  221e68:	623b      	str	r3, [r7, #32]
  221e6a:	230b      	movs	r3, #11
  221e6c:	61fb      	str	r3, [r7, #28]
			b <<= 2; continue;
  221e6e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221e72:	009b      	lsls	r3, r3, #2
  221e74:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  221e78:	e051      	b.n	221f1e <create_name+0x2c6>
		}

		if (w >= 0x80) {				/* Non ASCII character */
  221e7a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221e7c:	2b7f      	cmp	r3, #127	; 0x7f
  221e7e:	d914      	bls.n	221eaa <create_name+0x252>
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  221e80:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221e82:	2100      	movs	r1, #0
  221e84:	4618      	mov	r0, r3
  221e86:	f001 fb01 	bl	22348c <ff_convert>
  221e8a:	4603      	mov	r3, r0
  221e8c:	84bb      	strh	r3, [r7, #36]	; 0x24
			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
  221e8e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221e90:	2b00      	cmp	r3, #0
  221e92:	d004      	beq.n	221e9e <create_name+0x246>
  221e94:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221e96:	3b80      	subs	r3, #128	; 0x80
  221e98:	4a49      	ldr	r2, [pc, #292]	; (221fc0 <create_name+0x368>)
  221e9a:	5cd3      	ldrb	r3, [r2, r3]
  221e9c:	84bb      	strh	r3, [r7, #36]	; 0x24
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  221e9e:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221ea2:	f043 0302 	orr.w	r3, r3, #2
  221ea6:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dp->fn[i++] = (BYTE)(w >> 8);
		} else {						/* SBC */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
  221eaa:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221eac:	2b00      	cmp	r3, #0
  221eae:	d007      	beq.n	221ec0 <create_name+0x268>
  221eb0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221eb2:	4619      	mov	r1, r3
  221eb4:	4843      	ldr	r0, [pc, #268]	; (221fc4 <create_name+0x36c>)
  221eb6:	f7fe fb77 	bl	2205a8 <chk_chr>
  221eba:	4603      	mov	r3, r0
  221ebc:	2b00      	cmp	r3, #0
  221ebe:	d008      	beq.n	221ed2 <create_name+0x27a>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  221ec0:	235f      	movs	r3, #95	; 0x5f
  221ec2:	84bb      	strh	r3, [r7, #36]	; 0x24
  221ec4:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221ec8:	f043 0303 	orr.w	r3, r3, #3
  221ecc:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
  221ed0:	e01b      	b.n	221f0a <create_name+0x2b2>
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  221ed2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221ed4:	2b40      	cmp	r3, #64	; 0x40
  221ed6:	d909      	bls.n	221eec <create_name+0x294>
  221ed8:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221eda:	2b5a      	cmp	r3, #90	; 0x5a
  221edc:	d806      	bhi.n	221eec <create_name+0x294>
					b |= 2;
  221ede:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221ee2:	f043 0302 	orr.w	r3, r3, #2
  221ee6:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  221eea:	e00e      	b.n	221f0a <create_name+0x2b2>
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  221eec:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221eee:	2b60      	cmp	r3, #96	; 0x60
  221ef0:	d90b      	bls.n	221f0a <create_name+0x2b2>
  221ef2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221ef4:	2b7a      	cmp	r3, #122	; 0x7a
  221ef6:	d808      	bhi.n	221f0a <create_name+0x2b2>
						b |= 1; w -= 0x20;
  221ef8:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221efc:	f043 0301 	orr.w	r3, r3, #1
  221f00:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
  221f04:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  221f06:	3b20      	subs	r3, #32
  221f08:	84bb      	strh	r3, [r7, #36]	; 0x24
					}
				}
			}
		}
		dp->fn[i++] = (BYTE)w;
  221f0a:	6a3b      	ldr	r3, [r7, #32]
  221f0c:	1c5a      	adds	r2, r3, #1
  221f0e:	623a      	str	r2, [r7, #32]
  221f10:	8cba      	ldrh	r2, [r7, #36]	; 0x24
  221f12:	b2d1      	uxtb	r1, r2
  221f14:	687a      	ldr	r2, [r7, #4]
  221f16:	4413      	add	r3, r2
  221f18:	460a      	mov	r2, r1
  221f1a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
		w = lfn[si++];					/* Get an LFN character */
  221f1e:	e763      	b.n	221de8 <create_name+0x190>
		if (!w) break;					/* Break on end of the LFN */
  221f20:	bf00      	nop
  221f22:	e000      	b.n	221f26 <create_name+0x2ce>
			if (si > di) break;			/* No extension */
  221f24:	bf00      	nop
	}

	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
  221f26:	687b      	ldr	r3, [r7, #4]
  221f28:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
  221f2c:	2be5      	cmp	r3, #229	; 0xe5
  221f2e:	d103      	bne.n	221f38 <create_name+0x2e0>
  221f30:	687b      	ldr	r3, [r7, #4]
  221f32:	2205      	movs	r2, #5
  221f34:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

	if (ni == 8) b <<= 2;
  221f38:	69fb      	ldr	r3, [r7, #28]
  221f3a:	2b08      	cmp	r3, #8
  221f3c:	d104      	bne.n	221f48 <create_name+0x2f0>
  221f3e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221f42:	009b      	lsls	r3, r3, #2
  221f44:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
  221f48:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221f4c:	f003 030c 	and.w	r3, r3, #12
  221f50:	2b0c      	cmp	r3, #12
  221f52:	d005      	beq.n	221f60 <create_name+0x308>
  221f54:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221f58:	f003 0303 	and.w	r3, r3, #3
  221f5c:	2b03      	cmp	r3, #3
  221f5e:	d105      	bne.n	221f6c <create_name+0x314>
  221f60:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221f64:	f043 0302 	orr.w	r3, r3, #2
  221f68:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
  221f6c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221f70:	f003 0302 	and.w	r3, r3, #2
  221f74:	2b00      	cmp	r3, #0
  221f76:	d117      	bne.n	221fa8 <create_name+0x350>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  221f78:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221f7c:	f003 0303 	and.w	r3, r3, #3
  221f80:	2b01      	cmp	r3, #1
  221f82:	d105      	bne.n	221f90 <create_name+0x338>
  221f84:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221f88:	f043 0310 	orr.w	r3, r3, #16
  221f8c:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  221f90:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  221f94:	f003 030c 	and.w	r3, r3, #12
  221f98:	2b04      	cmp	r3, #4
  221f9a:	d105      	bne.n	221fa8 <create_name+0x350>
  221f9c:	f897 3026 	ldrb.w	r3, [r7, #38]	; 0x26
  221fa0:	f043 0308 	orr.w	r3, r3, #8
  221fa4:	f887 3026 	strb.w	r3, [r7, #38]	; 0x26
	}

	dp->fn[NSFLAG] = cf;	/* SFN is created */
  221fa8:	687b      	ldr	r3, [r7, #4]
  221faa:	f897 2026 	ldrb.w	r2, [r7, #38]	; 0x26
  221fae:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

	return FR_OK;
  221fb2:	2300      	movs	r3, #0
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */

	return FR_OK;
#endif /* _USE_LFN != 0 */
}
  221fb4:	4618      	mov	r0, r3
  221fb6:	3728      	adds	r7, #40	; 0x28
  221fb8:	46bd      	mov	sp, r7
  221fba:	bd80      	pop	{r7, pc}
  221fbc:	00229210 	.word	0x00229210
  221fc0:	002293a4 	.word	0x002293a4
  221fc4:	0022921c 	.word	0x0022921c

00221fc8 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR* dp,			/* Directory object to return last directory and found object */
	const TCHAR* path	/* Full-path string to find a file or directory */
)
{
  221fc8:	b580      	push	{r7, lr}
  221fca:	b086      	sub	sp, #24
  221fcc:	af00      	add	r7, sp, #0
  221fce:	6078      	str	r0, [r7, #4]
  221fd0:	6039      	str	r1, [r7, #0]
	FRESULT res;
	BYTE ns;
	_FDID *obj = &dp->obj;
  221fd2:	687b      	ldr	r3, [r7, #4]
  221fd4:	613b      	str	r3, [r7, #16]
	FATFS *fs = obj->fs;
  221fd6:	693b      	ldr	r3, [r7, #16]
  221fd8:	681b      	ldr	r3, [r3, #0]
  221fda:	60fb      	str	r3, [r7, #12]
	if (*path != '/' && *path != '\\') {	/* Without heading separator */
		obj->sclust = fs->cdir;				/* Start from current directory */
	} else
#endif
	{										/* With heading separator */
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
  221fdc:	e002      	b.n	221fe4 <follow_path+0x1c>
  221fde:	683b      	ldr	r3, [r7, #0]
  221fe0:	3301      	adds	r3, #1
  221fe2:	603b      	str	r3, [r7, #0]
  221fe4:	683b      	ldr	r3, [r7, #0]
  221fe6:	781b      	ldrb	r3, [r3, #0]
  221fe8:	2b2f      	cmp	r3, #47	; 0x2f
  221fea:	d0f8      	beq.n	221fde <follow_path+0x16>
  221fec:	683b      	ldr	r3, [r7, #0]
  221fee:	781b      	ldrb	r3, [r3, #0]
  221ff0:	2b5c      	cmp	r3, #92	; 0x5c
  221ff2:	d0f4      	beq.n	221fde <follow_path+0x16>
		obj->sclust = 0;					/* Start from root directory */
  221ff4:	693b      	ldr	r3, [r7, #16]
  221ff6:	2200      	movs	r2, #0
  221ff8:	609a      	str	r2, [r3, #8]
		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
	}
#endif
#endif

	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
  221ffa:	683b      	ldr	r3, [r7, #0]
  221ffc:	781b      	ldrb	r3, [r3, #0]
  221ffe:	2b1f      	cmp	r3, #31
  222000:	d80a      	bhi.n	222018 <follow_path+0x50>
		dp->fn[NSFLAG] = NS_NONAME;
  222002:	687b      	ldr	r3, [r7, #4]
  222004:	2280      	movs	r2, #128	; 0x80
  222006:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		res = dir_sdi(dp, 0);
  22200a:	2100      	movs	r1, #0
  22200c:	6878      	ldr	r0, [r7, #4]
  22200e:	f7ff f83f 	bl	221090 <dir_sdi>
  222012:	4603      	mov	r3, r0
  222014:	75fb      	strb	r3, [r7, #23]
  222016:	e043      	b.n	2220a0 <follow_path+0xd8>

	} else {								/* Follow path */
		for (;;) {
			res = create_name(dp, &path);	/* Get a segment name of the path */
  222018:	463b      	mov	r3, r7
  22201a:	4619      	mov	r1, r3
  22201c:	6878      	ldr	r0, [r7, #4]
  22201e:	f7ff fe1b 	bl	221c58 <create_name>
  222022:	4603      	mov	r3, r0
  222024:	75fb      	strb	r3, [r7, #23]
			if (res != FR_OK) break;
  222026:	7dfb      	ldrb	r3, [r7, #23]
  222028:	2b00      	cmp	r3, #0
  22202a:	d134      	bne.n	222096 <follow_path+0xce>
			res = dir_find(dp);				/* Find an object with the segment name */
  22202c:	6878      	ldr	r0, [r7, #4]
  22202e:	f7ff fb7c 	bl	22172a <dir_find>
  222032:	4603      	mov	r3, r0
  222034:	75fb      	strb	r3, [r7, #23]
			ns = dp->fn[NSFLAG];
  222036:	687b      	ldr	r3, [r7, #4]
  222038:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
  22203c:	72fb      	strb	r3, [r7, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  22203e:	7dfb      	ldrb	r3, [r7, #23]
  222040:	2b00      	cmp	r3, #0
  222042:	d00a      	beq.n	22205a <follow_path+0x92>
				if (res == FR_NO_FILE) {	/* Object is not found */
  222044:	7dfb      	ldrb	r3, [r7, #23]
  222046:	2b04      	cmp	r3, #4
  222048:	d127      	bne.n	22209a <follow_path+0xd2>
					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
						dp->fn[NSFLAG] = NS_NONAME;
						res = FR_OK;
					} else {							/* Could not find the object */
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
  22204a:	7afb      	ldrb	r3, [r7, #11]
  22204c:	f003 0304 	and.w	r3, r3, #4
  222050:	2b00      	cmp	r3, #0
  222052:	d122      	bne.n	22209a <follow_path+0xd2>
  222054:	2305      	movs	r3, #5
  222056:	75fb      	strb	r3, [r7, #23]
					}
				}
				break;
  222058:	e01f      	b.n	22209a <follow_path+0xd2>
			}
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
  22205a:	7afb      	ldrb	r3, [r7, #11]
  22205c:	f003 0304 	and.w	r3, r3, #4
  222060:	2b00      	cmp	r3, #0
  222062:	d11c      	bne.n	22209e <follow_path+0xd6>
			/* Get into the sub-directory */
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
  222064:	693b      	ldr	r3, [r7, #16]
  222066:	799b      	ldrb	r3, [r3, #6]
  222068:	f003 0310 	and.w	r3, r3, #16
  22206c:	2b00      	cmp	r3, #0
  22206e:	d102      	bne.n	222076 <follow_path+0xae>
				res = FR_NO_PATH; break;
  222070:	2305      	movs	r3, #5
  222072:	75fb      	strb	r3, [r7, #23]
  222074:	e014      	b.n	2220a0 <follow_path+0xd8>
				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
			} else
#endif
			{
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
  222076:	68fb      	ldr	r3, [r7, #12]
  222078:	f103 0238 	add.w	r2, r3, #56	; 0x38
  22207c:	687b      	ldr	r3, [r7, #4]
  22207e:	695b      	ldr	r3, [r3, #20]
  222080:	f3c3 0308 	ubfx	r3, r3, #0, #9
  222084:	4413      	add	r3, r2
  222086:	4619      	mov	r1, r3
  222088:	68f8      	ldr	r0, [r7, #12]
  22208a:	f7ff f988 	bl	22139e <ld_clust>
  22208e:	4602      	mov	r2, r0
  222090:	693b      	ldr	r3, [r7, #16]
  222092:	609a      	str	r2, [r3, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
  222094:	e7c0      	b.n	222018 <follow_path+0x50>
			if (res != FR_OK) break;
  222096:	bf00      	nop
  222098:	e002      	b.n	2220a0 <follow_path+0xd8>
				break;
  22209a:	bf00      	nop
  22209c:	e000      	b.n	2220a0 <follow_path+0xd8>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
  22209e:	bf00      	nop
			}
		}
	}

	return res;
  2220a0:	7dfb      	ldrb	r3, [r7, #23]
}
  2220a2:	4618      	mov	r0, r3
  2220a4:	3718      	adds	r7, #24
  2220a6:	46bd      	mov	sp, r7
  2220a8:	bd80      	pop	{r7, pc}

002220aa <get_ldnumber>:

static
int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
	const TCHAR** path	/* Pointer to pointer to the path name */
)
{
  2220aa:	b480      	push	{r7}
  2220ac:	b087      	sub	sp, #28
  2220ae:	af00      	add	r7, sp, #0
  2220b0:	6078      	str	r0, [r7, #4]
	const TCHAR *tp, *tt;
	UINT i;
	int vol = -1;
  2220b2:	f04f 33ff 	mov.w	r3, #4294967295
  2220b6:	613b      	str	r3, [r7, #16]
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
  2220b8:	687b      	ldr	r3, [r7, #4]
  2220ba:	681b      	ldr	r3, [r3, #0]
  2220bc:	2b00      	cmp	r3, #0
  2220be:	d031      	beq.n	222124 <get_ldnumber+0x7a>
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
  2220c0:	687b      	ldr	r3, [r7, #4]
  2220c2:	681b      	ldr	r3, [r3, #0]
  2220c4:	617b      	str	r3, [r7, #20]
  2220c6:	e002      	b.n	2220ce <get_ldnumber+0x24>
  2220c8:	697b      	ldr	r3, [r7, #20]
  2220ca:	3301      	adds	r3, #1
  2220cc:	617b      	str	r3, [r7, #20]
  2220ce:	697b      	ldr	r3, [r7, #20]
  2220d0:	781b      	ldrb	r3, [r3, #0]
  2220d2:	2b1f      	cmp	r3, #31
  2220d4:	d903      	bls.n	2220de <get_ldnumber+0x34>
  2220d6:	697b      	ldr	r3, [r7, #20]
  2220d8:	781b      	ldrb	r3, [r3, #0]
  2220da:	2b3a      	cmp	r3, #58	; 0x3a
  2220dc:	d1f4      	bne.n	2220c8 <get_ldnumber+0x1e>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
  2220de:	697b      	ldr	r3, [r7, #20]
  2220e0:	781b      	ldrb	r3, [r3, #0]
  2220e2:	2b3a      	cmp	r3, #58	; 0x3a
  2220e4:	d11c      	bne.n	222120 <get_ldnumber+0x76>
			tp = *path;
  2220e6:	687b      	ldr	r3, [r7, #4]
  2220e8:	681b      	ldr	r3, [r3, #0]
  2220ea:	60fb      	str	r3, [r7, #12]
			i = *tp++ - '0';
  2220ec:	68fb      	ldr	r3, [r7, #12]
  2220ee:	1c5a      	adds	r2, r3, #1
  2220f0:	60fa      	str	r2, [r7, #12]
  2220f2:	781b      	ldrb	r3, [r3, #0]
  2220f4:	3b30      	subs	r3, #48	; 0x30
  2220f6:	60bb      	str	r3, [r7, #8]
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
  2220f8:	68bb      	ldr	r3, [r7, #8]
  2220fa:	2b09      	cmp	r3, #9
  2220fc:	d80e      	bhi.n	22211c <get_ldnumber+0x72>
  2220fe:	68fa      	ldr	r2, [r7, #12]
  222100:	697b      	ldr	r3, [r7, #20]
  222102:	429a      	cmp	r2, r3
  222104:	d10a      	bne.n	22211c <get_ldnumber+0x72>
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
  222106:	68bb      	ldr	r3, [r7, #8]
  222108:	2b00      	cmp	r3, #0
  22210a:	d107      	bne.n	22211c <get_ldnumber+0x72>
					vol = (int)i;
  22210c:	68bb      	ldr	r3, [r7, #8]
  22210e:	613b      	str	r3, [r7, #16]
					*path = ++tt;
  222110:	697b      	ldr	r3, [r7, #20]
  222112:	3301      	adds	r3, #1
  222114:	617b      	str	r3, [r7, #20]
  222116:	687b      	ldr	r3, [r7, #4]
  222118:	697a      	ldr	r2, [r7, #20]
  22211a:	601a      	str	r2, [r3, #0]
					vol = (int)i;
					*path = tt;
				}
			}
#endif
			return vol;
  22211c:	693b      	ldr	r3, [r7, #16]
  22211e:	e002      	b.n	222126 <get_ldnumber+0x7c>
		}
#if _FS_RPATH != 0 && _VOLUMES >= 2
		vol = CurrVol;	/* Current drive */
#else
		vol = 0;		/* Drive 0 */
  222120:	2300      	movs	r3, #0
  222122:	613b      	str	r3, [r7, #16]
#endif
	}
	return vol;
  222124:	693b      	ldr	r3, [r7, #16]
}
  222126:	4618      	mov	r0, r3
  222128:	371c      	adds	r7, #28
  22212a:	46bd      	mov	sp, r7
  22212c:	f85d 7b04 	ldr.w	r7, [sp], #4
  222130:	4770      	bx	lr
	...

00222134 <check_fs>:
static
BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
	FATFS* fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
)
{
  222134:	b580      	push	{r7, lr}
  222136:	b082      	sub	sp, #8
  222138:	af00      	add	r7, sp, #0
  22213a:	6078      	str	r0, [r7, #4]
  22213c:	6039      	str	r1, [r7, #0]
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
  22213e:	687b      	ldr	r3, [r7, #4]
  222140:	2200      	movs	r2, #0
  222142:	70da      	strb	r2, [r3, #3]
  222144:	687b      	ldr	r3, [r7, #4]
  222146:	f04f 32ff 	mov.w	r2, #4294967295
  22214a:	635a      	str	r2, [r3, #52]	; 0x34
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
  22214c:	6839      	ldr	r1, [r7, #0]
  22214e:	6878      	ldr	r0, [r7, #4]
  222150:	f7fe fc26 	bl	2209a0 <move_window>
  222154:	4603      	mov	r3, r0
  222156:	2b00      	cmp	r3, #0
  222158:	d001      	beq.n	22215e <check_fs+0x2a>
  22215a:	2304      	movs	r3, #4
  22215c:	e038      	b.n	2221d0 <check_fs+0x9c>

	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
  22215e:	687b      	ldr	r3, [r7, #4]
  222160:	3338      	adds	r3, #56	; 0x38
  222162:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
  222166:	4618      	mov	r0, r3
  222168:	f7fe f93a 	bl	2203e0 <ld_word>
  22216c:	4603      	mov	r3, r0
  22216e:	461a      	mov	r2, r3
  222170:	f64a 2355 	movw	r3, #43605	; 0xaa55
  222174:	429a      	cmp	r2, r3
  222176:	d001      	beq.n	22217c <check_fs+0x48>
  222178:	2303      	movs	r3, #3
  22217a:	e029      	b.n	2221d0 <check_fs+0x9c>

	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
  22217c:	687b      	ldr	r3, [r7, #4]
  22217e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
  222182:	2be9      	cmp	r3, #233	; 0xe9
  222184:	d009      	beq.n	22219a <check_fs+0x66>
  222186:	687b      	ldr	r3, [r7, #4]
  222188:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
  22218c:	2beb      	cmp	r3, #235	; 0xeb
  22218e:	d11e      	bne.n	2221ce <check_fs+0x9a>
  222190:	687b      	ldr	r3, [r7, #4]
  222192:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
  222196:	2b90      	cmp	r3, #144	; 0x90
  222198:	d119      	bne.n	2221ce <check_fs+0x9a>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
  22219a:	687b      	ldr	r3, [r7, #4]
  22219c:	3338      	adds	r3, #56	; 0x38
  22219e:	3336      	adds	r3, #54	; 0x36
  2221a0:	4618      	mov	r0, r3
  2221a2:	f7fe f935 	bl	220410 <ld_dword>
  2221a6:	4603      	mov	r3, r0
  2221a8:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
  2221ac:	4a0a      	ldr	r2, [pc, #40]	; (2221d8 <check_fs+0xa4>)
  2221ae:	4293      	cmp	r3, r2
  2221b0:	d101      	bne.n	2221b6 <check_fs+0x82>
  2221b2:	2300      	movs	r3, #0
  2221b4:	e00c      	b.n	2221d0 <check_fs+0x9c>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
  2221b6:	687b      	ldr	r3, [r7, #4]
  2221b8:	3338      	adds	r3, #56	; 0x38
  2221ba:	3352      	adds	r3, #82	; 0x52
  2221bc:	4618      	mov	r0, r3
  2221be:	f7fe f927 	bl	220410 <ld_dword>
  2221c2:	4602      	mov	r2, r0
  2221c4:	4b05      	ldr	r3, [pc, #20]	; (2221dc <check_fs+0xa8>)
  2221c6:	429a      	cmp	r2, r3
  2221c8:	d101      	bne.n	2221ce <check_fs+0x9a>
  2221ca:	2300      	movs	r3, #0
  2221cc:	e000      	b.n	2221d0 <check_fs+0x9c>
	}
#if _FS_EXFAT
	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;
#endif
	return 2;
  2221ce:	2302      	movs	r3, #2
}
  2221d0:	4618      	mov	r0, r3
  2221d2:	3708      	adds	r7, #8
  2221d4:	46bd      	mov	sp, r7
  2221d6:	bd80      	pop	{r7, pc}
  2221d8:	00544146 	.word	0x00544146
  2221dc:	33544146 	.word	0x33544146

002221e0 <find_volume>:
FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
	FATFS** rfs,		/* Pointer to pointer to the found file system object */
	BYTE mode			/* !=0: Check write protection for write access */
)
{
  2221e0:	b580      	push	{r7, lr}
  2221e2:	b096      	sub	sp, #88	; 0x58
  2221e4:	af00      	add	r7, sp, #0
  2221e6:	60f8      	str	r0, [r7, #12]
  2221e8:	60b9      	str	r1, [r7, #8]
  2221ea:	4613      	mov	r3, r2
  2221ec:	71fb      	strb	r3, [r7, #7]
	FATFS *fs;
	UINT i;


	/* Get logical drive number */
	*rfs = 0;
  2221ee:	68bb      	ldr	r3, [r7, #8]
  2221f0:	2200      	movs	r2, #0
  2221f2:	601a      	str	r2, [r3, #0]
	vol = get_ldnumber(path);
  2221f4:	68f8      	ldr	r0, [r7, #12]
  2221f6:	f7ff ff58 	bl	2220aa <get_ldnumber>
  2221fa:	63f8      	str	r0, [r7, #60]	; 0x3c
	if (vol < 0) return FR_INVALID_DRIVE;
  2221fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  2221fe:	2b00      	cmp	r3, #0
  222200:	da01      	bge.n	222206 <find_volume+0x26>
  222202:	230b      	movs	r3, #11
  222204:	e236      	b.n	222674 <find_volume+0x494>

	/* Check if the file system object is valid or not */
	fs = FatFs[vol];					/* Get pointer to the file system object */
  222206:	4aac      	ldr	r2, [pc, #688]	; (2224b8 <find_volume+0x2d8>)
  222208:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  22220a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  22220e:	63bb      	str	r3, [r7, #56]	; 0x38
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  222210:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222212:	2b00      	cmp	r3, #0
  222214:	d101      	bne.n	22221a <find_volume+0x3a>
  222216:	230c      	movs	r3, #12
  222218:	e22c      	b.n	222674 <find_volume+0x494>

	ENTER_FF(fs);						/* Lock the volume */
  22221a:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  22221c:	f7fe f9df 	bl	2205de <lock_fs>
  222220:	4603      	mov	r3, r0
  222222:	2b00      	cmp	r3, #0
  222224:	d101      	bne.n	22222a <find_volume+0x4a>
  222226:	230f      	movs	r3, #15
  222228:	e224      	b.n	222674 <find_volume+0x494>
	*rfs = fs;							/* Return pointer to the file system object */
  22222a:	68bb      	ldr	r3, [r7, #8]
  22222c:	6bba      	ldr	r2, [r7, #56]	; 0x38
  22222e:	601a      	str	r2, [r3, #0]

	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
  222230:	79fb      	ldrb	r3, [r7, #7]
  222232:	f023 0301 	bic.w	r3, r3, #1
  222236:	71fb      	strb	r3, [r7, #7]
	if (fs->fs_type) {					/* If the volume has been mounted */
  222238:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22223a:	781b      	ldrb	r3, [r3, #0]
  22223c:	2b00      	cmp	r3, #0
  22223e:	d01a      	beq.n	222276 <find_volume+0x96>
		stat = disk_status(fs->drv);
  222240:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222242:	785b      	ldrb	r3, [r3, #1]
  222244:	4618      	mov	r0, r3
  222246:	f7fe f82d 	bl	2202a4 <disk_status>
  22224a:	4603      	mov	r3, r0
  22224c:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
  222250:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  222254:	f003 0301 	and.w	r3, r3, #1
  222258:	2b00      	cmp	r3, #0
  22225a:	d10c      	bne.n	222276 <find_volume+0x96>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
  22225c:	79fb      	ldrb	r3, [r7, #7]
  22225e:	2b00      	cmp	r3, #0
  222260:	d007      	beq.n	222272 <find_volume+0x92>
  222262:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  222266:	f003 0304 	and.w	r3, r3, #4
  22226a:	2b00      	cmp	r3, #0
  22226c:	d001      	beq.n	222272 <find_volume+0x92>
				return FR_WRITE_PROTECTED;
  22226e:	230a      	movs	r3, #10
  222270:	e200      	b.n	222674 <find_volume+0x494>
			}
			return FR_OK;				/* The file system object is valid */
  222272:	2300      	movs	r3, #0
  222274:	e1fe      	b.n	222674 <find_volume+0x494>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  222276:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222278:	2200      	movs	r2, #0
  22227a:	701a      	strb	r2, [r3, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  22227c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
  22227e:	b2da      	uxtb	r2, r3
  222280:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222282:	705a      	strb	r2, [r3, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
  222284:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222286:	785b      	ldrb	r3, [r3, #1]
  222288:	4618      	mov	r0, r3
  22228a:	f7fe f825 	bl	2202d8 <disk_initialize>
  22228e:	4603      	mov	r3, r0
  222290:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
  222294:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  222298:	f003 0301 	and.w	r3, r3, #1
  22229c:	2b00      	cmp	r3, #0
  22229e:	d001      	beq.n	2222a4 <find_volume+0xc4>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
  2222a0:	2303      	movs	r3, #3
  2222a2:	e1e7      	b.n	222674 <find_volume+0x494>
	}
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
  2222a4:	79fb      	ldrb	r3, [r7, #7]
  2222a6:	2b00      	cmp	r3, #0
  2222a8:	d007      	beq.n	2222ba <find_volume+0xda>
  2222aa:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  2222ae:	f003 0304 	and.w	r3, r3, #4
  2222b2:	2b00      	cmp	r3, #0
  2222b4:	d001      	beq.n	2222ba <find_volume+0xda>
		return FR_WRITE_PROTECTED;
  2222b6:	230a      	movs	r3, #10
  2222b8:	e1dc      	b.n	222674 <find_volume+0x494>
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK) return FR_DISK_ERR;
	if (SS(fs) > _MAX_SS || SS(fs) < _MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
#endif

	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
	bsect = 0;
  2222ba:	2300      	movs	r3, #0
  2222bc:	653b      	str	r3, [r7, #80]	; 0x50
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
  2222be:	6d39      	ldr	r1, [r7, #80]	; 0x50
  2222c0:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  2222c2:	f7ff ff37 	bl	222134 <check_fs>
  2222c6:	4603      	mov	r3, r0
  2222c8:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
  2222cc:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  2222d0:	2b02      	cmp	r3, #2
  2222d2:	d14b      	bne.n	22236c <find_volume+0x18c>
		for (i = 0; i < 4; i++) {		/* Get partition offset */
  2222d4:	2300      	movs	r3, #0
  2222d6:	643b      	str	r3, [r7, #64]	; 0x40
  2222d8:	e01f      	b.n	22231a <find_volume+0x13a>
			pt = fs->win + (MBR_Table + i * SZ_PTE);
  2222da:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2222dc:	f103 0238 	add.w	r2, r3, #56	; 0x38
  2222e0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  2222e2:	011b      	lsls	r3, r3, #4
  2222e4:	f503 73df 	add.w	r3, r3, #446	; 0x1be
  2222e8:	4413      	add	r3, r2
  2222ea:	633b      	str	r3, [r7, #48]	; 0x30
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
  2222ec:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2222ee:	3304      	adds	r3, #4
  2222f0:	781b      	ldrb	r3, [r3, #0]
  2222f2:	2b00      	cmp	r3, #0
  2222f4:	d006      	beq.n	222304 <find_volume+0x124>
  2222f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2222f8:	3308      	adds	r3, #8
  2222fa:	4618      	mov	r0, r3
  2222fc:	f7fe f888 	bl	220410 <ld_dword>
  222300:	4602      	mov	r2, r0
  222302:	e000      	b.n	222306 <find_volume+0x126>
  222304:	2200      	movs	r2, #0
  222306:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  222308:	009b      	lsls	r3, r3, #2
  22230a:	f107 0158 	add.w	r1, r7, #88	; 0x58
  22230e:	440b      	add	r3, r1
  222310:	f843 2c44 	str.w	r2, [r3, #-68]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
  222314:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  222316:	3301      	adds	r3, #1
  222318:	643b      	str	r3, [r7, #64]	; 0x40
  22231a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  22231c:	2b03      	cmp	r3, #3
  22231e:	d9dc      	bls.n	2222da <find_volume+0xfa>
		}
		i = LD2PT(vol);					/* Partition number: 0:auto, 1-4:forced */
  222320:	2300      	movs	r3, #0
  222322:	643b      	str	r3, [r7, #64]	; 0x40
		if (i) i--;
  222324:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  222326:	2b00      	cmp	r3, #0
  222328:	d002      	beq.n	222330 <find_volume+0x150>
  22232a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  22232c:	3b01      	subs	r3, #1
  22232e:	643b      	str	r3, [r7, #64]	; 0x40
		do {							/* Find an FAT volume */
			bsect = br[i];
  222330:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  222332:	009b      	lsls	r3, r3, #2
  222334:	f107 0258 	add.w	r2, r7, #88	; 0x58
  222338:	4413      	add	r3, r2
  22233a:	f853 3c44 	ldr.w	r3, [r3, #-68]
  22233e:	653b      	str	r3, [r7, #80]	; 0x50
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
  222340:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  222342:	2b00      	cmp	r3, #0
  222344:	d005      	beq.n	222352 <find_volume+0x172>
  222346:	6d39      	ldr	r1, [r7, #80]	; 0x50
  222348:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  22234a:	f7ff fef3 	bl	222134 <check_fs>
  22234e:	4603      	mov	r3, r0
  222350:	e000      	b.n	222354 <find_volume+0x174>
  222352:	2303      	movs	r3, #3
  222354:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
  222358:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  22235c:	2b01      	cmp	r3, #1
  22235e:	d905      	bls.n	22236c <find_volume+0x18c>
  222360:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  222362:	3301      	adds	r3, #1
  222364:	643b      	str	r3, [r7, #64]	; 0x40
  222366:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  222368:	2b03      	cmp	r3, #3
  22236a:	d9e1      	bls.n	222330 <find_volume+0x150>
	}
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
  22236c:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  222370:	2b04      	cmp	r3, #4
  222372:	d101      	bne.n	222378 <find_volume+0x198>
  222374:	2301      	movs	r3, #1
  222376:	e17d      	b.n	222674 <find_volume+0x494>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
  222378:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  22237c:	2b01      	cmp	r3, #1
  22237e:	d901      	bls.n	222384 <find_volume+0x1a4>
  222380:	230d      	movs	r3, #13
  222382:	e177      	b.n	222674 <find_volume+0x494>
#endif
		fmt = FS_EXFAT;			/* FAT sub-type */
	} else
#endif	/* _FS_EXFAT */
	{
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
  222384:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222386:	3338      	adds	r3, #56	; 0x38
  222388:	330b      	adds	r3, #11
  22238a:	4618      	mov	r0, r3
  22238c:	f7fe f828 	bl	2203e0 <ld_word>
  222390:	4603      	mov	r3, r0
  222392:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  222396:	d001      	beq.n	22239c <find_volume+0x1bc>
  222398:	230d      	movs	r3, #13
  22239a:	e16b      	b.n	222674 <find_volume+0x494>

		fasize = ld_word(fs->win + BPB_FATSz16);		/* Number of sectors per FAT */
  22239c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22239e:	3338      	adds	r3, #56	; 0x38
  2223a0:	3316      	adds	r3, #22
  2223a2:	4618      	mov	r0, r3
  2223a4:	f7fe f81c 	bl	2203e0 <ld_word>
  2223a8:	4603      	mov	r3, r0
  2223aa:	64fb      	str	r3, [r7, #76]	; 0x4c
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
  2223ac:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2223ae:	2b00      	cmp	r3, #0
  2223b0:	d106      	bne.n	2223c0 <find_volume+0x1e0>
  2223b2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223b4:	3338      	adds	r3, #56	; 0x38
  2223b6:	3324      	adds	r3, #36	; 0x24
  2223b8:	4618      	mov	r0, r3
  2223ba:	f7fe f829 	bl	220410 <ld_dword>
  2223be:	64f8      	str	r0, [r7, #76]	; 0x4c
		fs->fsize = fasize;
  2223c0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223c2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
  2223c4:	621a      	str	r2, [r3, #32]

		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
  2223c6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223c8:	f893 2048 	ldrb.w	r2, [r3, #72]	; 0x48
  2223cc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223ce:	709a      	strb	r2, [r3, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
  2223d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223d2:	789b      	ldrb	r3, [r3, #2]
  2223d4:	2b01      	cmp	r3, #1
  2223d6:	d005      	beq.n	2223e4 <find_volume+0x204>
  2223d8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223da:	789b      	ldrb	r3, [r3, #2]
  2223dc:	2b02      	cmp	r3, #2
  2223de:	d001      	beq.n	2223e4 <find_volume+0x204>
  2223e0:	230d      	movs	r3, #13
  2223e2:	e147      	b.n	222674 <find_volume+0x494>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
  2223e4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223e6:	789b      	ldrb	r3, [r3, #2]
  2223e8:	461a      	mov	r2, r3
  2223ea:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  2223ec:	fb02 f303 	mul.w	r3, r2, r3
  2223f0:	64fb      	str	r3, [r7, #76]	; 0x4c

		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
  2223f2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223f4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  2223f8:	b29a      	uxth	r2, r3
  2223fa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2223fc:	815a      	strh	r2, [r3, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  2223fe:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222400:	895b      	ldrh	r3, [r3, #10]
  222402:	2b00      	cmp	r3, #0
  222404:	d008      	beq.n	222418 <find_volume+0x238>
  222406:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222408:	895b      	ldrh	r3, [r3, #10]
  22240a:	461a      	mov	r2, r3
  22240c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22240e:	895b      	ldrh	r3, [r3, #10]
  222410:	3b01      	subs	r3, #1
  222412:	4013      	ands	r3, r2
  222414:	2b00      	cmp	r3, #0
  222416:	d001      	beq.n	22241c <find_volume+0x23c>
  222418:	230d      	movs	r3, #13
  22241a:	e12b      	b.n	222674 <find_volume+0x494>

		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
  22241c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22241e:	3338      	adds	r3, #56	; 0x38
  222420:	3311      	adds	r3, #17
  222422:	4618      	mov	r0, r3
  222424:	f7fd ffdc 	bl	2203e0 <ld_word>
  222428:	4603      	mov	r3, r0
  22242a:	461a      	mov	r2, r3
  22242c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22242e:	811a      	strh	r2, [r3, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
  222430:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222432:	891b      	ldrh	r3, [r3, #8]
  222434:	f003 030f 	and.w	r3, r3, #15
  222438:	b29b      	uxth	r3, r3
  22243a:	2b00      	cmp	r3, #0
  22243c:	d001      	beq.n	222442 <find_volume+0x262>
  22243e:	230d      	movs	r3, #13
  222440:	e118      	b.n	222674 <find_volume+0x494>

		tsect = ld_word(fs->win + BPB_TotSec16);		/* Number of sectors on the volume */
  222442:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222444:	3338      	adds	r3, #56	; 0x38
  222446:	3313      	adds	r3, #19
  222448:	4618      	mov	r0, r3
  22244a:	f7fd ffc9 	bl	2203e0 <ld_word>
  22244e:	4603      	mov	r3, r0
  222450:	64bb      	str	r3, [r7, #72]	; 0x48
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
  222452:	6cbb      	ldr	r3, [r7, #72]	; 0x48
  222454:	2b00      	cmp	r3, #0
  222456:	d106      	bne.n	222466 <find_volume+0x286>
  222458:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22245a:	3338      	adds	r3, #56	; 0x38
  22245c:	3320      	adds	r3, #32
  22245e:	4618      	mov	r0, r3
  222460:	f7fd ffd6 	bl	220410 <ld_dword>
  222464:	64b8      	str	r0, [r7, #72]	; 0x48

		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);		/* Number of reserved sectors */
  222466:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222468:	3338      	adds	r3, #56	; 0x38
  22246a:	330e      	adds	r3, #14
  22246c:	4618      	mov	r0, r3
  22246e:	f7fd ffb7 	bl	2203e0 <ld_word>
  222472:	4603      	mov	r3, r0
  222474:	85fb      	strh	r3, [r7, #46]	; 0x2e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
  222476:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
  222478:	2b00      	cmp	r3, #0
  22247a:	d101      	bne.n	222480 <find_volume+0x2a0>
  22247c:	230d      	movs	r3, #13
  22247e:	e0f9      	b.n	222674 <find_volume+0x494>

		/* Determine the FAT sub type */
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
  222480:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
  222482:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  222484:	4413      	add	r3, r2
  222486:	6bba      	ldr	r2, [r7, #56]	; 0x38
  222488:	8912      	ldrh	r2, [r2, #8]
  22248a:	0912      	lsrs	r2, r2, #4
  22248c:	b292      	uxth	r2, r2
  22248e:	4413      	add	r3, r2
  222490:	62bb      	str	r3, [r7, #40]	; 0x28
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
  222492:	6cba      	ldr	r2, [r7, #72]	; 0x48
  222494:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222496:	429a      	cmp	r2, r3
  222498:	d201      	bcs.n	22249e <find_volume+0x2be>
  22249a:	230d      	movs	r3, #13
  22249c:	e0ea      	b.n	222674 <find_volume+0x494>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
  22249e:	6cba      	ldr	r2, [r7, #72]	; 0x48
  2224a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2224a2:	1ad3      	subs	r3, r2, r3
  2224a4:	6bba      	ldr	r2, [r7, #56]	; 0x38
  2224a6:	8952      	ldrh	r2, [r2, #10]
  2224a8:	fbb3 f3f2 	udiv	r3, r3, r2
  2224ac:	627b      	str	r3, [r7, #36]	; 0x24
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  2224ae:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2224b0:	2b00      	cmp	r3, #0
  2224b2:	d103      	bne.n	2224bc <find_volume+0x2dc>
  2224b4:	230d      	movs	r3, #13
  2224b6:	e0dd      	b.n	222674 <find_volume+0x494>
  2224b8:	20010ba4 	.word	0x20010ba4
		fmt = FS_FAT32;
  2224bc:	2303      	movs	r3, #3
  2224be:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
  2224c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2224c4:	f64f 72f5 	movw	r2, #65525	; 0xfff5
  2224c8:	4293      	cmp	r3, r2
  2224ca:	d802      	bhi.n	2224d2 <find_volume+0x2f2>
  2224cc:	2302      	movs	r3, #2
  2224ce:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
  2224d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2224d4:	f640 72f5 	movw	r2, #4085	; 0xff5
  2224d8:	4293      	cmp	r3, r2
  2224da:	d802      	bhi.n	2224e2 <find_volume+0x302>
  2224dc:	2301      	movs	r3, #1
  2224de:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57

		/* Boundaries and Limits */
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
  2224e2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2224e4:	1c9a      	adds	r2, r3, #2
  2224e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2224e8:	61da      	str	r2, [r3, #28]
		fs->volbase = bsect;							/* Volume start sector */
  2224ea:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2224ec:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  2224ee:	625a      	str	r2, [r3, #36]	; 0x24
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
  2224f0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
  2224f2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2224f4:	441a      	add	r2, r3
  2224f6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2224f8:	629a      	str	r2, [r3, #40]	; 0x28
		fs->database = bsect + sysect;					/* Data start sector */
  2224fa:	6d3a      	ldr	r2, [r7, #80]	; 0x50
  2224fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2224fe:	441a      	add	r2, r3
  222500:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222502:	631a      	str	r2, [r3, #48]	; 0x30
		if (fmt == FS_FAT32) {
  222504:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  222508:	2b03      	cmp	r3, #3
  22250a:	d11e      	bne.n	22254a <find_volume+0x36a>
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
  22250c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22250e:	3338      	adds	r3, #56	; 0x38
  222510:	332a      	adds	r3, #42	; 0x2a
  222512:	4618      	mov	r0, r3
  222514:	f7fd ff64 	bl	2203e0 <ld_word>
  222518:	4603      	mov	r3, r0
  22251a:	2b00      	cmp	r3, #0
  22251c:	d001      	beq.n	222522 <find_volume+0x342>
  22251e:	230d      	movs	r3, #13
  222520:	e0a8      	b.n	222674 <find_volume+0x494>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
  222522:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222524:	891b      	ldrh	r3, [r3, #8]
  222526:	2b00      	cmp	r3, #0
  222528:	d001      	beq.n	22252e <find_volume+0x34e>
  22252a:	230d      	movs	r3, #13
  22252c:	e0a2      	b.n	222674 <find_volume+0x494>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
  22252e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222530:	3338      	adds	r3, #56	; 0x38
  222532:	332c      	adds	r3, #44	; 0x2c
  222534:	4618      	mov	r0, r3
  222536:	f7fd ff6b 	bl	220410 <ld_dword>
  22253a:	4602      	mov	r2, r0
  22253c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22253e:	62da      	str	r2, [r3, #44]	; 0x2c
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
  222540:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222542:	69db      	ldr	r3, [r3, #28]
  222544:	009b      	lsls	r3, r3, #2
  222546:	647b      	str	r3, [r7, #68]	; 0x44
  222548:	e01f      	b.n	22258a <find_volume+0x3aa>
		} else {
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
  22254a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22254c:	891b      	ldrh	r3, [r3, #8]
  22254e:	2b00      	cmp	r3, #0
  222550:	d101      	bne.n	222556 <find_volume+0x376>
  222552:	230d      	movs	r3, #13
  222554:	e08e      	b.n	222674 <find_volume+0x494>
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
  222556:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222558:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  22255a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  22255c:	441a      	add	r2, r3
  22255e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222560:	62da      	str	r2, [r3, #44]	; 0x2c
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  222562:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  222566:	2b02      	cmp	r3, #2
  222568:	d103      	bne.n	222572 <find_volume+0x392>
  22256a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22256c:	69db      	ldr	r3, [r3, #28]
  22256e:	005b      	lsls	r3, r3, #1
  222570:	e00a      	b.n	222588 <find_volume+0x3a8>
  222572:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222574:	69da      	ldr	r2, [r3, #28]
  222576:	4613      	mov	r3, r2
  222578:	005b      	lsls	r3, r3, #1
  22257a:	4413      	add	r3, r2
  22257c:	085a      	lsrs	r2, r3, #1
  22257e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222580:	69db      	ldr	r3, [r3, #28]
  222582:	f003 0301 	and.w	r3, r3, #1
  222586:	4413      	add	r3, r2
			szbfat = (fmt == FS_FAT16) ?				/* (Needed FAT size) */
  222588:	647b      	str	r3, [r7, #68]	; 0x44
		}
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
  22258a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22258c:	6a1a      	ldr	r2, [r3, #32]
  22258e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
  222590:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  222594:	0a5b      	lsrs	r3, r3, #9
  222596:	429a      	cmp	r2, r3
  222598:	d201      	bcs.n	22259e <find_volume+0x3be>
  22259a:	230d      	movs	r3, #13
  22259c:	e06a      	b.n	222674 <find_volume+0x494>

#if !_FS_READONLY
		/* Get FSINFO if available */
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
  22259e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225a0:	f04f 32ff 	mov.w	r2, #4294967295
  2225a4:	619a      	str	r2, [r3, #24]
  2225a6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225a8:	699a      	ldr	r2, [r3, #24]
  2225aa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225ac:	615a      	str	r2, [r3, #20]
		fs->fsi_flag = 0x80;
  2225ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225b0:	2280      	movs	r2, #128	; 0x80
  2225b2:	711a      	strb	r2, [r3, #4]
#if (_FS_NOFSINFO & 3) != 3
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
  2225b4:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
  2225b8:	2b03      	cmp	r3, #3
  2225ba:	d149      	bne.n	222650 <find_volume+0x470>
			&& ld_word(fs->win + BPB_FSInfo32) == 1
  2225bc:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225be:	3338      	adds	r3, #56	; 0x38
  2225c0:	3330      	adds	r3, #48	; 0x30
  2225c2:	4618      	mov	r0, r3
  2225c4:	f7fd ff0c 	bl	2203e0 <ld_word>
  2225c8:	4603      	mov	r3, r0
  2225ca:	2b01      	cmp	r3, #1
  2225cc:	d140      	bne.n	222650 <find_volume+0x470>
			&& move_window(fs, bsect + 1) == FR_OK)
  2225ce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  2225d0:	3301      	adds	r3, #1
  2225d2:	4619      	mov	r1, r3
  2225d4:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  2225d6:	f7fe f9e3 	bl	2209a0 <move_window>
  2225da:	4603      	mov	r3, r0
  2225dc:	2b00      	cmp	r3, #0
  2225de:	d137      	bne.n	222650 <find_volume+0x470>
		{
			fs->fsi_flag = 0;
  2225e0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225e2:	2200      	movs	r2, #0
  2225e4:	711a      	strb	r2, [r3, #4]
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
  2225e6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2225e8:	3338      	adds	r3, #56	; 0x38
  2225ea:	f503 73ff 	add.w	r3, r3, #510	; 0x1fe
  2225ee:	4618      	mov	r0, r3
  2225f0:	f7fd fef6 	bl	2203e0 <ld_word>
  2225f4:	4603      	mov	r3, r0
  2225f6:	461a      	mov	r2, r3
  2225f8:	f64a 2355 	movw	r3, #43605	; 0xaa55
  2225fc:	429a      	cmp	r2, r3
  2225fe:	d127      	bne.n	222650 <find_volume+0x470>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
  222600:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222602:	3338      	adds	r3, #56	; 0x38
  222604:	4618      	mov	r0, r3
  222606:	f7fd ff03 	bl	220410 <ld_dword>
  22260a:	4602      	mov	r2, r0
  22260c:	4b1b      	ldr	r3, [pc, #108]	; (22267c <find_volume+0x49c>)
  22260e:	429a      	cmp	r2, r3
  222610:	d11e      	bne.n	222650 <find_volume+0x470>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
  222612:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222614:	3338      	adds	r3, #56	; 0x38
  222616:	f503 73f2 	add.w	r3, r3, #484	; 0x1e4
  22261a:	4618      	mov	r0, r3
  22261c:	f7fd fef8 	bl	220410 <ld_dword>
  222620:	4602      	mov	r2, r0
  222622:	4b17      	ldr	r3, [pc, #92]	; (222680 <find_volume+0x4a0>)
  222624:	429a      	cmp	r2, r3
  222626:	d113      	bne.n	222650 <find_volume+0x470>
			{
#if (_FS_NOFSINFO & 1) == 0
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
  222628:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22262a:	3338      	adds	r3, #56	; 0x38
  22262c:	f503 73f4 	add.w	r3, r3, #488	; 0x1e8
  222630:	4618      	mov	r0, r3
  222632:	f7fd feed 	bl	220410 <ld_dword>
  222636:	4602      	mov	r2, r0
  222638:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22263a:	619a      	str	r2, [r3, #24]
#endif
#if (_FS_NOFSINFO & 2) == 0
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
  22263c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22263e:	3338      	adds	r3, #56	; 0x38
  222640:	f503 73f6 	add.w	r3, r3, #492	; 0x1ec
  222644:	4618      	mov	r0, r3
  222646:	f7fd fee3 	bl	220410 <ld_dword>
  22264a:	4602      	mov	r2, r0
  22264c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22264e:	615a      	str	r2, [r3, #20]
		}
#endif	/* (_FS_NOFSINFO & 3) != 3 */
#endif	/* !_FS_READONLY */
	}

	fs->fs_type = fmt;		/* FAT sub-type */
  222650:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222652:	f897 2057 	ldrb.w	r2, [r7, #87]	; 0x57
  222656:	701a      	strb	r2, [r3, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  222658:	4b0a      	ldr	r3, [pc, #40]	; (222684 <find_volume+0x4a4>)
  22265a:	881b      	ldrh	r3, [r3, #0]
  22265c:	3301      	adds	r3, #1
  22265e:	b29a      	uxth	r2, r3
  222660:	4b08      	ldr	r3, [pc, #32]	; (222684 <find_volume+0x4a4>)
  222662:	801a      	strh	r2, [r3, #0]
  222664:	4b07      	ldr	r3, [pc, #28]	; (222684 <find_volume+0x4a4>)
  222666:	881a      	ldrh	r2, [r3, #0]
  222668:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  22266a:	80da      	strh	r2, [r3, #6]
#endif
#if _FS_RPATH != 0
	fs->cdir = 0;			/* Initialize current directory */
#endif
#if _FS_LOCK != 0			/* Clear file lock semaphores */
	clear_lock(fs);
  22266c:	6bb8      	ldr	r0, [r7, #56]	; 0x38
  22266e:	f7fe f92f 	bl	2208d0 <clear_lock>
#endif
	return FR_OK;
  222672:	2300      	movs	r3, #0
}
  222674:	4618      	mov	r0, r3
  222676:	3758      	adds	r7, #88	; 0x58
  222678:	46bd      	mov	sp, r7
  22267a:	bd80      	pop	{r7, pc}
  22267c:	41615252 	.word	0x41615252
  222680:	61417272 	.word	0x61417272
  222684:	20010ba8 	.word	0x20010ba8

00222688 <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
  222688:	b580      	push	{r7, lr}
  22268a:	b084      	sub	sp, #16
  22268c:	af00      	add	r7, sp, #0
  22268e:	6078      	str	r0, [r7, #4]
  222690:	6039      	str	r1, [r7, #0]
	FRESULT res = FR_INVALID_OBJECT;
  222692:	2309      	movs	r3, #9
  222694:	73fb      	strb	r3, [r7, #15]


	if (obj && obj->fs && obj->fs->fs_type && obj->id == obj->fs->id) {	/* Test if the object is valid */
  222696:	687b      	ldr	r3, [r7, #4]
  222698:	2b00      	cmp	r3, #0
  22269a:	d02e      	beq.n	2226fa <validate+0x72>
  22269c:	687b      	ldr	r3, [r7, #4]
  22269e:	681b      	ldr	r3, [r3, #0]
  2226a0:	2b00      	cmp	r3, #0
  2226a2:	d02a      	beq.n	2226fa <validate+0x72>
  2226a4:	687b      	ldr	r3, [r7, #4]
  2226a6:	681b      	ldr	r3, [r3, #0]
  2226a8:	781b      	ldrb	r3, [r3, #0]
  2226aa:	2b00      	cmp	r3, #0
  2226ac:	d025      	beq.n	2226fa <validate+0x72>
  2226ae:	687b      	ldr	r3, [r7, #4]
  2226b0:	889a      	ldrh	r2, [r3, #4]
  2226b2:	687b      	ldr	r3, [r7, #4]
  2226b4:	681b      	ldr	r3, [r3, #0]
  2226b6:	88db      	ldrh	r3, [r3, #6]
  2226b8:	429a      	cmp	r2, r3
  2226ba:	d11e      	bne.n	2226fa <validate+0x72>
#if _FS_REENTRANT
		if (lock_fs(obj->fs)) {	/* Obtain the filesystem object */
  2226bc:	687b      	ldr	r3, [r7, #4]
  2226be:	681b      	ldr	r3, [r3, #0]
  2226c0:	4618      	mov	r0, r3
  2226c2:	f7fd ff8c 	bl	2205de <lock_fs>
  2226c6:	4603      	mov	r3, r0
  2226c8:	2b00      	cmp	r3, #0
  2226ca:	d014      	beq.n	2226f6 <validate+0x6e>
			if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
  2226cc:	687b      	ldr	r3, [r7, #4]
  2226ce:	681b      	ldr	r3, [r3, #0]
  2226d0:	785b      	ldrb	r3, [r3, #1]
  2226d2:	4618      	mov	r0, r3
  2226d4:	f7fd fde6 	bl	2202a4 <disk_status>
  2226d8:	4603      	mov	r3, r0
  2226da:	f003 0301 	and.w	r3, r3, #1
  2226de:	2b00      	cmp	r3, #0
  2226e0:	d102      	bne.n	2226e8 <validate+0x60>
				res = FR_OK;
  2226e2:	2300      	movs	r3, #0
  2226e4:	73fb      	strb	r3, [r7, #15]
  2226e6:	e008      	b.n	2226fa <validate+0x72>
			} else {
				unlock_fs(obj->fs, FR_OK);
  2226e8:	687b      	ldr	r3, [r7, #4]
  2226ea:	681b      	ldr	r3, [r3, #0]
  2226ec:	2100      	movs	r1, #0
  2226ee:	4618      	mov	r0, r3
  2226f0:	f7fd ff8b 	bl	22060a <unlock_fs>
  2226f4:	e001      	b.n	2226fa <validate+0x72>
			}
		} else {
			res = FR_TIMEOUT;
  2226f6:	230f      	movs	r3, #15
  2226f8:	73fb      	strb	r3, [r7, #15]
		if (!(disk_status(obj->fs->drv) & STA_NOINIT)) { /* Test if the phsical drive is kept initialized */
			res = FR_OK;
		}
#endif
	}
	*fs = (res == FR_OK) ? obj->fs : 0;	/* Corresponding filesystem object */
  2226fa:	7bfb      	ldrb	r3, [r7, #15]
  2226fc:	2b00      	cmp	r3, #0
  2226fe:	d102      	bne.n	222706 <validate+0x7e>
  222700:	687b      	ldr	r3, [r7, #4]
  222702:	681b      	ldr	r3, [r3, #0]
  222704:	e000      	b.n	222708 <validate+0x80>
  222706:	2300      	movs	r3, #0
  222708:	683a      	ldr	r2, [r7, #0]
  22270a:	6013      	str	r3, [r2, #0]
	return res;
  22270c:	7bfb      	ldrb	r3, [r7, #15]
}
  22270e:	4618      	mov	r0, r3
  222710:	3710      	adds	r7, #16
  222712:	46bd      	mov	sp, r7
  222714:	bd80      	pop	{r7, pc}
	...

00222718 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
  222718:	b580      	push	{r7, lr}
  22271a:	b088      	sub	sp, #32
  22271c:	af00      	add	r7, sp, #0
  22271e:	60f8      	str	r0, [r7, #12]
  222720:	60b9      	str	r1, [r7, #8]
  222722:	4613      	mov	r3, r2
  222724:	71fb      	strb	r3, [r7, #7]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
  222726:	68bb      	ldr	r3, [r7, #8]
  222728:	613b      	str	r3, [r7, #16]


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
  22272a:	f107 0310 	add.w	r3, r7, #16
  22272e:	4618      	mov	r0, r3
  222730:	f7ff fcbb 	bl	2220aa <get_ldnumber>
  222734:	61f8      	str	r0, [r7, #28]
	if (vol < 0) return FR_INVALID_DRIVE;
  222736:	69fb      	ldr	r3, [r7, #28]
  222738:	2b00      	cmp	r3, #0
  22273a:	da01      	bge.n	222740 <f_mount+0x28>
  22273c:	230b      	movs	r3, #11
  22273e:	e048      	b.n	2227d2 <f_mount+0xba>
	cfs = FatFs[vol];					/* Pointer to fs object */
  222740:	4a26      	ldr	r2, [pc, #152]	; (2227dc <f_mount+0xc4>)
  222742:	69fb      	ldr	r3, [r7, #28]
  222744:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  222748:	61bb      	str	r3, [r7, #24]

	if (cfs) {
  22274a:	69bb      	ldr	r3, [r7, #24]
  22274c:	2b00      	cmp	r3, #0
  22274e:	d00f      	beq.n	222770 <f_mount+0x58>
#if _FS_LOCK != 0
		clear_lock(cfs);
  222750:	69b8      	ldr	r0, [r7, #24]
  222752:	f7fe f8bd 	bl	2208d0 <clear_lock>
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
  222756:	69bb      	ldr	r3, [r7, #24]
  222758:	691b      	ldr	r3, [r3, #16]
  22275a:	4618      	mov	r0, r3
  22275c:	f000 ff7c 	bl	223658 <ff_del_syncobj>
  222760:	4603      	mov	r3, r0
  222762:	2b00      	cmp	r3, #0
  222764:	d101      	bne.n	22276a <f_mount+0x52>
  222766:	2302      	movs	r3, #2
  222768:	e033      	b.n	2227d2 <f_mount+0xba>
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
  22276a:	69bb      	ldr	r3, [r7, #24]
  22276c:	2200      	movs	r2, #0
  22276e:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  222770:	68fb      	ldr	r3, [r7, #12]
  222772:	2b00      	cmp	r3, #0
  222774:	d00f      	beq.n	222796 <f_mount+0x7e>
		fs->fs_type = 0;				/* Clear new fs object */
  222776:	68fb      	ldr	r3, [r7, #12]
  222778:	2200      	movs	r2, #0
  22277a:	701a      	strb	r2, [r3, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
  22277c:	69fb      	ldr	r3, [r7, #28]
  22277e:	b2da      	uxtb	r2, r3
  222780:	68fb      	ldr	r3, [r7, #12]
  222782:	3310      	adds	r3, #16
  222784:	4619      	mov	r1, r3
  222786:	4610      	mov	r0, r2
  222788:	f000 ff46 	bl	223618 <ff_cre_syncobj>
  22278c:	4603      	mov	r3, r0
  22278e:	2b00      	cmp	r3, #0
  222790:	d101      	bne.n	222796 <f_mount+0x7e>
  222792:	2302      	movs	r3, #2
  222794:	e01d      	b.n	2227d2 <f_mount+0xba>
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
  222796:	68fa      	ldr	r2, [r7, #12]
  222798:	4910      	ldr	r1, [pc, #64]	; (2227dc <f_mount+0xc4>)
  22279a:	69fb      	ldr	r3, [r7, #28]
  22279c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
  2227a0:	68fb      	ldr	r3, [r7, #12]
  2227a2:	2b00      	cmp	r3, #0
  2227a4:	d002      	beq.n	2227ac <f_mount+0x94>
  2227a6:	79fb      	ldrb	r3, [r7, #7]
  2227a8:	2b01      	cmp	r3, #1
  2227aa:	d001      	beq.n	2227b0 <f_mount+0x98>
  2227ac:	2300      	movs	r3, #0
  2227ae:	e010      	b.n	2227d2 <f_mount+0xba>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
  2227b0:	f107 010c 	add.w	r1, r7, #12
  2227b4:	f107 0308 	add.w	r3, r7, #8
  2227b8:	2200      	movs	r2, #0
  2227ba:	4618      	mov	r0, r3
  2227bc:	f7ff fd10 	bl	2221e0 <find_volume>
  2227c0:	4603      	mov	r3, r0
  2227c2:	75fb      	strb	r3, [r7, #23]
	LEAVE_FF(fs, res);
  2227c4:	68fb      	ldr	r3, [r7, #12]
  2227c6:	7dfa      	ldrb	r2, [r7, #23]
  2227c8:	4611      	mov	r1, r2
  2227ca:	4618      	mov	r0, r3
  2227cc:	f7fd ff1d 	bl	22060a <unlock_fs>
  2227d0:	7dfb      	ldrb	r3, [r7, #23]
}
  2227d2:	4618      	mov	r0, r3
  2227d4:	3720      	adds	r7, #32
  2227d6:	46bd      	mov	sp, r7
  2227d8:	bd80      	pop	{r7, pc}
  2227da:	bf00      	nop
  2227dc:	20010ba4 	.word	0x20010ba4

002227e0 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  2227e0:	b580      	push	{r7, lr}
  2227e2:	b09c      	sub	sp, #112	; 0x70
  2227e4:	af00      	add	r7, sp, #0
  2227e6:	60f8      	str	r0, [r7, #12]
  2227e8:	60b9      	str	r1, [r7, #8]
  2227ea:	4613      	mov	r3, r2
  2227ec:	71fb      	strb	r3, [r7, #7]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
  2227ee:	68fb      	ldr	r3, [r7, #12]
  2227f0:	2b00      	cmp	r3, #0
  2227f2:	d101      	bne.n	2227f8 <f_open+0x18>
  2227f4:	2309      	movs	r3, #9
  2227f6:	e1c9      	b.n	222b8c <f_open+0x3ac>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
  2227f8:	79fb      	ldrb	r3, [r7, #7]
  2227fa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  2227fe:	71fb      	strb	r3, [r7, #7]
	res = find_volume(&path, &fs, mode);
  222800:	79fa      	ldrb	r2, [r7, #7]
  222802:	f107 0114 	add.w	r1, r7, #20
  222806:	f107 0308 	add.w	r3, r7, #8
  22280a:	4618      	mov	r0, r3
  22280c:	f7ff fce8 	bl	2221e0 <find_volume>
  222810:	4603      	mov	r3, r0
  222812:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
	if (res == FR_OK) {
  222816:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  22281a:	2b00      	cmp	r3, #0
  22281c:	f040 81a6 	bne.w	222b6c <f_open+0x38c>
		dj.obj.fs = fs;
  222820:	697b      	ldr	r3, [r7, #20]
  222822:	61bb      	str	r3, [r7, #24]
		INIT_NAMBUF(fs);
  222824:	f44f 7000 	mov.w	r0, #512	; 0x200
  222828:	f000 ff42 	bl	2236b0 <ff_memalloc>
  22282c:	6638      	str	r0, [r7, #96]	; 0x60
  22282e:	6e3b      	ldr	r3, [r7, #96]	; 0x60
  222830:	2b00      	cmp	r3, #0
  222832:	d106      	bne.n	222842 <f_open+0x62>
  222834:	697b      	ldr	r3, [r7, #20]
  222836:	2111      	movs	r1, #17
  222838:	4618      	mov	r0, r3
  22283a:	f7fd fee6 	bl	22060a <unlock_fs>
  22283e:	2311      	movs	r3, #17
  222840:	e1a4      	b.n	222b8c <f_open+0x3ac>
  222842:	697b      	ldr	r3, [r7, #20]
  222844:	6e3a      	ldr	r2, [r7, #96]	; 0x60
  222846:	60da      	str	r2, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
  222848:	68ba      	ldr	r2, [r7, #8]
  22284a:	f107 0318 	add.w	r3, r7, #24
  22284e:	4611      	mov	r1, r2
  222850:	4618      	mov	r0, r3
  222852:	f7ff fbb9 	bl	221fc8 <follow_path>
  222856:	4603      	mov	r3, r0
  222858:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
  22285c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222860:	2b00      	cmp	r3, #0
  222862:	d11a      	bne.n	22289a <f_open+0xba>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
  222864:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
  222868:	b25b      	sxtb	r3, r3
  22286a:	2b00      	cmp	r3, #0
  22286c:	da03      	bge.n	222876 <f_open+0x96>
				res = FR_INVALID_NAME;
  22286e:	2306      	movs	r3, #6
  222870:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  222874:	e011      	b.n	22289a <f_open+0xba>
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  222876:	79fb      	ldrb	r3, [r7, #7]
  222878:	f023 0301 	bic.w	r3, r3, #1
  22287c:	2b00      	cmp	r3, #0
  22287e:	bf14      	ite	ne
  222880:	2301      	movne	r3, #1
  222882:	2300      	moveq	r3, #0
  222884:	b2db      	uxtb	r3, r3
  222886:	461a      	mov	r2, r3
  222888:	f107 0318 	add.w	r3, r7, #24
  22288c:	4611      	mov	r1, r2
  22288e:	4618      	mov	r0, r3
  222890:	f7fd fed6 	bl	220640 <chk_lock>
  222894:	4603      	mov	r3, r0
  222896:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  22289a:	79fb      	ldrb	r3, [r7, #7]
  22289c:	f003 031c 	and.w	r3, r3, #28
  2228a0:	2b00      	cmp	r3, #0
  2228a2:	d07f      	beq.n	2229a4 <f_open+0x1c4>
			if (res != FR_OK) {					/* No file, create new */
  2228a4:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  2228a8:	2b00      	cmp	r3, #0
  2228aa:	d017      	beq.n	2228dc <f_open+0xfc>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
  2228ac:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  2228b0:	2b04      	cmp	r3, #4
  2228b2:	d10e      	bne.n	2228d2 <f_open+0xf2>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  2228b4:	f7fd ff20 	bl	2206f8 <enq_lock>
  2228b8:	4603      	mov	r3, r0
  2228ba:	2b00      	cmp	r3, #0
  2228bc:	d006      	beq.n	2228cc <f_open+0xec>
  2228be:	f107 0318 	add.w	r3, r7, #24
  2228c2:	4618      	mov	r0, r3
  2228c4:	f7fe fff2 	bl	2218ac <dir_register>
  2228c8:	4603      	mov	r3, r0
  2228ca:	e000      	b.n	2228ce <f_open+0xee>
  2228cc:	2312      	movs	r3, #18
  2228ce:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
  2228d2:	79fb      	ldrb	r3, [r7, #7]
  2228d4:	f043 0308 	orr.w	r3, r3, #8
  2228d8:	71fb      	strb	r3, [r7, #7]
  2228da:	e010      	b.n	2228fe <f_open+0x11e>
			}
			else {								/* Any object is already existing */
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  2228dc:	7fbb      	ldrb	r3, [r7, #30]
  2228de:	f003 0311 	and.w	r3, r3, #17
  2228e2:	2b00      	cmp	r3, #0
  2228e4:	d003      	beq.n	2228ee <f_open+0x10e>
					res = FR_DENIED;
  2228e6:	2307      	movs	r3, #7
  2228e8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  2228ec:	e007      	b.n	2228fe <f_open+0x11e>
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
  2228ee:	79fb      	ldrb	r3, [r7, #7]
  2228f0:	f003 0304 	and.w	r3, r3, #4
  2228f4:	2b00      	cmp	r3, #0
  2228f6:	d002      	beq.n	2228fe <f_open+0x11e>
  2228f8:	2308      	movs	r3, #8
  2228fa:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  2228fe:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222902:	2b00      	cmp	r3, #0
  222904:	d168      	bne.n	2229d8 <f_open+0x1f8>
  222906:	79fb      	ldrb	r3, [r7, #7]
  222908:	f003 0308 	and.w	r3, r3, #8
  22290c:	2b00      	cmp	r3, #0
  22290e:	d063      	beq.n	2229d8 <f_open+0x1f8>
				dw = GET_FATTIME();
  222910:	f7fd f91c 	bl	21fb4c <get_fattime>
  222914:	65f8      	str	r0, [r7, #92]	; 0x5c
					}
				} else
#endif
				{
					/* Clean directory info */
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
  222916:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222918:	330e      	adds	r3, #14
  22291a:	6df9      	ldr	r1, [r7, #92]	; 0x5c
  22291c:	4618      	mov	r0, r3
  22291e:	f7fd fdb5 	bl	22048c <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
  222922:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222924:	3316      	adds	r3, #22
  222926:	6df9      	ldr	r1, [r7, #92]	; 0x5c
  222928:	4618      	mov	r0, r3
  22292a:	f7fd fdaf 	bl	22048c <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
  22292e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222930:	330b      	adds	r3, #11
  222932:	2220      	movs	r2, #32
  222934:	701a      	strb	r2, [r3, #0]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
  222936:	697b      	ldr	r3, [r7, #20]
  222938:	6bba      	ldr	r2, [r7, #56]	; 0x38
  22293a:	4611      	mov	r1, r2
  22293c:	4618      	mov	r0, r3
  22293e:	f7fe fd2e 	bl	22139e <ld_clust>
  222942:	65b8      	str	r0, [r7, #88]	; 0x58
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
  222944:	697b      	ldr	r3, [r7, #20]
  222946:	6bb9      	ldr	r1, [r7, #56]	; 0x38
  222948:	2200      	movs	r2, #0
  22294a:	4618      	mov	r0, r3
  22294c:	f7fe fd46 	bl	2213dc <st_clust>
					st_dword(dj.dir + DIR_FileSize, 0);
  222950:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222952:	331c      	adds	r3, #28
  222954:	2100      	movs	r1, #0
  222956:	4618      	mov	r0, r3
  222958:	f7fd fd98 	bl	22048c <st_dword>
					fs->wflag = 1;
  22295c:	697b      	ldr	r3, [r7, #20]
  22295e:	2201      	movs	r2, #1
  222960:	70da      	strb	r2, [r3, #3]

					if (cl) {							/* Remove the cluster chain if exist */
  222962:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  222964:	2b00      	cmp	r3, #0
  222966:	d037      	beq.n	2229d8 <f_open+0x1f8>
						dw = fs->winsect;
  222968:	697b      	ldr	r3, [r7, #20]
  22296a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  22296c:	65fb      	str	r3, [r7, #92]	; 0x5c
						res = remove_chain(&dj.obj, cl, 0);
  22296e:	f107 0318 	add.w	r3, r7, #24
  222972:	2200      	movs	r2, #0
  222974:	6db9      	ldr	r1, [r7, #88]	; 0x58
  222976:	4618      	mov	r0, r3
  222978:	f7fe fa59 	bl	220e2e <remove_chain>
  22297c:	4603      	mov	r3, r0
  22297e:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
						if (res == FR_OK) {
  222982:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222986:	2b00      	cmp	r3, #0
  222988:	d126      	bne.n	2229d8 <f_open+0x1f8>
							res = move_window(fs, dw);
  22298a:	697b      	ldr	r3, [r7, #20]
  22298c:	6df9      	ldr	r1, [r7, #92]	; 0x5c
  22298e:	4618      	mov	r0, r3
  222990:	f7fe f806 	bl	2209a0 <move_window>
  222994:	4603      	mov	r3, r0
  222996:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
  22299a:	697b      	ldr	r3, [r7, #20]
  22299c:	6dba      	ldr	r2, [r7, #88]	; 0x58
  22299e:	3a01      	subs	r2, #1
  2229a0:	615a      	str	r2, [r3, #20]
  2229a2:	e019      	b.n	2229d8 <f_open+0x1f8>
					}
				}
			}
		}
		else {	/* Open an existing file */
			if (res == FR_OK) {					/* Following succeeded */
  2229a4:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  2229a8:	2b00      	cmp	r3, #0
  2229aa:	d115      	bne.n	2229d8 <f_open+0x1f8>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
  2229ac:	7fbb      	ldrb	r3, [r7, #30]
  2229ae:	f003 0310 	and.w	r3, r3, #16
  2229b2:	2b00      	cmp	r3, #0
  2229b4:	d003      	beq.n	2229be <f_open+0x1de>
					res = FR_NO_FILE;
  2229b6:	2304      	movs	r3, #4
  2229b8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  2229bc:	e00c      	b.n	2229d8 <f_open+0x1f8>
				} else {
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
  2229be:	79fb      	ldrb	r3, [r7, #7]
  2229c0:	f003 0302 	and.w	r3, r3, #2
  2229c4:	2b00      	cmp	r3, #0
  2229c6:	d007      	beq.n	2229d8 <f_open+0x1f8>
  2229c8:	7fbb      	ldrb	r3, [r7, #30]
  2229ca:	f003 0301 	and.w	r3, r3, #1
  2229ce:	2b00      	cmp	r3, #0
  2229d0:	d002      	beq.n	2229d8 <f_open+0x1f8>
						res = FR_DENIED;
  2229d2:	2307      	movs	r3, #7
  2229d4:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
					}
				}
			}
		}
		if (res == FR_OK) {
  2229d8:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  2229dc:	2b00      	cmp	r3, #0
  2229de:	d128      	bne.n	222a32 <f_open+0x252>
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
  2229e0:	79fb      	ldrb	r3, [r7, #7]
  2229e2:	f003 0308 	and.w	r3, r3, #8
  2229e6:	2b00      	cmp	r3, #0
  2229e8:	d003      	beq.n	2229f2 <f_open+0x212>
				mode |= FA_MODIFIED;
  2229ea:	79fb      	ldrb	r3, [r7, #7]
  2229ec:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  2229f0:	71fb      	strb	r3, [r7, #7]
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
  2229f2:	697b      	ldr	r3, [r7, #20]
  2229f4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  2229f6:	68fb      	ldr	r3, [r7, #12]
  2229f8:	625a      	str	r2, [r3, #36]	; 0x24
			fp->dir_ptr = dj.dir;
  2229fa:	6bba      	ldr	r2, [r7, #56]	; 0x38
  2229fc:	68fb      	ldr	r3, [r7, #12]
  2229fe:	629a      	str	r2, [r3, #40]	; 0x28
#if _FS_LOCK != 0
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  222a00:	79fb      	ldrb	r3, [r7, #7]
  222a02:	f023 0301 	bic.w	r3, r3, #1
  222a06:	2b00      	cmp	r3, #0
  222a08:	bf14      	ite	ne
  222a0a:	2301      	movne	r3, #1
  222a0c:	2300      	moveq	r3, #0
  222a0e:	b2db      	uxtb	r3, r3
  222a10:	461a      	mov	r2, r3
  222a12:	f107 0318 	add.w	r3, r7, #24
  222a16:	4611      	mov	r1, r2
  222a18:	4618      	mov	r0, r3
  222a1a:	f7fd fe8f 	bl	22073c <inc_lock>
  222a1e:	4602      	mov	r2, r0
  222a20:	68fb      	ldr	r3, [r7, #12]
  222a22:	611a      	str	r2, [r3, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
  222a24:	68fb      	ldr	r3, [r7, #12]
  222a26:	691b      	ldr	r3, [r3, #16]
  222a28:	2b00      	cmp	r3, #0
  222a2a:	d102      	bne.n	222a32 <f_open+0x252>
  222a2c:	2302      	movs	r3, #2
  222a2e:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				}
			}
		}
#endif

		if (res == FR_OK) {
  222a32:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222a36:	2b00      	cmp	r3, #0
  222a38:	f040 8095 	bne.w	222b66 <f_open+0x386>
				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
			} else
#endif
			{
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
  222a3c:	697b      	ldr	r3, [r7, #20]
  222a3e:	6bba      	ldr	r2, [r7, #56]	; 0x38
  222a40:	4611      	mov	r1, r2
  222a42:	4618      	mov	r0, r3
  222a44:	f7fe fcab 	bl	22139e <ld_clust>
  222a48:	4602      	mov	r2, r0
  222a4a:	68fb      	ldr	r3, [r7, #12]
  222a4c:	609a      	str	r2, [r3, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
  222a4e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  222a50:	331c      	adds	r3, #28
  222a52:	4618      	mov	r0, r3
  222a54:	f7fd fcdc 	bl	220410 <ld_dword>
  222a58:	4602      	mov	r2, r0
  222a5a:	68fb      	ldr	r3, [r7, #12]
  222a5c:	60da      	str	r2, [r3, #12]
			}
#if _USE_FASTSEEK
			fp->cltbl = 0;			/* Disable fast seek mode */
  222a5e:	68fb      	ldr	r3, [r7, #12]
  222a60:	2200      	movs	r2, #0
  222a62:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
			fp->obj.fs = fs;	 	/* Validate the file object */
  222a64:	697a      	ldr	r2, [r7, #20]
  222a66:	68fb      	ldr	r3, [r7, #12]
  222a68:	601a      	str	r2, [r3, #0]
			fp->obj.id = fs->id;
  222a6a:	697b      	ldr	r3, [r7, #20]
  222a6c:	88da      	ldrh	r2, [r3, #6]
  222a6e:	68fb      	ldr	r3, [r7, #12]
  222a70:	809a      	strh	r2, [r3, #4]
			fp->flag = mode;		/* Set file access mode */
  222a72:	68fb      	ldr	r3, [r7, #12]
  222a74:	79fa      	ldrb	r2, [r7, #7]
  222a76:	751a      	strb	r2, [r3, #20]
			fp->err = 0;			/* Clear error flag */
  222a78:	68fb      	ldr	r3, [r7, #12]
  222a7a:	2200      	movs	r2, #0
  222a7c:	755a      	strb	r2, [r3, #21]
			fp->sect = 0;			/* Invalidate current data sector */
  222a7e:	68fb      	ldr	r3, [r7, #12]
  222a80:	2200      	movs	r2, #0
  222a82:	621a      	str	r2, [r3, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
  222a84:	68fb      	ldr	r3, [r7, #12]
  222a86:	2200      	movs	r2, #0
  222a88:	619a      	str	r2, [r3, #24]
#if !_FS_READONLY
#if !_FS_TINY
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
  222a8a:	68fb      	ldr	r3, [r7, #12]
  222a8c:	3330      	adds	r3, #48	; 0x30
  222a8e:	f44f 7200 	mov.w	r2, #512	; 0x200
  222a92:	2100      	movs	r1, #0
  222a94:	4618      	mov	r0, r3
  222a96:	f7fd fd46 	bl	220526 <mem_set>
#endif
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
  222a9a:	79fb      	ldrb	r3, [r7, #7]
  222a9c:	f003 0320 	and.w	r3, r3, #32
  222aa0:	2b00      	cmp	r3, #0
  222aa2:	d060      	beq.n	222b66 <f_open+0x386>
  222aa4:	68fb      	ldr	r3, [r7, #12]
  222aa6:	68db      	ldr	r3, [r3, #12]
  222aa8:	2b00      	cmp	r3, #0
  222aaa:	d05c      	beq.n	222b66 <f_open+0x386>
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
  222aac:	68fb      	ldr	r3, [r7, #12]
  222aae:	68da      	ldr	r2, [r3, #12]
  222ab0:	68fb      	ldr	r3, [r7, #12]
  222ab2:	619a      	str	r2, [r3, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
  222ab4:	697b      	ldr	r3, [r7, #20]
  222ab6:	895b      	ldrh	r3, [r3, #10]
  222ab8:	025b      	lsls	r3, r3, #9
  222aba:	657b      	str	r3, [r7, #84]	; 0x54
				clst = fp->obj.sclust;				/* Follow the cluster chain */
  222abc:	68fb      	ldr	r3, [r7, #12]
  222abe:	689b      	ldr	r3, [r3, #8]
  222ac0:	66bb      	str	r3, [r7, #104]	; 0x68
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
  222ac2:	68fb      	ldr	r3, [r7, #12]
  222ac4:	68db      	ldr	r3, [r3, #12]
  222ac6:	667b      	str	r3, [r7, #100]	; 0x64
  222ac8:	e016      	b.n	222af8 <f_open+0x318>
					clst = get_fat(&fp->obj, clst);
  222aca:	68fb      	ldr	r3, [r7, #12]
  222acc:	6eb9      	ldr	r1, [r7, #104]	; 0x68
  222ace:	4618      	mov	r0, r3
  222ad0:	f7fe f821 	bl	220b16 <get_fat>
  222ad4:	66b8      	str	r0, [r7, #104]	; 0x68
					if (clst <= 1) res = FR_INT_ERR;
  222ad6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  222ad8:	2b01      	cmp	r3, #1
  222ada:	d802      	bhi.n	222ae2 <f_open+0x302>
  222adc:	2302      	movs	r3, #2
  222ade:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
					if (clst == 0xFFFFFFFF) res = FR_DISK_ERR;
  222ae2:	6ebb      	ldr	r3, [r7, #104]	; 0x68
  222ae4:	f1b3 3fff 	cmp.w	r3, #4294967295
  222ae8:	d102      	bne.n	222af0 <f_open+0x310>
  222aea:	2301      	movs	r3, #1
  222aec:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
  222af0:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  222af2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  222af4:	1ad3      	subs	r3, r2, r3
  222af6:	667b      	str	r3, [r7, #100]	; 0x64
  222af8:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222afc:	2b00      	cmp	r3, #0
  222afe:	d103      	bne.n	222b08 <f_open+0x328>
  222b00:	6e7a      	ldr	r2, [r7, #100]	; 0x64
  222b02:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  222b04:	429a      	cmp	r2, r3
  222b06:	d8e0      	bhi.n	222aca <f_open+0x2ea>
				}
				fp->clust = clst;
  222b08:	68fb      	ldr	r3, [r7, #12]
  222b0a:	6eba      	ldr	r2, [r7, #104]	; 0x68
  222b0c:	61da      	str	r2, [r3, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
  222b0e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222b12:	2b00      	cmp	r3, #0
  222b14:	d127      	bne.n	222b66 <f_open+0x386>
  222b16:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  222b18:	f3c3 0308 	ubfx	r3, r3, #0, #9
  222b1c:	2b00      	cmp	r3, #0
  222b1e:	d022      	beq.n	222b66 <f_open+0x386>
					if ((sc = clust2sect(fs, clst)) == 0) {
  222b20:	697b      	ldr	r3, [r7, #20]
  222b22:	6eb9      	ldr	r1, [r7, #104]	; 0x68
  222b24:	4618      	mov	r0, r3
  222b26:	f7fd ffd7 	bl	220ad8 <clust2sect>
  222b2a:	6538      	str	r0, [r7, #80]	; 0x50
  222b2c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  222b2e:	2b00      	cmp	r3, #0
  222b30:	d103      	bne.n	222b3a <f_open+0x35a>
						res = FR_INT_ERR;
  222b32:	2302      	movs	r3, #2
  222b34:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
  222b38:	e015      	b.n	222b66 <f_open+0x386>
					} else {
						fp->sect = sc + (DWORD)(ofs / SS(fs));
  222b3a:	6e7b      	ldr	r3, [r7, #100]	; 0x64
  222b3c:	0a5a      	lsrs	r2, r3, #9
  222b3e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  222b40:	441a      	add	r2, r3
  222b42:	68fb      	ldr	r3, [r7, #12]
  222b44:	621a      	str	r2, [r3, #32]
#if !_FS_TINY
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
  222b46:	697b      	ldr	r3, [r7, #20]
  222b48:	7858      	ldrb	r0, [r3, #1]
  222b4a:	68fb      	ldr	r3, [r7, #12]
  222b4c:	f103 0130 	add.w	r1, r3, #48	; 0x30
  222b50:	68fb      	ldr	r3, [r7, #12]
  222b52:	6a1a      	ldr	r2, [r3, #32]
  222b54:	2301      	movs	r3, #1
  222b56:	f7fd fbe5 	bl	220324 <disk_read>
  222b5a:	4603      	mov	r3, r0
  222b5c:	2b00      	cmp	r3, #0
  222b5e:	d002      	beq.n	222b66 <f_open+0x386>
  222b60:	2301      	movs	r3, #1
  222b62:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
				}
			}
#endif
		}

		FREE_NAMBUF();
  222b66:	6e38      	ldr	r0, [r7, #96]	; 0x60
  222b68:	f000 fdae 	bl	2236c8 <ff_memfree>
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
  222b6c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
  222b70:	2b00      	cmp	r3, #0
  222b72:	d002      	beq.n	222b7a <f_open+0x39a>
  222b74:	68fb      	ldr	r3, [r7, #12]
  222b76:	2200      	movs	r2, #0
  222b78:	601a      	str	r2, [r3, #0]

	LEAVE_FF(fs, res);
  222b7a:	697b      	ldr	r3, [r7, #20]
  222b7c:	f897 206f 	ldrb.w	r2, [r7, #111]	; 0x6f
  222b80:	4611      	mov	r1, r2
  222b82:	4618      	mov	r0, r3
  222b84:	f7fd fd41 	bl	22060a <unlock_fs>
  222b88:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
}
  222b8c:	4618      	mov	r0, r3
  222b8e:	3770      	adds	r7, #112	; 0x70
  222b90:	46bd      	mov	sp, r7
  222b92:	bd80      	pop	{r7, pc}

00222b94 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
  222b94:	b580      	push	{r7, lr}
  222b96:	b08e      	sub	sp, #56	; 0x38
  222b98:	af00      	add	r7, sp, #0
  222b9a:	60f8      	str	r0, [r7, #12]
  222b9c:	60b9      	str	r1, [r7, #8]
  222b9e:	607a      	str	r2, [r7, #4]
  222ba0:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;
  222ba2:	68bb      	ldr	r3, [r7, #8]
  222ba4:	627b      	str	r3, [r7, #36]	; 0x24


	*br = 0;	/* Clear read byte counter */
  222ba6:	683b      	ldr	r3, [r7, #0]
  222ba8:	2200      	movs	r2, #0
  222baa:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
  222bac:	68fb      	ldr	r3, [r7, #12]
  222bae:	f107 0214 	add.w	r2, r7, #20
  222bb2:	4611      	mov	r1, r2
  222bb4:	4618      	mov	r0, r3
  222bb6:	f7ff fd67 	bl	222688 <validate>
  222bba:	4603      	mov	r3, r0
  222bbc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
  222bc0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  222bc4:	2b00      	cmp	r3, #0
  222bc6:	d107      	bne.n	222bd8 <f_read+0x44>
  222bc8:	68fb      	ldr	r3, [r7, #12]
  222bca:	7d5b      	ldrb	r3, [r3, #21]
  222bcc:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
  222bd0:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  222bd4:	2b00      	cmp	r3, #0
  222bd6:	d009      	beq.n	222bec <f_read+0x58>
  222bd8:	697b      	ldr	r3, [r7, #20]
  222bda:	f897 2037 	ldrb.w	r2, [r7, #55]	; 0x37
  222bde:	4611      	mov	r1, r2
  222be0:	4618      	mov	r0, r3
  222be2:	f7fd fd12 	bl	22060a <unlock_fs>
  222be6:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  222bea:	e13d      	b.n	222e68 <f_read+0x2d4>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
  222bec:	68fb      	ldr	r3, [r7, #12]
  222bee:	7d1b      	ldrb	r3, [r3, #20]
  222bf0:	f003 0301 	and.w	r3, r3, #1
  222bf4:	2b00      	cmp	r3, #0
  222bf6:	d106      	bne.n	222c06 <f_read+0x72>
  222bf8:	697b      	ldr	r3, [r7, #20]
  222bfa:	2107      	movs	r1, #7
  222bfc:	4618      	mov	r0, r3
  222bfe:	f7fd fd04 	bl	22060a <unlock_fs>
  222c02:	2307      	movs	r3, #7
  222c04:	e130      	b.n	222e68 <f_read+0x2d4>
	remain = fp->obj.objsize - fp->fptr;
  222c06:	68fb      	ldr	r3, [r7, #12]
  222c08:	68da      	ldr	r2, [r3, #12]
  222c0a:	68fb      	ldr	r3, [r7, #12]
  222c0c:	699b      	ldr	r3, [r3, #24]
  222c0e:	1ad3      	subs	r3, r2, r3
  222c10:	623b      	str	r3, [r7, #32]
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
  222c12:	687a      	ldr	r2, [r7, #4]
  222c14:	6a3b      	ldr	r3, [r7, #32]
  222c16:	429a      	cmp	r2, r3
  222c18:	f240 811c 	bls.w	222e54 <f_read+0x2c0>
  222c1c:	6a3b      	ldr	r3, [r7, #32]
  222c1e:	607b      	str	r3, [r7, #4]

	for ( ;  btr;								/* Repeat until all data read */
  222c20:	e118      	b.n	222e54 <f_read+0x2c0>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
  222c22:	68fb      	ldr	r3, [r7, #12]
  222c24:	699b      	ldr	r3, [r3, #24]
  222c26:	f3c3 0308 	ubfx	r3, r3, #0, #9
  222c2a:	2b00      	cmp	r3, #0
  222c2c:	f040 80e4 	bne.w	222df8 <f_read+0x264>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
  222c30:	68fb      	ldr	r3, [r7, #12]
  222c32:	699b      	ldr	r3, [r3, #24]
  222c34:	0a5b      	lsrs	r3, r3, #9
  222c36:	697a      	ldr	r2, [r7, #20]
  222c38:	8952      	ldrh	r2, [r2, #10]
  222c3a:	3a01      	subs	r2, #1
  222c3c:	4013      	ands	r3, r2
  222c3e:	61fb      	str	r3, [r7, #28]
			if (csect == 0) {					/* On the cluster boundary? */
  222c40:	69fb      	ldr	r3, [r7, #28]
  222c42:	2b00      	cmp	r3, #0
  222c44:	d139      	bne.n	222cba <f_read+0x126>
				if (fp->fptr == 0) {			/* On the top of the file? */
  222c46:	68fb      	ldr	r3, [r7, #12]
  222c48:	699b      	ldr	r3, [r3, #24]
  222c4a:	2b00      	cmp	r3, #0
  222c4c:	d103      	bne.n	222c56 <f_read+0xc2>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
  222c4e:	68fb      	ldr	r3, [r7, #12]
  222c50:	689b      	ldr	r3, [r3, #8]
  222c52:	633b      	str	r3, [r7, #48]	; 0x30
  222c54:	e013      	b.n	222c7e <f_read+0xea>
				} else {						/* Middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
  222c56:	68fb      	ldr	r3, [r7, #12]
  222c58:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  222c5a:	2b00      	cmp	r3, #0
  222c5c:	d007      	beq.n	222c6e <f_read+0xda>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
  222c5e:	68fb      	ldr	r3, [r7, #12]
  222c60:	699b      	ldr	r3, [r3, #24]
  222c62:	4619      	mov	r1, r3
  222c64:	68f8      	ldr	r0, [r7, #12]
  222c66:	f7fe f9df 	bl	221028 <clmt_clust>
  222c6a:	6338      	str	r0, [r7, #48]	; 0x30
  222c6c:	e007      	b.n	222c7e <f_read+0xea>
					} else
#endif
					{
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
  222c6e:	68fa      	ldr	r2, [r7, #12]
  222c70:	68fb      	ldr	r3, [r7, #12]
  222c72:	69db      	ldr	r3, [r3, #28]
  222c74:	4619      	mov	r1, r3
  222c76:	4610      	mov	r0, r2
  222c78:	f7fd ff4d 	bl	220b16 <get_fat>
  222c7c:	6338      	str	r0, [r7, #48]	; 0x30
					}
				}
				if (clst < 2) ABORT(fs, FR_INT_ERR);
  222c7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  222c80:	2b01      	cmp	r3, #1
  222c82:	d809      	bhi.n	222c98 <f_read+0x104>
  222c84:	68fb      	ldr	r3, [r7, #12]
  222c86:	2202      	movs	r2, #2
  222c88:	755a      	strb	r2, [r3, #21]
  222c8a:	697b      	ldr	r3, [r7, #20]
  222c8c:	2102      	movs	r1, #2
  222c8e:	4618      	mov	r0, r3
  222c90:	f7fd fcbb 	bl	22060a <unlock_fs>
  222c94:	2302      	movs	r3, #2
  222c96:	e0e7      	b.n	222e68 <f_read+0x2d4>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  222c98:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  222c9a:	f1b3 3fff 	cmp.w	r3, #4294967295
  222c9e:	d109      	bne.n	222cb4 <f_read+0x120>
  222ca0:	68fb      	ldr	r3, [r7, #12]
  222ca2:	2201      	movs	r2, #1
  222ca4:	755a      	strb	r2, [r3, #21]
  222ca6:	697b      	ldr	r3, [r7, #20]
  222ca8:	2101      	movs	r1, #1
  222caa:	4618      	mov	r0, r3
  222cac:	f7fd fcad 	bl	22060a <unlock_fs>
  222cb0:	2301      	movs	r3, #1
  222cb2:	e0d9      	b.n	222e68 <f_read+0x2d4>
				fp->clust = clst;				/* Update current cluster */
  222cb4:	68fb      	ldr	r3, [r7, #12]
  222cb6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  222cb8:	61da      	str	r2, [r3, #28]
			}
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
  222cba:	697a      	ldr	r2, [r7, #20]
  222cbc:	68fb      	ldr	r3, [r7, #12]
  222cbe:	69db      	ldr	r3, [r3, #28]
  222cc0:	4619      	mov	r1, r3
  222cc2:	4610      	mov	r0, r2
  222cc4:	f7fd ff08 	bl	220ad8 <clust2sect>
  222cc8:	61b8      	str	r0, [r7, #24]
			if (!sect) ABORT(fs, FR_INT_ERR);
  222cca:	69bb      	ldr	r3, [r7, #24]
  222ccc:	2b00      	cmp	r3, #0
  222cce:	d109      	bne.n	222ce4 <f_read+0x150>
  222cd0:	68fb      	ldr	r3, [r7, #12]
  222cd2:	2202      	movs	r2, #2
  222cd4:	755a      	strb	r2, [r3, #21]
  222cd6:	697b      	ldr	r3, [r7, #20]
  222cd8:	2102      	movs	r1, #2
  222cda:	4618      	mov	r0, r3
  222cdc:	f7fd fc95 	bl	22060a <unlock_fs>
  222ce0:	2302      	movs	r3, #2
  222ce2:	e0c1      	b.n	222e68 <f_read+0x2d4>
			sect += csect;
  222ce4:	69ba      	ldr	r2, [r7, #24]
  222ce6:	69fb      	ldr	r3, [r7, #28]
  222ce8:	4413      	add	r3, r2
  222cea:	61bb      	str	r3, [r7, #24]
			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
  222cec:	687b      	ldr	r3, [r7, #4]
  222cee:	0a5b      	lsrs	r3, r3, #9
  222cf0:	62bb      	str	r3, [r7, #40]	; 0x28
			if (cc) {							/* Read maximum contiguous sectors directly */
  222cf2:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222cf4:	2b00      	cmp	r3, #0
  222cf6:	d03e      	beq.n	222d76 <f_read+0x1e2>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
  222cf8:	69fa      	ldr	r2, [r7, #28]
  222cfa:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222cfc:	4413      	add	r3, r2
  222cfe:	697a      	ldr	r2, [r7, #20]
  222d00:	8952      	ldrh	r2, [r2, #10]
  222d02:	4293      	cmp	r3, r2
  222d04:	d905      	bls.n	222d12 <f_read+0x17e>
					cc = fs->csize - csect;
  222d06:	697b      	ldr	r3, [r7, #20]
  222d08:	895b      	ldrh	r3, [r3, #10]
  222d0a:	461a      	mov	r2, r3
  222d0c:	69fb      	ldr	r3, [r7, #28]
  222d0e:	1ad3      	subs	r3, r2, r3
  222d10:	62bb      	str	r3, [r7, #40]	; 0x28
				}
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  222d12:	697b      	ldr	r3, [r7, #20]
  222d14:	7858      	ldrb	r0, [r3, #1]
  222d16:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222d18:	69ba      	ldr	r2, [r7, #24]
  222d1a:	6a79      	ldr	r1, [r7, #36]	; 0x24
  222d1c:	f7fd fb02 	bl	220324 <disk_read>
  222d20:	4603      	mov	r3, r0
  222d22:	2b00      	cmp	r3, #0
  222d24:	d009      	beq.n	222d3a <f_read+0x1a6>
  222d26:	68fb      	ldr	r3, [r7, #12]
  222d28:	2201      	movs	r2, #1
  222d2a:	755a      	strb	r2, [r3, #21]
  222d2c:	697b      	ldr	r3, [r7, #20]
  222d2e:	2101      	movs	r1, #1
  222d30:	4618      	mov	r0, r3
  222d32:	f7fd fc6a 	bl	22060a <unlock_fs>
  222d36:	2301      	movs	r3, #1
  222d38:	e096      	b.n	222e68 <f_read+0x2d4>
#if _FS_TINY
				if (fs->wflag && fs->winsect - sect < cc) {
					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
				}
#else
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
  222d3a:	68fb      	ldr	r3, [r7, #12]
  222d3c:	7d1b      	ldrb	r3, [r3, #20]
  222d3e:	b25b      	sxtb	r3, r3
  222d40:	2b00      	cmp	r3, #0
  222d42:	da14      	bge.n	222d6e <f_read+0x1da>
  222d44:	68fb      	ldr	r3, [r7, #12]
  222d46:	6a1a      	ldr	r2, [r3, #32]
  222d48:	69bb      	ldr	r3, [r7, #24]
  222d4a:	1ad2      	subs	r2, r2, r3
  222d4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222d4e:	429a      	cmp	r2, r3
  222d50:	d20d      	bcs.n	222d6e <f_read+0x1da>
					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
  222d52:	68fb      	ldr	r3, [r7, #12]
  222d54:	6a1a      	ldr	r2, [r3, #32]
  222d56:	69bb      	ldr	r3, [r7, #24]
  222d58:	1ad3      	subs	r3, r2, r3
  222d5a:	025b      	lsls	r3, r3, #9
  222d5c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  222d5e:	18d0      	adds	r0, r2, r3
  222d60:	68fb      	ldr	r3, [r7, #12]
  222d62:	3330      	adds	r3, #48	; 0x30
  222d64:	f44f 7200 	mov.w	r2, #512	; 0x200
  222d68:	4619      	mov	r1, r3
  222d6a:	f7fd fbbb 	bl	2204e4 <mem_cpy>
				}
#endif
#endif
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
  222d6e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222d70:	025b      	lsls	r3, r3, #9
  222d72:	62fb      	str	r3, [r7, #44]	; 0x2c
				continue;
  222d74:	e05a      	b.n	222e2c <f_read+0x298>
			}
#if !_FS_TINY
			if (fp->sect != sect) {			/* Load data sector if not in cache */
  222d76:	68fb      	ldr	r3, [r7, #12]
  222d78:	6a1a      	ldr	r2, [r3, #32]
  222d7a:	69bb      	ldr	r3, [r7, #24]
  222d7c:	429a      	cmp	r2, r3
  222d7e:	d038      	beq.n	222df2 <f_read+0x25e>
#if !_FS_READONLY
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
  222d80:	68fb      	ldr	r3, [r7, #12]
  222d82:	7d1b      	ldrb	r3, [r3, #20]
  222d84:	b25b      	sxtb	r3, r3
  222d86:	2b00      	cmp	r3, #0
  222d88:	da1d      	bge.n	222dc6 <f_read+0x232>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  222d8a:	697b      	ldr	r3, [r7, #20]
  222d8c:	7858      	ldrb	r0, [r3, #1]
  222d8e:	68fb      	ldr	r3, [r7, #12]
  222d90:	f103 0130 	add.w	r1, r3, #48	; 0x30
  222d94:	68fb      	ldr	r3, [r7, #12]
  222d96:	6a1a      	ldr	r2, [r3, #32]
  222d98:	2301      	movs	r3, #1
  222d9a:	f7fd fae3 	bl	220364 <disk_write>
  222d9e:	4603      	mov	r3, r0
  222da0:	2b00      	cmp	r3, #0
  222da2:	d009      	beq.n	222db8 <f_read+0x224>
  222da4:	68fb      	ldr	r3, [r7, #12]
  222da6:	2201      	movs	r2, #1
  222da8:	755a      	strb	r2, [r3, #21]
  222daa:	697b      	ldr	r3, [r7, #20]
  222dac:	2101      	movs	r1, #1
  222dae:	4618      	mov	r0, r3
  222db0:	f7fd fc2b 	bl	22060a <unlock_fs>
  222db4:	2301      	movs	r3, #1
  222db6:	e057      	b.n	222e68 <f_read+0x2d4>
					fp->flag &= (BYTE)~FA_DIRTY;
  222db8:	68fb      	ldr	r3, [r7, #12]
  222dba:	7d1b      	ldrb	r3, [r3, #20]
  222dbc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  222dc0:	b2da      	uxtb	r2, r3
  222dc2:	68fb      	ldr	r3, [r7, #12]
  222dc4:	751a      	strb	r2, [r3, #20]
				}
#endif
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
  222dc6:	697b      	ldr	r3, [r7, #20]
  222dc8:	7858      	ldrb	r0, [r3, #1]
  222dca:	68fb      	ldr	r3, [r7, #12]
  222dcc:	f103 0130 	add.w	r1, r3, #48	; 0x30
  222dd0:	2301      	movs	r3, #1
  222dd2:	69ba      	ldr	r2, [r7, #24]
  222dd4:	f7fd faa6 	bl	220324 <disk_read>
  222dd8:	4603      	mov	r3, r0
  222dda:	2b00      	cmp	r3, #0
  222ddc:	d009      	beq.n	222df2 <f_read+0x25e>
  222dde:	68fb      	ldr	r3, [r7, #12]
  222de0:	2201      	movs	r2, #1
  222de2:	755a      	strb	r2, [r3, #21]
  222de4:	697b      	ldr	r3, [r7, #20]
  222de6:	2101      	movs	r1, #1
  222de8:	4618      	mov	r0, r3
  222dea:	f7fd fc0e 	bl	22060a <unlock_fs>
  222dee:	2301      	movs	r3, #1
  222df0:	e03a      	b.n	222e68 <f_read+0x2d4>
			}
#endif
			fp->sect = sect;
  222df2:	68fb      	ldr	r3, [r7, #12]
  222df4:	69ba      	ldr	r2, [r7, #24]
  222df6:	621a      	str	r2, [r3, #32]
		}
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
  222df8:	68fb      	ldr	r3, [r7, #12]
  222dfa:	699b      	ldr	r3, [r3, #24]
  222dfc:	f3c3 0308 	ubfx	r3, r3, #0, #9
  222e00:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
  222e04:	62fb      	str	r3, [r7, #44]	; 0x2c
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
  222e06:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  222e08:	687b      	ldr	r3, [r7, #4]
  222e0a:	429a      	cmp	r2, r3
  222e0c:	d901      	bls.n	222e12 <f_read+0x27e>
  222e0e:	687b      	ldr	r3, [r7, #4]
  222e10:	62fb      	str	r3, [r7, #44]	; 0x2c
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
  222e12:	68fb      	ldr	r3, [r7, #12]
  222e14:	f103 0230 	add.w	r2, r3, #48	; 0x30
  222e18:	68fb      	ldr	r3, [r7, #12]
  222e1a:	699b      	ldr	r3, [r3, #24]
  222e1c:	f3c3 0308 	ubfx	r3, r3, #0, #9
  222e20:	4413      	add	r3, r2
  222e22:	6afa      	ldr	r2, [r7, #44]	; 0x2c
  222e24:	4619      	mov	r1, r3
  222e26:	6a78      	ldr	r0, [r7, #36]	; 0x24
  222e28:	f7fd fb5c 	bl	2204e4 <mem_cpy>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  222e2c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  222e2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  222e30:	4413      	add	r3, r2
  222e32:	627b      	str	r3, [r7, #36]	; 0x24
  222e34:	68fb      	ldr	r3, [r7, #12]
  222e36:	699a      	ldr	r2, [r3, #24]
  222e38:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  222e3a:	441a      	add	r2, r3
  222e3c:	68fb      	ldr	r3, [r7, #12]
  222e3e:	619a      	str	r2, [r3, #24]
  222e40:	683b      	ldr	r3, [r7, #0]
  222e42:	681a      	ldr	r2, [r3, #0]
  222e44:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  222e46:	441a      	add	r2, r3
  222e48:	683b      	ldr	r3, [r7, #0]
  222e4a:	601a      	str	r2, [r3, #0]
  222e4c:	687a      	ldr	r2, [r7, #4]
  222e4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  222e50:	1ad3      	subs	r3, r2, r3
  222e52:	607b      	str	r3, [r7, #4]
	for ( ;  btr;								/* Repeat until all data read */
  222e54:	687b      	ldr	r3, [r7, #4]
  222e56:	2b00      	cmp	r3, #0
  222e58:	f47f aee3 	bne.w	222c22 <f_read+0x8e>
#endif
	}

	LEAVE_FF(fs, FR_OK);
  222e5c:	697b      	ldr	r3, [r7, #20]
  222e5e:	2100      	movs	r1, #0
  222e60:	4618      	mov	r0, r3
  222e62:	f7fd fbd2 	bl	22060a <unlock_fs>
  222e66:	2300      	movs	r3, #0
}
  222e68:	4618      	mov	r0, r3
  222e6a:	3738      	adds	r7, #56	; 0x38
  222e6c:	46bd      	mov	sp, r7
  222e6e:	bd80      	pop	{r7, pc}

00222e70 <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
  222e70:	b580      	push	{r7, lr}
  222e72:	b08c      	sub	sp, #48	; 0x30
  222e74:	af00      	add	r7, sp, #0
  222e76:	60f8      	str	r0, [r7, #12]
  222e78:	60b9      	str	r1, [r7, #8]
  222e7a:	607a      	str	r2, [r7, #4]
  222e7c:	603b      	str	r3, [r7, #0]
	FRESULT res;
	FATFS *fs;
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;
  222e7e:	68bb      	ldr	r3, [r7, #8]
  222e80:	61fb      	str	r3, [r7, #28]


	*bw = 0;	/* Clear write byte counter */
  222e82:	683b      	ldr	r3, [r7, #0]
  222e84:	2200      	movs	r2, #0
  222e86:	601a      	str	r2, [r3, #0]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
  222e88:	68fb      	ldr	r3, [r7, #12]
  222e8a:	f107 0210 	add.w	r2, r7, #16
  222e8e:	4611      	mov	r1, r2
  222e90:	4618      	mov	r0, r3
  222e92:	f7ff fbf9 	bl	222688 <validate>
  222e96:	4603      	mov	r3, r0
  222e98:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
  222e9c:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  222ea0:	2b00      	cmp	r3, #0
  222ea2:	d107      	bne.n	222eb4 <f_write+0x44>
  222ea4:	68fb      	ldr	r3, [r7, #12]
  222ea6:	7d5b      	ldrb	r3, [r3, #21]
  222ea8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  222eac:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  222eb0:	2b00      	cmp	r3, #0
  222eb2:	d009      	beq.n	222ec8 <f_write+0x58>
  222eb4:	693b      	ldr	r3, [r7, #16]
  222eb6:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
  222eba:	4611      	mov	r1, r2
  222ebc:	4618      	mov	r0, r3
  222ebe:	f7fd fba4 	bl	22060a <unlock_fs>
  222ec2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  222ec6:	e173      	b.n	2231b0 <f_write+0x340>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
  222ec8:	68fb      	ldr	r3, [r7, #12]
  222eca:	7d1b      	ldrb	r3, [r3, #20]
  222ecc:	f003 0302 	and.w	r3, r3, #2
  222ed0:	2b00      	cmp	r3, #0
  222ed2:	d106      	bne.n	222ee2 <f_write+0x72>
  222ed4:	693b      	ldr	r3, [r7, #16]
  222ed6:	2107      	movs	r1, #7
  222ed8:	4618      	mov	r0, r3
  222eda:	f7fd fb96 	bl	22060a <unlock_fs>
  222ede:	2307      	movs	r3, #7
  222ee0:	e166      	b.n	2231b0 <f_write+0x340>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
  222ee2:	68fb      	ldr	r3, [r7, #12]
  222ee4:	699a      	ldr	r2, [r3, #24]
  222ee6:	687b      	ldr	r3, [r7, #4]
  222ee8:	441a      	add	r2, r3
  222eea:	68fb      	ldr	r3, [r7, #12]
  222eec:	699b      	ldr	r3, [r3, #24]
  222eee:	429a      	cmp	r2, r3
  222ef0:	f080 814b 	bcs.w	22318a <f_write+0x31a>
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
  222ef4:	68fb      	ldr	r3, [r7, #12]
  222ef6:	699b      	ldr	r3, [r3, #24]
  222ef8:	43db      	mvns	r3, r3
  222efa:	607b      	str	r3, [r7, #4]
	}

	for ( ;  btw;							/* Repeat until all data written */
  222efc:	e145      	b.n	22318a <f_write+0x31a>
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
  222efe:	68fb      	ldr	r3, [r7, #12]
  222f00:	699b      	ldr	r3, [r3, #24]
  222f02:	f3c3 0308 	ubfx	r3, r3, #0, #9
  222f06:	2b00      	cmp	r3, #0
  222f08:	f040 8101 	bne.w	22310e <f_write+0x29e>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
  222f0c:	68fb      	ldr	r3, [r7, #12]
  222f0e:	699b      	ldr	r3, [r3, #24]
  222f10:	0a5b      	lsrs	r3, r3, #9
  222f12:	693a      	ldr	r2, [r7, #16]
  222f14:	8952      	ldrh	r2, [r2, #10]
  222f16:	3a01      	subs	r2, #1
  222f18:	4013      	ands	r3, r2
  222f1a:	61bb      	str	r3, [r7, #24]
			if (csect == 0) {				/* On the cluster boundary? */
  222f1c:	69bb      	ldr	r3, [r7, #24]
  222f1e:	2b00      	cmp	r3, #0
  222f20:	d14d      	bne.n	222fbe <f_write+0x14e>
				if (fp->fptr == 0) {		/* On the top of the file? */
  222f22:	68fb      	ldr	r3, [r7, #12]
  222f24:	699b      	ldr	r3, [r3, #24]
  222f26:	2b00      	cmp	r3, #0
  222f28:	d10c      	bne.n	222f44 <f_write+0xd4>
					clst = fp->obj.sclust;	/* Follow from the origin */
  222f2a:	68fb      	ldr	r3, [r7, #12]
  222f2c:	689b      	ldr	r3, [r3, #8]
  222f2e:	62bb      	str	r3, [r7, #40]	; 0x28
					if (clst == 0) {		/* If no cluster is allocated, */
  222f30:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222f32:	2b00      	cmp	r3, #0
  222f34:	d11a      	bne.n	222f6c <f_write+0xfc>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
  222f36:	68fb      	ldr	r3, [r7, #12]
  222f38:	2100      	movs	r1, #0
  222f3a:	4618      	mov	r0, r3
  222f3c:	f7fd ffdc 	bl	220ef8 <create_chain>
  222f40:	62b8      	str	r0, [r7, #40]	; 0x28
  222f42:	e013      	b.n	222f6c <f_write+0xfc>
					}
				} else {					/* On the middle or end of the file */
#if _USE_FASTSEEK
					if (fp->cltbl) {
  222f44:	68fb      	ldr	r3, [r7, #12]
  222f46:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  222f48:	2b00      	cmp	r3, #0
  222f4a:	d007      	beq.n	222f5c <f_write+0xec>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
  222f4c:	68fb      	ldr	r3, [r7, #12]
  222f4e:	699b      	ldr	r3, [r3, #24]
  222f50:	4619      	mov	r1, r3
  222f52:	68f8      	ldr	r0, [r7, #12]
  222f54:	f7fe f868 	bl	221028 <clmt_clust>
  222f58:	62b8      	str	r0, [r7, #40]	; 0x28
  222f5a:	e007      	b.n	222f6c <f_write+0xfc>
					} else
#endif
					{
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
  222f5c:	68fa      	ldr	r2, [r7, #12]
  222f5e:	68fb      	ldr	r3, [r7, #12]
  222f60:	69db      	ldr	r3, [r3, #28]
  222f62:	4619      	mov	r1, r3
  222f64:	4610      	mov	r0, r2
  222f66:	f7fd ffc7 	bl	220ef8 <create_chain>
  222f6a:	62b8      	str	r0, [r7, #40]	; 0x28
					}
				}
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  222f6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222f6e:	2b00      	cmp	r3, #0
  222f70:	f000 8110 	beq.w	223194 <f_write+0x324>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
  222f74:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222f76:	2b01      	cmp	r3, #1
  222f78:	d109      	bne.n	222f8e <f_write+0x11e>
  222f7a:	68fb      	ldr	r3, [r7, #12]
  222f7c:	2202      	movs	r2, #2
  222f7e:	755a      	strb	r2, [r3, #21]
  222f80:	693b      	ldr	r3, [r7, #16]
  222f82:	2102      	movs	r1, #2
  222f84:	4618      	mov	r0, r3
  222f86:	f7fd fb40 	bl	22060a <unlock_fs>
  222f8a:	2302      	movs	r3, #2
  222f8c:	e110      	b.n	2231b0 <f_write+0x340>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
  222f8e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  222f90:	f1b3 3fff 	cmp.w	r3, #4294967295
  222f94:	d109      	bne.n	222faa <f_write+0x13a>
  222f96:	68fb      	ldr	r3, [r7, #12]
  222f98:	2201      	movs	r2, #1
  222f9a:	755a      	strb	r2, [r3, #21]
  222f9c:	693b      	ldr	r3, [r7, #16]
  222f9e:	2101      	movs	r1, #1
  222fa0:	4618      	mov	r0, r3
  222fa2:	f7fd fb32 	bl	22060a <unlock_fs>
  222fa6:	2301      	movs	r3, #1
  222fa8:	e102      	b.n	2231b0 <f_write+0x340>
				fp->clust = clst;			/* Update current cluster */
  222faa:	68fb      	ldr	r3, [r7, #12]
  222fac:	6aba      	ldr	r2, [r7, #40]	; 0x28
  222fae:	61da      	str	r2, [r3, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
  222fb0:	68fb      	ldr	r3, [r7, #12]
  222fb2:	689b      	ldr	r3, [r3, #8]
  222fb4:	2b00      	cmp	r3, #0
  222fb6:	d102      	bne.n	222fbe <f_write+0x14e>
  222fb8:	68fb      	ldr	r3, [r7, #12]
  222fba:	6aba      	ldr	r2, [r7, #40]	; 0x28
  222fbc:	609a      	str	r2, [r3, #8]
			}
#if _FS_TINY
			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Write-back sector cache */
#else
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
  222fbe:	68fb      	ldr	r3, [r7, #12]
  222fc0:	7d1b      	ldrb	r3, [r3, #20]
  222fc2:	b25b      	sxtb	r3, r3
  222fc4:	2b00      	cmp	r3, #0
  222fc6:	da1d      	bge.n	223004 <f_write+0x194>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
  222fc8:	693b      	ldr	r3, [r7, #16]
  222fca:	7858      	ldrb	r0, [r3, #1]
  222fcc:	68fb      	ldr	r3, [r7, #12]
  222fce:	f103 0130 	add.w	r1, r3, #48	; 0x30
  222fd2:	68fb      	ldr	r3, [r7, #12]
  222fd4:	6a1a      	ldr	r2, [r3, #32]
  222fd6:	2301      	movs	r3, #1
  222fd8:	f7fd f9c4 	bl	220364 <disk_write>
  222fdc:	4603      	mov	r3, r0
  222fde:	2b00      	cmp	r3, #0
  222fe0:	d009      	beq.n	222ff6 <f_write+0x186>
  222fe2:	68fb      	ldr	r3, [r7, #12]
  222fe4:	2201      	movs	r2, #1
  222fe6:	755a      	strb	r2, [r3, #21]
  222fe8:	693b      	ldr	r3, [r7, #16]
  222fea:	2101      	movs	r1, #1
  222fec:	4618      	mov	r0, r3
  222fee:	f7fd fb0c 	bl	22060a <unlock_fs>
  222ff2:	2301      	movs	r3, #1
  222ff4:	e0dc      	b.n	2231b0 <f_write+0x340>
				fp->flag &= (BYTE)~FA_DIRTY;
  222ff6:	68fb      	ldr	r3, [r7, #12]
  222ff8:	7d1b      	ldrb	r3, [r3, #20]
  222ffa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  222ffe:	b2da      	uxtb	r2, r3
  223000:	68fb      	ldr	r3, [r7, #12]
  223002:	751a      	strb	r2, [r3, #20]
			}
#endif
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
  223004:	693a      	ldr	r2, [r7, #16]
  223006:	68fb      	ldr	r3, [r7, #12]
  223008:	69db      	ldr	r3, [r3, #28]
  22300a:	4619      	mov	r1, r3
  22300c:	4610      	mov	r0, r2
  22300e:	f7fd fd63 	bl	220ad8 <clust2sect>
  223012:	6178      	str	r0, [r7, #20]
			if (!sect) ABORT(fs, FR_INT_ERR);
  223014:	697b      	ldr	r3, [r7, #20]
  223016:	2b00      	cmp	r3, #0
  223018:	d109      	bne.n	22302e <f_write+0x1be>
  22301a:	68fb      	ldr	r3, [r7, #12]
  22301c:	2202      	movs	r2, #2
  22301e:	755a      	strb	r2, [r3, #21]
  223020:	693b      	ldr	r3, [r7, #16]
  223022:	2102      	movs	r1, #2
  223024:	4618      	mov	r0, r3
  223026:	f7fd faf0 	bl	22060a <unlock_fs>
  22302a:	2302      	movs	r3, #2
  22302c:	e0c0      	b.n	2231b0 <f_write+0x340>
			sect += csect;
  22302e:	697a      	ldr	r2, [r7, #20]
  223030:	69bb      	ldr	r3, [r7, #24]
  223032:	4413      	add	r3, r2
  223034:	617b      	str	r3, [r7, #20]
			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
  223036:	687b      	ldr	r3, [r7, #4]
  223038:	0a5b      	lsrs	r3, r3, #9
  22303a:	623b      	str	r3, [r7, #32]
			if (cc) {						/* Write maximum contiguous sectors directly */
  22303c:	6a3b      	ldr	r3, [r7, #32]
  22303e:	2b00      	cmp	r3, #0
  223040:	d041      	beq.n	2230c6 <f_write+0x256>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
  223042:	69ba      	ldr	r2, [r7, #24]
  223044:	6a3b      	ldr	r3, [r7, #32]
  223046:	4413      	add	r3, r2
  223048:	693a      	ldr	r2, [r7, #16]
  22304a:	8952      	ldrh	r2, [r2, #10]
  22304c:	4293      	cmp	r3, r2
  22304e:	d905      	bls.n	22305c <f_write+0x1ec>
					cc = fs->csize - csect;
  223050:	693b      	ldr	r3, [r7, #16]
  223052:	895b      	ldrh	r3, [r3, #10]
  223054:	461a      	mov	r2, r3
  223056:	69bb      	ldr	r3, [r7, #24]
  223058:	1ad3      	subs	r3, r2, r3
  22305a:	623b      	str	r3, [r7, #32]
				}
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
  22305c:	693b      	ldr	r3, [r7, #16]
  22305e:	7858      	ldrb	r0, [r3, #1]
  223060:	6a3b      	ldr	r3, [r7, #32]
  223062:	697a      	ldr	r2, [r7, #20]
  223064:	69f9      	ldr	r1, [r7, #28]
  223066:	f7fd f97d 	bl	220364 <disk_write>
  22306a:	4603      	mov	r3, r0
  22306c:	2b00      	cmp	r3, #0
  22306e:	d009      	beq.n	223084 <f_write+0x214>
  223070:	68fb      	ldr	r3, [r7, #12]
  223072:	2201      	movs	r2, #1
  223074:	755a      	strb	r2, [r3, #21]
  223076:	693b      	ldr	r3, [r7, #16]
  223078:	2101      	movs	r1, #1
  22307a:	4618      	mov	r0, r3
  22307c:	f7fd fac5 	bl	22060a <unlock_fs>
  223080:	2301      	movs	r3, #1
  223082:	e095      	b.n	2231b0 <f_write+0x340>
				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
					fs->wflag = 0;
				}
#else
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
  223084:	68fb      	ldr	r3, [r7, #12]
  223086:	6a1a      	ldr	r2, [r3, #32]
  223088:	697b      	ldr	r3, [r7, #20]
  22308a:	1ad2      	subs	r2, r2, r3
  22308c:	6a3b      	ldr	r3, [r7, #32]
  22308e:	429a      	cmp	r2, r3
  223090:	d215      	bcs.n	2230be <f_write+0x24e>
					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
  223092:	68fb      	ldr	r3, [r7, #12]
  223094:	f103 0030 	add.w	r0, r3, #48	; 0x30
  223098:	68fb      	ldr	r3, [r7, #12]
  22309a:	6a1a      	ldr	r2, [r3, #32]
  22309c:	697b      	ldr	r3, [r7, #20]
  22309e:	1ad3      	subs	r3, r2, r3
  2230a0:	025b      	lsls	r3, r3, #9
  2230a2:	69fa      	ldr	r2, [r7, #28]
  2230a4:	4413      	add	r3, r2
  2230a6:	f44f 7200 	mov.w	r2, #512	; 0x200
  2230aa:	4619      	mov	r1, r3
  2230ac:	f7fd fa1a 	bl	2204e4 <mem_cpy>
					fp->flag &= (BYTE)~FA_DIRTY;
  2230b0:	68fb      	ldr	r3, [r7, #12]
  2230b2:	7d1b      	ldrb	r3, [r3, #20]
  2230b4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  2230b8:	b2da      	uxtb	r2, r3
  2230ba:	68fb      	ldr	r3, [r7, #12]
  2230bc:	751a      	strb	r2, [r3, #20]
				}
#endif
#endif
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
  2230be:	6a3b      	ldr	r3, [r7, #32]
  2230c0:	025b      	lsls	r3, r3, #9
  2230c2:	627b      	str	r3, [r7, #36]	; 0x24
				continue;
  2230c4:	e044      	b.n	223150 <f_write+0x2e0>
			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling on the growing edge */
				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
				fs->winsect = sect;
			}
#else
			if (fp->sect != sect && 		/* Fill sector cache with file data */
  2230c6:	68fb      	ldr	r3, [r7, #12]
  2230c8:	6a1a      	ldr	r2, [r3, #32]
  2230ca:	697b      	ldr	r3, [r7, #20]
  2230cc:	429a      	cmp	r2, r3
  2230ce:	d01b      	beq.n	223108 <f_write+0x298>
				fp->fptr < fp->obj.objsize &&
  2230d0:	68fb      	ldr	r3, [r7, #12]
  2230d2:	699a      	ldr	r2, [r3, #24]
  2230d4:	68fb      	ldr	r3, [r7, #12]
  2230d6:	68db      	ldr	r3, [r3, #12]
			if (fp->sect != sect && 		/* Fill sector cache with file data */
  2230d8:	429a      	cmp	r2, r3
  2230da:	d215      	bcs.n	223108 <f_write+0x298>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
  2230dc:	693b      	ldr	r3, [r7, #16]
  2230de:	7858      	ldrb	r0, [r3, #1]
  2230e0:	68fb      	ldr	r3, [r7, #12]
  2230e2:	f103 0130 	add.w	r1, r3, #48	; 0x30
  2230e6:	2301      	movs	r3, #1
  2230e8:	697a      	ldr	r2, [r7, #20]
  2230ea:	f7fd f91b 	bl	220324 <disk_read>
  2230ee:	4603      	mov	r3, r0
				fp->fptr < fp->obj.objsize &&
  2230f0:	2b00      	cmp	r3, #0
  2230f2:	d009      	beq.n	223108 <f_write+0x298>
					ABORT(fs, FR_DISK_ERR);
  2230f4:	68fb      	ldr	r3, [r7, #12]
  2230f6:	2201      	movs	r2, #1
  2230f8:	755a      	strb	r2, [r3, #21]
  2230fa:	693b      	ldr	r3, [r7, #16]
  2230fc:	2101      	movs	r1, #1
  2230fe:	4618      	mov	r0, r3
  223100:	f7fd fa83 	bl	22060a <unlock_fs>
  223104:	2301      	movs	r3, #1
  223106:	e053      	b.n	2231b0 <f_write+0x340>
			}
#endif
			fp->sect = sect;
  223108:	68fb      	ldr	r3, [r7, #12]
  22310a:	697a      	ldr	r2, [r7, #20]
  22310c:	621a      	str	r2, [r3, #32]
		}
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
  22310e:	68fb      	ldr	r3, [r7, #12]
  223110:	699b      	ldr	r3, [r3, #24]
  223112:	f3c3 0308 	ubfx	r3, r3, #0, #9
  223116:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
  22311a:	627b      	str	r3, [r7, #36]	; 0x24
		if (wcnt > btw) wcnt = btw;					/* Clip it by btw if needed */
  22311c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  22311e:	687b      	ldr	r3, [r7, #4]
  223120:	429a      	cmp	r2, r3
  223122:	d901      	bls.n	223128 <f_write+0x2b8>
  223124:	687b      	ldr	r3, [r7, #4]
  223126:	627b      	str	r3, [r7, #36]	; 0x24
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
  223128:	68fb      	ldr	r3, [r7, #12]
  22312a:	f103 0230 	add.w	r2, r3, #48	; 0x30
  22312e:	68fb      	ldr	r3, [r7, #12]
  223130:	699b      	ldr	r3, [r3, #24]
  223132:	f3c3 0308 	ubfx	r3, r3, #0, #9
  223136:	4413      	add	r3, r2
  223138:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  22313a:	69f9      	ldr	r1, [r7, #28]
  22313c:	4618      	mov	r0, r3
  22313e:	f7fd f9d1 	bl	2204e4 <mem_cpy>
		fp->flag |= FA_DIRTY;
  223142:	68fb      	ldr	r3, [r7, #12]
  223144:	7d1b      	ldrb	r3, [r3, #20]
  223146:	f063 037f 	orn	r3, r3, #127	; 0x7f
  22314a:	b2da      	uxtb	r2, r3
  22314c:	68fb      	ldr	r3, [r7, #12]
  22314e:	751a      	strb	r2, [r3, #20]
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
  223150:	69fa      	ldr	r2, [r7, #28]
  223152:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  223154:	4413      	add	r3, r2
  223156:	61fb      	str	r3, [r7, #28]
  223158:	68fb      	ldr	r3, [r7, #12]
  22315a:	699a      	ldr	r2, [r3, #24]
  22315c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  22315e:	441a      	add	r2, r3
  223160:	68fb      	ldr	r3, [r7, #12]
  223162:	619a      	str	r2, [r3, #24]
  223164:	68fb      	ldr	r3, [r7, #12]
  223166:	68da      	ldr	r2, [r3, #12]
  223168:	68fb      	ldr	r3, [r7, #12]
  22316a:	699b      	ldr	r3, [r3, #24]
  22316c:	429a      	cmp	r2, r3
  22316e:	bf38      	it	cc
  223170:	461a      	movcc	r2, r3
  223172:	68fb      	ldr	r3, [r7, #12]
  223174:	60da      	str	r2, [r3, #12]
  223176:	683b      	ldr	r3, [r7, #0]
  223178:	681a      	ldr	r2, [r3, #0]
  22317a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  22317c:	441a      	add	r2, r3
  22317e:	683b      	ldr	r3, [r7, #0]
  223180:	601a      	str	r2, [r3, #0]
  223182:	687a      	ldr	r2, [r7, #4]
  223184:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  223186:	1ad3      	subs	r3, r2, r3
  223188:	607b      	str	r3, [r7, #4]
	for ( ;  btw;							/* Repeat until all data written */
  22318a:	687b      	ldr	r3, [r7, #4]
  22318c:	2b00      	cmp	r3, #0
  22318e:	f47f aeb6 	bne.w	222efe <f_write+0x8e>
  223192:	e000      	b.n	223196 <f_write+0x326>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
  223194:	bf00      	nop
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
  223196:	68fb      	ldr	r3, [r7, #12]
  223198:	7d1b      	ldrb	r3, [r3, #20]
  22319a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  22319e:	b2da      	uxtb	r2, r3
  2231a0:	68fb      	ldr	r3, [r7, #12]
  2231a2:	751a      	strb	r2, [r3, #20]

	LEAVE_FF(fs, FR_OK);
  2231a4:	693b      	ldr	r3, [r7, #16]
  2231a6:	2100      	movs	r1, #0
  2231a8:	4618      	mov	r0, r3
  2231aa:	f7fd fa2e 	bl	22060a <unlock_fs>
  2231ae:	2300      	movs	r3, #0
}
  2231b0:	4618      	mov	r0, r3
  2231b2:	3730      	adds	r7, #48	; 0x30
  2231b4:	46bd      	mov	sp, r7
  2231b6:	bd80      	pop	{r7, pc}

002231b8 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
  2231b8:	b580      	push	{r7, lr}
  2231ba:	b086      	sub	sp, #24
  2231bc:	af00      	add	r7, sp, #0
  2231be:	6078      	str	r0, [r7, #4]
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
  2231c0:	687b      	ldr	r3, [r7, #4]
  2231c2:	f107 0208 	add.w	r2, r7, #8
  2231c6:	4611      	mov	r1, r2
  2231c8:	4618      	mov	r0, r3
  2231ca:	f7ff fa5d 	bl	222688 <validate>
  2231ce:	4603      	mov	r3, r0
  2231d0:	75fb      	strb	r3, [r7, #23]
	if (res == FR_OK) {
  2231d2:	7dfb      	ldrb	r3, [r7, #23]
  2231d4:	2b00      	cmp	r3, #0
  2231d6:	d16d      	bne.n	2232b4 <f_sync+0xfc>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
  2231d8:	687b      	ldr	r3, [r7, #4]
  2231da:	7d1b      	ldrb	r3, [r3, #20]
  2231dc:	f003 0340 	and.w	r3, r3, #64	; 0x40
  2231e0:	2b00      	cmp	r3, #0
  2231e2:	d067      	beq.n	2232b4 <f_sync+0xfc>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
  2231e4:	687b      	ldr	r3, [r7, #4]
  2231e6:	7d1b      	ldrb	r3, [r3, #20]
  2231e8:	b25b      	sxtb	r3, r3
  2231ea:	2b00      	cmp	r3, #0
  2231ec:	da1a      	bge.n	223224 <f_sync+0x6c>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
  2231ee:	68bb      	ldr	r3, [r7, #8]
  2231f0:	7858      	ldrb	r0, [r3, #1]
  2231f2:	687b      	ldr	r3, [r7, #4]
  2231f4:	f103 0130 	add.w	r1, r3, #48	; 0x30
  2231f8:	687b      	ldr	r3, [r7, #4]
  2231fa:	6a1a      	ldr	r2, [r3, #32]
  2231fc:	2301      	movs	r3, #1
  2231fe:	f7fd f8b1 	bl	220364 <disk_write>
  223202:	4603      	mov	r3, r0
  223204:	2b00      	cmp	r3, #0
  223206:	d006      	beq.n	223216 <f_sync+0x5e>
  223208:	68bb      	ldr	r3, [r7, #8]
  22320a:	2101      	movs	r1, #1
  22320c:	4618      	mov	r0, r3
  22320e:	f7fd f9fc 	bl	22060a <unlock_fs>
  223212:	2301      	movs	r3, #1
  223214:	e055      	b.n	2232c2 <f_sync+0x10a>
				fp->flag &= (BYTE)~FA_DIRTY;
  223216:	687b      	ldr	r3, [r7, #4]
  223218:	7d1b      	ldrb	r3, [r3, #20]
  22321a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  22321e:	b2da      	uxtb	r2, r3
  223220:	687b      	ldr	r3, [r7, #4]
  223222:	751a      	strb	r2, [r3, #20]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
  223224:	f7fc fc92 	bl	21fb4c <get_fattime>
  223228:	6138      	str	r0, [r7, #16]
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
  22322a:	68ba      	ldr	r2, [r7, #8]
  22322c:	687b      	ldr	r3, [r7, #4]
  22322e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  223230:	4619      	mov	r1, r3
  223232:	4610      	mov	r0, r2
  223234:	f7fd fbb4 	bl	2209a0 <move_window>
  223238:	4603      	mov	r3, r0
  22323a:	75fb      	strb	r3, [r7, #23]
				if (res == FR_OK) {
  22323c:	7dfb      	ldrb	r3, [r7, #23]
  22323e:	2b00      	cmp	r3, #0
  223240:	d138      	bne.n	2232b4 <f_sync+0xfc>
					dir = fp->dir_ptr;
  223242:	687b      	ldr	r3, [r7, #4]
  223244:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  223246:	60fb      	str	r3, [r7, #12]
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
  223248:	68fb      	ldr	r3, [r7, #12]
  22324a:	330b      	adds	r3, #11
  22324c:	68fa      	ldr	r2, [r7, #12]
  22324e:	320b      	adds	r2, #11
  223250:	7812      	ldrb	r2, [r2, #0]
  223252:	f042 0220 	orr.w	r2, r2, #32
  223256:	b2d2      	uxtb	r2, r2
  223258:	701a      	strb	r2, [r3, #0]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
  22325a:	687b      	ldr	r3, [r7, #4]
  22325c:	6818      	ldr	r0, [r3, #0]
  22325e:	687b      	ldr	r3, [r7, #4]
  223260:	689b      	ldr	r3, [r3, #8]
  223262:	461a      	mov	r2, r3
  223264:	68f9      	ldr	r1, [r7, #12]
  223266:	f7fe f8b9 	bl	2213dc <st_clust>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
  22326a:	68fb      	ldr	r3, [r7, #12]
  22326c:	f103 021c 	add.w	r2, r3, #28
  223270:	687b      	ldr	r3, [r7, #4]
  223272:	68db      	ldr	r3, [r3, #12]
  223274:	4619      	mov	r1, r3
  223276:	4610      	mov	r0, r2
  223278:	f7fd f908 	bl	22048c <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
  22327c:	68fb      	ldr	r3, [r7, #12]
  22327e:	3316      	adds	r3, #22
  223280:	6939      	ldr	r1, [r7, #16]
  223282:	4618      	mov	r0, r3
  223284:	f7fd f902 	bl	22048c <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
  223288:	68fb      	ldr	r3, [r7, #12]
  22328a:	3312      	adds	r3, #18
  22328c:	2100      	movs	r1, #0
  22328e:	4618      	mov	r0, r3
  223290:	f7fd f8e1 	bl	220456 <st_word>
					fs->wflag = 1;
  223294:	68bb      	ldr	r3, [r7, #8]
  223296:	2201      	movs	r2, #1
  223298:	70da      	strb	r2, [r3, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
  22329a:	68bb      	ldr	r3, [r7, #8]
  22329c:	4618      	mov	r0, r3
  22329e:	f7fd fbad 	bl	2209fc <sync_fs>
  2232a2:	4603      	mov	r3, r0
  2232a4:	75fb      	strb	r3, [r7, #23]
					fp->flag &= (BYTE)~FA_MODIFIED;
  2232a6:	687b      	ldr	r3, [r7, #4]
  2232a8:	7d1b      	ldrb	r3, [r3, #20]
  2232aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  2232ae:	b2da      	uxtb	r2, r3
  2232b0:	687b      	ldr	r3, [r7, #4]
  2232b2:	751a      	strb	r2, [r3, #20]
				}
			}
		}
	}

	LEAVE_FF(fs, res);
  2232b4:	68bb      	ldr	r3, [r7, #8]
  2232b6:	7dfa      	ldrb	r2, [r7, #23]
  2232b8:	4611      	mov	r1, r2
  2232ba:	4618      	mov	r0, r3
  2232bc:	f7fd f9a5 	bl	22060a <unlock_fs>
  2232c0:	7dfb      	ldrb	r3, [r7, #23]
}
  2232c2:	4618      	mov	r0, r3
  2232c4:	3718      	adds	r7, #24
  2232c6:	46bd      	mov	sp, r7
  2232c8:	bd80      	pop	{r7, pc}

002232ca <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
  2232ca:	b580      	push	{r7, lr}
  2232cc:	b084      	sub	sp, #16
  2232ce:	af00      	add	r7, sp, #0
  2232d0:	6078      	str	r0, [r7, #4]
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
  2232d2:	6878      	ldr	r0, [r7, #4]
  2232d4:	f7ff ff70 	bl	2231b8 <f_sync>
  2232d8:	4603      	mov	r3, r0
  2232da:	73fb      	strb	r3, [r7, #15]
	if (res == FR_OK)
  2232dc:	7bfb      	ldrb	r3, [r7, #15]
  2232de:	2b00      	cmp	r3, #0
  2232e0:	d11d      	bne.n	22331e <f_close+0x54>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
  2232e2:	687b      	ldr	r3, [r7, #4]
  2232e4:	f107 0208 	add.w	r2, r7, #8
  2232e8:	4611      	mov	r1, r2
  2232ea:	4618      	mov	r0, r3
  2232ec:	f7ff f9cc 	bl	222688 <validate>
  2232f0:	4603      	mov	r3, r0
  2232f2:	73fb      	strb	r3, [r7, #15]
		if (res == FR_OK) {
  2232f4:	7bfb      	ldrb	r3, [r7, #15]
  2232f6:	2b00      	cmp	r3, #0
  2232f8:	d111      	bne.n	22331e <f_close+0x54>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
  2232fa:	687b      	ldr	r3, [r7, #4]
  2232fc:	691b      	ldr	r3, [r3, #16]
  2232fe:	4618      	mov	r0, r3
  223300:	f7fd faaa 	bl	220858 <dec_lock>
  223304:	4603      	mov	r3, r0
  223306:	73fb      	strb	r3, [r7, #15]
			if (res == FR_OK)
  223308:	7bfb      	ldrb	r3, [r7, #15]
  22330a:	2b00      	cmp	r3, #0
  22330c:	d102      	bne.n	223314 <f_close+0x4a>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
  22330e:	687b      	ldr	r3, [r7, #4]
  223310:	2200      	movs	r2, #0
  223312:	601a      	str	r2, [r3, #0]
			}
#if _FS_REENTRANT
			unlock_fs(fs, FR_OK);		/* Unlock volume */
  223314:	68bb      	ldr	r3, [r7, #8]
  223316:	2100      	movs	r1, #0
  223318:	4618      	mov	r0, r3
  22331a:	f7fd f976 	bl	22060a <unlock_fs>
#endif
		}
	}
	return res;
  22331e:	7bfb      	ldrb	r3, [r7, #15]
}
  223320:	4618      	mov	r0, r3
  223322:	3710      	adds	r7, #16
  223324:	46bd      	mov	sp, r7
  223326:	bd80      	pop	{r7, pc}

00223328 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
  223328:	b580      	push	{r7, lr}
  22332a:	b092      	sub	sp, #72	; 0x48
  22332c:	af00      	add	r7, sp, #0
  22332e:	6078      	str	r0, [r7, #4]
  223330:	6039      	str	r1, [r7, #0]
	DIR dj;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &dj.obj.fs, 0);
  223332:	f107 0108 	add.w	r1, r7, #8
  223336:	1d3b      	adds	r3, r7, #4
  223338:	2200      	movs	r2, #0
  22333a:	4618      	mov	r0, r3
  22333c:	f7fe ff50 	bl	2221e0 <find_volume>
  223340:	4603      	mov	r3, r0
  223342:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
	if (res == FR_OK) {
  223346:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
  22334a:	2b00      	cmp	r3, #0
  22334c:	d134      	bne.n	2233b8 <f_stat+0x90>
		INIT_NAMBUF(dj.obj.fs);
  22334e:	f44f 7000 	mov.w	r0, #512	; 0x200
  223352:	f000 f9ad 	bl	2236b0 <ff_memalloc>
  223356:	6438      	str	r0, [r7, #64]	; 0x40
  223358:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  22335a:	2b00      	cmp	r3, #0
  22335c:	d106      	bne.n	22336c <f_stat+0x44>
  22335e:	68bb      	ldr	r3, [r7, #8]
  223360:	2111      	movs	r1, #17
  223362:	4618      	mov	r0, r3
  223364:	f7fd f951 	bl	22060a <unlock_fs>
  223368:	2311      	movs	r3, #17
  22336a:	e02e      	b.n	2233ca <f_stat+0xa2>
  22336c:	68bb      	ldr	r3, [r7, #8]
  22336e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  223370:	60da      	str	r2, [r3, #12]
		res = follow_path(&dj, path);	/* Follow the file path */
  223372:	687a      	ldr	r2, [r7, #4]
  223374:	f107 0308 	add.w	r3, r7, #8
  223378:	4611      	mov	r1, r2
  22337a:	4618      	mov	r0, r3
  22337c:	f7fe fe24 	bl	221fc8 <follow_path>
  223380:	4603      	mov	r3, r0
  223382:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
		if (res == FR_OK) {				/* Follow completed */
  223386:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
  22338a:	2b00      	cmp	r3, #0
  22338c:	d111      	bne.n	2233b2 <f_stat+0x8a>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
  22338e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
  223392:	b25b      	sxtb	r3, r3
  223394:	2b00      	cmp	r3, #0
  223396:	da03      	bge.n	2233a0 <f_stat+0x78>
				res = FR_INVALID_NAME;
  223398:	2306      	movs	r3, #6
  22339a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
  22339e:	e008      	b.n	2233b2 <f_stat+0x8a>
			} else {							/* Found an object */
				if (fno) get_fileinfo(&dj, fno);
  2233a0:	683b      	ldr	r3, [r7, #0]
  2233a2:	2b00      	cmp	r3, #0
  2233a4:	d005      	beq.n	2233b2 <f_stat+0x8a>
  2233a6:	f107 0308 	add.w	r3, r7, #8
  2233aa:	6839      	ldr	r1, [r7, #0]
  2233ac:	4618      	mov	r0, r3
  2233ae:	f7fe fb75 	bl	221a9c <get_fileinfo>
			}
		}
		FREE_NAMBUF();
  2233b2:	6c38      	ldr	r0, [r7, #64]	; 0x40
  2233b4:	f000 f988 	bl	2236c8 <ff_memfree>
	}

	LEAVE_FF(dj.obj.fs, res);
  2233b8:	68bb      	ldr	r3, [r7, #8]
  2233ba:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
  2233be:	4611      	mov	r1, r2
  2233c0:	4618      	mov	r0, r3
  2233c2:	f7fd f922 	bl	22060a <unlock_fs>
  2233c6:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
  2233ca:	4618      	mov	r0, r3
  2233cc:	3748      	adds	r7, #72	; 0x48
  2233ce:	46bd      	mov	sp, r7
  2233d0:	bd80      	pop	{r7, pc}
	...

002233d4 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  2233d4:	b480      	push	{r7}
  2233d6:	b087      	sub	sp, #28
  2233d8:	af00      	add	r7, sp, #0
  2233da:	60f8      	str	r0, [r7, #12]
  2233dc:	60b9      	str	r1, [r7, #8]
  2233de:	4613      	mov	r3, r2
  2233e0:	71fb      	strb	r3, [r7, #7]
  uint8_t ret = 1;
  2233e2:	2301      	movs	r3, #1
  2233e4:	75fb      	strb	r3, [r7, #23]
  uint8_t DiskNum = 0;
  2233e6:	2300      	movs	r3, #0
  2233e8:	75bb      	strb	r3, [r7, #22]

  if(disk.nbr < _VOLUMES)
  2233ea:	4b1f      	ldr	r3, [pc, #124]	; (223468 <FATFS_LinkDriverEx+0x94>)
  2233ec:	7a5b      	ldrb	r3, [r3, #9]
  2233ee:	b2db      	uxtb	r3, r3
  2233f0:	2b00      	cmp	r3, #0
  2233f2:	d131      	bne.n	223458 <FATFS_LinkDriverEx+0x84>
  {
    disk.is_initialized[disk.nbr] = 0;
  2233f4:	4b1c      	ldr	r3, [pc, #112]	; (223468 <FATFS_LinkDriverEx+0x94>)
  2233f6:	7a5b      	ldrb	r3, [r3, #9]
  2233f8:	b2db      	uxtb	r3, r3
  2233fa:	461a      	mov	r2, r3
  2233fc:	4b1a      	ldr	r3, [pc, #104]	; (223468 <FATFS_LinkDriverEx+0x94>)
  2233fe:	2100      	movs	r1, #0
  223400:	5499      	strb	r1, [r3, r2]
    disk.drv[disk.nbr] = drv;
  223402:	4b19      	ldr	r3, [pc, #100]	; (223468 <FATFS_LinkDriverEx+0x94>)
  223404:	7a5b      	ldrb	r3, [r3, #9]
  223406:	b2db      	uxtb	r3, r3
  223408:	4a17      	ldr	r2, [pc, #92]	; (223468 <FATFS_LinkDriverEx+0x94>)
  22340a:	009b      	lsls	r3, r3, #2
  22340c:	4413      	add	r3, r2
  22340e:	68fa      	ldr	r2, [r7, #12]
  223410:	605a      	str	r2, [r3, #4]
    disk.lun[disk.nbr] = lun;
  223412:	4b15      	ldr	r3, [pc, #84]	; (223468 <FATFS_LinkDriverEx+0x94>)
  223414:	7a5b      	ldrb	r3, [r3, #9]
  223416:	b2db      	uxtb	r3, r3
  223418:	461a      	mov	r2, r3
  22341a:	4b13      	ldr	r3, [pc, #76]	; (223468 <FATFS_LinkDriverEx+0x94>)
  22341c:	4413      	add	r3, r2
  22341e:	79fa      	ldrb	r2, [r7, #7]
  223420:	721a      	strb	r2, [r3, #8]
    DiskNum = disk.nbr++;
  223422:	4b11      	ldr	r3, [pc, #68]	; (223468 <FATFS_LinkDriverEx+0x94>)
  223424:	7a5b      	ldrb	r3, [r3, #9]
  223426:	b2db      	uxtb	r3, r3
  223428:	1c5a      	adds	r2, r3, #1
  22342a:	b2d1      	uxtb	r1, r2
  22342c:	4a0e      	ldr	r2, [pc, #56]	; (223468 <FATFS_LinkDriverEx+0x94>)
  22342e:	7251      	strb	r1, [r2, #9]
  223430:	75bb      	strb	r3, [r7, #22]
    path[0] = DiskNum + '0';
  223432:	7dbb      	ldrb	r3, [r7, #22]
  223434:	3330      	adds	r3, #48	; 0x30
  223436:	b2da      	uxtb	r2, r3
  223438:	68bb      	ldr	r3, [r7, #8]
  22343a:	701a      	strb	r2, [r3, #0]
    path[1] = ':';
  22343c:	68bb      	ldr	r3, [r7, #8]
  22343e:	3301      	adds	r3, #1
  223440:	223a      	movs	r2, #58	; 0x3a
  223442:	701a      	strb	r2, [r3, #0]
    path[2] = '/';
  223444:	68bb      	ldr	r3, [r7, #8]
  223446:	3302      	adds	r3, #2
  223448:	222f      	movs	r2, #47	; 0x2f
  22344a:	701a      	strb	r2, [r3, #0]
    path[3] = 0;
  22344c:	68bb      	ldr	r3, [r7, #8]
  22344e:	3303      	adds	r3, #3
  223450:	2200      	movs	r2, #0
  223452:	701a      	strb	r2, [r3, #0]
    ret = 0;
  223454:	2300      	movs	r3, #0
  223456:	75fb      	strb	r3, [r7, #23]
  }

  return ret;
  223458:	7dfb      	ldrb	r3, [r7, #23]
}
  22345a:	4618      	mov	r0, r3
  22345c:	371c      	adds	r7, #28
  22345e:	46bd      	mov	sp, r7
  223460:	f85d 7b04 	ldr.w	r7, [sp], #4
  223464:	4770      	bx	lr
  223466:	bf00      	nop
  223468:	20010c4c 	.word	0x20010c4c

0022346c <FATFS_LinkDriver>:
  * @param  drv: pointer to the disk IO Driver structure
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  22346c:	b580      	push	{r7, lr}
  22346e:	b082      	sub	sp, #8
  223470:	af00      	add	r7, sp, #0
  223472:	6078      	str	r0, [r7, #4]
  223474:	6039      	str	r1, [r7, #0]
  return FATFS_LinkDriverEx(drv, path, 0);
  223476:	2200      	movs	r2, #0
  223478:	6839      	ldr	r1, [r7, #0]
  22347a:	6878      	ldr	r0, [r7, #4]
  22347c:	f7ff ffaa 	bl	2233d4 <FATFS_LinkDriverEx>
  223480:	4603      	mov	r3, r0
}
  223482:	4618      	mov	r0, r3
  223484:	3708      	adds	r7, #8
  223486:	46bd      	mov	sp, r7
  223488:	bd80      	pop	{r7, pc}
	...

0022348c <ff_convert>:

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	chr,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEM code, 1: OEM code to Unicode */
)
{
  22348c:	b480      	push	{r7}
  22348e:	b085      	sub	sp, #20
  223490:	af00      	add	r7, sp, #0
  223492:	4603      	mov	r3, r0
  223494:	6039      	str	r1, [r7, #0]
  223496:	80fb      	strh	r3, [r7, #6]
	WCHAR c;


	if (chr < 0x80) {	/* ASCII */
  223498:	88fb      	ldrh	r3, [r7, #6]
  22349a:	2b7f      	cmp	r3, #127	; 0x7f
  22349c:	d802      	bhi.n	2234a4 <ff_convert+0x18>
		c = chr;
  22349e:	88fb      	ldrh	r3, [r7, #6]
  2234a0:	81fb      	strh	r3, [r7, #14]
  2234a2:	e025      	b.n	2234f0 <ff_convert+0x64>

	} else {
		if (dir) {		/* OEM code to Unicode */
  2234a4:	683b      	ldr	r3, [r7, #0]
  2234a6:	2b00      	cmp	r3, #0
  2234a8:	d00b      	beq.n	2234c2 <ff_convert+0x36>
			c = (chr >= 0x100) ? 0 : Tbl[chr - 0x80];
  2234aa:	88fb      	ldrh	r3, [r7, #6]
  2234ac:	2bff      	cmp	r3, #255	; 0xff
  2234ae:	d805      	bhi.n	2234bc <ff_convert+0x30>
  2234b0:	88fb      	ldrh	r3, [r7, #6]
  2234b2:	3b80      	subs	r3, #128	; 0x80
  2234b4:	4a12      	ldr	r2, [pc, #72]	; (223500 <ff_convert+0x74>)
  2234b6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  2234ba:	e000      	b.n	2234be <ff_convert+0x32>
  2234bc:	2300      	movs	r3, #0
  2234be:	81fb      	strh	r3, [r7, #14]
  2234c0:	e016      	b.n	2234f0 <ff_convert+0x64>

		} else {		/* Unicode to OEM code */
			for (c = 0; c < 0x80; c++) {
  2234c2:	2300      	movs	r3, #0
  2234c4:	81fb      	strh	r3, [r7, #14]
  2234c6:	e009      	b.n	2234dc <ff_convert+0x50>
				if (chr == Tbl[c]) break;
  2234c8:	89fb      	ldrh	r3, [r7, #14]
  2234ca:	4a0d      	ldr	r2, [pc, #52]	; (223500 <ff_convert+0x74>)
  2234cc:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
  2234d0:	88fa      	ldrh	r2, [r7, #6]
  2234d2:	429a      	cmp	r2, r3
  2234d4:	d006      	beq.n	2234e4 <ff_convert+0x58>
			for (c = 0; c < 0x80; c++) {
  2234d6:	89fb      	ldrh	r3, [r7, #14]
  2234d8:	3301      	adds	r3, #1
  2234da:	81fb      	strh	r3, [r7, #14]
  2234dc:	89fb      	ldrh	r3, [r7, #14]
  2234de:	2b7f      	cmp	r3, #127	; 0x7f
  2234e0:	d9f2      	bls.n	2234c8 <ff_convert+0x3c>
  2234e2:	e000      	b.n	2234e6 <ff_convert+0x5a>
				if (chr == Tbl[c]) break;
  2234e4:	bf00      	nop
			}
			c = (c + 0x80) & 0xFF;
  2234e6:	89fb      	ldrh	r3, [r7, #14]
  2234e8:	3380      	adds	r3, #128	; 0x80
  2234ea:	b29b      	uxth	r3, r3
  2234ec:	b2db      	uxtb	r3, r3
  2234ee:	81fb      	strh	r3, [r7, #14]
		}
	}

	return c;
  2234f0:	89fb      	ldrh	r3, [r7, #14]
}
  2234f2:	4618      	mov	r0, r3
  2234f4:	3714      	adds	r7, #20
  2234f6:	46bd      	mov	sp, r7
  2234f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  2234fc:	4770      	bx	lr
  2234fe:	bf00      	nop
  223500:	00229434 	.word	0x00229434

00223504 <ff_wtoupper>:


WCHAR ff_wtoupper (	/* Returns upper converted character */
	WCHAR chr		/* Unicode character to be upper converted (BMP only) */
)
{
  223504:	b480      	push	{r7}
  223506:	b087      	sub	sp, #28
  223508:	af00      	add	r7, sp, #0
  22350a:	4603      	mov	r3, r0
  22350c:	80fb      	strh	r3, [r7, #6]
	};
	const WCHAR *p;
	WCHAR bc, nc, cmd;


	p = chr < 0x1000 ? cvt1 : cvt2;
  22350e:	88fb      	ldrh	r3, [r7, #6]
  223510:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
  223514:	d201      	bcs.n	22351a <ff_wtoupper+0x16>
  223516:	4b3e      	ldr	r3, [pc, #248]	; (223610 <ff_wtoupper+0x10c>)
  223518:	e000      	b.n	22351c <ff_wtoupper+0x18>
  22351a:	4b3e      	ldr	r3, [pc, #248]	; (223614 <ff_wtoupper+0x110>)
  22351c:	617b      	str	r3, [r7, #20]
	for (;;) {
		bc = *p++;								/* Get block base */
  22351e:	697b      	ldr	r3, [r7, #20]
  223520:	1c9a      	adds	r2, r3, #2
  223522:	617a      	str	r2, [r7, #20]
  223524:	881b      	ldrh	r3, [r3, #0]
  223526:	827b      	strh	r3, [r7, #18]
		if (!bc || chr < bc) break;
  223528:	8a7b      	ldrh	r3, [r7, #18]
  22352a:	2b00      	cmp	r3, #0
  22352c:	d068      	beq.n	223600 <ff_wtoupper+0xfc>
  22352e:	88fa      	ldrh	r2, [r7, #6]
  223530:	8a7b      	ldrh	r3, [r7, #18]
  223532:	429a      	cmp	r2, r3
  223534:	d364      	bcc.n	223600 <ff_wtoupper+0xfc>
		nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
  223536:	697b      	ldr	r3, [r7, #20]
  223538:	1c9a      	adds	r2, r3, #2
  22353a:	617a      	str	r2, [r7, #20]
  22353c:	881b      	ldrh	r3, [r3, #0]
  22353e:	823b      	strh	r3, [r7, #16]
  223540:	8a3b      	ldrh	r3, [r7, #16]
  223542:	0a1b      	lsrs	r3, r3, #8
  223544:	81fb      	strh	r3, [r7, #14]
  223546:	8a3b      	ldrh	r3, [r7, #16]
  223548:	b2db      	uxtb	r3, r3
  22354a:	823b      	strh	r3, [r7, #16]
		if (chr < bc + nc) {	/* In the block? */
  22354c:	88fa      	ldrh	r2, [r7, #6]
  22354e:	8a79      	ldrh	r1, [r7, #18]
  223550:	8a3b      	ldrh	r3, [r7, #16]
  223552:	440b      	add	r3, r1
  223554:	429a      	cmp	r2, r3
  223556:	da49      	bge.n	2235ec <ff_wtoupper+0xe8>
			switch (cmd) {
  223558:	89fb      	ldrh	r3, [r7, #14]
  22355a:	2b08      	cmp	r3, #8
  22355c:	d84f      	bhi.n	2235fe <ff_wtoupper+0xfa>
  22355e:	a201      	add	r2, pc, #4	; (adr r2, 223564 <ff_wtoupper+0x60>)
  223560:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  223564:	00223589 	.word	0x00223589
  223568:	0022359b 	.word	0x0022359b
  22356c:	002235b1 	.word	0x002235b1
  223570:	002235b9 	.word	0x002235b9
  223574:	002235c1 	.word	0x002235c1
  223578:	002235c9 	.word	0x002235c9
  22357c:	002235d1 	.word	0x002235d1
  223580:	002235d9 	.word	0x002235d9
  223584:	002235e1 	.word	0x002235e1
			case 0:	chr = p[chr - bc]; break;		/* Table conversion */
  223588:	88fa      	ldrh	r2, [r7, #6]
  22358a:	8a7b      	ldrh	r3, [r7, #18]
  22358c:	1ad3      	subs	r3, r2, r3
  22358e:	005b      	lsls	r3, r3, #1
  223590:	697a      	ldr	r2, [r7, #20]
  223592:	4413      	add	r3, r2
  223594:	881b      	ldrh	r3, [r3, #0]
  223596:	80fb      	strh	r3, [r7, #6]
  223598:	e027      	b.n	2235ea <ff_wtoupper+0xe6>
			case 1:	chr -= (chr - bc) & 1; break;	/* Case pairs */
  22359a:	88fa      	ldrh	r2, [r7, #6]
  22359c:	8a7b      	ldrh	r3, [r7, #18]
  22359e:	1ad3      	subs	r3, r2, r3
  2235a0:	b29b      	uxth	r3, r3
  2235a2:	f003 0301 	and.w	r3, r3, #1
  2235a6:	b29b      	uxth	r3, r3
  2235a8:	88fa      	ldrh	r2, [r7, #6]
  2235aa:	1ad3      	subs	r3, r2, r3
  2235ac:	80fb      	strh	r3, [r7, #6]
  2235ae:	e01c      	b.n	2235ea <ff_wtoupper+0xe6>
			case 2: chr -= 16; break;				/* Shift -16 */
  2235b0:	88fb      	ldrh	r3, [r7, #6]
  2235b2:	3b10      	subs	r3, #16
  2235b4:	80fb      	strh	r3, [r7, #6]
  2235b6:	e018      	b.n	2235ea <ff_wtoupper+0xe6>
			case 3:	chr -= 32; break;				/* Shift -32 */
  2235b8:	88fb      	ldrh	r3, [r7, #6]
  2235ba:	3b20      	subs	r3, #32
  2235bc:	80fb      	strh	r3, [r7, #6]
  2235be:	e014      	b.n	2235ea <ff_wtoupper+0xe6>
			case 4:	chr -= 48; break;				/* Shift -48 */
  2235c0:	88fb      	ldrh	r3, [r7, #6]
  2235c2:	3b30      	subs	r3, #48	; 0x30
  2235c4:	80fb      	strh	r3, [r7, #6]
  2235c6:	e010      	b.n	2235ea <ff_wtoupper+0xe6>
			case 5:	chr -= 26; break;				/* Shift -26 */
  2235c8:	88fb      	ldrh	r3, [r7, #6]
  2235ca:	3b1a      	subs	r3, #26
  2235cc:	80fb      	strh	r3, [r7, #6]
  2235ce:	e00c      	b.n	2235ea <ff_wtoupper+0xe6>
			case 6:	chr += 8; break;				/* Shift +8 */
  2235d0:	88fb      	ldrh	r3, [r7, #6]
  2235d2:	3308      	adds	r3, #8
  2235d4:	80fb      	strh	r3, [r7, #6]
  2235d6:	e008      	b.n	2235ea <ff_wtoupper+0xe6>
			case 7: chr -= 80; break;				/* Shift -80 */
  2235d8:	88fb      	ldrh	r3, [r7, #6]
  2235da:	3b50      	subs	r3, #80	; 0x50
  2235dc:	80fb      	strh	r3, [r7, #6]
  2235de:	e004      	b.n	2235ea <ff_wtoupper+0xe6>
			case 8:	chr -= 0x1C60; break;			/* Shift -0x1C60 */
  2235e0:	88fb      	ldrh	r3, [r7, #6]
  2235e2:	f5a3 53e3 	sub.w	r3, r3, #7264	; 0x1c60
  2235e6:	80fb      	strh	r3, [r7, #6]
  2235e8:	bf00      	nop
			}
			break;
  2235ea:	e008      	b.n	2235fe <ff_wtoupper+0xfa>
		}
		if (!cmd) p += nc;
  2235ec:	89fb      	ldrh	r3, [r7, #14]
  2235ee:	2b00      	cmp	r3, #0
  2235f0:	d195      	bne.n	22351e <ff_wtoupper+0x1a>
  2235f2:	8a3b      	ldrh	r3, [r7, #16]
  2235f4:	005b      	lsls	r3, r3, #1
  2235f6:	697a      	ldr	r2, [r7, #20]
  2235f8:	4413      	add	r3, r2
  2235fa:	617b      	str	r3, [r7, #20]
		bc = *p++;								/* Get block base */
  2235fc:	e78f      	b.n	22351e <ff_wtoupper+0x1a>
			break;
  2235fe:	bf00      	nop
	}

	return chr;
  223600:	88fb      	ldrh	r3, [r7, #6]
}
  223602:	4618      	mov	r0, r3
  223604:	371c      	adds	r7, #28
  223606:	46bd      	mov	sp, r7
  223608:	f85d 7b04 	ldr.w	r7, [sp], #4
  22360c:	4770      	bx	lr
  22360e:	bf00      	nop
  223610:	00229534 	.word	0x00229534
  223614:	00229728 	.word	0x00229728

00223618 <ff_cre_syncobj>:

int ff_cre_syncobj (	/* 1:Function succeeded, 0:Could not create the sync object */
	BYTE vol,			/* Corresponding volume (logical drive number) */
	_SYNC_t *sobj		/* Pointer to return the created sync object */
)
{
  223618:	b580      	push	{r7, lr}
  22361a:	b086      	sub	sp, #24
  22361c:	af00      	add	r7, sp, #0
  22361e:	4603      	mov	r3, r0
  223620:	6039      	str	r1, [r7, #0]
  223622:	71fb      	strb	r3, [r7, #7]
#endif

#else

#if (osCMSIS < 0x20000U)
    osSemaphoreDef(SEM);
  223624:	2300      	movs	r3, #0
  223626:	60fb      	str	r3, [r7, #12]
  223628:	2300      	movs	r3, #0
  22362a:	613b      	str	r3, [r7, #16]
    *sobj = osSemaphoreCreate(osSemaphore(SEM), 1);
  22362c:	f107 030c 	add.w	r3, r7, #12
  223630:	2101      	movs	r1, #1
  223632:	4618      	mov	r0, r3
  223634:	f000 f8ec 	bl	223810 <osSemaphoreCreate>
  223638:	4602      	mov	r2, r0
  22363a:	683b      	ldr	r3, [r7, #0]
  22363c:	601a      	str	r2, [r3, #0]
#else
    *sobj = osSemaphoreNew(1, 1, NULL);
#endif

#endif
    ret = (*sobj != NULL);
  22363e:	683b      	ldr	r3, [r7, #0]
  223640:	681b      	ldr	r3, [r3, #0]
  223642:	2b00      	cmp	r3, #0
  223644:	bf14      	ite	ne
  223646:	2301      	movne	r3, #1
  223648:	2300      	moveq	r3, #0
  22364a:	b2db      	uxtb	r3, r3
  22364c:	617b      	str	r3, [r7, #20]

    return ret;
  22364e:	697b      	ldr	r3, [r7, #20]
}
  223650:	4618      	mov	r0, r3
  223652:	3718      	adds	r7, #24
  223654:	46bd      	mov	sp, r7
  223656:	bd80      	pop	{r7, pc}

00223658 <ff_del_syncobj>:
*/

int ff_del_syncobj (	/* 1:Function succeeded, 0:Could not delete due to any error */
	_SYNC_t sobj		/* Sync object tied to the logical drive to be deleted */
)
{
  223658:	b580      	push	{r7, lr}
  22365a:	b082      	sub	sp, #8
  22365c:	af00      	add	r7, sp, #0
  22365e:	6078      	str	r0, [r7, #4]
#if _USE_MUTEX
    osMutexDelete (sobj);
#else
    osSemaphoreDelete (sobj);
  223660:	6878      	ldr	r0, [r7, #4]
  223662:	f000 f98d 	bl	223980 <osSemaphoreDelete>
#endif
    return 1;
  223666:	2301      	movs	r3, #1
}
  223668:	4618      	mov	r0, r3
  22366a:	3708      	adds	r7, #8
  22366c:	46bd      	mov	sp, r7
  22366e:	bd80      	pop	{r7, pc}

00223670 <ff_req_grant>:
*/

int ff_req_grant (	/* 1:Got a grant to access the volume, 0:Could not get a grant */
	_SYNC_t sobj	/* Sync object to wait */
)
{
  223670:	b580      	push	{r7, lr}
  223672:	b084      	sub	sp, #16
  223674:	af00      	add	r7, sp, #0
  223676:	6078      	str	r0, [r7, #4]
  int ret = 0;
  223678:	2300      	movs	r3, #0
  22367a:	60fb      	str	r3, [r7, #12]
#if (osCMSIS < 0x20000U)

#if _USE_MUTEX
  if(osMutexWait(sobj, _FS_TIMEOUT) == osOK)
#else
  if(osSemaphoreWait(sobj, _FS_TIMEOUT) == osOK)
  22367c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  223680:	6878      	ldr	r0, [r7, #4]
  223682:	f000 f8f9 	bl	223878 <osSemaphoreWait>
  223686:	4603      	mov	r3, r0
  223688:	2b00      	cmp	r3, #0
  22368a:	d101      	bne.n	223690 <ff_req_grant+0x20>
   if(osSemaphoreAcquire(sobj, _FS_TIMEOUT) == osOK)
#endif

#endif
  {
    ret = 1;
  22368c:	2301      	movs	r3, #1
  22368e:	60fb      	str	r3, [r7, #12]
  }

  return ret;
  223690:	68fb      	ldr	r3, [r7, #12]
}
  223692:	4618      	mov	r0, r3
  223694:	3710      	adds	r7, #16
  223696:	46bd      	mov	sp, r7
  223698:	bd80      	pop	{r7, pc}

0022369a <ff_rel_grant>:
*/

void ff_rel_grant (
	_SYNC_t sobj	/* Sync object to be signaled */
)
{
  22369a:	b580      	push	{r7, lr}
  22369c:	b082      	sub	sp, #8
  22369e:	af00      	add	r7, sp, #0
  2236a0:	6078      	str	r0, [r7, #4]
#if _USE_MUTEX
  osMutexRelease(sobj);
#else
  osSemaphoreRelease(sobj);
  2236a2:	6878      	ldr	r0, [r7, #4]
  2236a4:	f000 f936 	bl	223914 <osSemaphoreRelease>
#endif
}
  2236a8:	bf00      	nop
  2236aa:	3708      	adds	r7, #8
  2236ac:	46bd      	mov	sp, r7
  2236ae:	bd80      	pop	{r7, pc}

002236b0 <ff_memalloc>:
*/

void* ff_memalloc (	/* Returns pointer to the allocated memory block */
	UINT msize		/* Number of bytes to allocate */
)
{
  2236b0:	b580      	push	{r7, lr}
  2236b2:	b082      	sub	sp, #8
  2236b4:	af00      	add	r7, sp, #0
  2236b6:	6078      	str	r0, [r7, #4]
	return ff_malloc(msize);	/* Allocate a new memory block with POSIX API */
  2236b8:	6878      	ldr	r0, [r7, #4]
  2236ba:	f000 fd2f 	bl	22411c <pvPortMalloc>
  2236be:	4603      	mov	r3, r0
}
  2236c0:	4618      	mov	r0, r3
  2236c2:	3708      	adds	r7, #8
  2236c4:	46bd      	mov	sp, r7
  2236c6:	bd80      	pop	{r7, pc}

002236c8 <ff_memfree>:
/*------------------------------------------------------------------------*/

void ff_memfree (
	void* mblock	/* Pointer to the memory block to free */
)
{
  2236c8:	b580      	push	{r7, lr}
  2236ca:	b082      	sub	sp, #8
  2236cc:	af00      	add	r7, sp, #0
  2236ce:	6078      	str	r0, [r7, #4]
	ff_free(mblock);	/* Discard the memory block with POSIX API */
  2236d0:	6878      	ldr	r0, [r7, #4]
  2236d2:	f000 fdeb 	bl	2242ac <vPortFree>
}
  2236d6:	bf00      	nop
  2236d8:	3708      	adds	r7, #8
  2236da:	46bd      	mov	sp, r7
  2236dc:	bd80      	pop	{r7, pc}

002236de <makeFreeRtosPriority>:

extern void xPortSysTickHandler(void);

/* Convert from CMSIS type osPriority to FreeRTOS priority number */
static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
{
  2236de:	b480      	push	{r7}
  2236e0:	b085      	sub	sp, #20
  2236e2:	af00      	add	r7, sp, #0
  2236e4:	4603      	mov	r3, r0
  2236e6:	80fb      	strh	r3, [r7, #6]
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
  2236e8:	2300      	movs	r3, #0
  2236ea:	60fb      	str	r3, [r7, #12]
  
  if (priority != osPriorityError) {
  2236ec:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
  2236f0:	2b84      	cmp	r3, #132	; 0x84
  2236f2:	d005      	beq.n	223700 <makeFreeRtosPriority+0x22>
    fpriority += (priority - osPriorityIdle);
  2236f4:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
  2236f8:	68fb      	ldr	r3, [r7, #12]
  2236fa:	4413      	add	r3, r2
  2236fc:	3303      	adds	r3, #3
  2236fe:	60fb      	str	r3, [r7, #12]
  }
  
  return fpriority;
  223700:	68fb      	ldr	r3, [r7, #12]
}
  223702:	4618      	mov	r0, r3
  223704:	3714      	adds	r7, #20
  223706:	46bd      	mov	sp, r7
  223708:	f85d 7b04 	ldr.w	r7, [sp], #4
  22370c:	4770      	bx	lr

0022370e <inHandlerMode>:
#endif


/* Determine whether we are in thread mode or handler mode. */
static int inHandlerMode (void)
{
  22370e:	b480      	push	{r7}
  223710:	b083      	sub	sp, #12
  223712:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
  223714:	f3ef 8305 	mrs	r3, IPSR
  223718:	607b      	str	r3, [r7, #4]
  return(result);
  22371a:	687b      	ldr	r3, [r7, #4]
  return __get_IPSR() != 0;
  22371c:	2b00      	cmp	r3, #0
  22371e:	bf14      	ite	ne
  223720:	2301      	movne	r3, #1
  223722:	2300      	moveq	r3, #0
  223724:	b2db      	uxtb	r3, r3
}
  223726:	4618      	mov	r0, r3
  223728:	370c      	adds	r7, #12
  22372a:	46bd      	mov	sp, r7
  22372c:	f85d 7b04 	ldr.w	r7, [sp], #4
  223730:	4770      	bx	lr

00223732 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
  223732:	b580      	push	{r7, lr}
  223734:	af00      	add	r7, sp, #0
  vTaskStartScheduler();
  223736:	f002 f803 	bl	225740 <vTaskStartScheduler>
  
  return osOK;
  22373a:	2300      	movs	r3, #0
}
  22373c:	4618      	mov	r0, r3
  22373e:	bd80      	pop	{r7, pc}

00223740 <osKernelRunning>:
*         (1) RTOS is started
*         (-1) if this feature is disabled in FreeRTOSConfig.h 
* @note  MUST REMAIN UNCHANGED: \b osKernelRunning shall be consistent in every CMSIS-RTOS.
*/
int32_t osKernelRunning(void)
{
  223740:	b580      	push	{r7, lr}
  223742:	af00      	add	r7, sp, #0
#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
  if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)
  223744:	f002 fc40 	bl	225fc8 <xTaskGetSchedulerState>
  223748:	4603      	mov	r3, r0
  22374a:	2b01      	cmp	r3, #1
  22374c:	d101      	bne.n	223752 <osKernelRunning+0x12>
    return 0;
  22374e:	2300      	movs	r3, #0
  223750:	e000      	b.n	223754 <osKernelRunning+0x14>
  else
    return 1;
  223752:	2301      	movs	r3, #1
#else
	return (-1);
#endif	
}
  223754:	4618      	mov	r0, r3
  223756:	bd80      	pop	{r7, pc}

00223758 <osKernelSysTick>:
* @param  None
* @retval None
* @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
*/
uint32_t osKernelSysTick(void)
{
  223758:	b580      	push	{r7, lr}
  22375a:	af00      	add	r7, sp, #0
  if (inHandlerMode()) {
  22375c:	f7ff ffd7 	bl	22370e <inHandlerMode>
  223760:	4603      	mov	r3, r0
  223762:	2b00      	cmp	r3, #0
  223764:	d003      	beq.n	22376e <osKernelSysTick+0x16>
    return xTaskGetTickCountFromISR();
  223766:	f002 f909 	bl	22597c <xTaskGetTickCountFromISR>
  22376a:	4603      	mov	r3, r0
  22376c:	e002      	b.n	223774 <osKernelSysTick+0x1c>
  }
  else {
    return xTaskGetTickCount();
  22376e:	f002 f8f5 	bl	22595c <xTaskGetTickCount>
  223772:	4603      	mov	r3, r0
  }
}
  223774:	4618      	mov	r0, r3
  223776:	bd80      	pop	{r7, pc}

00223778 <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
  223778:	b5f0      	push	{r4, r5, r6, r7, lr}
  22377a:	b089      	sub	sp, #36	; 0x24
  22377c:	af04      	add	r7, sp, #16
  22377e:	6078      	str	r0, [r7, #4]
  223780:	6039      	str	r1, [r7, #0]
  TaskHandle_t handle;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
  if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
  223782:	687b      	ldr	r3, [r7, #4]
  223784:	695b      	ldr	r3, [r3, #20]
  223786:	2b00      	cmp	r3, #0
  223788:	d020      	beq.n	2237cc <osThreadCreate+0x54>
  22378a:	687b      	ldr	r3, [r7, #4]
  22378c:	699b      	ldr	r3, [r3, #24]
  22378e:	2b00      	cmp	r3, #0
  223790:	d01c      	beq.n	2237cc <osThreadCreate+0x54>
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
  223792:	687b      	ldr	r3, [r7, #4]
  223794:	685c      	ldr	r4, [r3, #4]
  223796:	687b      	ldr	r3, [r7, #4]
  223798:	681d      	ldr	r5, [r3, #0]
  22379a:	687b      	ldr	r3, [r7, #4]
  22379c:	691e      	ldr	r6, [r3, #16]
  22379e:	687b      	ldr	r3, [r7, #4]
  2237a0:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
  2237a4:	4618      	mov	r0, r3
  2237a6:	f7ff ff9a 	bl	2236de <makeFreeRtosPriority>
  2237aa:	4601      	mov	r1, r0
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
  2237ac:	687b      	ldr	r3, [r7, #4]
  2237ae:	695b      	ldr	r3, [r3, #20]
  2237b0:	687a      	ldr	r2, [r7, #4]
  2237b2:	6992      	ldr	r2, [r2, #24]
    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
  2237b4:	9202      	str	r2, [sp, #8]
  2237b6:	9301      	str	r3, [sp, #4]
  2237b8:	9100      	str	r1, [sp, #0]
  2237ba:	683b      	ldr	r3, [r7, #0]
  2237bc:	4632      	mov	r2, r6
  2237be:	4629      	mov	r1, r5
  2237c0:	4620      	mov	r0, r4
  2237c2:	f001 fdef 	bl	2253a4 <xTaskCreateStatic>
  2237c6:	4603      	mov	r3, r0
  2237c8:	60fb      	str	r3, [r7, #12]
  2237ca:	e01c      	b.n	223806 <osThreadCreate+0x8e>
  }
  else {
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
  2237cc:	687b      	ldr	r3, [r7, #4]
  2237ce:	685c      	ldr	r4, [r3, #4]
  2237d0:	687b      	ldr	r3, [r7, #4]
  2237d2:	681d      	ldr	r5, [r3, #0]
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
  2237d4:	687b      	ldr	r3, [r7, #4]
  2237d6:	691b      	ldr	r3, [r3, #16]
    if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
  2237d8:	b29e      	uxth	r6, r3
  2237da:	687b      	ldr	r3, [r7, #4]
  2237dc:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
  2237e0:	4618      	mov	r0, r3
  2237e2:	f7ff ff7c 	bl	2236de <makeFreeRtosPriority>
  2237e6:	4602      	mov	r2, r0
  2237e8:	f107 030c 	add.w	r3, r7, #12
  2237ec:	9301      	str	r3, [sp, #4]
  2237ee:	9200      	str	r2, [sp, #0]
  2237f0:	683b      	ldr	r3, [r7, #0]
  2237f2:	4632      	mov	r2, r6
  2237f4:	4629      	mov	r1, r5
  2237f6:	4620      	mov	r0, r4
  2237f8:	f001 fe34 	bl	225464 <xTaskCreate>
  2237fc:	4603      	mov	r3, r0
  2237fe:	2b01      	cmp	r3, #1
  223800:	d001      	beq.n	223806 <osThreadCreate+0x8e>
              &handle) != pdPASS)  {
      return NULL;
  223802:	2300      	movs	r3, #0
  223804:	e000      	b.n	223808 <osThreadCreate+0x90>
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
  223806:	68fb      	ldr	r3, [r7, #12]
}
  223808:	4618      	mov	r0, r3
  22380a:	3714      	adds	r7, #20
  22380c:	46bd      	mov	sp, r7
  22380e:	bdf0      	pop	{r4, r5, r6, r7, pc}

00223810 <osSemaphoreCreate>:
* @param count         number of available resources.
* @retval  semaphore ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
*/
osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
{ 
  223810:	b580      	push	{r7, lr}
  223812:	b086      	sub	sp, #24
  223814:	af02      	add	r7, sp, #8
  223816:	6078      	str	r0, [r7, #4]
  223818:	6039      	str	r1, [r7, #0]
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  osSemaphoreId sema;
  
  if (semaphore_def->controlblock != NULL){
  22381a:	687b      	ldr	r3, [r7, #4]
  22381c:	685b      	ldr	r3, [r3, #4]
  22381e:	2b00      	cmp	r3, #0
  223820:	d010      	beq.n	223844 <osSemaphoreCreate+0x34>
    if (count == 1) {
  223822:	683b      	ldr	r3, [r7, #0]
  223824:	2b01      	cmp	r3, #1
  223826:	d10b      	bne.n	223840 <osSemaphoreCreate+0x30>
      return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
  223828:	687b      	ldr	r3, [r7, #4]
  22382a:	685a      	ldr	r2, [r3, #4]
  22382c:	2303      	movs	r3, #3
  22382e:	9300      	str	r3, [sp, #0]
  223830:	4613      	mov	r3, r2
  223832:	2200      	movs	r2, #0
  223834:	2100      	movs	r1, #0
  223836:	2001      	movs	r0, #1
  223838:	f000 feba 	bl	2245b0 <xQueueGenericCreateStatic>
  22383c:	4603      	mov	r3, r0
  22383e:	e016      	b.n	22386e <osSemaphoreCreate+0x5e>
    }
    else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )
      return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
#else
      return NULL;
  223840:	2300      	movs	r3, #0
  223842:	e014      	b.n	22386e <osSemaphoreCreate+0x5e>
#endif
    }
  }
  else {
    if (count == 1) {
  223844:	683b      	ldr	r3, [r7, #0]
  223846:	2b01      	cmp	r3, #1
  223848:	d110      	bne.n	22386c <osSemaphoreCreate+0x5c>
      vSemaphoreCreateBinary(sema);
  22384a:	2203      	movs	r2, #3
  22384c:	2100      	movs	r1, #0
  22384e:	2001      	movs	r0, #1
  223850:	f000 ff2b 	bl	2246aa <xQueueGenericCreate>
  223854:	60f8      	str	r0, [r7, #12]
  223856:	68fb      	ldr	r3, [r7, #12]
  223858:	2b00      	cmp	r3, #0
  22385a:	d005      	beq.n	223868 <osSemaphoreCreate+0x58>
  22385c:	2300      	movs	r3, #0
  22385e:	2200      	movs	r2, #0
  223860:	2100      	movs	r1, #0
  223862:	68f8      	ldr	r0, [r7, #12]
  223864:	f000 ff82 	bl	22476c <xQueueGenericSend>
      return sema;
  223868:	68fb      	ldr	r3, [r7, #12]
  22386a:	e000      	b.n	22386e <osSemaphoreCreate+0x5e>
    }
    else {
#if (configUSE_COUNTING_SEMAPHORES == 1 )	
      return xSemaphoreCreateCounting(count, count);
#else
      return NULL;
  22386c:	2300      	movs	r3, #0
#else
    return NULL;
#endif
  }
#endif
}
  22386e:	4618      	mov	r0, r3
  223870:	3710      	adds	r7, #16
  223872:	46bd      	mov	sp, r7
  223874:	bd80      	pop	{r7, pc}
	...

00223878 <osSemaphoreWait>:
* @param  millisec      timeout value or 0 in case of no time-out.
* @retval  number of available tokens, or -1 in case of incorrect parameters.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
*/
int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
{
  223878:	b580      	push	{r7, lr}
  22387a:	b084      	sub	sp, #16
  22387c:	af00      	add	r7, sp, #0
  22387e:	6078      	str	r0, [r7, #4]
  223880:	6039      	str	r1, [r7, #0]
  TickType_t ticks;
  portBASE_TYPE taskWoken = pdFALSE;  
  223882:	2300      	movs	r3, #0
  223884:	60bb      	str	r3, [r7, #8]
  
  
  if (semaphore_id == NULL) {
  223886:	687b      	ldr	r3, [r7, #4]
  223888:	2b00      	cmp	r3, #0
  22388a:	d101      	bne.n	223890 <osSemaphoreWait+0x18>
    return osErrorParameter;
  22388c:	2380      	movs	r3, #128	; 0x80
  22388e:	e03a      	b.n	223906 <osSemaphoreWait+0x8e>
  }
  
  ticks = 0;
  223890:	2300      	movs	r3, #0
  223892:	60fb      	str	r3, [r7, #12]
  if (millisec == osWaitForever) {
  223894:	683b      	ldr	r3, [r7, #0]
  223896:	f1b3 3fff 	cmp.w	r3, #4294967295
  22389a:	d103      	bne.n	2238a4 <osSemaphoreWait+0x2c>
    ticks = portMAX_DELAY;
  22389c:	f04f 33ff 	mov.w	r3, #4294967295
  2238a0:	60fb      	str	r3, [r7, #12]
  2238a2:	e009      	b.n	2238b8 <osSemaphoreWait+0x40>
  }
  else if (millisec != 0) {
  2238a4:	683b      	ldr	r3, [r7, #0]
  2238a6:	2b00      	cmp	r3, #0
  2238a8:	d006      	beq.n	2238b8 <osSemaphoreWait+0x40>
    ticks = millisec / portTICK_PERIOD_MS;
  2238aa:	683b      	ldr	r3, [r7, #0]
  2238ac:	60fb      	str	r3, [r7, #12]
    if (ticks == 0) {
  2238ae:	68fb      	ldr	r3, [r7, #12]
  2238b0:	2b00      	cmp	r3, #0
  2238b2:	d101      	bne.n	2238b8 <osSemaphoreWait+0x40>
      ticks = 1;
  2238b4:	2301      	movs	r3, #1
  2238b6:	60fb      	str	r3, [r7, #12]
    }
  }
  
  if (inHandlerMode()) {
  2238b8:	f7ff ff29 	bl	22370e <inHandlerMode>
  2238bc:	4603      	mov	r3, r0
  2238be:	2b00      	cmp	r3, #0
  2238c0:	d017      	beq.n	2238f2 <osSemaphoreWait+0x7a>
    if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
  2238c2:	f107 0308 	add.w	r3, r7, #8
  2238c6:	461a      	mov	r2, r3
  2238c8:	2100      	movs	r1, #0
  2238ca:	6878      	ldr	r0, [r7, #4]
  2238cc:	f001 fb70 	bl	224fb0 <xQueueReceiveFromISR>
  2238d0:	4603      	mov	r3, r0
  2238d2:	2b01      	cmp	r3, #1
  2238d4:	d001      	beq.n	2238da <osSemaphoreWait+0x62>
      return osErrorOS;
  2238d6:	23ff      	movs	r3, #255	; 0xff
  2238d8:	e015      	b.n	223906 <osSemaphoreWait+0x8e>
    }
	portEND_SWITCHING_ISR(taskWoken);
  2238da:	68bb      	ldr	r3, [r7, #8]
  2238dc:	2b00      	cmp	r3, #0
  2238de:	d011      	beq.n	223904 <osSemaphoreWait+0x8c>
  2238e0:	4b0b      	ldr	r3, [pc, #44]	; (223910 <osSemaphoreWait+0x98>)
  2238e2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  2238e6:	601a      	str	r2, [r3, #0]
  2238e8:	f3bf 8f4f 	dsb	sy
  2238ec:	f3bf 8f6f 	isb	sy
  2238f0:	e008      	b.n	223904 <osSemaphoreWait+0x8c>
  }  
  else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
  2238f2:	68f9      	ldr	r1, [r7, #12]
  2238f4:	6878      	ldr	r0, [r7, #4]
  2238f6:	f001 fa4b 	bl	224d90 <xQueueSemaphoreTake>
  2238fa:	4603      	mov	r3, r0
  2238fc:	2b01      	cmp	r3, #1
  2238fe:	d001      	beq.n	223904 <osSemaphoreWait+0x8c>
    return osErrorOS;
  223900:	23ff      	movs	r3, #255	; 0xff
  223902:	e000      	b.n	223906 <osSemaphoreWait+0x8e>
  }
  
  return osOK;
  223904:	2300      	movs	r3, #0
}
  223906:	4618      	mov	r0, r3
  223908:	3710      	adds	r7, #16
  22390a:	46bd      	mov	sp, r7
  22390c:	bd80      	pop	{r7, pc}
  22390e:	bf00      	nop
  223910:	e000ed04 	.word	0xe000ed04

00223914 <osSemaphoreRelease>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
{
  223914:	b580      	push	{r7, lr}
  223916:	b084      	sub	sp, #16
  223918:	af00      	add	r7, sp, #0
  22391a:	6078      	str	r0, [r7, #4]
  osStatus result = osOK;
  22391c:	2300      	movs	r3, #0
  22391e:	60fb      	str	r3, [r7, #12]
  portBASE_TYPE taskWoken = pdFALSE;
  223920:	2300      	movs	r3, #0
  223922:	60bb      	str	r3, [r7, #8]
  
  
  if (inHandlerMode()) {
  223924:	f7ff fef3 	bl	22370e <inHandlerMode>
  223928:	4603      	mov	r3, r0
  22392a:	2b00      	cmp	r3, #0
  22392c:	d016      	beq.n	22395c <osSemaphoreRelease+0x48>
    if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
  22392e:	f107 0308 	add.w	r3, r7, #8
  223932:	4619      	mov	r1, r3
  223934:	6878      	ldr	r0, [r7, #4]
  223936:	f001 f8b7 	bl	224aa8 <xQueueGiveFromISR>
  22393a:	4603      	mov	r3, r0
  22393c:	2b01      	cmp	r3, #1
  22393e:	d001      	beq.n	223944 <osSemaphoreRelease+0x30>
      return osErrorOS;
  223940:	23ff      	movs	r3, #255	; 0xff
  223942:	e017      	b.n	223974 <osSemaphoreRelease+0x60>
    }
    portEND_SWITCHING_ISR(taskWoken);
  223944:	68bb      	ldr	r3, [r7, #8]
  223946:	2b00      	cmp	r3, #0
  223948:	d013      	beq.n	223972 <osSemaphoreRelease+0x5e>
  22394a:	4b0c      	ldr	r3, [pc, #48]	; (22397c <osSemaphoreRelease+0x68>)
  22394c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  223950:	601a      	str	r2, [r3, #0]
  223952:	f3bf 8f4f 	dsb	sy
  223956:	f3bf 8f6f 	isb	sy
  22395a:	e00a      	b.n	223972 <osSemaphoreRelease+0x5e>
  }
  else {
    if (xSemaphoreGive(semaphore_id) != pdTRUE) {
  22395c:	2300      	movs	r3, #0
  22395e:	2200      	movs	r2, #0
  223960:	2100      	movs	r1, #0
  223962:	6878      	ldr	r0, [r7, #4]
  223964:	f000 ff02 	bl	22476c <xQueueGenericSend>
  223968:	4603      	mov	r3, r0
  22396a:	2b01      	cmp	r3, #1
  22396c:	d001      	beq.n	223972 <osSemaphoreRelease+0x5e>
      result = osErrorOS;
  22396e:	23ff      	movs	r3, #255	; 0xff
  223970:	60fb      	str	r3, [r7, #12]
    }
  }
  
  return result;
  223972:	68fb      	ldr	r3, [r7, #12]
}
  223974:	4618      	mov	r0, r3
  223976:	3710      	adds	r7, #16
  223978:	46bd      	mov	sp, r7
  22397a:	bd80      	pop	{r7, pc}
  22397c:	e000ed04 	.word	0xe000ed04

00223980 <osSemaphoreDelete>:
* @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
* @retval  status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS.
*/
osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
{
  223980:	b580      	push	{r7, lr}
  223982:	b082      	sub	sp, #8
  223984:	af00      	add	r7, sp, #0
  223986:	6078      	str	r0, [r7, #4]
  if (inHandlerMode()) {
  223988:	f7ff fec1 	bl	22370e <inHandlerMode>
  22398c:	4603      	mov	r3, r0
  22398e:	2b00      	cmp	r3, #0
  223990:	d001      	beq.n	223996 <osSemaphoreDelete+0x16>
    return osErrorISR;
  223992:	2382      	movs	r3, #130	; 0x82
  223994:	e003      	b.n	22399e <osSemaphoreDelete+0x1e>
  }

  vSemaphoreDelete(semaphore_id);
  223996:	6878      	ldr	r0, [r7, #4]
  223998:	f001 fb8d 	bl	2250b6 <vQueueDelete>

  return osOK; 
  22399c:	2300      	movs	r3, #0
}
  22399e:	4618      	mov	r0, r3
  2239a0:	3708      	adds	r7, #8
  2239a2:	46bd      	mov	sp, r7
  2239a4:	bd80      	pop	{r7, pc}

002239a6 <osMessageCreate>:
* @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
* @retval  message queue ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
*/
osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
{
  2239a6:	b590      	push	{r4, r7, lr}
  2239a8:	b085      	sub	sp, #20
  2239aa:	af02      	add	r7, sp, #8
  2239ac:	6078      	str	r0, [r7, #4]
  2239ae:	6039      	str	r1, [r7, #0]
  (void) thread_id;
  
#if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

  if ((queue_def->buffer != NULL) && (queue_def->controlblock != NULL)) {
  2239b0:	687b      	ldr	r3, [r7, #4]
  2239b2:	689b      	ldr	r3, [r3, #8]
  2239b4:	2b00      	cmp	r3, #0
  2239b6:	d012      	beq.n	2239de <osMessageCreate+0x38>
  2239b8:	687b      	ldr	r3, [r7, #4]
  2239ba:	68db      	ldr	r3, [r3, #12]
  2239bc:	2b00      	cmp	r3, #0
  2239be:	d00e      	beq.n	2239de <osMessageCreate+0x38>
    return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
  2239c0:	687b      	ldr	r3, [r7, #4]
  2239c2:	6818      	ldr	r0, [r3, #0]
  2239c4:	687b      	ldr	r3, [r7, #4]
  2239c6:	6859      	ldr	r1, [r3, #4]
  2239c8:	687b      	ldr	r3, [r7, #4]
  2239ca:	689a      	ldr	r2, [r3, #8]
  2239cc:	687b      	ldr	r3, [r7, #4]
  2239ce:	68dc      	ldr	r4, [r3, #12]
  2239d0:	2300      	movs	r3, #0
  2239d2:	9300      	str	r3, [sp, #0]
  2239d4:	4623      	mov	r3, r4
  2239d6:	f000 fdeb 	bl	2245b0 <xQueueGenericCreateStatic>
  2239da:	4603      	mov	r3, r0
  2239dc:	e008      	b.n	2239f0 <osMessageCreate+0x4a>
  }
  else {
    return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
  2239de:	687b      	ldr	r3, [r7, #4]
  2239e0:	6818      	ldr	r0, [r3, #0]
  2239e2:	687b      	ldr	r3, [r7, #4]
  2239e4:	685b      	ldr	r3, [r3, #4]
  2239e6:	2200      	movs	r2, #0
  2239e8:	4619      	mov	r1, r3
  2239ea:	f000 fe5e 	bl	2246aa <xQueueGenericCreate>
  2239ee:	4603      	mov	r3, r0
#elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
  return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
#else  
  return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
#endif
}
  2239f0:	4618      	mov	r0, r3
  2239f2:	370c      	adds	r7, #12
  2239f4:	46bd      	mov	sp, r7
  2239f6:	bd90      	pop	{r4, r7, pc}

002239f8 <osMessagePut>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval status code that indicates the execution status of the function.
* @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
*/
osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
{
  2239f8:	b580      	push	{r7, lr}
  2239fa:	b086      	sub	sp, #24
  2239fc:	af00      	add	r7, sp, #0
  2239fe:	60f8      	str	r0, [r7, #12]
  223a00:	60b9      	str	r1, [r7, #8]
  223a02:	607a      	str	r2, [r7, #4]
  portBASE_TYPE taskWoken = pdFALSE;
  223a04:	2300      	movs	r3, #0
  223a06:	613b      	str	r3, [r7, #16]
  TickType_t ticks;
  
  ticks = millisec / portTICK_PERIOD_MS;
  223a08:	687b      	ldr	r3, [r7, #4]
  223a0a:	617b      	str	r3, [r7, #20]
  if (ticks == 0) {
  223a0c:	697b      	ldr	r3, [r7, #20]
  223a0e:	2b00      	cmp	r3, #0
  223a10:	d101      	bne.n	223a16 <osMessagePut+0x1e>
    ticks = 1;
  223a12:	2301      	movs	r3, #1
  223a14:	617b      	str	r3, [r7, #20]
  }
  
  if (inHandlerMode()) {
  223a16:	f7ff fe7a 	bl	22370e <inHandlerMode>
  223a1a:	4603      	mov	r3, r0
  223a1c:	2b00      	cmp	r3, #0
  223a1e:	d018      	beq.n	223a52 <osMessagePut+0x5a>
    if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
  223a20:	f107 0210 	add.w	r2, r7, #16
  223a24:	f107 0108 	add.w	r1, r7, #8
  223a28:	2300      	movs	r3, #0
  223a2a:	68f8      	ldr	r0, [r7, #12]
  223a2c:	f000 ffa0 	bl	224970 <xQueueGenericSendFromISR>
  223a30:	4603      	mov	r3, r0
  223a32:	2b01      	cmp	r3, #1
  223a34:	d001      	beq.n	223a3a <osMessagePut+0x42>
      return osErrorOS;
  223a36:	23ff      	movs	r3, #255	; 0xff
  223a38:	e018      	b.n	223a6c <osMessagePut+0x74>
    }
    portEND_SWITCHING_ISR(taskWoken);
  223a3a:	693b      	ldr	r3, [r7, #16]
  223a3c:	2b00      	cmp	r3, #0
  223a3e:	d014      	beq.n	223a6a <osMessagePut+0x72>
  223a40:	4b0c      	ldr	r3, [pc, #48]	; (223a74 <osMessagePut+0x7c>)
  223a42:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  223a46:	601a      	str	r2, [r3, #0]
  223a48:	f3bf 8f4f 	dsb	sy
  223a4c:	f3bf 8f6f 	isb	sy
  223a50:	e00b      	b.n	223a6a <osMessagePut+0x72>
  }
  else {
    if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
  223a52:	f107 0108 	add.w	r1, r7, #8
  223a56:	2300      	movs	r3, #0
  223a58:	697a      	ldr	r2, [r7, #20]
  223a5a:	68f8      	ldr	r0, [r7, #12]
  223a5c:	f000 fe86 	bl	22476c <xQueueGenericSend>
  223a60:	4603      	mov	r3, r0
  223a62:	2b01      	cmp	r3, #1
  223a64:	d001      	beq.n	223a6a <osMessagePut+0x72>
      return osErrorOS;
  223a66:	23ff      	movs	r3, #255	; 0xff
  223a68:	e000      	b.n	223a6c <osMessagePut+0x74>
    }
  }
  
  return osOK;
  223a6a:	2300      	movs	r3, #0
}
  223a6c:	4618      	mov	r0, r3
  223a6e:	3718      	adds	r7, #24
  223a70:	46bd      	mov	sp, r7
  223a72:	bd80      	pop	{r7, pc}
  223a74:	e000ed04 	.word	0xe000ed04

00223a78 <osMessageGet>:
* @param  millisec  timeout value or 0 in case of no time-out.
* @retval event information that includes status code.
* @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
*/
osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
{
  223a78:	b590      	push	{r4, r7, lr}
  223a7a:	b08b      	sub	sp, #44	; 0x2c
  223a7c:	af00      	add	r7, sp, #0
  223a7e:	60f8      	str	r0, [r7, #12]
  223a80:	60b9      	str	r1, [r7, #8]
  223a82:	607a      	str	r2, [r7, #4]
  portBASE_TYPE taskWoken;
  TickType_t ticks;
  osEvent event;
  
  event.def.message_id = queue_id;
  223a84:	68bb      	ldr	r3, [r7, #8]
  223a86:	61fb      	str	r3, [r7, #28]
  event.value.v = 0;
  223a88:	2300      	movs	r3, #0
  223a8a:	61bb      	str	r3, [r7, #24]
  
  if (queue_id == NULL) {
  223a8c:	68bb      	ldr	r3, [r7, #8]
  223a8e:	2b00      	cmp	r3, #0
  223a90:	d10a      	bne.n	223aa8 <osMessageGet+0x30>
    event.status = osErrorParameter;
  223a92:	2380      	movs	r3, #128	; 0x80
  223a94:	617b      	str	r3, [r7, #20]
    return event;
  223a96:	68fb      	ldr	r3, [r7, #12]
  223a98:	461c      	mov	r4, r3
  223a9a:	f107 0314 	add.w	r3, r7, #20
  223a9e:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  223aa2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
  223aa6:	e054      	b.n	223b52 <osMessageGet+0xda>
  }
  
  taskWoken = pdFALSE;
  223aa8:	2300      	movs	r3, #0
  223aaa:	623b      	str	r3, [r7, #32]
  
  ticks = 0;
  223aac:	2300      	movs	r3, #0
  223aae:	627b      	str	r3, [r7, #36]	; 0x24
  if (millisec == osWaitForever) {
  223ab0:	687b      	ldr	r3, [r7, #4]
  223ab2:	f1b3 3fff 	cmp.w	r3, #4294967295
  223ab6:	d103      	bne.n	223ac0 <osMessageGet+0x48>
    ticks = portMAX_DELAY;
  223ab8:	f04f 33ff 	mov.w	r3, #4294967295
  223abc:	627b      	str	r3, [r7, #36]	; 0x24
  223abe:	e009      	b.n	223ad4 <osMessageGet+0x5c>
  }
  else if (millisec != 0) {
  223ac0:	687b      	ldr	r3, [r7, #4]
  223ac2:	2b00      	cmp	r3, #0
  223ac4:	d006      	beq.n	223ad4 <osMessageGet+0x5c>
    ticks = millisec / portTICK_PERIOD_MS;
  223ac6:	687b      	ldr	r3, [r7, #4]
  223ac8:	627b      	str	r3, [r7, #36]	; 0x24
    if (ticks == 0) {
  223aca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  223acc:	2b00      	cmp	r3, #0
  223ace:	d101      	bne.n	223ad4 <osMessageGet+0x5c>
      ticks = 1;
  223ad0:	2301      	movs	r3, #1
  223ad2:	627b      	str	r3, [r7, #36]	; 0x24
    }
  }
  
  if (inHandlerMode()) {
  223ad4:	f7ff fe1b 	bl	22370e <inHandlerMode>
  223ad8:	4603      	mov	r3, r0
  223ada:	2b00      	cmp	r3, #0
  223adc:	d01c      	beq.n	223b18 <osMessageGet+0xa0>
    if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
  223ade:	f107 0220 	add.w	r2, r7, #32
  223ae2:	f107 0314 	add.w	r3, r7, #20
  223ae6:	3304      	adds	r3, #4
  223ae8:	4619      	mov	r1, r3
  223aea:	68b8      	ldr	r0, [r7, #8]
  223aec:	f001 fa60 	bl	224fb0 <xQueueReceiveFromISR>
  223af0:	4603      	mov	r3, r0
  223af2:	2b01      	cmp	r3, #1
  223af4:	d102      	bne.n	223afc <osMessageGet+0x84>
      /* We have mail */
      event.status = osEventMessage;
  223af6:	2310      	movs	r3, #16
  223af8:	617b      	str	r3, [r7, #20]
  223afa:	e001      	b.n	223b00 <osMessageGet+0x88>
    }
    else {
      event.status = osOK;
  223afc:	2300      	movs	r3, #0
  223afe:	617b      	str	r3, [r7, #20]
    }
    portEND_SWITCHING_ISR(taskWoken);
  223b00:	6a3b      	ldr	r3, [r7, #32]
  223b02:	2b00      	cmp	r3, #0
  223b04:	d01d      	beq.n	223b42 <osMessageGet+0xca>
  223b06:	4b15      	ldr	r3, [pc, #84]	; (223b5c <osMessageGet+0xe4>)
  223b08:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  223b0c:	601a      	str	r2, [r3, #0]
  223b0e:	f3bf 8f4f 	dsb	sy
  223b12:	f3bf 8f6f 	isb	sy
  223b16:	e014      	b.n	223b42 <osMessageGet+0xca>
  }
  else {
    if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
  223b18:	f107 0314 	add.w	r3, r7, #20
  223b1c:	3304      	adds	r3, #4
  223b1e:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  223b20:	4619      	mov	r1, r3
  223b22:	68b8      	ldr	r0, [r7, #8]
  223b24:	f001 f852 	bl	224bcc <xQueueReceive>
  223b28:	4603      	mov	r3, r0
  223b2a:	2b01      	cmp	r3, #1
  223b2c:	d102      	bne.n	223b34 <osMessageGet+0xbc>
      /* We have mail */
      event.status = osEventMessage;
  223b2e:	2310      	movs	r3, #16
  223b30:	617b      	str	r3, [r7, #20]
  223b32:	e006      	b.n	223b42 <osMessageGet+0xca>
    }
    else {
      event.status = (ticks == 0) ? osOK : osEventTimeout;
  223b34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  223b36:	2b00      	cmp	r3, #0
  223b38:	d101      	bne.n	223b3e <osMessageGet+0xc6>
  223b3a:	2300      	movs	r3, #0
  223b3c:	e000      	b.n	223b40 <osMessageGet+0xc8>
  223b3e:	2340      	movs	r3, #64	; 0x40
  223b40:	617b      	str	r3, [r7, #20]
    }
  }
  
  return event;
  223b42:	68fb      	ldr	r3, [r7, #12]
  223b44:	461c      	mov	r4, r3
  223b46:	f107 0314 	add.w	r3, r7, #20
  223b4a:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
  223b4e:	e884 0007 	stmia.w	r4, {r0, r1, r2}
}
  223b52:	68f8      	ldr	r0, [r7, #12]
  223b54:	372c      	adds	r7, #44	; 0x2c
  223b56:	46bd      	mov	sp, r7
  223b58:	bd90      	pop	{r4, r7, pc}
  223b5a:	bf00      	nop
  223b5c:	e000ed04 	.word	0xe000ed04

00223b60 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
  223b60:	b480      	push	{r7}
  223b62:	b083      	sub	sp, #12
  223b64:	af00      	add	r7, sp, #0
  223b66:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  223b68:	687b      	ldr	r3, [r7, #4]
  223b6a:	f103 0208 	add.w	r2, r3, #8
  223b6e:	687b      	ldr	r3, [r7, #4]
  223b70:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  223b72:	687b      	ldr	r3, [r7, #4]
  223b74:	f04f 32ff 	mov.w	r2, #4294967295
  223b78:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  223b7a:	687b      	ldr	r3, [r7, #4]
  223b7c:	f103 0208 	add.w	r2, r3, #8
  223b80:	687b      	ldr	r3, [r7, #4]
  223b82:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
  223b84:	687b      	ldr	r3, [r7, #4]
  223b86:	f103 0208 	add.w	r2, r3, #8
  223b8a:	687b      	ldr	r3, [r7, #4]
  223b8c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
  223b8e:	687b      	ldr	r3, [r7, #4]
  223b90:	2200      	movs	r2, #0
  223b92:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
  223b94:	bf00      	nop
  223b96:	370c      	adds	r7, #12
  223b98:	46bd      	mov	sp, r7
  223b9a:	f85d 7b04 	ldr.w	r7, [sp], #4
  223b9e:	4770      	bx	lr

00223ba0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
  223ba0:	b480      	push	{r7}
  223ba2:	b083      	sub	sp, #12
  223ba4:	af00      	add	r7, sp, #0
  223ba6:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
  223ba8:	687b      	ldr	r3, [r7, #4]
  223baa:	2200      	movs	r2, #0
  223bac:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
  223bae:	bf00      	nop
  223bb0:	370c      	adds	r7, #12
  223bb2:	46bd      	mov	sp, r7
  223bb4:	f85d 7b04 	ldr.w	r7, [sp], #4
  223bb8:	4770      	bx	lr

00223bba <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  223bba:	b480      	push	{r7}
  223bbc:	b085      	sub	sp, #20
  223bbe:	af00      	add	r7, sp, #0
  223bc0:	6078      	str	r0, [r7, #4]
  223bc2:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
  223bc4:	687b      	ldr	r3, [r7, #4]
  223bc6:	685b      	ldr	r3, [r3, #4]
  223bc8:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
  223bca:	683b      	ldr	r3, [r7, #0]
  223bcc:	68fa      	ldr	r2, [r7, #12]
  223bce:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
  223bd0:	68fb      	ldr	r3, [r7, #12]
  223bd2:	689a      	ldr	r2, [r3, #8]
  223bd4:	683b      	ldr	r3, [r7, #0]
  223bd6:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
  223bd8:	68fb      	ldr	r3, [r7, #12]
  223bda:	689b      	ldr	r3, [r3, #8]
  223bdc:	683a      	ldr	r2, [r7, #0]
  223bde:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
  223be0:	68fb      	ldr	r3, [r7, #12]
  223be2:	683a      	ldr	r2, [r7, #0]
  223be4:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
  223be6:	683b      	ldr	r3, [r7, #0]
  223be8:	687a      	ldr	r2, [r7, #4]
  223bea:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  223bec:	687b      	ldr	r3, [r7, #4]
  223bee:	681b      	ldr	r3, [r3, #0]
  223bf0:	1c5a      	adds	r2, r3, #1
  223bf2:	687b      	ldr	r3, [r7, #4]
  223bf4:	601a      	str	r2, [r3, #0]
}
  223bf6:	bf00      	nop
  223bf8:	3714      	adds	r7, #20
  223bfa:	46bd      	mov	sp, r7
  223bfc:	f85d 7b04 	ldr.w	r7, [sp], #4
  223c00:	4770      	bx	lr

00223c02 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
  223c02:	b480      	push	{r7}
  223c04:	b085      	sub	sp, #20
  223c06:	af00      	add	r7, sp, #0
  223c08:	6078      	str	r0, [r7, #4]
  223c0a:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
  223c0c:	683b      	ldr	r3, [r7, #0]
  223c0e:	681b      	ldr	r3, [r3, #0]
  223c10:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  223c12:	68bb      	ldr	r3, [r7, #8]
  223c14:	f1b3 3fff 	cmp.w	r3, #4294967295
  223c18:	d103      	bne.n	223c22 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  223c1a:	687b      	ldr	r3, [r7, #4]
  223c1c:	691b      	ldr	r3, [r3, #16]
  223c1e:	60fb      	str	r3, [r7, #12]
  223c20:	e00c      	b.n	223c3c <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
  223c22:	687b      	ldr	r3, [r7, #4]
  223c24:	3308      	adds	r3, #8
  223c26:	60fb      	str	r3, [r7, #12]
  223c28:	e002      	b.n	223c30 <vListInsert+0x2e>
  223c2a:	68fb      	ldr	r3, [r7, #12]
  223c2c:	685b      	ldr	r3, [r3, #4]
  223c2e:	60fb      	str	r3, [r7, #12]
  223c30:	68fb      	ldr	r3, [r7, #12]
  223c32:	685b      	ldr	r3, [r3, #4]
  223c34:	681a      	ldr	r2, [r3, #0]
  223c36:	68bb      	ldr	r3, [r7, #8]
  223c38:	429a      	cmp	r2, r3
  223c3a:	d9f6      	bls.n	223c2a <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  223c3c:	68fb      	ldr	r3, [r7, #12]
  223c3e:	685a      	ldr	r2, [r3, #4]
  223c40:	683b      	ldr	r3, [r7, #0]
  223c42:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
  223c44:	683b      	ldr	r3, [r7, #0]
  223c46:	685b      	ldr	r3, [r3, #4]
  223c48:	683a      	ldr	r2, [r7, #0]
  223c4a:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
  223c4c:	683b      	ldr	r3, [r7, #0]
  223c4e:	68fa      	ldr	r2, [r7, #12]
  223c50:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
  223c52:	68fb      	ldr	r3, [r7, #12]
  223c54:	683a      	ldr	r2, [r7, #0]
  223c56:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
  223c58:	683b      	ldr	r3, [r7, #0]
  223c5a:	687a      	ldr	r2, [r7, #4]
  223c5c:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  223c5e:	687b      	ldr	r3, [r7, #4]
  223c60:	681b      	ldr	r3, [r3, #0]
  223c62:	1c5a      	adds	r2, r3, #1
  223c64:	687b      	ldr	r3, [r7, #4]
  223c66:	601a      	str	r2, [r3, #0]
}
  223c68:	bf00      	nop
  223c6a:	3714      	adds	r7, #20
  223c6c:	46bd      	mov	sp, r7
  223c6e:	f85d 7b04 	ldr.w	r7, [sp], #4
  223c72:	4770      	bx	lr

00223c74 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
  223c74:	b480      	push	{r7}
  223c76:	b085      	sub	sp, #20
  223c78:	af00      	add	r7, sp, #0
  223c7a:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
  223c7c:	687b      	ldr	r3, [r7, #4]
  223c7e:	691b      	ldr	r3, [r3, #16]
  223c80:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  223c82:	687b      	ldr	r3, [r7, #4]
  223c84:	685b      	ldr	r3, [r3, #4]
  223c86:	687a      	ldr	r2, [r7, #4]
  223c88:	6892      	ldr	r2, [r2, #8]
  223c8a:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  223c8c:	687b      	ldr	r3, [r7, #4]
  223c8e:	689b      	ldr	r3, [r3, #8]
  223c90:	687a      	ldr	r2, [r7, #4]
  223c92:	6852      	ldr	r2, [r2, #4]
  223c94:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  223c96:	68fb      	ldr	r3, [r7, #12]
  223c98:	685a      	ldr	r2, [r3, #4]
  223c9a:	687b      	ldr	r3, [r7, #4]
  223c9c:	429a      	cmp	r2, r3
  223c9e:	d103      	bne.n	223ca8 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  223ca0:	687b      	ldr	r3, [r7, #4]
  223ca2:	689a      	ldr	r2, [r3, #8]
  223ca4:	68fb      	ldr	r3, [r7, #12]
  223ca6:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
  223ca8:	687b      	ldr	r3, [r7, #4]
  223caa:	2200      	movs	r2, #0
  223cac:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  223cae:	68fb      	ldr	r3, [r7, #12]
  223cb0:	681b      	ldr	r3, [r3, #0]
  223cb2:	1e5a      	subs	r2, r3, #1
  223cb4:	68fb      	ldr	r3, [r7, #12]
  223cb6:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  223cb8:	68fb      	ldr	r3, [r7, #12]
  223cba:	681b      	ldr	r3, [r3, #0]
}
  223cbc:	4618      	mov	r0, r3
  223cbe:	3714      	adds	r7, #20
  223cc0:	46bd      	mov	sp, r7
  223cc2:	f85d 7b04 	ldr.w	r7, [sp], #4
  223cc6:	4770      	bx	lr

00223cc8 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
  223cc8:	b480      	push	{r7}
  223cca:	b085      	sub	sp, #20
  223ccc:	af00      	add	r7, sp, #0
  223cce:	60f8      	str	r0, [r7, #12]
  223cd0:	60b9      	str	r1, [r7, #8]
  223cd2:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
  223cd4:	68fb      	ldr	r3, [r7, #12]
  223cd6:	3b04      	subs	r3, #4
  223cd8:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
  223cda:	68fb      	ldr	r3, [r7, #12]
  223cdc:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  223ce0:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  223ce2:	68fb      	ldr	r3, [r7, #12]
  223ce4:	3b04      	subs	r3, #4
  223ce6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
  223ce8:	68bb      	ldr	r3, [r7, #8]
  223cea:	f023 0201 	bic.w	r2, r3, #1
  223cee:	68fb      	ldr	r3, [r7, #12]
  223cf0:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
  223cf2:	68fb      	ldr	r3, [r7, #12]
  223cf4:	3b04      	subs	r3, #4
  223cf6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
  223cf8:	4a0c      	ldr	r2, [pc, #48]	; (223d2c <pxPortInitialiseStack+0x64>)
  223cfa:	68fb      	ldr	r3, [r7, #12]
  223cfc:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
  223cfe:	68fb      	ldr	r3, [r7, #12]
  223d00:	3b14      	subs	r3, #20
  223d02:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
  223d04:	687a      	ldr	r2, [r7, #4]
  223d06:	68fb      	ldr	r3, [r7, #12]
  223d08:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
  223d0a:	68fb      	ldr	r3, [r7, #12]
  223d0c:	3b04      	subs	r3, #4
  223d0e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
  223d10:	68fb      	ldr	r3, [r7, #12]
  223d12:	f06f 0202 	mvn.w	r2, #2
  223d16:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
  223d18:	68fb      	ldr	r3, [r7, #12]
  223d1a:	3b20      	subs	r3, #32
  223d1c:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
  223d1e:	68fb      	ldr	r3, [r7, #12]
}
  223d20:	4618      	mov	r0, r3
  223d22:	3714      	adds	r7, #20
  223d24:	46bd      	mov	sp, r7
  223d26:	f85d 7b04 	ldr.w	r7, [sp], #4
  223d2a:	4770      	bx	lr
  223d2c:	00223d31 	.word	0x00223d31

00223d30 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
  223d30:	b480      	push	{r7}
  223d32:	b085      	sub	sp, #20
  223d34:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
  223d36:	2300      	movs	r3, #0
  223d38:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
  223d3a:	4b13      	ldr	r3, [pc, #76]	; (223d88 <prvTaskExitError+0x58>)
  223d3c:	681b      	ldr	r3, [r3, #0]
  223d3e:	f1b3 3fff 	cmp.w	r3, #4294967295
  223d42:	d00b      	beq.n	223d5c <prvTaskExitError+0x2c>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
  223d44:	f04f 0350 	mov.w	r3, #80	; 0x50
  223d48:	b672      	cpsid	i
  223d4a:	f383 8811 	msr	BASEPRI, r3
  223d4e:	f3bf 8f6f 	isb	sy
  223d52:	f3bf 8f4f 	dsb	sy
  223d56:	b662      	cpsie	i
  223d58:	60fb      	str	r3, [r7, #12]
  223d5a:	e7fe      	b.n	223d5a <prvTaskExitError+0x2a>
  223d5c:	f04f 0350 	mov.w	r3, #80	; 0x50
  223d60:	b672      	cpsid	i
  223d62:	f383 8811 	msr	BASEPRI, r3
  223d66:	f3bf 8f6f 	isb	sy
  223d6a:	f3bf 8f4f 	dsb	sy
  223d6e:	b662      	cpsie	i
  223d70:	60bb      	str	r3, [r7, #8]
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
  223d72:	bf00      	nop
  223d74:	687b      	ldr	r3, [r7, #4]
  223d76:	2b00      	cmp	r3, #0
  223d78:	d0fc      	beq.n	223d74 <prvTaskExitError+0x44>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
  223d7a:	bf00      	nop
  223d7c:	3714      	adds	r7, #20
  223d7e:	46bd      	mov	sp, r7
  223d80:	f85d 7b04 	ldr.w	r7, [sp], #4
  223d84:	4770      	bx	lr
  223d86:	bf00      	nop
  223d88:	20000010 	.word	0x20000010
  223d8c:	00000000 	.word	0x00000000

00223d90 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
  223d90:	4b07      	ldr	r3, [pc, #28]	; (223db0 <pxCurrentTCBConst2>)
  223d92:	6819      	ldr	r1, [r3, #0]
  223d94:	6808      	ldr	r0, [r1, #0]
  223d96:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  223d9a:	f380 8809 	msr	PSP, r0
  223d9e:	f3bf 8f6f 	isb	sy
  223da2:	f04f 0000 	mov.w	r0, #0
  223da6:	f380 8811 	msr	BASEPRI, r0
  223daa:	4770      	bx	lr
  223dac:	f3af 8000 	nop.w

00223db0 <pxCurrentTCBConst2>:
  223db0:	20014878 	.word	0x20014878
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
  223db4:	bf00      	nop
  223db6:	bf00      	nop

00223db8 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
  223db8:	4808      	ldr	r0, [pc, #32]	; (223ddc <prvPortStartFirstTask+0x24>)
  223dba:	6800      	ldr	r0, [r0, #0]
  223dbc:	6800      	ldr	r0, [r0, #0]
  223dbe:	f380 8808 	msr	MSP, r0
  223dc2:	f04f 0000 	mov.w	r0, #0
  223dc6:	f380 8814 	msr	CONTROL, r0
  223dca:	b662      	cpsie	i
  223dcc:	b661      	cpsie	f
  223dce:	f3bf 8f4f 	dsb	sy
  223dd2:	f3bf 8f6f 	isb	sy
  223dd6:	df00      	svc	0
  223dd8:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
  223dda:	bf00      	nop
  223ddc:	e000ed08 	.word	0xe000ed08

00223de0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
  223de0:	b580      	push	{r7, lr}
  223de2:	b084      	sub	sp, #16
  223de4:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
  223de6:	4b36      	ldr	r3, [pc, #216]	; (223ec0 <xPortStartScheduler+0xe0>)
  223de8:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
  223dea:	68fb      	ldr	r3, [r7, #12]
  223dec:	781b      	ldrb	r3, [r3, #0]
  223dee:	b2db      	uxtb	r3, r3
  223df0:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
  223df2:	68fb      	ldr	r3, [r7, #12]
  223df4:	22ff      	movs	r2, #255	; 0xff
  223df6:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
  223df8:	68fb      	ldr	r3, [r7, #12]
  223dfa:	781b      	ldrb	r3, [r3, #0]
  223dfc:	b2db      	uxtb	r3, r3
  223dfe:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
  223e00:	78fb      	ldrb	r3, [r7, #3]
  223e02:	b2db      	uxtb	r3, r3
  223e04:	f003 0350 	and.w	r3, r3, #80	; 0x50
  223e08:	b2da      	uxtb	r2, r3
  223e0a:	4b2e      	ldr	r3, [pc, #184]	; (223ec4 <xPortStartScheduler+0xe4>)
  223e0c:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
  223e0e:	4b2e      	ldr	r3, [pc, #184]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e10:	2207      	movs	r2, #7
  223e12:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  223e14:	e009      	b.n	223e2a <xPortStartScheduler+0x4a>
		{
			ulMaxPRIGROUPValue--;
  223e16:	4b2c      	ldr	r3, [pc, #176]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e18:	681b      	ldr	r3, [r3, #0]
  223e1a:	3b01      	subs	r3, #1
  223e1c:	4a2a      	ldr	r2, [pc, #168]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e1e:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
  223e20:	78fb      	ldrb	r3, [r7, #3]
  223e22:	b2db      	uxtb	r3, r3
  223e24:	005b      	lsls	r3, r3, #1
  223e26:	b2db      	uxtb	r3, r3
  223e28:	70fb      	strb	r3, [r7, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
  223e2a:	78fb      	ldrb	r3, [r7, #3]
  223e2c:	b2db      	uxtb	r3, r3
  223e2e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  223e32:	2b80      	cmp	r3, #128	; 0x80
  223e34:	d0ef      	beq.n	223e16 <xPortStartScheduler+0x36>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
  223e36:	4b24      	ldr	r3, [pc, #144]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e38:	681b      	ldr	r3, [r3, #0]
  223e3a:	f1c3 0307 	rsb	r3, r3, #7
  223e3e:	2b04      	cmp	r3, #4
  223e40:	d00b      	beq.n	223e5a <xPortStartScheduler+0x7a>
  223e42:	f04f 0350 	mov.w	r3, #80	; 0x50
  223e46:	b672      	cpsid	i
  223e48:	f383 8811 	msr	BASEPRI, r3
  223e4c:	f3bf 8f6f 	isb	sy
  223e50:	f3bf 8f4f 	dsb	sy
  223e54:	b662      	cpsie	i
  223e56:	60bb      	str	r3, [r7, #8]
  223e58:	e7fe      	b.n	223e58 <xPortStartScheduler+0x78>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
  223e5a:	4b1b      	ldr	r3, [pc, #108]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e5c:	681b      	ldr	r3, [r3, #0]
  223e5e:	021b      	lsls	r3, r3, #8
  223e60:	4a19      	ldr	r2, [pc, #100]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e62:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
  223e64:	4b18      	ldr	r3, [pc, #96]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e66:	681b      	ldr	r3, [r3, #0]
  223e68:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  223e6c:	4a16      	ldr	r2, [pc, #88]	; (223ec8 <xPortStartScheduler+0xe8>)
  223e6e:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
  223e70:	687b      	ldr	r3, [r7, #4]
  223e72:	b2da      	uxtb	r2, r3
  223e74:	68fb      	ldr	r3, [r7, #12]
  223e76:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
  223e78:	4a14      	ldr	r2, [pc, #80]	; (223ecc <xPortStartScheduler+0xec>)
  223e7a:	4b14      	ldr	r3, [pc, #80]	; (223ecc <xPortStartScheduler+0xec>)
  223e7c:	681b      	ldr	r3, [r3, #0]
  223e7e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  223e82:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
  223e84:	4a11      	ldr	r2, [pc, #68]	; (223ecc <xPortStartScheduler+0xec>)
  223e86:	4b11      	ldr	r3, [pc, #68]	; (223ecc <xPortStartScheduler+0xec>)
  223e88:	681b      	ldr	r3, [r3, #0]
  223e8a:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
  223e8e:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
  223e90:	f000 f8d4 	bl	22403c <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
  223e94:	4b0e      	ldr	r3, [pc, #56]	; (223ed0 <xPortStartScheduler+0xf0>)
  223e96:	2200      	movs	r2, #0
  223e98:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
  223e9a:	f000 f8f3 	bl	224084 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
  223e9e:	4a0d      	ldr	r2, [pc, #52]	; (223ed4 <xPortStartScheduler+0xf4>)
  223ea0:	4b0c      	ldr	r3, [pc, #48]	; (223ed4 <xPortStartScheduler+0xf4>)
  223ea2:	681b      	ldr	r3, [r3, #0]
  223ea4:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
  223ea8:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
  223eaa:	f7ff ff85 	bl	223db8 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
  223eae:	f001 fe39 	bl	225b24 <vTaskSwitchContext>
	prvTaskExitError();
  223eb2:	f7ff ff3d 	bl	223d30 <prvTaskExitError>

	/* Should not get here! */
	return 0;
  223eb6:	2300      	movs	r3, #0
}
  223eb8:	4618      	mov	r0, r3
  223eba:	3710      	adds	r7, #16
  223ebc:	46bd      	mov	sp, r7
  223ebe:	bd80      	pop	{r7, pc}
  223ec0:	e000e400 	.word	0xe000e400
  223ec4:	20010c58 	.word	0x20010c58
  223ec8:	20010c5c 	.word	0x20010c5c
  223ecc:	e000ed20 	.word	0xe000ed20
  223ed0:	20000010 	.word	0x20000010
  223ed4:	e000ef34 	.word	0xe000ef34

00223ed8 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  223ed8:	b480      	push	{r7}
  223eda:	b083      	sub	sp, #12
  223edc:	af00      	add	r7, sp, #0
  223ede:	f04f 0350 	mov.w	r3, #80	; 0x50
  223ee2:	b672      	cpsid	i
  223ee4:	f383 8811 	msr	BASEPRI, r3
  223ee8:	f3bf 8f6f 	isb	sy
  223eec:	f3bf 8f4f 	dsb	sy
  223ef0:	b662      	cpsie	i
  223ef2:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
  223ef4:	4b0f      	ldr	r3, [pc, #60]	; (223f34 <vPortEnterCritical+0x5c>)
  223ef6:	681b      	ldr	r3, [r3, #0]
  223ef8:	3301      	adds	r3, #1
  223efa:	4a0e      	ldr	r2, [pc, #56]	; (223f34 <vPortEnterCritical+0x5c>)
  223efc:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
  223efe:	4b0d      	ldr	r3, [pc, #52]	; (223f34 <vPortEnterCritical+0x5c>)
  223f00:	681b      	ldr	r3, [r3, #0]
  223f02:	2b01      	cmp	r3, #1
  223f04:	d110      	bne.n	223f28 <vPortEnterCritical+0x50>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
  223f06:	4b0c      	ldr	r3, [pc, #48]	; (223f38 <vPortEnterCritical+0x60>)
  223f08:	681b      	ldr	r3, [r3, #0]
  223f0a:	b2db      	uxtb	r3, r3
  223f0c:	2b00      	cmp	r3, #0
  223f0e:	d00b      	beq.n	223f28 <vPortEnterCritical+0x50>
  223f10:	f04f 0350 	mov.w	r3, #80	; 0x50
  223f14:	b672      	cpsid	i
  223f16:	f383 8811 	msr	BASEPRI, r3
  223f1a:	f3bf 8f6f 	isb	sy
  223f1e:	f3bf 8f4f 	dsb	sy
  223f22:	b662      	cpsie	i
  223f24:	603b      	str	r3, [r7, #0]
  223f26:	e7fe      	b.n	223f26 <vPortEnterCritical+0x4e>
	}
}
  223f28:	bf00      	nop
  223f2a:	370c      	adds	r7, #12
  223f2c:	46bd      	mov	sp, r7
  223f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
  223f32:	4770      	bx	lr
  223f34:	20000010 	.word	0x20000010
  223f38:	e000ed04 	.word	0xe000ed04

00223f3c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  223f3c:	b480      	push	{r7}
  223f3e:	b083      	sub	sp, #12
  223f40:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
  223f42:	4b12      	ldr	r3, [pc, #72]	; (223f8c <vPortExitCritical+0x50>)
  223f44:	681b      	ldr	r3, [r3, #0]
  223f46:	2b00      	cmp	r3, #0
  223f48:	d10b      	bne.n	223f62 <vPortExitCritical+0x26>
  223f4a:	f04f 0350 	mov.w	r3, #80	; 0x50
  223f4e:	b672      	cpsid	i
  223f50:	f383 8811 	msr	BASEPRI, r3
  223f54:	f3bf 8f6f 	isb	sy
  223f58:	f3bf 8f4f 	dsb	sy
  223f5c:	b662      	cpsie	i
  223f5e:	607b      	str	r3, [r7, #4]
  223f60:	e7fe      	b.n	223f60 <vPortExitCritical+0x24>
	uxCriticalNesting--;
  223f62:	4b0a      	ldr	r3, [pc, #40]	; (223f8c <vPortExitCritical+0x50>)
  223f64:	681b      	ldr	r3, [r3, #0]
  223f66:	3b01      	subs	r3, #1
  223f68:	4a08      	ldr	r2, [pc, #32]	; (223f8c <vPortExitCritical+0x50>)
  223f6a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
  223f6c:	4b07      	ldr	r3, [pc, #28]	; (223f8c <vPortExitCritical+0x50>)
  223f6e:	681b      	ldr	r3, [r3, #0]
  223f70:	2b00      	cmp	r3, #0
  223f72:	d104      	bne.n	223f7e <vPortExitCritical+0x42>
  223f74:	2300      	movs	r3, #0
  223f76:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
  223f78:	683b      	ldr	r3, [r7, #0]
  223f7a:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
  223f7e:	bf00      	nop
  223f80:	370c      	adds	r7, #12
  223f82:	46bd      	mov	sp, r7
  223f84:	f85d 7b04 	ldr.w	r7, [sp], #4
  223f88:	4770      	bx	lr
  223f8a:	bf00      	nop
  223f8c:	20000010 	.word	0x20000010

00223f90 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
  223f90:	f3ef 8009 	mrs	r0, PSP
  223f94:	f3bf 8f6f 	isb	sy
  223f98:	4b15      	ldr	r3, [pc, #84]	; (223ff0 <pxCurrentTCBConst>)
  223f9a:	681a      	ldr	r2, [r3, #0]
  223f9c:	f01e 0f10 	tst.w	lr, #16
  223fa0:	bf08      	it	eq
  223fa2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  223fa6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  223faa:	6010      	str	r0, [r2, #0]
  223fac:	e92d 0009 	stmdb	sp!, {r0, r3}
  223fb0:	f04f 0050 	mov.w	r0, #80	; 0x50
  223fb4:	b672      	cpsid	i
  223fb6:	f380 8811 	msr	BASEPRI, r0
  223fba:	f3bf 8f4f 	dsb	sy
  223fbe:	f3bf 8f6f 	isb	sy
  223fc2:	b662      	cpsie	i
  223fc4:	f001 fdae 	bl	225b24 <vTaskSwitchContext>
  223fc8:	f04f 0000 	mov.w	r0, #0
  223fcc:	f380 8811 	msr	BASEPRI, r0
  223fd0:	bc09      	pop	{r0, r3}
  223fd2:	6819      	ldr	r1, [r3, #0]
  223fd4:	6808      	ldr	r0, [r1, #0]
  223fd6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  223fda:	f01e 0f10 	tst.w	lr, #16
  223fde:	bf08      	it	eq
  223fe0:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  223fe4:	f380 8809 	msr	PSP, r0
  223fe8:	f3bf 8f6f 	isb	sy
  223fec:	4770      	bx	lr
  223fee:	bf00      	nop

00223ff0 <pxCurrentTCBConst>:
  223ff0:	20014878 	.word	0x20014878
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
  223ff4:	bf00      	nop
  223ff6:	bf00      	nop

00223ff8 <SysTick_Handler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
  223ff8:	b580      	push	{r7, lr}
  223ffa:	b082      	sub	sp, #8
  223ffc:	af00      	add	r7, sp, #0
	__asm volatile
  223ffe:	f04f 0350 	mov.w	r3, #80	; 0x50
  224002:	b672      	cpsid	i
  224004:	f383 8811 	msr	BASEPRI, r3
  224008:	f3bf 8f6f 	isb	sy
  22400c:	f3bf 8f4f 	dsb	sy
  224010:	b662      	cpsie	i
  224012:	607b      	str	r3, [r7, #4]
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
  224014:	f001 fcc4 	bl	2259a0 <xTaskIncrementTick>
  224018:	4603      	mov	r3, r0
  22401a:	2b00      	cmp	r3, #0
  22401c:	d003      	beq.n	224026 <SysTick_Handler+0x2e>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  22401e:	4b06      	ldr	r3, [pc, #24]	; (224038 <SysTick_Handler+0x40>)
  224020:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224024:	601a      	str	r2, [r3, #0]
  224026:	2300      	movs	r3, #0
  224028:	603b      	str	r3, [r7, #0]
	__asm volatile
  22402a:	683b      	ldr	r3, [r7, #0]
  22402c:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
  224030:	bf00      	nop
  224032:	3708      	adds	r7, #8
  224034:	46bd      	mov	sp, r7
  224036:	bd80      	pop	{r7, pc}
  224038:	e000ed04 	.word	0xe000ed04

0022403c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
  22403c:	b480      	push	{r7}
  22403e:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
  224040:	4b0b      	ldr	r3, [pc, #44]	; (224070 <vPortSetupTimerInterrupt+0x34>)
  224042:	2200      	movs	r2, #0
  224044:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
  224046:	4b0b      	ldr	r3, [pc, #44]	; (224074 <vPortSetupTimerInterrupt+0x38>)
  224048:	2200      	movs	r2, #0
  22404a:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
  22404c:	4a0a      	ldr	r2, [pc, #40]	; (224078 <vPortSetupTimerInterrupt+0x3c>)
  22404e:	4b0b      	ldr	r3, [pc, #44]	; (22407c <vPortSetupTimerInterrupt+0x40>)
  224050:	681b      	ldr	r3, [r3, #0]
  224052:	490b      	ldr	r1, [pc, #44]	; (224080 <vPortSetupTimerInterrupt+0x44>)
  224054:	fba1 1303 	umull	r1, r3, r1, r3
  224058:	099b      	lsrs	r3, r3, #6
  22405a:	3b01      	subs	r3, #1
  22405c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
  22405e:	4b04      	ldr	r3, [pc, #16]	; (224070 <vPortSetupTimerInterrupt+0x34>)
  224060:	2207      	movs	r2, #7
  224062:	601a      	str	r2, [r3, #0]
}
  224064:	bf00      	nop
  224066:	46bd      	mov	sp, r7
  224068:	f85d 7b04 	ldr.w	r7, [sp], #4
  22406c:	4770      	bx	lr
  22406e:	bf00      	nop
  224070:	e000e010 	.word	0xe000e010
  224074:	e000e018 	.word	0xe000e018
  224078:	e000e014 	.word	0xe000e014
  22407c:	20000004 	.word	0x20000004
  224080:	10624dd3 	.word	0x10624dd3

00224084 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
  224084:	f8df 000c 	ldr.w	r0, [pc, #12]	; 224094 <vPortEnableVFP+0x10>
  224088:	6801      	ldr	r1, [r0, #0]
  22408a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
  22408e:	6001      	str	r1, [r0, #0]
  224090:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
  224092:	bf00      	nop
  224094:	e000ed88 	.word	0xe000ed88

00224098 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
  224098:	b480      	push	{r7}
  22409a:	b085      	sub	sp, #20
  22409c:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
  22409e:	f3ef 8305 	mrs	r3, IPSR
  2240a2:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
  2240a4:	68fb      	ldr	r3, [r7, #12]
  2240a6:	2b0f      	cmp	r3, #15
  2240a8:	d915      	bls.n	2240d6 <vPortValidateInterruptPriority+0x3e>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
  2240aa:	4a18      	ldr	r2, [pc, #96]	; (22410c <vPortValidateInterruptPriority+0x74>)
  2240ac:	68fb      	ldr	r3, [r7, #12]
  2240ae:	4413      	add	r3, r2
  2240b0:	781b      	ldrb	r3, [r3, #0]
  2240b2:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
  2240b4:	4b16      	ldr	r3, [pc, #88]	; (224110 <vPortValidateInterruptPriority+0x78>)
  2240b6:	781b      	ldrb	r3, [r3, #0]
  2240b8:	7afa      	ldrb	r2, [r7, #11]
  2240ba:	429a      	cmp	r2, r3
  2240bc:	d20b      	bcs.n	2240d6 <vPortValidateInterruptPriority+0x3e>
	__asm volatile
  2240be:	f04f 0350 	mov.w	r3, #80	; 0x50
  2240c2:	b672      	cpsid	i
  2240c4:	f383 8811 	msr	BASEPRI, r3
  2240c8:	f3bf 8f6f 	isb	sy
  2240cc:	f3bf 8f4f 	dsb	sy
  2240d0:	b662      	cpsie	i
  2240d2:	607b      	str	r3, [r7, #4]
  2240d4:	e7fe      	b.n	2240d4 <vPortValidateInterruptPriority+0x3c>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
  2240d6:	4b0f      	ldr	r3, [pc, #60]	; (224114 <vPortValidateInterruptPriority+0x7c>)
  2240d8:	681b      	ldr	r3, [r3, #0]
  2240da:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
  2240de:	4b0e      	ldr	r3, [pc, #56]	; (224118 <vPortValidateInterruptPriority+0x80>)
  2240e0:	681b      	ldr	r3, [r3, #0]
  2240e2:	429a      	cmp	r2, r3
  2240e4:	d90b      	bls.n	2240fe <vPortValidateInterruptPriority+0x66>
  2240e6:	f04f 0350 	mov.w	r3, #80	; 0x50
  2240ea:	b672      	cpsid	i
  2240ec:	f383 8811 	msr	BASEPRI, r3
  2240f0:	f3bf 8f6f 	isb	sy
  2240f4:	f3bf 8f4f 	dsb	sy
  2240f8:	b662      	cpsie	i
  2240fa:	603b      	str	r3, [r7, #0]
  2240fc:	e7fe      	b.n	2240fc <vPortValidateInterruptPriority+0x64>
	}
  2240fe:	bf00      	nop
  224100:	3714      	adds	r7, #20
  224102:	46bd      	mov	sp, r7
  224104:	f85d 7b04 	ldr.w	r7, [sp], #4
  224108:	4770      	bx	lr
  22410a:	bf00      	nop
  22410c:	e000e3f0 	.word	0xe000e3f0
  224110:	20010c58 	.word	0x20010c58
  224114:	e000ed0c 	.word	0xe000ed0c
  224118:	20010c5c 	.word	0x20010c5c

0022411c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  22411c:	b580      	push	{r7, lr}
  22411e:	b08a      	sub	sp, #40	; 0x28
  224120:	af00      	add	r7, sp, #0
  224122:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  224124:	2300      	movs	r3, #0
  224126:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
  224128:	f001 fb6c 	bl	225804 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  22412c:	4b5a      	ldr	r3, [pc, #360]	; (224298 <pvPortMalloc+0x17c>)
  22412e:	681b      	ldr	r3, [r3, #0]
  224130:	2b00      	cmp	r3, #0
  224132:	d101      	bne.n	224138 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
  224134:	f000 f916 	bl	224364 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
  224138:	4b58      	ldr	r3, [pc, #352]	; (22429c <pvPortMalloc+0x180>)
  22413a:	681a      	ldr	r2, [r3, #0]
  22413c:	687b      	ldr	r3, [r7, #4]
  22413e:	4013      	ands	r3, r2
  224140:	2b00      	cmp	r3, #0
  224142:	f040 8090 	bne.w	224266 <pvPortMalloc+0x14a>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
  224146:	687b      	ldr	r3, [r7, #4]
  224148:	2b00      	cmp	r3, #0
  22414a:	d01e      	beq.n	22418a <pvPortMalloc+0x6e>
			{
				xWantedSize += xHeapStructSize;
  22414c:	2208      	movs	r2, #8
  22414e:	687b      	ldr	r3, [r7, #4]
  224150:	4413      	add	r3, r2
  224152:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
  224154:	687b      	ldr	r3, [r7, #4]
  224156:	f003 0307 	and.w	r3, r3, #7
  22415a:	2b00      	cmp	r3, #0
  22415c:	d015      	beq.n	22418a <pvPortMalloc+0x6e>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  22415e:	687b      	ldr	r3, [r7, #4]
  224160:	f023 0307 	bic.w	r3, r3, #7
  224164:	3308      	adds	r3, #8
  224166:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
  224168:	687b      	ldr	r3, [r7, #4]
  22416a:	f003 0307 	and.w	r3, r3, #7
  22416e:	2b00      	cmp	r3, #0
  224170:	d00b      	beq.n	22418a <pvPortMalloc+0x6e>
  224172:	f04f 0350 	mov.w	r3, #80	; 0x50
  224176:	b672      	cpsid	i
  224178:	f383 8811 	msr	BASEPRI, r3
  22417c:	f3bf 8f6f 	isb	sy
  224180:	f3bf 8f4f 	dsb	sy
  224184:	b662      	cpsie	i
  224186:	617b      	str	r3, [r7, #20]
  224188:	e7fe      	b.n	224188 <pvPortMalloc+0x6c>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
  22418a:	687b      	ldr	r3, [r7, #4]
  22418c:	2b00      	cmp	r3, #0
  22418e:	d06a      	beq.n	224266 <pvPortMalloc+0x14a>
  224190:	4b43      	ldr	r3, [pc, #268]	; (2242a0 <pvPortMalloc+0x184>)
  224192:	681b      	ldr	r3, [r3, #0]
  224194:	687a      	ldr	r2, [r7, #4]
  224196:	429a      	cmp	r2, r3
  224198:	d865      	bhi.n	224266 <pvPortMalloc+0x14a>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
  22419a:	4b42      	ldr	r3, [pc, #264]	; (2242a4 <pvPortMalloc+0x188>)
  22419c:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
  22419e:	4b41      	ldr	r3, [pc, #260]	; (2242a4 <pvPortMalloc+0x188>)
  2241a0:	681b      	ldr	r3, [r3, #0]
  2241a2:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  2241a4:	e004      	b.n	2241b0 <pvPortMalloc+0x94>
				{
					pxPreviousBlock = pxBlock;
  2241a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2241a8:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
  2241aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2241ac:	681b      	ldr	r3, [r3, #0]
  2241ae:	627b      	str	r3, [r7, #36]	; 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  2241b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2241b2:	685a      	ldr	r2, [r3, #4]
  2241b4:	687b      	ldr	r3, [r7, #4]
  2241b6:	429a      	cmp	r2, r3
  2241b8:	d203      	bcs.n	2241c2 <pvPortMalloc+0xa6>
  2241ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2241bc:	681b      	ldr	r3, [r3, #0]
  2241be:	2b00      	cmp	r3, #0
  2241c0:	d1f1      	bne.n	2241a6 <pvPortMalloc+0x8a>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
  2241c2:	4b35      	ldr	r3, [pc, #212]	; (224298 <pvPortMalloc+0x17c>)
  2241c4:	681b      	ldr	r3, [r3, #0]
  2241c6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2241c8:	429a      	cmp	r2, r3
  2241ca:	d04c      	beq.n	224266 <pvPortMalloc+0x14a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
  2241cc:	6a3b      	ldr	r3, [r7, #32]
  2241ce:	681b      	ldr	r3, [r3, #0]
  2241d0:	2208      	movs	r2, #8
  2241d2:	4413      	add	r3, r2
  2241d4:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  2241d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2241d8:	681a      	ldr	r2, [r3, #0]
  2241da:	6a3b      	ldr	r3, [r7, #32]
  2241dc:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  2241de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  2241e0:	685a      	ldr	r2, [r3, #4]
  2241e2:	687b      	ldr	r3, [r7, #4]
  2241e4:	1ad2      	subs	r2, r2, r3
  2241e6:	2308      	movs	r3, #8
  2241e8:	005b      	lsls	r3, r3, #1
  2241ea:	429a      	cmp	r2, r3
  2241ec:	d920      	bls.n	224230 <pvPortMalloc+0x114>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
  2241ee:	6a7a      	ldr	r2, [r7, #36]	; 0x24
  2241f0:	687b      	ldr	r3, [r7, #4]
  2241f2:	4413      	add	r3, r2
  2241f4:	61bb      	str	r3, [r7, #24]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
  2241f6:	69bb      	ldr	r3, [r7, #24]
  2241f8:	f003 0307 	and.w	r3, r3, #7
  2241fc:	2b00      	cmp	r3, #0
  2241fe:	d00b      	beq.n	224218 <pvPortMalloc+0xfc>
  224200:	f04f 0350 	mov.w	r3, #80	; 0x50
  224204:	b672      	cpsid	i
  224206:	f383 8811 	msr	BASEPRI, r3
  22420a:	f3bf 8f6f 	isb	sy
  22420e:	f3bf 8f4f 	dsb	sy
  224212:	b662      	cpsie	i
  224214:	613b      	str	r3, [r7, #16]
  224216:	e7fe      	b.n	224216 <pvPortMalloc+0xfa>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  224218:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  22421a:	685a      	ldr	r2, [r3, #4]
  22421c:	687b      	ldr	r3, [r7, #4]
  22421e:	1ad2      	subs	r2, r2, r3
  224220:	69bb      	ldr	r3, [r7, #24]
  224222:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
  224224:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  224226:	687a      	ldr	r2, [r7, #4]
  224228:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
  22422a:	69b8      	ldr	r0, [r7, #24]
  22422c:	f000 f8fc 	bl	224428 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
  224230:	4b1b      	ldr	r3, [pc, #108]	; (2242a0 <pvPortMalloc+0x184>)
  224232:	681a      	ldr	r2, [r3, #0]
  224234:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  224236:	685b      	ldr	r3, [r3, #4]
  224238:	1ad3      	subs	r3, r2, r3
  22423a:	4a19      	ldr	r2, [pc, #100]	; (2242a0 <pvPortMalloc+0x184>)
  22423c:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
  22423e:	4b18      	ldr	r3, [pc, #96]	; (2242a0 <pvPortMalloc+0x184>)
  224240:	681a      	ldr	r2, [r3, #0]
  224242:	4b19      	ldr	r3, [pc, #100]	; (2242a8 <pvPortMalloc+0x18c>)
  224244:	681b      	ldr	r3, [r3, #0]
  224246:	429a      	cmp	r2, r3
  224248:	d203      	bcs.n	224252 <pvPortMalloc+0x136>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
  22424a:	4b15      	ldr	r3, [pc, #84]	; (2242a0 <pvPortMalloc+0x184>)
  22424c:	681b      	ldr	r3, [r3, #0]
  22424e:	4a16      	ldr	r2, [pc, #88]	; (2242a8 <pvPortMalloc+0x18c>)
  224250:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
  224252:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  224254:	685a      	ldr	r2, [r3, #4]
  224256:	4b11      	ldr	r3, [pc, #68]	; (22429c <pvPortMalloc+0x180>)
  224258:	681b      	ldr	r3, [r3, #0]
  22425a:	431a      	orrs	r2, r3
  22425c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  22425e:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
  224260:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  224262:	2200      	movs	r2, #0
  224264:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
  224266:	f001 fadb 	bl	225820 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
  22426a:	69fb      	ldr	r3, [r7, #28]
  22426c:	f003 0307 	and.w	r3, r3, #7
  224270:	2b00      	cmp	r3, #0
  224272:	d00b      	beq.n	22428c <pvPortMalloc+0x170>
  224274:	f04f 0350 	mov.w	r3, #80	; 0x50
  224278:	b672      	cpsid	i
  22427a:	f383 8811 	msr	BASEPRI, r3
  22427e:	f3bf 8f6f 	isb	sy
  224282:	f3bf 8f4f 	dsb	sy
  224286:	b662      	cpsie	i
  224288:	60fb      	str	r3, [r7, #12]
  22428a:	e7fe      	b.n	22428a <pvPortMalloc+0x16e>
	return pvReturn;
  22428c:	69fb      	ldr	r3, [r7, #28]
}
  22428e:	4618      	mov	r0, r3
  224290:	3728      	adds	r7, #40	; 0x28
  224292:	46bd      	mov	sp, r7
  224294:	bd80      	pop	{r7, pc}
  224296:	bf00      	nop
  224298:	20014868 	.word	0x20014868
  22429c:	20014874 	.word	0x20014874
  2242a0:	2001486c 	.word	0x2001486c
  2242a4:	20014860 	.word	0x20014860
  2242a8:	20014870 	.word	0x20014870

002242ac <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  2242ac:	b580      	push	{r7, lr}
  2242ae:	b086      	sub	sp, #24
  2242b0:	af00      	add	r7, sp, #0
  2242b2:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
  2242b4:	687b      	ldr	r3, [r7, #4]
  2242b6:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
  2242b8:	687b      	ldr	r3, [r7, #4]
  2242ba:	2b00      	cmp	r3, #0
  2242bc:	d04a      	beq.n	224354 <vPortFree+0xa8>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
  2242be:	2308      	movs	r3, #8
  2242c0:	425b      	negs	r3, r3
  2242c2:	697a      	ldr	r2, [r7, #20]
  2242c4:	4413      	add	r3, r2
  2242c6:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  2242c8:	697b      	ldr	r3, [r7, #20]
  2242ca:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
  2242cc:	693b      	ldr	r3, [r7, #16]
  2242ce:	685a      	ldr	r2, [r3, #4]
  2242d0:	4b22      	ldr	r3, [pc, #136]	; (22435c <vPortFree+0xb0>)
  2242d2:	681b      	ldr	r3, [r3, #0]
  2242d4:	4013      	ands	r3, r2
  2242d6:	2b00      	cmp	r3, #0
  2242d8:	d10b      	bne.n	2242f2 <vPortFree+0x46>
  2242da:	f04f 0350 	mov.w	r3, #80	; 0x50
  2242de:	b672      	cpsid	i
  2242e0:	f383 8811 	msr	BASEPRI, r3
  2242e4:	f3bf 8f6f 	isb	sy
  2242e8:	f3bf 8f4f 	dsb	sy
  2242ec:	b662      	cpsie	i
  2242ee:	60fb      	str	r3, [r7, #12]
  2242f0:	e7fe      	b.n	2242f0 <vPortFree+0x44>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
  2242f2:	693b      	ldr	r3, [r7, #16]
  2242f4:	681b      	ldr	r3, [r3, #0]
  2242f6:	2b00      	cmp	r3, #0
  2242f8:	d00b      	beq.n	224312 <vPortFree+0x66>
  2242fa:	f04f 0350 	mov.w	r3, #80	; 0x50
  2242fe:	b672      	cpsid	i
  224300:	f383 8811 	msr	BASEPRI, r3
  224304:	f3bf 8f6f 	isb	sy
  224308:	f3bf 8f4f 	dsb	sy
  22430c:	b662      	cpsie	i
  22430e:	60bb      	str	r3, [r7, #8]
  224310:	e7fe      	b.n	224310 <vPortFree+0x64>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
  224312:	693b      	ldr	r3, [r7, #16]
  224314:	685a      	ldr	r2, [r3, #4]
  224316:	4b11      	ldr	r3, [pc, #68]	; (22435c <vPortFree+0xb0>)
  224318:	681b      	ldr	r3, [r3, #0]
  22431a:	4013      	ands	r3, r2
  22431c:	2b00      	cmp	r3, #0
  22431e:	d019      	beq.n	224354 <vPortFree+0xa8>
		{
			if( pxLink->pxNextFreeBlock == NULL )
  224320:	693b      	ldr	r3, [r7, #16]
  224322:	681b      	ldr	r3, [r3, #0]
  224324:	2b00      	cmp	r3, #0
  224326:	d115      	bne.n	224354 <vPortFree+0xa8>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
  224328:	693b      	ldr	r3, [r7, #16]
  22432a:	685a      	ldr	r2, [r3, #4]
  22432c:	4b0b      	ldr	r3, [pc, #44]	; (22435c <vPortFree+0xb0>)
  22432e:	681b      	ldr	r3, [r3, #0]
  224330:	43db      	mvns	r3, r3
  224332:	401a      	ands	r2, r3
  224334:	693b      	ldr	r3, [r7, #16]
  224336:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
  224338:	f001 fa64 	bl	225804 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
  22433c:	693b      	ldr	r3, [r7, #16]
  22433e:	685a      	ldr	r2, [r3, #4]
  224340:	4b07      	ldr	r3, [pc, #28]	; (224360 <vPortFree+0xb4>)
  224342:	681b      	ldr	r3, [r3, #0]
  224344:	4413      	add	r3, r2
  224346:	4a06      	ldr	r2, [pc, #24]	; (224360 <vPortFree+0xb4>)
  224348:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
  22434a:	6938      	ldr	r0, [r7, #16]
  22434c:	f000 f86c 	bl	224428 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
  224350:	f001 fa66 	bl	225820 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
  224354:	bf00      	nop
  224356:	3718      	adds	r7, #24
  224358:	46bd      	mov	sp, r7
  22435a:	bd80      	pop	{r7, pc}
  22435c:	20014874 	.word	0x20014874
  224360:	2001486c 	.word	0x2001486c

00224364 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  224364:	b480      	push	{r7}
  224366:	b085      	sub	sp, #20
  224368:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
  22436a:	f44f 5370 	mov.w	r3, #15360	; 0x3c00
  22436e:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
  224370:	4b27      	ldr	r3, [pc, #156]	; (224410 <prvHeapInit+0xac>)
  224372:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
  224374:	68fb      	ldr	r3, [r7, #12]
  224376:	f003 0307 	and.w	r3, r3, #7
  22437a:	2b00      	cmp	r3, #0
  22437c:	d00c      	beq.n	224398 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
  22437e:	68fb      	ldr	r3, [r7, #12]
  224380:	3307      	adds	r3, #7
  224382:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  224384:	68fb      	ldr	r3, [r7, #12]
  224386:	f023 0307 	bic.w	r3, r3, #7
  22438a:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
  22438c:	68ba      	ldr	r2, [r7, #8]
  22438e:	68fb      	ldr	r3, [r7, #12]
  224390:	1ad3      	subs	r3, r2, r3
  224392:	4a1f      	ldr	r2, [pc, #124]	; (224410 <prvHeapInit+0xac>)
  224394:	4413      	add	r3, r2
  224396:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
  224398:	68fb      	ldr	r3, [r7, #12]
  22439a:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  22439c:	4a1d      	ldr	r2, [pc, #116]	; (224414 <prvHeapInit+0xb0>)
  22439e:	687b      	ldr	r3, [r7, #4]
  2243a0:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
  2243a2:	4b1c      	ldr	r3, [pc, #112]	; (224414 <prvHeapInit+0xb0>)
  2243a4:	2200      	movs	r2, #0
  2243a6:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
  2243a8:	687a      	ldr	r2, [r7, #4]
  2243aa:	68bb      	ldr	r3, [r7, #8]
  2243ac:	4413      	add	r3, r2
  2243ae:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
  2243b0:	2208      	movs	r2, #8
  2243b2:	68fb      	ldr	r3, [r7, #12]
  2243b4:	1a9b      	subs	r3, r3, r2
  2243b6:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
  2243b8:	68fb      	ldr	r3, [r7, #12]
  2243ba:	f023 0307 	bic.w	r3, r3, #7
  2243be:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
  2243c0:	68fb      	ldr	r3, [r7, #12]
  2243c2:	4a15      	ldr	r2, [pc, #84]	; (224418 <prvHeapInit+0xb4>)
  2243c4:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
  2243c6:	4b14      	ldr	r3, [pc, #80]	; (224418 <prvHeapInit+0xb4>)
  2243c8:	681b      	ldr	r3, [r3, #0]
  2243ca:	2200      	movs	r2, #0
  2243cc:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  2243ce:	4b12      	ldr	r3, [pc, #72]	; (224418 <prvHeapInit+0xb4>)
  2243d0:	681b      	ldr	r3, [r3, #0]
  2243d2:	2200      	movs	r2, #0
  2243d4:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
  2243d6:	687b      	ldr	r3, [r7, #4]
  2243d8:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
  2243da:	683b      	ldr	r3, [r7, #0]
  2243dc:	68fa      	ldr	r2, [r7, #12]
  2243de:	1ad2      	subs	r2, r2, r3
  2243e0:	683b      	ldr	r3, [r7, #0]
  2243e2:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  2243e4:	4b0c      	ldr	r3, [pc, #48]	; (224418 <prvHeapInit+0xb4>)
  2243e6:	681a      	ldr	r2, [r3, #0]
  2243e8:	683b      	ldr	r3, [r7, #0]
  2243ea:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  2243ec:	683b      	ldr	r3, [r7, #0]
  2243ee:	685b      	ldr	r3, [r3, #4]
  2243f0:	4a0a      	ldr	r2, [pc, #40]	; (22441c <prvHeapInit+0xb8>)
  2243f2:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
  2243f4:	683b      	ldr	r3, [r7, #0]
  2243f6:	685b      	ldr	r3, [r3, #4]
  2243f8:	4a09      	ldr	r2, [pc, #36]	; (224420 <prvHeapInit+0xbc>)
  2243fa:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
  2243fc:	4b09      	ldr	r3, [pc, #36]	; (224424 <prvHeapInit+0xc0>)
  2243fe:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
  224402:	601a      	str	r2, [r3, #0]
}
  224404:	bf00      	nop
  224406:	3714      	adds	r7, #20
  224408:	46bd      	mov	sp, r7
  22440a:	f85d 7b04 	ldr.w	r7, [sp], #4
  22440e:	4770      	bx	lr
  224410:	20010c60 	.word	0x20010c60
  224414:	20014860 	.word	0x20014860
  224418:	20014868 	.word	0x20014868
  22441c:	20014870 	.word	0x20014870
  224420:	2001486c 	.word	0x2001486c
  224424:	20014874 	.word	0x20014874

00224428 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
  224428:	b480      	push	{r7}
  22442a:	b085      	sub	sp, #20
  22442c:	af00      	add	r7, sp, #0
  22442e:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  224430:	4b28      	ldr	r3, [pc, #160]	; (2244d4 <prvInsertBlockIntoFreeList+0xac>)
  224432:	60fb      	str	r3, [r7, #12]
  224434:	e002      	b.n	22443c <prvInsertBlockIntoFreeList+0x14>
  224436:	68fb      	ldr	r3, [r7, #12]
  224438:	681b      	ldr	r3, [r3, #0]
  22443a:	60fb      	str	r3, [r7, #12]
  22443c:	68fb      	ldr	r3, [r7, #12]
  22443e:	681a      	ldr	r2, [r3, #0]
  224440:	687b      	ldr	r3, [r7, #4]
  224442:	429a      	cmp	r2, r3
  224444:	d3f7      	bcc.n	224436 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
  224446:	68fb      	ldr	r3, [r7, #12]
  224448:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
  22444a:	68fb      	ldr	r3, [r7, #12]
  22444c:	685b      	ldr	r3, [r3, #4]
  22444e:	68ba      	ldr	r2, [r7, #8]
  224450:	441a      	add	r2, r3
  224452:	687b      	ldr	r3, [r7, #4]
  224454:	429a      	cmp	r2, r3
  224456:	d108      	bne.n	22446a <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  224458:	68fb      	ldr	r3, [r7, #12]
  22445a:	685a      	ldr	r2, [r3, #4]
  22445c:	687b      	ldr	r3, [r7, #4]
  22445e:	685b      	ldr	r3, [r3, #4]
  224460:	441a      	add	r2, r3
  224462:	68fb      	ldr	r3, [r7, #12]
  224464:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  224466:	68fb      	ldr	r3, [r7, #12]
  224468:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
  22446a:	687b      	ldr	r3, [r7, #4]
  22446c:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
  22446e:	687b      	ldr	r3, [r7, #4]
  224470:	685b      	ldr	r3, [r3, #4]
  224472:	68ba      	ldr	r2, [r7, #8]
  224474:	441a      	add	r2, r3
  224476:	68fb      	ldr	r3, [r7, #12]
  224478:	681b      	ldr	r3, [r3, #0]
  22447a:	429a      	cmp	r2, r3
  22447c:	d118      	bne.n	2244b0 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  22447e:	68fb      	ldr	r3, [r7, #12]
  224480:	681a      	ldr	r2, [r3, #0]
  224482:	4b15      	ldr	r3, [pc, #84]	; (2244d8 <prvInsertBlockIntoFreeList+0xb0>)
  224484:	681b      	ldr	r3, [r3, #0]
  224486:	429a      	cmp	r2, r3
  224488:	d00d      	beq.n	2244a6 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  22448a:	687b      	ldr	r3, [r7, #4]
  22448c:	685a      	ldr	r2, [r3, #4]
  22448e:	68fb      	ldr	r3, [r7, #12]
  224490:	681b      	ldr	r3, [r3, #0]
  224492:	685b      	ldr	r3, [r3, #4]
  224494:	441a      	add	r2, r3
  224496:	687b      	ldr	r3, [r7, #4]
  224498:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  22449a:	68fb      	ldr	r3, [r7, #12]
  22449c:	681b      	ldr	r3, [r3, #0]
  22449e:	681a      	ldr	r2, [r3, #0]
  2244a0:	687b      	ldr	r3, [r7, #4]
  2244a2:	601a      	str	r2, [r3, #0]
  2244a4:	e008      	b.n	2244b8 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  2244a6:	4b0c      	ldr	r3, [pc, #48]	; (2244d8 <prvInsertBlockIntoFreeList+0xb0>)
  2244a8:	681a      	ldr	r2, [r3, #0]
  2244aa:	687b      	ldr	r3, [r7, #4]
  2244ac:	601a      	str	r2, [r3, #0]
  2244ae:	e003      	b.n	2244b8 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
  2244b0:	68fb      	ldr	r3, [r7, #12]
  2244b2:	681a      	ldr	r2, [r3, #0]
  2244b4:	687b      	ldr	r3, [r7, #4]
  2244b6:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  2244b8:	68fa      	ldr	r2, [r7, #12]
  2244ba:	687b      	ldr	r3, [r7, #4]
  2244bc:	429a      	cmp	r2, r3
  2244be:	d002      	beq.n	2244c6 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  2244c0:	68fb      	ldr	r3, [r7, #12]
  2244c2:	687a      	ldr	r2, [r7, #4]
  2244c4:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  2244c6:	bf00      	nop
  2244c8:	3714      	adds	r7, #20
  2244ca:	46bd      	mov	sp, r7
  2244cc:	f85d 7b04 	ldr.w	r7, [sp], #4
  2244d0:	4770      	bx	lr
  2244d2:	bf00      	nop
  2244d4:	20014860 	.word	0x20014860
  2244d8:	20014868 	.word	0x20014868

002244dc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
  2244dc:	b580      	push	{r7, lr}
  2244de:	b084      	sub	sp, #16
  2244e0:	af00      	add	r7, sp, #0
  2244e2:	6078      	str	r0, [r7, #4]
  2244e4:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
  2244e6:	687b      	ldr	r3, [r7, #4]
  2244e8:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  2244ea:	68fb      	ldr	r3, [r7, #12]
  2244ec:	2b00      	cmp	r3, #0
  2244ee:	d10b      	bne.n	224508 <xQueueGenericReset+0x2c>
  2244f0:	f04f 0350 	mov.w	r3, #80	; 0x50
  2244f4:	b672      	cpsid	i
  2244f6:	f383 8811 	msr	BASEPRI, r3
  2244fa:	f3bf 8f6f 	isb	sy
  2244fe:	f3bf 8f4f 	dsb	sy
  224502:	b662      	cpsie	i
  224504:	60bb      	str	r3, [r7, #8]
  224506:	e7fe      	b.n	224506 <xQueueGenericReset+0x2a>

	taskENTER_CRITICAL();
  224508:	f7ff fce6 	bl	223ed8 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  22450c:	68fb      	ldr	r3, [r7, #12]
  22450e:	681a      	ldr	r2, [r3, #0]
  224510:	68fb      	ldr	r3, [r7, #12]
  224512:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  224514:	68f9      	ldr	r1, [r7, #12]
  224516:	6c09      	ldr	r1, [r1, #64]	; 0x40
  224518:	fb01 f303 	mul.w	r3, r1, r3
  22451c:	441a      	add	r2, r3
  22451e:	68fb      	ldr	r3, [r7, #12]
  224520:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
  224522:	68fb      	ldr	r3, [r7, #12]
  224524:	2200      	movs	r2, #0
  224526:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  224528:	68fb      	ldr	r3, [r7, #12]
  22452a:	681a      	ldr	r2, [r3, #0]
  22452c:	68fb      	ldr	r3, [r7, #12]
  22452e:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  224530:	68fb      	ldr	r3, [r7, #12]
  224532:	681a      	ldr	r2, [r3, #0]
  224534:	68fb      	ldr	r3, [r7, #12]
  224536:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  224538:	3b01      	subs	r3, #1
  22453a:	68f9      	ldr	r1, [r7, #12]
  22453c:	6c09      	ldr	r1, [r1, #64]	; 0x40
  22453e:	fb01 f303 	mul.w	r3, r1, r3
  224542:	441a      	add	r2, r3
  224544:	68fb      	ldr	r3, [r7, #12]
  224546:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
  224548:	68fb      	ldr	r3, [r7, #12]
  22454a:	22ff      	movs	r2, #255	; 0xff
  22454c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
  224550:	68fb      	ldr	r3, [r7, #12]
  224552:	22ff      	movs	r2, #255	; 0xff
  224554:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
  224558:	683b      	ldr	r3, [r7, #0]
  22455a:	2b00      	cmp	r3, #0
  22455c:	d114      	bne.n	224588 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  22455e:	68fb      	ldr	r3, [r7, #12]
  224560:	691b      	ldr	r3, [r3, #16]
  224562:	2b00      	cmp	r3, #0
  224564:	d01a      	beq.n	22459c <xQueueGenericReset+0xc0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  224566:	68fb      	ldr	r3, [r7, #12]
  224568:	3310      	adds	r3, #16
  22456a:	4618      	mov	r0, r3
  22456c:	f001 fb5c 	bl	225c28 <xTaskRemoveFromEventList>
  224570:	4603      	mov	r3, r0
  224572:	2b00      	cmp	r3, #0
  224574:	d012      	beq.n	22459c <xQueueGenericReset+0xc0>
				{
					queueYIELD_IF_USING_PREEMPTION();
  224576:	4b0d      	ldr	r3, [pc, #52]	; (2245ac <xQueueGenericReset+0xd0>)
  224578:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  22457c:	601a      	str	r2, [r3, #0]
  22457e:	f3bf 8f4f 	dsb	sy
  224582:	f3bf 8f6f 	isb	sy
  224586:	e009      	b.n	22459c <xQueueGenericReset+0xc0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  224588:	68fb      	ldr	r3, [r7, #12]
  22458a:	3310      	adds	r3, #16
  22458c:	4618      	mov	r0, r3
  22458e:	f7ff fae7 	bl	223b60 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  224592:	68fb      	ldr	r3, [r7, #12]
  224594:	3324      	adds	r3, #36	; 0x24
  224596:	4618      	mov	r0, r3
  224598:	f7ff fae2 	bl	223b60 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
  22459c:	f7ff fcce 	bl	223f3c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  2245a0:	2301      	movs	r3, #1
}
  2245a2:	4618      	mov	r0, r3
  2245a4:	3710      	adds	r7, #16
  2245a6:	46bd      	mov	sp, r7
  2245a8:	bd80      	pop	{r7, pc}
  2245aa:	bf00      	nop
  2245ac:	e000ed04 	.word	0xe000ed04

002245b0 <xQueueGenericCreateStatic>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_STATIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
	{
  2245b0:	b580      	push	{r7, lr}
  2245b2:	b08e      	sub	sp, #56	; 0x38
  2245b4:	af02      	add	r7, sp, #8
  2245b6:	60f8      	str	r0, [r7, #12]
  2245b8:	60b9      	str	r1, [r7, #8]
  2245ba:	607a      	str	r2, [r7, #4]
  2245bc:	603b      	str	r3, [r7, #0]
	Queue_t *pxNewQueue;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  2245be:	68fb      	ldr	r3, [r7, #12]
  2245c0:	2b00      	cmp	r3, #0
  2245c2:	d10b      	bne.n	2245dc <xQueueGenericCreateStatic+0x2c>
  2245c4:	f04f 0350 	mov.w	r3, #80	; 0x50
  2245c8:	b672      	cpsid	i
  2245ca:	f383 8811 	msr	BASEPRI, r3
  2245ce:	f3bf 8f6f 	isb	sy
  2245d2:	f3bf 8f4f 	dsb	sy
  2245d6:	b662      	cpsie	i
  2245d8:	62bb      	str	r3, [r7, #40]	; 0x28
  2245da:	e7fe      	b.n	2245da <xQueueGenericCreateStatic+0x2a>

		/* The StaticQueue_t structure and the queue storage area must be
		supplied. */
		configASSERT( pxStaticQueue != NULL );
  2245dc:	683b      	ldr	r3, [r7, #0]
  2245de:	2b00      	cmp	r3, #0
  2245e0:	d10b      	bne.n	2245fa <xQueueGenericCreateStatic+0x4a>
  2245e2:	f04f 0350 	mov.w	r3, #80	; 0x50
  2245e6:	b672      	cpsid	i
  2245e8:	f383 8811 	msr	BASEPRI, r3
  2245ec:	f3bf 8f6f 	isb	sy
  2245f0:	f3bf 8f4f 	dsb	sy
  2245f4:	b662      	cpsie	i
  2245f6:	627b      	str	r3, [r7, #36]	; 0x24
  2245f8:	e7fe      	b.n	2245f8 <xQueueGenericCreateStatic+0x48>

		/* A queue storage area should be provided if the item size is not 0, and
		should not be provided if the item size is 0. */
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
  2245fa:	687b      	ldr	r3, [r7, #4]
  2245fc:	2b00      	cmp	r3, #0
  2245fe:	d002      	beq.n	224606 <xQueueGenericCreateStatic+0x56>
  224600:	68bb      	ldr	r3, [r7, #8]
  224602:	2b00      	cmp	r3, #0
  224604:	d001      	beq.n	22460a <xQueueGenericCreateStatic+0x5a>
  224606:	2301      	movs	r3, #1
  224608:	e000      	b.n	22460c <xQueueGenericCreateStatic+0x5c>
  22460a:	2300      	movs	r3, #0
  22460c:	2b00      	cmp	r3, #0
  22460e:	d10b      	bne.n	224628 <xQueueGenericCreateStatic+0x78>
  224610:	f04f 0350 	mov.w	r3, #80	; 0x50
  224614:	b672      	cpsid	i
  224616:	f383 8811 	msr	BASEPRI, r3
  22461a:	f3bf 8f6f 	isb	sy
  22461e:	f3bf 8f4f 	dsb	sy
  224622:	b662      	cpsie	i
  224624:	623b      	str	r3, [r7, #32]
  224626:	e7fe      	b.n	224626 <xQueueGenericCreateStatic+0x76>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
  224628:	687b      	ldr	r3, [r7, #4]
  22462a:	2b00      	cmp	r3, #0
  22462c:	d102      	bne.n	224634 <xQueueGenericCreateStatic+0x84>
  22462e:	68bb      	ldr	r3, [r7, #8]
  224630:	2b00      	cmp	r3, #0
  224632:	d101      	bne.n	224638 <xQueueGenericCreateStatic+0x88>
  224634:	2301      	movs	r3, #1
  224636:	e000      	b.n	22463a <xQueueGenericCreateStatic+0x8a>
  224638:	2300      	movs	r3, #0
  22463a:	2b00      	cmp	r3, #0
  22463c:	d10b      	bne.n	224656 <xQueueGenericCreateStatic+0xa6>
  22463e:	f04f 0350 	mov.w	r3, #80	; 0x50
  224642:	b672      	cpsid	i
  224644:	f383 8811 	msr	BASEPRI, r3
  224648:	f3bf 8f6f 	isb	sy
  22464c:	f3bf 8f4f 	dsb	sy
  224650:	b662      	cpsie	i
  224652:	61fb      	str	r3, [r7, #28]
  224654:	e7fe      	b.n	224654 <xQueueGenericCreateStatic+0xa4>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
			the real queue and semaphore structures. */
			volatile size_t xSize = sizeof( StaticQueue_t );
  224656:	2348      	movs	r3, #72	; 0x48
  224658:	617b      	str	r3, [r7, #20]
			configASSERT( xSize == sizeof( Queue_t ) );
  22465a:	697b      	ldr	r3, [r7, #20]
  22465c:	2b48      	cmp	r3, #72	; 0x48
  22465e:	d00b      	beq.n	224678 <xQueueGenericCreateStatic+0xc8>
  224660:	f04f 0350 	mov.w	r3, #80	; 0x50
  224664:	b672      	cpsid	i
  224666:	f383 8811 	msr	BASEPRI, r3
  22466a:	f3bf 8f6f 	isb	sy
  22466e:	f3bf 8f4f 	dsb	sy
  224672:	b662      	cpsie	i
  224674:	61bb      	str	r3, [r7, #24]
  224676:	e7fe      	b.n	224676 <xQueueGenericCreateStatic+0xc6>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
  224678:	697b      	ldr	r3, [r7, #20]
		#endif /* configASSERT_DEFINED */

		/* The address of a statically allocated queue was passed in, use it.
		The address of a statically allocated storage area was also passed in
		but is already set. */
		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
  22467a:	683b      	ldr	r3, [r7, #0]
  22467c:	62fb      	str	r3, [r7, #44]	; 0x2c

		if( pxNewQueue != NULL )
  22467e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224680:	2b00      	cmp	r3, #0
  224682:	d00d      	beq.n	2246a0 <xQueueGenericCreateStatic+0xf0>
			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
			{
				/* Queues can be allocated wither statically or dynamically, so
				note this queue was allocated statically in case the queue is
				later deleted. */
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
  224684:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224686:	2201      	movs	r2, #1
  224688:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  22468c:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
  224690:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224692:	9300      	str	r3, [sp, #0]
  224694:	4613      	mov	r3, r2
  224696:	687a      	ldr	r2, [r7, #4]
  224698:	68b9      	ldr	r1, [r7, #8]
  22469a:	68f8      	ldr	r0, [r7, #12]
  22469c:	f000 f846 	bl	22472c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
  2246a0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
  2246a2:	4618      	mov	r0, r3
  2246a4:	3730      	adds	r7, #48	; 0x30
  2246a6:	46bd      	mov	sp, r7
  2246a8:	bd80      	pop	{r7, pc}

002246aa <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
  2246aa:	b580      	push	{r7, lr}
  2246ac:	b08a      	sub	sp, #40	; 0x28
  2246ae:	af02      	add	r7, sp, #8
  2246b0:	60f8      	str	r0, [r7, #12]
  2246b2:	60b9      	str	r1, [r7, #8]
  2246b4:	4613      	mov	r3, r2
  2246b6:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
  2246b8:	68fb      	ldr	r3, [r7, #12]
  2246ba:	2b00      	cmp	r3, #0
  2246bc:	d10b      	bne.n	2246d6 <xQueueGenericCreate+0x2c>
  2246be:	f04f 0350 	mov.w	r3, #80	; 0x50
  2246c2:	b672      	cpsid	i
  2246c4:	f383 8811 	msr	BASEPRI, r3
  2246c8:	f3bf 8f6f 	isb	sy
  2246cc:	f3bf 8f4f 	dsb	sy
  2246d0:	b662      	cpsie	i
  2246d2:	613b      	str	r3, [r7, #16]
  2246d4:	e7fe      	b.n	2246d4 <xQueueGenericCreate+0x2a>

		if( uxItemSize == ( UBaseType_t ) 0 )
  2246d6:	68bb      	ldr	r3, [r7, #8]
  2246d8:	2b00      	cmp	r3, #0
  2246da:	d102      	bne.n	2246e2 <xQueueGenericCreate+0x38>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
  2246dc:	2300      	movs	r3, #0
  2246de:	61fb      	str	r3, [r7, #28]
  2246e0:	e004      	b.n	2246ec <xQueueGenericCreate+0x42>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  2246e2:	68fb      	ldr	r3, [r7, #12]
  2246e4:	68ba      	ldr	r2, [r7, #8]
  2246e6:	fb02 f303 	mul.w	r3, r2, r3
  2246ea:	61fb      	str	r3, [r7, #28]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
  2246ec:	69fb      	ldr	r3, [r7, #28]
  2246ee:	3348      	adds	r3, #72	; 0x48
  2246f0:	4618      	mov	r0, r3
  2246f2:	f7ff fd13 	bl	22411c <pvPortMalloc>
  2246f6:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
  2246f8:	69bb      	ldr	r3, [r7, #24]
  2246fa:	2b00      	cmp	r3, #0
  2246fc:	d011      	beq.n	224722 <xQueueGenericCreate+0x78>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
  2246fe:	69bb      	ldr	r3, [r7, #24]
  224700:	617b      	str	r3, [r7, #20]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
  224702:	697b      	ldr	r3, [r7, #20]
  224704:	3348      	adds	r3, #72	; 0x48
  224706:	617b      	str	r3, [r7, #20]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
  224708:	69bb      	ldr	r3, [r7, #24]
  22470a:	2200      	movs	r2, #0
  22470c:	f883 2046 	strb.w	r2, [r3, #70]	; 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
  224710:	79fa      	ldrb	r2, [r7, #7]
  224712:	69bb      	ldr	r3, [r7, #24]
  224714:	9300      	str	r3, [sp, #0]
  224716:	4613      	mov	r3, r2
  224718:	697a      	ldr	r2, [r7, #20]
  22471a:	68b9      	ldr	r1, [r7, #8]
  22471c:	68f8      	ldr	r0, [r7, #12]
  22471e:	f000 f805 	bl	22472c <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
  224722:	69bb      	ldr	r3, [r7, #24]
	}
  224724:	4618      	mov	r0, r3
  224726:	3720      	adds	r7, #32
  224728:	46bd      	mov	sp, r7
  22472a:	bd80      	pop	{r7, pc}

0022472c <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
  22472c:	b580      	push	{r7, lr}
  22472e:	b084      	sub	sp, #16
  224730:	af00      	add	r7, sp, #0
  224732:	60f8      	str	r0, [r7, #12]
  224734:	60b9      	str	r1, [r7, #8]
  224736:	607a      	str	r2, [r7, #4]
  224738:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
  22473a:	68bb      	ldr	r3, [r7, #8]
  22473c:	2b00      	cmp	r3, #0
  22473e:	d103      	bne.n	224748 <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
  224740:	69bb      	ldr	r3, [r7, #24]
  224742:	69ba      	ldr	r2, [r7, #24]
  224744:	601a      	str	r2, [r3, #0]
  224746:	e002      	b.n	22474e <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
  224748:	69bb      	ldr	r3, [r7, #24]
  22474a:	687a      	ldr	r2, [r7, #4]
  22474c:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
  22474e:	69bb      	ldr	r3, [r7, #24]
  224750:	68fa      	ldr	r2, [r7, #12]
  224752:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
  224754:	69bb      	ldr	r3, [r7, #24]
  224756:	68ba      	ldr	r2, [r7, #8]
  224758:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
  22475a:	2101      	movs	r1, #1
  22475c:	69b8      	ldr	r0, [r7, #24]
  22475e:	f7ff febd 	bl	2244dc <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
  224762:	bf00      	nop
  224764:	3710      	adds	r7, #16
  224766:	46bd      	mov	sp, r7
  224768:	bd80      	pop	{r7, pc}
	...

0022476c <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
  22476c:	b580      	push	{r7, lr}
  22476e:	b08e      	sub	sp, #56	; 0x38
  224770:	af00      	add	r7, sp, #0
  224772:	60f8      	str	r0, [r7, #12]
  224774:	60b9      	str	r1, [r7, #8]
  224776:	607a      	str	r2, [r7, #4]
  224778:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
  22477a:	2300      	movs	r3, #0
  22477c:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  22477e:	68fb      	ldr	r3, [r7, #12]
  224780:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  224782:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224784:	2b00      	cmp	r3, #0
  224786:	d10b      	bne.n	2247a0 <xQueueGenericSend+0x34>
  224788:	f04f 0350 	mov.w	r3, #80	; 0x50
  22478c:	b672      	cpsid	i
  22478e:	f383 8811 	msr	BASEPRI, r3
  224792:	f3bf 8f6f 	isb	sy
  224796:	f3bf 8f4f 	dsb	sy
  22479a:	b662      	cpsie	i
  22479c:	62bb      	str	r3, [r7, #40]	; 0x28
  22479e:	e7fe      	b.n	22479e <xQueueGenericSend+0x32>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  2247a0:	68bb      	ldr	r3, [r7, #8]
  2247a2:	2b00      	cmp	r3, #0
  2247a4:	d103      	bne.n	2247ae <xQueueGenericSend+0x42>
  2247a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2247a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2247aa:	2b00      	cmp	r3, #0
  2247ac:	d101      	bne.n	2247b2 <xQueueGenericSend+0x46>
  2247ae:	2301      	movs	r3, #1
  2247b0:	e000      	b.n	2247b4 <xQueueGenericSend+0x48>
  2247b2:	2300      	movs	r3, #0
  2247b4:	2b00      	cmp	r3, #0
  2247b6:	d10b      	bne.n	2247d0 <xQueueGenericSend+0x64>
  2247b8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2247bc:	b672      	cpsid	i
  2247be:	f383 8811 	msr	BASEPRI, r3
  2247c2:	f3bf 8f6f 	isb	sy
  2247c6:	f3bf 8f4f 	dsb	sy
  2247ca:	b662      	cpsie	i
  2247cc:	627b      	str	r3, [r7, #36]	; 0x24
  2247ce:	e7fe      	b.n	2247ce <xQueueGenericSend+0x62>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  2247d0:	683b      	ldr	r3, [r7, #0]
  2247d2:	2b02      	cmp	r3, #2
  2247d4:	d103      	bne.n	2247de <xQueueGenericSend+0x72>
  2247d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2247d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  2247da:	2b01      	cmp	r3, #1
  2247dc:	d101      	bne.n	2247e2 <xQueueGenericSend+0x76>
  2247de:	2301      	movs	r3, #1
  2247e0:	e000      	b.n	2247e4 <xQueueGenericSend+0x78>
  2247e2:	2300      	movs	r3, #0
  2247e4:	2b00      	cmp	r3, #0
  2247e6:	d10b      	bne.n	224800 <xQueueGenericSend+0x94>
  2247e8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2247ec:	b672      	cpsid	i
  2247ee:	f383 8811 	msr	BASEPRI, r3
  2247f2:	f3bf 8f6f 	isb	sy
  2247f6:	f3bf 8f4f 	dsb	sy
  2247fa:	b662      	cpsie	i
  2247fc:	623b      	str	r3, [r7, #32]
  2247fe:	e7fe      	b.n	2247fe <xQueueGenericSend+0x92>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  224800:	f001 fbe2 	bl	225fc8 <xTaskGetSchedulerState>
  224804:	4603      	mov	r3, r0
  224806:	2b00      	cmp	r3, #0
  224808:	d102      	bne.n	224810 <xQueueGenericSend+0xa4>
  22480a:	687b      	ldr	r3, [r7, #4]
  22480c:	2b00      	cmp	r3, #0
  22480e:	d101      	bne.n	224814 <xQueueGenericSend+0xa8>
  224810:	2301      	movs	r3, #1
  224812:	e000      	b.n	224816 <xQueueGenericSend+0xaa>
  224814:	2300      	movs	r3, #0
  224816:	2b00      	cmp	r3, #0
  224818:	d10b      	bne.n	224832 <xQueueGenericSend+0xc6>
  22481a:	f04f 0350 	mov.w	r3, #80	; 0x50
  22481e:	b672      	cpsid	i
  224820:	f383 8811 	msr	BASEPRI, r3
  224824:	f3bf 8f6f 	isb	sy
  224828:	f3bf 8f4f 	dsb	sy
  22482c:	b662      	cpsie	i
  22482e:	61fb      	str	r3, [r7, #28]
  224830:	e7fe      	b.n	224830 <xQueueGenericSend+0xc4>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  224832:	f7ff fb51 	bl	223ed8 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  224836:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224838:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  22483a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  22483c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  22483e:	429a      	cmp	r2, r3
  224840:	d302      	bcc.n	224848 <xQueueGenericSend+0xdc>
  224842:	683b      	ldr	r3, [r7, #0]
  224844:	2b02      	cmp	r3, #2
  224846:	d129      	bne.n	22489c <xQueueGenericSend+0x130>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  224848:	683a      	ldr	r2, [r7, #0]
  22484a:	68b9      	ldr	r1, [r7, #8]
  22484c:	6b38      	ldr	r0, [r7, #48]	; 0x30
  22484e:	f000 fc6e 	bl	22512e <prvCopyDataToQueue>
  224852:	62f8      	str	r0, [r7, #44]	; 0x2c

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  224854:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224856:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  224858:	2b00      	cmp	r3, #0
  22485a:	d010      	beq.n	22487e <xQueueGenericSend+0x112>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  22485c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  22485e:	3324      	adds	r3, #36	; 0x24
  224860:	4618      	mov	r0, r3
  224862:	f001 f9e1 	bl	225c28 <xTaskRemoveFromEventList>
  224866:	4603      	mov	r3, r0
  224868:	2b00      	cmp	r3, #0
  22486a:	d013      	beq.n	224894 <xQueueGenericSend+0x128>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
  22486c:	4b3f      	ldr	r3, [pc, #252]	; (22496c <xQueueGenericSend+0x200>)
  22486e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224872:	601a      	str	r2, [r3, #0]
  224874:	f3bf 8f4f 	dsb	sy
  224878:	f3bf 8f6f 	isb	sy
  22487c:	e00a      	b.n	224894 <xQueueGenericSend+0x128>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
  22487e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224880:	2b00      	cmp	r3, #0
  224882:	d007      	beq.n	224894 <xQueueGenericSend+0x128>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
  224884:	4b39      	ldr	r3, [pc, #228]	; (22496c <xQueueGenericSend+0x200>)
  224886:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  22488a:	601a      	str	r2, [r3, #0]
  22488c:	f3bf 8f4f 	dsb	sy
  224890:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
  224894:	f7ff fb52 	bl	223f3c <vPortExitCritical>
				return pdPASS;
  224898:	2301      	movs	r3, #1
  22489a:	e063      	b.n	224964 <xQueueGenericSend+0x1f8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  22489c:	687b      	ldr	r3, [r7, #4]
  22489e:	2b00      	cmp	r3, #0
  2248a0:	d103      	bne.n	2248aa <xQueueGenericSend+0x13e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  2248a2:	f7ff fb4b 	bl	223f3c <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  2248a6:	2300      	movs	r3, #0
  2248a8:	e05c      	b.n	224964 <xQueueGenericSend+0x1f8>
				}
				else if( xEntryTimeSet == pdFALSE )
  2248aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2248ac:	2b00      	cmp	r3, #0
  2248ae:	d106      	bne.n	2248be <xQueueGenericSend+0x152>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  2248b0:	f107 0314 	add.w	r3, r7, #20
  2248b4:	4618      	mov	r0, r3
  2248b6:	f001 fa1b 	bl	225cf0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  2248ba:	2301      	movs	r3, #1
  2248bc:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  2248be:	f7ff fb3d 	bl	223f3c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  2248c2:	f000 ff9f 	bl	225804 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  2248c6:	f7ff fb07 	bl	223ed8 <vPortEnterCritical>
  2248ca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2248cc:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  2248d0:	b25b      	sxtb	r3, r3
  2248d2:	f1b3 3fff 	cmp.w	r3, #4294967295
  2248d6:	d103      	bne.n	2248e0 <xQueueGenericSend+0x174>
  2248d8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2248da:	2200      	movs	r2, #0
  2248dc:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  2248e0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2248e2:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  2248e6:	b25b      	sxtb	r3, r3
  2248e8:	f1b3 3fff 	cmp.w	r3, #4294967295
  2248ec:	d103      	bne.n	2248f6 <xQueueGenericSend+0x18a>
  2248ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2248f0:	2200      	movs	r2, #0
  2248f2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  2248f6:	f7ff fb21 	bl	223f3c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  2248fa:	1d3a      	adds	r2, r7, #4
  2248fc:	f107 0314 	add.w	r3, r7, #20
  224900:	4611      	mov	r1, r2
  224902:	4618      	mov	r0, r3
  224904:	f001 fa0a 	bl	225d1c <xTaskCheckForTimeOut>
  224908:	4603      	mov	r3, r0
  22490a:	2b00      	cmp	r3, #0
  22490c:	d124      	bne.n	224958 <xQueueGenericSend+0x1ec>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
  22490e:	6b38      	ldr	r0, [r7, #48]	; 0x30
  224910:	f000 fd05 	bl	22531e <prvIsQueueFull>
  224914:	4603      	mov	r3, r0
  224916:	2b00      	cmp	r3, #0
  224918:	d018      	beq.n	22494c <xQueueGenericSend+0x1e0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  22491a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  22491c:	3310      	adds	r3, #16
  22491e:	687a      	ldr	r2, [r7, #4]
  224920:	4611      	mov	r1, r2
  224922:	4618      	mov	r0, r3
  224924:	f001 f95a 	bl	225bdc <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  224928:	6b38      	ldr	r0, [r7, #48]	; 0x30
  22492a:	f000 fc90 	bl	22524e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
  22492e:	f000 ff77 	bl	225820 <xTaskResumeAll>
  224932:	4603      	mov	r3, r0
  224934:	2b00      	cmp	r3, #0
  224936:	f47f af7c 	bne.w	224832 <xQueueGenericSend+0xc6>
				{
					portYIELD_WITHIN_API();
  22493a:	4b0c      	ldr	r3, [pc, #48]	; (22496c <xQueueGenericSend+0x200>)
  22493c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224940:	601a      	str	r2, [r3, #0]
  224942:	f3bf 8f4f 	dsb	sy
  224946:	f3bf 8f6f 	isb	sy
  22494a:	e772      	b.n	224832 <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  22494c:	6b38      	ldr	r0, [r7, #48]	; 0x30
  22494e:	f000 fc7e 	bl	22524e <prvUnlockQueue>
				( void ) xTaskResumeAll();
  224952:	f000 ff65 	bl	225820 <xTaskResumeAll>
  224956:	e76c      	b.n	224832 <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  224958:	6b38      	ldr	r0, [r7, #48]	; 0x30
  22495a:	f000 fc78 	bl	22524e <prvUnlockQueue>
			( void ) xTaskResumeAll();
  22495e:	f000 ff5f 	bl	225820 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  224962:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
  224964:	4618      	mov	r0, r3
  224966:	3738      	adds	r7, #56	; 0x38
  224968:	46bd      	mov	sp, r7
  22496a:	bd80      	pop	{r7, pc}
  22496c:	e000ed04 	.word	0xe000ed04

00224970 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
  224970:	b580      	push	{r7, lr}
  224972:	b08e      	sub	sp, #56	; 0x38
  224974:	af00      	add	r7, sp, #0
  224976:	60f8      	str	r0, [r7, #12]
  224978:	60b9      	str	r1, [r7, #8]
  22497a:	607a      	str	r2, [r7, #4]
  22497c:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  22497e:	68fb      	ldr	r3, [r7, #12]
  224980:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  224982:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224984:	2b00      	cmp	r3, #0
  224986:	d10b      	bne.n	2249a0 <xQueueGenericSendFromISR+0x30>
  224988:	f04f 0350 	mov.w	r3, #80	; 0x50
  22498c:	b672      	cpsid	i
  22498e:	f383 8811 	msr	BASEPRI, r3
  224992:	f3bf 8f6f 	isb	sy
  224996:	f3bf 8f4f 	dsb	sy
  22499a:	b662      	cpsie	i
  22499c:	627b      	str	r3, [r7, #36]	; 0x24
  22499e:	e7fe      	b.n	22499e <xQueueGenericSendFromISR+0x2e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  2249a0:	68bb      	ldr	r3, [r7, #8]
  2249a2:	2b00      	cmp	r3, #0
  2249a4:	d103      	bne.n	2249ae <xQueueGenericSendFromISR+0x3e>
  2249a6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2249a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2249aa:	2b00      	cmp	r3, #0
  2249ac:	d101      	bne.n	2249b2 <xQueueGenericSendFromISR+0x42>
  2249ae:	2301      	movs	r3, #1
  2249b0:	e000      	b.n	2249b4 <xQueueGenericSendFromISR+0x44>
  2249b2:	2300      	movs	r3, #0
  2249b4:	2b00      	cmp	r3, #0
  2249b6:	d10b      	bne.n	2249d0 <xQueueGenericSendFromISR+0x60>
  2249b8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2249bc:	b672      	cpsid	i
  2249be:	f383 8811 	msr	BASEPRI, r3
  2249c2:	f3bf 8f6f 	isb	sy
  2249c6:	f3bf 8f4f 	dsb	sy
  2249ca:	b662      	cpsie	i
  2249cc:	623b      	str	r3, [r7, #32]
  2249ce:	e7fe      	b.n	2249ce <xQueueGenericSendFromISR+0x5e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
  2249d0:	683b      	ldr	r3, [r7, #0]
  2249d2:	2b02      	cmp	r3, #2
  2249d4:	d103      	bne.n	2249de <xQueueGenericSendFromISR+0x6e>
  2249d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2249d8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  2249da:	2b01      	cmp	r3, #1
  2249dc:	d101      	bne.n	2249e2 <xQueueGenericSendFromISR+0x72>
  2249de:	2301      	movs	r3, #1
  2249e0:	e000      	b.n	2249e4 <xQueueGenericSendFromISR+0x74>
  2249e2:	2300      	movs	r3, #0
  2249e4:	2b00      	cmp	r3, #0
  2249e6:	d10b      	bne.n	224a00 <xQueueGenericSendFromISR+0x90>
  2249e8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2249ec:	b672      	cpsid	i
  2249ee:	f383 8811 	msr	BASEPRI, r3
  2249f2:	f3bf 8f6f 	isb	sy
  2249f6:	f3bf 8f4f 	dsb	sy
  2249fa:	b662      	cpsie	i
  2249fc:	61fb      	str	r3, [r7, #28]
  2249fe:	e7fe      	b.n	2249fe <xQueueGenericSendFromISR+0x8e>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  224a00:	f7ff fb4a 	bl	224098 <vPortValidateInterruptPriority>
	__asm volatile
  224a04:	f3ef 8211 	mrs	r2, BASEPRI
  224a08:	f04f 0350 	mov.w	r3, #80	; 0x50
  224a0c:	b672      	cpsid	i
  224a0e:	f383 8811 	msr	BASEPRI, r3
  224a12:	f3bf 8f6f 	isb	sy
  224a16:	f3bf 8f4f 	dsb	sy
  224a1a:	b662      	cpsie	i
  224a1c:	61ba      	str	r2, [r7, #24]
  224a1e:	617b      	str	r3, [r7, #20]
	return ulOriginalBASEPRI;
  224a20:	69bb      	ldr	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  224a22:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
  224a24:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224a26:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  224a28:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224a2a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  224a2c:	429a      	cmp	r2, r3
  224a2e:	d302      	bcc.n	224a36 <xQueueGenericSendFromISR+0xc6>
  224a30:	683b      	ldr	r3, [r7, #0]
  224a32:	2b02      	cmp	r3, #2
  224a34:	d12c      	bne.n	224a90 <xQueueGenericSendFromISR+0x120>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  224a36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224a38:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  224a3c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  224a40:	683a      	ldr	r2, [r7, #0]
  224a42:	68b9      	ldr	r1, [r7, #8]
  224a44:	6b38      	ldr	r0, [r7, #48]	; 0x30
  224a46:	f000 fb72 	bl	22512e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  224a4a:	f997 302b 	ldrsb.w	r3, [r7, #43]	; 0x2b
  224a4e:	f1b3 3fff 	cmp.w	r3, #4294967295
  224a52:	d112      	bne.n	224a7a <xQueueGenericSendFromISR+0x10a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  224a54:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224a56:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  224a58:	2b00      	cmp	r3, #0
  224a5a:	d016      	beq.n	224a8a <xQueueGenericSendFromISR+0x11a>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  224a5c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224a5e:	3324      	adds	r3, #36	; 0x24
  224a60:	4618      	mov	r0, r3
  224a62:	f001 f8e1 	bl	225c28 <xTaskRemoveFromEventList>
  224a66:	4603      	mov	r3, r0
  224a68:	2b00      	cmp	r3, #0
  224a6a:	d00e      	beq.n	224a8a <xQueueGenericSendFromISR+0x11a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  224a6c:	687b      	ldr	r3, [r7, #4]
  224a6e:	2b00      	cmp	r3, #0
  224a70:	d00b      	beq.n	224a8a <xQueueGenericSendFromISR+0x11a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  224a72:	687b      	ldr	r3, [r7, #4]
  224a74:	2201      	movs	r2, #1
  224a76:	601a      	str	r2, [r3, #0]
  224a78:	e007      	b.n	224a8a <xQueueGenericSendFromISR+0x11a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  224a7a:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  224a7e:	3301      	adds	r3, #1
  224a80:	b2db      	uxtb	r3, r3
  224a82:	b25a      	sxtb	r2, r3
  224a84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224a86:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
  224a8a:	2301      	movs	r3, #1
  224a8c:	637b      	str	r3, [r7, #52]	; 0x34
		{
  224a8e:	e001      	b.n	224a94 <xQueueGenericSendFromISR+0x124>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  224a90:	2300      	movs	r3, #0
  224a92:	637b      	str	r3, [r7, #52]	; 0x34
  224a94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224a96:	613b      	str	r3, [r7, #16]
	__asm volatile
  224a98:	693b      	ldr	r3, [r7, #16]
  224a9a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  224a9e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  224aa0:	4618      	mov	r0, r3
  224aa2:	3738      	adds	r7, #56	; 0x38
  224aa4:	46bd      	mov	sp, r7
  224aa6:	bd80      	pop	{r7, pc}

00224aa8 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
  224aa8:	b580      	push	{r7, lr}
  224aaa:	b08e      	sub	sp, #56	; 0x38
  224aac:	af00      	add	r7, sp, #0
  224aae:	6078      	str	r0, [r7, #4]
  224ab0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  224ab2:	687b      	ldr	r3, [r7, #4]
  224ab4:	633b      	str	r3, [r7, #48]	; 0x30
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
  224ab6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224ab8:	2b00      	cmp	r3, #0
  224aba:	d10b      	bne.n	224ad4 <xQueueGiveFromISR+0x2c>
	__asm volatile
  224abc:	f04f 0350 	mov.w	r3, #80	; 0x50
  224ac0:	b672      	cpsid	i
  224ac2:	f383 8811 	msr	BASEPRI, r3
  224ac6:	f3bf 8f6f 	isb	sy
  224aca:	f3bf 8f4f 	dsb	sy
  224ace:	b662      	cpsie	i
  224ad0:	623b      	str	r3, [r7, #32]
  224ad2:	e7fe      	b.n	224ad2 <xQueueGiveFromISR+0x2a>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
  224ad4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224ad6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  224ad8:	2b00      	cmp	r3, #0
  224ada:	d00b      	beq.n	224af4 <xQueueGiveFromISR+0x4c>
  224adc:	f04f 0350 	mov.w	r3, #80	; 0x50
  224ae0:	b672      	cpsid	i
  224ae2:	f383 8811 	msr	BASEPRI, r3
  224ae6:	f3bf 8f6f 	isb	sy
  224aea:	f3bf 8f4f 	dsb	sy
  224aee:	b662      	cpsie	i
  224af0:	61fb      	str	r3, [r7, #28]
  224af2:	e7fe      	b.n	224af2 <xQueueGiveFromISR+0x4a>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->u.xSemaphore.xMutexHolder != NULL ) ) );
  224af4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224af6:	681b      	ldr	r3, [r3, #0]
  224af8:	2b00      	cmp	r3, #0
  224afa:	d103      	bne.n	224b04 <xQueueGiveFromISR+0x5c>
  224afc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224afe:	689b      	ldr	r3, [r3, #8]
  224b00:	2b00      	cmp	r3, #0
  224b02:	d101      	bne.n	224b08 <xQueueGiveFromISR+0x60>
  224b04:	2301      	movs	r3, #1
  224b06:	e000      	b.n	224b0a <xQueueGiveFromISR+0x62>
  224b08:	2300      	movs	r3, #0
  224b0a:	2b00      	cmp	r3, #0
  224b0c:	d10b      	bne.n	224b26 <xQueueGiveFromISR+0x7e>
  224b0e:	f04f 0350 	mov.w	r3, #80	; 0x50
  224b12:	b672      	cpsid	i
  224b14:	f383 8811 	msr	BASEPRI, r3
  224b18:	f3bf 8f6f 	isb	sy
  224b1c:	f3bf 8f4f 	dsb	sy
  224b20:	b662      	cpsie	i
  224b22:	61bb      	str	r3, [r7, #24]
  224b24:	e7fe      	b.n	224b24 <xQueueGiveFromISR+0x7c>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  224b26:	f7ff fab7 	bl	224098 <vPortValidateInterruptPriority>
	__asm volatile
  224b2a:	f3ef 8211 	mrs	r2, BASEPRI
  224b2e:	f04f 0350 	mov.w	r3, #80	; 0x50
  224b32:	b672      	cpsid	i
  224b34:	f383 8811 	msr	BASEPRI, r3
  224b38:	f3bf 8f6f 	isb	sy
  224b3c:	f3bf 8f4f 	dsb	sy
  224b40:	b662      	cpsie	i
  224b42:	617a      	str	r2, [r7, #20]
  224b44:	613b      	str	r3, [r7, #16]
	return ulOriginalBASEPRI;
  224b46:	697b      	ldr	r3, [r7, #20]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  224b48:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  224b4a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224b4c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  224b4e:	62bb      	str	r3, [r7, #40]	; 0x28

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
  224b50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224b52:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  224b54:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224b56:	429a      	cmp	r2, r3
  224b58:	d92b      	bls.n	224bb2 <xQueueGiveFromISR+0x10a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
  224b5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224b5c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  224b60:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  224b64:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224b66:	1c5a      	adds	r2, r3, #1
  224b68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224b6a:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
  224b6c:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
  224b70:	f1b3 3fff 	cmp.w	r3, #4294967295
  224b74:	d112      	bne.n	224b9c <xQueueGiveFromISR+0xf4>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  224b76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224b78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  224b7a:	2b00      	cmp	r3, #0
  224b7c:	d016      	beq.n	224bac <xQueueGiveFromISR+0x104>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  224b7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224b80:	3324      	adds	r3, #36	; 0x24
  224b82:	4618      	mov	r0, r3
  224b84:	f001 f850 	bl	225c28 <xTaskRemoveFromEventList>
  224b88:	4603      	mov	r3, r0
  224b8a:	2b00      	cmp	r3, #0
  224b8c:	d00e      	beq.n	224bac <xQueueGiveFromISR+0x104>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
  224b8e:	683b      	ldr	r3, [r7, #0]
  224b90:	2b00      	cmp	r3, #0
  224b92:	d00b      	beq.n	224bac <xQueueGiveFromISR+0x104>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
  224b94:	683b      	ldr	r3, [r7, #0]
  224b96:	2201      	movs	r2, #1
  224b98:	601a      	str	r2, [r3, #0]
  224b9a:	e007      	b.n	224bac <xQueueGiveFromISR+0x104>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
  224b9c:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  224ba0:	3301      	adds	r3, #1
  224ba2:	b2db      	uxtb	r3, r3
  224ba4:	b25a      	sxtb	r2, r3
  224ba6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224ba8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
  224bac:	2301      	movs	r3, #1
  224bae:	637b      	str	r3, [r7, #52]	; 0x34
  224bb0:	e001      	b.n	224bb6 <xQueueGiveFromISR+0x10e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  224bb2:	2300      	movs	r3, #0
  224bb4:	637b      	str	r3, [r7, #52]	; 0x34
  224bb6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224bb8:	60fb      	str	r3, [r7, #12]
	__asm volatile
  224bba:	68fb      	ldr	r3, [r7, #12]
  224bbc:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  224bc0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  224bc2:	4618      	mov	r0, r3
  224bc4:	3738      	adds	r7, #56	; 0x38
  224bc6:	46bd      	mov	sp, r7
  224bc8:	bd80      	pop	{r7, pc}
	...

00224bcc <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
  224bcc:	b580      	push	{r7, lr}
  224bce:	b08c      	sub	sp, #48	; 0x30
  224bd0:	af00      	add	r7, sp, #0
  224bd2:	60f8      	str	r0, [r7, #12]
  224bd4:	60b9      	str	r1, [r7, #8]
  224bd6:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
  224bd8:	2300      	movs	r3, #0
  224bda:	62fb      	str	r3, [r7, #44]	; 0x2c
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  224bdc:	68fb      	ldr	r3, [r7, #12]
  224bde:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
  224be0:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224be2:	2b00      	cmp	r3, #0
  224be4:	d10b      	bne.n	224bfe <xQueueReceive+0x32>
	__asm volatile
  224be6:	f04f 0350 	mov.w	r3, #80	; 0x50
  224bea:	b672      	cpsid	i
  224bec:	f383 8811 	msr	BASEPRI, r3
  224bf0:	f3bf 8f6f 	isb	sy
  224bf4:	f3bf 8f4f 	dsb	sy
  224bf8:	b662      	cpsie	i
  224bfa:	623b      	str	r3, [r7, #32]
  224bfc:	e7fe      	b.n	224bfc <xQueueReceive+0x30>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
  224bfe:	68bb      	ldr	r3, [r7, #8]
  224c00:	2b00      	cmp	r3, #0
  224c02:	d103      	bne.n	224c0c <xQueueReceive+0x40>
  224c04:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224c06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  224c08:	2b00      	cmp	r3, #0
  224c0a:	d101      	bne.n	224c10 <xQueueReceive+0x44>
  224c0c:	2301      	movs	r3, #1
  224c0e:	e000      	b.n	224c12 <xQueueReceive+0x46>
  224c10:	2300      	movs	r3, #0
  224c12:	2b00      	cmp	r3, #0
  224c14:	d10b      	bne.n	224c2e <xQueueReceive+0x62>
  224c16:	f04f 0350 	mov.w	r3, #80	; 0x50
  224c1a:	b672      	cpsid	i
  224c1c:	f383 8811 	msr	BASEPRI, r3
  224c20:	f3bf 8f6f 	isb	sy
  224c24:	f3bf 8f4f 	dsb	sy
  224c28:	b662      	cpsie	i
  224c2a:	61fb      	str	r3, [r7, #28]
  224c2c:	e7fe      	b.n	224c2c <xQueueReceive+0x60>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  224c2e:	f001 f9cb 	bl	225fc8 <xTaskGetSchedulerState>
  224c32:	4603      	mov	r3, r0
  224c34:	2b00      	cmp	r3, #0
  224c36:	d102      	bne.n	224c3e <xQueueReceive+0x72>
  224c38:	687b      	ldr	r3, [r7, #4]
  224c3a:	2b00      	cmp	r3, #0
  224c3c:	d101      	bne.n	224c42 <xQueueReceive+0x76>
  224c3e:	2301      	movs	r3, #1
  224c40:	e000      	b.n	224c44 <xQueueReceive+0x78>
  224c42:	2300      	movs	r3, #0
  224c44:	2b00      	cmp	r3, #0
  224c46:	d10b      	bne.n	224c60 <xQueueReceive+0x94>
  224c48:	f04f 0350 	mov.w	r3, #80	; 0x50
  224c4c:	b672      	cpsid	i
  224c4e:	f383 8811 	msr	BASEPRI, r3
  224c52:	f3bf 8f6f 	isb	sy
  224c56:	f3bf 8f4f 	dsb	sy
  224c5a:	b662      	cpsie	i
  224c5c:	61bb      	str	r3, [r7, #24]
  224c5e:	e7fe      	b.n	224c5e <xQueueReceive+0x92>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  224c60:	f7ff f93a 	bl	223ed8 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  224c64:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224c66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  224c68:	627b      	str	r3, [r7, #36]	; 0x24

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  224c6a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  224c6c:	2b00      	cmp	r3, #0
  224c6e:	d01f      	beq.n	224cb0 <xQueueReceive+0xe4>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
  224c70:	68b9      	ldr	r1, [r7, #8]
  224c72:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  224c74:	f000 fac5 	bl	225202 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  224c78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  224c7a:	1e5a      	subs	r2, r3, #1
  224c7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224c7e:	639a      	str	r2, [r3, #56]	; 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  224c80:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224c82:	691b      	ldr	r3, [r3, #16]
  224c84:	2b00      	cmp	r3, #0
  224c86:	d00f      	beq.n	224ca8 <xQueueReceive+0xdc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  224c88:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224c8a:	3310      	adds	r3, #16
  224c8c:	4618      	mov	r0, r3
  224c8e:	f000 ffcb 	bl	225c28 <xTaskRemoveFromEventList>
  224c92:	4603      	mov	r3, r0
  224c94:	2b00      	cmp	r3, #0
  224c96:	d007      	beq.n	224ca8 <xQueueReceive+0xdc>
					{
						queueYIELD_IF_USING_PREEMPTION();
  224c98:	4b3c      	ldr	r3, [pc, #240]	; (224d8c <xQueueReceive+0x1c0>)
  224c9a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224c9e:	601a      	str	r2, [r3, #0]
  224ca0:	f3bf 8f4f 	dsb	sy
  224ca4:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  224ca8:	f7ff f948 	bl	223f3c <vPortExitCritical>
				return pdPASS;
  224cac:	2301      	movs	r3, #1
  224cae:	e069      	b.n	224d84 <xQueueReceive+0x1b8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  224cb0:	687b      	ldr	r3, [r7, #4]
  224cb2:	2b00      	cmp	r3, #0
  224cb4:	d103      	bne.n	224cbe <xQueueReceive+0xf2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  224cb6:	f7ff f941 	bl	223f3c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  224cba:	2300      	movs	r3, #0
  224cbc:	e062      	b.n	224d84 <xQueueReceive+0x1b8>
				}
				else if( xEntryTimeSet == pdFALSE )
  224cbe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224cc0:	2b00      	cmp	r3, #0
  224cc2:	d106      	bne.n	224cd2 <xQueueReceive+0x106>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  224cc4:	f107 0310 	add.w	r3, r7, #16
  224cc8:	4618      	mov	r0, r3
  224cca:	f001 f811 	bl	225cf0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  224cce:	2301      	movs	r3, #1
  224cd0:	62fb      	str	r3, [r7, #44]	; 0x2c
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  224cd2:	f7ff f933 	bl	223f3c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  224cd6:	f000 fd95 	bl	225804 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  224cda:	f7ff f8fd 	bl	223ed8 <vPortEnterCritical>
  224cde:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224ce0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  224ce4:	b25b      	sxtb	r3, r3
  224ce6:	f1b3 3fff 	cmp.w	r3, #4294967295
  224cea:	d103      	bne.n	224cf4 <xQueueReceive+0x128>
  224cec:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224cee:	2200      	movs	r2, #0
  224cf0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  224cf4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224cf6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  224cfa:	b25b      	sxtb	r3, r3
  224cfc:	f1b3 3fff 	cmp.w	r3, #4294967295
  224d00:	d103      	bne.n	224d0a <xQueueReceive+0x13e>
  224d02:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224d04:	2200      	movs	r2, #0
  224d06:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  224d0a:	f7ff f917 	bl	223f3c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  224d0e:	1d3a      	adds	r2, r7, #4
  224d10:	f107 0310 	add.w	r3, r7, #16
  224d14:	4611      	mov	r1, r2
  224d16:	4618      	mov	r0, r3
  224d18:	f001 f800 	bl	225d1c <xTaskCheckForTimeOut>
  224d1c:	4603      	mov	r3, r0
  224d1e:	2b00      	cmp	r3, #0
  224d20:	d123      	bne.n	224d6a <xQueueReceive+0x19e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  224d22:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  224d24:	f000 fae5 	bl	2252f2 <prvIsQueueEmpty>
  224d28:	4603      	mov	r3, r0
  224d2a:	2b00      	cmp	r3, #0
  224d2c:	d017      	beq.n	224d5e <xQueueReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  224d2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224d30:	3324      	adds	r3, #36	; 0x24
  224d32:	687a      	ldr	r2, [r7, #4]
  224d34:	4611      	mov	r1, r2
  224d36:	4618      	mov	r0, r3
  224d38:	f000 ff50 	bl	225bdc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  224d3c:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  224d3e:	f000 fa86 	bl	22524e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  224d42:	f000 fd6d 	bl	225820 <xTaskResumeAll>
  224d46:	4603      	mov	r3, r0
  224d48:	2b00      	cmp	r3, #0
  224d4a:	d189      	bne.n	224c60 <xQueueReceive+0x94>
				{
					portYIELD_WITHIN_API();
  224d4c:	4b0f      	ldr	r3, [pc, #60]	; (224d8c <xQueueReceive+0x1c0>)
  224d4e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224d52:	601a      	str	r2, [r3, #0]
  224d54:	f3bf 8f4f 	dsb	sy
  224d58:	f3bf 8f6f 	isb	sy
  224d5c:	e780      	b.n	224c60 <xQueueReceive+0x94>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
  224d5e:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  224d60:	f000 fa75 	bl	22524e <prvUnlockQueue>
				( void ) xTaskResumeAll();
  224d64:	f000 fd5c 	bl	225820 <xTaskResumeAll>
  224d68:	e77a      	b.n	224c60 <xQueueReceive+0x94>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
  224d6a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  224d6c:	f000 fa6f 	bl	22524e <prvUnlockQueue>
			( void ) xTaskResumeAll();
  224d70:	f000 fd56 	bl	225820 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  224d74:	6ab8      	ldr	r0, [r7, #40]	; 0x28
  224d76:	f000 fabc 	bl	2252f2 <prvIsQueueEmpty>
  224d7a:	4603      	mov	r3, r0
  224d7c:	2b00      	cmp	r3, #0
  224d7e:	f43f af6f 	beq.w	224c60 <xQueueReceive+0x94>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  224d82:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  224d84:	4618      	mov	r0, r3
  224d86:	3730      	adds	r7, #48	; 0x30
  224d88:	46bd      	mov	sp, r7
  224d8a:	bd80      	pop	{r7, pc}
  224d8c:	e000ed04 	.word	0xe000ed04

00224d90 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
  224d90:	b580      	push	{r7, lr}
  224d92:	b08e      	sub	sp, #56	; 0x38
  224d94:	af00      	add	r7, sp, #0
  224d96:	6078      	str	r0, [r7, #4]
  224d98:	6039      	str	r1, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
  224d9a:	2300      	movs	r3, #0
  224d9c:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
  224d9e:	687b      	ldr	r3, [r7, #4]
  224da0:	62fb      	str	r3, [r7, #44]	; 0x2c

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
  224da2:	2300      	movs	r3, #0
  224da4:	633b      	str	r3, [r7, #48]	; 0x30
#endif

	/* Check the queue pointer is not NULL. */
	configASSERT( ( pxQueue ) );
  224da6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224da8:	2b00      	cmp	r3, #0
  224daa:	d10b      	bne.n	224dc4 <xQueueSemaphoreTake+0x34>
  224dac:	f04f 0350 	mov.w	r3, #80	; 0x50
  224db0:	b672      	cpsid	i
  224db2:	f383 8811 	msr	BASEPRI, r3
  224db6:	f3bf 8f6f 	isb	sy
  224dba:	f3bf 8f4f 	dsb	sy
  224dbe:	b662      	cpsie	i
  224dc0:	623b      	str	r3, [r7, #32]
  224dc2:	e7fe      	b.n	224dc2 <xQueueSemaphoreTake+0x32>

	/* Check this really is a semaphore, in which case the item size will be
	0. */
	configASSERT( pxQueue->uxItemSize == 0 );
  224dc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224dc6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  224dc8:	2b00      	cmp	r3, #0
  224dca:	d00b      	beq.n	224de4 <xQueueSemaphoreTake+0x54>
  224dcc:	f04f 0350 	mov.w	r3, #80	; 0x50
  224dd0:	b672      	cpsid	i
  224dd2:	f383 8811 	msr	BASEPRI, r3
  224dd6:	f3bf 8f6f 	isb	sy
  224dda:	f3bf 8f4f 	dsb	sy
  224dde:	b662      	cpsie	i
  224de0:	61fb      	str	r3, [r7, #28]
  224de2:	e7fe      	b.n	224de2 <xQueueSemaphoreTake+0x52>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
  224de4:	f001 f8f0 	bl	225fc8 <xTaskGetSchedulerState>
  224de8:	4603      	mov	r3, r0
  224dea:	2b00      	cmp	r3, #0
  224dec:	d102      	bne.n	224df4 <xQueueSemaphoreTake+0x64>
  224dee:	683b      	ldr	r3, [r7, #0]
  224df0:	2b00      	cmp	r3, #0
  224df2:	d101      	bne.n	224df8 <xQueueSemaphoreTake+0x68>
  224df4:	2301      	movs	r3, #1
  224df6:	e000      	b.n	224dfa <xQueueSemaphoreTake+0x6a>
  224df8:	2300      	movs	r3, #0
  224dfa:	2b00      	cmp	r3, #0
  224dfc:	d10b      	bne.n	224e16 <xQueueSemaphoreTake+0x86>
  224dfe:	f04f 0350 	mov.w	r3, #80	; 0x50
  224e02:	b672      	cpsid	i
  224e04:	f383 8811 	msr	BASEPRI, r3
  224e08:	f3bf 8f6f 	isb	sy
  224e0c:	f3bf 8f4f 	dsb	sy
  224e10:	b662      	cpsie	i
  224e12:	61bb      	str	r3, [r7, #24]
  224e14:	e7fe      	b.n	224e14 <xQueueSemaphoreTake+0x84>
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  224e16:	f7ff f85f 	bl	223ed8 <vPortEnterCritical>
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
  224e1a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224e1c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  224e1e:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
  224e20:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224e22:	2b00      	cmp	r3, #0
  224e24:	d024      	beq.n	224e70 <xQueueSemaphoreTake+0xe0>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
  224e26:	6abb      	ldr	r3, [r7, #40]	; 0x28
  224e28:	1e5a      	subs	r2, r3, #1
  224e2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224e2c:	639a      	str	r2, [r3, #56]	; 0x38

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  224e2e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224e30:	681b      	ldr	r3, [r3, #0]
  224e32:	2b00      	cmp	r3, #0
  224e34:	d104      	bne.n	224e40 <xQueueSemaphoreTake+0xb0>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
  224e36:	f001 fa89 	bl	22634c <pvTaskIncrementMutexHeldCount>
  224e3a:	4602      	mov	r2, r0
  224e3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224e3e:	609a      	str	r2, [r3, #8]
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  224e40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224e42:	691b      	ldr	r3, [r3, #16]
  224e44:	2b00      	cmp	r3, #0
  224e46:	d00f      	beq.n	224e68 <xQueueSemaphoreTake+0xd8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  224e48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224e4a:	3310      	adds	r3, #16
  224e4c:	4618      	mov	r0, r3
  224e4e:	f000 feeb 	bl	225c28 <xTaskRemoveFromEventList>
  224e52:	4603      	mov	r3, r0
  224e54:	2b00      	cmp	r3, #0
  224e56:	d007      	beq.n	224e68 <xQueueSemaphoreTake+0xd8>
					{
						queueYIELD_IF_USING_PREEMPTION();
  224e58:	4b54      	ldr	r3, [pc, #336]	; (224fac <xQueueSemaphoreTake+0x21c>)
  224e5a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224e5e:	601a      	str	r2, [r3, #0]
  224e60:	f3bf 8f4f 	dsb	sy
  224e64:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
  224e68:	f7ff f868 	bl	223f3c <vPortExitCritical>
				return pdPASS;
  224e6c:	2301      	movs	r3, #1
  224e6e:	e098      	b.n	224fa2 <xQueueSemaphoreTake+0x212>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
  224e70:	683b      	ldr	r3, [r7, #0]
  224e72:	2b00      	cmp	r3, #0
  224e74:	d112      	bne.n	224e9c <xQueueSemaphoreTake+0x10c>
					/* For inheritance to have occurred there must have been an
					initial timeout, and an adjusted timeout cannot become 0, as
					if it were 0 the function would have exited. */
					#if( configUSE_MUTEXES == 1 )
					{
						configASSERT( xInheritanceOccurred == pdFALSE );
  224e76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224e78:	2b00      	cmp	r3, #0
  224e7a:	d00b      	beq.n	224e94 <xQueueSemaphoreTake+0x104>
  224e7c:	f04f 0350 	mov.w	r3, #80	; 0x50
  224e80:	b672      	cpsid	i
  224e82:	f383 8811 	msr	BASEPRI, r3
  224e86:	f3bf 8f6f 	isb	sy
  224e8a:	f3bf 8f4f 	dsb	sy
  224e8e:	b662      	cpsie	i
  224e90:	617b      	str	r3, [r7, #20]
  224e92:	e7fe      	b.n	224e92 <xQueueSemaphoreTake+0x102>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
  224e94:	f7ff f852 	bl	223f3c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  224e98:	2300      	movs	r3, #0
  224e9a:	e082      	b.n	224fa2 <xQueueSemaphoreTake+0x212>
				}
				else if( xEntryTimeSet == pdFALSE )
  224e9c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  224e9e:	2b00      	cmp	r3, #0
  224ea0:	d106      	bne.n	224eb0 <xQueueSemaphoreTake+0x120>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
  224ea2:	f107 030c 	add.w	r3, r7, #12
  224ea6:	4618      	mov	r0, r3
  224ea8:	f000 ff22 	bl	225cf0 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
  224eac:	2301      	movs	r3, #1
  224eae:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
  224eb0:	f7ff f844 	bl	223f3c <vPortExitCritical>

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
  224eb4:	f000 fca6 	bl	225804 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
  224eb8:	f7ff f80e 	bl	223ed8 <vPortEnterCritical>
  224ebc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224ebe:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  224ec2:	b25b      	sxtb	r3, r3
  224ec4:	f1b3 3fff 	cmp.w	r3, #4294967295
  224ec8:	d103      	bne.n	224ed2 <xQueueSemaphoreTake+0x142>
  224eca:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224ecc:	2200      	movs	r2, #0
  224ece:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
  224ed2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224ed4:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  224ed8:	b25b      	sxtb	r3, r3
  224eda:	f1b3 3fff 	cmp.w	r3, #4294967295
  224ede:	d103      	bne.n	224ee8 <xQueueSemaphoreTake+0x158>
  224ee0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224ee2:	2200      	movs	r2, #0
  224ee4:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
  224ee8:	f7ff f828 	bl	223f3c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  224eec:	463a      	mov	r2, r7
  224eee:	f107 030c 	add.w	r3, r7, #12
  224ef2:	4611      	mov	r1, r2
  224ef4:	4618      	mov	r0, r3
  224ef6:	f000 ff11 	bl	225d1c <xTaskCheckForTimeOut>
  224efa:	4603      	mov	r3, r0
  224efc:	2b00      	cmp	r3, #0
  224efe:	d132      	bne.n	224f66 <xQueueSemaphoreTake+0x1d6>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  224f00:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  224f02:	f000 f9f6 	bl	2252f2 <prvIsQueueEmpty>
  224f06:	4603      	mov	r3, r0
  224f08:	2b00      	cmp	r3, #0
  224f0a:	d026      	beq.n	224f5a <xQueueSemaphoreTake+0x1ca>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  224f0c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224f0e:	681b      	ldr	r3, [r3, #0]
  224f10:	2b00      	cmp	r3, #0
  224f12:	d109      	bne.n	224f28 <xQueueSemaphoreTake+0x198>
					{
						taskENTER_CRITICAL();
  224f14:	f7fe ffe0 	bl	223ed8 <vPortEnterCritical>
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
  224f18:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224f1a:	689b      	ldr	r3, [r3, #8]
  224f1c:	4618      	mov	r0, r3
  224f1e:	f001 f871 	bl	226004 <xTaskPriorityInherit>
  224f22:	6338      	str	r0, [r7, #48]	; 0x30
						}
						taskEXIT_CRITICAL();
  224f24:	f7ff f80a 	bl	223f3c <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  224f28:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224f2a:	3324      	adds	r3, #36	; 0x24
  224f2c:	683a      	ldr	r2, [r7, #0]
  224f2e:	4611      	mov	r1, r2
  224f30:	4618      	mov	r0, r3
  224f32:	f000 fe53 	bl	225bdc <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
  224f36:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  224f38:	f000 f989 	bl	22524e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
  224f3c:	f000 fc70 	bl	225820 <xTaskResumeAll>
  224f40:	4603      	mov	r3, r0
  224f42:	2b00      	cmp	r3, #0
  224f44:	f47f af67 	bne.w	224e16 <xQueueSemaphoreTake+0x86>
				{
					portYIELD_WITHIN_API();
  224f48:	4b18      	ldr	r3, [pc, #96]	; (224fac <xQueueSemaphoreTake+0x21c>)
  224f4a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  224f4e:	601a      	str	r2, [r3, #0]
  224f50:	f3bf 8f4f 	dsb	sy
  224f54:	f3bf 8f6f 	isb	sy
  224f58:	e75d      	b.n	224e16 <xQueueSemaphoreTake+0x86>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
  224f5a:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  224f5c:	f000 f977 	bl	22524e <prvUnlockQueue>
				( void ) xTaskResumeAll();
  224f60:	f000 fc5e 	bl	225820 <xTaskResumeAll>
  224f64:	e757      	b.n	224e16 <xQueueSemaphoreTake+0x86>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
  224f66:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  224f68:	f000 f971 	bl	22524e <prvUnlockQueue>
			( void ) xTaskResumeAll();
  224f6c:	f000 fc58 	bl	225820 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
  224f70:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  224f72:	f000 f9be 	bl	2252f2 <prvIsQueueEmpty>
  224f76:	4603      	mov	r3, r0
  224f78:	2b00      	cmp	r3, #0
  224f7a:	f43f af4c 	beq.w	224e16 <xQueueSemaphoreTake+0x86>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
  224f7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224f80:	2b00      	cmp	r3, #0
  224f82:	d00d      	beq.n	224fa0 <xQueueSemaphoreTake+0x210>
					{
						taskENTER_CRITICAL();
  224f84:	f7fe ffa8 	bl	223ed8 <vPortEnterCritical>
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
  224f88:	6af8      	ldr	r0, [r7, #44]	; 0x2c
  224f8a:	f000 f8b8 	bl	2250fe <prvGetDisinheritPriorityAfterTimeout>
  224f8e:	6278      	str	r0, [r7, #36]	; 0x24
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
  224f90:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  224f92:	689b      	ldr	r3, [r3, #8]
  224f94:	6a79      	ldr	r1, [r7, #36]	; 0x24
  224f96:	4618      	mov	r0, r3
  224f98:	f001 f93c 	bl	226214 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
  224f9c:	f7fe ffce 	bl	223f3c <vPortExitCritical>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
  224fa0:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
  224fa2:	4618      	mov	r0, r3
  224fa4:	3738      	adds	r7, #56	; 0x38
  224fa6:	46bd      	mov	sp, r7
  224fa8:	bd80      	pop	{r7, pc}
  224faa:	bf00      	nop
  224fac:	e000ed04 	.word	0xe000ed04

00224fb0 <xQueueReceiveFromISR>:
	} /*lint -restore */
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
  224fb0:	b580      	push	{r7, lr}
  224fb2:	b08e      	sub	sp, #56	; 0x38
  224fb4:	af00      	add	r7, sp, #0
  224fb6:	60f8      	str	r0, [r7, #12]
  224fb8:	60b9      	str	r1, [r7, #8]
  224fba:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
  224fbc:	68fb      	ldr	r3, [r7, #12]
  224fbe:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
  224fc0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224fc2:	2b00      	cmp	r3, #0
  224fc4:	d10b      	bne.n	224fde <xQueueReceiveFromISR+0x2e>
  224fc6:	f04f 0350 	mov.w	r3, #80	; 0x50
  224fca:	b672      	cpsid	i
  224fcc:	f383 8811 	msr	BASEPRI, r3
  224fd0:	f3bf 8f6f 	isb	sy
  224fd4:	f3bf 8f4f 	dsb	sy
  224fd8:	b662      	cpsie	i
  224fda:	623b      	str	r3, [r7, #32]
  224fdc:	e7fe      	b.n	224fdc <xQueueReceiveFromISR+0x2c>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
  224fde:	68bb      	ldr	r3, [r7, #8]
  224fe0:	2b00      	cmp	r3, #0
  224fe2:	d103      	bne.n	224fec <xQueueReceiveFromISR+0x3c>
  224fe4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  224fe6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  224fe8:	2b00      	cmp	r3, #0
  224fea:	d101      	bne.n	224ff0 <xQueueReceiveFromISR+0x40>
  224fec:	2301      	movs	r3, #1
  224fee:	e000      	b.n	224ff2 <xQueueReceiveFromISR+0x42>
  224ff0:	2300      	movs	r3, #0
  224ff2:	2b00      	cmp	r3, #0
  224ff4:	d10b      	bne.n	22500e <xQueueReceiveFromISR+0x5e>
  224ff6:	f04f 0350 	mov.w	r3, #80	; 0x50
  224ffa:	b672      	cpsid	i
  224ffc:	f383 8811 	msr	BASEPRI, r3
  225000:	f3bf 8f6f 	isb	sy
  225004:	f3bf 8f4f 	dsb	sy
  225008:	b662      	cpsie	i
  22500a:	61fb      	str	r3, [r7, #28]
  22500c:	e7fe      	b.n	22500c <xQueueReceiveFromISR+0x5c>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  22500e:	f7ff f843 	bl	224098 <vPortValidateInterruptPriority>
	__asm volatile
  225012:	f3ef 8211 	mrs	r2, BASEPRI
  225016:	f04f 0350 	mov.w	r3, #80	; 0x50
  22501a:	b672      	cpsid	i
  22501c:	f383 8811 	msr	BASEPRI, r3
  225020:	f3bf 8f6f 	isb	sy
  225024:	f3bf 8f4f 	dsb	sy
  225028:	b662      	cpsie	i
  22502a:	61ba      	str	r2, [r7, #24]
  22502c:	617b      	str	r3, [r7, #20]
	return ulOriginalBASEPRI;
  22502e:	69bb      	ldr	r3, [r7, #24]

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  225030:	62fb      	str	r3, [r7, #44]	; 0x2c
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  225032:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225034:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  225036:	62bb      	str	r3, [r7, #40]	; 0x28

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  225038:	6abb      	ldr	r3, [r7, #40]	; 0x28
  22503a:	2b00      	cmp	r3, #0
  22503c:	d02f      	beq.n	22509e <xQueueReceiveFromISR+0xee>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
  22503e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225040:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  225044:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
  225048:	68b9      	ldr	r1, [r7, #8]
  22504a:	6b38      	ldr	r0, [r7, #48]	; 0x30
  22504c:	f000 f8d9 	bl	225202 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
  225050:	6abb      	ldr	r3, [r7, #40]	; 0x28
  225052:	1e5a      	subs	r2, r3, #1
  225054:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225056:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
  225058:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
  22505c:	f1b3 3fff 	cmp.w	r3, #4294967295
  225060:	d112      	bne.n	225088 <xQueueReceiveFromISR+0xd8>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  225062:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225064:	691b      	ldr	r3, [r3, #16]
  225066:	2b00      	cmp	r3, #0
  225068:	d016      	beq.n	225098 <xQueueReceiveFromISR+0xe8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  22506a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  22506c:	3310      	adds	r3, #16
  22506e:	4618      	mov	r0, r3
  225070:	f000 fdda 	bl	225c28 <xTaskRemoveFromEventList>
  225074:	4603      	mov	r3, r0
  225076:	2b00      	cmp	r3, #0
  225078:	d00e      	beq.n	225098 <xQueueReceiveFromISR+0xe8>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
  22507a:	687b      	ldr	r3, [r7, #4]
  22507c:	2b00      	cmp	r3, #0
  22507e:	d00b      	beq.n	225098 <xQueueReceiveFromISR+0xe8>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
  225080:	687b      	ldr	r3, [r7, #4]
  225082:	2201      	movs	r2, #1
  225084:	601a      	str	r2, [r3, #0]
  225086:	e007      	b.n	225098 <xQueueReceiveFromISR+0xe8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
  225088:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  22508c:	3301      	adds	r3, #1
  22508e:	b2db      	uxtb	r3, r3
  225090:	b25a      	sxtb	r2, r3
  225092:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225094:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
  225098:	2301      	movs	r3, #1
  22509a:	637b      	str	r3, [r7, #52]	; 0x34
  22509c:	e001      	b.n	2250a2 <xQueueReceiveFromISR+0xf2>
		}
		else
		{
			xReturn = pdFAIL;
  22509e:	2300      	movs	r3, #0
  2250a0:	637b      	str	r3, [r7, #52]	; 0x34
  2250a2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2250a4:	613b      	str	r3, [r7, #16]
	__asm volatile
  2250a6:	693b      	ldr	r3, [r7, #16]
  2250a8:	f383 8811 	msr	BASEPRI, r3
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  2250ac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
}
  2250ae:	4618      	mov	r0, r3
  2250b0:	3738      	adds	r7, #56	; 0x38
  2250b2:	46bd      	mov	sp, r7
  2250b4:	bd80      	pop	{r7, pc}

002250b6 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
  2250b6:	b580      	push	{r7, lr}
  2250b8:	b084      	sub	sp, #16
  2250ba:	af00      	add	r7, sp, #0
  2250bc:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
  2250be:	687b      	ldr	r3, [r7, #4]
  2250c0:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
  2250c2:	68fb      	ldr	r3, [r7, #12]
  2250c4:	2b00      	cmp	r3, #0
  2250c6:	d10b      	bne.n	2250e0 <vQueueDelete+0x2a>
	__asm volatile
  2250c8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2250cc:	b672      	cpsid	i
  2250ce:	f383 8811 	msr	BASEPRI, r3
  2250d2:	f3bf 8f6f 	isb	sy
  2250d6:	f3bf 8f4f 	dsb	sy
  2250da:	b662      	cpsie	i
  2250dc:	60bb      	str	r3, [r7, #8]
  2250de:	e7fe      	b.n	2250de <vQueueDelete+0x28>
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
  2250e0:	68f8      	ldr	r0, [r7, #12]
  2250e2:	f000 f935 	bl	225350 <vQueueUnregisterQueue>
	}
	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
	{
		/* The queue could have been allocated statically or dynamically, so
		check before attempting to free the memory. */
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
  2250e6:	68fb      	ldr	r3, [r7, #12]
  2250e8:	f893 3046 	ldrb.w	r3, [r3, #70]	; 0x46
  2250ec:	2b00      	cmp	r3, #0
  2250ee:	d102      	bne.n	2250f6 <vQueueDelete+0x40>
		{
			vPortFree( pxQueue );
  2250f0:	68f8      	ldr	r0, [r7, #12]
  2250f2:	f7ff f8db 	bl	2242ac <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
  2250f6:	bf00      	nop
  2250f8:	3710      	adds	r7, #16
  2250fa:	46bd      	mov	sp, r7
  2250fc:	bd80      	pop	{r7, pc}

002250fe <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
  2250fe:	b480      	push	{r7}
  225100:	b085      	sub	sp, #20
  225102:	af00      	add	r7, sp, #0
  225104:	6078      	str	r0, [r7, #4]
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
  225106:	687b      	ldr	r3, [r7, #4]
  225108:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  22510a:	2b00      	cmp	r3, #0
  22510c:	d006      	beq.n	22511c <prvGetDisinheritPriorityAfterTimeout+0x1e>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
  22510e:	687b      	ldr	r3, [r7, #4]
  225110:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  225112:	681b      	ldr	r3, [r3, #0]
  225114:	f1c3 0307 	rsb	r3, r3, #7
  225118:	60fb      	str	r3, [r7, #12]
  22511a:	e001      	b.n	225120 <prvGetDisinheritPriorityAfterTimeout+0x22>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
  22511c:	2300      	movs	r3, #0
  22511e:	60fb      	str	r3, [r7, #12]
		}

		return uxHighestPriorityOfWaitingTasks;
  225120:	68fb      	ldr	r3, [r7, #12]
	}
  225122:	4618      	mov	r0, r3
  225124:	3714      	adds	r7, #20
  225126:	46bd      	mov	sp, r7
  225128:	f85d 7b04 	ldr.w	r7, [sp], #4
  22512c:	4770      	bx	lr

0022512e <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
  22512e:	b580      	push	{r7, lr}
  225130:	b086      	sub	sp, #24
  225132:	af00      	add	r7, sp, #0
  225134:	60f8      	str	r0, [r7, #12]
  225136:	60b9      	str	r1, [r7, #8]
  225138:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
  22513a:	2300      	movs	r3, #0
  22513c:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
  22513e:	68fb      	ldr	r3, [r7, #12]
  225140:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  225142:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
  225144:	68fb      	ldr	r3, [r7, #12]
  225146:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  225148:	2b00      	cmp	r3, #0
  22514a:	d10d      	bne.n	225168 <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  22514c:	68fb      	ldr	r3, [r7, #12]
  22514e:	681b      	ldr	r3, [r3, #0]
  225150:	2b00      	cmp	r3, #0
  225152:	d14d      	bne.n	2251f0 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
  225154:	68fb      	ldr	r3, [r7, #12]
  225156:	689b      	ldr	r3, [r3, #8]
  225158:	4618      	mov	r0, r3
  22515a:	f000 ffd3 	bl	226104 <xTaskPriorityDisinherit>
  22515e:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
  225160:	68fb      	ldr	r3, [r7, #12]
  225162:	2200      	movs	r2, #0
  225164:	609a      	str	r2, [r3, #8]
  225166:	e043      	b.n	2251f0 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
  225168:	687b      	ldr	r3, [r7, #4]
  22516a:	2b00      	cmp	r3, #0
  22516c:	d119      	bne.n	2251a2 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  22516e:	68fb      	ldr	r3, [r7, #12]
  225170:	6858      	ldr	r0, [r3, #4]
  225172:	68fb      	ldr	r3, [r7, #12]
  225174:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  225176:	461a      	mov	r2, r3
  225178:	68b9      	ldr	r1, [r7, #8]
  22517a:	f001 f9cf 	bl	22651c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  22517e:	68fb      	ldr	r3, [r7, #12]
  225180:	685a      	ldr	r2, [r3, #4]
  225182:	68fb      	ldr	r3, [r7, #12]
  225184:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  225186:	441a      	add	r2, r3
  225188:	68fb      	ldr	r3, [r7, #12]
  22518a:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  22518c:	68fb      	ldr	r3, [r7, #12]
  22518e:	685a      	ldr	r2, [r3, #4]
  225190:	68fb      	ldr	r3, [r7, #12]
  225192:	689b      	ldr	r3, [r3, #8]
  225194:	429a      	cmp	r2, r3
  225196:	d32b      	bcc.n	2251f0 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  225198:	68fb      	ldr	r3, [r7, #12]
  22519a:	681a      	ldr	r2, [r3, #0]
  22519c:	68fb      	ldr	r3, [r7, #12]
  22519e:	605a      	str	r2, [r3, #4]
  2251a0:	e026      	b.n	2251f0 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
  2251a2:	68fb      	ldr	r3, [r7, #12]
  2251a4:	68d8      	ldr	r0, [r3, #12]
  2251a6:	68fb      	ldr	r3, [r7, #12]
  2251a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2251aa:	461a      	mov	r2, r3
  2251ac:	68b9      	ldr	r1, [r7, #8]
  2251ae:	f001 f9b5 	bl	22651c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
  2251b2:	68fb      	ldr	r3, [r7, #12]
  2251b4:	68da      	ldr	r2, [r3, #12]
  2251b6:	68fb      	ldr	r3, [r7, #12]
  2251b8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2251ba:	425b      	negs	r3, r3
  2251bc:	441a      	add	r2, r3
  2251be:	68fb      	ldr	r3, [r7, #12]
  2251c0:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
  2251c2:	68fb      	ldr	r3, [r7, #12]
  2251c4:	68da      	ldr	r2, [r3, #12]
  2251c6:	68fb      	ldr	r3, [r7, #12]
  2251c8:	681b      	ldr	r3, [r3, #0]
  2251ca:	429a      	cmp	r2, r3
  2251cc:	d207      	bcs.n	2251de <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
  2251ce:	68fb      	ldr	r3, [r7, #12]
  2251d0:	689a      	ldr	r2, [r3, #8]
  2251d2:	68fb      	ldr	r3, [r7, #12]
  2251d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  2251d6:	425b      	negs	r3, r3
  2251d8:	441a      	add	r2, r3
  2251da:	68fb      	ldr	r3, [r7, #12]
  2251dc:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
  2251de:	687b      	ldr	r3, [r7, #4]
  2251e0:	2b02      	cmp	r3, #2
  2251e2:	d105      	bne.n	2251f0 <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
  2251e4:	693b      	ldr	r3, [r7, #16]
  2251e6:	2b00      	cmp	r3, #0
  2251e8:	d002      	beq.n	2251f0 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
  2251ea:	693b      	ldr	r3, [r7, #16]
  2251ec:	3b01      	subs	r3, #1
  2251ee:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
  2251f0:	693b      	ldr	r3, [r7, #16]
  2251f2:	1c5a      	adds	r2, r3, #1
  2251f4:	68fb      	ldr	r3, [r7, #12]
  2251f6:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
  2251f8:	697b      	ldr	r3, [r7, #20]
}
  2251fa:	4618      	mov	r0, r3
  2251fc:	3718      	adds	r7, #24
  2251fe:	46bd      	mov	sp, r7
  225200:	bd80      	pop	{r7, pc}

00225202 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
  225202:	b580      	push	{r7, lr}
  225204:	b082      	sub	sp, #8
  225206:	af00      	add	r7, sp, #0
  225208:	6078      	str	r0, [r7, #4]
  22520a:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
  22520c:	687b      	ldr	r3, [r7, #4]
  22520e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  225210:	2b00      	cmp	r3, #0
  225212:	d018      	beq.n	225246 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
  225214:	687b      	ldr	r3, [r7, #4]
  225216:	68da      	ldr	r2, [r3, #12]
  225218:	687b      	ldr	r3, [r7, #4]
  22521a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  22521c:	441a      	add	r2, r3
  22521e:	687b      	ldr	r3, [r7, #4]
  225220:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
  225222:	687b      	ldr	r3, [r7, #4]
  225224:	68da      	ldr	r2, [r3, #12]
  225226:	687b      	ldr	r3, [r7, #4]
  225228:	689b      	ldr	r3, [r3, #8]
  22522a:	429a      	cmp	r2, r3
  22522c:	d303      	bcc.n	225236 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
  22522e:	687b      	ldr	r3, [r7, #4]
  225230:	681a      	ldr	r2, [r3, #0]
  225232:	687b      	ldr	r3, [r7, #4]
  225234:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
  225236:	687b      	ldr	r3, [r7, #4]
  225238:	68d9      	ldr	r1, [r3, #12]
  22523a:	687b      	ldr	r3, [r7, #4]
  22523c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  22523e:	461a      	mov	r2, r3
  225240:	6838      	ldr	r0, [r7, #0]
  225242:	f001 f96b 	bl	22651c <memcpy>
	}
}
  225246:	bf00      	nop
  225248:	3708      	adds	r7, #8
  22524a:	46bd      	mov	sp, r7
  22524c:	bd80      	pop	{r7, pc}

0022524e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
  22524e:	b580      	push	{r7, lr}
  225250:	b084      	sub	sp, #16
  225252:	af00      	add	r7, sp, #0
  225254:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  225256:	f7fe fe3f 	bl	223ed8 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
  22525a:	687b      	ldr	r3, [r7, #4]
  22525c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
  225260:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
  225262:	e011      	b.n	225288 <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  225264:	687b      	ldr	r3, [r7, #4]
  225266:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  225268:	2b00      	cmp	r3, #0
  22526a:	d012      	beq.n	225292 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  22526c:	687b      	ldr	r3, [r7, #4]
  22526e:	3324      	adds	r3, #36	; 0x24
  225270:	4618      	mov	r0, r3
  225272:	f000 fcd9 	bl	225c28 <xTaskRemoveFromEventList>
  225276:	4603      	mov	r3, r0
  225278:	2b00      	cmp	r3, #0
  22527a:	d001      	beq.n	225280 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
  22527c:	f000 fdb2 	bl	225de4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
  225280:	7bfb      	ldrb	r3, [r7, #15]
  225282:	3b01      	subs	r3, #1
  225284:	b2db      	uxtb	r3, r3
  225286:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
  225288:	f997 300f 	ldrsb.w	r3, [r7, #15]
  22528c:	2b00      	cmp	r3, #0
  22528e:	dce9      	bgt.n	225264 <prvUnlockQueue+0x16>
  225290:	e000      	b.n	225294 <prvUnlockQueue+0x46>
					break;
  225292:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
  225294:	687b      	ldr	r3, [r7, #4]
  225296:	22ff      	movs	r2, #255	; 0xff
  225298:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
  22529c:	f7fe fe4e 	bl	223f3c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  2252a0:	f7fe fe1a 	bl	223ed8 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
  2252a4:	687b      	ldr	r3, [r7, #4]
  2252a6:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
  2252aa:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
  2252ac:	e011      	b.n	2252d2 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  2252ae:	687b      	ldr	r3, [r7, #4]
  2252b0:	691b      	ldr	r3, [r3, #16]
  2252b2:	2b00      	cmp	r3, #0
  2252b4:	d012      	beq.n	2252dc <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  2252b6:	687b      	ldr	r3, [r7, #4]
  2252b8:	3310      	adds	r3, #16
  2252ba:	4618      	mov	r0, r3
  2252bc:	f000 fcb4 	bl	225c28 <xTaskRemoveFromEventList>
  2252c0:	4603      	mov	r3, r0
  2252c2:	2b00      	cmp	r3, #0
  2252c4:	d001      	beq.n	2252ca <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
  2252c6:	f000 fd8d 	bl	225de4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
  2252ca:	7bbb      	ldrb	r3, [r7, #14]
  2252cc:	3b01      	subs	r3, #1
  2252ce:	b2db      	uxtb	r3, r3
  2252d0:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
  2252d2:	f997 300e 	ldrsb.w	r3, [r7, #14]
  2252d6:	2b00      	cmp	r3, #0
  2252d8:	dce9      	bgt.n	2252ae <prvUnlockQueue+0x60>
  2252da:	e000      	b.n	2252de <prvUnlockQueue+0x90>
			}
			else
			{
				break;
  2252dc:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
  2252de:	687b      	ldr	r3, [r7, #4]
  2252e0:	22ff      	movs	r2, #255	; 0xff
  2252e2:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  2252e6:	f7fe fe29 	bl	223f3c <vPortExitCritical>
}
  2252ea:	bf00      	nop
  2252ec:	3710      	adds	r7, #16
  2252ee:	46bd      	mov	sp, r7
  2252f0:	bd80      	pop	{r7, pc}

002252f2 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
  2252f2:	b580      	push	{r7, lr}
  2252f4:	b084      	sub	sp, #16
  2252f6:	af00      	add	r7, sp, #0
  2252f8:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  2252fa:	f7fe fded 	bl	223ed8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
  2252fe:	687b      	ldr	r3, [r7, #4]
  225300:	6b9b      	ldr	r3, [r3, #56]	; 0x38
  225302:	2b00      	cmp	r3, #0
  225304:	d102      	bne.n	22530c <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
  225306:	2301      	movs	r3, #1
  225308:	60fb      	str	r3, [r7, #12]
  22530a:	e001      	b.n	225310 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
  22530c:	2300      	movs	r3, #0
  22530e:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  225310:	f7fe fe14 	bl	223f3c <vPortExitCritical>

	return xReturn;
  225314:	68fb      	ldr	r3, [r7, #12]
}
  225316:	4618      	mov	r0, r3
  225318:	3710      	adds	r7, #16
  22531a:	46bd      	mov	sp, r7
  22531c:	bd80      	pop	{r7, pc}

0022531e <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
  22531e:	b580      	push	{r7, lr}
  225320:	b084      	sub	sp, #16
  225322:	af00      	add	r7, sp, #0
  225324:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
  225326:	f7fe fdd7 	bl	223ed8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
  22532a:	687b      	ldr	r3, [r7, #4]
  22532c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  22532e:	687b      	ldr	r3, [r7, #4]
  225330:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  225332:	429a      	cmp	r2, r3
  225334:	d102      	bne.n	22533c <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
  225336:	2301      	movs	r3, #1
  225338:	60fb      	str	r3, [r7, #12]
  22533a:	e001      	b.n	225340 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
  22533c:	2300      	movs	r3, #0
  22533e:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
  225340:	f7fe fdfc 	bl	223f3c <vPortExitCritical>

	return xReturn;
  225344:	68fb      	ldr	r3, [r7, #12]
}
  225346:	4618      	mov	r0, r3
  225348:	3710      	adds	r7, #16
  22534a:	46bd      	mov	sp, r7
  22534c:	bd80      	pop	{r7, pc}
	...

00225350 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
  225350:	b480      	push	{r7}
  225352:	b085      	sub	sp, #20
  225354:	af00      	add	r7, sp, #0
  225356:	6078      	str	r0, [r7, #4]
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  225358:	2300      	movs	r3, #0
  22535a:	60fb      	str	r3, [r7, #12]
  22535c:	e016      	b.n	22538c <vQueueUnregisterQueue+0x3c>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
  22535e:	4a10      	ldr	r2, [pc, #64]	; (2253a0 <vQueueUnregisterQueue+0x50>)
  225360:	68fb      	ldr	r3, [r7, #12]
  225362:	00db      	lsls	r3, r3, #3
  225364:	4413      	add	r3, r2
  225366:	685a      	ldr	r2, [r3, #4]
  225368:	687b      	ldr	r3, [r7, #4]
  22536a:	429a      	cmp	r2, r3
  22536c:	d10b      	bne.n	225386 <vQueueUnregisterQueue+0x36>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
  22536e:	4a0c      	ldr	r2, [pc, #48]	; (2253a0 <vQueueUnregisterQueue+0x50>)
  225370:	68fb      	ldr	r3, [r7, #12]
  225372:	2100      	movs	r1, #0
  225374:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
  225378:	4a09      	ldr	r2, [pc, #36]	; (2253a0 <vQueueUnregisterQueue+0x50>)
  22537a:	68fb      	ldr	r3, [r7, #12]
  22537c:	00db      	lsls	r3, r3, #3
  22537e:	4413      	add	r3, r2
  225380:	2200      	movs	r2, #0
  225382:	605a      	str	r2, [r3, #4]
				break;
  225384:	e005      	b.n	225392 <vQueueUnregisterQueue+0x42>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
  225386:	68fb      	ldr	r3, [r7, #12]
  225388:	3301      	adds	r3, #1
  22538a:	60fb      	str	r3, [r7, #12]
  22538c:	68fb      	ldr	r3, [r7, #12]
  22538e:	2b07      	cmp	r3, #7
  225390:	d9e5      	bls.n	22535e <vQueueUnregisterQueue+0xe>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
  225392:	bf00      	nop
  225394:	3714      	adds	r7, #20
  225396:	46bd      	mov	sp, r7
  225398:	f85d 7b04 	ldr.w	r7, [sp], #4
  22539c:	4770      	bx	lr
  22539e:	bf00      	nop
  2253a0:	200152d4 	.word	0x200152d4

002253a4 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
  2253a4:	b580      	push	{r7, lr}
  2253a6:	b08e      	sub	sp, #56	; 0x38
  2253a8:	af04      	add	r7, sp, #16
  2253aa:	60f8      	str	r0, [r7, #12]
  2253ac:	60b9      	str	r1, [r7, #8]
  2253ae:	607a      	str	r2, [r7, #4]
  2253b0:	603b      	str	r3, [r7, #0]
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

		configASSERT( puxStackBuffer != NULL );
  2253b2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  2253b4:	2b00      	cmp	r3, #0
  2253b6:	d10b      	bne.n	2253d0 <xTaskCreateStatic+0x2c>
  2253b8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2253bc:	b672      	cpsid	i
  2253be:	f383 8811 	msr	BASEPRI, r3
  2253c2:	f3bf 8f6f 	isb	sy
  2253c6:	f3bf 8f4f 	dsb	sy
  2253ca:	b662      	cpsie	i
  2253cc:	623b      	str	r3, [r7, #32]
  2253ce:	e7fe      	b.n	2253ce <xTaskCreateStatic+0x2a>
		configASSERT( pxTaskBuffer != NULL );
  2253d0:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  2253d2:	2b00      	cmp	r3, #0
  2253d4:	d10b      	bne.n	2253ee <xTaskCreateStatic+0x4a>
  2253d6:	f04f 0350 	mov.w	r3, #80	; 0x50
  2253da:	b672      	cpsid	i
  2253dc:	f383 8811 	msr	BASEPRI, r3
  2253e0:	f3bf 8f6f 	isb	sy
  2253e4:	f3bf 8f4f 	dsb	sy
  2253e8:	b662      	cpsie	i
  2253ea:	61fb      	str	r3, [r7, #28]
  2253ec:	e7fe      	b.n	2253ec <xTaskCreateStatic+0x48>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTask_t equals the size of the real task
			structure. */
			volatile size_t xSize = sizeof( StaticTask_t );
  2253ee:	2354      	movs	r3, #84	; 0x54
  2253f0:	613b      	str	r3, [r7, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
  2253f2:	693b      	ldr	r3, [r7, #16]
  2253f4:	2b54      	cmp	r3, #84	; 0x54
  2253f6:	d00b      	beq.n	225410 <xTaskCreateStatic+0x6c>
  2253f8:	f04f 0350 	mov.w	r3, #80	; 0x50
  2253fc:	b672      	cpsid	i
  2253fe:	f383 8811 	msr	BASEPRI, r3
  225402:	f3bf 8f6f 	isb	sy
  225406:	f3bf 8f4f 	dsb	sy
  22540a:	b662      	cpsie	i
  22540c:	61bb      	str	r3, [r7, #24]
  22540e:	e7fe      	b.n	22540e <xTaskCreateStatic+0x6a>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
  225410:	693b      	ldr	r3, [r7, #16]
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
  225412:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  225414:	2b00      	cmp	r3, #0
  225416:	d01e      	beq.n	225456 <xTaskCreateStatic+0xb2>
  225418:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  22541a:	2b00      	cmp	r3, #0
  22541c:	d01b      	beq.n	225456 <xTaskCreateStatic+0xb2>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
  22541e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  225420:	627b      	str	r3, [r7, #36]	; 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
  225422:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  225424:	6b7a      	ldr	r2, [r7, #52]	; 0x34
  225426:	631a      	str	r2, [r3, #48]	; 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
  225428:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  22542a:	2202      	movs	r2, #2
  22542c:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
  225430:	2300      	movs	r3, #0
  225432:	9303      	str	r3, [sp, #12]
  225434:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  225436:	9302      	str	r3, [sp, #8]
  225438:	f107 0314 	add.w	r3, r7, #20
  22543c:	9301      	str	r3, [sp, #4]
  22543e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225440:	9300      	str	r3, [sp, #0]
  225442:	683b      	ldr	r3, [r7, #0]
  225444:	687a      	ldr	r2, [r7, #4]
  225446:	68b9      	ldr	r1, [r7, #8]
  225448:	68f8      	ldr	r0, [r7, #12]
  22544a:	f000 f850 	bl	2254ee <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
  22544e:	6a78      	ldr	r0, [r7, #36]	; 0x24
  225450:	f000 f8d6 	bl	225600 <prvAddNewTaskToReadyList>
  225454:	e001      	b.n	22545a <xTaskCreateStatic+0xb6>
		}
		else
		{
			xReturn = NULL;
  225456:	2300      	movs	r3, #0
  225458:	617b      	str	r3, [r7, #20]
		}

		return xReturn;
  22545a:	697b      	ldr	r3, [r7, #20]
	}
  22545c:	4618      	mov	r0, r3
  22545e:	3728      	adds	r7, #40	; 0x28
  225460:	46bd      	mov	sp, r7
  225462:	bd80      	pop	{r7, pc}

00225464 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
  225464:	b580      	push	{r7, lr}
  225466:	b08c      	sub	sp, #48	; 0x30
  225468:	af04      	add	r7, sp, #16
  22546a:	60f8      	str	r0, [r7, #12]
  22546c:	60b9      	str	r1, [r7, #8]
  22546e:	603b      	str	r3, [r7, #0]
  225470:	4613      	mov	r3, r2
  225472:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
  225474:	88fb      	ldrh	r3, [r7, #6]
  225476:	009b      	lsls	r3, r3, #2
  225478:	4618      	mov	r0, r3
  22547a:	f7fe fe4f 	bl	22411c <pvPortMalloc>
  22547e:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
  225480:	697b      	ldr	r3, [r7, #20]
  225482:	2b00      	cmp	r3, #0
  225484:	d00e      	beq.n	2254a4 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
  225486:	2054      	movs	r0, #84	; 0x54
  225488:	f7fe fe48 	bl	22411c <pvPortMalloc>
  22548c:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
  22548e:	69fb      	ldr	r3, [r7, #28]
  225490:	2b00      	cmp	r3, #0
  225492:	d003      	beq.n	22549c <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
  225494:	69fb      	ldr	r3, [r7, #28]
  225496:	697a      	ldr	r2, [r7, #20]
  225498:	631a      	str	r2, [r3, #48]	; 0x30
  22549a:	e005      	b.n	2254a8 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
  22549c:	6978      	ldr	r0, [r7, #20]
  22549e:	f7fe ff05 	bl	2242ac <vPortFree>
  2254a2:	e001      	b.n	2254a8 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
  2254a4:	2300      	movs	r3, #0
  2254a6:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
  2254a8:	69fb      	ldr	r3, [r7, #28]
  2254aa:	2b00      	cmp	r3, #0
  2254ac:	d017      	beq.n	2254de <xTaskCreate+0x7a>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
  2254ae:	69fb      	ldr	r3, [r7, #28]
  2254b0:	2200      	movs	r2, #0
  2254b2:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
  2254b6:	88fa      	ldrh	r2, [r7, #6]
  2254b8:	2300      	movs	r3, #0
  2254ba:	9303      	str	r3, [sp, #12]
  2254bc:	69fb      	ldr	r3, [r7, #28]
  2254be:	9302      	str	r3, [sp, #8]
  2254c0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2254c2:	9301      	str	r3, [sp, #4]
  2254c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2254c6:	9300      	str	r3, [sp, #0]
  2254c8:	683b      	ldr	r3, [r7, #0]
  2254ca:	68b9      	ldr	r1, [r7, #8]
  2254cc:	68f8      	ldr	r0, [r7, #12]
  2254ce:	f000 f80e 	bl	2254ee <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
  2254d2:	69f8      	ldr	r0, [r7, #28]
  2254d4:	f000 f894 	bl	225600 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
  2254d8:	2301      	movs	r3, #1
  2254da:	61bb      	str	r3, [r7, #24]
  2254dc:	e002      	b.n	2254e4 <xTaskCreate+0x80>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
  2254de:	f04f 33ff 	mov.w	r3, #4294967295
  2254e2:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
  2254e4:	69bb      	ldr	r3, [r7, #24]
	}
  2254e6:	4618      	mov	r0, r3
  2254e8:	3720      	adds	r7, #32
  2254ea:	46bd      	mov	sp, r7
  2254ec:	bd80      	pop	{r7, pc}

002254ee <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
  2254ee:	b580      	push	{r7, lr}
  2254f0:	b088      	sub	sp, #32
  2254f2:	af00      	add	r7, sp, #0
  2254f4:	60f8      	str	r0, [r7, #12]
  2254f6:	60b9      	str	r1, [r7, #8]
  2254f8:	607a      	str	r2, [r7, #4]
  2254fa:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
  2254fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2254fe:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  225500:	6879      	ldr	r1, [r7, #4]
  225502:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
  225506:	440b      	add	r3, r1
  225508:	009b      	lsls	r3, r3, #2
  22550a:	4413      	add	r3, r2
  22550c:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
  22550e:	69bb      	ldr	r3, [r7, #24]
  225510:	f023 0307 	bic.w	r3, r3, #7
  225514:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
  225516:	69bb      	ldr	r3, [r7, #24]
  225518:	f003 0307 	and.w	r3, r3, #7
  22551c:	2b00      	cmp	r3, #0
  22551e:	d00b      	beq.n	225538 <prvInitialiseNewTask+0x4a>
  225520:	f04f 0350 	mov.w	r3, #80	; 0x50
  225524:	b672      	cpsid	i
  225526:	f383 8811 	msr	BASEPRI, r3
  22552a:	f3bf 8f6f 	isb	sy
  22552e:	f3bf 8f4f 	dsb	sy
  225532:	b662      	cpsie	i
  225534:	617b      	str	r3, [r7, #20]
  225536:	e7fe      	b.n	225536 <prvInitialiseNewTask+0x48>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
  225538:	68bb      	ldr	r3, [r7, #8]
  22553a:	2b00      	cmp	r3, #0
  22553c:	d01f      	beq.n	22557e <prvInitialiseNewTask+0x90>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  22553e:	2300      	movs	r3, #0
  225540:	61fb      	str	r3, [r7, #28]
  225542:	e012      	b.n	22556a <prvInitialiseNewTask+0x7c>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
  225544:	68ba      	ldr	r2, [r7, #8]
  225546:	69fb      	ldr	r3, [r7, #28]
  225548:	4413      	add	r3, r2
  22554a:	7819      	ldrb	r1, [r3, #0]
  22554c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  22554e:	69fb      	ldr	r3, [r7, #28]
  225550:	4413      	add	r3, r2
  225552:	3334      	adds	r3, #52	; 0x34
  225554:	460a      	mov	r2, r1
  225556:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
  225558:	68ba      	ldr	r2, [r7, #8]
  22555a:	69fb      	ldr	r3, [r7, #28]
  22555c:	4413      	add	r3, r2
  22555e:	781b      	ldrb	r3, [r3, #0]
  225560:	2b00      	cmp	r3, #0
  225562:	d006      	beq.n	225572 <prvInitialiseNewTask+0x84>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
  225564:	69fb      	ldr	r3, [r7, #28]
  225566:	3301      	adds	r3, #1
  225568:	61fb      	str	r3, [r7, #28]
  22556a:	69fb      	ldr	r3, [r7, #28]
  22556c:	2b0f      	cmp	r3, #15
  22556e:	d9e9      	bls.n	225544 <prvInitialiseNewTask+0x56>
  225570:	e000      	b.n	225574 <prvInitialiseNewTask+0x86>
			{
				break;
  225572:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
  225574:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225576:	2200      	movs	r2, #0
  225578:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43
  22557c:	e003      	b.n	225586 <prvInitialiseNewTask+0x98>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
  22557e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225580:	2200      	movs	r2, #0
  225582:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
  225586:	6abb      	ldr	r3, [r7, #40]	; 0x28
  225588:	2b06      	cmp	r3, #6
  22558a:	d901      	bls.n	225590 <prvInitialiseNewTask+0xa2>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
  22558c:	2306      	movs	r3, #6
  22558e:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
  225590:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225592:	6aba      	ldr	r2, [r7, #40]	; 0x28
  225594:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
  225596:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  225598:	6aba      	ldr	r2, [r7, #40]	; 0x28
  22559a:	645a      	str	r2, [r3, #68]	; 0x44
		pxNewTCB->uxMutexesHeld = 0;
  22559c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  22559e:	2200      	movs	r2, #0
  2255a0:	649a      	str	r2, [r3, #72]	; 0x48
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
  2255a2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255a4:	3304      	adds	r3, #4
  2255a6:	4618      	mov	r0, r3
  2255a8:	f7fe fafa 	bl	223ba0 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
  2255ac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255ae:	3318      	adds	r3, #24
  2255b0:	4618      	mov	r0, r3
  2255b2:	f7fe faf5 	bl	223ba0 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
  2255b6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255b8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  2255ba:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  2255bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
  2255be:	f1c3 0207 	rsb	r2, r3, #7
  2255c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255c4:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
  2255c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255c8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  2255ca:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
  2255cc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255ce:	2200      	movs	r2, #0
  2255d0:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
  2255d2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255d4:	2200      	movs	r2, #0
  2255d6:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
  2255da:	683a      	ldr	r2, [r7, #0]
  2255dc:	68f9      	ldr	r1, [r7, #12]
  2255de:	69b8      	ldr	r0, [r7, #24]
  2255e0:	f7fe fb72 	bl	223cc8 <pxPortInitialiseStack>
  2255e4:	4602      	mov	r2, r0
  2255e6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  2255e8:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
  2255ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2255ec:	2b00      	cmp	r3, #0
  2255ee:	d002      	beq.n	2255f6 <prvInitialiseNewTask+0x108>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
  2255f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  2255f2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
  2255f4:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  2255f6:	bf00      	nop
  2255f8:	3720      	adds	r7, #32
  2255fa:	46bd      	mov	sp, r7
  2255fc:	bd80      	pop	{r7, pc}
	...

00225600 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
  225600:	b580      	push	{r7, lr}
  225602:	b082      	sub	sp, #8
  225604:	af00      	add	r7, sp, #0
  225606:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
  225608:	f7fe fc66 	bl	223ed8 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
  22560c:	4b2a      	ldr	r3, [pc, #168]	; (2256b8 <prvAddNewTaskToReadyList+0xb8>)
  22560e:	681b      	ldr	r3, [r3, #0]
  225610:	3301      	adds	r3, #1
  225612:	4a29      	ldr	r2, [pc, #164]	; (2256b8 <prvAddNewTaskToReadyList+0xb8>)
  225614:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
  225616:	4b29      	ldr	r3, [pc, #164]	; (2256bc <prvAddNewTaskToReadyList+0xbc>)
  225618:	681b      	ldr	r3, [r3, #0]
  22561a:	2b00      	cmp	r3, #0
  22561c:	d109      	bne.n	225632 <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
  22561e:	4a27      	ldr	r2, [pc, #156]	; (2256bc <prvAddNewTaskToReadyList+0xbc>)
  225620:	687b      	ldr	r3, [r7, #4]
  225622:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
  225624:	4b24      	ldr	r3, [pc, #144]	; (2256b8 <prvAddNewTaskToReadyList+0xb8>)
  225626:	681b      	ldr	r3, [r3, #0]
  225628:	2b01      	cmp	r3, #1
  22562a:	d110      	bne.n	22564e <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
  22562c:	f000 fc00 	bl	225e30 <prvInitialiseTaskLists>
  225630:	e00d      	b.n	22564e <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
  225632:	4b23      	ldr	r3, [pc, #140]	; (2256c0 <prvAddNewTaskToReadyList+0xc0>)
  225634:	681b      	ldr	r3, [r3, #0]
  225636:	2b00      	cmp	r3, #0
  225638:	d109      	bne.n	22564e <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
  22563a:	4b20      	ldr	r3, [pc, #128]	; (2256bc <prvAddNewTaskToReadyList+0xbc>)
  22563c:	681b      	ldr	r3, [r3, #0]
  22563e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225640:	687b      	ldr	r3, [r7, #4]
  225642:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  225644:	429a      	cmp	r2, r3
  225646:	d802      	bhi.n	22564e <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
  225648:	4a1c      	ldr	r2, [pc, #112]	; (2256bc <prvAddNewTaskToReadyList+0xbc>)
  22564a:	687b      	ldr	r3, [r7, #4]
  22564c:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
  22564e:	4b1d      	ldr	r3, [pc, #116]	; (2256c4 <prvAddNewTaskToReadyList+0xc4>)
  225650:	681b      	ldr	r3, [r3, #0]
  225652:	3301      	adds	r3, #1
  225654:	4a1b      	ldr	r2, [pc, #108]	; (2256c4 <prvAddNewTaskToReadyList+0xc4>)
  225656:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
  225658:	687b      	ldr	r3, [r7, #4]
  22565a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22565c:	2201      	movs	r2, #1
  22565e:	409a      	lsls	r2, r3
  225660:	4b19      	ldr	r3, [pc, #100]	; (2256c8 <prvAddNewTaskToReadyList+0xc8>)
  225662:	681b      	ldr	r3, [r3, #0]
  225664:	4313      	orrs	r3, r2
  225666:	4a18      	ldr	r2, [pc, #96]	; (2256c8 <prvAddNewTaskToReadyList+0xc8>)
  225668:	6013      	str	r3, [r2, #0]
  22566a:	687b      	ldr	r3, [r7, #4]
  22566c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  22566e:	4613      	mov	r3, r2
  225670:	009b      	lsls	r3, r3, #2
  225672:	4413      	add	r3, r2
  225674:	009b      	lsls	r3, r3, #2
  225676:	4a15      	ldr	r2, [pc, #84]	; (2256cc <prvAddNewTaskToReadyList+0xcc>)
  225678:	441a      	add	r2, r3
  22567a:	687b      	ldr	r3, [r7, #4]
  22567c:	3304      	adds	r3, #4
  22567e:	4619      	mov	r1, r3
  225680:	4610      	mov	r0, r2
  225682:	f7fe fa9a 	bl	223bba <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
  225686:	f7fe fc59 	bl	223f3c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
  22568a:	4b0d      	ldr	r3, [pc, #52]	; (2256c0 <prvAddNewTaskToReadyList+0xc0>)
  22568c:	681b      	ldr	r3, [r3, #0]
  22568e:	2b00      	cmp	r3, #0
  225690:	d00e      	beq.n	2256b0 <prvAddNewTaskToReadyList+0xb0>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
  225692:	4b0a      	ldr	r3, [pc, #40]	; (2256bc <prvAddNewTaskToReadyList+0xbc>)
  225694:	681b      	ldr	r3, [r3, #0]
  225696:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225698:	687b      	ldr	r3, [r7, #4]
  22569a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22569c:	429a      	cmp	r2, r3
  22569e:	d207      	bcs.n	2256b0 <prvAddNewTaskToReadyList+0xb0>
		{
			taskYIELD_IF_USING_PREEMPTION();
  2256a0:	4b0b      	ldr	r3, [pc, #44]	; (2256d0 <prvAddNewTaskToReadyList+0xd0>)
  2256a2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  2256a6:	601a      	str	r2, [r3, #0]
  2256a8:	f3bf 8f4f 	dsb	sy
  2256ac:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
  2256b0:	bf00      	nop
  2256b2:	3708      	adds	r7, #8
  2256b4:	46bd      	mov	sp, r7
  2256b6:	bd80      	pop	{r7, pc}
  2256b8:	20014978 	.word	0x20014978
  2256bc:	20014878 	.word	0x20014878
  2256c0:	20014984 	.word	0x20014984
  2256c4:	20014994 	.word	0x20014994
  2256c8:	20014980 	.word	0x20014980
  2256cc:	2001487c 	.word	0x2001487c
  2256d0:	e000ed04 	.word	0xe000ed04

002256d4 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
  2256d4:	b580      	push	{r7, lr}
  2256d6:	b084      	sub	sp, #16
  2256d8:	af00      	add	r7, sp, #0
  2256da:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
  2256dc:	2300      	movs	r3, #0
  2256de:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
  2256e0:	687b      	ldr	r3, [r7, #4]
  2256e2:	2b00      	cmp	r3, #0
  2256e4:	d018      	beq.n	225718 <vTaskDelay+0x44>
		{
			configASSERT( uxSchedulerSuspended == 0 );
  2256e6:	4b14      	ldr	r3, [pc, #80]	; (225738 <vTaskDelay+0x64>)
  2256e8:	681b      	ldr	r3, [r3, #0]
  2256ea:	2b00      	cmp	r3, #0
  2256ec:	d00b      	beq.n	225706 <vTaskDelay+0x32>
  2256ee:	f04f 0350 	mov.w	r3, #80	; 0x50
  2256f2:	b672      	cpsid	i
  2256f4:	f383 8811 	msr	BASEPRI, r3
  2256f8:	f3bf 8f6f 	isb	sy
  2256fc:	f3bf 8f4f 	dsb	sy
  225700:	b662      	cpsie	i
  225702:	60bb      	str	r3, [r7, #8]
  225704:	e7fe      	b.n	225704 <vTaskDelay+0x30>
			vTaskSuspendAll();
  225706:	f000 f87d 	bl	225804 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
  22570a:	2100      	movs	r1, #0
  22570c:	6878      	ldr	r0, [r7, #4]
  22570e:	f000 fe31 	bl	226374 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
  225712:	f000 f885 	bl	225820 <xTaskResumeAll>
  225716:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
  225718:	68fb      	ldr	r3, [r7, #12]
  22571a:	2b00      	cmp	r3, #0
  22571c:	d107      	bne.n	22572e <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
  22571e:	4b07      	ldr	r3, [pc, #28]	; (22573c <vTaskDelay+0x68>)
  225720:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  225724:	601a      	str	r2, [r3, #0]
  225726:	f3bf 8f4f 	dsb	sy
  22572a:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  22572e:	bf00      	nop
  225730:	3710      	adds	r7, #16
  225732:	46bd      	mov	sp, r7
  225734:	bd80      	pop	{r7, pc}
  225736:	bf00      	nop
  225738:	200149a0 	.word	0x200149a0
  22573c:	e000ed04 	.word	0xe000ed04

00225740 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
  225740:	b580      	push	{r7, lr}
  225742:	b08a      	sub	sp, #40	; 0x28
  225744:	af04      	add	r7, sp, #16
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
  225746:	2300      	movs	r3, #0
  225748:	60bb      	str	r3, [r7, #8]
		StackType_t *pxIdleTaskStackBuffer = NULL;
  22574a:	2300      	movs	r3, #0
  22574c:	607b      	str	r3, [r7, #4]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
  22574e:	463a      	mov	r2, r7
  225750:	1d39      	adds	r1, r7, #4
  225752:	f107 0308 	add.w	r3, r7, #8
  225756:	4618      	mov	r0, r3
  225758:	f7f2 f9cc 	bl	217af4 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
  22575c:	6839      	ldr	r1, [r7, #0]
  22575e:	687b      	ldr	r3, [r7, #4]
  225760:	68ba      	ldr	r2, [r7, #8]
  225762:	9202      	str	r2, [sp, #8]
  225764:	9301      	str	r3, [sp, #4]
  225766:	2300      	movs	r3, #0
  225768:	9300      	str	r3, [sp, #0]
  22576a:	2300      	movs	r3, #0
  22576c:	460a      	mov	r2, r1
  22576e:	491f      	ldr	r1, [pc, #124]	; (2257ec <vTaskStartScheduler+0xac>)
  225770:	481f      	ldr	r0, [pc, #124]	; (2257f0 <vTaskStartScheduler+0xb0>)
  225772:	f7ff fe17 	bl	2253a4 <xTaskCreateStatic>
  225776:	4602      	mov	r2, r0
  225778:	4b1e      	ldr	r3, [pc, #120]	; (2257f4 <vTaskStartScheduler+0xb4>)
  22577a:	601a      	str	r2, [r3, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
  22577c:	4b1d      	ldr	r3, [pc, #116]	; (2257f4 <vTaskStartScheduler+0xb4>)
  22577e:	681b      	ldr	r3, [r3, #0]
  225780:	2b00      	cmp	r3, #0
  225782:	d002      	beq.n	22578a <vTaskStartScheduler+0x4a>
		{
			xReturn = pdPASS;
  225784:	2301      	movs	r3, #1
  225786:	617b      	str	r3, [r7, #20]
  225788:	e001      	b.n	22578e <vTaskStartScheduler+0x4e>
		}
		else
		{
			xReturn = pdFAIL;
  22578a:	2300      	movs	r3, #0
  22578c:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
  22578e:	697b      	ldr	r3, [r7, #20]
  225790:	2b01      	cmp	r3, #1
  225792:	d117      	bne.n	2257c4 <vTaskStartScheduler+0x84>
  225794:	f04f 0350 	mov.w	r3, #80	; 0x50
  225798:	b672      	cpsid	i
  22579a:	f383 8811 	msr	BASEPRI, r3
  22579e:	f3bf 8f6f 	isb	sy
  2257a2:	f3bf 8f4f 	dsb	sy
  2257a6:	b662      	cpsie	i
  2257a8:	613b      	str	r3, [r7, #16]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
  2257aa:	4b13      	ldr	r3, [pc, #76]	; (2257f8 <vTaskStartScheduler+0xb8>)
  2257ac:	f04f 32ff 	mov.w	r2, #4294967295
  2257b0:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
  2257b2:	4b12      	ldr	r3, [pc, #72]	; (2257fc <vTaskStartScheduler+0xbc>)
  2257b4:	2201      	movs	r2, #1
  2257b6:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
  2257b8:	4b11      	ldr	r3, [pc, #68]	; (225800 <vTaskStartScheduler+0xc0>)
  2257ba:	2200      	movs	r2, #0
  2257bc:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
  2257be:	f7fe fb0f 	bl	223de0 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
  2257c2:	e00f      	b.n	2257e4 <vTaskStartScheduler+0xa4>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
  2257c4:	697b      	ldr	r3, [r7, #20]
  2257c6:	f1b3 3fff 	cmp.w	r3, #4294967295
  2257ca:	d10b      	bne.n	2257e4 <vTaskStartScheduler+0xa4>
  2257cc:	f04f 0350 	mov.w	r3, #80	; 0x50
  2257d0:	b672      	cpsid	i
  2257d2:	f383 8811 	msr	BASEPRI, r3
  2257d6:	f3bf 8f6f 	isb	sy
  2257da:	f3bf 8f4f 	dsb	sy
  2257de:	b662      	cpsie	i
  2257e0:	60fb      	str	r3, [r7, #12]
  2257e2:	e7fe      	b.n	2257e2 <vTaskStartScheduler+0xa2>
}
  2257e4:	bf00      	nop
  2257e6:	3718      	adds	r7, #24
  2257e8:	46bd      	mov	sp, r7
  2257ea:	bd80      	pop	{r7, pc}
  2257ec:	00229258 	.word	0x00229258
  2257f0:	00225dfd 	.word	0x00225dfd
  2257f4:	2001499c 	.word	0x2001499c
  2257f8:	20014998 	.word	0x20014998
  2257fc:	20014984 	.word	0x20014984
  225800:	2001497c 	.word	0x2001497c

00225804 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  225804:	b480      	push	{r7}
  225806:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
  225808:	4b04      	ldr	r3, [pc, #16]	; (22581c <vTaskSuspendAll+0x18>)
  22580a:	681b      	ldr	r3, [r3, #0]
  22580c:	3301      	adds	r3, #1
  22580e:	4a03      	ldr	r2, [pc, #12]	; (22581c <vTaskSuspendAll+0x18>)
  225810:	6013      	str	r3, [r2, #0]
	portMEMORY_BARRIER();
}
  225812:	bf00      	nop
  225814:	46bd      	mov	sp, r7
  225816:	f85d 7b04 	ldr.w	r7, [sp], #4
  22581a:	4770      	bx	lr
  22581c:	200149a0 	.word	0x200149a0

00225820 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
  225820:	b580      	push	{r7, lr}
  225822:	b084      	sub	sp, #16
  225824:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
  225826:	2300      	movs	r3, #0
  225828:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
  22582a:	2300      	movs	r3, #0
  22582c:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  22582e:	4b42      	ldr	r3, [pc, #264]	; (225938 <xTaskResumeAll+0x118>)
  225830:	681b      	ldr	r3, [r3, #0]
  225832:	2b00      	cmp	r3, #0
  225834:	d10b      	bne.n	22584e <xTaskResumeAll+0x2e>
  225836:	f04f 0350 	mov.w	r3, #80	; 0x50
  22583a:	b672      	cpsid	i
  22583c:	f383 8811 	msr	BASEPRI, r3
  225840:	f3bf 8f6f 	isb	sy
  225844:	f3bf 8f4f 	dsb	sy
  225848:	b662      	cpsie	i
  22584a:	603b      	str	r3, [r7, #0]
  22584c:	e7fe      	b.n	22584c <xTaskResumeAll+0x2c>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  22584e:	f7fe fb43 	bl	223ed8 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
  225852:	4b39      	ldr	r3, [pc, #228]	; (225938 <xTaskResumeAll+0x118>)
  225854:	681b      	ldr	r3, [r3, #0]
  225856:	3b01      	subs	r3, #1
  225858:	4a37      	ldr	r2, [pc, #220]	; (225938 <xTaskResumeAll+0x118>)
  22585a:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  22585c:	4b36      	ldr	r3, [pc, #216]	; (225938 <xTaskResumeAll+0x118>)
  22585e:	681b      	ldr	r3, [r3, #0]
  225860:	2b00      	cmp	r3, #0
  225862:	d161      	bne.n	225928 <xTaskResumeAll+0x108>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
  225864:	4b35      	ldr	r3, [pc, #212]	; (22593c <xTaskResumeAll+0x11c>)
  225866:	681b      	ldr	r3, [r3, #0]
  225868:	2b00      	cmp	r3, #0
  22586a:	d05d      	beq.n	225928 <xTaskResumeAll+0x108>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  22586c:	e02e      	b.n	2258cc <xTaskResumeAll+0xac>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  22586e:	4b34      	ldr	r3, [pc, #208]	; (225940 <xTaskResumeAll+0x120>)
  225870:	68db      	ldr	r3, [r3, #12]
  225872:	68db      	ldr	r3, [r3, #12]
  225874:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  225876:	68fb      	ldr	r3, [r7, #12]
  225878:	3318      	adds	r3, #24
  22587a:	4618      	mov	r0, r3
  22587c:	f7fe f9fa 	bl	223c74 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  225880:	68fb      	ldr	r3, [r7, #12]
  225882:	3304      	adds	r3, #4
  225884:	4618      	mov	r0, r3
  225886:	f7fe f9f5 	bl	223c74 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
  22588a:	68fb      	ldr	r3, [r7, #12]
  22588c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22588e:	2201      	movs	r2, #1
  225890:	409a      	lsls	r2, r3
  225892:	4b2c      	ldr	r3, [pc, #176]	; (225944 <xTaskResumeAll+0x124>)
  225894:	681b      	ldr	r3, [r3, #0]
  225896:	4313      	orrs	r3, r2
  225898:	4a2a      	ldr	r2, [pc, #168]	; (225944 <xTaskResumeAll+0x124>)
  22589a:	6013      	str	r3, [r2, #0]
  22589c:	68fb      	ldr	r3, [r7, #12]
  22589e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2258a0:	4613      	mov	r3, r2
  2258a2:	009b      	lsls	r3, r3, #2
  2258a4:	4413      	add	r3, r2
  2258a6:	009b      	lsls	r3, r3, #2
  2258a8:	4a27      	ldr	r2, [pc, #156]	; (225948 <xTaskResumeAll+0x128>)
  2258aa:	441a      	add	r2, r3
  2258ac:	68fb      	ldr	r3, [r7, #12]
  2258ae:	3304      	adds	r3, #4
  2258b0:	4619      	mov	r1, r3
  2258b2:	4610      	mov	r0, r2
  2258b4:	f7fe f981 	bl	223bba <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  2258b8:	68fb      	ldr	r3, [r7, #12]
  2258ba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2258bc:	4b23      	ldr	r3, [pc, #140]	; (22594c <xTaskResumeAll+0x12c>)
  2258be:	681b      	ldr	r3, [r3, #0]
  2258c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2258c2:	429a      	cmp	r2, r3
  2258c4:	d302      	bcc.n	2258cc <xTaskResumeAll+0xac>
					{
						xYieldPending = pdTRUE;
  2258c6:	4b22      	ldr	r3, [pc, #136]	; (225950 <xTaskResumeAll+0x130>)
  2258c8:	2201      	movs	r2, #1
  2258ca:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
  2258cc:	4b1c      	ldr	r3, [pc, #112]	; (225940 <xTaskResumeAll+0x120>)
  2258ce:	681b      	ldr	r3, [r3, #0]
  2258d0:	2b00      	cmp	r3, #0
  2258d2:	d1cc      	bne.n	22586e <xTaskResumeAll+0x4e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
  2258d4:	68fb      	ldr	r3, [r7, #12]
  2258d6:	2b00      	cmp	r3, #0
  2258d8:	d001      	beq.n	2258de <xTaskResumeAll+0xbe>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
  2258da:	f000 fb45 	bl	225f68 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
  2258de:	4b1d      	ldr	r3, [pc, #116]	; (225954 <xTaskResumeAll+0x134>)
  2258e0:	681b      	ldr	r3, [r3, #0]
  2258e2:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
  2258e4:	687b      	ldr	r3, [r7, #4]
  2258e6:	2b00      	cmp	r3, #0
  2258e8:	d010      	beq.n	22590c <xTaskResumeAll+0xec>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
  2258ea:	f000 f859 	bl	2259a0 <xTaskIncrementTick>
  2258ee:	4603      	mov	r3, r0
  2258f0:	2b00      	cmp	r3, #0
  2258f2:	d002      	beq.n	2258fa <xTaskResumeAll+0xda>
							{
								xYieldPending = pdTRUE;
  2258f4:	4b16      	ldr	r3, [pc, #88]	; (225950 <xTaskResumeAll+0x130>)
  2258f6:	2201      	movs	r2, #1
  2258f8:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
  2258fa:	687b      	ldr	r3, [r7, #4]
  2258fc:	3b01      	subs	r3, #1
  2258fe:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
  225900:	687b      	ldr	r3, [r7, #4]
  225902:	2b00      	cmp	r3, #0
  225904:	d1f1      	bne.n	2258ea <xTaskResumeAll+0xca>

						uxPendedTicks = 0;
  225906:	4b13      	ldr	r3, [pc, #76]	; (225954 <xTaskResumeAll+0x134>)
  225908:	2200      	movs	r2, #0
  22590a:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
  22590c:	4b10      	ldr	r3, [pc, #64]	; (225950 <xTaskResumeAll+0x130>)
  22590e:	681b      	ldr	r3, [r3, #0]
  225910:	2b00      	cmp	r3, #0
  225912:	d009      	beq.n	225928 <xTaskResumeAll+0x108>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
  225914:	2301      	movs	r3, #1
  225916:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
  225918:	4b0f      	ldr	r3, [pc, #60]	; (225958 <xTaskResumeAll+0x138>)
  22591a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  22591e:	601a      	str	r2, [r3, #0]
  225920:	f3bf 8f4f 	dsb	sy
  225924:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
  225928:	f7fe fb08 	bl	223f3c <vPortExitCritical>

	return xAlreadyYielded;
  22592c:	68bb      	ldr	r3, [r7, #8]
}
  22592e:	4618      	mov	r0, r3
  225930:	3710      	adds	r7, #16
  225932:	46bd      	mov	sp, r7
  225934:	bd80      	pop	{r7, pc}
  225936:	bf00      	nop
  225938:	200149a0 	.word	0x200149a0
  22593c:	20014978 	.word	0x20014978
  225940:	20014938 	.word	0x20014938
  225944:	20014980 	.word	0x20014980
  225948:	2001487c 	.word	0x2001487c
  22594c:	20014878 	.word	0x20014878
  225950:	2001498c 	.word	0x2001498c
  225954:	20014988 	.word	0x20014988
  225958:	e000ed04 	.word	0xe000ed04

0022595c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
  22595c:	b480      	push	{r7}
  22595e:	b083      	sub	sp, #12
  225960:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
  225962:	4b05      	ldr	r3, [pc, #20]	; (225978 <xTaskGetTickCount+0x1c>)
  225964:	681b      	ldr	r3, [r3, #0]
  225966:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
  225968:	687b      	ldr	r3, [r7, #4]
}
  22596a:	4618      	mov	r0, r3
  22596c:	370c      	adds	r7, #12
  22596e:	46bd      	mov	sp, r7
  225970:	f85d 7b04 	ldr.w	r7, [sp], #4
  225974:	4770      	bx	lr
  225976:	bf00      	nop
  225978:	2001497c 	.word	0x2001497c

0022597c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
  22597c:	b580      	push	{r7, lr}
  22597e:	b082      	sub	sp, #8
  225980:	af00      	add	r7, sp, #0
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
  225982:	f7fe fb89 	bl	224098 <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
  225986:	2300      	movs	r3, #0
  225988:	607b      	str	r3, [r7, #4]
	{
		xReturn = xTickCount;
  22598a:	4b04      	ldr	r3, [pc, #16]	; (22599c <xTaskGetTickCountFromISR+0x20>)
  22598c:	681b      	ldr	r3, [r3, #0]
  22598e:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
  225990:	683b      	ldr	r3, [r7, #0]
}
  225992:	4618      	mov	r0, r3
  225994:	3708      	adds	r7, #8
  225996:	46bd      	mov	sp, r7
  225998:	bd80      	pop	{r7, pc}
  22599a:	bf00      	nop
  22599c:	2001497c 	.word	0x2001497c

002259a0 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
  2259a0:	b580      	push	{r7, lr}
  2259a2:	b086      	sub	sp, #24
  2259a4:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
  2259a6:	2300      	movs	r3, #0
  2259a8:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  2259aa:	4b53      	ldr	r3, [pc, #332]	; (225af8 <xTaskIncrementTick+0x158>)
  2259ac:	681b      	ldr	r3, [r3, #0]
  2259ae:	2b00      	cmp	r3, #0
  2259b0:	f040 808f 	bne.w	225ad2 <xTaskIncrementTick+0x132>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
  2259b4:	4b51      	ldr	r3, [pc, #324]	; (225afc <xTaskIncrementTick+0x15c>)
  2259b6:	681b      	ldr	r3, [r3, #0]
  2259b8:	3301      	adds	r3, #1
  2259ba:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
  2259bc:	4a4f      	ldr	r2, [pc, #316]	; (225afc <xTaskIncrementTick+0x15c>)
  2259be:	693b      	ldr	r3, [r7, #16]
  2259c0:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
  2259c2:	693b      	ldr	r3, [r7, #16]
  2259c4:	2b00      	cmp	r3, #0
  2259c6:	d121      	bne.n	225a0c <xTaskIncrementTick+0x6c>
		{
			taskSWITCH_DELAYED_LISTS();
  2259c8:	4b4d      	ldr	r3, [pc, #308]	; (225b00 <xTaskIncrementTick+0x160>)
  2259ca:	681b      	ldr	r3, [r3, #0]
  2259cc:	681b      	ldr	r3, [r3, #0]
  2259ce:	2b00      	cmp	r3, #0
  2259d0:	d00b      	beq.n	2259ea <xTaskIncrementTick+0x4a>
  2259d2:	f04f 0350 	mov.w	r3, #80	; 0x50
  2259d6:	b672      	cpsid	i
  2259d8:	f383 8811 	msr	BASEPRI, r3
  2259dc:	f3bf 8f6f 	isb	sy
  2259e0:	f3bf 8f4f 	dsb	sy
  2259e4:	b662      	cpsie	i
  2259e6:	603b      	str	r3, [r7, #0]
  2259e8:	e7fe      	b.n	2259e8 <xTaskIncrementTick+0x48>
  2259ea:	4b45      	ldr	r3, [pc, #276]	; (225b00 <xTaskIncrementTick+0x160>)
  2259ec:	681b      	ldr	r3, [r3, #0]
  2259ee:	60fb      	str	r3, [r7, #12]
  2259f0:	4b44      	ldr	r3, [pc, #272]	; (225b04 <xTaskIncrementTick+0x164>)
  2259f2:	681b      	ldr	r3, [r3, #0]
  2259f4:	4a42      	ldr	r2, [pc, #264]	; (225b00 <xTaskIncrementTick+0x160>)
  2259f6:	6013      	str	r3, [r2, #0]
  2259f8:	4a42      	ldr	r2, [pc, #264]	; (225b04 <xTaskIncrementTick+0x164>)
  2259fa:	68fb      	ldr	r3, [r7, #12]
  2259fc:	6013      	str	r3, [r2, #0]
  2259fe:	4b42      	ldr	r3, [pc, #264]	; (225b08 <xTaskIncrementTick+0x168>)
  225a00:	681b      	ldr	r3, [r3, #0]
  225a02:	3301      	adds	r3, #1
  225a04:	4a40      	ldr	r2, [pc, #256]	; (225b08 <xTaskIncrementTick+0x168>)
  225a06:	6013      	str	r3, [r2, #0]
  225a08:	f000 faae 	bl	225f68 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
  225a0c:	4b3f      	ldr	r3, [pc, #252]	; (225b0c <xTaskIncrementTick+0x16c>)
  225a0e:	681b      	ldr	r3, [r3, #0]
  225a10:	693a      	ldr	r2, [r7, #16]
  225a12:	429a      	cmp	r2, r3
  225a14:	d348      	bcc.n	225aa8 <xTaskIncrementTick+0x108>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  225a16:	4b3a      	ldr	r3, [pc, #232]	; (225b00 <xTaskIncrementTick+0x160>)
  225a18:	681b      	ldr	r3, [r3, #0]
  225a1a:	681b      	ldr	r3, [r3, #0]
  225a1c:	2b00      	cmp	r3, #0
  225a1e:	d104      	bne.n	225a2a <xTaskIncrementTick+0x8a>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  225a20:	4b3a      	ldr	r3, [pc, #232]	; (225b0c <xTaskIncrementTick+0x16c>)
  225a22:	f04f 32ff 	mov.w	r2, #4294967295
  225a26:	601a      	str	r2, [r3, #0]
					break;
  225a28:	e03e      	b.n	225aa8 <xTaskIncrementTick+0x108>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  225a2a:	4b35      	ldr	r3, [pc, #212]	; (225b00 <xTaskIncrementTick+0x160>)
  225a2c:	681b      	ldr	r3, [r3, #0]
  225a2e:	68db      	ldr	r3, [r3, #12]
  225a30:	68db      	ldr	r3, [r3, #12]
  225a32:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
  225a34:	68bb      	ldr	r3, [r7, #8]
  225a36:	685b      	ldr	r3, [r3, #4]
  225a38:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
  225a3a:	693a      	ldr	r2, [r7, #16]
  225a3c:	687b      	ldr	r3, [r7, #4]
  225a3e:	429a      	cmp	r2, r3
  225a40:	d203      	bcs.n	225a4a <xTaskIncrementTick+0xaa>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
  225a42:	4a32      	ldr	r2, [pc, #200]	; (225b0c <xTaskIncrementTick+0x16c>)
  225a44:	687b      	ldr	r3, [r7, #4]
  225a46:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
  225a48:	e02e      	b.n	225aa8 <xTaskIncrementTick+0x108>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  225a4a:	68bb      	ldr	r3, [r7, #8]
  225a4c:	3304      	adds	r3, #4
  225a4e:	4618      	mov	r0, r3
  225a50:	f7fe f910 	bl	223c74 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
  225a54:	68bb      	ldr	r3, [r7, #8]
  225a56:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  225a58:	2b00      	cmp	r3, #0
  225a5a:	d004      	beq.n	225a66 <xTaskIncrementTick+0xc6>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
  225a5c:	68bb      	ldr	r3, [r7, #8]
  225a5e:	3318      	adds	r3, #24
  225a60:	4618      	mov	r0, r3
  225a62:	f7fe f907 	bl	223c74 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
  225a66:	68bb      	ldr	r3, [r7, #8]
  225a68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  225a6a:	2201      	movs	r2, #1
  225a6c:	409a      	lsls	r2, r3
  225a6e:	4b28      	ldr	r3, [pc, #160]	; (225b10 <xTaskIncrementTick+0x170>)
  225a70:	681b      	ldr	r3, [r3, #0]
  225a72:	4313      	orrs	r3, r2
  225a74:	4a26      	ldr	r2, [pc, #152]	; (225b10 <xTaskIncrementTick+0x170>)
  225a76:	6013      	str	r3, [r2, #0]
  225a78:	68bb      	ldr	r3, [r7, #8]
  225a7a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225a7c:	4613      	mov	r3, r2
  225a7e:	009b      	lsls	r3, r3, #2
  225a80:	4413      	add	r3, r2
  225a82:	009b      	lsls	r3, r3, #2
  225a84:	4a23      	ldr	r2, [pc, #140]	; (225b14 <xTaskIncrementTick+0x174>)
  225a86:	441a      	add	r2, r3
  225a88:	68bb      	ldr	r3, [r7, #8]
  225a8a:	3304      	adds	r3, #4
  225a8c:	4619      	mov	r1, r3
  225a8e:	4610      	mov	r0, r2
  225a90:	f7fe f893 	bl	223bba <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  225a94:	68bb      	ldr	r3, [r7, #8]
  225a96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225a98:	4b1f      	ldr	r3, [pc, #124]	; (225b18 <xTaskIncrementTick+0x178>)
  225a9a:	681b      	ldr	r3, [r3, #0]
  225a9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  225a9e:	429a      	cmp	r2, r3
  225aa0:	d3b9      	bcc.n	225a16 <xTaskIncrementTick+0x76>
						{
							xSwitchRequired = pdTRUE;
  225aa2:	2301      	movs	r3, #1
  225aa4:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  225aa6:	e7b6      	b.n	225a16 <xTaskIncrementTick+0x76>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
  225aa8:	4b1b      	ldr	r3, [pc, #108]	; (225b18 <xTaskIncrementTick+0x178>)
  225aaa:	681b      	ldr	r3, [r3, #0]
  225aac:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225aae:	4919      	ldr	r1, [pc, #100]	; (225b14 <xTaskIncrementTick+0x174>)
  225ab0:	4613      	mov	r3, r2
  225ab2:	009b      	lsls	r3, r3, #2
  225ab4:	4413      	add	r3, r2
  225ab6:	009b      	lsls	r3, r3, #2
  225ab8:	440b      	add	r3, r1
  225aba:	681b      	ldr	r3, [r3, #0]
  225abc:	2b01      	cmp	r3, #1
  225abe:	d901      	bls.n	225ac4 <xTaskIncrementTick+0x124>
			{
				xSwitchRequired = pdTRUE;
  225ac0:	2301      	movs	r3, #1
  225ac2:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
  225ac4:	4b15      	ldr	r3, [pc, #84]	; (225b1c <xTaskIncrementTick+0x17c>)
  225ac6:	681b      	ldr	r3, [r3, #0]
  225ac8:	2b00      	cmp	r3, #0
  225aca:	d109      	bne.n	225ae0 <xTaskIncrementTick+0x140>
			{
				vApplicationTickHook();
  225acc:	f7f1 fd5c 	bl	217588 <vApplicationTickHook>
  225ad0:	e006      	b.n	225ae0 <xTaskIncrementTick+0x140>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
  225ad2:	4b12      	ldr	r3, [pc, #72]	; (225b1c <xTaskIncrementTick+0x17c>)
  225ad4:	681b      	ldr	r3, [r3, #0]
  225ad6:	3301      	adds	r3, #1
  225ad8:	4a10      	ldr	r2, [pc, #64]	; (225b1c <xTaskIncrementTick+0x17c>)
  225ada:	6013      	str	r3, [r2, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
  225adc:	f7f1 fd54 	bl	217588 <vApplicationTickHook>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
  225ae0:	4b0f      	ldr	r3, [pc, #60]	; (225b20 <xTaskIncrementTick+0x180>)
  225ae2:	681b      	ldr	r3, [r3, #0]
  225ae4:	2b00      	cmp	r3, #0
  225ae6:	d001      	beq.n	225aec <xTaskIncrementTick+0x14c>
		{
			xSwitchRequired = pdTRUE;
  225ae8:	2301      	movs	r3, #1
  225aea:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
  225aec:	697b      	ldr	r3, [r7, #20]
}
  225aee:	4618      	mov	r0, r3
  225af0:	3718      	adds	r7, #24
  225af2:	46bd      	mov	sp, r7
  225af4:	bd80      	pop	{r7, pc}
  225af6:	bf00      	nop
  225af8:	200149a0 	.word	0x200149a0
  225afc:	2001497c 	.word	0x2001497c
  225b00:	20014930 	.word	0x20014930
  225b04:	20014934 	.word	0x20014934
  225b08:	20014990 	.word	0x20014990
  225b0c:	20014998 	.word	0x20014998
  225b10:	20014980 	.word	0x20014980
  225b14:	2001487c 	.word	0x2001487c
  225b18:	20014878 	.word	0x20014878
  225b1c:	20014988 	.word	0x20014988
  225b20:	2001498c 	.word	0x2001498c

00225b24 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  225b24:	b480      	push	{r7}
  225b26:	b087      	sub	sp, #28
  225b28:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
  225b2a:	4b27      	ldr	r3, [pc, #156]	; (225bc8 <vTaskSwitchContext+0xa4>)
  225b2c:	681b      	ldr	r3, [r3, #0]
  225b2e:	2b00      	cmp	r3, #0
  225b30:	d003      	beq.n	225b3a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
  225b32:	4b26      	ldr	r3, [pc, #152]	; (225bcc <vTaskSwitchContext+0xa8>)
  225b34:	2201      	movs	r2, #1
  225b36:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
  225b38:	e040      	b.n	225bbc <vTaskSwitchContext+0x98>
		xYieldPending = pdFALSE;
  225b3a:	4b24      	ldr	r3, [pc, #144]	; (225bcc <vTaskSwitchContext+0xa8>)
  225b3c:	2200      	movs	r2, #0
  225b3e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  225b40:	4b23      	ldr	r3, [pc, #140]	; (225bd0 <vTaskSwitchContext+0xac>)
  225b42:	681b      	ldr	r3, [r3, #0]
  225b44:	60fb      	str	r3, [r7, #12]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
  225b46:	68fb      	ldr	r3, [r7, #12]
  225b48:	fab3 f383 	clz	r3, r3
  225b4c:	72fb      	strb	r3, [r7, #11]
		return ucReturn;
  225b4e:	7afb      	ldrb	r3, [r7, #11]
  225b50:	f1c3 031f 	rsb	r3, r3, #31
  225b54:	617b      	str	r3, [r7, #20]
  225b56:	491f      	ldr	r1, [pc, #124]	; (225bd4 <vTaskSwitchContext+0xb0>)
  225b58:	697a      	ldr	r2, [r7, #20]
  225b5a:	4613      	mov	r3, r2
  225b5c:	009b      	lsls	r3, r3, #2
  225b5e:	4413      	add	r3, r2
  225b60:	009b      	lsls	r3, r3, #2
  225b62:	440b      	add	r3, r1
  225b64:	681b      	ldr	r3, [r3, #0]
  225b66:	2b00      	cmp	r3, #0
  225b68:	d10b      	bne.n	225b82 <vTaskSwitchContext+0x5e>
	__asm volatile
  225b6a:	f04f 0350 	mov.w	r3, #80	; 0x50
  225b6e:	b672      	cpsid	i
  225b70:	f383 8811 	msr	BASEPRI, r3
  225b74:	f3bf 8f6f 	isb	sy
  225b78:	f3bf 8f4f 	dsb	sy
  225b7c:	b662      	cpsie	i
  225b7e:	607b      	str	r3, [r7, #4]
  225b80:	e7fe      	b.n	225b80 <vTaskSwitchContext+0x5c>
  225b82:	697a      	ldr	r2, [r7, #20]
  225b84:	4613      	mov	r3, r2
  225b86:	009b      	lsls	r3, r3, #2
  225b88:	4413      	add	r3, r2
  225b8a:	009b      	lsls	r3, r3, #2
  225b8c:	4a11      	ldr	r2, [pc, #68]	; (225bd4 <vTaskSwitchContext+0xb0>)
  225b8e:	4413      	add	r3, r2
  225b90:	613b      	str	r3, [r7, #16]
  225b92:	693b      	ldr	r3, [r7, #16]
  225b94:	685b      	ldr	r3, [r3, #4]
  225b96:	685a      	ldr	r2, [r3, #4]
  225b98:	693b      	ldr	r3, [r7, #16]
  225b9a:	605a      	str	r2, [r3, #4]
  225b9c:	693b      	ldr	r3, [r7, #16]
  225b9e:	685a      	ldr	r2, [r3, #4]
  225ba0:	693b      	ldr	r3, [r7, #16]
  225ba2:	3308      	adds	r3, #8
  225ba4:	429a      	cmp	r2, r3
  225ba6:	d104      	bne.n	225bb2 <vTaskSwitchContext+0x8e>
  225ba8:	693b      	ldr	r3, [r7, #16]
  225baa:	685b      	ldr	r3, [r3, #4]
  225bac:	685a      	ldr	r2, [r3, #4]
  225bae:	693b      	ldr	r3, [r7, #16]
  225bb0:	605a      	str	r2, [r3, #4]
  225bb2:	693b      	ldr	r3, [r7, #16]
  225bb4:	685b      	ldr	r3, [r3, #4]
  225bb6:	68db      	ldr	r3, [r3, #12]
  225bb8:	4a07      	ldr	r2, [pc, #28]	; (225bd8 <vTaskSwitchContext+0xb4>)
  225bba:	6013      	str	r3, [r2, #0]
}
  225bbc:	bf00      	nop
  225bbe:	371c      	adds	r7, #28
  225bc0:	46bd      	mov	sp, r7
  225bc2:	f85d 7b04 	ldr.w	r7, [sp], #4
  225bc6:	4770      	bx	lr
  225bc8:	200149a0 	.word	0x200149a0
  225bcc:	2001498c 	.word	0x2001498c
  225bd0:	20014980 	.word	0x20014980
  225bd4:	2001487c 	.word	0x2001487c
  225bd8:	20014878 	.word	0x20014878

00225bdc <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
  225bdc:	b580      	push	{r7, lr}
  225bde:	b084      	sub	sp, #16
  225be0:	af00      	add	r7, sp, #0
  225be2:	6078      	str	r0, [r7, #4]
  225be4:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
  225be6:	687b      	ldr	r3, [r7, #4]
  225be8:	2b00      	cmp	r3, #0
  225bea:	d10b      	bne.n	225c04 <vTaskPlaceOnEventList+0x28>
  225bec:	f04f 0350 	mov.w	r3, #80	; 0x50
  225bf0:	b672      	cpsid	i
  225bf2:	f383 8811 	msr	BASEPRI, r3
  225bf6:	f3bf 8f6f 	isb	sy
  225bfa:	f3bf 8f4f 	dsb	sy
  225bfe:	b662      	cpsie	i
  225c00:	60fb      	str	r3, [r7, #12]
  225c02:	e7fe      	b.n	225c02 <vTaskPlaceOnEventList+0x26>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
  225c04:	4b07      	ldr	r3, [pc, #28]	; (225c24 <vTaskPlaceOnEventList+0x48>)
  225c06:	681b      	ldr	r3, [r3, #0]
  225c08:	3318      	adds	r3, #24
  225c0a:	4619      	mov	r1, r3
  225c0c:	6878      	ldr	r0, [r7, #4]
  225c0e:	f7fd fff8 	bl	223c02 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
  225c12:	2101      	movs	r1, #1
  225c14:	6838      	ldr	r0, [r7, #0]
  225c16:	f000 fbad 	bl	226374 <prvAddCurrentTaskToDelayedList>
}
  225c1a:	bf00      	nop
  225c1c:	3710      	adds	r7, #16
  225c1e:	46bd      	mov	sp, r7
  225c20:	bd80      	pop	{r7, pc}
  225c22:	bf00      	nop
  225c24:	20014878 	.word	0x20014878

00225c28 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
  225c28:	b580      	push	{r7, lr}
  225c2a:	b086      	sub	sp, #24
  225c2c:	af00      	add	r7, sp, #0
  225c2e:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  225c30:	687b      	ldr	r3, [r7, #4]
  225c32:	68db      	ldr	r3, [r3, #12]
  225c34:	68db      	ldr	r3, [r3, #12]
  225c36:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
  225c38:	693b      	ldr	r3, [r7, #16]
  225c3a:	2b00      	cmp	r3, #0
  225c3c:	d10b      	bne.n	225c56 <xTaskRemoveFromEventList+0x2e>
  225c3e:	f04f 0350 	mov.w	r3, #80	; 0x50
  225c42:	b672      	cpsid	i
  225c44:	f383 8811 	msr	BASEPRI, r3
  225c48:	f3bf 8f6f 	isb	sy
  225c4c:	f3bf 8f4f 	dsb	sy
  225c50:	b662      	cpsie	i
  225c52:	60fb      	str	r3, [r7, #12]
  225c54:	e7fe      	b.n	225c54 <xTaskRemoveFromEventList+0x2c>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  225c56:	693b      	ldr	r3, [r7, #16]
  225c58:	3318      	adds	r3, #24
  225c5a:	4618      	mov	r0, r3
  225c5c:	f7fe f80a 	bl	223c74 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  225c60:	4b1d      	ldr	r3, [pc, #116]	; (225cd8 <xTaskRemoveFromEventList+0xb0>)
  225c62:	681b      	ldr	r3, [r3, #0]
  225c64:	2b00      	cmp	r3, #0
  225c66:	d11c      	bne.n	225ca2 <xTaskRemoveFromEventList+0x7a>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
  225c68:	693b      	ldr	r3, [r7, #16]
  225c6a:	3304      	adds	r3, #4
  225c6c:	4618      	mov	r0, r3
  225c6e:	f7fe f801 	bl	223c74 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
  225c72:	693b      	ldr	r3, [r7, #16]
  225c74:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  225c76:	2201      	movs	r2, #1
  225c78:	409a      	lsls	r2, r3
  225c7a:	4b18      	ldr	r3, [pc, #96]	; (225cdc <xTaskRemoveFromEventList+0xb4>)
  225c7c:	681b      	ldr	r3, [r3, #0]
  225c7e:	4313      	orrs	r3, r2
  225c80:	4a16      	ldr	r2, [pc, #88]	; (225cdc <xTaskRemoveFromEventList+0xb4>)
  225c82:	6013      	str	r3, [r2, #0]
  225c84:	693b      	ldr	r3, [r7, #16]
  225c86:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225c88:	4613      	mov	r3, r2
  225c8a:	009b      	lsls	r3, r3, #2
  225c8c:	4413      	add	r3, r2
  225c8e:	009b      	lsls	r3, r3, #2
  225c90:	4a13      	ldr	r2, [pc, #76]	; (225ce0 <xTaskRemoveFromEventList+0xb8>)
  225c92:	441a      	add	r2, r3
  225c94:	693b      	ldr	r3, [r7, #16]
  225c96:	3304      	adds	r3, #4
  225c98:	4619      	mov	r1, r3
  225c9a:	4610      	mov	r0, r2
  225c9c:	f7fd ff8d 	bl	223bba <vListInsertEnd>
  225ca0:	e005      	b.n	225cae <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  225ca2:	693b      	ldr	r3, [r7, #16]
  225ca4:	3318      	adds	r3, #24
  225ca6:	4619      	mov	r1, r3
  225ca8:	480e      	ldr	r0, [pc, #56]	; (225ce4 <xTaskRemoveFromEventList+0xbc>)
  225caa:	f7fd ff86 	bl	223bba <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
  225cae:	693b      	ldr	r3, [r7, #16]
  225cb0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  225cb2:	4b0d      	ldr	r3, [pc, #52]	; (225ce8 <xTaskRemoveFromEventList+0xc0>)
  225cb4:	681b      	ldr	r3, [r3, #0]
  225cb6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  225cb8:	429a      	cmp	r2, r3
  225cba:	d905      	bls.n	225cc8 <xTaskRemoveFromEventList+0xa0>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
  225cbc:	2301      	movs	r3, #1
  225cbe:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
  225cc0:	4b0a      	ldr	r3, [pc, #40]	; (225cec <xTaskRemoveFromEventList+0xc4>)
  225cc2:	2201      	movs	r2, #1
  225cc4:	601a      	str	r2, [r3, #0]
  225cc6:	e001      	b.n	225ccc <xTaskRemoveFromEventList+0xa4>
	}
	else
	{
		xReturn = pdFALSE;
  225cc8:	2300      	movs	r3, #0
  225cca:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
  225ccc:	697b      	ldr	r3, [r7, #20]
}
  225cce:	4618      	mov	r0, r3
  225cd0:	3718      	adds	r7, #24
  225cd2:	46bd      	mov	sp, r7
  225cd4:	bd80      	pop	{r7, pc}
  225cd6:	bf00      	nop
  225cd8:	200149a0 	.word	0x200149a0
  225cdc:	20014980 	.word	0x20014980
  225ce0:	2001487c 	.word	0x2001487c
  225ce4:	20014938 	.word	0x20014938
  225ce8:	20014878 	.word	0x20014878
  225cec:	2001498c 	.word	0x2001498c

00225cf0 <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
  225cf0:	b480      	push	{r7}
  225cf2:	b083      	sub	sp, #12
  225cf4:	af00      	add	r7, sp, #0
  225cf6:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  225cf8:	4b06      	ldr	r3, [pc, #24]	; (225d14 <vTaskInternalSetTimeOutState+0x24>)
  225cfa:	681a      	ldr	r2, [r3, #0]
  225cfc:	687b      	ldr	r3, [r7, #4]
  225cfe:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  225d00:	4b05      	ldr	r3, [pc, #20]	; (225d18 <vTaskInternalSetTimeOutState+0x28>)
  225d02:	681a      	ldr	r2, [r3, #0]
  225d04:	687b      	ldr	r3, [r7, #4]
  225d06:	605a      	str	r2, [r3, #4]
}
  225d08:	bf00      	nop
  225d0a:	370c      	adds	r7, #12
  225d0c:	46bd      	mov	sp, r7
  225d0e:	f85d 7b04 	ldr.w	r7, [sp], #4
  225d12:	4770      	bx	lr
  225d14:	20014990 	.word	0x20014990
  225d18:	2001497c 	.word	0x2001497c

00225d1c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
  225d1c:	b580      	push	{r7, lr}
  225d1e:	b088      	sub	sp, #32
  225d20:	af00      	add	r7, sp, #0
  225d22:	6078      	str	r0, [r7, #4]
  225d24:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
  225d26:	687b      	ldr	r3, [r7, #4]
  225d28:	2b00      	cmp	r3, #0
  225d2a:	d10b      	bne.n	225d44 <xTaskCheckForTimeOut+0x28>
  225d2c:	f04f 0350 	mov.w	r3, #80	; 0x50
  225d30:	b672      	cpsid	i
  225d32:	f383 8811 	msr	BASEPRI, r3
  225d36:	f3bf 8f6f 	isb	sy
  225d3a:	f3bf 8f4f 	dsb	sy
  225d3e:	b662      	cpsie	i
  225d40:	613b      	str	r3, [r7, #16]
  225d42:	e7fe      	b.n	225d42 <xTaskCheckForTimeOut+0x26>
	configASSERT( pxTicksToWait );
  225d44:	683b      	ldr	r3, [r7, #0]
  225d46:	2b00      	cmp	r3, #0
  225d48:	d10b      	bne.n	225d62 <xTaskCheckForTimeOut+0x46>
  225d4a:	f04f 0350 	mov.w	r3, #80	; 0x50
  225d4e:	b672      	cpsid	i
  225d50:	f383 8811 	msr	BASEPRI, r3
  225d54:	f3bf 8f6f 	isb	sy
  225d58:	f3bf 8f4f 	dsb	sy
  225d5c:	b662      	cpsie	i
  225d5e:	60fb      	str	r3, [r7, #12]
  225d60:	e7fe      	b.n	225d60 <xTaskCheckForTimeOut+0x44>

	taskENTER_CRITICAL();
  225d62:	f7fe f8b9 	bl	223ed8 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
  225d66:	4b1d      	ldr	r3, [pc, #116]	; (225ddc <xTaskCheckForTimeOut+0xc0>)
  225d68:	681b      	ldr	r3, [r3, #0]
  225d6a:	61bb      	str	r3, [r7, #24]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
  225d6c:	687b      	ldr	r3, [r7, #4]
  225d6e:	685b      	ldr	r3, [r3, #4]
  225d70:	69ba      	ldr	r2, [r7, #24]
  225d72:	1ad3      	subs	r3, r2, r3
  225d74:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
  225d76:	683b      	ldr	r3, [r7, #0]
  225d78:	681b      	ldr	r3, [r3, #0]
  225d7a:	f1b3 3fff 	cmp.w	r3, #4294967295
  225d7e:	d102      	bne.n	225d86 <xTaskCheckForTimeOut+0x6a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
  225d80:	2300      	movs	r3, #0
  225d82:	61fb      	str	r3, [r7, #28]
  225d84:	e023      	b.n	225dce <xTaskCheckForTimeOut+0xb2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
  225d86:	687b      	ldr	r3, [r7, #4]
  225d88:	681a      	ldr	r2, [r3, #0]
  225d8a:	4b15      	ldr	r3, [pc, #84]	; (225de0 <xTaskCheckForTimeOut+0xc4>)
  225d8c:	681b      	ldr	r3, [r3, #0]
  225d8e:	429a      	cmp	r2, r3
  225d90:	d007      	beq.n	225da2 <xTaskCheckForTimeOut+0x86>
  225d92:	687b      	ldr	r3, [r7, #4]
  225d94:	685a      	ldr	r2, [r3, #4]
  225d96:	69bb      	ldr	r3, [r7, #24]
  225d98:	429a      	cmp	r2, r3
  225d9a:	d802      	bhi.n	225da2 <xTaskCheckForTimeOut+0x86>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
  225d9c:	2301      	movs	r3, #1
  225d9e:	61fb      	str	r3, [r7, #28]
  225da0:	e015      	b.n	225dce <xTaskCheckForTimeOut+0xb2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
  225da2:	683b      	ldr	r3, [r7, #0]
  225da4:	681a      	ldr	r2, [r3, #0]
  225da6:	697b      	ldr	r3, [r7, #20]
  225da8:	429a      	cmp	r2, r3
  225daa:	d90b      	bls.n	225dc4 <xTaskCheckForTimeOut+0xa8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
  225dac:	683b      	ldr	r3, [r7, #0]
  225dae:	681a      	ldr	r2, [r3, #0]
  225db0:	697b      	ldr	r3, [r7, #20]
  225db2:	1ad2      	subs	r2, r2, r3
  225db4:	683b      	ldr	r3, [r7, #0]
  225db6:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
  225db8:	6878      	ldr	r0, [r7, #4]
  225dba:	f7ff ff99 	bl	225cf0 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
  225dbe:	2300      	movs	r3, #0
  225dc0:	61fb      	str	r3, [r7, #28]
  225dc2:	e004      	b.n	225dce <xTaskCheckForTimeOut+0xb2>
		}
		else
		{
			*pxTicksToWait = 0;
  225dc4:	683b      	ldr	r3, [r7, #0]
  225dc6:	2200      	movs	r2, #0
  225dc8:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
  225dca:	2301      	movs	r3, #1
  225dcc:	61fb      	str	r3, [r7, #28]
		}
	}
	taskEXIT_CRITICAL();
  225dce:	f7fe f8b5 	bl	223f3c <vPortExitCritical>

	return xReturn;
  225dd2:	69fb      	ldr	r3, [r7, #28]
}
  225dd4:	4618      	mov	r0, r3
  225dd6:	3720      	adds	r7, #32
  225dd8:	46bd      	mov	sp, r7
  225dda:	bd80      	pop	{r7, pc}
  225ddc:	2001497c 	.word	0x2001497c
  225de0:	20014990 	.word	0x20014990

00225de4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
  225de4:	b480      	push	{r7}
  225de6:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
  225de8:	4b03      	ldr	r3, [pc, #12]	; (225df8 <vTaskMissedYield+0x14>)
  225dea:	2201      	movs	r2, #1
  225dec:	601a      	str	r2, [r3, #0]
}
  225dee:	bf00      	nop
  225df0:	46bd      	mov	sp, r7
  225df2:	f85d 7b04 	ldr.w	r7, [sp], #4
  225df6:	4770      	bx	lr
  225df8:	2001498c 	.word	0x2001498c

00225dfc <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
  225dfc:	b580      	push	{r7, lr}
  225dfe:	b082      	sub	sp, #8
  225e00:	af00      	add	r7, sp, #0
  225e02:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
  225e04:	f000 f854 	bl	225eb0 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
  225e08:	4b07      	ldr	r3, [pc, #28]	; (225e28 <prvIdleTask+0x2c>)
  225e0a:	681b      	ldr	r3, [r3, #0]
  225e0c:	2b01      	cmp	r3, #1
  225e0e:	d907      	bls.n	225e20 <prvIdleTask+0x24>
			{
				taskYIELD();
  225e10:	4b06      	ldr	r3, [pc, #24]	; (225e2c <prvIdleTask+0x30>)
  225e12:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  225e16:	601a      	str	r2, [r3, #0]
  225e18:	f3bf 8f4f 	dsb	sy
  225e1c:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
  225e20:	f7f1 fba2 	bl	217568 <vApplicationIdleHook>
		prvCheckTasksWaitingTermination();
  225e24:	e7ee      	b.n	225e04 <prvIdleTask+0x8>
  225e26:	bf00      	nop
  225e28:	2001487c 	.word	0x2001487c
  225e2c:	e000ed04 	.word	0xe000ed04

00225e30 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
  225e30:	b580      	push	{r7, lr}
  225e32:	b082      	sub	sp, #8
  225e34:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  225e36:	2300      	movs	r3, #0
  225e38:	607b      	str	r3, [r7, #4]
  225e3a:	e00c      	b.n	225e56 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
  225e3c:	687a      	ldr	r2, [r7, #4]
  225e3e:	4613      	mov	r3, r2
  225e40:	009b      	lsls	r3, r3, #2
  225e42:	4413      	add	r3, r2
  225e44:	009b      	lsls	r3, r3, #2
  225e46:	4a12      	ldr	r2, [pc, #72]	; (225e90 <prvInitialiseTaskLists+0x60>)
  225e48:	4413      	add	r3, r2
  225e4a:	4618      	mov	r0, r3
  225e4c:	f7fd fe88 	bl	223b60 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
  225e50:	687b      	ldr	r3, [r7, #4]
  225e52:	3301      	adds	r3, #1
  225e54:	607b      	str	r3, [r7, #4]
  225e56:	687b      	ldr	r3, [r7, #4]
  225e58:	2b06      	cmp	r3, #6
  225e5a:	d9ef      	bls.n	225e3c <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
  225e5c:	480d      	ldr	r0, [pc, #52]	; (225e94 <prvInitialiseTaskLists+0x64>)
  225e5e:	f7fd fe7f 	bl	223b60 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
  225e62:	480d      	ldr	r0, [pc, #52]	; (225e98 <prvInitialiseTaskLists+0x68>)
  225e64:	f7fd fe7c 	bl	223b60 <vListInitialise>
	vListInitialise( &xPendingReadyList );
  225e68:	480c      	ldr	r0, [pc, #48]	; (225e9c <prvInitialiseTaskLists+0x6c>)
  225e6a:	f7fd fe79 	bl	223b60 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
  225e6e:	480c      	ldr	r0, [pc, #48]	; (225ea0 <prvInitialiseTaskLists+0x70>)
  225e70:	f7fd fe76 	bl	223b60 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
  225e74:	480b      	ldr	r0, [pc, #44]	; (225ea4 <prvInitialiseTaskLists+0x74>)
  225e76:	f7fd fe73 	bl	223b60 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
  225e7a:	4b0b      	ldr	r3, [pc, #44]	; (225ea8 <prvInitialiseTaskLists+0x78>)
  225e7c:	4a05      	ldr	r2, [pc, #20]	; (225e94 <prvInitialiseTaskLists+0x64>)
  225e7e:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
  225e80:	4b0a      	ldr	r3, [pc, #40]	; (225eac <prvInitialiseTaskLists+0x7c>)
  225e82:	4a05      	ldr	r2, [pc, #20]	; (225e98 <prvInitialiseTaskLists+0x68>)
  225e84:	601a      	str	r2, [r3, #0]
}
  225e86:	bf00      	nop
  225e88:	3708      	adds	r7, #8
  225e8a:	46bd      	mov	sp, r7
  225e8c:	bd80      	pop	{r7, pc}
  225e8e:	bf00      	nop
  225e90:	2001487c 	.word	0x2001487c
  225e94:	20014908 	.word	0x20014908
  225e98:	2001491c 	.word	0x2001491c
  225e9c:	20014938 	.word	0x20014938
  225ea0:	2001494c 	.word	0x2001494c
  225ea4:	20014964 	.word	0x20014964
  225ea8:	20014930 	.word	0x20014930
  225eac:	20014934 	.word	0x20014934

00225eb0 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
  225eb0:	b580      	push	{r7, lr}
  225eb2:	b082      	sub	sp, #8
  225eb4:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  225eb6:	e019      	b.n	225eec <prvCheckTasksWaitingTermination+0x3c>
		{
			taskENTER_CRITICAL();
  225eb8:	f7fe f80e 	bl	223ed8 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  225ebc:	4b0f      	ldr	r3, [pc, #60]	; (225efc <prvCheckTasksWaitingTermination+0x4c>)
  225ebe:	68db      	ldr	r3, [r3, #12]
  225ec0:	68db      	ldr	r3, [r3, #12]
  225ec2:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
  225ec4:	687b      	ldr	r3, [r7, #4]
  225ec6:	3304      	adds	r3, #4
  225ec8:	4618      	mov	r0, r3
  225eca:	f7fd fed3 	bl	223c74 <uxListRemove>
				--uxCurrentNumberOfTasks;
  225ece:	4b0c      	ldr	r3, [pc, #48]	; (225f00 <prvCheckTasksWaitingTermination+0x50>)
  225ed0:	681b      	ldr	r3, [r3, #0]
  225ed2:	3b01      	subs	r3, #1
  225ed4:	4a0a      	ldr	r2, [pc, #40]	; (225f00 <prvCheckTasksWaitingTermination+0x50>)
  225ed6:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
  225ed8:	4b0a      	ldr	r3, [pc, #40]	; (225f04 <prvCheckTasksWaitingTermination+0x54>)
  225eda:	681b      	ldr	r3, [r3, #0]
  225edc:	3b01      	subs	r3, #1
  225ede:	4a09      	ldr	r2, [pc, #36]	; (225f04 <prvCheckTasksWaitingTermination+0x54>)
  225ee0:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
  225ee2:	f7fe f82b 	bl	223f3c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
  225ee6:	6878      	ldr	r0, [r7, #4]
  225ee8:	f000 f80e 	bl	225f08 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
  225eec:	4b05      	ldr	r3, [pc, #20]	; (225f04 <prvCheckTasksWaitingTermination+0x54>)
  225eee:	681b      	ldr	r3, [r3, #0]
  225ef0:	2b00      	cmp	r3, #0
  225ef2:	d1e1      	bne.n	225eb8 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
  225ef4:	bf00      	nop
  225ef6:	3708      	adds	r7, #8
  225ef8:	46bd      	mov	sp, r7
  225efa:	bd80      	pop	{r7, pc}
  225efc:	2001494c 	.word	0x2001494c
  225f00:	20014978 	.word	0x20014978
  225f04:	20014960 	.word	0x20014960

00225f08 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
  225f08:	b580      	push	{r7, lr}
  225f0a:	b084      	sub	sp, #16
  225f0c:	af00      	add	r7, sp, #0
  225f0e:	6078      	str	r0, [r7, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
  225f10:	687b      	ldr	r3, [r7, #4]
  225f12:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
  225f16:	2b00      	cmp	r3, #0
  225f18:	d108      	bne.n	225f2c <prvDeleteTCB+0x24>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
  225f1a:	687b      	ldr	r3, [r7, #4]
  225f1c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  225f1e:	4618      	mov	r0, r3
  225f20:	f7fe f9c4 	bl	2242ac <vPortFree>
				vPortFree( pxTCB );
  225f24:	6878      	ldr	r0, [r7, #4]
  225f26:	f7fe f9c1 	bl	2242ac <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
  225f2a:	e019      	b.n	225f60 <prvDeleteTCB+0x58>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
  225f2c:	687b      	ldr	r3, [r7, #4]
  225f2e:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
  225f32:	2b01      	cmp	r3, #1
  225f34:	d103      	bne.n	225f3e <prvDeleteTCB+0x36>
				vPortFree( pxTCB );
  225f36:	6878      	ldr	r0, [r7, #4]
  225f38:	f7fe f9b8 	bl	2242ac <vPortFree>
	}
  225f3c:	e010      	b.n	225f60 <prvDeleteTCB+0x58>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
  225f3e:	687b      	ldr	r3, [r7, #4]
  225f40:	f893 3051 	ldrb.w	r3, [r3, #81]	; 0x51
  225f44:	2b02      	cmp	r3, #2
  225f46:	d00b      	beq.n	225f60 <prvDeleteTCB+0x58>
  225f48:	f04f 0350 	mov.w	r3, #80	; 0x50
  225f4c:	b672      	cpsid	i
  225f4e:	f383 8811 	msr	BASEPRI, r3
  225f52:	f3bf 8f6f 	isb	sy
  225f56:	f3bf 8f4f 	dsb	sy
  225f5a:	b662      	cpsie	i
  225f5c:	60fb      	str	r3, [r7, #12]
  225f5e:	e7fe      	b.n	225f5e <prvDeleteTCB+0x56>
	}
  225f60:	bf00      	nop
  225f62:	3710      	adds	r7, #16
  225f64:	46bd      	mov	sp, r7
  225f66:	bd80      	pop	{r7, pc}

00225f68 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
  225f68:	b480      	push	{r7}
  225f6a:	b083      	sub	sp, #12
  225f6c:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  225f6e:	4b0c      	ldr	r3, [pc, #48]	; (225fa0 <prvResetNextTaskUnblockTime+0x38>)
  225f70:	681b      	ldr	r3, [r3, #0]
  225f72:	681b      	ldr	r3, [r3, #0]
  225f74:	2b00      	cmp	r3, #0
  225f76:	d104      	bne.n	225f82 <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
  225f78:	4b0a      	ldr	r3, [pc, #40]	; (225fa4 <prvResetNextTaskUnblockTime+0x3c>)
  225f7a:	f04f 32ff 	mov.w	r2, #4294967295
  225f7e:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
  225f80:	e008      	b.n	225f94 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
  225f82:	4b07      	ldr	r3, [pc, #28]	; (225fa0 <prvResetNextTaskUnblockTime+0x38>)
  225f84:	681b      	ldr	r3, [r3, #0]
  225f86:	68db      	ldr	r3, [r3, #12]
  225f88:	68db      	ldr	r3, [r3, #12]
  225f8a:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
  225f8c:	687b      	ldr	r3, [r7, #4]
  225f8e:	685b      	ldr	r3, [r3, #4]
  225f90:	4a04      	ldr	r2, [pc, #16]	; (225fa4 <prvResetNextTaskUnblockTime+0x3c>)
  225f92:	6013      	str	r3, [r2, #0]
}
  225f94:	bf00      	nop
  225f96:	370c      	adds	r7, #12
  225f98:	46bd      	mov	sp, r7
  225f9a:	f85d 7b04 	ldr.w	r7, [sp], #4
  225f9e:	4770      	bx	lr
  225fa0:	20014930 	.word	0x20014930
  225fa4:	20014998 	.word	0x20014998

00225fa8 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
  225fa8:	b480      	push	{r7}
  225faa:	b083      	sub	sp, #12
  225fac:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  225fae:	4b05      	ldr	r3, [pc, #20]	; (225fc4 <xTaskGetCurrentTaskHandle+0x1c>)
  225fb0:	681b      	ldr	r3, [r3, #0]
  225fb2:	607b      	str	r3, [r7, #4]

		return xReturn;
  225fb4:	687b      	ldr	r3, [r7, #4]
	}
  225fb6:	4618      	mov	r0, r3
  225fb8:	370c      	adds	r7, #12
  225fba:	46bd      	mov	sp, r7
  225fbc:	f85d 7b04 	ldr.w	r7, [sp], #4
  225fc0:	4770      	bx	lr
  225fc2:	bf00      	nop
  225fc4:	20014878 	.word	0x20014878

00225fc8 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
  225fc8:	b480      	push	{r7}
  225fca:	b083      	sub	sp, #12
  225fcc:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
  225fce:	4b0b      	ldr	r3, [pc, #44]	; (225ffc <xTaskGetSchedulerState+0x34>)
  225fd0:	681b      	ldr	r3, [r3, #0]
  225fd2:	2b00      	cmp	r3, #0
  225fd4:	d102      	bne.n	225fdc <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
  225fd6:	2301      	movs	r3, #1
  225fd8:	607b      	str	r3, [r7, #4]
  225fda:	e008      	b.n	225fee <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
  225fdc:	4b08      	ldr	r3, [pc, #32]	; (226000 <xTaskGetSchedulerState+0x38>)
  225fde:	681b      	ldr	r3, [r3, #0]
  225fe0:	2b00      	cmp	r3, #0
  225fe2:	d102      	bne.n	225fea <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
  225fe4:	2302      	movs	r3, #2
  225fe6:	607b      	str	r3, [r7, #4]
  225fe8:	e001      	b.n	225fee <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
  225fea:	2300      	movs	r3, #0
  225fec:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
  225fee:	687b      	ldr	r3, [r7, #4]
	}
  225ff0:	4618      	mov	r0, r3
  225ff2:	370c      	adds	r7, #12
  225ff4:	46bd      	mov	sp, r7
  225ff6:	f85d 7b04 	ldr.w	r7, [sp], #4
  225ffa:	4770      	bx	lr
  225ffc:	20014984 	.word	0x20014984
  226000:	200149a0 	.word	0x200149a0

00226004 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
  226004:	b580      	push	{r7, lr}
  226006:	b084      	sub	sp, #16
  226008:	af00      	add	r7, sp, #0
  22600a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
  22600c:	687b      	ldr	r3, [r7, #4]
  22600e:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
  226010:	2300      	movs	r3, #0
  226012:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
  226014:	687b      	ldr	r3, [r7, #4]
  226016:	2b00      	cmp	r3, #0
  226018:	d069      	beq.n	2260ee <xTaskPriorityInherit+0xea>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
  22601a:	68bb      	ldr	r3, [r7, #8]
  22601c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  22601e:	4b36      	ldr	r3, [pc, #216]	; (2260f8 <xTaskPriorityInherit+0xf4>)
  226020:	681b      	ldr	r3, [r3, #0]
  226022:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  226024:	429a      	cmp	r2, r3
  226026:	d259      	bcs.n	2260dc <xTaskPriorityInherit+0xd8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  226028:	68bb      	ldr	r3, [r7, #8]
  22602a:	699b      	ldr	r3, [r3, #24]
  22602c:	2b00      	cmp	r3, #0
  22602e:	db06      	blt.n	22603e <xTaskPriorityInherit+0x3a>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  226030:	4b31      	ldr	r3, [pc, #196]	; (2260f8 <xTaskPriorityInherit+0xf4>)
  226032:	681b      	ldr	r3, [r3, #0]
  226034:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  226036:	f1c3 0207 	rsb	r2, r3, #7
  22603a:	68bb      	ldr	r3, [r7, #8]
  22603c:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
  22603e:	68bb      	ldr	r3, [r7, #8]
  226040:	6959      	ldr	r1, [r3, #20]
  226042:	68bb      	ldr	r3, [r7, #8]
  226044:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  226046:	4613      	mov	r3, r2
  226048:	009b      	lsls	r3, r3, #2
  22604a:	4413      	add	r3, r2
  22604c:	009b      	lsls	r3, r3, #2
  22604e:	4a2b      	ldr	r2, [pc, #172]	; (2260fc <xTaskPriorityInherit+0xf8>)
  226050:	4413      	add	r3, r2
  226052:	4299      	cmp	r1, r3
  226054:	d13a      	bne.n	2260cc <xTaskPriorityInherit+0xc8>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  226056:	68bb      	ldr	r3, [r7, #8]
  226058:	3304      	adds	r3, #4
  22605a:	4618      	mov	r0, r3
  22605c:	f7fd fe0a 	bl	223c74 <uxListRemove>
  226060:	4603      	mov	r3, r0
  226062:	2b00      	cmp	r3, #0
  226064:	d115      	bne.n	226092 <xTaskPriorityInherit+0x8e>
					{
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
  226066:	68bb      	ldr	r3, [r7, #8]
  226068:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  22606a:	4924      	ldr	r1, [pc, #144]	; (2260fc <xTaskPriorityInherit+0xf8>)
  22606c:	4613      	mov	r3, r2
  22606e:	009b      	lsls	r3, r3, #2
  226070:	4413      	add	r3, r2
  226072:	009b      	lsls	r3, r3, #2
  226074:	440b      	add	r3, r1
  226076:	681b      	ldr	r3, [r3, #0]
  226078:	2b00      	cmp	r3, #0
  22607a:	d10a      	bne.n	226092 <xTaskPriorityInherit+0x8e>
  22607c:	68bb      	ldr	r3, [r7, #8]
  22607e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  226080:	2201      	movs	r2, #1
  226082:	fa02 f303 	lsl.w	r3, r2, r3
  226086:	43da      	mvns	r2, r3
  226088:	4b1d      	ldr	r3, [pc, #116]	; (226100 <xTaskPriorityInherit+0xfc>)
  22608a:	681b      	ldr	r3, [r3, #0]
  22608c:	4013      	ands	r3, r2
  22608e:	4a1c      	ldr	r2, [pc, #112]	; (226100 <xTaskPriorityInherit+0xfc>)
  226090:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  226092:	4b19      	ldr	r3, [pc, #100]	; (2260f8 <xTaskPriorityInherit+0xf4>)
  226094:	681b      	ldr	r3, [r3, #0]
  226096:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  226098:	68bb      	ldr	r3, [r7, #8]
  22609a:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
  22609c:	68bb      	ldr	r3, [r7, #8]
  22609e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2260a0:	2201      	movs	r2, #1
  2260a2:	409a      	lsls	r2, r3
  2260a4:	4b16      	ldr	r3, [pc, #88]	; (226100 <xTaskPriorityInherit+0xfc>)
  2260a6:	681b      	ldr	r3, [r3, #0]
  2260a8:	4313      	orrs	r3, r2
  2260aa:	4a15      	ldr	r2, [pc, #84]	; (226100 <xTaskPriorityInherit+0xfc>)
  2260ac:	6013      	str	r3, [r2, #0]
  2260ae:	68bb      	ldr	r3, [r7, #8]
  2260b0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2260b2:	4613      	mov	r3, r2
  2260b4:	009b      	lsls	r3, r3, #2
  2260b6:	4413      	add	r3, r2
  2260b8:	009b      	lsls	r3, r3, #2
  2260ba:	4a10      	ldr	r2, [pc, #64]	; (2260fc <xTaskPriorityInherit+0xf8>)
  2260bc:	441a      	add	r2, r3
  2260be:	68bb      	ldr	r3, [r7, #8]
  2260c0:	3304      	adds	r3, #4
  2260c2:	4619      	mov	r1, r3
  2260c4:	4610      	mov	r0, r2
  2260c6:	f7fd fd78 	bl	223bba <vListInsertEnd>
  2260ca:	e004      	b.n	2260d6 <xTaskPriorityInherit+0xd2>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
  2260cc:	4b0a      	ldr	r3, [pc, #40]	; (2260f8 <xTaskPriorityInherit+0xf4>)
  2260ce:	681b      	ldr	r3, [r3, #0]
  2260d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2260d2:	68bb      	ldr	r3, [r7, #8]
  2260d4:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
  2260d6:	2301      	movs	r3, #1
  2260d8:	60fb      	str	r3, [r7, #12]
  2260da:	e008      	b.n	2260ee <xTaskPriorityInherit+0xea>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
  2260dc:	68bb      	ldr	r3, [r7, #8]
  2260de:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  2260e0:	4b05      	ldr	r3, [pc, #20]	; (2260f8 <xTaskPriorityInherit+0xf4>)
  2260e2:	681b      	ldr	r3, [r3, #0]
  2260e4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2260e6:	429a      	cmp	r2, r3
  2260e8:	d201      	bcs.n	2260ee <xTaskPriorityInherit+0xea>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
  2260ea:	2301      	movs	r3, #1
  2260ec:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  2260ee:	68fb      	ldr	r3, [r7, #12]
	}
  2260f0:	4618      	mov	r0, r3
  2260f2:	3710      	adds	r7, #16
  2260f4:	46bd      	mov	sp, r7
  2260f6:	bd80      	pop	{r7, pc}
  2260f8:	20014878 	.word	0x20014878
  2260fc:	2001487c 	.word	0x2001487c
  226100:	20014980 	.word	0x20014980

00226104 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
  226104:	b580      	push	{r7, lr}
  226106:	b086      	sub	sp, #24
  226108:	af00      	add	r7, sp, #0
  22610a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
  22610c:	687b      	ldr	r3, [r7, #4]
  22610e:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
  226110:	2300      	movs	r3, #0
  226112:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
  226114:	687b      	ldr	r3, [r7, #4]
  226116:	2b00      	cmp	r3, #0
  226118:	d070      	beq.n	2261fc <xTaskPriorityDisinherit+0xf8>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
  22611a:	4b3b      	ldr	r3, [pc, #236]	; (226208 <xTaskPriorityDisinherit+0x104>)
  22611c:	681b      	ldr	r3, [r3, #0]
  22611e:	693a      	ldr	r2, [r7, #16]
  226120:	429a      	cmp	r2, r3
  226122:	d00b      	beq.n	22613c <xTaskPriorityDisinherit+0x38>
  226124:	f04f 0350 	mov.w	r3, #80	; 0x50
  226128:	b672      	cpsid	i
  22612a:	f383 8811 	msr	BASEPRI, r3
  22612e:	f3bf 8f6f 	isb	sy
  226132:	f3bf 8f4f 	dsb	sy
  226136:	b662      	cpsie	i
  226138:	60fb      	str	r3, [r7, #12]
  22613a:	e7fe      	b.n	22613a <xTaskPriorityDisinherit+0x36>
			configASSERT( pxTCB->uxMutexesHeld );
  22613c:	693b      	ldr	r3, [r7, #16]
  22613e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  226140:	2b00      	cmp	r3, #0
  226142:	d10b      	bne.n	22615c <xTaskPriorityDisinherit+0x58>
  226144:	f04f 0350 	mov.w	r3, #80	; 0x50
  226148:	b672      	cpsid	i
  22614a:	f383 8811 	msr	BASEPRI, r3
  22614e:	f3bf 8f6f 	isb	sy
  226152:	f3bf 8f4f 	dsb	sy
  226156:	b662      	cpsie	i
  226158:	60bb      	str	r3, [r7, #8]
  22615a:	e7fe      	b.n	22615a <xTaskPriorityDisinherit+0x56>
			( pxTCB->uxMutexesHeld )--;
  22615c:	693b      	ldr	r3, [r7, #16]
  22615e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  226160:	1e5a      	subs	r2, r3, #1
  226162:	693b      	ldr	r3, [r7, #16]
  226164:	649a      	str	r2, [r3, #72]	; 0x48

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  226166:	693b      	ldr	r3, [r7, #16]
  226168:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  22616a:	693b      	ldr	r3, [r7, #16]
  22616c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  22616e:	429a      	cmp	r2, r3
  226170:	d044      	beq.n	2261fc <xTaskPriorityDisinherit+0xf8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
  226172:	693b      	ldr	r3, [r7, #16]
  226174:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  226176:	2b00      	cmp	r3, #0
  226178:	d140      	bne.n	2261fc <xTaskPriorityDisinherit+0xf8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  22617a:	693b      	ldr	r3, [r7, #16]
  22617c:	3304      	adds	r3, #4
  22617e:	4618      	mov	r0, r3
  226180:	f7fd fd78 	bl	223c74 <uxListRemove>
  226184:	4603      	mov	r3, r0
  226186:	2b00      	cmp	r3, #0
  226188:	d115      	bne.n	2261b6 <xTaskPriorityDisinherit+0xb2>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  22618a:	693b      	ldr	r3, [r7, #16]
  22618c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  22618e:	491f      	ldr	r1, [pc, #124]	; (22620c <xTaskPriorityDisinherit+0x108>)
  226190:	4613      	mov	r3, r2
  226192:	009b      	lsls	r3, r3, #2
  226194:	4413      	add	r3, r2
  226196:	009b      	lsls	r3, r3, #2
  226198:	440b      	add	r3, r1
  22619a:	681b      	ldr	r3, [r3, #0]
  22619c:	2b00      	cmp	r3, #0
  22619e:	d10a      	bne.n	2261b6 <xTaskPriorityDisinherit+0xb2>
  2261a0:	693b      	ldr	r3, [r7, #16]
  2261a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2261a4:	2201      	movs	r2, #1
  2261a6:	fa02 f303 	lsl.w	r3, r2, r3
  2261aa:	43da      	mvns	r2, r3
  2261ac:	4b18      	ldr	r3, [pc, #96]	; (226210 <xTaskPriorityDisinherit+0x10c>)
  2261ae:	681b      	ldr	r3, [r3, #0]
  2261b0:	4013      	ands	r3, r2
  2261b2:	4a17      	ldr	r2, [pc, #92]	; (226210 <xTaskPriorityDisinherit+0x10c>)
  2261b4:	6013      	str	r3, [r2, #0]
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
  2261b6:	693b      	ldr	r3, [r7, #16]
  2261b8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  2261ba:	693b      	ldr	r3, [r7, #16]
  2261bc:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  2261be:	693b      	ldr	r3, [r7, #16]
  2261c0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2261c2:	f1c3 0207 	rsb	r2, r3, #7
  2261c6:	693b      	ldr	r3, [r7, #16]
  2261c8:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
  2261ca:	693b      	ldr	r3, [r7, #16]
  2261cc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2261ce:	2201      	movs	r2, #1
  2261d0:	409a      	lsls	r2, r3
  2261d2:	4b0f      	ldr	r3, [pc, #60]	; (226210 <xTaskPriorityDisinherit+0x10c>)
  2261d4:	681b      	ldr	r3, [r3, #0]
  2261d6:	4313      	orrs	r3, r2
  2261d8:	4a0d      	ldr	r2, [pc, #52]	; (226210 <xTaskPriorityDisinherit+0x10c>)
  2261da:	6013      	str	r3, [r2, #0]
  2261dc:	693b      	ldr	r3, [r7, #16]
  2261de:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2261e0:	4613      	mov	r3, r2
  2261e2:	009b      	lsls	r3, r3, #2
  2261e4:	4413      	add	r3, r2
  2261e6:	009b      	lsls	r3, r3, #2
  2261e8:	4a08      	ldr	r2, [pc, #32]	; (22620c <xTaskPriorityDisinherit+0x108>)
  2261ea:	441a      	add	r2, r3
  2261ec:	693b      	ldr	r3, [r7, #16]
  2261ee:	3304      	adds	r3, #4
  2261f0:	4619      	mov	r1, r3
  2261f2:	4610      	mov	r0, r2
  2261f4:	f7fd fce1 	bl	223bba <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
  2261f8:	2301      	movs	r3, #1
  2261fa:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
  2261fc:	697b      	ldr	r3, [r7, #20]
	}
  2261fe:	4618      	mov	r0, r3
  226200:	3718      	adds	r7, #24
  226202:	46bd      	mov	sp, r7
  226204:	bd80      	pop	{r7, pc}
  226206:	bf00      	nop
  226208:	20014878 	.word	0x20014878
  22620c:	2001487c 	.word	0x2001487c
  226210:	20014980 	.word	0x20014980

00226214 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
  226214:	b580      	push	{r7, lr}
  226216:	b088      	sub	sp, #32
  226218:	af00      	add	r7, sp, #0
  22621a:	6078      	str	r0, [r7, #4]
  22621c:	6039      	str	r1, [r7, #0]
	TCB_t * const pxTCB = pxMutexHolder;
  22621e:	687b      	ldr	r3, [r7, #4]
  226220:	61bb      	str	r3, [r7, #24]
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
  226222:	2301      	movs	r3, #1
  226224:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
  226226:	687b      	ldr	r3, [r7, #4]
  226228:	2b00      	cmp	r3, #0
  22622a:	f000 8085 	beq.w	226338 <vTaskPriorityDisinheritAfterTimeout+0x124>
		{
			/* If pxMutexHolder is not NULL then the holder must hold at least
			one mutex. */
			configASSERT( pxTCB->uxMutexesHeld );
  22622e:	69bb      	ldr	r3, [r7, #24]
  226230:	6c9b      	ldr	r3, [r3, #72]	; 0x48
  226232:	2b00      	cmp	r3, #0
  226234:	d10b      	bne.n	22624e <vTaskPriorityDisinheritAfterTimeout+0x3a>
  226236:	f04f 0350 	mov.w	r3, #80	; 0x50
  22623a:	b672      	cpsid	i
  22623c:	f383 8811 	msr	BASEPRI, r3
  226240:	f3bf 8f6f 	isb	sy
  226244:	f3bf 8f4f 	dsb	sy
  226248:	b662      	cpsie	i
  22624a:	60fb      	str	r3, [r7, #12]
  22624c:	e7fe      	b.n	22624c <vTaskPriorityDisinheritAfterTimeout+0x38>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
  22624e:	69bb      	ldr	r3, [r7, #24]
  226250:	6c5a      	ldr	r2, [r3, #68]	; 0x44
  226252:	683b      	ldr	r3, [r7, #0]
  226254:	429a      	cmp	r2, r3
  226256:	d202      	bcs.n	22625e <vTaskPriorityDisinheritAfterTimeout+0x4a>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
  226258:	683b      	ldr	r3, [r7, #0]
  22625a:	61fb      	str	r3, [r7, #28]
  22625c:	e002      	b.n	226264 <vTaskPriorityDisinheritAfterTimeout+0x50>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
  22625e:	69bb      	ldr	r3, [r7, #24]
  226260:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  226262:	61fb      	str	r3, [r7, #28]
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
  226264:	69bb      	ldr	r3, [r7, #24]
  226266:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  226268:	69fb      	ldr	r3, [r7, #28]
  22626a:	429a      	cmp	r2, r3
  22626c:	d064      	beq.n	226338 <vTaskPriorityDisinheritAfterTimeout+0x124>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
  22626e:	69bb      	ldr	r3, [r7, #24]
  226270:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  226272:	697b      	ldr	r3, [r7, #20]
  226274:	429a      	cmp	r2, r3
  226276:	d15f      	bne.n	226338 <vTaskPriorityDisinheritAfterTimeout+0x124>
				{
					/* If a task has timed out because it already holds the
					mutex it was trying to obtain then it cannot of inherited
					its own priority. */
					configASSERT( pxTCB != pxCurrentTCB );
  226278:	4b31      	ldr	r3, [pc, #196]	; (226340 <vTaskPriorityDisinheritAfterTimeout+0x12c>)
  22627a:	681b      	ldr	r3, [r3, #0]
  22627c:	69ba      	ldr	r2, [r7, #24]
  22627e:	429a      	cmp	r2, r3
  226280:	d10b      	bne.n	22629a <vTaskPriorityDisinheritAfterTimeout+0x86>
  226282:	f04f 0350 	mov.w	r3, #80	; 0x50
  226286:	b672      	cpsid	i
  226288:	f383 8811 	msr	BASEPRI, r3
  22628c:	f3bf 8f6f 	isb	sy
  226290:	f3bf 8f4f 	dsb	sy
  226294:	b662      	cpsie	i
  226296:	60bb      	str	r3, [r7, #8]
  226298:	e7fe      	b.n	226298 <vTaskPriorityDisinheritAfterTimeout+0x84>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
  22629a:	69bb      	ldr	r3, [r7, #24]
  22629c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22629e:	613b      	str	r3, [r7, #16]
					pxTCB->uxPriority = uxPriorityToUse;
  2262a0:	69bb      	ldr	r3, [r7, #24]
  2262a2:	69fa      	ldr	r2, [r7, #28]
  2262a4:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
  2262a6:	69bb      	ldr	r3, [r7, #24]
  2262a8:	699b      	ldr	r3, [r3, #24]
  2262aa:	2b00      	cmp	r3, #0
  2262ac:	db04      	blt.n	2262b8 <vTaskPriorityDisinheritAfterTimeout+0xa4>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
  2262ae:	69fb      	ldr	r3, [r7, #28]
  2262b0:	f1c3 0207 	rsb	r2, r3, #7
  2262b4:	69bb      	ldr	r3, [r7, #24]
  2262b6:	619a      	str	r2, [r3, #24]
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
  2262b8:	69bb      	ldr	r3, [r7, #24]
  2262ba:	6959      	ldr	r1, [r3, #20]
  2262bc:	693a      	ldr	r2, [r7, #16]
  2262be:	4613      	mov	r3, r2
  2262c0:	009b      	lsls	r3, r3, #2
  2262c2:	4413      	add	r3, r2
  2262c4:	009b      	lsls	r3, r3, #2
  2262c6:	4a1f      	ldr	r2, [pc, #124]	; (226344 <vTaskPriorityDisinheritAfterTimeout+0x130>)
  2262c8:	4413      	add	r3, r2
  2262ca:	4299      	cmp	r1, r3
  2262cc:	d134      	bne.n	226338 <vTaskPriorityDisinheritAfterTimeout+0x124>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  2262ce:	69bb      	ldr	r3, [r7, #24]
  2262d0:	3304      	adds	r3, #4
  2262d2:	4618      	mov	r0, r3
  2262d4:	f7fd fcce 	bl	223c74 <uxListRemove>
  2262d8:	4603      	mov	r3, r0
  2262da:	2b00      	cmp	r3, #0
  2262dc:	d115      	bne.n	22630a <vTaskPriorityDisinheritAfterTimeout+0xf6>
						{
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
  2262de:	69bb      	ldr	r3, [r7, #24]
  2262e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  2262e2:	4918      	ldr	r1, [pc, #96]	; (226344 <vTaskPriorityDisinheritAfterTimeout+0x130>)
  2262e4:	4613      	mov	r3, r2
  2262e6:	009b      	lsls	r3, r3, #2
  2262e8:	4413      	add	r3, r2
  2262ea:	009b      	lsls	r3, r3, #2
  2262ec:	440b      	add	r3, r1
  2262ee:	681b      	ldr	r3, [r3, #0]
  2262f0:	2b00      	cmp	r3, #0
  2262f2:	d10a      	bne.n	22630a <vTaskPriorityDisinheritAfterTimeout+0xf6>
  2262f4:	69bb      	ldr	r3, [r7, #24]
  2262f6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  2262f8:	2201      	movs	r2, #1
  2262fa:	fa02 f303 	lsl.w	r3, r2, r3
  2262fe:	43da      	mvns	r2, r3
  226300:	4b11      	ldr	r3, [pc, #68]	; (226348 <vTaskPriorityDisinheritAfterTimeout+0x134>)
  226302:	681b      	ldr	r3, [r3, #0]
  226304:	4013      	ands	r3, r2
  226306:	4a10      	ldr	r2, [pc, #64]	; (226348 <vTaskPriorityDisinheritAfterTimeout+0x134>)
  226308:	6013      	str	r3, [r2, #0]
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
  22630a:	69bb      	ldr	r3, [r7, #24]
  22630c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22630e:	2201      	movs	r2, #1
  226310:	409a      	lsls	r2, r3
  226312:	4b0d      	ldr	r3, [pc, #52]	; (226348 <vTaskPriorityDisinheritAfterTimeout+0x134>)
  226314:	681b      	ldr	r3, [r3, #0]
  226316:	4313      	orrs	r3, r2
  226318:	4a0b      	ldr	r2, [pc, #44]	; (226348 <vTaskPriorityDisinheritAfterTimeout+0x134>)
  22631a:	6013      	str	r3, [r2, #0]
  22631c:	69bb      	ldr	r3, [r7, #24]
  22631e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  226320:	4613      	mov	r3, r2
  226322:	009b      	lsls	r3, r3, #2
  226324:	4413      	add	r3, r2
  226326:	009b      	lsls	r3, r3, #2
  226328:	4a06      	ldr	r2, [pc, #24]	; (226344 <vTaskPriorityDisinheritAfterTimeout+0x130>)
  22632a:	441a      	add	r2, r3
  22632c:	69bb      	ldr	r3, [r7, #24]
  22632e:	3304      	adds	r3, #4
  226330:	4619      	mov	r1, r3
  226332:	4610      	mov	r0, r2
  226334:	f7fd fc41 	bl	223bba <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
  226338:	bf00      	nop
  22633a:	3720      	adds	r7, #32
  22633c:	46bd      	mov	sp, r7
  22633e:	bd80      	pop	{r7, pc}
  226340:	20014878 	.word	0x20014878
  226344:	2001487c 	.word	0x2001487c
  226348:	20014980 	.word	0x20014980

0022634c <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
  22634c:	b480      	push	{r7}
  22634e:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
  226350:	4b07      	ldr	r3, [pc, #28]	; (226370 <pvTaskIncrementMutexHeldCount+0x24>)
  226352:	681b      	ldr	r3, [r3, #0]
  226354:	2b00      	cmp	r3, #0
  226356:	d004      	beq.n	226362 <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
  226358:	4b05      	ldr	r3, [pc, #20]	; (226370 <pvTaskIncrementMutexHeldCount+0x24>)
  22635a:	681b      	ldr	r3, [r3, #0]
  22635c:	6c9a      	ldr	r2, [r3, #72]	; 0x48
  22635e:	3201      	adds	r2, #1
  226360:	649a      	str	r2, [r3, #72]	; 0x48
		}

		return pxCurrentTCB;
  226362:	4b03      	ldr	r3, [pc, #12]	; (226370 <pvTaskIncrementMutexHeldCount+0x24>)
  226364:	681b      	ldr	r3, [r3, #0]
	}
  226366:	4618      	mov	r0, r3
  226368:	46bd      	mov	sp, r7
  22636a:	f85d 7b04 	ldr.w	r7, [sp], #4
  22636e:	4770      	bx	lr
  226370:	20014878 	.word	0x20014878

00226374 <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
  226374:	b580      	push	{r7, lr}
  226376:	b084      	sub	sp, #16
  226378:	af00      	add	r7, sp, #0
  22637a:	6078      	str	r0, [r7, #4]
  22637c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
  22637e:	4b29      	ldr	r3, [pc, #164]	; (226424 <prvAddCurrentTaskToDelayedList+0xb0>)
  226380:	681b      	ldr	r3, [r3, #0]
  226382:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
  226384:	4b28      	ldr	r3, [pc, #160]	; (226428 <prvAddCurrentTaskToDelayedList+0xb4>)
  226386:	681b      	ldr	r3, [r3, #0]
  226388:	3304      	adds	r3, #4
  22638a:	4618      	mov	r0, r3
  22638c:	f7fd fc72 	bl	223c74 <uxListRemove>
  226390:	4603      	mov	r3, r0
  226392:	2b00      	cmp	r3, #0
  226394:	d10b      	bne.n	2263ae <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority ); /*lint !e931 pxCurrentTCB cannot change as it is the calling task.  pxCurrentTCB->uxPriority and uxTopReadyPriority cannot change as called with scheduler suspended or in a critical section. */
  226396:	4b24      	ldr	r3, [pc, #144]	; (226428 <prvAddCurrentTaskToDelayedList+0xb4>)
  226398:	681b      	ldr	r3, [r3, #0]
  22639a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  22639c:	2201      	movs	r2, #1
  22639e:	fa02 f303 	lsl.w	r3, r2, r3
  2263a2:	43da      	mvns	r2, r3
  2263a4:	4b21      	ldr	r3, [pc, #132]	; (22642c <prvAddCurrentTaskToDelayedList+0xb8>)
  2263a6:	681b      	ldr	r3, [r3, #0]
  2263a8:	4013      	ands	r3, r2
  2263aa:	4a20      	ldr	r2, [pc, #128]	; (22642c <prvAddCurrentTaskToDelayedList+0xb8>)
  2263ac:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
  2263ae:	687b      	ldr	r3, [r7, #4]
  2263b0:	f1b3 3fff 	cmp.w	r3, #4294967295
  2263b4:	d10a      	bne.n	2263cc <prvAddCurrentTaskToDelayedList+0x58>
  2263b6:	683b      	ldr	r3, [r7, #0]
  2263b8:	2b00      	cmp	r3, #0
  2263ba:	d007      	beq.n	2263cc <prvAddCurrentTaskToDelayedList+0x58>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
  2263bc:	4b1a      	ldr	r3, [pc, #104]	; (226428 <prvAddCurrentTaskToDelayedList+0xb4>)
  2263be:	681b      	ldr	r3, [r3, #0]
  2263c0:	3304      	adds	r3, #4
  2263c2:	4619      	mov	r1, r3
  2263c4:	481a      	ldr	r0, [pc, #104]	; (226430 <prvAddCurrentTaskToDelayedList+0xbc>)
  2263c6:	f7fd fbf8 	bl	223bba <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
  2263ca:	e026      	b.n	22641a <prvAddCurrentTaskToDelayedList+0xa6>
			xTimeToWake = xConstTickCount + xTicksToWait;
  2263cc:	68fa      	ldr	r2, [r7, #12]
  2263ce:	687b      	ldr	r3, [r7, #4]
  2263d0:	4413      	add	r3, r2
  2263d2:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
  2263d4:	4b14      	ldr	r3, [pc, #80]	; (226428 <prvAddCurrentTaskToDelayedList+0xb4>)
  2263d6:	681b      	ldr	r3, [r3, #0]
  2263d8:	68ba      	ldr	r2, [r7, #8]
  2263da:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
  2263dc:	68ba      	ldr	r2, [r7, #8]
  2263de:	68fb      	ldr	r3, [r7, #12]
  2263e0:	429a      	cmp	r2, r3
  2263e2:	d209      	bcs.n	2263f8 <prvAddCurrentTaskToDelayedList+0x84>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  2263e4:	4b13      	ldr	r3, [pc, #76]	; (226434 <prvAddCurrentTaskToDelayedList+0xc0>)
  2263e6:	681a      	ldr	r2, [r3, #0]
  2263e8:	4b0f      	ldr	r3, [pc, #60]	; (226428 <prvAddCurrentTaskToDelayedList+0xb4>)
  2263ea:	681b      	ldr	r3, [r3, #0]
  2263ec:	3304      	adds	r3, #4
  2263ee:	4619      	mov	r1, r3
  2263f0:	4610      	mov	r0, r2
  2263f2:	f7fd fc06 	bl	223c02 <vListInsert>
}
  2263f6:	e010      	b.n	22641a <prvAddCurrentTaskToDelayedList+0xa6>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
  2263f8:	4b0f      	ldr	r3, [pc, #60]	; (226438 <prvAddCurrentTaskToDelayedList+0xc4>)
  2263fa:	681a      	ldr	r2, [r3, #0]
  2263fc:	4b0a      	ldr	r3, [pc, #40]	; (226428 <prvAddCurrentTaskToDelayedList+0xb4>)
  2263fe:	681b      	ldr	r3, [r3, #0]
  226400:	3304      	adds	r3, #4
  226402:	4619      	mov	r1, r3
  226404:	4610      	mov	r0, r2
  226406:	f7fd fbfc 	bl	223c02 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
  22640a:	4b0c      	ldr	r3, [pc, #48]	; (22643c <prvAddCurrentTaskToDelayedList+0xc8>)
  22640c:	681b      	ldr	r3, [r3, #0]
  22640e:	68ba      	ldr	r2, [r7, #8]
  226410:	429a      	cmp	r2, r3
  226412:	d202      	bcs.n	22641a <prvAddCurrentTaskToDelayedList+0xa6>
					xNextTaskUnblockTime = xTimeToWake;
  226414:	4a09      	ldr	r2, [pc, #36]	; (22643c <prvAddCurrentTaskToDelayedList+0xc8>)
  226416:	68bb      	ldr	r3, [r7, #8]
  226418:	6013      	str	r3, [r2, #0]
}
  22641a:	bf00      	nop
  22641c:	3710      	adds	r7, #16
  22641e:	46bd      	mov	sp, r7
  226420:	bd80      	pop	{r7, pc}
  226422:	bf00      	nop
  226424:	2001497c 	.word	0x2001497c
  226428:	20014878 	.word	0x20014878
  22642c:	20014980 	.word	0x20014980
  226430:	20014964 	.word	0x20014964
  226434:	20014934 	.word	0x20014934
  226438:	20014930 	.word	0x20014930
  22643c:	20014998 	.word	0x20014998

00226440 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
  226440:	f8df d034 	ldr.w	sp, [pc, #52]	; 226478 <LoopFillZerobss+0x12>

/* Copy the data segment initializers from flash to SRAM */  
  ldr r0, =_sdata
  226444:	480d      	ldr	r0, [pc, #52]	; (22647c <LoopFillZerobss+0x16>)
  ldr r1, =_edata
  226446:	490e      	ldr	r1, [pc, #56]	; (226480 <LoopFillZerobss+0x1a>)
  ldr r2, =_sidata
  226448:	4a0e      	ldr	r2, [pc, #56]	; (226484 <LoopFillZerobss+0x1e>)
  movs r3, #0
  22644a:	2300      	movs	r3, #0
  b LoopCopyDataInit
  22644c:	e002      	b.n	226454 <LoopCopyDataInit>

0022644e <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
  22644e:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
  226450:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
  226452:	3304      	adds	r3, #4

00226454 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
  226454:	18c4      	adds	r4, r0, r3
  cmp r4, r1
  226456:	428c      	cmp	r4, r1
  bcc CopyDataInit
  226458:	d3f9      	bcc.n	22644e <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
  22645a:	4a0b      	ldr	r2, [pc, #44]	; (226488 <LoopFillZerobss+0x22>)
  ldr r4, =_ebss
  22645c:	4c0b      	ldr	r4, [pc, #44]	; (22648c <LoopFillZerobss+0x26>)
  movs r3, #0
  22645e:	2300      	movs	r3, #0
  b LoopFillZerobss
  226460:	e001      	b.n	226466 <LoopFillZerobss>

00226462 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
  226462:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
  226464:	3204      	adds	r2, #4

00226466 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
  226466:	42a2      	cmp	r2, r4
  bcc FillZerobss
  226468:	d3fb      	bcc.n	226462 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
  22646a:	f7f2 fa5b 	bl	218924 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
  22646e:	f000 f817 	bl	2264a0 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
  226472:	f7f1 ff50 	bl	218316 <main>
  bx  lr    
  226476:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
  226478:	20080000 	.word	0x20080000
  ldr r0, =_sdata
  22647c:	20000000 	.word	0x20000000
  ldr r1, =_edata
  226480:	2000007c 	.word	0x2000007c
  ldr r2, =_sidata
  226484:	00229a78 	.word	0x00229a78
  ldr r2, =_sbss
  226488:	20000080 	.word	0x20000080
  ldr r4, =_ebss
  22648c:	20015314 	.word	0x20015314

00226490 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
  226490:	e7fe      	b.n	226490 <ADC_IRQHandler>
	...

00226494 <__errno>:
  226494:	4b01      	ldr	r3, [pc, #4]	; (22649c <__errno+0x8>)
  226496:	6818      	ldr	r0, [r3, #0]
  226498:	4770      	bx	lr
  22649a:	bf00      	nop
  22649c:	20000014 	.word	0x20000014

002264a0 <__libc_init_array>:
  2264a0:	b570      	push	{r4, r5, r6, lr}
  2264a2:	4e0d      	ldr	r6, [pc, #52]	; (2264d8 <__libc_init_array+0x38>)
  2264a4:	4c0d      	ldr	r4, [pc, #52]	; (2264dc <__libc_init_array+0x3c>)
  2264a6:	1ba4      	subs	r4, r4, r6
  2264a8:	10a4      	asrs	r4, r4, #2
  2264aa:	2500      	movs	r5, #0
  2264ac:	42a5      	cmp	r5, r4
  2264ae:	d109      	bne.n	2264c4 <__libc_init_array+0x24>
  2264b0:	4e0b      	ldr	r6, [pc, #44]	; (2264e0 <__libc_init_array+0x40>)
  2264b2:	4c0c      	ldr	r4, [pc, #48]	; (2264e4 <__libc_init_array+0x44>)
  2264b4:	f001 fea0 	bl	2281f8 <_init>
  2264b8:	1ba4      	subs	r4, r4, r6
  2264ba:	10a4      	asrs	r4, r4, #2
  2264bc:	2500      	movs	r5, #0
  2264be:	42a5      	cmp	r5, r4
  2264c0:	d105      	bne.n	2264ce <__libc_init_array+0x2e>
  2264c2:	bd70      	pop	{r4, r5, r6, pc}
  2264c4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  2264c8:	4798      	blx	r3
  2264ca:	3501      	adds	r5, #1
  2264cc:	e7ee      	b.n	2264ac <__libc_init_array+0xc>
  2264ce:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
  2264d2:	4798      	blx	r3
  2264d4:	3501      	adds	r5, #1
  2264d6:	e7f2      	b.n	2264be <__libc_init_array+0x1e>
  2264d8:	00229a70 	.word	0x00229a70
  2264dc:	00229a70 	.word	0x00229a70
  2264e0:	00229a70 	.word	0x00229a70
  2264e4:	00229a74 	.word	0x00229a74

002264e8 <__itoa>:
  2264e8:	1e93      	subs	r3, r2, #2
  2264ea:	2b22      	cmp	r3, #34	; 0x22
  2264ec:	b510      	push	{r4, lr}
  2264ee:	460c      	mov	r4, r1
  2264f0:	d904      	bls.n	2264fc <__itoa+0x14>
  2264f2:	2300      	movs	r3, #0
  2264f4:	700b      	strb	r3, [r1, #0]
  2264f6:	461c      	mov	r4, r3
  2264f8:	4620      	mov	r0, r4
  2264fa:	bd10      	pop	{r4, pc}
  2264fc:	2a0a      	cmp	r2, #10
  2264fe:	d109      	bne.n	226514 <__itoa+0x2c>
  226500:	2800      	cmp	r0, #0
  226502:	da07      	bge.n	226514 <__itoa+0x2c>
  226504:	232d      	movs	r3, #45	; 0x2d
  226506:	700b      	strb	r3, [r1, #0]
  226508:	4240      	negs	r0, r0
  22650a:	2101      	movs	r1, #1
  22650c:	4421      	add	r1, r4
  22650e:	f000 f855 	bl	2265bc <__utoa>
  226512:	e7f1      	b.n	2264f8 <__itoa+0x10>
  226514:	2100      	movs	r1, #0
  226516:	e7f9      	b.n	22650c <__itoa+0x24>

00226518 <itoa>:
  226518:	f7ff bfe6 	b.w	2264e8 <__itoa>

0022651c <memcpy>:
  22651c:	b510      	push	{r4, lr}
  22651e:	1e43      	subs	r3, r0, #1
  226520:	440a      	add	r2, r1
  226522:	4291      	cmp	r1, r2
  226524:	d100      	bne.n	226528 <memcpy+0xc>
  226526:	bd10      	pop	{r4, pc}
  226528:	f811 4b01 	ldrb.w	r4, [r1], #1
  22652c:	f803 4f01 	strb.w	r4, [r3, #1]!
  226530:	e7f7      	b.n	226522 <memcpy+0x6>

00226532 <memset>:
  226532:	4402      	add	r2, r0
  226534:	4603      	mov	r3, r0
  226536:	4293      	cmp	r3, r2
  226538:	d100      	bne.n	22653c <memset+0xa>
  22653a:	4770      	bx	lr
  22653c:	f803 1b01 	strb.w	r1, [r3], #1
  226540:	e7f9      	b.n	226536 <memset+0x4>

00226542 <strchr>:
  226542:	b2c9      	uxtb	r1, r1
  226544:	4603      	mov	r3, r0
  226546:	f810 2b01 	ldrb.w	r2, [r0], #1
  22654a:	b11a      	cbz	r2, 226554 <strchr+0x12>
  22654c:	4291      	cmp	r1, r2
  22654e:	d1f9      	bne.n	226544 <strchr+0x2>
  226550:	4618      	mov	r0, r3
  226552:	4770      	bx	lr
  226554:	2900      	cmp	r1, #0
  226556:	bf0c      	ite	eq
  226558:	4618      	moveq	r0, r3
  22655a:	2000      	movne	r0, #0
  22655c:	4770      	bx	lr

0022655e <strncat>:
  22655e:	b530      	push	{r4, r5, lr}
  226560:	4603      	mov	r3, r0
  226562:	781c      	ldrb	r4, [r3, #0]
  226564:	1c5d      	adds	r5, r3, #1
  226566:	b944      	cbnz	r4, 22657a <strncat+0x1c>
  226568:	f112 32ff 	adds.w	r2, r2, #4294967295
  22656c:	d304      	bcc.n	226578 <strncat+0x1a>
  22656e:	f811 4b01 	ldrb.w	r4, [r1], #1
  226572:	f803 4b01 	strb.w	r4, [r3], #1
  226576:	b914      	cbnz	r4, 22657e <strncat+0x20>
  226578:	bd30      	pop	{r4, r5, pc}
  22657a:	462b      	mov	r3, r5
  22657c:	e7f1      	b.n	226562 <strncat+0x4>
  22657e:	2a00      	cmp	r2, #0
  226580:	d1f2      	bne.n	226568 <strncat+0xa>
  226582:	701a      	strb	r2, [r3, #0]
  226584:	e7f0      	b.n	226568 <strncat+0xa>

00226586 <strstr>:
  226586:	b5f0      	push	{r4, r5, r6, r7, lr}
  226588:	7803      	ldrb	r3, [r0, #0]
  22658a:	b133      	cbz	r3, 22659a <strstr+0x14>
  22658c:	4603      	mov	r3, r0
  22658e:	4618      	mov	r0, r3
  226590:	1c5e      	adds	r6, r3, #1
  226592:	781b      	ldrb	r3, [r3, #0]
  226594:	b933      	cbnz	r3, 2265a4 <strstr+0x1e>
  226596:	4618      	mov	r0, r3
  226598:	bdf0      	pop	{r4, r5, r6, r7, pc}
  22659a:	780b      	ldrb	r3, [r1, #0]
  22659c:	2b00      	cmp	r3, #0
  22659e:	bf18      	it	ne
  2265a0:	2000      	movne	r0, #0
  2265a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2265a4:	1e4d      	subs	r5, r1, #1
  2265a6:	1e44      	subs	r4, r0, #1
  2265a8:	f815 2f01 	ldrb.w	r2, [r5, #1]!
  2265ac:	2a00      	cmp	r2, #0
  2265ae:	d0f3      	beq.n	226598 <strstr+0x12>
  2265b0:	f814 7f01 	ldrb.w	r7, [r4, #1]!
  2265b4:	4297      	cmp	r7, r2
  2265b6:	4633      	mov	r3, r6
  2265b8:	d0f6      	beq.n	2265a8 <strstr+0x22>
  2265ba:	e7e8      	b.n	22658e <strstr+0x8>

002265bc <__utoa>:
  2265bc:	b5f0      	push	{r4, r5, r6, r7, lr}
  2265be:	4c1e      	ldr	r4, [pc, #120]	; (226638 <__utoa+0x7c>)
  2265c0:	b08b      	sub	sp, #44	; 0x2c
  2265c2:	4603      	mov	r3, r0
  2265c4:	460f      	mov	r7, r1
  2265c6:	466d      	mov	r5, sp
  2265c8:	f104 0e20 	add.w	lr, r4, #32
  2265cc:	6820      	ldr	r0, [r4, #0]
  2265ce:	6861      	ldr	r1, [r4, #4]
  2265d0:	462e      	mov	r6, r5
  2265d2:	c603      	stmia	r6!, {r0, r1}
  2265d4:	3408      	adds	r4, #8
  2265d6:	4574      	cmp	r4, lr
  2265d8:	4635      	mov	r5, r6
  2265da:	d1f7      	bne.n	2265cc <__utoa+0x10>
  2265dc:	7921      	ldrb	r1, [r4, #4]
  2265de:	7131      	strb	r1, [r6, #4]
  2265e0:	1e91      	subs	r1, r2, #2
  2265e2:	6820      	ldr	r0, [r4, #0]
  2265e4:	6030      	str	r0, [r6, #0]
  2265e6:	2922      	cmp	r1, #34	; 0x22
  2265e8:	f04f 0100 	mov.w	r1, #0
  2265ec:	d904      	bls.n	2265f8 <__utoa+0x3c>
  2265ee:	7039      	strb	r1, [r7, #0]
  2265f0:	460f      	mov	r7, r1
  2265f2:	4638      	mov	r0, r7
  2265f4:	b00b      	add	sp, #44	; 0x2c
  2265f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  2265f8:	1e78      	subs	r0, r7, #1
  2265fa:	4606      	mov	r6, r0
  2265fc:	fbb3 f5f2 	udiv	r5, r3, r2
  226600:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
  226604:	fb02 3315 	mls	r3, r2, r5, r3
  226608:	4473      	add	r3, lr
  22660a:	1c4c      	adds	r4, r1, #1
  22660c:	f813 3c28 	ldrb.w	r3, [r3, #-40]
  226610:	f806 3f01 	strb.w	r3, [r6, #1]!
  226614:	462b      	mov	r3, r5
  226616:	b965      	cbnz	r5, 226632 <__utoa+0x76>
  226618:	553d      	strb	r5, [r7, r4]
  22661a:	187a      	adds	r2, r7, r1
  22661c:	1acc      	subs	r4, r1, r3
  22661e:	42a3      	cmp	r3, r4
  226620:	dae7      	bge.n	2265f2 <__utoa+0x36>
  226622:	7844      	ldrb	r4, [r0, #1]
  226624:	7815      	ldrb	r5, [r2, #0]
  226626:	f800 5f01 	strb.w	r5, [r0, #1]!
  22662a:	3301      	adds	r3, #1
  22662c:	f802 4901 	strb.w	r4, [r2], #-1
  226630:	e7f4      	b.n	22661c <__utoa+0x60>
  226632:	4621      	mov	r1, r4
  226634:	e7e2      	b.n	2265fc <__utoa+0x40>
  226636:	bf00      	nop
  226638:	002297e4 	.word	0x002297e4
  22663c:	00000000 	.word	0x00000000

00226640 <tan>:
  226640:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  226642:	eeb0 7b40 	vmov.f64	d7, d0
  226646:	ee17 3a90 	vmov	r3, s15
  22664a:	4a13      	ldr	r2, [pc, #76]	; (226698 <tan+0x58>)
  22664c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  226650:	4293      	cmp	r3, r2
  226652:	dc05      	bgt.n	226660 <tan+0x20>
  226654:	ed9f 1b0e 	vldr	d1, [pc, #56]	; 226690 <tan+0x50>
  226658:	2001      	movs	r0, #1
  22665a:	f001 fa1d 	bl	227a98 <__kernel_tan>
  22665e:	e004      	b.n	22666a <tan+0x2a>
  226660:	4a0e      	ldr	r2, [pc, #56]	; (22669c <tan+0x5c>)
  226662:	4293      	cmp	r3, r2
  226664:	dd04      	ble.n	226670 <tan+0x30>
  226666:	ee30 0b40 	vsub.f64	d0, d0, d0
  22666a:	b005      	add	sp, #20
  22666c:	f85d fb04 	ldr.w	pc, [sp], #4
  226670:	4668      	mov	r0, sp
  226672:	f000 fdbd 	bl	2271f0 <__ieee754_rem_pio2>
  226676:	0040      	lsls	r0, r0, #1
  226678:	f000 0002 	and.w	r0, r0, #2
  22667c:	f1c0 0001 	rsb	r0, r0, #1
  226680:	ed9d 1b02 	vldr	d1, [sp, #8]
  226684:	ed9d 0b00 	vldr	d0, [sp]
  226688:	e7e7      	b.n	22665a <tan+0x1a>
  22668a:	bf00      	nop
  22668c:	f3af 8000 	nop.w
	...
  226698:	3fe921fb 	.word	0x3fe921fb
  22669c:	7fefffff 	.word	0x7fefffff

002266a0 <atan2>:
  2266a0:	f000 b936 	b.w	226910 <__ieee754_atan2>
  2266a4:	0000      	movs	r0, r0
	...

002266a8 <pow>:
  2266a8:	b570      	push	{r4, r5, r6, lr}
  2266aa:	ed2d 8b0a 	vpush	{d8-d12}
  2266ae:	eeb0 9b40 	vmov.f64	d9, d0
  2266b2:	eeb0 8b41 	vmov.f64	d8, d1
  2266b6:	4c8e      	ldr	r4, [pc, #568]	; (2268f0 <pow+0x248>)
  2266b8:	b08a      	sub	sp, #40	; 0x28
  2266ba:	f000 fa11 	bl	226ae0 <__ieee754_pow>
  2266be:	f994 3000 	ldrsb.w	r3, [r4]
  2266c2:	eeb0 ab40 	vmov.f64	d10, d0
  2266c6:	1c5a      	adds	r2, r3, #1
  2266c8:	4626      	mov	r6, r4
  2266ca:	d04b      	beq.n	226764 <pow+0xbc>
  2266cc:	eeb4 8b48 	vcmp.f64	d8, d8
  2266d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2266d4:	d646      	bvs.n	226764 <pow+0xbc>
  2266d6:	eeb4 9b49 	vcmp.f64	d9, d9
  2266da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2266de:	d719      	bvc.n	226714 <pow+0x6c>
  2266e0:	eeb5 8b40 	vcmp.f64	d8, #0.0
  2266e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2266e8:	d13c      	bne.n	226764 <pow+0xbc>
  2266ea:	2201      	movs	r2, #1
  2266ec:	9200      	str	r2, [sp, #0]
  2266ee:	4981      	ldr	r1, [pc, #516]	; (2268f4 <pow+0x24c>)
  2266f0:	4a81      	ldr	r2, [pc, #516]	; (2268f8 <pow+0x250>)
  2266f2:	9201      	str	r2, [sp, #4]
  2266f4:	2000      	movs	r0, #0
  2266f6:	2200      	movs	r2, #0
  2266f8:	2b02      	cmp	r3, #2
  2266fa:	9208      	str	r2, [sp, #32]
  2266fc:	ed8d 9b02 	vstr	d9, [sp, #8]
  226700:	ed8d 8b04 	vstr	d8, [sp, #16]
  226704:	e9cd 0106 	strd	r0, r1, [sp, #24]
  226708:	d02a      	beq.n	226760 <pow+0xb8>
  22670a:	4668      	mov	r0, sp
  22670c:	f001 fc50 	bl	227fb0 <matherr>
  226710:	bb00      	cbnz	r0, 226754 <pow+0xac>
  226712:	e04e      	b.n	2267b2 <pow+0x10a>
  226714:	ed9f bb74 	vldr	d11, [pc, #464]	; 2268e8 <pow+0x240>
  226718:	eeb4 9b4b 	vcmp.f64	d9, d11
  22671c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  226720:	eeb0 cb4b 	vmov.f64	d12, d11
  226724:	d14a      	bne.n	2267bc <pow+0x114>
  226726:	eeb4 8b4b 	vcmp.f64	d8, d11
  22672a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  22672e:	d11f      	bne.n	226770 <pow+0xc8>
  226730:	2201      	movs	r2, #1
  226732:	9200      	str	r2, [sp, #0]
  226734:	4a70      	ldr	r2, [pc, #448]	; (2268f8 <pow+0x250>)
  226736:	9201      	str	r2, [sp, #4]
  226738:	2200      	movs	r2, #0
  22673a:	9208      	str	r2, [sp, #32]
  22673c:	ed8d 9b02 	vstr	d9, [sp, #8]
  226740:	ed8d 8b04 	vstr	d8, [sp, #16]
  226744:	ed8d bb06 	vstr	d11, [sp, #24]
  226748:	2b00      	cmp	r3, #0
  22674a:	d0de      	beq.n	22670a <pow+0x62>
  22674c:	4b69      	ldr	r3, [pc, #420]	; (2268f4 <pow+0x24c>)
  22674e:	2200      	movs	r2, #0
  226750:	e9cd 2306 	strd	r2, r3, [sp, #24]
  226754:	9b08      	ldr	r3, [sp, #32]
  226756:	b11b      	cbz	r3, 226760 <pow+0xb8>
  226758:	f7ff fe9c 	bl	226494 <__errno>
  22675c:	9b08      	ldr	r3, [sp, #32]
  22675e:	6003      	str	r3, [r0, #0]
  226760:	ed9d ab06 	vldr	d10, [sp, #24]
  226764:	eeb0 0b4a 	vmov.f64	d0, d10
  226768:	b00a      	add	sp, #40	; 0x28
  22676a:	ecbd 8b0a 	vpop	{d8-d12}
  22676e:	bd70      	pop	{r4, r5, r6, pc}
  226770:	eeb0 0b48 	vmov.f64	d0, d8
  226774:	f001 fb99 	bl	227eaa <finite>
  226778:	2800      	cmp	r0, #0
  22677a:	d0f3      	beq.n	226764 <pow+0xbc>
  22677c:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
  226780:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  226784:	d5ee      	bpl.n	226764 <pow+0xbc>
  226786:	2301      	movs	r3, #1
  226788:	9300      	str	r3, [sp, #0]
  22678a:	4b5b      	ldr	r3, [pc, #364]	; (2268f8 <pow+0x250>)
  22678c:	9301      	str	r3, [sp, #4]
  22678e:	2300      	movs	r3, #0
  226790:	9308      	str	r3, [sp, #32]
  226792:	f994 3000 	ldrsb.w	r3, [r4]
  226796:	ed8d 9b02 	vstr	d9, [sp, #8]
  22679a:	ed8d 8b04 	vstr	d8, [sp, #16]
  22679e:	b913      	cbnz	r3, 2267a6 <pow+0xfe>
  2267a0:	ed8d bb06 	vstr	d11, [sp, #24]
  2267a4:	e7b1      	b.n	22670a <pow+0x62>
  2267a6:	4955      	ldr	r1, [pc, #340]	; (2268fc <pow+0x254>)
  2267a8:	2000      	movs	r0, #0
  2267aa:	e9cd 0106 	strd	r0, r1, [sp, #24]
  2267ae:	2b02      	cmp	r3, #2
  2267b0:	d1ab      	bne.n	22670a <pow+0x62>
  2267b2:	f7ff fe6f 	bl	226494 <__errno>
  2267b6:	2321      	movs	r3, #33	; 0x21
  2267b8:	6003      	str	r3, [r0, #0]
  2267ba:	e7cb      	b.n	226754 <pow+0xac>
  2267bc:	f001 fb75 	bl	227eaa <finite>
  2267c0:	4605      	mov	r5, r0
  2267c2:	2800      	cmp	r0, #0
  2267c4:	d168      	bne.n	226898 <pow+0x1f0>
  2267c6:	eeb0 0b49 	vmov.f64	d0, d9
  2267ca:	f001 fb6e 	bl	227eaa <finite>
  2267ce:	2800      	cmp	r0, #0
  2267d0:	d062      	beq.n	226898 <pow+0x1f0>
  2267d2:	eeb0 0b48 	vmov.f64	d0, d8
  2267d6:	f001 fb68 	bl	227eaa <finite>
  2267da:	2800      	cmp	r0, #0
  2267dc:	d05c      	beq.n	226898 <pow+0x1f0>
  2267de:	eeb4 ab4a 	vcmp.f64	d10, d10
  2267e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2267e6:	f994 3000 	ldrsb.w	r3, [r4]
  2267ea:	4a43      	ldr	r2, [pc, #268]	; (2268f8 <pow+0x250>)
  2267ec:	d70e      	bvc.n	22680c <pow+0x164>
  2267ee:	2101      	movs	r1, #1
  2267f0:	e88d 0006 	stmia.w	sp, {r1, r2}
  2267f4:	9508      	str	r5, [sp, #32]
  2267f6:	ed8d 9b02 	vstr	d9, [sp, #8]
  2267fa:	ed8d 8b04 	vstr	d8, [sp, #16]
  2267fe:	2b00      	cmp	r3, #0
  226800:	d0ce      	beq.n	2267a0 <pow+0xf8>
  226802:	ee8b 7b0b 	vdiv.f64	d7, d11, d11
  226806:	ed8d 7b06 	vstr	d7, [sp, #24]
  22680a:	e7d0      	b.n	2267ae <pow+0x106>
  22680c:	2103      	movs	r1, #3
  22680e:	e88d 0006 	stmia.w	sp, {r1, r2}
  226812:	9508      	str	r5, [sp, #32]
  226814:	ed8d 9b02 	vstr	d9, [sp, #8]
  226818:	ed8d 8b04 	vstr	d8, [sp, #16]
  22681c:	bb1b      	cbnz	r3, 226866 <pow+0x1be>
  22681e:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
  226822:	4b37      	ldr	r3, [pc, #220]	; (226900 <pow+0x258>)
  226824:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
  226828:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  22682c:	e9cd 2306 	strd	r2, r3, [sp, #24]
  226830:	d553      	bpl.n	2268da <pow+0x232>
  226832:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  226836:	ee28 8b07 	vmul.f64	d8, d8, d7
  22683a:	eeb0 0b48 	vmov.f64	d0, d8
  22683e:	f001 fbc3 	bl	227fc8 <rint>
  226842:	eeb4 8b40 	vcmp.f64	d8, d0
  226846:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  22684a:	d004      	beq.n	226856 <pow+0x1ae>
  22684c:	4b2d      	ldr	r3, [pc, #180]	; (226904 <pow+0x25c>)
  22684e:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
  226852:	e9cd 2306 	strd	r2, r3, [sp, #24]
  226856:	f996 3000 	ldrsb.w	r3, [r6]
  22685a:	2b02      	cmp	r3, #2
  22685c:	d13d      	bne.n	2268da <pow+0x232>
  22685e:	f7ff fe19 	bl	226494 <__errno>
  226862:	2322      	movs	r3, #34	; 0x22
  226864:	e7a8      	b.n	2267b8 <pow+0x110>
  226866:	4b28      	ldr	r3, [pc, #160]	; (226908 <pow+0x260>)
  226868:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
  22686c:	2200      	movs	r2, #0
  22686e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  226872:	e9cd 2306 	strd	r2, r3, [sp, #24]
  226876:	d5ee      	bpl.n	226856 <pow+0x1ae>
  226878:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  22687c:	ee28 8b07 	vmul.f64	d8, d8, d7
  226880:	eeb0 0b48 	vmov.f64	d0, d8
  226884:	f001 fba0 	bl	227fc8 <rint>
  226888:	eeb4 8b40 	vcmp.f64	d8, d0
  22688c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  226890:	d0e1      	beq.n	226856 <pow+0x1ae>
  226892:	2200      	movs	r2, #0
  226894:	4b19      	ldr	r3, [pc, #100]	; (2268fc <pow+0x254>)
  226896:	e7dc      	b.n	226852 <pow+0x1aa>
  226898:	eeb5 ab40 	vcmp.f64	d10, #0.0
  22689c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2268a0:	f47f af60 	bne.w	226764 <pow+0xbc>
  2268a4:	eeb0 0b49 	vmov.f64	d0, d9
  2268a8:	f001 faff 	bl	227eaa <finite>
  2268ac:	2800      	cmp	r0, #0
  2268ae:	f43f af59 	beq.w	226764 <pow+0xbc>
  2268b2:	eeb0 0b48 	vmov.f64	d0, d8
  2268b6:	f001 faf8 	bl	227eaa <finite>
  2268ba:	2800      	cmp	r0, #0
  2268bc:	f43f af52 	beq.w	226764 <pow+0xbc>
  2268c0:	2304      	movs	r3, #4
  2268c2:	9300      	str	r3, [sp, #0]
  2268c4:	4b0c      	ldr	r3, [pc, #48]	; (2268f8 <pow+0x250>)
  2268c6:	9301      	str	r3, [sp, #4]
  2268c8:	2300      	movs	r3, #0
  2268ca:	9308      	str	r3, [sp, #32]
  2268cc:	ed8d 9b02 	vstr	d9, [sp, #8]
  2268d0:	ed8d 8b04 	vstr	d8, [sp, #16]
  2268d4:	ed8d cb06 	vstr	d12, [sp, #24]
  2268d8:	e7bd      	b.n	226856 <pow+0x1ae>
  2268da:	4668      	mov	r0, sp
  2268dc:	f001 fb68 	bl	227fb0 <matherr>
  2268e0:	2800      	cmp	r0, #0
  2268e2:	f47f af37 	bne.w	226754 <pow+0xac>
  2268e6:	e7ba      	b.n	22685e <pow+0x1b6>
	...
  2268f0:	20000078 	.word	0x20000078
  2268f4:	3ff00000 	.word	0x3ff00000
  2268f8:	00229809 	.word	0x00229809
  2268fc:	fff00000 	.word	0xfff00000
  226900:	47efffff 	.word	0x47efffff
  226904:	c7efffff 	.word	0xc7efffff
  226908:	7ff00000 	.word	0x7ff00000
  22690c:	00000000 	.word	0x00000000

00226910 <__ieee754_atan2>:
  226910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  226912:	ee11 ea10 	vmov	lr, s2
  226916:	ee11 5a90 	vmov	r5, s3
  22691a:	f1ce 0100 	rsb	r1, lr, #0
  22691e:	f025 4000 	bic.w	r0, r5, #2147483648	; 0x80000000
  226922:	ea41 010e 	orr.w	r1, r1, lr
  226926:	4f6c      	ldr	r7, [pc, #432]	; (226ad8 <__ieee754_atan2+0x1c8>)
  226928:	ec53 2b10 	vmov	r2, r3, d0
  22692c:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
  226930:	42b9      	cmp	r1, r7
  226932:	ee10 ca10 	vmov	ip, s0
  226936:	461e      	mov	r6, r3
  226938:	d807      	bhi.n	22694a <__ieee754_atan2+0x3a>
  22693a:	4254      	negs	r4, r2
  22693c:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
  226940:	4314      	orrs	r4, r2
  226942:	ea41 74d4 	orr.w	r4, r1, r4, lsr #31
  226946:	42bc      	cmp	r4, r7
  226948:	d906      	bls.n	226958 <__ieee754_atan2+0x48>
  22694a:	ec43 2b17 	vmov	d7, r2, r3
  22694e:	ee37 7b01 	vadd.f64	d7, d7, d1
  226952:	ec53 2b17 	vmov	r2, r3, d7
  226956:	e01a      	b.n	22698e <__ieee754_atan2+0x7e>
  226958:	f105 4440 	add.w	r4, r5, #3221225472	; 0xc0000000
  22695c:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
  226960:	ea54 040e 	orrs.w	r4, r4, lr
  226964:	d103      	bne.n	22696e <__ieee754_atan2+0x5e>
  226966:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  22696a:	f001 b9a1 	b.w	227cb0 <atan>
  22696e:	17ac      	asrs	r4, r5, #30
  226970:	f004 0402 	and.w	r4, r4, #2
  226974:	ea5c 0c01 	orrs.w	ip, ip, r1
  226978:	ea44 74d3 	orr.w	r4, r4, r3, lsr #31
  22697c:	d10a      	bne.n	226994 <__ieee754_atan2+0x84>
  22697e:	2c02      	cmp	r4, #2
  226980:	d03b      	beq.n	2269fa <__ieee754_atan2+0xea>
  226982:	ed9f 7b3f 	vldr	d7, [pc, #252]	; 226a80 <__ieee754_atan2+0x170>
  226986:	2c03      	cmp	r4, #3
  226988:	bf08      	it	eq
  22698a:	ec53 2b17 	vmoveq	r2, r3, d7
  22698e:	ec43 2b10 	vmov	d0, r2, r3
  226992:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  226994:	ea5e 0e00 	orrs.w	lr, lr, r0
  226998:	d10a      	bne.n	2269b0 <__ieee754_atan2+0xa0>
  22699a:	ed9f 7b3b 	vldr	d7, [pc, #236]	; 226a88 <__ieee754_atan2+0x178>
  22699e:	ed9f 6b3c 	vldr	d6, [pc, #240]	; 226a90 <__ieee754_atan2+0x180>
  2269a2:	2e00      	cmp	r6, #0
  2269a4:	bfb4      	ite	lt
  2269a6:	ec53 2b17 	vmovlt	r2, r3, d7
  2269aa:	ec53 2b16 	vmovge	r2, r3, d6
  2269ae:	e7ee      	b.n	22698e <__ieee754_atan2+0x7e>
  2269b0:	42b8      	cmp	r0, r7
  2269b2:	d12a      	bne.n	226a0a <__ieee754_atan2+0xfa>
  2269b4:	4281      	cmp	r1, r0
  2269b6:	d116      	bne.n	2269e6 <__ieee754_atan2+0xd6>
  2269b8:	2c02      	cmp	r4, #2
  2269ba:	d00c      	beq.n	2269d6 <__ieee754_atan2+0xc6>
  2269bc:	2c03      	cmp	r4, #3
  2269be:	d00e      	beq.n	2269de <__ieee754_atan2+0xce>
  2269c0:	ed9f 7b35 	vldr	d7, [pc, #212]	; 226a98 <__ieee754_atan2+0x188>
  2269c4:	ed9f 6b36 	vldr	d6, [pc, #216]	; 226aa0 <__ieee754_atan2+0x190>
  2269c8:	2c01      	cmp	r4, #1
  2269ca:	bf14      	ite	ne
  2269cc:	ec53 2b17 	vmovne	r2, r3, d7
  2269d0:	ec53 2b16 	vmoveq	r2, r3, d6
  2269d4:	e7db      	b.n	22698e <__ieee754_atan2+0x7e>
  2269d6:	a334      	add	r3, pc, #208	; (adr r3, 226aa8 <__ieee754_atan2+0x198>)
  2269d8:	e9d3 2300 	ldrd	r2, r3, [r3]
  2269dc:	e7d7      	b.n	22698e <__ieee754_atan2+0x7e>
  2269de:	a334      	add	r3, pc, #208	; (adr r3, 226ab0 <__ieee754_atan2+0x1a0>)
  2269e0:	e9d3 2300 	ldrd	r2, r3, [r3]
  2269e4:	e7d3      	b.n	22698e <__ieee754_atan2+0x7e>
  2269e6:	2c02      	cmp	r4, #2
  2269e8:	d007      	beq.n	2269fa <__ieee754_atan2+0xea>
  2269ea:	2c03      	cmp	r4, #3
  2269ec:	d009      	beq.n	226a02 <__ieee754_atan2+0xf2>
  2269ee:	2c01      	cmp	r4, #1
  2269f0:	ed9f 7b31 	vldr	d7, [pc, #196]	; 226ab8 <__ieee754_atan2+0x1a8>
  2269f4:	ed9f 6b32 	vldr	d6, [pc, #200]	; 226ac0 <__ieee754_atan2+0x1b0>
  2269f8:	e7e7      	b.n	2269ca <__ieee754_atan2+0xba>
  2269fa:	a333      	add	r3, pc, #204	; (adr r3, 226ac8 <__ieee754_atan2+0x1b8>)
  2269fc:	e9d3 2300 	ldrd	r2, r3, [r3]
  226a00:	e7c5      	b.n	22698e <__ieee754_atan2+0x7e>
  226a02:	a31f      	add	r3, pc, #124	; (adr r3, 226a80 <__ieee754_atan2+0x170>)
  226a04:	e9d3 2300 	ldrd	r2, r3, [r3]
  226a08:	e7c1      	b.n	22698e <__ieee754_atan2+0x7e>
  226a0a:	42b9      	cmp	r1, r7
  226a0c:	d0c5      	beq.n	22699a <__ieee754_atan2+0x8a>
  226a0e:	1a09      	subs	r1, r1, r0
  226a10:	1509      	asrs	r1, r1, #20
  226a12:	293c      	cmp	r1, #60	; 0x3c
  226a14:	dc1e      	bgt.n	226a54 <__ieee754_atan2+0x144>
  226a16:	2d00      	cmp	r5, #0
  226a18:	da01      	bge.n	226a1e <__ieee754_atan2+0x10e>
  226a1a:	313c      	adds	r1, #60	; 0x3c
  226a1c:	db1e      	blt.n	226a5c <__ieee754_atan2+0x14c>
  226a1e:	ec43 2b17 	vmov	d7, r2, r3
  226a22:	ee87 0b01 	vdiv.f64	d0, d7, d1
  226a26:	f001 fa39 	bl	227e9c <fabs>
  226a2a:	f001 f941 	bl	227cb0 <atan>
  226a2e:	ec53 2b10 	vmov	r2, r3, d0
  226a32:	2c01      	cmp	r4, #1
  226a34:	d015      	beq.n	226a62 <__ieee754_atan2+0x152>
  226a36:	2c02      	cmp	r4, #2
  226a38:	d016      	beq.n	226a68 <__ieee754_atan2+0x158>
  226a3a:	2c00      	cmp	r4, #0
  226a3c:	d0a7      	beq.n	22698e <__ieee754_atan2+0x7e>
  226a3e:	ed9f 7b24 	vldr	d7, [pc, #144]	; 226ad0 <__ieee754_atan2+0x1c0>
  226a42:	ec43 2b16 	vmov	d6, r2, r3
  226a46:	ee36 7b47 	vsub.f64	d7, d6, d7
  226a4a:	ed9f 6b1f 	vldr	d6, [pc, #124]	; 226ac8 <__ieee754_atan2+0x1b8>
  226a4e:	ee37 7b46 	vsub.f64	d7, d7, d6
  226a52:	e77e      	b.n	226952 <__ieee754_atan2+0x42>
  226a54:	a30e      	add	r3, pc, #56	; (adr r3, 226a90 <__ieee754_atan2+0x180>)
  226a56:	e9d3 2300 	ldrd	r2, r3, [r3]
  226a5a:	e7ea      	b.n	226a32 <__ieee754_atan2+0x122>
  226a5c:	2200      	movs	r2, #0
  226a5e:	2300      	movs	r3, #0
  226a60:	e7e7      	b.n	226a32 <__ieee754_atan2+0x122>
  226a62:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
  226a66:	e792      	b.n	22698e <__ieee754_atan2+0x7e>
  226a68:	ed9f 7b19 	vldr	d7, [pc, #100]	; 226ad0 <__ieee754_atan2+0x1c0>
  226a6c:	ec43 2b16 	vmov	d6, r2, r3
  226a70:	ee36 7b47 	vsub.f64	d7, d6, d7
  226a74:	ed9f 6b14 	vldr	d6, [pc, #80]	; 226ac8 <__ieee754_atan2+0x1b8>
  226a78:	ee36 7b47 	vsub.f64	d7, d6, d7
  226a7c:	e769      	b.n	226952 <__ieee754_atan2+0x42>
  226a7e:	bf00      	nop
  226a80:	54442d18 	.word	0x54442d18
  226a84:	c00921fb 	.word	0xc00921fb
  226a88:	54442d18 	.word	0x54442d18
  226a8c:	bff921fb 	.word	0xbff921fb
  226a90:	54442d18 	.word	0x54442d18
  226a94:	3ff921fb 	.word	0x3ff921fb
  226a98:	54442d18 	.word	0x54442d18
  226a9c:	3fe921fb 	.word	0x3fe921fb
  226aa0:	54442d18 	.word	0x54442d18
  226aa4:	bfe921fb 	.word	0xbfe921fb
  226aa8:	7f3321d2 	.word	0x7f3321d2
  226aac:	4002d97c 	.word	0x4002d97c
  226ab0:	7f3321d2 	.word	0x7f3321d2
  226ab4:	c002d97c 	.word	0xc002d97c
	...
  226ac4:	80000000 	.word	0x80000000
  226ac8:	54442d18 	.word	0x54442d18
  226acc:	400921fb 	.word	0x400921fb
  226ad0:	33145c07 	.word	0x33145c07
  226ad4:	3ca1a626 	.word	0x3ca1a626
  226ad8:	7ff00000 	.word	0x7ff00000
  226adc:	00000000 	.word	0x00000000

00226ae0 <__ieee754_pow>:
  226ae0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  226ae4:	ec57 6b11 	vmov	r6, r7, d1
  226ae8:	ed2d 8b02 	vpush	{d8}
  226aec:	eeb0 8b40 	vmov.f64	d8, d0
  226af0:	f027 4800 	bic.w	r8, r7, #2147483648	; 0x80000000
  226af4:	ea58 0306 	orrs.w	r3, r8, r6
  226af8:	b085      	sub	sp, #20
  226afa:	ee10 ba10 	vmov	fp, s0
  226afe:	ee18 9a90 	vmov	r9, s17
  226b02:	ee11 2a10 	vmov	r2, s2
  226b06:	46ba      	mov	sl, r7
  226b08:	f000 8303 	beq.w	227112 <__ieee754_pow+0x632>
  226b0c:	4bb8      	ldr	r3, [pc, #736]	; (226df0 <__ieee754_pow+0x310>)
  226b0e:	f029 4400 	bic.w	r4, r9, #2147483648	; 0x80000000
  226b12:	429c      	cmp	r4, r3
  226b14:	dc0b      	bgt.n	226b2e <__ieee754_pow+0x4e>
  226b16:	d105      	bne.n	226b24 <__ieee754_pow+0x44>
  226b18:	f1bb 0f00 	cmp.w	fp, #0
  226b1c:	d107      	bne.n	226b2e <__ieee754_pow+0x4e>
  226b1e:	45a0      	cmp	r8, r4
  226b20:	dc0d      	bgt.n	226b3e <__ieee754_pow+0x5e>
  226b22:	e001      	b.n	226b28 <__ieee754_pow+0x48>
  226b24:	4598      	cmp	r8, r3
  226b26:	dc02      	bgt.n	226b2e <__ieee754_pow+0x4e>
  226b28:	4598      	cmp	r8, r3
  226b2a:	d110      	bne.n	226b4e <__ieee754_pow+0x6e>
  226b2c:	b17a      	cbz	r2, 226b4e <__ieee754_pow+0x6e>
  226b2e:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
  226b32:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
  226b36:	ea54 030b 	orrs.w	r3, r4, fp
  226b3a:	f000 82ea 	beq.w	227112 <__ieee754_pow+0x632>
  226b3e:	48ad      	ldr	r0, [pc, #692]	; (226df4 <__ieee754_pow+0x314>)
  226b40:	b005      	add	sp, #20
  226b42:	ecbd 8b02 	vpop	{d8}
  226b46:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  226b4a:	f001 ba35 	b.w	227fb8 <nan>
  226b4e:	f1b9 0f00 	cmp.w	r9, #0
  226b52:	da50      	bge.n	226bf6 <__ieee754_pow+0x116>
  226b54:	4ba8      	ldr	r3, [pc, #672]	; (226df8 <__ieee754_pow+0x318>)
  226b56:	4598      	cmp	r8, r3
  226b58:	dc4b      	bgt.n	226bf2 <__ieee754_pow+0x112>
  226b5a:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
  226b5e:	4598      	cmp	r8, r3
  226b60:	dd49      	ble.n	226bf6 <__ieee754_pow+0x116>
  226b62:	ea4f 5328 	mov.w	r3, r8, asr #20
  226b66:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
  226b6a:	2b14      	cmp	r3, #20
  226b6c:	dd24      	ble.n	226bb8 <__ieee754_pow+0xd8>
  226b6e:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
  226b72:	fa22 f503 	lsr.w	r5, r2, r3
  226b76:	fa05 f303 	lsl.w	r3, r5, r3
  226b7a:	429a      	cmp	r2, r3
  226b7c:	d13b      	bne.n	226bf6 <__ieee754_pow+0x116>
  226b7e:	f005 0501 	and.w	r5, r5, #1
  226b82:	f1c5 0502 	rsb	r5, r5, #2
  226b86:	2a00      	cmp	r2, #0
  226b88:	d15c      	bne.n	226c44 <__ieee754_pow+0x164>
  226b8a:	4b99      	ldr	r3, [pc, #612]	; (226df0 <__ieee754_pow+0x310>)
  226b8c:	4598      	cmp	r8, r3
  226b8e:	d122      	bne.n	226bd6 <__ieee754_pow+0xf6>
  226b90:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
  226b94:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
  226b98:	ea53 030b 	orrs.w	r3, r3, fp
  226b9c:	f000 82b9 	beq.w	227112 <__ieee754_pow+0x632>
  226ba0:	4b96      	ldr	r3, [pc, #600]	; (226dfc <__ieee754_pow+0x31c>)
  226ba2:	429c      	cmp	r4, r3
  226ba4:	dd29      	ble.n	226bfa <__ieee754_pow+0x11a>
  226ba6:	f1ba 0f00 	cmp.w	sl, #0
  226baa:	f280 82b5 	bge.w	227118 <__ieee754_pow+0x638>
  226bae:	ed9f 7b84 	vldr	d7, [pc, #528]	; 226dc0 <__ieee754_pow+0x2e0>
  226bb2:	ed8d 7b00 	vstr	d7, [sp]
  226bb6:	e028      	b.n	226c0a <__ieee754_pow+0x12a>
  226bb8:	2a00      	cmp	r2, #0
  226bba:	d142      	bne.n	226c42 <__ieee754_pow+0x162>
  226bbc:	f1c3 0314 	rsb	r3, r3, #20
  226bc0:	fa48 f503 	asr.w	r5, r8, r3
  226bc4:	fa05 f303 	lsl.w	r3, r5, r3
  226bc8:	4598      	cmp	r8, r3
  226bca:	f040 82ab 	bne.w	227124 <__ieee754_pow+0x644>
  226bce:	f005 0501 	and.w	r5, r5, #1
  226bd2:	f1c5 0502 	rsb	r5, r5, #2
  226bd6:	4b8a      	ldr	r3, [pc, #552]	; (226e00 <__ieee754_pow+0x320>)
  226bd8:	4598      	cmp	r8, r3
  226bda:	d11d      	bne.n	226c18 <__ieee754_pow+0x138>
  226bdc:	f1ba 0f00 	cmp.w	sl, #0
  226be0:	f280 829d 	bge.w	22711e <__ieee754_pow+0x63e>
  226be4:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
  226be8:	ee87 6b08 	vdiv.f64	d6, d7, d8
  226bec:	ed8d 6b00 	vstr	d6, [sp]
  226bf0:	e00b      	b.n	226c0a <__ieee754_pow+0x12a>
  226bf2:	2502      	movs	r5, #2
  226bf4:	e7c7      	b.n	226b86 <__ieee754_pow+0xa6>
  226bf6:	2500      	movs	r5, #0
  226bf8:	e7c5      	b.n	226b86 <__ieee754_pow+0xa6>
  226bfa:	f1ba 0f00 	cmp.w	sl, #0
  226bfe:	dad6      	bge.n	226bae <__ieee754_pow+0xce>
  226c00:	f087 4400 	eor.w	r4, r7, #2147483648	; 0x80000000
  226c04:	4633      	mov	r3, r6
  226c06:	e88d 0018 	stmia.w	sp, {r3, r4}
  226c0a:	ed9d 0b00 	vldr	d0, [sp]
  226c0e:	b005      	add	sp, #20
  226c10:	ecbd 8b02 	vpop	{d8}
  226c14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  226c18:	f1ba 4f80 	cmp.w	sl, #1073741824	; 0x40000000
  226c1c:	d102      	bne.n	226c24 <__ieee754_pow+0x144>
  226c1e:	ee28 7b08 	vmul.f64	d7, d8, d8
  226c22:	e7c6      	b.n	226bb2 <__ieee754_pow+0xd2>
  226c24:	4b77      	ldr	r3, [pc, #476]	; (226e04 <__ieee754_pow+0x324>)
  226c26:	459a      	cmp	sl, r3
  226c28:	d10c      	bne.n	226c44 <__ieee754_pow+0x164>
  226c2a:	f1b9 0f00 	cmp.w	r9, #0
  226c2e:	db09      	blt.n	226c44 <__ieee754_pow+0x164>
  226c30:	eeb0 0b48 	vmov.f64	d0, d8
  226c34:	b005      	add	sp, #20
  226c36:	ecbd 8b02 	vpop	{d8}
  226c3a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  226c3e:	f000 bc17 	b.w	227470 <__ieee754_sqrt>
  226c42:	2500      	movs	r5, #0
  226c44:	eeb0 0b48 	vmov.f64	d0, d8
  226c48:	f001 f928 	bl	227e9c <fabs>
  226c4c:	ed8d 0b00 	vstr	d0, [sp]
  226c50:	f1bb 0f00 	cmp.w	fp, #0
  226c54:	d128      	bne.n	226ca8 <__ieee754_pow+0x1c8>
  226c56:	b124      	cbz	r4, 226c62 <__ieee754_pow+0x182>
  226c58:	4b69      	ldr	r3, [pc, #420]	; (226e00 <__ieee754_pow+0x320>)
  226c5a:	f029 4240 	bic.w	r2, r9, #3221225472	; 0xc0000000
  226c5e:	429a      	cmp	r2, r3
  226c60:	d122      	bne.n	226ca8 <__ieee754_pow+0x1c8>
  226c62:	f1ba 0f00 	cmp.w	sl, #0
  226c66:	da07      	bge.n	226c78 <__ieee754_pow+0x198>
  226c68:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
  226c6c:	ed9d 5b00 	vldr	d5, [sp]
  226c70:	ee87 6b05 	vdiv.f64	d6, d7, d5
  226c74:	ed8d 6b00 	vstr	d6, [sp]
  226c78:	f1b9 0f00 	cmp.w	r9, #0
  226c7c:	dac5      	bge.n	226c0a <__ieee754_pow+0x12a>
  226c7e:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
  226c82:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
  226c86:	ea54 0305 	orrs.w	r3, r4, r5
  226c8a:	d106      	bne.n	226c9a <__ieee754_pow+0x1ba>
  226c8c:	ed9d 7b00 	vldr	d7, [sp]
  226c90:	ee37 7b47 	vsub.f64	d7, d7, d7
  226c94:	ee87 6b07 	vdiv.f64	d6, d7, d7
  226c98:	e7a8      	b.n	226bec <__ieee754_pow+0x10c>
  226c9a:	2d01      	cmp	r5, #1
  226c9c:	d1b5      	bne.n	226c0a <__ieee754_pow+0x12a>
  226c9e:	ed9d 7b00 	vldr	d7, [sp]
  226ca2:	eeb1 7b47 	vneg.f64	d7, d7
  226ca6:	e784      	b.n	226bb2 <__ieee754_pow+0xd2>
  226ca8:	ea4f 79d9 	mov.w	r9, r9, lsr #31
  226cac:	f109 30ff 	add.w	r0, r9, #4294967295
  226cb0:	ea55 0300 	orrs.w	r3, r5, r0
  226cb4:	d104      	bne.n	226cc0 <__ieee754_pow+0x1e0>
  226cb6:	ee38 8b48 	vsub.f64	d8, d8, d8
  226cba:	ee88 7b08 	vdiv.f64	d7, d8, d8
  226cbe:	e778      	b.n	226bb2 <__ieee754_pow+0xd2>
  226cc0:	4b51      	ldr	r3, [pc, #324]	; (226e08 <__ieee754_pow+0x328>)
  226cc2:	4598      	cmp	r8, r3
  226cc4:	f340 80a6 	ble.w	226e14 <__ieee754_pow+0x334>
  226cc8:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
  226ccc:	4598      	cmp	r8, r3
  226cce:	dd0b      	ble.n	226ce8 <__ieee754_pow+0x208>
  226cd0:	4b4a      	ldr	r3, [pc, #296]	; (226dfc <__ieee754_pow+0x31c>)
  226cd2:	429c      	cmp	r4, r3
  226cd4:	dc0e      	bgt.n	226cf4 <__ieee754_pow+0x214>
  226cd6:	f1ba 0f00 	cmp.w	sl, #0
  226cda:	f6bf af68 	bge.w	226bae <__ieee754_pow+0xce>
  226cde:	ed9f 7b3a 	vldr	d7, [pc, #232]	; 226dc8 <__ieee754_pow+0x2e8>
  226ce2:	ee27 7b07 	vmul.f64	d7, d7, d7
  226ce6:	e764      	b.n	226bb2 <__ieee754_pow+0xd2>
  226ce8:	4b48      	ldr	r3, [pc, #288]	; (226e0c <__ieee754_pow+0x32c>)
  226cea:	429c      	cmp	r4, r3
  226cec:	ddf3      	ble.n	226cd6 <__ieee754_pow+0x1f6>
  226cee:	4b44      	ldr	r3, [pc, #272]	; (226e00 <__ieee754_pow+0x320>)
  226cf0:	429c      	cmp	r4, r3
  226cf2:	dd03      	ble.n	226cfc <__ieee754_pow+0x21c>
  226cf4:	f1ba 0f00 	cmp.w	sl, #0
  226cf8:	dcf1      	bgt.n	226cde <__ieee754_pow+0x1fe>
  226cfa:	e758      	b.n	226bae <__ieee754_pow+0xce>
  226cfc:	ed9d 7b00 	vldr	d7, [sp]
  226d00:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
  226d04:	ed9f 5b32 	vldr	d5, [pc, #200]	; 226dd0 <__ieee754_pow+0x2f0>
  226d08:	ee37 6b46 	vsub.f64	d6, d7, d6
  226d0c:	eeb5 7b00 	vmov.f64	d7, #80	; 0x3e800000  0.250
  226d10:	eeb1 3b46 	vneg.f64	d3, d6
  226d14:	eea3 5b07 	vfma.f64	d5, d3, d7
  226d18:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  226d1c:	eea3 7b05 	vfma.f64	d7, d3, d5
  226d20:	ee26 5b06 	vmul.f64	d5, d6, d6
  226d24:	ee27 5b05 	vmul.f64	d5, d7, d5
  226d28:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 226dd8 <__ieee754_pow+0x2f8>
  226d2c:	ee27 7b45 	vnmul.f64	d7, d7, d5
  226d30:	ed9f 5b2b 	vldr	d5, [pc, #172]	; 226de0 <__ieee754_pow+0x300>
  226d34:	eea6 7b05 	vfma.f64	d7, d6, d5
  226d38:	ed9f 5b2b 	vldr	d5, [pc, #172]	; 226de8 <__ieee754_pow+0x308>
  226d3c:	eeb0 4b47 	vmov.f64	d4, d7
  226d40:	eea6 4b05 	vfma.f64	d4, d6, d5
  226d44:	ec53 2b14 	vmov	r2, r3, d4
  226d48:	2200      	movs	r2, #0
  226d4a:	ec43 2b14 	vmov	d4, r2, r3
  226d4e:	eeb0 6b44 	vmov.f64	d6, d4
  226d52:	eea3 6b05 	vfma.f64	d6, d3, d5
  226d56:	ee37 7b46 	vsub.f64	d7, d7, d6
  226d5a:	3d01      	subs	r5, #1
  226d5c:	ea55 0300 	orrs.w	r3, r5, r0
  226d60:	f04f 0200 	mov.w	r2, #0
  226d64:	463b      	mov	r3, r7
  226d66:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
  226d6a:	ec47 6b15 	vmov	d5, r6, r7
  226d6e:	eeb7 8b00 	vmov.f64	d8, #112	; 0x3f800000  1.0
  226d72:	bf08      	it	eq
  226d74:	eeb0 8b46 	vmoveq.f64	d8, d6
  226d78:	ec43 2b16 	vmov	d6, r2, r3
  226d7c:	ee27 7b05 	vmul.f64	d7, d7, d5
  226d80:	4b23      	ldr	r3, [pc, #140]	; (226e10 <__ieee754_pow+0x330>)
  226d82:	ee35 5b46 	vsub.f64	d5, d5, d6
  226d86:	ee24 6b06 	vmul.f64	d6, d4, d6
  226d8a:	eea4 7b05 	vfma.f64	d7, d4, d5
  226d8e:	ee37 5b06 	vadd.f64	d5, d7, d6
  226d92:	ee15 1a90 	vmov	r1, s11
  226d96:	4299      	cmp	r1, r3
  226d98:	ee15 2a10 	vmov	r2, s10
  226d9c:	f340 819b 	ble.w	2270d6 <__ieee754_pow+0x5f6>
  226da0:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
  226da4:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
  226da8:	4313      	orrs	r3, r2
  226daa:	f000 810a 	beq.w	226fc2 <__ieee754_pow+0x4e2>
  226dae:	ed9f 7b06 	vldr	d7, [pc, #24]	; 226dc8 <__ieee754_pow+0x2e8>
  226db2:	ee28 8b07 	vmul.f64	d8, d8, d7
  226db6:	ee28 7b07 	vmul.f64	d7, d8, d7
  226dba:	e6fa      	b.n	226bb2 <__ieee754_pow+0xd2>
  226dbc:	f3af 8000 	nop.w
	...
  226dc8:	8800759c 	.word	0x8800759c
  226dcc:	7e37e43c 	.word	0x7e37e43c
  226dd0:	55555555 	.word	0x55555555
  226dd4:	3fd55555 	.word	0x3fd55555
  226dd8:	652b82fe 	.word	0x652b82fe
  226ddc:	3ff71547 	.word	0x3ff71547
  226de0:	f85ddf44 	.word	0xf85ddf44
  226de4:	3e54ae0b 	.word	0x3e54ae0b
  226de8:	60000000 	.word	0x60000000
  226dec:	3ff71547 	.word	0x3ff71547
  226df0:	7ff00000 	.word	0x7ff00000
  226df4:	0022980c 	.word	0x0022980c
  226df8:	433fffff 	.word	0x433fffff
  226dfc:	3fefffff 	.word	0x3fefffff
  226e00:	3ff00000 	.word	0x3ff00000
  226e04:	3fe00000 	.word	0x3fe00000
  226e08:	41e00000 	.word	0x41e00000
  226e0c:	3feffffe 	.word	0x3feffffe
  226e10:	408fffff 	.word	0x408fffff
  226e14:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
  226e18:	f280 80cf 	bge.w	226fba <__ieee754_pow+0x4da>
  226e1c:	ed9d 6b00 	vldr	d6, [sp]
  226e20:	ed9f 7bc1 	vldr	d7, [pc, #772]	; 227128 <__ieee754_pow+0x648>
  226e24:	ee26 7b07 	vmul.f64	d7, d6, d7
  226e28:	ed8d 7b00 	vstr	d7, [sp]
  226e2c:	9c01      	ldr	r4, [sp, #4]
  226e2e:	f06f 0334 	mvn.w	r3, #52	; 0x34
  226e32:	1521      	asrs	r1, r4, #20
  226e34:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
  226e38:	4419      	add	r1, r3
  226e3a:	4be3      	ldr	r3, [pc, #908]	; (2271c8 <__ieee754_pow+0x6e8>)
  226e3c:	f3c4 0413 	ubfx	r4, r4, #0, #20
  226e40:	f044 5e7f 	orr.w	lr, r4, #1069547520	; 0x3fc00000
  226e44:	429c      	cmp	r4, r3
  226e46:	f44e 1e40 	orr.w	lr, lr, #3145728	; 0x300000
  226e4a:	dd06      	ble.n	226e5a <__ieee754_pow+0x37a>
  226e4c:	4bdf      	ldr	r3, [pc, #892]	; (2271cc <__ieee754_pow+0x6ec>)
  226e4e:	429c      	cmp	r4, r3
  226e50:	f340 80b5 	ble.w	226fbe <__ieee754_pow+0x4de>
  226e54:	3101      	adds	r1, #1
  226e56:	f5ae 1e80 	sub.w	lr, lr, #1048576	; 0x100000
  226e5a:	2400      	movs	r4, #0
  226e5c:	e9dd 2300 	ldrd	r2, r3, [sp]
  226e60:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
  226e64:	4673      	mov	r3, lr
  226e66:	ec43 2b17 	vmov	d7, r2, r3
  226e6a:	4bd9      	ldr	r3, [pc, #868]	; (2271d0 <__ieee754_pow+0x6f0>)
  226e6c:	ea4f 0cc4 	mov.w	ip, r4, lsl #3
  226e70:	4463      	add	r3, ip
  226e72:	ed93 5b00 	vldr	d5, [r3]
  226e76:	ea4f 0e6e 	mov.w	lr, lr, asr #1
  226e7a:	ee37 2b45 	vsub.f64	d2, d7, d5
  226e7e:	ee37 6b05 	vadd.f64	d6, d7, d5
  226e82:	ee84 1b06 	vdiv.f64	d1, d4, d6
  226e86:	ee22 6b01 	vmul.f64	d6, d2, d1
  226e8a:	ed8d 6b00 	vstr	d6, [sp]
  226e8e:	e9dd 8900 	ldrd	r8, r9, [sp]
  226e92:	f04e 5e00 	orr.w	lr, lr, #536870912	; 0x20000000
  226e96:	f50e 2e00 	add.w	lr, lr, #524288	; 0x80000
  226e9a:	f04f 0800 	mov.w	r8, #0
  226e9e:	eb0e 4384 	add.w	r3, lr, r4, lsl #18
  226ea2:	2200      	movs	r2, #0
  226ea4:	ec49 8b14 	vmov	d4, r8, r9
  226ea8:	ec43 2b16 	vmov	d6, r2, r3
  226eac:	eeb1 3b44 	vneg.f64	d3, d4
  226eb0:	eea3 2b06 	vfma.f64	d2, d3, d6
  226eb4:	ee36 6b45 	vsub.f64	d6, d6, d5
  226eb8:	ee37 7b46 	vsub.f64	d7, d7, d6
  226ebc:	eea3 2b07 	vfma.f64	d2, d3, d7
  226ec0:	ed9d 7b00 	vldr	d7, [sp]
  226ec4:	ee22 2b01 	vmul.f64	d2, d2, d1
  226ec8:	ee27 5b07 	vmul.f64	d5, d7, d7
  226ecc:	ee37 6b04 	vadd.f64	d6, d7, d4
  226ed0:	ed9f 1b97 	vldr	d1, [pc, #604]	; 227130 <__ieee754_pow+0x650>
  226ed4:	ee25 0b05 	vmul.f64	d0, d5, d5
  226ed8:	ee26 6b02 	vmul.f64	d6, d6, d2
  226edc:	ed9f 7b96 	vldr	d7, [pc, #600]	; 227138 <__ieee754_pow+0x658>
  226ee0:	eea5 7b01 	vfma.f64	d7, d5, d1
  226ee4:	ed9f 1b96 	vldr	d1, [pc, #600]	; 227140 <__ieee754_pow+0x660>
  226ee8:	eea5 1b07 	vfma.f64	d1, d5, d7
  226eec:	ed9f 7b96 	vldr	d7, [pc, #600]	; 227148 <__ieee754_pow+0x668>
  226ef0:	eea5 7b01 	vfma.f64	d7, d5, d1
  226ef4:	ed9f 1b96 	vldr	d1, [pc, #600]	; 227150 <__ieee754_pow+0x670>
  226ef8:	eea5 1b07 	vfma.f64	d1, d5, d7
  226efc:	ed9f 7b96 	vldr	d7, [pc, #600]	; 227158 <__ieee754_pow+0x678>
  226f00:	eea5 7b01 	vfma.f64	d7, d5, d1
  226f04:	eea0 6b07 	vfma.f64	d6, d0, d7
  226f08:	eeb0 7b08 	vmov.f64	d7, #8	; 0x40400000  3.0
  226f0c:	eeb0 5b47 	vmov.f64	d5, d7
  226f10:	eea4 5b04 	vfma.f64	d5, d4, d4
  226f14:	ee35 5b06 	vadd.f64	d5, d5, d6
  226f18:	ed8d 5b02 	vstr	d5, [sp, #8]
  226f1c:	f8cd 8008 	str.w	r8, [sp, #8]
  226f20:	ed9d 5b02 	vldr	d5, [sp, #8]
  226f24:	ee35 7b47 	vsub.f64	d7, d5, d7
  226f28:	eea3 7b04 	vfma.f64	d7, d3, d4
  226f2c:	ee36 7b47 	vsub.f64	d7, d6, d7
  226f30:	ed9d 6b00 	vldr	d6, [sp]
  226f34:	ee27 7b06 	vmul.f64	d7, d7, d6
  226f38:	eea2 7b05 	vfma.f64	d7, d2, d5
  226f3c:	eeb0 6b47 	vmov.f64	d6, d7
  226f40:	eea4 6b05 	vfma.f64	d6, d4, d5
  226f44:	ed8d 6b00 	vstr	d6, [sp]
  226f48:	f8cd 8000 	str.w	r8, [sp]
  226f4c:	ed9d 2b00 	vldr	d2, [sp]
  226f50:	eeb0 6b42 	vmov.f64	d6, d2
  226f54:	eea3 6b05 	vfma.f64	d6, d3, d5
  226f58:	ee37 7b46 	vsub.f64	d7, d7, d6
  226f5c:	ed9f 6b80 	vldr	d6, [pc, #512]	; 227160 <__ieee754_pow+0x680>
  226f60:	4b9c      	ldr	r3, [pc, #624]	; (2271d4 <__ieee754_pow+0x6f4>)
  226f62:	ee27 7b06 	vmul.f64	d7, d7, d6
  226f66:	ed9f 6b80 	vldr	d6, [pc, #512]	; 227168 <__ieee754_pow+0x688>
  226f6a:	4463      	add	r3, ip
  226f6c:	eea2 7b06 	vfma.f64	d7, d2, d6
  226f70:	ed93 6b00 	vldr	d6, [r3]
  226f74:	4b98      	ldr	r3, [pc, #608]	; (2271d8 <__ieee754_pow+0x6f8>)
  226f76:	ee37 6b06 	vadd.f64	d6, d7, d6
  226f7a:	449c      	add	ip, r3
  226f7c:	ed9c 1b00 	vldr	d1, [ip]
  226f80:	eeb0 4b46 	vmov.f64	d4, d6
  226f84:	ed9f 3b7a 	vldr	d3, [pc, #488]	; 227170 <__ieee754_pow+0x690>
  226f88:	ee07 1a90 	vmov	s15, r1
  226f8c:	eea2 4b03 	vfma.f64	d4, d2, d3
  226f90:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  226f94:	ee34 4b01 	vadd.f64	d4, d4, d1
  226f98:	ee34 5b07 	vadd.f64	d5, d4, d7
  226f9c:	ed8d 5b00 	vstr	d5, [sp]
  226fa0:	f8cd 8000 	str.w	r8, [sp]
  226fa4:	ed9d 4b00 	vldr	d4, [sp]
  226fa8:	ee34 7b47 	vsub.f64	d7, d4, d7
  226fac:	ee37 7b41 	vsub.f64	d7, d7, d1
  226fb0:	eea2 7b43 	vfms.f64	d7, d2, d3
  226fb4:	ee36 7b47 	vsub.f64	d7, d6, d7
  226fb8:	e6cf      	b.n	226d5a <__ieee754_pow+0x27a>
  226fba:	2300      	movs	r3, #0
  226fbc:	e739      	b.n	226e32 <__ieee754_pow+0x352>
  226fbe:	2401      	movs	r4, #1
  226fc0:	e74c      	b.n	226e5c <__ieee754_pow+0x37c>
  226fc2:	ed9f 4b6d 	vldr	d4, [pc, #436]	; 227178 <__ieee754_pow+0x698>
  226fc6:	ee35 5b46 	vsub.f64	d5, d5, d6
  226fca:	ee37 4b04 	vadd.f64	d4, d7, d4
  226fce:	eeb4 4bc5 	vcmpe.f64	d4, d5
  226fd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  226fd6:	f73f aeea 	bgt.w	226dae <__ieee754_pow+0x2ce>
  226fda:	4a80      	ldr	r2, [pc, #512]	; (2271dc <__ieee754_pow+0x6fc>)
  226fdc:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
  226fe0:	4293      	cmp	r3, r2
  226fe2:	f340 808e 	ble.w	227102 <__ieee754_pow+0x622>
  226fe6:	151b      	asrs	r3, r3, #20
  226fe8:	f2a3 30fe 	subw	r0, r3, #1022	; 0x3fe
  226fec:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
  226ff0:	4103      	asrs	r3, r0
  226ff2:	440b      	add	r3, r1
  226ff4:	f3c3 520a 	ubfx	r2, r3, #20, #11
  226ff8:	4879      	ldr	r0, [pc, #484]	; (2271e0 <__ieee754_pow+0x700>)
  226ffa:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
  226ffe:	4110      	asrs	r0, r2
  227000:	ea23 0500 	bic.w	r5, r3, r0
  227004:	f3c3 0013 	ubfx	r0, r3, #0, #20
  227008:	2400      	movs	r4, #0
  22700a:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  22700e:	f1c2 0214 	rsb	r2, r2, #20
  227012:	ec45 4b15 	vmov	d5, r4, r5
  227016:	4110      	asrs	r0, r2
  227018:	2900      	cmp	r1, #0
  22701a:	bfb8      	it	lt
  22701c:	4240      	neglt	r0, r0
  22701e:	ee36 6b45 	vsub.f64	d6, d6, d5
  227022:	ee36 5b07 	vadd.f64	d5, d6, d7
  227026:	ec53 2b15 	vmov	r2, r3, d5
  22702a:	2200      	movs	r2, #0
  22702c:	ec43 2b15 	vmov	d5, r2, r3
  227030:	ed9f 4b53 	vldr	d4, [pc, #332]	; 227180 <__ieee754_pow+0x6a0>
  227034:	ee35 6b46 	vsub.f64	d6, d5, d6
  227038:	ee37 6b46 	vsub.f64	d6, d7, d6
  22703c:	ed9f 7b52 	vldr	d7, [pc, #328]	; 227188 <__ieee754_pow+0x6a8>
  227040:	ee25 7b07 	vmul.f64	d7, d5, d7
  227044:	eea6 7b04 	vfma.f64	d7, d6, d4
  227048:	ed9f 6b51 	vldr	d6, [pc, #324]	; 227190 <__ieee754_pow+0x6b0>
  22704c:	eeb0 4b47 	vmov.f64	d4, d7
  227050:	eea5 4b06 	vfma.f64	d4, d5, d6
  227054:	eeb0 3b44 	vmov.f64	d3, d4
  227058:	eea5 3b46 	vfms.f64	d3, d5, d6
  22705c:	ed9f 5b4e 	vldr	d5, [pc, #312]	; 227198 <__ieee754_pow+0x6b8>
  227060:	ee37 7b43 	vsub.f64	d7, d7, d3
  227064:	ee24 6b04 	vmul.f64	d6, d4, d4
  227068:	ed9f 3b4d 	vldr	d3, [pc, #308]	; 2271a0 <__ieee754_pow+0x6c0>
  22706c:	eea4 7b07 	vfma.f64	d7, d4, d7
  227070:	eea6 3b05 	vfma.f64	d3, d6, d5
  227074:	ed9f 5b4c 	vldr	d5, [pc, #304]	; 2271a8 <__ieee754_pow+0x6c8>
  227078:	eea6 5b03 	vfma.f64	d5, d6, d3
  22707c:	ed9f 3b4c 	vldr	d3, [pc, #304]	; 2271b0 <__ieee754_pow+0x6d0>
  227080:	eea6 3b05 	vfma.f64	d3, d6, d5
  227084:	ed9f 5b4c 	vldr	d5, [pc, #304]	; 2271b8 <__ieee754_pow+0x6d8>
  227088:	eea6 5b03 	vfma.f64	d5, d6, d3
  22708c:	eeb0 3b44 	vmov.f64	d3, d4
  227090:	eea6 3b45 	vfms.f64	d3, d6, d5
  227094:	eeb0 5b00 	vmov.f64	d5, #0	; 0x40000000  2.0
  227098:	eeb0 6b43 	vmov.f64	d6, d3
  22709c:	ee24 3b03 	vmul.f64	d3, d4, d3
  2270a0:	ee36 5b45 	vsub.f64	d5, d6, d5
  2270a4:	ee83 6b05 	vdiv.f64	d6, d3, d5
  2270a8:	ee36 7b47 	vsub.f64	d7, d6, d7
  2270ac:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
  2270b0:	ee37 7b44 	vsub.f64	d7, d7, d4
  2270b4:	ee36 7b47 	vsub.f64	d7, d6, d7
  2270b8:	ed8d 7b00 	vstr	d7, [sp]
  2270bc:	9901      	ldr	r1, [sp, #4]
  2270be:	eb01 5100 	add.w	r1, r1, r0, lsl #20
  2270c2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
  2270c6:	da1e      	bge.n	227106 <__ieee754_pow+0x626>
  2270c8:	eeb0 0b47 	vmov.f64	d0, d7
  2270cc:	f001 f808 	bl	2280e0 <scalbn>
  2270d0:	ee20 7b08 	vmul.f64	d7, d0, d8
  2270d4:	e56d      	b.n	226bb2 <__ieee754_pow+0xd2>
  2270d6:	4b43      	ldr	r3, [pc, #268]	; (2271e4 <__ieee754_pow+0x704>)
  2270d8:	f021 4000 	bic.w	r0, r1, #2147483648	; 0x80000000
  2270dc:	4298      	cmp	r0, r3
  2270de:	f77f af7c 	ble.w	226fda <__ieee754_pow+0x4fa>
  2270e2:	4b41      	ldr	r3, [pc, #260]	; (2271e8 <__ieee754_pow+0x708>)
  2270e4:	440b      	add	r3, r1
  2270e6:	4313      	orrs	r3, r2
  2270e8:	d002      	beq.n	2270f0 <__ieee754_pow+0x610>
  2270ea:	ed9f 7b35 	vldr	d7, [pc, #212]	; 2271c0 <__ieee754_pow+0x6e0>
  2270ee:	e660      	b.n	226db2 <__ieee754_pow+0x2d2>
  2270f0:	ee35 5b46 	vsub.f64	d5, d5, d6
  2270f4:	eeb4 7bc5 	vcmpe.f64	d7, d5
  2270f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2270fc:	f63f af6d 	bhi.w	226fda <__ieee754_pow+0x4fa>
  227100:	e7f3      	b.n	2270ea <__ieee754_pow+0x60a>
  227102:	2000      	movs	r0, #0
  227104:	e78d      	b.n	227022 <__ieee754_pow+0x542>
  227106:	e9dd 2300 	ldrd	r2, r3, [sp]
  22710a:	460b      	mov	r3, r1
  22710c:	ec43 2b10 	vmov	d0, r2, r3
  227110:	e7de      	b.n	2270d0 <__ieee754_pow+0x5f0>
  227112:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
  227116:	e54c      	b.n	226bb2 <__ieee754_pow+0xd2>
  227118:	e9cd 6700 	strd	r6, r7, [sp]
  22711c:	e575      	b.n	226c0a <__ieee754_pow+0x12a>
  22711e:	ed8d 8b00 	vstr	d8, [sp]
  227122:	e572      	b.n	226c0a <__ieee754_pow+0x12a>
  227124:	4615      	mov	r5, r2
  227126:	e556      	b.n	226bd6 <__ieee754_pow+0xf6>
  227128:	00000000 	.word	0x00000000
  22712c:	43400000 	.word	0x43400000
  227130:	4a454eef 	.word	0x4a454eef
  227134:	3fca7e28 	.word	0x3fca7e28
  227138:	93c9db65 	.word	0x93c9db65
  22713c:	3fcd864a 	.word	0x3fcd864a
  227140:	a91d4101 	.word	0xa91d4101
  227144:	3fd17460 	.word	0x3fd17460
  227148:	518f264d 	.word	0x518f264d
  22714c:	3fd55555 	.word	0x3fd55555
  227150:	db6fabff 	.word	0xdb6fabff
  227154:	3fdb6db6 	.word	0x3fdb6db6
  227158:	33333303 	.word	0x33333303
  22715c:	3fe33333 	.word	0x3fe33333
  227160:	dc3a03fd 	.word	0xdc3a03fd
  227164:	3feec709 	.word	0x3feec709
  227168:	145b01f5 	.word	0x145b01f5
  22716c:	be3e2fe0 	.word	0xbe3e2fe0
  227170:	e0000000 	.word	0xe0000000
  227174:	3feec709 	.word	0x3feec709
  227178:	652b82fe 	.word	0x652b82fe
  22717c:	3c971547 	.word	0x3c971547
  227180:	fefa39ef 	.word	0xfefa39ef
  227184:	3fe62e42 	.word	0x3fe62e42
  227188:	0ca86c39 	.word	0x0ca86c39
  22718c:	be205c61 	.word	0xbe205c61
  227190:	00000000 	.word	0x00000000
  227194:	3fe62e43 	.word	0x3fe62e43
  227198:	72bea4d0 	.word	0x72bea4d0
  22719c:	3e663769 	.word	0x3e663769
  2271a0:	c5d26bf1 	.word	0xc5d26bf1
  2271a4:	bebbbd41 	.word	0xbebbbd41
  2271a8:	af25de2c 	.word	0xaf25de2c
  2271ac:	3f11566a 	.word	0x3f11566a
  2271b0:	16bebd93 	.word	0x16bebd93
  2271b4:	bf66c16c 	.word	0xbf66c16c
  2271b8:	5555553e 	.word	0x5555553e
  2271bc:	3fc55555 	.word	0x3fc55555
  2271c0:	c2f8f359 	.word	0xc2f8f359
  2271c4:	01a56e1f 	.word	0x01a56e1f
  2271c8:	0003988e 	.word	0x0003988e
  2271cc:	000bb679 	.word	0x000bb679
  2271d0:	00229810 	.word	0x00229810
  2271d4:	00229830 	.word	0x00229830
  2271d8:	00229820 	.word	0x00229820
  2271dc:	3fe00000 	.word	0x3fe00000
  2271e0:	000fffff 	.word	0x000fffff
  2271e4:	4090cbff 	.word	0x4090cbff
  2271e8:	3f6f3400 	.word	0x3f6f3400
  2271ec:	00000000 	.word	0x00000000

002271f0 <__ieee754_rem_pio2>:
  2271f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  2271f2:	eeb0 7b40 	vmov.f64	d7, d0
  2271f6:	ee17 5a90 	vmov	r5, s15
  2271fa:	4b97      	ldr	r3, [pc, #604]	; (227458 <__ieee754_rem_pio2+0x268>)
  2271fc:	f025 4600 	bic.w	r6, r5, #2147483648	; 0x80000000
  227200:	429e      	cmp	r6, r3
  227202:	b089      	sub	sp, #36	; 0x24
  227204:	4604      	mov	r4, r0
  227206:	dc07      	bgt.n	227218 <__ieee754_rem_pio2+0x28>
  227208:	2200      	movs	r2, #0
  22720a:	2300      	movs	r3, #0
  22720c:	ed84 0b00 	vstr	d0, [r4]
  227210:	e9c0 2302 	strd	r2, r3, [r0, #8]
  227214:	2000      	movs	r0, #0
  227216:	e01b      	b.n	227250 <__ieee754_rem_pio2+0x60>
  227218:	4b90      	ldr	r3, [pc, #576]	; (22745c <__ieee754_rem_pio2+0x26c>)
  22721a:	429e      	cmp	r6, r3
  22721c:	dc3b      	bgt.n	227296 <__ieee754_rem_pio2+0xa6>
  22721e:	f5a3 231b 	sub.w	r3, r3, #634880	; 0x9b000
  227222:	2d00      	cmp	r5, #0
  227224:	ed9f 6b7c 	vldr	d6, [pc, #496]	; 227418 <__ieee754_rem_pio2+0x228>
  227228:	f5a3 63f0 	sub.w	r3, r3, #1920	; 0x780
  22722c:	dd19      	ble.n	227262 <__ieee754_rem_pio2+0x72>
  22722e:	ee30 7b46 	vsub.f64	d7, d0, d6
  227232:	429e      	cmp	r6, r3
  227234:	d00e      	beq.n	227254 <__ieee754_rem_pio2+0x64>
  227236:	ed9f 6b7a 	vldr	d6, [pc, #488]	; 227420 <__ieee754_rem_pio2+0x230>
  22723a:	ee37 5b46 	vsub.f64	d5, d7, d6
  22723e:	ee37 7b45 	vsub.f64	d7, d7, d5
  227242:	ed84 5b00 	vstr	d5, [r4]
  227246:	ee37 7b46 	vsub.f64	d7, d7, d6
  22724a:	ed84 7b02 	vstr	d7, [r4, #8]
  22724e:	2001      	movs	r0, #1
  227250:	b009      	add	sp, #36	; 0x24
  227252:	bdf0      	pop	{r4, r5, r6, r7, pc}
  227254:	ed9f 6b74 	vldr	d6, [pc, #464]	; 227428 <__ieee754_rem_pio2+0x238>
  227258:	ee37 7b46 	vsub.f64	d7, d7, d6
  22725c:	ed9f 6b74 	vldr	d6, [pc, #464]	; 227430 <__ieee754_rem_pio2+0x240>
  227260:	e7eb      	b.n	22723a <__ieee754_rem_pio2+0x4a>
  227262:	429e      	cmp	r6, r3
  227264:	ee30 7b06 	vadd.f64	d7, d0, d6
  227268:	d00e      	beq.n	227288 <__ieee754_rem_pio2+0x98>
  22726a:	ed9f 6b6d 	vldr	d6, [pc, #436]	; 227420 <__ieee754_rem_pio2+0x230>
  22726e:	ee37 5b06 	vadd.f64	d5, d7, d6
  227272:	ee37 7b45 	vsub.f64	d7, d7, d5
  227276:	ed84 5b00 	vstr	d5, [r4]
  22727a:	ee37 7b06 	vadd.f64	d7, d7, d6
  22727e:	f04f 30ff 	mov.w	r0, #4294967295
  227282:	ed84 7b02 	vstr	d7, [r4, #8]
  227286:	e7e3      	b.n	227250 <__ieee754_rem_pio2+0x60>
  227288:	ed9f 6b67 	vldr	d6, [pc, #412]	; 227428 <__ieee754_rem_pio2+0x238>
  22728c:	ee37 7b06 	vadd.f64	d7, d7, d6
  227290:	ed9f 6b67 	vldr	d6, [pc, #412]	; 227430 <__ieee754_rem_pio2+0x240>
  227294:	e7eb      	b.n	22726e <__ieee754_rem_pio2+0x7e>
  227296:	4b72      	ldr	r3, [pc, #456]	; (227460 <__ieee754_rem_pio2+0x270>)
  227298:	429e      	cmp	r6, r3
  22729a:	dc6e      	bgt.n	22737a <__ieee754_rem_pio2+0x18a>
  22729c:	f000 fdfe 	bl	227e9c <fabs>
  2272a0:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  2272a4:	ed9f 6b64 	vldr	d6, [pc, #400]	; 227438 <__ieee754_rem_pio2+0x248>
  2272a8:	eea0 7b06 	vfma.f64	d7, d0, d6
  2272ac:	eefd 7bc7 	vcvt.s32.f64	s15, d7
  2272b0:	eeb8 4be7 	vcvt.f64.s32	d4, s15
  2272b4:	ee17 0a90 	vmov	r0, s15
  2272b8:	eeb1 5b44 	vneg.f64	d5, d4
  2272bc:	ed9f 7b56 	vldr	d7, [pc, #344]	; 227418 <__ieee754_rem_pio2+0x228>
  2272c0:	eea5 0b07 	vfma.f64	d0, d5, d7
  2272c4:	ed9f 7b56 	vldr	d7, [pc, #344]	; 227420 <__ieee754_rem_pio2+0x230>
  2272c8:	281f      	cmp	r0, #31
  2272ca:	ee24 7b07 	vmul.f64	d7, d4, d7
  2272ce:	ee30 6b47 	vsub.f64	d6, d0, d7
  2272d2:	dc1b      	bgt.n	22730c <__ieee754_rem_pio2+0x11c>
  2272d4:	1e42      	subs	r2, r0, #1
  2272d6:	4b63      	ldr	r3, [pc, #396]	; (227464 <__ieee754_rem_pio2+0x274>)
  2272d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
  2272dc:	429e      	cmp	r6, r3
  2272de:	d015      	beq.n	22730c <__ieee754_rem_pio2+0x11c>
  2272e0:	ed84 6b00 	vstr	d6, [r4]
  2272e4:	ed94 6b00 	vldr	d6, [r4]
  2272e8:	2d00      	cmp	r5, #0
  2272ea:	ee30 0b46 	vsub.f64	d0, d0, d6
  2272ee:	ee30 7b47 	vsub.f64	d7, d0, d7
  2272f2:	ed84 7b02 	vstr	d7, [r4, #8]
  2272f6:	daab      	bge.n	227250 <__ieee754_rem_pio2+0x60>
  2272f8:	eeb1 6b46 	vneg.f64	d6, d6
  2272fc:	ed84 6b00 	vstr	d6, [r4]
  227300:	eeb1 7b47 	vneg.f64	d7, d7
  227304:	4240      	negs	r0, r0
  227306:	ed84 7b02 	vstr	d7, [r4, #8]
  22730a:	e7a1      	b.n	227250 <__ieee754_rem_pio2+0x60>
  22730c:	ee16 3a90 	vmov	r3, s13
  227310:	1536      	asrs	r6, r6, #20
  227312:	f3c3 530a 	ubfx	r3, r3, #20, #11
  227316:	1af3      	subs	r3, r6, r3
  227318:	2b10      	cmp	r3, #16
  22731a:	ed84 6b00 	vstr	d6, [r4]
  22731e:	dde1      	ble.n	2272e4 <__ieee754_rem_pio2+0xf4>
  227320:	eeb0 6b40 	vmov.f64	d6, d0
  227324:	ed9f 3b40 	vldr	d3, [pc, #256]	; 227428 <__ieee754_rem_pio2+0x238>
  227328:	eea5 6b03 	vfma.f64	d6, d5, d3
  22732c:	ee30 7b46 	vsub.f64	d7, d0, d6
  227330:	eea5 7b03 	vfma.f64	d7, d5, d3
  227334:	ed9f 3b3e 	vldr	d3, [pc, #248]	; 227430 <__ieee754_rem_pio2+0x240>
  227338:	ee94 7b03 	vfnms.f64	d7, d4, d3
  22733c:	ee36 3b47 	vsub.f64	d3, d6, d7
  227340:	ee13 3a90 	vmov	r3, s7
  227344:	f3c3 530a 	ubfx	r3, r3, #20, #11
  227348:	1af6      	subs	r6, r6, r3
  22734a:	2e31      	cmp	r6, #49	; 0x31
  22734c:	ed84 3b00 	vstr	d3, [r4]
  227350:	dd10      	ble.n	227374 <__ieee754_rem_pio2+0x184>
  227352:	eeb0 0b46 	vmov.f64	d0, d6
  227356:	ed9f 3b3a 	vldr	d3, [pc, #232]	; 227440 <__ieee754_rem_pio2+0x250>
  22735a:	eea5 0b03 	vfma.f64	d0, d5, d3
  22735e:	ee36 7b40 	vsub.f64	d7, d6, d0
  227362:	ed9f 6b39 	vldr	d6, [pc, #228]	; 227448 <__ieee754_rem_pio2+0x258>
  227366:	eea5 7b03 	vfma.f64	d7, d5, d3
  22736a:	ee94 7b06 	vfnms.f64	d7, d4, d6
  22736e:	ee30 6b47 	vsub.f64	d6, d0, d7
  227372:	e7b5      	b.n	2272e0 <__ieee754_rem_pio2+0xf0>
  227374:	eeb0 0b46 	vmov.f64	d0, d6
  227378:	e7b4      	b.n	2272e4 <__ieee754_rem_pio2+0xf4>
  22737a:	4b3b      	ldr	r3, [pc, #236]	; (227468 <__ieee754_rem_pio2+0x278>)
  22737c:	429e      	cmp	r6, r3
  22737e:	dd06      	ble.n	22738e <__ieee754_rem_pio2+0x19e>
  227380:	ee30 7b40 	vsub.f64	d7, d0, d0
  227384:	ed80 7b02 	vstr	d7, [r0, #8]
  227388:	ed80 7b00 	vstr	d7, [r0]
  22738c:	e742      	b.n	227214 <__ieee754_rem_pio2+0x24>
  22738e:	ee10 3a10 	vmov	r3, s0
  227392:	1532      	asrs	r2, r6, #20
  227394:	f2a2 4216 	subw	r2, r2, #1046	; 0x416
  227398:	4618      	mov	r0, r3
  22739a:	eba6 5102 	sub.w	r1, r6, r2, lsl #20
  22739e:	ec41 0b17 	vmov	d7, r0, r1
  2273a2:	eebd 6bc7 	vcvt.s32.f64	s12, d7
  2273a6:	ed9f 5b2a 	vldr	d5, [pc, #168]	; 227450 <__ieee754_rem_pio2+0x260>
  2273aa:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
  2273ae:	ee37 7b46 	vsub.f64	d7, d7, d6
  2273b2:	ed8d 6b02 	vstr	d6, [sp, #8]
  2273b6:	ee27 7b05 	vmul.f64	d7, d7, d5
  2273ba:	eebd 6bc7 	vcvt.s32.f64	s12, d7
  2273be:	a908      	add	r1, sp, #32
  2273c0:	eeb8 6bc6 	vcvt.f64.s32	d6, s12
  2273c4:	ee37 7b46 	vsub.f64	d7, d7, d6
  2273c8:	ed8d 6b04 	vstr	d6, [sp, #16]
  2273cc:	ee27 7b05 	vmul.f64	d7, d7, d5
  2273d0:	ed8d 7b06 	vstr	d7, [sp, #24]
  2273d4:	2303      	movs	r3, #3
  2273d6:	ed31 7b02 	vldmdb	r1!, {d7}
  2273da:	eeb5 7b40 	vcmp.f64	d7, #0.0
  2273de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2273e2:	f103 30ff 	add.w	r0, r3, #4294967295
  2273e6:	d013      	beq.n	227410 <__ieee754_rem_pio2+0x220>
  2273e8:	4920      	ldr	r1, [pc, #128]	; (22746c <__ieee754_rem_pio2+0x27c>)
  2273ea:	9101      	str	r1, [sp, #4]
  2273ec:	2102      	movs	r1, #2
  2273ee:	9100      	str	r1, [sp, #0]
  2273f0:	a802      	add	r0, sp, #8
  2273f2:	4621      	mov	r1, r4
  2273f4:	f000 f8dc 	bl	2275b0 <__kernel_rem_pio2>
  2273f8:	2d00      	cmp	r5, #0
  2273fa:	f6bf af29 	bge.w	227250 <__ieee754_rem_pio2+0x60>
  2273fe:	ed94 7b00 	vldr	d7, [r4]
  227402:	eeb1 7b47 	vneg.f64	d7, d7
  227406:	ed84 7b00 	vstr	d7, [r4]
  22740a:	ed94 7b02 	vldr	d7, [r4, #8]
  22740e:	e777      	b.n	227300 <__ieee754_rem_pio2+0x110>
  227410:	4603      	mov	r3, r0
  227412:	e7e0      	b.n	2273d6 <__ieee754_rem_pio2+0x1e6>
  227414:	f3af 8000 	nop.w
  227418:	54400000 	.word	0x54400000
  22741c:	3ff921fb 	.word	0x3ff921fb
  227420:	1a626331 	.word	0x1a626331
  227424:	3dd0b461 	.word	0x3dd0b461
  227428:	1a600000 	.word	0x1a600000
  22742c:	3dd0b461 	.word	0x3dd0b461
  227430:	2e037073 	.word	0x2e037073
  227434:	3ba3198a 	.word	0x3ba3198a
  227438:	6dc9c883 	.word	0x6dc9c883
  22743c:	3fe45f30 	.word	0x3fe45f30
  227440:	2e000000 	.word	0x2e000000
  227444:	3ba3198a 	.word	0x3ba3198a
  227448:	252049c1 	.word	0x252049c1
  22744c:	397b839a 	.word	0x397b839a
  227450:	00000000 	.word	0x00000000
  227454:	41700000 	.word	0x41700000
  227458:	3fe921fb 	.word	0x3fe921fb
  22745c:	4002d97b 	.word	0x4002d97b
  227460:	413921fb 	.word	0x413921fb
  227464:	00229840 	.word	0x00229840
  227468:	7fefffff 	.word	0x7fefffff
  22746c:	002298c0 	.word	0x002298c0

00227470 <__ieee754_sqrt>:
  227470:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  227474:	ee10 3a90 	vmov	r3, s1
  227478:	4c4b      	ldr	r4, [pc, #300]	; (2275a8 <__ieee754_sqrt+0x138>)
  22747a:	439c      	bics	r4, r3
  22747c:	ee10 0a10 	vmov	r0, s0
  227480:	ee10 2a90 	vmov	r2, s1
  227484:	ee10 1a10 	vmov	r1, s0
  227488:	d103      	bne.n	227492 <__ieee754_sqrt+0x22>
  22748a:	eea0 0b00 	vfma.f64	d0, d0, d0
  22748e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  227492:	2b00      	cmp	r3, #0
  227494:	dc0a      	bgt.n	2274ac <__ieee754_sqrt+0x3c>
  227496:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
  22749a:	4320      	orrs	r0, r4
  22749c:	d079      	beq.n	227592 <__ieee754_sqrt+0x122>
  22749e:	b12b      	cbz	r3, 2274ac <__ieee754_sqrt+0x3c>
  2274a0:	ee30 7b40 	vsub.f64	d7, d0, d0
  2274a4:	ee87 0b07 	vdiv.f64	d0, d7, d7
  2274a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2274ac:	151b      	asrs	r3, r3, #20
  2274ae:	d10c      	bne.n	2274ca <__ieee754_sqrt+0x5a>
  2274b0:	2a00      	cmp	r2, #0
  2274b2:	d070      	beq.n	227596 <__ieee754_sqrt+0x126>
  2274b4:	2000      	movs	r0, #0
  2274b6:	02d5      	lsls	r5, r2, #11
  2274b8:	d571      	bpl.n	22759e <__ieee754_sqrt+0x12e>
  2274ba:	1e44      	subs	r4, r0, #1
  2274bc:	1b1b      	subs	r3, r3, r4
  2274be:	f1c0 0420 	rsb	r4, r0, #32
  2274c2:	fa21 f404 	lsr.w	r4, r1, r4
  2274c6:	4322      	orrs	r2, r4
  2274c8:	4081      	lsls	r1, r0
  2274ca:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
  2274ce:	f3c2 0213 	ubfx	r2, r2, #0, #20
  2274d2:	07dc      	lsls	r4, r3, #31
  2274d4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
  2274d8:	bf42      	ittt	mi
  2274da:	0052      	lslmi	r2, r2, #1
  2274dc:	eb02 72d1 	addmi.w	r2, r2, r1, lsr #31
  2274e0:	0049      	lslmi	r1, r1, #1
  2274e2:	105c      	asrs	r4, r3, #1
  2274e4:	2500      	movs	r5, #0
  2274e6:	eb02 73d1 	add.w	r3, r2, r1, lsr #31
  2274ea:	441a      	add	r2, r3
  2274ec:	0049      	lsls	r1, r1, #1
  2274ee:	2316      	movs	r3, #22
  2274f0:	4628      	mov	r0, r5
  2274f2:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
  2274f6:	1987      	adds	r7, r0, r6
  2274f8:	4297      	cmp	r7, r2
  2274fa:	bfde      	ittt	le
  2274fc:	1bd2      	suble	r2, r2, r7
  2274fe:	19b8      	addle	r0, r7, r6
  227500:	19ad      	addle	r5, r5, r6
  227502:	0052      	lsls	r2, r2, #1
  227504:	3b01      	subs	r3, #1
  227506:	eb02 72d1 	add.w	r2, r2, r1, lsr #31
  22750a:	ea4f 0656 	mov.w	r6, r6, lsr #1
  22750e:	ea4f 0141 	mov.w	r1, r1, lsl #1
  227512:	d1f0      	bne.n	2274f6 <__ieee754_sqrt+0x86>
  227514:	f04f 0e20 	mov.w	lr, #32
  227518:	469c      	mov	ip, r3
  22751a:	f04f 4600 	mov.w	r6, #2147483648	; 0x80000000
  22751e:	4282      	cmp	r2, r0
  227520:	eb06 070c 	add.w	r7, r6, ip
  227524:	dc02      	bgt.n	22752c <__ieee754_sqrt+0xbc>
  227526:	d112      	bne.n	22754e <__ieee754_sqrt+0xde>
  227528:	428f      	cmp	r7, r1
  22752a:	d810      	bhi.n	22754e <__ieee754_sqrt+0xde>
  22752c:	2f00      	cmp	r7, #0
  22752e:	eb07 0c06 	add.w	ip, r7, r6
  227532:	da37      	bge.n	2275a4 <__ieee754_sqrt+0x134>
  227534:	f1bc 0f00 	cmp.w	ip, #0
  227538:	db34      	blt.n	2275a4 <__ieee754_sqrt+0x134>
  22753a:	f100 0801 	add.w	r8, r0, #1
  22753e:	1a12      	subs	r2, r2, r0
  227540:	428f      	cmp	r7, r1
  227542:	bf88      	it	hi
  227544:	f102 32ff 	addhi.w	r2, r2, #4294967295
  227548:	1bc9      	subs	r1, r1, r7
  22754a:	4433      	add	r3, r6
  22754c:	4640      	mov	r0, r8
  22754e:	eb02 77d1 	add.w	r7, r2, r1, lsr #31
  227552:	f1be 0e01 	subs.w	lr, lr, #1
  227556:	443a      	add	r2, r7
  227558:	ea4f 0141 	mov.w	r1, r1, lsl #1
  22755c:	ea4f 0656 	mov.w	r6, r6, lsr #1
  227560:	d1dd      	bne.n	22751e <__ieee754_sqrt+0xae>
  227562:	430a      	orrs	r2, r1
  227564:	d006      	beq.n	227574 <__ieee754_sqrt+0x104>
  227566:	1c58      	adds	r0, r3, #1
  227568:	bf13      	iteet	ne
  22756a:	3301      	addne	r3, #1
  22756c:	3501      	addeq	r5, #1
  22756e:	4673      	moveq	r3, lr
  227570:	f023 0301 	bicne.w	r3, r3, #1
  227574:	106a      	asrs	r2, r5, #1
  227576:	085b      	lsrs	r3, r3, #1
  227578:	07e9      	lsls	r1, r5, #31
  22757a:	f102 527f 	add.w	r2, r2, #1069547520	; 0x3fc00000
  22757e:	f502 1200 	add.w	r2, r2, #2097152	; 0x200000
  227582:	bf48      	it	mi
  227584:	f043 4300 	orrmi.w	r3, r3, #2147483648	; 0x80000000
  227588:	eb02 5104 	add.w	r1, r2, r4, lsl #20
  22758c:	4618      	mov	r0, r3
  22758e:	ec41 0b10 	vmov	d0, r0, r1
  227592:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  227596:	0aca      	lsrs	r2, r1, #11
  227598:	3b15      	subs	r3, #21
  22759a:	0549      	lsls	r1, r1, #21
  22759c:	e788      	b.n	2274b0 <__ieee754_sqrt+0x40>
  22759e:	0052      	lsls	r2, r2, #1
  2275a0:	3001      	adds	r0, #1
  2275a2:	e788      	b.n	2274b6 <__ieee754_sqrt+0x46>
  2275a4:	4680      	mov	r8, r0
  2275a6:	e7ca      	b.n	22753e <__ieee754_sqrt+0xce>
  2275a8:	7ff00000 	.word	0x7ff00000
  2275ac:	00000000 	.word	0x00000000

002275b0 <__kernel_rem_pio2>:
  2275b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2275b4:	ed2d 8b06 	vpush	{d8-d10}
  2275b8:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
  2275bc:	468b      	mov	fp, r1
  2275be:	9301      	str	r3, [sp, #4]
  2275c0:	99a2      	ldr	r1, [sp, #648]	; 0x288
  2275c2:	4bcf      	ldr	r3, [pc, #828]	; (227900 <__kernel_rem_pio2+0x350>)
  2275c4:	9002      	str	r0, [sp, #8]
  2275c6:	f853 a021 	ldr.w	sl, [r3, r1, lsl #2]
  2275ca:	9b01      	ldr	r3, [sp, #4]
  2275cc:	9ca3      	ldr	r4, [sp, #652]	; 0x28c
  2275ce:	3b01      	subs	r3, #1
  2275d0:	1ed0      	subs	r0, r2, #3
  2275d2:	2518      	movs	r5, #24
  2275d4:	ed9f 6bc4 	vldr	d6, [pc, #784]	; 2278e8 <__kernel_rem_pio2+0x338>
  2275d8:	fb90 f0f5 	sdiv	r0, r0, r5
  2275dc:	f06f 0517 	mvn.w	r5, #23
  2275e0:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
  2275e4:	fb00 5505 	mla	r5, r0, r5, r5
  2275e8:	1ac7      	subs	r7, r0, r3
  2275ea:	4415      	add	r5, r2
  2275ec:	eb0a 0e03 	add.w	lr, sl, r3
  2275f0:	ae1a      	add	r6, sp, #104	; 0x68
  2275f2:	eb04 0c87 	add.w	ip, r4, r7, lsl #2
  2275f6:	2200      	movs	r2, #0
  2275f8:	4572      	cmp	r2, lr
  2275fa:	dd0f      	ble.n	22761c <__kernel_rem_pio2+0x6c>
  2275fc:	f50d 7ed4 	add.w	lr, sp, #424	; 0x1a8
  227600:	2600      	movs	r6, #0
  227602:	4556      	cmp	r6, sl
  227604:	dc27      	bgt.n	227656 <__kernel_rem_pio2+0xa6>
  227606:	9a01      	ldr	r2, [sp, #4]
  227608:	9f02      	ldr	r7, [sp, #8]
  22760a:	4432      	add	r2, r6
  22760c:	a91a      	add	r1, sp, #104	; 0x68
  22760e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  227612:	ed9f 7bb5 	vldr	d7, [pc, #724]	; 2278e8 <__kernel_rem_pio2+0x338>
  227616:	f04f 0c00 	mov.w	ip, #0
  22761a:	e016      	b.n	22764a <__kernel_rem_pio2+0x9a>
  22761c:	42d7      	cmn	r7, r2
  22761e:	d409      	bmi.n	227634 <__kernel_rem_pio2+0x84>
  227620:	f85c 1022 	ldr.w	r1, [ip, r2, lsl #2]
  227624:	ee07 1a90 	vmov	s15, r1
  227628:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  22762c:	eca6 7b02 	vstmia	r6!, {d7}
  227630:	3201      	adds	r2, #1
  227632:	e7e1      	b.n	2275f8 <__kernel_rem_pio2+0x48>
  227634:	eeb0 7b46 	vmov.f64	d7, d6
  227638:	e7f8      	b.n	22762c <__kernel_rem_pio2+0x7c>
  22763a:	ecb7 5b02 	vldmia	r7!, {d5}
  22763e:	ed32 6b02 	vldmdb	r2!, {d6}
  227642:	f10c 0c01 	add.w	ip, ip, #1
  227646:	eea5 7b06 	vfma.f64	d7, d5, d6
  22764a:	459c      	cmp	ip, r3
  22764c:	ddf5      	ble.n	22763a <__kernel_rem_pio2+0x8a>
  22764e:	ecae 7b02 	vstmia	lr!, {d7}
  227652:	3601      	adds	r6, #1
  227654:	e7d5      	b.n	227602 <__kernel_rem_pio2+0x52>
  227656:	aa06      	add	r2, sp, #24
  227658:	eb02 028a 	add.w	r2, r2, sl, lsl #2
  22765c:	ed9f 9ba4 	vldr	d9, [pc, #656]	; 2278f0 <__kernel_rem_pio2+0x340>
  227660:	ed9f aba5 	vldr	d10, [pc, #660]	; 2278f8 <__kernel_rem_pio2+0x348>
  227664:	9204      	str	r2, [sp, #16]
  227666:	eb04 0280 	add.w	r2, r4, r0, lsl #2
  22766a:	9203      	str	r2, [sp, #12]
  22766c:	4657      	mov	r7, sl
  22766e:	aa92      	add	r2, sp, #584	; 0x248
  227670:	f107 5800 	add.w	r8, r7, #536870912	; 0x20000000
  227674:	eb02 02c7 	add.w	r2, r2, r7, lsl #3
  227678:	f108 38ff 	add.w	r8, r8, #4294967295
  22767c:	ed12 0b28 	vldr	d0, [r2, #-160]	; 0xffffff60
  227680:	ea4f 08c8 	mov.w	r8, r8, lsl #3
  227684:	aa92      	add	r2, sp, #584	; 0x248
  227686:	eb02 0008 	add.w	r0, r2, r8
  22768a:	3898      	subs	r0, #152	; 0x98
  22768c:	2200      	movs	r2, #0
  22768e:	1abc      	subs	r4, r7, r2
  227690:	2c00      	cmp	r4, #0
  227692:	dc4c      	bgt.n	22772e <__kernel_rem_pio2+0x17e>
  227694:	4628      	mov	r0, r5
  227696:	9305      	str	r3, [sp, #20]
  227698:	f000 fd22 	bl	2280e0 <scalbn>
  22769c:	eeb0 8b40 	vmov.f64	d8, d0
  2276a0:	eeb4 0b00 	vmov.f64	d0, #64	; 0x3e000000  0.125
  2276a4:	ee28 0b00 	vmul.f64	d0, d8, d0
  2276a8:	f000 fc0a 	bl	227ec0 <floor>
  2276ac:	eeb2 7b00 	vmov.f64	d7, #32	; 0x41000000  8.0
  2276b0:	eea0 8b47 	vfms.f64	d8, d0, d7
  2276b4:	eefd 7bc8 	vcvt.s32.f64	s15, d8
  2276b8:	2d00      	cmp	r5, #0
  2276ba:	ee17 9a90 	vmov	r9, s15
  2276be:	9b05      	ldr	r3, [sp, #20]
  2276c0:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  2276c4:	ee38 8b47 	vsub.f64	d8, d8, d7
  2276c8:	dd46      	ble.n	227758 <__kernel_rem_pio2+0x1a8>
  2276ca:	1e78      	subs	r0, r7, #1
  2276cc:	aa06      	add	r2, sp, #24
  2276ce:	f1c5 0418 	rsb	r4, r5, #24
  2276d2:	f852 6020 	ldr.w	r6, [r2, r0, lsl #2]
  2276d6:	fa46 f204 	asr.w	r2, r6, r4
  2276da:	4491      	add	r9, r2
  2276dc:	40a2      	lsls	r2, r4
  2276de:	1ab6      	subs	r6, r6, r2
  2276e0:	aa06      	add	r2, sp, #24
  2276e2:	f842 6020 	str.w	r6, [r2, r0, lsl #2]
  2276e6:	f1c5 0217 	rsb	r2, r5, #23
  2276ea:	4116      	asrs	r6, r2
  2276ec:	2e00      	cmp	r6, #0
  2276ee:	dd42      	ble.n	227776 <__kernel_rem_pio2+0x1c6>
  2276f0:	2400      	movs	r4, #0
  2276f2:	f109 0901 	add.w	r9, r9, #1
  2276f6:	4620      	mov	r0, r4
  2276f8:	f06f 4e7f 	mvn.w	lr, #4278190080	; 0xff000000
  2276fc:	42a7      	cmp	r7, r4
  2276fe:	dc75      	bgt.n	2277ec <__kernel_rem_pio2+0x23c>
  227700:	2d00      	cmp	r5, #0
  227702:	dd05      	ble.n	227710 <__kernel_rem_pio2+0x160>
  227704:	2d01      	cmp	r5, #1
  227706:	f000 8086 	beq.w	227816 <__kernel_rem_pio2+0x266>
  22770a:	2d02      	cmp	r5, #2
  22770c:	f000 808d 	beq.w	22782a <__kernel_rem_pio2+0x27a>
  227710:	2e02      	cmp	r6, #2
  227712:	d130      	bne.n	227776 <__kernel_rem_pio2+0x1c6>
  227714:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
  227718:	ee30 8b48 	vsub.f64	d8, d0, d8
  22771c:	b358      	cbz	r0, 227776 <__kernel_rem_pio2+0x1c6>
  22771e:	4628      	mov	r0, r5
  227720:	9305      	str	r3, [sp, #20]
  227722:	f000 fcdd 	bl	2280e0 <scalbn>
  227726:	9b05      	ldr	r3, [sp, #20]
  227728:	ee38 8b40 	vsub.f64	d8, d8, d0
  22772c:	e023      	b.n	227776 <__kernel_rem_pio2+0x1c6>
  22772e:	ee20 7b09 	vmul.f64	d7, d0, d9
  227732:	eebd 7bc7 	vcvt.s32.f64	s14, d7
  227736:	ac06      	add	r4, sp, #24
  227738:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  22773c:	eea7 0b4a 	vfms.f64	d0, d7, d10
  227740:	eebd 0bc0 	vcvt.s32.f64	s0, d0
  227744:	ee10 1a10 	vmov	r1, s0
  227748:	ed30 0b02 	vldmdb	r0!, {d0}
  22774c:	f844 1022 	str.w	r1, [r4, r2, lsl #2]
  227750:	ee37 0b00 	vadd.f64	d0, d7, d0
  227754:	3201      	adds	r2, #1
  227756:	e79a      	b.n	22768e <__kernel_rem_pio2+0xde>
  227758:	d105      	bne.n	227766 <__kernel_rem_pio2+0x1b6>
  22775a:	1e7a      	subs	r2, r7, #1
  22775c:	a906      	add	r1, sp, #24
  22775e:	f851 6022 	ldr.w	r6, [r1, r2, lsl #2]
  227762:	15f6      	asrs	r6, r6, #23
  227764:	e7c2      	b.n	2276ec <__kernel_rem_pio2+0x13c>
  227766:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
  22776a:	eeb4 8bc7 	vcmpe.f64	d8, d7
  22776e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  227772:	da39      	bge.n	2277e8 <__kernel_rem_pio2+0x238>
  227774:	2600      	movs	r6, #0
  227776:	eeb5 8b40 	vcmp.f64	d8, #0.0
  22777a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  22777e:	f040 808e 	bne.w	22789e <__kernel_rem_pio2+0x2ee>
  227782:	1e7c      	subs	r4, r7, #1
  227784:	4620      	mov	r0, r4
  227786:	2200      	movs	r2, #0
  227788:	4550      	cmp	r0, sl
  22778a:	da55      	bge.n	227838 <__kernel_rem_pio2+0x288>
  22778c:	2a00      	cmp	r2, #0
  22778e:	d164      	bne.n	22785a <__kernel_rem_pio2+0x2aa>
  227790:	2401      	movs	r4, #1
  227792:	f06f 0003 	mvn.w	r0, #3
  227796:	fb00 f204 	mul.w	r2, r0, r4
  22779a:	9904      	ldr	r1, [sp, #16]
  22779c:	588a      	ldr	r2, [r1, r2]
  22779e:	2a00      	cmp	r2, #0
  2277a0:	d050      	beq.n	227844 <__kernel_rem_pio2+0x294>
  2277a2:	aa92      	add	r2, sp, #584	; 0x248
  2277a4:	4490      	add	r8, r2
  2277a6:	9a01      	ldr	r2, [sp, #4]
  2277a8:	a91a      	add	r1, sp, #104	; 0x68
  2277aa:	443a      	add	r2, r7
  2277ac:	1c78      	adds	r0, r7, #1
  2277ae:	f1a8 0890 	sub.w	r8, r8, #144	; 0x90
  2277b2:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
  2277b6:	4427      	add	r7, r4
  2277b8:	42b8      	cmp	r0, r7
  2277ba:	f73f af58 	bgt.w	22766e <__kernel_rem_pio2+0xbe>
  2277be:	9903      	ldr	r1, [sp, #12]
  2277c0:	9e02      	ldr	r6, [sp, #8]
  2277c2:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  2277c6:	9105      	str	r1, [sp, #20]
  2277c8:	ee07 1a90 	vmov	s15, r1
  2277cc:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  2277d0:	2400      	movs	r4, #0
  2277d2:	eca2 7b02 	vstmia	r2!, {d7}
  2277d6:	ed9f 7b44 	vldr	d7, [pc, #272]	; 2278e8 <__kernel_rem_pio2+0x338>
  2277da:	4696      	mov	lr, r2
  2277dc:	429c      	cmp	r4, r3
  2277de:	dd33      	ble.n	227848 <__kernel_rem_pio2+0x298>
  2277e0:	eca8 7b02 	vstmia	r8!, {d7}
  2277e4:	3001      	adds	r0, #1
  2277e6:	e7e7      	b.n	2277b8 <__kernel_rem_pio2+0x208>
  2277e8:	2602      	movs	r6, #2
  2277ea:	e781      	b.n	2276f0 <__kernel_rem_pio2+0x140>
  2277ec:	aa06      	add	r2, sp, #24
  2277ee:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
  2277f2:	b948      	cbnz	r0, 227808 <__kernel_rem_pio2+0x258>
  2277f4:	b12a      	cbz	r2, 227802 <__kernel_rem_pio2+0x252>
  2277f6:	a906      	add	r1, sp, #24
  2277f8:	f1c2 7280 	rsb	r2, r2, #16777216	; 0x1000000
  2277fc:	f841 2024 	str.w	r2, [r1, r4, lsl #2]
  227800:	2201      	movs	r2, #1
  227802:	3401      	adds	r4, #1
  227804:	4610      	mov	r0, r2
  227806:	e779      	b.n	2276fc <__kernel_rem_pio2+0x14c>
  227808:	a906      	add	r1, sp, #24
  22780a:	ebae 0202 	sub.w	r2, lr, r2
  22780e:	f841 2024 	str.w	r2, [r1, r4, lsl #2]
  227812:	4602      	mov	r2, r0
  227814:	e7f5      	b.n	227802 <__kernel_rem_pio2+0x252>
  227816:	1e7c      	subs	r4, r7, #1
  227818:	aa06      	add	r2, sp, #24
  22781a:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
  22781e:	f3c2 0216 	ubfx	r2, r2, #0, #23
  227822:	a906      	add	r1, sp, #24
  227824:	f841 2024 	str.w	r2, [r1, r4, lsl #2]
  227828:	e772      	b.n	227710 <__kernel_rem_pio2+0x160>
  22782a:	1e7c      	subs	r4, r7, #1
  22782c:	aa06      	add	r2, sp, #24
  22782e:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
  227832:	f3c2 0215 	ubfx	r2, r2, #0, #22
  227836:	e7f4      	b.n	227822 <__kernel_rem_pio2+0x272>
  227838:	a906      	add	r1, sp, #24
  22783a:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
  22783e:	3801      	subs	r0, #1
  227840:	430a      	orrs	r2, r1
  227842:	e7a1      	b.n	227788 <__kernel_rem_pio2+0x1d8>
  227844:	3401      	adds	r4, #1
  227846:	e7a6      	b.n	227796 <__kernel_rem_pio2+0x1e6>
  227848:	ecb6 5b02 	vldmia	r6!, {d5}
  22784c:	ed3e 6b02 	vldmdb	lr!, {d6}
  227850:	3401      	adds	r4, #1
  227852:	eea5 7b06 	vfma.f64	d7, d5, d6
  227856:	e7c1      	b.n	2277dc <__kernel_rem_pio2+0x22c>
  227858:	3c01      	subs	r4, #1
  22785a:	ab06      	add	r3, sp, #24
  22785c:	3d18      	subs	r5, #24
  22785e:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
  227862:	2b00      	cmp	r3, #0
  227864:	d0f8      	beq.n	227858 <__kernel_rem_pio2+0x2a8>
  227866:	4628      	mov	r0, r5
  227868:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
  22786c:	f000 fc38 	bl	2280e0 <scalbn>
  227870:	00e3      	lsls	r3, r4, #3
  227872:	ed9f 6b1f 	vldr	d6, [pc, #124]	; 2278f0 <__kernel_rem_pio2+0x340>
  227876:	aa6a      	add	r2, sp, #424	; 0x1a8
  227878:	3308      	adds	r3, #8
  22787a:	18d0      	adds	r0, r2, r3
  22787c:	4622      	mov	r2, r4
  22787e:	2a00      	cmp	r2, #0
  227880:	da4b      	bge.n	22791a <__kernel_rem_pio2+0x36a>
  227882:	f50d 7e84 	add.w	lr, sp, #264	; 0x108
  227886:	2200      	movs	r2, #0
  227888:	4677      	mov	r7, lr
  22788a:	1aa5      	subs	r5, r4, r2
  22788c:	d464      	bmi.n	227958 <__kernel_rem_pio2+0x3a8>
  22788e:	a86a      	add	r0, sp, #424	; 0x1a8
  227890:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
  227894:	491b      	ldr	r1, [pc, #108]	; (227904 <__kernel_rem_pio2+0x354>)
  227896:	ed9f 7b14 	vldr	d7, [pc, #80]	; 2278e8 <__kernel_rem_pio2+0x338>
  22789a:	2000      	movs	r0, #0
  22789c:	e054      	b.n	227948 <__kernel_rem_pio2+0x398>
  22789e:	4268      	negs	r0, r5
  2278a0:	eeb0 0b48 	vmov.f64	d0, d8
  2278a4:	f000 fc1c 	bl	2280e0 <scalbn>
  2278a8:	ed9f 6b13 	vldr	d6, [pc, #76]	; 2278f8 <__kernel_rem_pio2+0x348>
  2278ac:	eeb4 0bc6 	vcmpe.f64	d0, d6
  2278b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  2278b4:	db28      	blt.n	227908 <__kernel_rem_pio2+0x358>
  2278b6:	ed9f 7b0e 	vldr	d7, [pc, #56]	; 2278f0 <__kernel_rem_pio2+0x340>
  2278ba:	ee20 7b07 	vmul.f64	d7, d0, d7
  2278be:	eebd 7bc7 	vcvt.s32.f64	s14, d7
  2278c2:	aa06      	add	r2, sp, #24
  2278c4:	eeb8 5bc7 	vcvt.f64.s32	d5, s14
  2278c8:	eea5 0b46 	vfms.f64	d0, d5, d6
  2278cc:	eebd 0bc0 	vcvt.s32.f64	s0, d0
  2278d0:	1c7c      	adds	r4, r7, #1
  2278d2:	ee10 3a10 	vmov	r3, s0
  2278d6:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
  2278da:	ee17 3a10 	vmov	r3, s14
  2278de:	3518      	adds	r5, #24
  2278e0:	f842 3024 	str.w	r3, [r2, r4, lsl #2]
  2278e4:	e7bf      	b.n	227866 <__kernel_rem_pio2+0x2b6>
  2278e6:	bf00      	nop
	...
  2278f4:	3e700000 	.word	0x3e700000
  2278f8:	00000000 	.word	0x00000000
  2278fc:	41700000 	.word	0x41700000
  227900:	00229a08 	.word	0x00229a08
  227904:	002299c8 	.word	0x002299c8
  227908:	eebd 0bc0 	vcvt.s32.f64	s0, d0
  22790c:	aa06      	add	r2, sp, #24
  22790e:	ee10 3a10 	vmov	r3, s0
  227912:	463c      	mov	r4, r7
  227914:	f842 3027 	str.w	r3, [r2, r7, lsl #2]
  227918:	e7a5      	b.n	227866 <__kernel_rem_pio2+0x2b6>
  22791a:	a906      	add	r1, sp, #24
  22791c:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
  227920:	9101      	str	r1, [sp, #4]
  227922:	ee07 1a90 	vmov	s15, r1
  227926:	3a01      	subs	r2, #1
  227928:	eeb8 7be7 	vcvt.f64.s32	d7, s15
  22792c:	ee27 7b00 	vmul.f64	d7, d7, d0
  227930:	ee20 0b06 	vmul.f64	d0, d0, d6
  227934:	ed20 7b02 	vstmdb	r0!, {d7}
  227938:	e7a1      	b.n	22787e <__kernel_rem_pio2+0x2ce>
  22793a:	ecb1 5b02 	vldmia	r1!, {d5}
  22793e:	ecb5 6b02 	vldmia	r5!, {d6}
  227942:	3001      	adds	r0, #1
  227944:	eea5 7b06 	vfma.f64	d7, d5, d6
  227948:	4550      	cmp	r0, sl
  22794a:	dc01      	bgt.n	227950 <__kernel_rem_pio2+0x3a0>
  22794c:	4290      	cmp	r0, r2
  22794e:	ddf4      	ble.n	22793a <__kernel_rem_pio2+0x38a>
  227950:	ecae 7b02 	vstmia	lr!, {d7}
  227954:	3201      	adds	r2, #1
  227956:	e798      	b.n	22788a <__kernel_rem_pio2+0x2da>
  227958:	9aa2      	ldr	r2, [sp, #648]	; 0x288
  22795a:	2a03      	cmp	r2, #3
  22795c:	d843      	bhi.n	2279e6 <__kernel_rem_pio2+0x436>
  22795e:	e8df f002 	tbb	[pc, r2]
  227962:	1d37      	.short	0x1d37
  227964:	021d      	.short	0x021d
  227966:	aa42      	add	r2, sp, #264	; 0x108
  227968:	4413      	add	r3, r2
  22796a:	461a      	mov	r2, r3
  22796c:	4620      	mov	r0, r4
  22796e:	2800      	cmp	r0, #0
  227970:	dc56      	bgt.n	227a20 <__kernel_rem_pio2+0x470>
  227972:	461a      	mov	r2, r3
  227974:	4620      	mov	r0, r4
  227976:	2801      	cmp	r0, #1
  227978:	dc62      	bgt.n	227a40 <__kernel_rem_pio2+0x490>
  22797a:	ed9f 7b45 	vldr	d7, [pc, #276]	; 227a90 <__kernel_rem_pio2+0x4e0>
  22797e:	2c01      	cmp	r4, #1
  227980:	dc6e      	bgt.n	227a60 <__kernel_rem_pio2+0x4b0>
  227982:	2e00      	cmp	r6, #0
  227984:	d172      	bne.n	227a6c <__kernel_rem_pio2+0x4bc>
  227986:	e9dd 2342 	ldrd	r2, r3, [sp, #264]	; 0x108
  22798a:	e9cb 2300 	strd	r2, r3, [fp]
  22798e:	e9dd 2344 	ldrd	r2, r3, [sp, #272]	; 0x110
  227992:	e9cb 2302 	strd	r2, r3, [fp, #8]
  227996:	ed8b 7b04 	vstr	d7, [fp, #16]
  22799a:	e024      	b.n	2279e6 <__kernel_rem_pio2+0x436>
  22799c:	ed9f 6b3c 	vldr	d6, [pc, #240]	; 227a90 <__kernel_rem_pio2+0x4e0>
  2279a0:	aa42      	add	r2, sp, #264	; 0x108
  2279a2:	4413      	add	r3, r2
  2279a4:	4622      	mov	r2, r4
  2279a6:	2a00      	cmp	r2, #0
  2279a8:	da2b      	bge.n	227a02 <__kernel_rem_pio2+0x452>
  2279aa:	b386      	cbz	r6, 227a0e <__kernel_rem_pio2+0x45e>
  2279ac:	eeb1 7b46 	vneg.f64	d7, d6
  2279b0:	ed8b 7b00 	vstr	d7, [fp]
  2279b4:	ed9d 7b42 	vldr	d7, [sp, #264]	; 0x108
  2279b8:	aa44      	add	r2, sp, #272	; 0x110
  2279ba:	2301      	movs	r3, #1
  2279bc:	ee37 7b46 	vsub.f64	d7, d7, d6
  2279c0:	429c      	cmp	r4, r3
  2279c2:	da27      	bge.n	227a14 <__kernel_rem_pio2+0x464>
  2279c4:	b10e      	cbz	r6, 2279ca <__kernel_rem_pio2+0x41a>
  2279c6:	eeb1 7b47 	vneg.f64	d7, d7
  2279ca:	ed8b 7b02 	vstr	d7, [fp, #8]
  2279ce:	e00a      	b.n	2279e6 <__kernel_rem_pio2+0x436>
  2279d0:	ed9f 7b2f 	vldr	d7, [pc, #188]	; 227a90 <__kernel_rem_pio2+0x4e0>
  2279d4:	aa42      	add	r2, sp, #264	; 0x108
  2279d6:	4413      	add	r3, r2
  2279d8:	2c00      	cmp	r4, #0
  2279da:	da0c      	bge.n	2279f6 <__kernel_rem_pio2+0x446>
  2279dc:	b10e      	cbz	r6, 2279e2 <__kernel_rem_pio2+0x432>
  2279de:	eeb1 7b47 	vneg.f64	d7, d7
  2279e2:	ed8b 7b00 	vstr	d7, [fp]
  2279e6:	f009 0007 	and.w	r0, r9, #7
  2279ea:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
  2279ee:	ecbd 8b06 	vpop	{d8-d10}
  2279f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  2279f6:	ed33 6b02 	vldmdb	r3!, {d6}
  2279fa:	3c01      	subs	r4, #1
  2279fc:	ee37 7b06 	vadd.f64	d7, d7, d6
  227a00:	e7ea      	b.n	2279d8 <__kernel_rem_pio2+0x428>
  227a02:	ed33 7b02 	vldmdb	r3!, {d7}
  227a06:	3a01      	subs	r2, #1
  227a08:	ee36 6b07 	vadd.f64	d6, d6, d7
  227a0c:	e7cb      	b.n	2279a6 <__kernel_rem_pio2+0x3f6>
  227a0e:	eeb0 7b46 	vmov.f64	d7, d6
  227a12:	e7cd      	b.n	2279b0 <__kernel_rem_pio2+0x400>
  227a14:	ecb2 6b02 	vldmia	r2!, {d6}
  227a18:	3301      	adds	r3, #1
  227a1a:	ee37 7b06 	vadd.f64	d7, d7, d6
  227a1e:	e7cf      	b.n	2279c0 <__kernel_rem_pio2+0x410>
  227a20:	ed12 5b02 	vldr	d5, [r2, #-8]
  227a24:	ed12 7b04 	vldr	d7, [r2, #-16]
  227a28:	ee37 6b05 	vadd.f64	d6, d7, d5
  227a2c:	ee37 7b46 	vsub.f64	d7, d7, d6
  227a30:	ee37 7b05 	vadd.f64	d7, d7, d5
  227a34:	ed22 7b02 	vstmdb	r2!, {d7}
  227a38:	3801      	subs	r0, #1
  227a3a:	ed02 6b02 	vstr	d6, [r2, #-8]
  227a3e:	e796      	b.n	22796e <__kernel_rem_pio2+0x3be>
  227a40:	ed12 5b02 	vldr	d5, [r2, #-8]
  227a44:	ed12 7b04 	vldr	d7, [r2, #-16]
  227a48:	ee37 6b05 	vadd.f64	d6, d7, d5
  227a4c:	ee37 7b46 	vsub.f64	d7, d7, d6
  227a50:	ee37 7b05 	vadd.f64	d7, d7, d5
  227a54:	ed22 7b02 	vstmdb	r2!, {d7}
  227a58:	3801      	subs	r0, #1
  227a5a:	ed02 6b02 	vstr	d6, [r2, #-8]
  227a5e:	e78a      	b.n	227976 <__kernel_rem_pio2+0x3c6>
  227a60:	ed33 6b02 	vldmdb	r3!, {d6}
  227a64:	3c01      	subs	r4, #1
  227a66:	ee37 7b06 	vadd.f64	d7, d7, d6
  227a6a:	e788      	b.n	22797e <__kernel_rem_pio2+0x3ce>
  227a6c:	ed97 6b00 	vldr	d6, [r7]
  227a70:	eeb1 7b47 	vneg.f64	d7, d7
  227a74:	eeb1 6b46 	vneg.f64	d6, d6
  227a78:	ed8b 6b00 	vstr	d6, [fp]
  227a7c:	ed97 6b02 	vldr	d6, [r7, #8]
  227a80:	eeb1 6b46 	vneg.f64	d6, d6
  227a84:	ed8b 6b02 	vstr	d6, [fp, #8]
  227a88:	e785      	b.n	227996 <__kernel_rem_pio2+0x3e6>
  227a8a:	bf00      	nop
  227a8c:	f3af 8000 	nop.w
	...

00227a98 <__kernel_tan>:
  227a98:	eeb0 7b40 	vmov.f64	d7, d0
  227a9c:	ee17 3a90 	vmov	r3, s15
  227aa0:	b507      	push	{r0, r1, r2, lr}
  227aa2:	4981      	ldr	r1, [pc, #516]	; (227ca8 <__kernel_tan+0x210>)
  227aa4:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
  227aa8:	428a      	cmp	r2, r1
  227aaa:	dc1c      	bgt.n	227ae6 <__kernel_tan+0x4e>
  227aac:	eefd 6bc0 	vcvt.s32.f64	s13, d0
  227ab0:	ee16 1a90 	vmov	r1, s13
  227ab4:	bb69      	cbnz	r1, 227b12 <__kernel_tan+0x7a>
  227ab6:	ee10 3a10 	vmov	r3, s0
  227aba:	431a      	orrs	r2, r3
  227abc:	1c43      	adds	r3, r0, #1
  227abe:	4313      	orrs	r3, r2
  227ac0:	d10a      	bne.n	227ad8 <__kernel_tan+0x40>
  227ac2:	f000 f9eb 	bl	227e9c <fabs>
  227ac6:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
  227aca:	ee86 7b00 	vdiv.f64	d7, d6, d0
  227ace:	eeb0 0b47 	vmov.f64	d0, d7
  227ad2:	b003      	add	sp, #12
  227ad4:	f85d fb04 	ldr.w	pc, [sp], #4
  227ad8:	2801      	cmp	r0, #1
  227ada:	d0f8      	beq.n	227ace <__kernel_tan+0x36>
  227adc:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
  227ae0:	ee86 7b00 	vdiv.f64	d7, d6, d0
  227ae4:	e7f3      	b.n	227ace <__kernel_tan+0x36>
  227ae6:	4971      	ldr	r1, [pc, #452]	; (227cac <__kernel_tan+0x214>)
  227ae8:	428a      	cmp	r2, r1
  227aea:	dd12      	ble.n	227b12 <__kernel_tan+0x7a>
  227aec:	ed9f 6b4e 	vldr	d6, [pc, #312]	; 227c28 <__kernel_tan+0x190>
  227af0:	2b00      	cmp	r3, #0
  227af2:	bfb8      	it	lt
  227af4:	eeb1 7b40 	vneglt.f64	d7, d0
  227af8:	ee36 7b47 	vsub.f64	d7, d6, d7
  227afc:	ed9f 6b4c 	vldr	d6, [pc, #304]	; 227c30 <__kernel_tan+0x198>
  227b00:	bfb8      	it	lt
  227b02:	eeb1 1b41 	vneglt.f64	d1, d1
  227b06:	ee36 1b41 	vsub.f64	d1, d6, d1
  227b0a:	ee31 7b07 	vadd.f64	d7, d1, d7
  227b0e:	ed9f 1b4a 	vldr	d1, [pc, #296]	; 227c38 <__kernel_tan+0x1a0>
  227b12:	ee27 5b07 	vmul.f64	d5, d7, d7
  227b16:	ee25 6b05 	vmul.f64	d6, d5, d5
  227b1a:	ed9f 3b49 	vldr	d3, [pc, #292]	; 227c40 <__kernel_tan+0x1a8>
  227b1e:	ee27 0b05 	vmul.f64	d0, d7, d5
  227b22:	ed9f 4b49 	vldr	d4, [pc, #292]	; 227c48 <__kernel_tan+0x1b0>
  227b26:	eea6 4b03 	vfma.f64	d4, d6, d3
  227b2a:	ed9f 3b49 	vldr	d3, [pc, #292]	; 227c50 <__kernel_tan+0x1b8>
  227b2e:	eea6 3b04 	vfma.f64	d3, d6, d4
  227b32:	ed9f 4b49 	vldr	d4, [pc, #292]	; 227c58 <__kernel_tan+0x1c0>
  227b36:	eea6 4b03 	vfma.f64	d4, d6, d3
  227b3a:	ed9f 3b49 	vldr	d3, [pc, #292]	; 227c60 <__kernel_tan+0x1c8>
  227b3e:	eea6 3b04 	vfma.f64	d3, d6, d4
  227b42:	ed9f 4b49 	vldr	d4, [pc, #292]	; 227c68 <__kernel_tan+0x1d0>
  227b46:	ed9f 2b4a 	vldr	d2, [pc, #296]	; 227c70 <__kernel_tan+0x1d8>
  227b4a:	eea6 4b03 	vfma.f64	d4, d6, d3
  227b4e:	ed9f 3b4a 	vldr	d3, [pc, #296]	; 227c78 <__kernel_tan+0x1e0>
  227b52:	eea6 3b02 	vfma.f64	d3, d6, d2
  227b56:	ed9f 2b4a 	vldr	d2, [pc, #296]	; 227c80 <__kernel_tan+0x1e8>
  227b5a:	eea6 2b03 	vfma.f64	d2, d6, d3
  227b5e:	ed9f 3b4a 	vldr	d3, [pc, #296]	; 227c88 <__kernel_tan+0x1f0>
  227b62:	eea6 3b02 	vfma.f64	d3, d6, d2
  227b66:	ed9f 2b4a 	vldr	d2, [pc, #296]	; 227c90 <__kernel_tan+0x1f8>
  227b6a:	eea6 2b03 	vfma.f64	d2, d6, d3
  227b6e:	ed9f 3b4a 	vldr	d3, [pc, #296]	; 227c98 <__kernel_tan+0x200>
  227b72:	494e      	ldr	r1, [pc, #312]	; (227cac <__kernel_tan+0x214>)
  227b74:	eea6 3b02 	vfma.f64	d3, d6, d2
  227b78:	eeb0 6b41 	vmov.f64	d6, d1
  227b7c:	eea5 4b03 	vfma.f64	d4, d5, d3
  227b80:	eea0 6b04 	vfma.f64	d6, d0, d4
  227b84:	eea5 1b06 	vfma.f64	d1, d5, d6
  227b88:	ed9f 6b45 	vldr	d6, [pc, #276]	; 227ca0 <__kernel_tan+0x208>
  227b8c:	428a      	cmp	r2, r1
  227b8e:	eea0 1b06 	vfma.f64	d1, d0, d6
  227b92:	ee37 6b01 	vadd.f64	d6, d7, d1
  227b96:	ed8d 6b00 	vstr	d6, [sp]
  227b9a:	dd1f      	ble.n	227bdc <__kernel_tan+0x144>
  227b9c:	ed9d 5b00 	vldr	d5, [sp]
  227ba0:	179b      	asrs	r3, r3, #30
  227ba2:	ee06 0a90 	vmov	s13, r0
  227ba6:	ee25 3b05 	vmul.f64	d3, d5, d5
  227baa:	f003 0302 	and.w	r3, r3, #2
  227bae:	f1c3 0301 	rsb	r3, r3, #1
  227bb2:	eeb8 6be6 	vcvt.f64.s32	d6, s13
  227bb6:	ee35 4b06 	vadd.f64	d4, d5, d6
  227bba:	ee83 5b04 	vdiv.f64	d5, d3, d4
  227bbe:	ee35 1b41 	vsub.f64	d1, d5, d1
  227bc2:	eeb0 5b00 	vmov.f64	d5, #0	; 0x40000000  2.0
  227bc6:	ee37 7b41 	vsub.f64	d7, d7, d1
  227bca:	eea7 6b45 	vfms.f64	d6, d7, d5
  227bce:	ee07 3a10 	vmov	s14, r3
  227bd2:	eeb8 7bc7 	vcvt.f64.s32	d7, s14
  227bd6:	ee26 7b07 	vmul.f64	d7, d6, d7
  227bda:	e778      	b.n	227ace <__kernel_tan+0x36>
  227bdc:	2801      	cmp	r0, #1
  227bde:	d020      	beq.n	227c22 <__kernel_tan+0x18a>
  227be0:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
  227be4:	ed9d 3b00 	vldr	d3, [sp]
  227be8:	e9dd 0100 	ldrd	r0, r1, [sp]
  227bec:	ee86 4b03 	vdiv.f64	d4, d6, d3
  227bf0:	ed8d 4b00 	vstr	d4, [sp]
  227bf4:	e9dd 2300 	ldrd	r2, r3, [sp]
  227bf8:	2000      	movs	r0, #0
  227bfa:	4602      	mov	r2, r0
  227bfc:	ec43 2b16 	vmov	d6, r2, r3
  227c00:	ec41 0b15 	vmov	d5, r0, r1
  227c04:	ee35 7b47 	vsub.f64	d7, d5, d7
  227c08:	ee31 1b47 	vsub.f64	d1, d1, d7
  227c0c:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
  227c10:	eea5 7b06 	vfma.f64	d7, d5, d6
  227c14:	eea1 7b06 	vfma.f64	d7, d1, d6
  227c18:	eea4 6b07 	vfma.f64	d6, d4, d7
  227c1c:	eeb0 7b46 	vmov.f64	d7, d6
  227c20:	e755      	b.n	227ace <__kernel_tan+0x36>
  227c22:	ed9d 7b00 	vldr	d7, [sp]
  227c26:	e752      	b.n	227ace <__kernel_tan+0x36>
  227c28:	54442d18 	.word	0x54442d18
  227c2c:	3fe921fb 	.word	0x3fe921fb
  227c30:	33145c07 	.word	0x33145c07
  227c34:	3c81a626 	.word	0x3c81a626
	...
  227c40:	db605373 	.word	0xdb605373
  227c44:	bef375cb 	.word	0xbef375cb
  227c48:	a03792a6 	.word	0xa03792a6
  227c4c:	3f147e88 	.word	0x3f147e88
  227c50:	f2f26501 	.word	0xf2f26501
  227c54:	3f4344d8 	.word	0x3f4344d8
  227c58:	c9560328 	.word	0xc9560328
  227c5c:	3f6d6d22 	.word	0x3f6d6d22
  227c60:	8406d637 	.word	0x8406d637
  227c64:	3f9664f4 	.word	0x3f9664f4
  227c68:	1110fe7a 	.word	0x1110fe7a
  227c6c:	3fc11111 	.word	0x3fc11111
  227c70:	74bf7ad4 	.word	0x74bf7ad4
  227c74:	3efb2a70 	.word	0x3efb2a70
  227c78:	32f0a7e9 	.word	0x32f0a7e9
  227c7c:	3f12b80f 	.word	0x3f12b80f
  227c80:	1a8d1068 	.word	0x1a8d1068
  227c84:	3f3026f7 	.word	0x3f3026f7
  227c88:	fee08315 	.word	0xfee08315
  227c8c:	3f57dbc8 	.word	0x3f57dbc8
  227c90:	e96e8493 	.word	0xe96e8493
  227c94:	3f8226e3 	.word	0x3f8226e3
  227c98:	1bb341fe 	.word	0x1bb341fe
  227c9c:	3faba1ba 	.word	0x3faba1ba
  227ca0:	55555563 	.word	0x55555563
  227ca4:	3fd55555 	.word	0x3fd55555
  227ca8:	3e2fffff 	.word	0x3e2fffff
  227cac:	3fe59427 	.word	0x3fe59427

00227cb0 <atan>:
  227cb0:	b538      	push	{r3, r4, r5, lr}
  227cb2:	eeb0 7b40 	vmov.f64	d7, d0
  227cb6:	ee17 5a90 	vmov	r5, s15
  227cba:	4b71      	ldr	r3, [pc, #452]	; (227e80 <atan+0x1d0>)
  227cbc:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
  227cc0:	429c      	cmp	r4, r3
  227cc2:	dd14      	ble.n	227cee <atan+0x3e>
  227cc4:	4a6f      	ldr	r2, [pc, #444]	; (227e84 <atan+0x1d4>)
  227cc6:	4294      	cmp	r4, r2
  227cc8:	ee10 3a10 	vmov	r3, s0
  227ccc:	dc01      	bgt.n	227cd2 <atan+0x22>
  227cce:	d105      	bne.n	227cdc <atan+0x2c>
  227cd0:	b123      	cbz	r3, 227cdc <atan+0x2c>
  227cd2:	ee37 7b07 	vadd.f64	d7, d7, d7
  227cd6:	eeb0 0b47 	vmov.f64	d0, d7
  227cda:	bd38      	pop	{r3, r4, r5, pc}
  227cdc:	ed9f 7b4c 	vldr	d7, [pc, #304]	; 227e10 <atan+0x160>
  227ce0:	ed9f 6b4d 	vldr	d6, [pc, #308]	; 227e18 <atan+0x168>
  227ce4:	2d00      	cmp	r5, #0
  227ce6:	bfc8      	it	gt
  227ce8:	eeb0 7b46 	vmovgt.f64	d7, d6
  227cec:	e7f3      	b.n	227cd6 <atan+0x26>
  227cee:	4b66      	ldr	r3, [pc, #408]	; (227e88 <atan+0x1d8>)
  227cf0:	429c      	cmp	r4, r3
  227cf2:	dc11      	bgt.n	227d18 <atan+0x68>
  227cf4:	f1a3 73de 	sub.w	r3, r3, #29097984	; 0x1bc0000
  227cf8:	429c      	cmp	r4, r3
  227cfa:	dc0a      	bgt.n	227d12 <atan+0x62>
  227cfc:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
  227d00:	ed9f 6b47 	vldr	d6, [pc, #284]	; 227e20 <atan+0x170>
  227d04:	ee30 6b06 	vadd.f64	d6, d0, d6
  227d08:	eeb4 6bc5 	vcmpe.f64	d6, d5
  227d0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  227d10:	dce1      	bgt.n	227cd6 <atan+0x26>
  227d12:	f04f 33ff 	mov.w	r3, #4294967295
  227d16:	e013      	b.n	227d40 <atan+0x90>
  227d18:	f000 f8c0 	bl	227e9c <fabs>
  227d1c:	4b5b      	ldr	r3, [pc, #364]	; (227e8c <atan+0x1dc>)
  227d1e:	429c      	cmp	r4, r3
  227d20:	dc4d      	bgt.n	227dbe <atan+0x10e>
  227d22:	f5a3 2350 	sub.w	r3, r3, #851968	; 0xd0000
  227d26:	429c      	cmp	r4, r3
  227d28:	dc3f      	bgt.n	227daa <atan+0xfa>
  227d2a:	eeb0 7b00 	vmov.f64	d7, #0	; 0x40000000  2.0
  227d2e:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
  227d32:	2300      	movs	r3, #0
  227d34:	eea0 6b07 	vfma.f64	d6, d0, d7
  227d38:	ee30 0b07 	vadd.f64	d0, d0, d7
  227d3c:	ee86 7b00 	vdiv.f64	d7, d6, d0
  227d40:	ed9f 5b39 	vldr	d5, [pc, #228]	; 227e28 <atan+0x178>
  227d44:	ee27 4b07 	vmul.f64	d4, d7, d7
  227d48:	ee24 6b04 	vmul.f64	d6, d4, d4
  227d4c:	ed9f 3b38 	vldr	d3, [pc, #224]	; 227e30 <atan+0x180>
  227d50:	eea6 3b05 	vfma.f64	d3, d6, d5
  227d54:	ed9f 5b38 	vldr	d5, [pc, #224]	; 227e38 <atan+0x188>
  227d58:	eea6 5b03 	vfma.f64	d5, d6, d3
  227d5c:	ed9f 3b38 	vldr	d3, [pc, #224]	; 227e40 <atan+0x190>
  227d60:	eea6 3b05 	vfma.f64	d3, d6, d5
  227d64:	ed9f 5b38 	vldr	d5, [pc, #224]	; 227e48 <atan+0x198>
  227d68:	eea6 5b03 	vfma.f64	d5, d6, d3
  227d6c:	ed9f 3b38 	vldr	d3, [pc, #224]	; 227e50 <atan+0x1a0>
  227d70:	ed9f 2b39 	vldr	d2, [pc, #228]	; 227e58 <atan+0x1a8>
  227d74:	eea6 3b05 	vfma.f64	d3, d6, d5
  227d78:	ed9f 5b39 	vldr	d5, [pc, #228]	; 227e60 <atan+0x1b0>
  227d7c:	eea6 2b05 	vfma.f64	d2, d6, d5
  227d80:	ed9f 5b39 	vldr	d5, [pc, #228]	; 227e68 <atan+0x1b8>
  227d84:	eea6 5b02 	vfma.f64	d5, d6, d2
  227d88:	ed9f 2b39 	vldr	d2, [pc, #228]	; 227e70 <atan+0x1c0>
  227d8c:	eea6 2b05 	vfma.f64	d2, d6, d5
  227d90:	ed9f 5b39 	vldr	d5, [pc, #228]	; 227e78 <atan+0x1c8>
  227d94:	1c5a      	adds	r2, r3, #1
  227d96:	eea6 5b02 	vfma.f64	d5, d6, d2
  227d9a:	ee25 6b06 	vmul.f64	d6, d5, d6
  227d9e:	ee03 6b04 	vmla.f64	d6, d3, d4
  227da2:	d121      	bne.n	227de8 <atan+0x138>
  227da4:	eea7 7b46 	vfms.f64	d7, d7, d6
  227da8:	e795      	b.n	227cd6 <atan+0x26>
  227daa:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
  227dae:	2301      	movs	r3, #1
  227db0:	ee30 6b47 	vsub.f64	d6, d0, d7
  227db4:	ee30 0b07 	vadd.f64	d0, d0, d7
  227db8:	ee86 7b00 	vdiv.f64	d7, d6, d0
  227dbc:	e7c0      	b.n	227d40 <atan+0x90>
  227dbe:	4b34      	ldr	r3, [pc, #208]	; (227e90 <atan+0x1e0>)
  227dc0:	429c      	cmp	r4, r3
  227dc2:	dc0b      	bgt.n	227ddc <atan+0x12c>
  227dc4:	eeb7 7b08 	vmov.f64	d7, #120	; 0x3fc00000  1.5
  227dc8:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
  227dcc:	ee30 5b47 	vsub.f64	d5, d0, d7
  227dd0:	eea0 6b07 	vfma.f64	d6, d0, d7
  227dd4:	2302      	movs	r3, #2
  227dd6:	ee85 7b06 	vdiv.f64	d7, d5, d6
  227dda:	e7b1      	b.n	227d40 <atan+0x90>
  227ddc:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
  227de0:	2303      	movs	r3, #3
  227de2:	ee86 7b00 	vdiv.f64	d7, d6, d0
  227de6:	e7ab      	b.n	227d40 <atan+0x90>
  227de8:	4a2a      	ldr	r2, [pc, #168]	; (227e94 <atan+0x1e4>)
  227dea:	492b      	ldr	r1, [pc, #172]	; (227e98 <atan+0x1e8>)
  227dec:	00db      	lsls	r3, r3, #3
  227dee:	441a      	add	r2, r3
  227df0:	440b      	add	r3, r1
  227df2:	ed93 5b00 	vldr	d5, [r3]
  227df6:	ee97 5b06 	vfnms.f64	d5, d7, d6
  227dfa:	ed92 6b00 	vldr	d6, [r2]
  227dfe:	ee35 7b47 	vsub.f64	d7, d5, d7
  227e02:	2d00      	cmp	r5, #0
  227e04:	ee36 7b47 	vsub.f64	d7, d6, d7
  227e08:	bfb8      	it	lt
  227e0a:	eeb1 7b47 	vneglt.f64	d7, d7
  227e0e:	e762      	b.n	227cd6 <atan+0x26>
  227e10:	54442d18 	.word	0x54442d18
  227e14:	bff921fb 	.word	0xbff921fb
  227e18:	54442d18 	.word	0x54442d18
  227e1c:	3ff921fb 	.word	0x3ff921fb
  227e20:	8800759c 	.word	0x8800759c
  227e24:	7e37e43c 	.word	0x7e37e43c
  227e28:	e322da11 	.word	0xe322da11
  227e2c:	3f90ad3a 	.word	0x3f90ad3a
  227e30:	24760deb 	.word	0x24760deb
  227e34:	3fa97b4b 	.word	0x3fa97b4b
  227e38:	a0d03d51 	.word	0xa0d03d51
  227e3c:	3fb10d66 	.word	0x3fb10d66
  227e40:	c54c206e 	.word	0xc54c206e
  227e44:	3fb745cd 	.word	0x3fb745cd
  227e48:	920083ff 	.word	0x920083ff
  227e4c:	3fc24924 	.word	0x3fc24924
  227e50:	5555550d 	.word	0x5555550d
  227e54:	3fd55555 	.word	0x3fd55555
  227e58:	52defd9a 	.word	0x52defd9a
  227e5c:	bfadde2d 	.word	0xbfadde2d
  227e60:	2c6a6c2f 	.word	0x2c6a6c2f
  227e64:	bfa2b444 	.word	0xbfa2b444
  227e68:	af749a6d 	.word	0xaf749a6d
  227e6c:	bfb3b0f2 	.word	0xbfb3b0f2
  227e70:	fe231671 	.word	0xfe231671
  227e74:	bfbc71c6 	.word	0xbfbc71c6
  227e78:	9998ebc4 	.word	0x9998ebc4
  227e7c:	bfc99999 	.word	0xbfc99999
  227e80:	440fffff 	.word	0x440fffff
  227e84:	7ff00000 	.word	0x7ff00000
  227e88:	3fdbffff 	.word	0x3fdbffff
  227e8c:	3ff2ffff 	.word	0x3ff2ffff
  227e90:	40037fff 	.word	0x40037fff
  227e94:	00229a18 	.word	0x00229a18
  227e98:	00229a38 	.word	0x00229a38

00227e9c <fabs>:
  227e9c:	ec53 2b10 	vmov	r2, r3, d0
  227ea0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  227ea4:	ec43 2b10 	vmov	d0, r2, r3
  227ea8:	4770      	bx	lr

00227eaa <finite>:
  227eaa:	ee10 3a90 	vmov	r3, s1
  227eae:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
  227eb2:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
  227eb6:	0fc0      	lsrs	r0, r0, #31
  227eb8:	4770      	bx	lr
  227eba:	0000      	movs	r0, r0
  227ebc:	0000      	movs	r0, r0
	...

00227ec0 <floor>:
  227ec0:	ee10 1a90 	vmov	r1, s1
  227ec4:	f3c1 520a 	ubfx	r2, r1, #20, #11
  227ec8:	f2a2 33ff 	subw	r3, r2, #1023	; 0x3ff
  227ecc:	2b13      	cmp	r3, #19
  227ece:	b530      	push	{r4, r5, lr}
  227ed0:	ee10 0a10 	vmov	r0, s0
  227ed4:	ee10 5a10 	vmov	r5, s0
  227ed8:	dc33      	bgt.n	227f42 <floor+0x82>
  227eda:	2b00      	cmp	r3, #0
  227edc:	da17      	bge.n	227f0e <floor+0x4e>
  227ede:	ed9f 7b30 	vldr	d7, [pc, #192]	; 227fa0 <floor+0xe0>
  227ee2:	ee30 0b07 	vadd.f64	d0, d0, d7
  227ee6:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
  227eea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  227eee:	dd09      	ble.n	227f04 <floor+0x44>
  227ef0:	2900      	cmp	r1, #0
  227ef2:	da50      	bge.n	227f96 <floor+0xd6>
  227ef4:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
  227ef8:	432b      	orrs	r3, r5
  227efa:	4b2b      	ldr	r3, [pc, #172]	; (227fa8 <floor+0xe8>)
  227efc:	f04f 0000 	mov.w	r0, #0
  227f00:	bf18      	it	ne
  227f02:	4619      	movne	r1, r3
  227f04:	460b      	mov	r3, r1
  227f06:	4602      	mov	r2, r0
  227f08:	ec43 2b10 	vmov	d0, r2, r3
  227f0c:	bd30      	pop	{r4, r5, pc}
  227f0e:	4a27      	ldr	r2, [pc, #156]	; (227fac <floor+0xec>)
  227f10:	411a      	asrs	r2, r3
  227f12:	ea01 0402 	and.w	r4, r1, r2
  227f16:	432c      	orrs	r4, r5
  227f18:	d0f8      	beq.n	227f0c <floor+0x4c>
  227f1a:	ed9f 7b21 	vldr	d7, [pc, #132]	; 227fa0 <floor+0xe0>
  227f1e:	ee30 0b07 	vadd.f64	d0, d0, d7
  227f22:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
  227f26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  227f2a:	ddeb      	ble.n	227f04 <floor+0x44>
  227f2c:	2900      	cmp	r1, #0
  227f2e:	bfbe      	ittt	lt
  227f30:	f44f 1080 	movlt.w	r0, #1048576	; 0x100000
  227f34:	fa40 f303 	asrlt.w	r3, r0, r3
  227f38:	18c9      	addlt	r1, r1, r3
  227f3a:	ea21 0102 	bic.w	r1, r1, r2
  227f3e:	2000      	movs	r0, #0
  227f40:	e7e0      	b.n	227f04 <floor+0x44>
  227f42:	2b33      	cmp	r3, #51	; 0x33
  227f44:	dd05      	ble.n	227f52 <floor+0x92>
  227f46:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
  227f4a:	d1df      	bne.n	227f0c <floor+0x4c>
  227f4c:	ee30 0b00 	vadd.f64	d0, d0, d0
  227f50:	bd30      	pop	{r4, r5, pc}
  227f52:	f2a2 4413 	subw	r4, r2, #1043	; 0x413
  227f56:	f04f 32ff 	mov.w	r2, #4294967295
  227f5a:	40e2      	lsrs	r2, r4
  227f5c:	4215      	tst	r5, r2
  227f5e:	d0d5      	beq.n	227f0c <floor+0x4c>
  227f60:	ed9f 7b0f 	vldr	d7, [pc, #60]	; 227fa0 <floor+0xe0>
  227f64:	ee30 0b07 	vadd.f64	d0, d0, d7
  227f68:	eeb5 0bc0 	vcmpe.f64	d0, #0.0
  227f6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
  227f70:	ddc8      	ble.n	227f04 <floor+0x44>
  227f72:	2900      	cmp	r1, #0
  227f74:	da02      	bge.n	227f7c <floor+0xbc>
  227f76:	2b14      	cmp	r3, #20
  227f78:	d103      	bne.n	227f82 <floor+0xc2>
  227f7a:	3101      	adds	r1, #1
  227f7c:	ea20 0002 	bic.w	r0, r0, r2
  227f80:	e7c0      	b.n	227f04 <floor+0x44>
  227f82:	2401      	movs	r4, #1
  227f84:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
  227f88:	fa04 f303 	lsl.w	r3, r4, r3
  227f8c:	4418      	add	r0, r3
  227f8e:	4285      	cmp	r5, r0
  227f90:	bf88      	it	hi
  227f92:	1909      	addhi	r1, r1, r4
  227f94:	e7f2      	b.n	227f7c <floor+0xbc>
  227f96:	2000      	movs	r0, #0
  227f98:	4601      	mov	r1, r0
  227f9a:	e7b3      	b.n	227f04 <floor+0x44>
  227f9c:	f3af 8000 	nop.w
  227fa0:	8800759c 	.word	0x8800759c
  227fa4:	7e37e43c 	.word	0x7e37e43c
  227fa8:	bff00000 	.word	0xbff00000
  227fac:	000fffff 	.word	0x000fffff

00227fb0 <matherr>:
  227fb0:	2000      	movs	r0, #0
  227fb2:	4770      	bx	lr
  227fb4:	0000      	movs	r0, r0
	...

00227fb8 <nan>:
  227fb8:	ed9f 0b01 	vldr	d0, [pc, #4]	; 227fc0 <nan+0x8>
  227fbc:	4770      	bx	lr
  227fbe:	bf00      	nop
  227fc0:	00000000 	.word	0x00000000
  227fc4:	7ff80000 	.word	0x7ff80000

00227fc8 <rint>:
  227fc8:	b530      	push	{r4, r5, lr}
  227fca:	b085      	sub	sp, #20
  227fcc:	ed8d 0b00 	vstr	d0, [sp]
  227fd0:	9b01      	ldr	r3, [sp, #4]
  227fd2:	9d00      	ldr	r5, [sp, #0]
  227fd4:	f3c3 510a 	ubfx	r1, r3, #20, #11
  227fd8:	f2a1 30ff 	subw	r0, r1, #1023	; 0x3ff
  227fdc:	2813      	cmp	r0, #19
  227fde:	462a      	mov	r2, r5
  227fe0:	ea4f 74d3 	mov.w	r4, r3, lsr #31
  227fe4:	dc5a      	bgt.n	22809c <rint+0xd4>
  227fe6:	2800      	cmp	r0, #0
  227fe8:	da2f      	bge.n	22804a <rint+0x82>
  227fea:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
  227fee:	432a      	orrs	r2, r5
  227ff0:	d027      	beq.n	228042 <rint+0x7a>
  227ff2:	f3c3 0213 	ubfx	r2, r3, #0, #20
  227ff6:	4315      	orrs	r5, r2
  227ff8:	426a      	negs	r2, r5
  227ffa:	432a      	orrs	r2, r5
  227ffc:	0b12      	lsrs	r2, r2, #12
  227ffe:	0c5b      	lsrs	r3, r3, #17
  228000:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
  228004:	045b      	lsls	r3, r3, #17
  228006:	e9dd 0100 	ldrd	r0, r1, [sp]
  22800a:	ea42 0103 	orr.w	r1, r2, r3
  22800e:	4b32      	ldr	r3, [pc, #200]	; (2280d8 <rint+0x110>)
  228010:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
  228014:	ed93 6b00 	vldr	d6, [r3]
  228018:	ec41 0b17 	vmov	d7, r0, r1
  22801c:	ee37 7b06 	vadd.f64	d7, d7, d6
  228020:	ed8d 7b02 	vstr	d7, [sp, #8]
  228024:	ed9d 7b02 	vldr	d7, [sp, #8]
  228028:	ee37 7b46 	vsub.f64	d7, d7, d6
  22802c:	ed8d 7b00 	vstr	d7, [sp]
  228030:	9901      	ldr	r1, [sp, #4]
  228032:	e9dd 2300 	ldrd	r2, r3, [sp]
  228036:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
  22803a:	ea41 73c4 	orr.w	r3, r1, r4, lsl #31
  22803e:	e9cd 2300 	strd	r2, r3, [sp]
  228042:	ed9d 0b00 	vldr	d0, [sp]
  228046:	b005      	add	sp, #20
  228048:	bd30      	pop	{r4, r5, pc}
  22804a:	4924      	ldr	r1, [pc, #144]	; (2280dc <rint+0x114>)
  22804c:	4101      	asrs	r1, r0
  22804e:	ea03 0501 	and.w	r5, r3, r1
  228052:	4315      	orrs	r5, r2
  228054:	d0f5      	beq.n	228042 <rint+0x7a>
  228056:	0849      	lsrs	r1, r1, #1
  228058:	ea03 0501 	and.w	r5, r3, r1
  22805c:	432a      	orrs	r2, r5
  22805e:	d00b      	beq.n	228078 <rint+0xb0>
  228060:	ea23 0101 	bic.w	r1, r3, r1
  228064:	f44f 2380 	mov.w	r3, #262144	; 0x40000
  228068:	2813      	cmp	r0, #19
  22806a:	fa43 f300 	asr.w	r3, r3, r0
  22806e:	bf0c      	ite	eq
  228070:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
  228074:	2200      	movne	r2, #0
  228076:	430b      	orrs	r3, r1
  228078:	4619      	mov	r1, r3
  22807a:	4b17      	ldr	r3, [pc, #92]	; (2280d8 <rint+0x110>)
  22807c:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
  228080:	ed94 6b00 	vldr	d6, [r4]
  228084:	4610      	mov	r0, r2
  228086:	ec41 0b17 	vmov	d7, r0, r1
  22808a:	ee37 7b06 	vadd.f64	d7, d7, d6
  22808e:	ed8d 7b02 	vstr	d7, [sp, #8]
  228092:	ed9d 7b02 	vldr	d7, [sp, #8]
  228096:	ee37 7b46 	vsub.f64	d7, d7, d6
  22809a:	e008      	b.n	2280ae <rint+0xe6>
  22809c:	2833      	cmp	r0, #51	; 0x33
  22809e:	dd09      	ble.n	2280b4 <rint+0xec>
  2280a0:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
  2280a4:	d1cd      	bne.n	228042 <rint+0x7a>
  2280a6:	ed9d 7b00 	vldr	d7, [sp]
  2280aa:	ee37 7b07 	vadd.f64	d7, d7, d7
  2280ae:	ed8d 7b00 	vstr	d7, [sp]
  2280b2:	e7c6      	b.n	228042 <rint+0x7a>
  2280b4:	f2a1 4013 	subw	r0, r1, #1043	; 0x413
  2280b8:	f04f 31ff 	mov.w	r1, #4294967295
  2280bc:	40c1      	lsrs	r1, r0
  2280be:	420d      	tst	r5, r1
  2280c0:	d0bf      	beq.n	228042 <rint+0x7a>
  2280c2:	0849      	lsrs	r1, r1, #1
  2280c4:	420d      	tst	r5, r1
  2280c6:	bf1f      	itttt	ne
  2280c8:	f04f 4280 	movne.w	r2, #1073741824	; 0x40000000
  2280cc:	ea25 0101 	bicne.w	r1, r5, r1
  2280d0:	4102      	asrne	r2, r0
  2280d2:	430a      	orrne	r2, r1
  2280d4:	e7d0      	b.n	228078 <rint+0xb0>
  2280d6:	bf00      	nop
  2280d8:	00229a58 	.word	0x00229a58
  2280dc:	000fffff 	.word	0x000fffff

002280e0 <scalbn>:
  2280e0:	b500      	push	{lr}
  2280e2:	ed2d 8b02 	vpush	{d8}
  2280e6:	b083      	sub	sp, #12
  2280e8:	ed8d 0b00 	vstr	d0, [sp]
  2280ec:	e89d 000a 	ldmia.w	sp, {r1, r3}
  2280f0:	f3c3 520a 	ubfx	r2, r3, #20, #11
  2280f4:	b9a2      	cbnz	r2, 228120 <scalbn+0x40>
  2280f6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
  2280fa:	430b      	orrs	r3, r1
  2280fc:	d03a      	beq.n	228174 <scalbn+0x94>
  2280fe:	ed9f 7b2e 	vldr	d7, [pc, #184]	; 2281b8 <scalbn+0xd8>
  228102:	4a35      	ldr	r2, [pc, #212]	; (2281d8 <scalbn+0xf8>)
  228104:	ee20 7b07 	vmul.f64	d7, d0, d7
  228108:	4290      	cmp	r0, r2
  22810a:	ed8d 7b00 	vstr	d7, [sp]
  22810e:	9b01      	ldr	r3, [sp, #4]
  228110:	da11      	bge.n	228136 <scalbn+0x56>
  228112:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 2281c0 <scalbn+0xe0>
  228116:	ed9d 6b00 	vldr	d6, [sp]
  22811a:	ee27 7b06 	vmul.f64	d7, d7, d6
  22811e:	e007      	b.n	228130 <scalbn+0x50>
  228120:	f240 71ff 	movw	r1, #2047	; 0x7ff
  228124:	428a      	cmp	r2, r1
  228126:	d109      	bne.n	22813c <scalbn+0x5c>
  228128:	ed9d 7b00 	vldr	d7, [sp]
  22812c:	ee37 7b07 	vadd.f64	d7, d7, d7
  228130:	ed8d 7b00 	vstr	d7, [sp]
  228134:	e01e      	b.n	228174 <scalbn+0x94>
  228136:	f3c3 520a 	ubfx	r2, r3, #20, #11
  22813a:	3a36      	subs	r2, #54	; 0x36
  22813c:	4402      	add	r2, r0
  22813e:	f240 71fe 	movw	r1, #2046	; 0x7fe
  228142:	428a      	cmp	r2, r1
  228144:	dd0a      	ble.n	22815c <scalbn+0x7c>
  228146:	ed9f 8b20 	vldr	d8, [pc, #128]	; 2281c8 <scalbn+0xe8>
  22814a:	eeb0 0b48 	vmov.f64	d0, d8
  22814e:	ed9d 1b00 	vldr	d1, [sp]
  228152:	f000 f843 	bl	2281dc <copysign>
  228156:	ee20 7b08 	vmul.f64	d7, d0, d8
  22815a:	e7e9      	b.n	228130 <scalbn+0x50>
  22815c:	2a00      	cmp	r2, #0
  22815e:	dd10      	ble.n	228182 <scalbn+0xa2>
  228160:	e9dd 0100 	ldrd	r0, r1, [sp]
  228164:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
  228168:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
  22816c:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
  228170:	e9cd 0100 	strd	r0, r1, [sp]
  228174:	ed9d 0b00 	vldr	d0, [sp]
  228178:	b003      	add	sp, #12
  22817a:	ecbd 8b02 	vpop	{d8}
  22817e:	f85d fb04 	ldr.w	pc, [sp], #4
  228182:	f112 0f35 	cmn.w	r2, #53	; 0x35
  228186:	da06      	bge.n	228196 <scalbn+0xb6>
  228188:	f24c 3350 	movw	r3, #50000	; 0xc350
  22818c:	4298      	cmp	r0, r3
  22818e:	dcda      	bgt.n	228146 <scalbn+0x66>
  228190:	ed9f 8b0b 	vldr	d8, [pc, #44]	; 2281c0 <scalbn+0xe0>
  228194:	e7d9      	b.n	22814a <scalbn+0x6a>
  228196:	e9dd 0100 	ldrd	r0, r1, [sp]
  22819a:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
  22819e:	3236      	adds	r2, #54	; 0x36
  2281a0:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
  2281a4:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
  2281a8:	ec41 0b17 	vmov	d7, r0, r1
  2281ac:	ed9f 6b08 	vldr	d6, [pc, #32]	; 2281d0 <scalbn+0xf0>
  2281b0:	e7b3      	b.n	22811a <scalbn+0x3a>
  2281b2:	bf00      	nop
  2281b4:	f3af 8000 	nop.w
  2281b8:	00000000 	.word	0x00000000
  2281bc:	43500000 	.word	0x43500000
  2281c0:	c2f8f359 	.word	0xc2f8f359
  2281c4:	01a56e1f 	.word	0x01a56e1f
  2281c8:	8800759c 	.word	0x8800759c
  2281cc:	7e37e43c 	.word	0x7e37e43c
  2281d0:	00000000 	.word	0x00000000
  2281d4:	3c900000 	.word	0x3c900000
  2281d8:	ffff3cb0 	.word	0xffff3cb0

002281dc <copysign>:
  2281dc:	ec53 2b10 	vmov	r2, r3, d0
  2281e0:	ee11 0a90 	vmov	r0, s3
  2281e4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
  2281e8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
  2281ec:	ea41 0300 	orr.w	r3, r1, r0
  2281f0:	ec43 2b10 	vmov	d0, r2, r3
  2281f4:	4770      	bx	lr
	...

002281f8 <_init>:
  2281f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  2281fa:	bf00      	nop
  2281fc:	bcf8      	pop	{r3, r4, r5, r6, r7}
  2281fe:	bc08      	pop	{r3}
  228200:	469e      	mov	lr, r3
  228202:	4770      	bx	lr

00228204 <_fini>:
  228204:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  228206:	bf00      	nop
  228208:	bcf8      	pop	{r3, r4, r5, r6, r7}
  22820a:	bc08      	pop	{r3}
  22820c:	469e      	mov	lr, r3
  22820e:	4770      	bx	lr
